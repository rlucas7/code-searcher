[{"idx": "cosqa-train-0", "doc": "python code to write bool value 1", "code": "def writeBoolean(self, n):\n        \"\"\"\n        Writes a Boolean to the stream.\n        \"\"\"\n        t = TYPE_BOOL_TRUE\n\n        if n is False:\n            t = TYPE_BOOL_FALSE\n\n        self.stream.write(t)", "code_tokens": "def writeBoolean ( self , n ) : t = TYPE_BOOL_TRUE if n is False : t = TYPE_BOOL_FALSE self . stream . write ( t )", "docstring_tokens": "Writes a Boolean to the stream .", "label": 0}, {"idx": "cosqa-train-1", "doc": "\"python how to manipulate clipboard\"", "code": "def paste(xsel=False):\n    \"\"\"Returns system clipboard contents.\"\"\"\n    selection = \"primary\" if xsel else \"clipboard\"\n    try:\n        return subprocess.Popen([\"xclip\", \"-selection\", selection, \"-o\"], stdout=subprocess.PIPE).communicate()[0].decode(\"utf-8\")\n    except OSError as why:\n        raise XclipNotFound", "code_tokens": "def paste ( xsel = False ) : selection = \"primary\" if xsel else \"clipboard\" try : return subprocess . Popen ( [ \"xclip\" , \"-selection\" , selection , \"-o\" ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] . decode ( \"utf-8\" ) except OSError as why : raise XclipNotFound", "docstring_tokens": "Returns system clipboard contents .", "label": 0}, {"idx": "cosqa-train-2", "doc": "python colored output to html", "code": "def _format_json(data, theme):\n    \"\"\"Pretty print a dict as a JSON, with colors if pygments is present.\"\"\"\n    output = json.dumps(data, indent=2, sort_keys=True)\n\n    if pygments and sys.stdout.isatty():\n        style = get_style_by_name(theme)\n        formatter = Terminal256Formatter(style=style)\n        return pygments.highlight(output, JsonLexer(), formatter)\n\n    return output", "code_tokens": "def _format_json ( data , theme ) : output = json . dumps ( data , indent = 2 , sort_keys = True ) if pygments and sys . stdout . isatty ( ) : style = get_style_by_name ( theme ) formatter = Terminal256Formatter ( style = style ) return pygments . highlight ( output , JsonLexer ( ) , formatter ) return output", "docstring_tokens": "Pretty print a dict as a JSON with colors if pygments is present .", "label": 0}, {"idx": "cosqa-train-3", "doc": "python \"create directory\" using \"relative path\"", "code": "def create_path(path):\n    \"\"\"Creates a absolute path in the file system.\n\n    :param path: The path to be created\n    \"\"\"\n    import os\n    if not os.path.exists(path):\n        os.makedirs(path)", "code_tokens": "def create_path ( path ) : import os if not os . path . exists ( path ) : os . makedirs ( path )", "docstring_tokens": "Creates a absolute path in the file system .", "label": 0}, {"idx": "cosqa-train-4", "doc": "python column of an array", "code": "def _vector_or_scalar(x, type='row'):\n    \"\"\"Convert an object to either a scalar or a row or column vector.\"\"\"\n    if isinstance(x, (list, tuple)):\n        x = np.array(x)\n    if isinstance(x, np.ndarray):\n        assert x.ndim == 1\n        if type == 'column':\n            x = x[:, None]\n    return x", "code_tokens": "def _vector_or_scalar ( x , type = 'row' ) : if isinstance ( x , ( list , tuple ) ) : x = np . array ( x ) if isinstance ( x , np . ndarray ) : assert x . ndim == 1 if type == 'column' : x = x [ : , None ] return x", "docstring_tokens": "Convert an object to either a scalar or a row or column vector .", "label": 0}, {"idx": "cosqa-train-5", "doc": "python calling a property returns \"property object\"", "code": "def experiment_property(prop):\n    \"\"\"Get a property of the experiment by name.\"\"\"\n    exp = experiment(session)\n    p = getattr(exp, prop)\n    return success_response(field=prop, data=p, request_type=prop)", "code_tokens": "def experiment_property ( prop ) : exp = experiment ( session ) p = getattr ( exp , prop ) return success_response ( field = prop , data = p , request_type = prop )", "docstring_tokens": "Get a property of the experiment by name .", "label": 0}, {"idx": "cosqa-train-6", "doc": "python combine wav file into one as separate channels", "code": "def data_from_file(file):\n    \"\"\"Return (first channel data, sample frequency, sample width) from a .wav\n    file.\"\"\"\n    fp = wave.open(file, 'r')\n    data = fp.readframes(fp.getnframes())\n    channels = fp.getnchannels()\n    freq = fp.getframerate()\n    bits = fp.getsampwidth()\n\n    # Unpack bytes -- warning currently only tested with 16 bit wavefiles. 32\n    # bit not supported.\n    data = struct.unpack(('%sh' % fp.getnframes()) * channels, data)\n\n    # Only use first channel\n    channel1 = []\n    n = 0\n    for d in data:\n        if n % channels == 0:\n            channel1.append(d)\n        n += 1\n    fp.close()\n    return (channel1, freq, bits)", "code_tokens": "def data_from_file ( file ) : fp = wave . open ( file , 'r' ) data = fp . readframes ( fp . getnframes ( ) ) channels = fp . getnchannels ( ) freq = fp . getframerate ( ) bits = fp . getsampwidth ( ) # Unpack bytes -- warning currently only tested with 16 bit wavefiles. 32 # bit not supported. data = struct . unpack ( ( '%sh' % fp . getnframes ( ) ) * channels , data ) # Only use first channel channel1 = [ ] n = 0 for d in data : if n % channels == 0 : channel1 . append ( d ) n += 1 fp . close ( ) return ( channel1 , freq , bits )", "docstring_tokens": "Return ( first channel data sample frequency sample width ) from a . wav file .", "label": 0}, {"idx": "cosqa-train-7", "doc": "+how to use range with a dictionary python", "code": "def source_range(start, end, nr_var_dict):\n    \"\"\"\n    Given a range of source numbers, as well as a dictionary\n    containing the numbers of each source, returns a dictionary\n    containing tuples of the start and end index\n    for each source variable type.\n    \"\"\"\n\n    return OrderedDict((k, e-s)\n        for k, (s, e)\n        in source_range_tuple(start, end, nr_var_dict).iteritems())", "code_tokens": "def source_range ( start , end , nr_var_dict ) : return OrderedDict ( ( k , e - s ) for k , ( s , e ) in source_range_tuple ( start , end , nr_var_dict ) . iteritems ( ) )", "docstring_tokens": "Given a range of source numbers as well as a dictionary containing the numbers of each source returns a dictionary containing tuples of the start and end index for each source variable type .", "label": 0}, {"idx": "cosqa-train-8", "doc": "python compare timespan to number", "code": "def timespan(start_time):\n    \"\"\"Return time in milliseconds from start_time\"\"\"\n\n    timespan = datetime.datetime.now() - start_time\n    timespan_ms = timespan.total_seconds() * 1000\n    return timespan_ms", "code_tokens": "def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms", "docstring_tokens": "Return time in milliseconds from start_time", "label": 0}, {"idx": "cosqa-train-9", "doc": "1d array in char datatype in python", "code": "def _convert_to_array(array_like, dtype):\n        \"\"\"\n        Convert Matrix attributes which are array-like or buffer to array.\n        \"\"\"\n        if isinstance(array_like, bytes):\n            return np.frombuffer(array_like, dtype=dtype)\n        return np.asarray(array_like, dtype=dtype)", "code_tokens": "def _convert_to_array ( array_like , dtype ) : if isinstance ( array_like , bytes ) : return np . frombuffer ( array_like , dtype = dtype ) return np . asarray ( array_like , dtype = dtype )", "docstring_tokens": "Convert Matrix attributes which are array - like or buffer to array .", "label": 1}, {"idx": "cosqa-train-10", "doc": "python comprehension list distinct", "code": "def get_uniques(l):\n    \"\"\" Returns a list with no repeated elements.\n    \"\"\"\n    result = []\n\n    for i in l:\n        if i not in result:\n            result.append(i)\n\n    return result", "code_tokens": "def get_uniques ( l ) : result = [ ] for i in l : if i not in result : result . append ( i ) return result", "docstring_tokens": "Returns a list with no repeated elements .", "label": 0}, {"idx": "cosqa-train-11", "doc": "1d interpolation function python example", "code": "def interp(x, xp, *args, **kwargs):\n    \"\"\"Wrap interpolate_1d for deprecated interp.\"\"\"\n    return interpolate_1d(x, xp, *args, **kwargs)", "code_tokens": "def interp ( x , xp , * args , * * kwargs ) : return interpolate_1d ( x , xp , * args , * * kwargs )", "docstring_tokens": "Wrap interpolate_1d for deprecated interp .", "label": 0}, {"idx": "cosqa-train-12", "doc": "python compress array to string", "code": "def _array2cstr(arr):\n    \"\"\" Serializes a numpy array to a compressed base64 string \"\"\"\n    out = StringIO()\n    np.save(out, arr)\n    return b64encode(out.getvalue())", "code_tokens": "def _array2cstr ( arr ) : out = StringIO ( ) np . save ( out , arr ) return b64encode ( out . getvalue ( ) )", "docstring_tokens": "Serializes a numpy array to a compressed base64 string", "label": 0}, {"idx": "cosqa-train-13", "doc": "25 and 75 percentile of a list python", "code": "def percentile(values, k):\n    \"\"\"Find the percentile of a list of values.\n\n    :param list values: The list of values to find the percentile of\n    :param int k: The percentile to find\n    :rtype: float or int\n\n    \"\"\"\n    if not values:\n        return None\n    values.sort()\n    index = (len(values) * (float(k) / 100)) - 1\n    return values[int(math.ceil(index))]", "code_tokens": "def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]", "docstring_tokens": "Find the percentile of a list of values .", "label": 0}, {"idx": "cosqa-train-14", "doc": "python compute hash of string", "code": "def _string_hash(s):\n    \"\"\"String hash (djb2) with consistency between py2/py3 and persistency between runs (unlike `hash`).\"\"\"\n    h = 5381\n    for c in s:\n        h = h * 33 + ord(c)\n    return h", "code_tokens": "def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h", "docstring_tokens": "String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) .", "label": 0}, {"idx": "cosqa-train-15", "doc": "3d rotatioin matrix in python", "code": "def transform_from_rot_trans(R, t):\n    \"\"\"Transforation matrix from rotation matrix and translation vector.\"\"\"\n    R = R.reshape(3, 3)\n    t = t.reshape(3, 1)\n    return np.vstack((np.hstack([R, t]), [0, 0, 0, 1]))", "code_tokens": "def transform_from_rot_trans ( R , t ) : R = R . reshape ( 3 , 3 ) t = t . reshape ( 3 , 1 ) return np . vstack ( ( np . hstack ( [ R , t ] ) , [ 0 , 0 , 0 , 1 ] ) )", "docstring_tokens": "Transforation matrix from rotation matrix and translation vector .", "label": 0}, {"idx": "cosqa-train-16", "doc": "python concatenate bool to string", "code": "def _encode_bool(name, value, dummy0, dummy1):\n    \"\"\"Encode a python boolean (True/False).\"\"\"\n    return b\"\\x08\" + name + (value and b\"\\x01\" or b\"\\x00\")", "code_tokens": "def _encode_bool ( name , value , dummy0 , dummy1 ) : return b\"\\x08\" + name + ( value and b\"\\x01\" or b\"\\x00\" )", "docstring_tokens": "Encode a python boolean ( True / False ) .", "label": 0}, {"idx": "cosqa-train-17", "doc": "3d rotation in python around z axis", "code": "def transform_to_3d(points,normal,z=0):\n    \"\"\"Project points into 3d from 2d points.\"\"\"\n    d = np.cross(normal, (0, 0, 1))\n    M = rotation_matrix(d)\n    transformed_points = M.dot(points.T).T + z\n    return transformed_points", "code_tokens": "def transform_to_3d ( points , normal , z = 0 ) : d = np . cross ( normal , ( 0 , 0 , 1 ) ) M = rotation_matrix ( d ) transformed_points = M . dot ( points . T ) . T + z return transformed_points", "docstring_tokens": "Project points into 3d from 2d points .", "label": 0}, {"idx": "cosqa-train-18", "doc": "python condition non none", "code": "def _not(condition=None, **kwargs):\n    \"\"\"\n    Return the opposite of input condition.\n\n    :param condition: condition to process.\n\n    :result: not condition.\n    :rtype: bool\n    \"\"\"\n\n    result = True\n\n    if condition is not None:\n        result = not run(condition, **kwargs)\n\n    return result", "code_tokens": "def _not ( condition = None , * * kwargs ) : result = True if condition is not None : result = not run ( condition , * * kwargs ) return result", "docstring_tokens": "Return the opposite of input condition .", "label": 1}, {"idx": "cosqa-train-19", "doc": "403 code from request python", "code": "def HttpResponse403(request, template=KEY_AUTH_403_TEMPLATE,\ncontent=KEY_AUTH_403_CONTENT, content_type=KEY_AUTH_403_CONTENT_TYPE):\n    \"\"\"\n    HTTP response for forbidden access (status code 403)\n    \"\"\"\n    return AccessFailedResponse(request, template, content, content_type, status=403)", "code_tokens": "def HttpResponse403 ( request , template = KEY_AUTH_403_TEMPLATE , content = KEY_AUTH_403_CONTENT , content_type = KEY_AUTH_403_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 403 )", "docstring_tokens": "HTTP response for forbidden access ( status code 403 )", "label": 0}, {"idx": "cosqa-train-20", "doc": "python configparser get keys in section", "code": "def items(self, section_name):\n        \"\"\":return: list((option, value), ...) pairs of all items in the given section\"\"\"\n        return [(k, v) for k, v in super(GitConfigParser, self).items(section_name) if k != '__name__']", "code_tokens": "def items ( self , section_name ) : return [ ( k , v ) for k , v in super ( GitConfigParser , self ) . items ( section_name ) if k != '__name__' ]", "docstring_tokens": ": return : list (( option value ) ... ) pairs of all items in the given section", "label": 0}, {"idx": "cosqa-train-21", "doc": "a array of vector, compute the norm of each vector python", "code": "def mag(z):\n    \"\"\"Get the magnitude of a vector.\"\"\"\n    if isinstance(z[0], np.ndarray):\n        return np.array(list(map(np.linalg.norm, z)))\n    else:\n        return np.linalg.norm(z)", "code_tokens": "def mag ( z ) : if isinstance ( z [ 0 ] , np . ndarray ) : return np . array ( list ( map ( np . linalg . norm , z ) ) ) else : return np . linalg . norm ( z )", "docstring_tokens": "Get the magnitude of a vector .", "label": 0}, {"idx": "cosqa-train-22", "doc": "python configparser transfer dict", "code": "def config_parser_to_dict(config_parser):\n    \"\"\"\n    Convert a ConfigParser to a dictionary.\n    \"\"\"\n    response = {}\n\n    for section in config_parser.sections():\n        for option in config_parser.options(section):\n            response.setdefault(section, {})[option] = config_parser.get(section, option)\n\n    return response", "code_tokens": "def config_parser_to_dict ( config_parser ) : response = { } for section in config_parser . sections ( ) : for option in config_parser . options ( section ) : response . setdefault ( section , { } ) [ option ] = config_parser . get ( section , option ) return response", "docstring_tokens": "Convert a ConfigParser to a dictionary .", "label": 0}, {"idx": "cosqa-train-23", "doc": "a+b in python addition code", "code": "def __add__(self, other):\n        \"\"\"Handle the `+` operator.\"\"\"\n        return self._handle_type(other)(self.value + other.value)", "code_tokens": "def __add__ ( self , other ) : return self . _handle_type ( other ) ( self . value + other . value )", "docstring_tokens": "Handle the + operator .", "label": 0}, {"idx": "cosqa-train-24", "doc": "python connect mysql denied password", "code": "def connect_mysql(host, port, user, password, database):\n    \"\"\"Connect to MySQL with retries.\"\"\"\n    return pymysql.connect(\n        host=host, port=port,\n        user=user, passwd=password,\n        db=database\n    )", "code_tokens": "def connect_mysql ( host , port , user , password , database ) : return pymysql . connect ( host = host , port = port , user = user , passwd = password , db = database )", "docstring_tokens": "Connect to MySQL with retries .", "label": 0}, {"idx": "cosqa-train-25", "doc": "accessing a column from a matrix in python", "code": "def get_column(self, X, column):\n        \"\"\"Return a column of the given matrix.\n\n        Args:\n            X: `numpy.ndarray` or `pandas.DataFrame`.\n            column: `int` or `str`.\n\n        Returns:\n            np.ndarray: Selected column.\n        \"\"\"\n        if isinstance(X, pd.DataFrame):\n            return X[column].values\n\n        return X[:, column]", "code_tokens": "def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]", "docstring_tokens": "Return a column of the given matrix .", "label": 1}, {"idx": "cosqa-train-26", "doc": "python connecting to an api with username and password", "code": "def connect(url, username, password):\n    \"\"\"\n    Return a connected Bitbucket session\n    \"\"\"\n\n    bb_session = stashy.connect(url, username, password)\n\n    logger.info('Connected to: %s as %s', url, username)\n\n    return bb_session", "code_tokens": "def connect ( url , username , password ) : bb_session = stashy . connect ( url , username , password ) logger . info ( 'Connected to: %s as %s' , url , username ) return bb_session", "docstring_tokens": "Return a connected Bitbucket session", "label": 0}, {"idx": "cosqa-train-27", "doc": "add empty series to data frame python", "code": "def add_blank_row(self, label):\n        \"\"\"\n        Add a blank row with only an index value to self.df.\n        This is done inplace.\n        \"\"\"\n        col_labels = self.df.columns\n        blank_item = pd.Series({}, index=col_labels, name=label)\n        # use .loc to add in place (append won't do that)\n        self.df.loc[blank_item.name] = blank_item\n        return self.df", "code_tokens": "def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df", "docstring_tokens": "Add a blank row with only an index value to self . df . This is done inplace .", "label": 0}, {"idx": "cosqa-train-28", "doc": "python container pod stuck in terminating", "code": "def teardown(self):\n        \"\"\"\n        Stop and remove the container if it exists.\n        \"\"\"\n        while self._http_clients:\n            self._http_clients.pop().close()\n        if self.created:\n            self.halt()", "code_tokens": "def teardown ( self ) : while self . _http_clients : self . _http_clients . pop ( ) . close ( ) if self . created : self . halt ( )", "docstring_tokens": "Stop and remove the container if it exists .", "label": 0}, {"idx": "cosqa-train-29", "doc": "add indentations to code in python", "code": "def dumped(text, level, indent=2):\n    \"\"\"Put curly brackets round an indented text\"\"\"\n    return indented(\"{\\n%s\\n}\" % indented(text, level + 1, indent) or \"None\", level, indent) + \"\\n\"", "code_tokens": "def dumped ( text , level , indent = 2 ) : return indented ( \"{\\n%s\\n}\" % indented ( text , level + 1 , indent ) or \"None\" , level , indent ) + \"\\n\"", "docstring_tokens": "Put curly brackets round an indented text", "label": 0}, {"idx": "cosqa-train-30", "doc": "python context manager exit", "code": "def context(self):\n        \"\"\"\n        Create a context manager that ensures code runs within action's context.\n\n        The action does NOT finish when the context is exited.\n        \"\"\"\n        parent = _ACTION_CONTEXT.set(self)\n        try:\n            yield self\n        finally:\n            _ACTION_CONTEXT.reset(parent)", "code_tokens": "def context ( self ) : parent = _ACTION_CONTEXT . set ( self ) try : yield self finally : _ACTION_CONTEXT . reset ( parent )", "docstring_tokens": "Create a context manager that ensures code runs within action s context .", "label": 0}, {"idx": "cosqa-train-31", "doc": "add print depth inpython", "code": "def pformat(object, indent=1, width=80, depth=None):\n    \"\"\"Format a Python object into a pretty-printed representation.\"\"\"\n    return PrettyPrinter(indent=indent, width=width, depth=depth).pformat(object)", "code_tokens": "def pformat ( object , indent = 1 , width = 80 , depth = None ) : return PrettyPrinter ( indent = indent , width = width , depth = depth ) . pformat ( object )", "docstring_tokens": "Format a Python object into a pretty - printed representation .", "label": 0}, {"idx": "cosqa-train-32", "doc": "python contextmanager temperarily set env", "code": "def replace_sys_args(new_args):\n    \"\"\"Temporarily replace sys.argv with current arguments\n\n    Restores sys.argv upon exit of the context manager.\n    \"\"\"\n    # Replace sys.argv arguments\n    # for module import\n    old_args = sys.argv\n    sys.argv = new_args\n    try:\n        yield\n    finally:\n        sys.argv = old_args", "code_tokens": "def replace_sys_args ( new_args ) : # Replace sys.argv arguments # for module import old_args = sys . argv sys . argv = new_args try : yield finally : sys . argv = old_args", "docstring_tokens": "Temporarily replace sys . argv with current arguments", "label": 0}, {"idx": "cosqa-train-33", "doc": "add serializer for type python", "code": "def serialize(obj):\n    \"\"\"Takes a object and produces a dict-like representation\n\n    :param obj: the object to serialize\n    \"\"\"\n    if isinstance(obj, list):\n        return [serialize(o) for o in obj]\n    return GenericSerializer(ModelProviderImpl()).serialize(obj)", "code_tokens": "def serialize ( obj ) : if isinstance ( obj , list ) : return [ serialize ( o ) for o in obj ] return GenericSerializer ( ModelProviderImpl ( ) ) . serialize ( obj )", "docstring_tokens": "Takes a object and produces a dict - like representation", "label": 0}, {"idx": "cosqa-train-34", "doc": "python continuation on next line", "code": "def advance_one_line(self):\n    \"\"\"Advances to next line.\"\"\"\n\n    current_line = self._current_token.line_number\n    while current_line == self._current_token.line_number:\n      self._current_token = ConfigParser.Token(*next(self._token_generator))", "code_tokens": "def advance_one_line ( self ) : current_line = self . _current_token . line_number while current_line == self . _current_token . line_number : self . _current_token = ConfigParser . Token ( * next ( self . _token_generator ) )", "docstring_tokens": "Advances to next line .", "label": 0}, {"idx": "cosqa-train-35", "doc": "add swagger to python django", "code": "def generate_swagger_html(swagger_static_root, swagger_json_url):\n    \"\"\"\n    given a root directory for the swagger statics, and\n    a swagger json path, return back a swagger html designed\n    to use those values.\n    \"\"\"\n    tmpl = _get_template(\"swagger.html\")\n    return tmpl.render(\n        swagger_root=swagger_static_root, swagger_json_url=swagger_json_url\n    )", "code_tokens": "def generate_swagger_html ( swagger_static_root , swagger_json_url ) : tmpl = _get_template ( \"swagger.html\" ) return tmpl . render ( swagger_root = swagger_static_root , swagger_json_url = swagger_json_url )", "docstring_tokens": "given a root directory for the swagger statics and a swagger json path return back a swagger html designed to use those values .", "label": 0}, {"idx": "cosqa-train-36", "doc": "python continue executing the next command", "code": "def do_next(self, args):\n        \"\"\"Step over the next statement\n        \"\"\"\n        self._do_print_from_last_cmd = True\n        self._interp.step_over()\n        return True", "code_tokens": "def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "docstring_tokens": "Step over the next statement", "label": 0}, {"idx": "cosqa-train-37", "doc": "add two matrix with same shape expect one dim python", "code": "def __add__(self,other):\n        \"\"\"\n            If the number of columns matches, we can concatenate two LabeldMatrices\n            with the + operator.\n        \"\"\"\n        assert self.matrix.shape[1] == other.matrix.shape[1]\n        return LabeledMatrix(np.concatenate([self.matrix,other.matrix],axis=0),self.labels)", "code_tokens": "def __add__ ( self , other ) : assert self . matrix . shape [ 1 ] == other . matrix . shape [ 1 ] return LabeledMatrix ( np . concatenate ( [ self . matrix , other . matrix ] , axis = 0 ) , self . labels )", "docstring_tokens": "If the number of columns matches we can concatenate two LabeldMatrices with the + operator .", "label": 0}, {"idx": "cosqa-train-38", "doc": "python contourf interpolation method", "code": "def get_line_flux(line_wave, wave, flux, **kwargs):\n    \"\"\"Interpolated flux at a given wavelength (calls np.interp).\"\"\"\n    return np.interp(line_wave, wave, flux, **kwargs)", "code_tokens": "def get_line_flux ( line_wave , wave , flux , * * kwargs ) : return np . interp ( line_wave , wave , flux , * * kwargs )", "docstring_tokens": "Interpolated flux at a given wavelength ( calls np . interp ) .", "label": 0}, {"idx": "cosqa-train-39", "doc": "add websocket support to python", "code": "def send(message, request_context=None, binary=False):\n    \"\"\"Sends a message to websocket.\n\n    :param str message: data to send\n\n    :param request_context:\n\n    :raises IOError: If unable to send a message.\n    \"\"\"\n    if binary:\n        return uwsgi.websocket_send_binary(message, request_context)\n\n    return uwsgi.websocket_send(message, request_context)", "code_tokens": "def send ( message , request_context = None , binary = False ) : if binary : return uwsgi . websocket_send_binary ( message , request_context ) return uwsgi . websocket_send ( message , request_context )", "docstring_tokens": "Sends a message to websocket .", "label": 0}, {"idx": "cosqa-train-40", "doc": "python conver string to number", "code": "def get_number(s, cast=int):\n    \"\"\"\n    Try to get a number out of a string, and cast it.\n    \"\"\"\n    import string\n    d = \"\".join(x for x in str(s) if x in string.digits)\n    return cast(d)", "code_tokens": "def get_number ( s , cast = int ) : import string d = \"\" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )", "docstring_tokens": "Try to get a number out of a string and cast it .", "label": 0}, {"idx": "cosqa-train-41", "doc": "adding a horxontal line python", "code": "def get_hline():\n    \"\"\" gets a horiztonal line \"\"\"\n    return Window(\n        width=LayoutDimension.exact(1),\n        height=LayoutDimension.exact(1),\n        content=FillControl('-', token=Token.Line))", "code_tokens": "def get_hline ( ) : return Window ( width = LayoutDimension . exact ( 1 ) , height = LayoutDimension . exact ( 1 ) , content = FillControl ( '-' , token = Token . Line ) )", "docstring_tokens": "gets a horiztonal line", "label": 0}, {"idx": "cosqa-train-42", "doc": "python cookies change to dict", "code": "def parse_cookies_str(cookies):\n    \"\"\"\n    parse cookies str to dict\n    :param cookies: cookies str\n    :type cookies: str\n    :return: cookie dict\n    :rtype: dict\n    \"\"\"\n    cookie_dict = {}\n    for record in cookies.split(\";\"):\n        key, value = record.strip().split(\"=\", 1)\n        cookie_dict[key] = value\n    return cookie_dict", "code_tokens": "def parse_cookies_str ( cookies ) : cookie_dict = { } for record in cookies . split ( \";\" ) : key , value = record . strip ( ) . split ( \"=\" , 1 ) cookie_dict [ key ] = value return cookie_dict", "docstring_tokens": "parse cookies str to dict : param cookies : cookies str : type cookies : str : return : cookie dict : rtype : dict", "label": 0}, {"idx": "cosqa-train-43", "doc": "alternate uppercase and lower case in python", "code": "def to_snake_case(name):\n    \"\"\" Given a name in camelCase return in snake_case \"\"\"\n    s1 = FIRST_CAP_REGEX.sub(r'\\1_\\2', name)\n    return ALL_CAP_REGEX.sub(r'\\1_\\2', s1).lower()", "code_tokens": "def to_snake_case ( name ) : s1 = FIRST_CAP_REGEX . sub ( r'\\1_\\2' , name ) return ALL_CAP_REGEX . sub ( r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Given a name in camelCase return in snake_case", "label": 0}, {"idx": "cosqa-train-44", "doc": "python copy a dict to object attributes", "code": "def populate_obj(obj, attrs):\n    \"\"\"Populates an object's attributes using the provided dict\n    \"\"\"\n    for k, v in attrs.iteritems():\n        setattr(obj, k, v)", "code_tokens": "def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "docstring_tokens": "Populates an object s attributes using the provided dict", "label": 0}, {"idx": "cosqa-train-45", "doc": "analyze the frequency of a word using python", "code": "def wordfreq(text, is_filename=False):\n    \"\"\"Return a dictionary of words and word counts in a string.\"\"\"\n    if is_filename:\n        with open(text) as f:\n            text = f.read()\n    freqs = {}\n    for word in text.split():\n        lword = word.lower()\n        freqs[lword] = freqs.get(lword, 0) + 1\n    return freqs", "code_tokens": "def wordfreq ( text , is_filename = False ) : if is_filename : with open ( text ) as f : text = f . read ( ) freqs = { } for word in text . split ( ) : lword = word . lower ( ) freqs [ lword ] = freqs . get ( lword , 0 ) + 1 return freqs", "docstring_tokens": "Return a dictionary of words and word counts in a string .", "label": 0}, {"idx": "cosqa-train-46", "doc": "python copy files effeciently", "code": "def copyFile(input, output, replace=None):\n    \"\"\"Copy a file whole from input to output.\"\"\"\n\n    _found = findFile(output)\n    if not _found or (_found and replace):\n        shutil.copy2(input, output)", "code_tokens": "def copyFile ( input , output , replace = None ) : _found = findFile ( output ) if not _found or ( _found and replace ) : shutil . copy2 ( input , output )", "docstring_tokens": "Copy a file whole from input to output .", "label": 0}, {"idx": "cosqa-train-47", "doc": "append last element of the stack in pythong", "code": "def push(h, x):\n    \"\"\"Push a new value into heap.\"\"\"\n    h.push(x)\n    up(h, h.size()-1)", "code_tokens": "def push ( h , x ) : h . push ( x ) up ( h , h . size ( ) - 1 )", "docstring_tokens": "Push a new value into heap .", "label": 0}, {"idx": "cosqa-train-48", "doc": "python copy paste clipboard drop", "code": "def yank(event):\n    \"\"\"\n    Paste before cursor.\n    \"\"\"\n    event.current_buffer.paste_clipboard_data(\n        event.cli.clipboard.get_data(), count=event.arg, paste_mode=PasteMode.EMACS)", "code_tokens": "def yank ( event ) : event . current_buffer . paste_clipboard_data ( event . cli . clipboard . get_data ( ) , count = event . arg , paste_mode = PasteMode . EMACS )", "docstring_tokens": "Paste before cursor .", "label": 0}, {"idx": "cosqa-train-49", "doc": "apply a filter to an image python", "code": "def filter_contour(imageFile, opFile):\n    \"\"\" convert an image by applying a contour \"\"\"\n    im = Image.open(imageFile)\n    im1 = im.filter(ImageFilter.CONTOUR)\n    im1.save(opFile)", "code_tokens": "def filter_contour ( imageFile , opFile ) : im = Image . open ( imageFile ) im1 = im . filter ( ImageFilter . CONTOUR ) im1 . save ( opFile )", "docstring_tokens": "convert an image by applying a contour", "label": 0}, {"idx": "cosqa-train-50", "doc": "python count number of words in each sentence", "code": "def count(lines):\n  \"\"\" Counts the word frequences in a list of sentences.\n\n  Note:\n    This is a helper function for parallel execution of `Vocabulary.from_text`\n    method.\n  \"\"\"\n  words = [w for l in lines for w in l.strip().split()]\n  return Counter(words)", "code_tokens": "def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )", "docstring_tokens": "Counts the word frequences in a list of sentences .", "label": 0}, {"idx": "cosqa-train-51", "doc": "apply a function to dictionary python", "code": "def dictapply(d, fn):\n    \"\"\"\n    apply a function to all non-dict values in a dictionary\n    \"\"\"\n    for k, v in d.items():\n        if isinstance(v, dict):\n            v = dictapply(v, fn)\n        else:\n            d[k] = fn(v)\n    return d", "code_tokens": "def dictapply ( d , fn ) : for k , v in d . items ( ) : if isinstance ( v , dict ) : v = dictapply ( v , fn ) else : d [ k ] = fn ( v ) return d", "docstring_tokens": "apply a function to all non - dict values in a dictionary", "label": 0}, {"idx": "cosqa-train-52", "doc": "python count partitions of a number", "code": "def count_replica(self, partition):\n        \"\"\"Return count of replicas of given partition.\"\"\"\n        return sum(1 for b in partition.replicas if b in self.brokers)", "code_tokens": "def count_replica ( self , partition ) : return sum ( 1 for b in partition . replicas if b in self . brokers )", "docstring_tokens": "Return count of replicas of given partition .", "label": 0}, {"idx": "cosqa-train-53", "doc": "apply range to method python", "code": "def visit_Name(self, node):\n        \"\"\" Get range for parameters for examples or false branching. \"\"\"\n        return self.add(node, self.result[node.id])", "code_tokens": "def visit_Name ( self , node ) : return self . add ( node , self . result [ node . id ] )", "docstring_tokens": "Get range for parameters for examples or false branching .", "label": 0}, {"idx": "cosqa-train-54", "doc": "python creat a dir", "code": "def mkdir(dir, enter):\n    \"\"\"Create directory with template for topic of the current environment\n\n    \"\"\"\n\n    if not os.path.exists(dir):\n        os.makedirs(dir)", "code_tokens": "def mkdir ( dir , enter ) : if not os . path . exists ( dir ) : os . makedirs ( dir )", "docstring_tokens": "Create directory with template for topic of the current environment", "label": 0}, {"idx": "cosqa-train-55", "doc": "apply rotation on vector along a axis python", "code": "def qrot(vector, quaternion):\n    \"\"\"Rotate a 3D vector using quaternion algebra.\n\n    Implemented by Vladimir Kulikovskiy.\n\n    Parameters\n    ----------\n    vector: np.array\n    quaternion: np.array\n\n    Returns\n    -------\n    np.array\n\n    \"\"\"\n    t = 2 * np.cross(quaternion[1:], vector)\n    v_rot = vector + quaternion[0] * t + np.cross(quaternion[1:], t)\n    return v_rot", "code_tokens": "def qrot ( vector , quaternion ) : t = 2 * np . cross ( quaternion [ 1 : ] , vector ) v_rot = vector + quaternion [ 0 ] * t + np . cross ( quaternion [ 1 : ] , t ) return v_rot", "docstring_tokens": "Rotate a 3D vector using quaternion algebra .", "label": 0}, {"idx": "cosqa-train-56", "doc": "python create a numpy of chars", "code": "def _numpy_char_to_bytes(arr):\n    \"\"\"Like netCDF4.chartostring, but faster and more flexible.\n    \"\"\"\n    # based on: http://stackoverflow.com/a/10984878/809705\n    arr = np.array(arr, copy=False, order='C')\n    dtype = 'S' + str(arr.shape[-1])\n    return arr.view(dtype).reshape(arr.shape[:-1])", "code_tokens": "def _numpy_char_to_bytes ( arr ) : # based on: http://stackoverflow.com/a/10984878/809705 arr = np . array ( arr , copy = False , order = 'C' ) dtype = 'S' + str ( arr . shape [ - 1 ] ) return arr . view ( dtype ) . reshape ( arr . shape [ : - 1 ] )", "docstring_tokens": "Like netCDF4 . chartostring but faster and more flexible .", "label": 0}, {"idx": "cosqa-train-57", "doc": "are python strings hashable", "code": "def _string_hash(s):\n    \"\"\"String hash (djb2) with consistency between py2/py3 and persistency between runs (unlike `hash`).\"\"\"\n    h = 5381\n    for c in s:\n        h = h * 33 + ord(c)\n    return h", "code_tokens": "def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h", "docstring_tokens": "String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) .", "label": 1}, {"idx": "cosqa-train-58", "doc": "python create list of dictionary from csv file no key", "code": "def csv_to_dicts(file, header=None):\n    \"\"\"Reads a csv and returns a List of Dicts with keys given by header row.\"\"\"\n    with open(file) as csvfile:\n        return [row for row in csv.DictReader(csvfile, fieldnames=header)]", "code_tokens": "def csv_to_dicts ( file , header = None ) : with open ( file ) as csvfile : return [ row for row in csv . DictReader ( csvfile , fieldnames = header ) ]", "docstring_tokens": "Reads a csv and returns a List of Dicts with keys given by header row .", "label": 0}, {"idx": "cosqa-train-59", "doc": "area of a triangle python function", "code": "def get_tri_area(pts):\n    \"\"\"\n    Given a list of coords for 3 points,\n    Compute the area of this triangle.\n\n    Args:\n        pts: [a, b, c] three points\n    \"\"\"\n    a, b, c = pts[0], pts[1], pts[2]\n    v1 = np.array(b) - np.array(a)\n    v2 = np.array(c) - np.array(a)\n    area_tri = abs(sp.linalg.norm(sp.cross(v1, v2)) / 2)\n    return area_tri", "code_tokens": "def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri", "docstring_tokens": "Given a list of coords for 3 points Compute the area of this triangle .", "label": 0}, {"idx": "cosqa-train-60", "doc": "python create numpy onehot", "code": "def one_hot(x, size, dtype=np.float32):\n  \"\"\"Make a n+1 dim one-hot array from n dim int-categorical array.\"\"\"\n  return np.array(x[..., np.newaxis] == np.arange(size), dtype)", "code_tokens": "def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )", "docstring_tokens": "Make a n + 1 dim one - hot array from n dim int - categorical array .", "label": 0}, {"idx": "cosqa-train-61", "doc": "around to precision python", "code": "def round_to_int(number, precision):\n    \"\"\"Round a number to a precision\"\"\"\n    precision = int(precision)\n    rounded = (int(number) + precision / 2) // precision * precision\n    return rounded", "code_tokens": "def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded", "docstring_tokens": "Round a number to a precision", "label": 0}, {"idx": "cosqa-train-62", "doc": "ascii character representation in python 3", "code": "def to_unicode_repr( _letter ):\n    \"\"\" helpful in situations where browser/app may recognize Unicode encoding\n        in the \\u0b8e type syntax but not actual unicode glyph/code-point\"\"\"\n    # Python 2-3 compatible\n    return u\"u'\"+ u\"\".join( [ u\"\\\\u%04x\"%ord(l) for l in _letter ] ) + u\"'\"", "code_tokens": "def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u\"u'\" + u\"\" . join ( [ u\"\\\\u%04x\" % ord ( l ) for l in _letter ] ) + u\"'\"", "docstring_tokens": "helpful in situations where browser / app may recognize Unicode encoding in the \\ u0b8e type syntax but not actual unicode glyph / code - point", "label": 0}, {"idx": "cosqa-train-63", "doc": "python create path pathlib create directory", "code": "def create_path(path):\n    \"\"\"Creates a absolute path in the file system.\n\n    :param path: The path to be created\n    \"\"\"\n    import os\n    if not os.path.exists(path):\n        os.makedirs(path)", "code_tokens": "def create_path ( path ) : import os if not os . path . exists ( path ) : os . makedirs ( path )", "docstring_tokens": "Creates a absolute path in the file system .", "label": 0}, {"idx": "cosqa-train-64", "doc": "ask any python 3 question", "code": "def string_input(prompt=''):\n    \"\"\"Python 3 input()/Python 2 raw_input()\"\"\"\n    v = sys.version[0]\n    if v == '3':\n        return input(prompt)\n    else:\n        return raw_input(prompt)", "code_tokens": "def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )", "docstring_tokens": "Python 3 input () / Python 2 raw_input ()", "label": 0}, {"idx": "cosqa-train-65", "doc": "python create pointer ctypes array", "code": "def cfloat64_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes double pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_double)):\n        return np.fromiter(cptr, dtype=np.float64, count=length)\n    else:\n        raise RuntimeError('Expected double pointer')", "code_tokens": "def cfloat64_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_double ) ) : return np . fromiter ( cptr , dtype = np . float64 , count = length ) else : raise RuntimeError ( 'Expected double pointer' )", "docstring_tokens": "Convert a ctypes double pointer array to a numpy array .", "label": 0}, {"idx": "cosqa-train-66", "doc": "asking user yes or no in python", "code": "def yn_prompt(msg, default=True):\n    \"\"\"\n    Prompts the user for yes or no.\n    \"\"\"\n    ret = custom_prompt(msg, [\"y\", \"n\"], \"y\" if default else \"n\")\n    if ret == \"y\":\n        return True\n    return False", "code_tokens": "def yn_prompt ( msg , default = True ) : ret = custom_prompt ( msg , [ \"y\" , \"n\" ] , \"y\" if default else \"n\" ) if ret == \"y\" : return True return False", "docstring_tokens": "Prompts the user for yes or no .", "label": 0}, {"idx": "cosqa-train-67", "doc": "python create print text in grid", "code": "def _display(self, layout):\n        \"\"\"launch layouts display\"\"\"\n        print(file=self.out)\n        TextWriter().format(layout, self.out)", "code_tokens": "def _display ( self , layout ) : print ( file = self . out ) TextWriter ( ) . format ( layout , self . out )", "docstring_tokens": "launch layouts display", "label": 0}, {"idx": "cosqa-train-68", "doc": "assert based on part of string in a list python", "code": "def assert_list(self, putative_list, expected_type=string_types, key_arg=None):\n    \"\"\"\n    :API: public\n    \"\"\"\n    return assert_list(putative_list, expected_type, key_arg=key_arg,\n                       raise_type=lambda msg: TargetDefinitionException(self, msg))", "code_tokens": "def assert_list ( self , putative_list , expected_type = string_types , key_arg = None ) : return assert_list ( putative_list , expected_type , key_arg = key_arg , raise_type = lambda msg : TargetDefinitionException ( self , msg ) )", "docstring_tokens": ": API : public", "label": 0}, {"idx": "cosqa-train-69", "doc": "assure all true of a list of boolean python", "code": "def assert_exactly_one_true(bool_list):\n    \"\"\"This method asserts that only one value of the provided list is True.\n\n    :param bool_list: List of booleans to check\n    :return: True if only one value is True, False otherwise\n    \"\"\"\n    assert isinstance(bool_list, list)\n    counter = 0\n    for item in bool_list:\n        if item:\n            counter += 1\n    return counter == 1", "code_tokens": "def assert_exactly_one_true ( bool_list ) : assert isinstance ( bool_list , list ) counter = 0 for item in bool_list : if item : counter += 1 return counter == 1", "docstring_tokens": "This method asserts that only one value of the provided list is True .", "label": 1}, {"idx": "cosqa-train-70", "doc": "python create unique 5 letter id", "code": "def _get_random_id():\n    \"\"\" Get a random (i.e., unique) string identifier\"\"\"\n    symbols = string.ascii_uppercase + string.ascii_lowercase + string.digits\n    return ''.join(random.choice(symbols) for _ in range(15))", "code_tokens": "def _get_random_id ( ) : symbols = string . ascii_uppercase + string . ascii_lowercase + string . digits return '' . join ( random . choice ( symbols ) for _ in range ( 15 ) )", "docstring_tokens": "Get a random ( i . e . unique ) string identifier", "label": 0}, {"idx": "cosqa-train-71", "doc": "async list comprehension python", "code": "async def list(source):\n    \"\"\"Generate a single list from an asynchronous sequence.\"\"\"\n    result = []\n    async with streamcontext(source) as streamer:\n        async for item in streamer:\n            result.append(item)\n    yield result", "code_tokens": "async def list ( source ) : result = [ ] async with streamcontext ( source ) as streamer : async for item in streamer : result . append ( item ) yield result", "docstring_tokens": "Generate a single list from an asynchronous sequence .", "label": 0}, {"idx": "cosqa-train-72", "doc": "attr dot notation python", "code": "def _attrprint(d, delimiter=', '):\n    \"\"\"Print a dictionary of attributes in the DOT format\"\"\"\n    return delimiter.join(('\"%s\"=\"%s\"' % item) for item in sorted(d.items()))", "code_tokens": "def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '\"%s\"=\"%s\"' % item ) for item in sorted ( d . items ( ) ) )", "docstring_tokens": "Print a dictionary of attributes in the DOT format", "label": 0}, {"idx": "cosqa-train-73", "doc": "python croniter sigle question", "code": "def get_next_scheduled_time(cron_string):\n    \"\"\"Calculate the next scheduled time by creating a crontab object\n    with a cron string\"\"\"\n    itr = croniter.croniter(cron_string, datetime.utcnow())\n    return itr.get_next(datetime)", "code_tokens": "def get_next_scheduled_time ( cron_string ) : itr = croniter . croniter ( cron_string , datetime . utcnow ( ) ) return itr . get_next ( datetime )", "docstring_tokens": "Calculate the next scheduled time by creating a crontab object with a cron string", "label": 0}, {"idx": "cosqa-train-74", "doc": "autoexit python shell after script executed", "code": "def exit(exit_code=0):\n  r\"\"\"A function to support exiting from exit hooks.\n\n  Could also be used to exit from the calling scripts in a thread safe manner.\n  \"\"\"\n  core.processExitHooks()\n\n  if state.isExitHooked and not hasattr(sys, 'exitfunc'): # The function is called from the exit hook\n    sys.stderr.flush()\n    sys.stdout.flush()\n    os._exit(exit_code) #pylint: disable=W0212\n\n  sys.exit(exit_code)", "code_tokens": "def exit ( exit_code = 0 ) : core . processExitHooks ( ) if state . isExitHooked and not hasattr ( sys , 'exitfunc' ) : # The function is called from the exit hook sys . stderr . flush ( ) sys . stdout . flush ( ) os . _exit ( exit_code ) #pylint: disable=W0212 sys . exit ( exit_code )", "docstring_tokens": "r A function to support exiting from exit hooks .", "label": 0}, {"idx": "cosqa-train-75", "doc": "python cross product of two vectors", "code": "def dot_product(self, other):\n        \"\"\" Return the dot product of the given vectors. \"\"\"\n        return self.x * other.x + self.y * other.y", "code_tokens": "def dot_product ( self , other ) : return self . x * other . x + self . y * other . y", "docstring_tokens": "Return the dot product of the given vectors .", "label": 0}, {"idx": "cosqa-train-76", "doc": "automatically restart python program after crash", "code": "def reloader_thread(softexit=False):\n    \"\"\"If ``soft_exit`` is True, we use sys.exit(); otherwise ``os_exit``\n    will be used to end the process.\n    \"\"\"\n    while RUN_RELOADER:\n        if code_changed():\n            # force reload\n            if softexit:\n                sys.exit(3)\n            else:\n                os._exit(3)\n        time.sleep(1)", "code_tokens": "def reloader_thread ( softexit = False ) : while RUN_RELOADER : if code_changed ( ) : # force reload if softexit : sys . exit ( 3 ) else : os . _exit ( 3 ) time . sleep ( 1 )", "docstring_tokens": "If soft_exit is True we use sys . exit () ; otherwise os_exit will be used to end the process .", "label": 0}, {"idx": "cosqa-train-77", "doc": "python csv with comma in string", "code": "def list_to_csv(value):\n    \"\"\"\n    Converts list to string with comma separated values. For string is no-op.\n    \"\"\"\n    if isinstance(value, (list, tuple, set)):\n        value = \",\".join(value)\n    return value", "code_tokens": "def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = \",\" . join ( value ) return value", "docstring_tokens": "Converts list to string with comma separated values . For string is no - op .", "label": 0}, {"idx": "cosqa-train-78", "doc": "average time python takes to run a for loop", "code": "def average(iterator):\n    \"\"\"Iterative mean.\"\"\"\n    count = 0\n    total = 0\n    for num in iterator:\n        count += 1\n        total += num\n    return float(total)/count", "code_tokens": "def average ( iterator ) : count = 0 total = 0 for num in iterator : count += 1 total += num return float ( total ) / count", "docstring_tokens": "Iterative mean .", "label": 0}, {"idx": "cosqa-train-79", "doc": "python ctypes array int", "code": "def cint32_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes int pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_int32)):\n        return np.fromiter(cptr, dtype=np.int32, count=length)\n    else:\n        raise RuntimeError('Expected int pointer')", "code_tokens": "def cint32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int32 ) ) : return np . fromiter ( cptr , dtype = np . int32 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "docstring_tokens": "Convert a ctypes int pointer array to a numpy array .", "label": 0}, {"idx": "cosqa-train-80", "doc": "aws python boto3 list all ec2 with tags", "code": "def _aws_get_instance_by_tag(region, name, tag, raw):\n    \"\"\"Get all instances matching a tag.\"\"\"\n    client = boto3.session.Session().client('ec2', region)\n    matching_reservations = client.describe_instances(Filters=[{'Name': tag, 'Values': [name]}]).get('Reservations', [])\n    instances = []\n    [[instances.append(_aws_instance_from_dict(region, instance, raw))  # pylint: disable=expression-not-assigned\n      for instance in reservation.get('Instances')] for reservation in matching_reservations if reservation]\n    return instances", "code_tokens": "def _aws_get_instance_by_tag ( region , name , tag , raw ) : client = boto3 . session . Session ( ) . client ( 'ec2' , region ) matching_reservations = client . describe_instances ( Filters = [ { 'Name' : tag , 'Values' : [ name ] } ] ) . get ( 'Reservations' , [ ] ) instances = [ ] [ [ instances . append ( _aws_instance_from_dict ( region , instance , raw ) ) # pylint: disable=expression-not-assigned for instance in reservation . get ( 'Instances' ) ] for reservation in matching_reservations if reservation ] return instances", "docstring_tokens": "Get all instances matching a tag .", "label": 0}, {"idx": "cosqa-train-81", "doc": "python ctypes array to pointer", "code": "def cfloat64_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes double pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_double)):\n        return np.fromiter(cptr, dtype=np.float64, count=length)\n    else:\n        raise RuntimeError('Expected double pointer')", "code_tokens": "def cfloat64_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_double ) ) : return np . fromiter ( cptr , dtype = np . float64 , count = length ) else : raise RuntimeError ( 'Expected double pointer' )", "docstring_tokens": "Convert a ctypes double pointer array to a numpy array .", "label": 1}, {"idx": "cosqa-train-82", "doc": "azure python use cli session", "code": "def loganalytics_data_plane_client(cli_ctx, _):\n    \"\"\"Initialize Log Analytics data client for use with CLI.\"\"\"\n    from .vendored_sdks.loganalytics import LogAnalyticsDataClient\n    from azure.cli.core._profile import Profile\n    profile = Profile(cli_ctx=cli_ctx)\n    cred, _, _ = profile.get_login_credentials(\n        resource=\"https://api.loganalytics.io\")\n    return LogAnalyticsDataClient(cred)", "code_tokens": "def loganalytics_data_plane_client ( cli_ctx , _ ) : from . vendored_sdks . loganalytics import LogAnalyticsDataClient from azure . cli . core . _profile import Profile profile = Profile ( cli_ctx = cli_ctx ) cred , _ , _ = profile . get_login_credentials ( resource = \"https://api.loganalytics.io\" ) return LogAnalyticsDataClient ( cred )", "docstring_tokens": "Initialize Log Analytics data client for use with CLI .", "label": 0}, {"idx": "cosqa-train-83", "doc": "python ctypes make float string", "code": "def cfloat32_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes float pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_float)):\n        return np.fromiter(cptr, dtype=np.float32, count=length)\n    else:\n        raise RuntimeError('Expected float pointer')", "code_tokens": "def cfloat32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_float ) ) : return np . fromiter ( cptr , dtype = np . float32 , count = length ) else : raise RuntimeError ( 'Expected float pointer' )", "docstring_tokens": "Convert a ctypes float pointer array to a numpy array .", "label": 0}, {"idx": "cosqa-train-84", "doc": "before after underscore python", "code": "def underscore(text):\n    \"\"\"Converts text that may be camelcased into an underscored format\"\"\"\n    return UNDERSCORE[1].sub(r'\\1_\\2', UNDERSCORE[0].sub(r'\\1_\\2', text)).lower()", "code_tokens": "def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\\1_\\2' , UNDERSCORE [ 0 ] . sub ( r'\\1_\\2' , text ) ) . lower ( )", "docstring_tokens": "Converts text that may be camelcased into an underscored format", "label": 0}, {"idx": "cosqa-train-85", "doc": "python ctypes pointer from int", "code": "def cint8_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes int pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)):\n        return np.fromiter(cptr, dtype=np.int8, count=length)\n    else:\n        raise RuntimeError('Expected int pointer')", "code_tokens": "def cint8_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int8 ) ) : return np . fromiter ( cptr , dtype = np . int8 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "docstring_tokens": "Convert a ctypes int pointer array to a numpy array .", "label": 0}, {"idx": "cosqa-train-86", "doc": "best stopword list for python", "code": "def get_stoplist(language):\n    \"\"\"Returns an built-in stop-list for the language as a set of words.\"\"\"\n    file_path = os.path.join(\"stoplists\", \"%s.txt\" % language)\n    try:\n        stopwords = pkgutil.get_data(\"justext\", file_path)\n    except IOError:\n        raise ValueError(\n            \"Stoplist for language '%s' is missing. \"\n            \"Please use function 'get_stoplists' for complete list of stoplists \"\n            \"and feel free to contribute by your own stoplist.\" % language\n        )\n\n    return frozenset(w.decode(\"utf8\").lower() for w in stopwords.splitlines())", "code_tokens": "def get_stoplist ( language ) : file_path = os . path . join ( \"stoplists\" , \"%s.txt\" % language ) try : stopwords = pkgutil . get_data ( \"justext\" , file_path ) except IOError : raise ValueError ( \"Stoplist for language '%s' is missing. \" \"Please use function 'get_stoplists' for complete list of stoplists \" \"and feel free to contribute by your own stoplist.\" % language ) return frozenset ( w . decode ( \"utf8\" ) . lower ( ) for w in stopwords . splitlines ( ) )", "docstring_tokens": "Returns an built - in stop - list for the language as a set of words .", "label": 0}, {"idx": "cosqa-train-87", "doc": "python curses addstr returned err", "code": "def add_str(window, line_num, str):\n    \"\"\" attempt to draw str on screen and ignore errors if they occur \"\"\"\n    try:\n        window.addstr(line_num, 0, str)\n    except curses.error:\n        pass", "code_tokens": "def add_str ( window , line_num , str ) : try : window . addstr ( line_num , 0 , str ) except curses . error : pass", "docstring_tokens": "attempt to draw str on screen and ignore errors if they occur", "label": 0}, {"idx": "cosqa-train-88", "doc": "best way to give file path in python", "code": "def relative_path(path):\n    \"\"\"\n    Return the given path relative to this file.\n    \"\"\"\n    return os.path.join(os.path.dirname(__file__), path)", "code_tokens": "def relative_path ( path ) : return os . path . join ( os . path . dirname ( __file__ ) , path )", "docstring_tokens": "Return the given path relative to this file .", "label": 1}, {"idx": "cosqa-train-89", "doc": "python cursor fetchall field name", "code": "def dictfetchall(cursor):\n    \"\"\"Returns all rows from a cursor as a dict (rather than a headerless table)\n\n    From Django Documentation: https://docs.djangoproject.com/en/dev/topics/db/sql/\n    \"\"\"\n    desc = cursor.description\n    return [dict(zip([col[0] for col in desc], row)) for row in cursor.fetchall()]", "code_tokens": "def dictfetchall ( cursor ) : desc = cursor . description return [ dict ( zip ( [ col [ 0 ] for col in desc ] , row ) ) for row in cursor . fetchall ( ) ]", "docstring_tokens": "Returns all rows from a cursor as a dict ( rather than a headerless table )", "label": 0}, {"idx": "cosqa-train-90", "doc": "best way to parse xml files in python", "code": "def xmltreefromfile(filename):\n    \"\"\"Internal function to read an XML file\"\"\"\n    try:\n        return ElementTree.parse(filename, ElementTree.XMLParser(collect_ids=False))\n    except TypeError:\n        return ElementTree.parse(filename, ElementTree.XMLParser())", "code_tokens": "def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )", "docstring_tokens": "Internal function to read an XML file", "label": 0}, {"idx": "cosqa-train-91", "doc": "python cursor fetchone to dictionary", "code": "def _dictfetchall(self, cursor):\n        \"\"\" Return all rows from a cursor as a dict. \"\"\"\n        columns = [col[0] for col in cursor.description]\n        return [\n            dict(zip(columns, row))\n            for row in cursor.fetchall()\n        ]", "code_tokens": "def _dictfetchall ( self , cursor ) : columns = [ col [ 0 ] for col in cursor . description ] return [ dict ( zip ( columns , row ) ) for row in cursor . fetchall ( ) ]", "docstring_tokens": "Return all rows from a cursor as a dict .", "label": 0}, {"idx": "cosqa-train-92", "doc": "beta distribution function graph in python", "code": "def beta_pdf(x, a, b):\n  \"\"\"Beta distirbution probability density function.\"\"\"\n  bc = 1 / beta(a, b)\n  fc = x ** (a - 1)\n  sc = (1 - x) ** (b - 1)\n  return bc * fc * sc", "code_tokens": "def beta_pdf ( x , a , b ) : bc = 1 / beta ( a , b ) fc = x ** ( a - 1 ) sc = ( 1 - x ) ** ( b - 1 ) return bc * fc * sc", "docstring_tokens": "Beta distirbution probability density function .", "label": 0}, {"idx": "cosqa-train-93", "doc": "python custom filter based on extra", "code": "def filter_out(queryset, setting_name):\n  \"\"\"\n  Remove unwanted results from queryset\n  \"\"\"\n  kwargs = helpers.get_settings().get(setting_name, {}).get('FILTER_OUT', {})\n  queryset = queryset.exclude(**kwargs)\n  return queryset", "code_tokens": "def filter_out ( queryset , setting_name ) : kwargs = helpers . get_settings ( ) . get ( setting_name , { } ) . get ( 'FILTER_OUT' , { } ) queryset = queryset . exclude ( * * kwargs ) return queryset", "docstring_tokens": "Remove unwanted results from queryset", "label": 0}, {"idx": "cosqa-train-94", "doc": "bin as 8 digits python", "code": "def intToBin(i):\n    \"\"\" Integer to two bytes \"\"\"\n    # divide in two parts (bytes)\n    i1 = i % 256\n    i2 = int(i / 256)\n    # make string (little endian)\n    return i.to_bytes(2, byteorder='little')", "code_tokens": "def intToBin ( i ) : # divide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return i . to_bytes ( 2 , byteorder = 'little' )", "docstring_tokens": "Integer to two bytes", "label": 0}, {"idx": "cosqa-train-95", "doc": "python custom object nonetype", "code": "def listlike(obj):\n    \"\"\"Is an object iterable like a list (and not a string)?\"\"\"\n    \n    return hasattr(obj, \"__iter__\") \\\n    and not issubclass(type(obj), str)\\\n    and not issubclass(type(obj), unicode)", "code_tokens": "def listlike ( obj ) : return hasattr ( obj , \"__iter__\" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )", "docstring_tokens": "Is an object iterable like a list ( and not a string ) ?", "label": 0}, {"idx": "cosqa-train-96", "doc": "bottom 5 rows in python", "code": "def table_top_abs(self):\n        \"\"\"Returns the absolute position of table top\"\"\"\n        table_height = np.array([0, 0, self.table_full_size[2]])\n        return string_to_array(self.floor.get(\"pos\")) + table_height", "code_tokens": "def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( \"pos\" ) ) + table_height", "docstring_tokens": "Returns the absolute position of table top", "label": 1}, {"idx": "cosqa-train-97", "doc": "python custom probability distribution", "code": "def pdf(x, mu, std):\n    \"\"\"Probability density function (normal distribution)\"\"\"\n    return (1.0 / (std * sqrt(2 * pi))) * np.exp(-(x - mu) ** 2 / (2 * std ** 2))", "code_tokens": "def pdf ( x , mu , std ) : return ( 1.0 / ( std * sqrt ( 2 * pi ) ) ) * np . exp ( - ( x - mu ) ** 2 / ( 2 * std ** 2 ) )", "docstring_tokens": "Probability density function ( normal distribution )", "label": 0}, {"idx": "cosqa-train-98", "doc": "c style array to python", "code": "def bytes_to_c_array(data):\n    \"\"\"\n    Make a C array using the given string.\n    \"\"\"\n    chars = [\n        \"'{}'\".format(encode_escape(i))\n        for i in decode_escape(data)\n    ]\n    return ', '.join(chars) + ', 0'", "code_tokens": "def bytes_to_c_array ( data ) : chars = [ \"'{}'\" . format ( encode_escape ( i ) ) for i in decode_escape ( data ) ] return ', ' . join ( chars ) + ', 0'", "docstring_tokens": "Make a C array using the given string .", "label": 0}, {"idx": "cosqa-train-99", "doc": "python cv2 np array to gray scale", "code": "def gray2bgr(img):\n    \"\"\"Convert a grayscale image to BGR image.\n\n    Args:\n        img (ndarray or str): The input image.\n\n    Returns:\n        ndarray: The converted BGR image.\n    \"\"\"\n    img = img[..., None] if img.ndim == 2 else img\n    out_img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n    return out_img", "code_tokens": "def gray2bgr ( img ) : img = img [ ... , None ] if img . ndim == 2 else img out_img = cv2 . cvtColor ( img , cv2 . COLOR_GRAY2BGR ) return out_img", "docstring_tokens": "Convert a grayscale image to BGR image .", "label": 1}, {"idx": "cosqa-train-100", "doc": "calculate average value over datetime python", "code": "def mean_date(dt_list):\n    \"\"\"Calcuate mean datetime from datetime list\n    \"\"\"\n    dt_list_sort = sorted(dt_list)\n    dt_list_sort_rel = [dt - dt_list_sort[0] for dt in dt_list_sort]\n    avg_timedelta = sum(dt_list_sort_rel, timedelta())/len(dt_list_sort_rel)\n    return dt_list_sort[0] + avg_timedelta", "code_tokens": "def mean_date ( dt_list ) : dt_list_sort = sorted ( dt_list ) dt_list_sort_rel = [ dt - dt_list_sort [ 0 ] for dt in dt_list_sort ] avg_timedelta = sum ( dt_list_sort_rel , timedelta ( ) ) / len ( dt_list_sort_rel ) return dt_list_sort [ 0 ] + avg_timedelta", "docstring_tokens": "Calcuate mean datetime from datetime list", "label": 0}, {"idx": "cosqa-train-101", "doc": "python cv2 rotate image", "code": "def rotate_img(im, deg, mode=cv2.BORDER_CONSTANT, interpolation=cv2.INTER_AREA):\n    \"\"\" Rotates an image by deg degrees\n\n    Arguments:\n        deg (float): degree to rotate.\n    \"\"\"\n    r,c,*_ = im.shape\n    M = cv2.getRotationMatrix2D((c//2,r//2),deg,1)\n    return cv2.warpAffine(im,M,(c,r), borderMode=mode, flags=cv2.WARP_FILL_OUTLIERS+interpolation)", "code_tokens": "def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )", "docstring_tokens": "Rotates an image by deg degrees", "label": 0}, {"idx": "cosqa-train-102", "doc": "calculate cosine similarity between two document vectors python", "code": "def similarity(self, other):\n        \"\"\"Calculates the cosine similarity between this vector and another\n        vector.\"\"\"\n        if self.magnitude == 0 or other.magnitude == 0:\n            return 0\n\n        return self.dot(other) / self.magnitude", "code_tokens": "def similarity ( self , other ) : if self . magnitude == 0 or other . magnitude == 0 : return 0 return self . dot ( other ) / self . magnitude", "docstring_tokens": "Calculates the cosine similarity between this vector and another vector .", "label": 0}, {"idx": "cosqa-train-103", "doc": "python cv2 rotate image 90 degrees", "code": "def rotate_img(im, deg, mode=cv2.BORDER_CONSTANT, interpolation=cv2.INTER_AREA):\n    \"\"\" Rotates an image by deg degrees\n\n    Arguments:\n        deg (float): degree to rotate.\n    \"\"\"\n    r,c,*_ = im.shape\n    M = cv2.getRotationMatrix2D((c//2,r//2),deg,1)\n    return cv2.warpAffine(im,M,(c,r), borderMode=mode, flags=cv2.WARP_FILL_OUTLIERS+interpolation)", "code_tokens": "def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )", "docstring_tokens": "Rotates an image by deg degrees", "label": 1}, {"idx": "cosqa-train-104", "doc": "calculate distance between two coorinates python", "code": "def _calculate_distance(latlon1, latlon2):\n    \"\"\"Calculates the distance between two points on earth.\n    \"\"\"\n    lat1, lon1 = latlon1\n    lat2, lon2 = latlon2\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    R = 6371  # radius of the earth in kilometers\n    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * (np.sin(dlon / 2))**2\n    c = 2 * np.pi * R * np.arctan2(np.sqrt(a), np.sqrt(1 - a)) / 180\n    return c", "code_tokens": "def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c", "docstring_tokens": "Calculates the distance between two points on earth .", "label": 1}, {"idx": "cosqa-train-105", "doc": "python cv2 show image in same window", "code": "def screen_cv2(self):\n        \"\"\"cv2 Image of current window screen\"\"\"\n        pil_image = self.screen.convert('RGB')\n        cv2_image = np.array(pil_image)\n        pil_image.close()\n        # Convert RGB to BGR \n        cv2_image = cv2_image[:, :, ::-1]\n        return cv2_image", "code_tokens": "def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR \n cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image", "docstring_tokens": "cv2 Image of current window screen", "label": 0}, {"idx": "cosqa-train-106", "doc": "calculate distance between two points on a map on python", "code": "def direct2dDistance(self, point):\n        \"\"\"consider the distance between two mapPoints, ignoring all terrain, pathing issues\"\"\"\n        if not isinstance(point, MapPoint): return 0.0\n        return  ((self.x-point.x)**2 + (self.y-point.y)**2)**(0.5) # simple distance formula", "code_tokens": "def direct2dDistance ( self , point ) : if not isinstance ( point , MapPoint ) : return 0.0 return ( ( self . x - point . x ) ** 2 + ( self . y - point . y ) ** 2 ) ** ( 0.5 ) # simple distance formula", "docstring_tokens": "consider the distance between two mapPoints ignoring all terrain pathing issues", "label": 0}, {"idx": "cosqa-train-107", "doc": "python cycle through each column name that is obejct type and show the unique values in each", "code": "def _model_unique(ins):\n    \"\"\" Get unique constraints info\n\n    :type ins: sqlalchemy.orm.mapper.Mapper\n    :rtype: list[tuple[str]]\n    \"\"\"\n    unique = []\n    for t in ins.tables:\n        for c in t.constraints:\n            if isinstance(c, UniqueConstraint):\n                unique.append(tuple(col.key for col in c.columns))\n    return unique", "code_tokens": "def _model_unique ( ins ) : unique = [ ] for t in ins . tables : for c in t . constraints : if isinstance ( c , UniqueConstraint ) : unique . append ( tuple ( col . key for col in c . columns ) ) return unique", "docstring_tokens": "Get unique constraints info", "label": 0}, {"idx": "cosqa-train-108", "doc": "calculate dpi of image python", "code": "def horz_dpi(self):\n        \"\"\"\n        Integer dots per inch for the width of this image. Defaults to 72\n        when not present in the file, as is often the case.\n        \"\"\"\n        pHYs = self._chunks.pHYs\n        if pHYs is None:\n            return 72\n        return self._dpi(pHYs.units_specifier, pHYs.horz_px_per_unit)", "code_tokens": "def horz_dpi ( self ) : pHYs = self . _chunks . pHYs if pHYs is None : return 72 return self . _dpi ( pHYs . units_specifier , pHYs . horz_px_per_unit )", "docstring_tokens": "Integer dots per inch for the width of this image . Defaults to 72 when not present in the file as is often the case .", "label": 0}, {"idx": "cosqa-train-109", "doc": "python date parser without format", "code": "def parse(self, s):\n        \"\"\"\n        Parses a date string formatted like ``YYYY-MM-DD``.\n        \"\"\"\n        return datetime.datetime.strptime(s, self.date_format).date()", "code_tokens": "def parse ( self , s ) : return datetime . datetime . strptime ( s , self . date_format ) . date ( )", "docstring_tokens": "Parses a date string formatted like YYYY - MM - DD .", "label": 1}, {"idx": "cosqa-train-110", "doc": "calculate time complexity in python", "code": "def estimate_complexity(self, x,y,z,n):\n        \"\"\" \n        calculates a rough guess of runtime based on product of parameters \n        \"\"\"\n        num_calculations = x * y * z * n\n        run_time = num_calculations / 100000  # a 2014 PC does about 100k calcs in a second (guess based on prior logs)\n        return self.show_time_as_short_string(run_time)", "code_tokens": "def estimate_complexity ( self , x , y , z , n ) : num_calculations = x * y * z * n run_time = num_calculations / 100000 # a 2014 PC does about 100k calcs in a second (guess based on prior logs) return self . show_time_as_short_string ( run_time )", "docstring_tokens": "calculates a rough guess of runtime based on product of parameters", "label": 0}, {"idx": "cosqa-train-111", "doc": "python date plus one week", "code": "def weekly(date=datetime.date.today()):\n    \"\"\"\n    Weeks start are fixes at Monday for now.\n    \"\"\"\n    return date - datetime.timedelta(days=date.weekday())", "code_tokens": "def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )", "docstring_tokens": "Weeks start are fixes at Monday for now .", "label": 0}, {"idx": "cosqa-train-112", "doc": "calculateinverse of a matrix in python", "code": "def inh(table):\n    \"\"\"\n    inverse hyperbolic sine transformation\n    \"\"\"\n    t = []\n    for i in table:\n        t.append(np.ndarray.tolist(np.arcsinh(i)))\n    return t", "code_tokens": "def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "docstring_tokens": "inverse hyperbolic sine transformation", "label": 0}, {"idx": "cosqa-train-113", "doc": "python date range iterator", "code": "def daterange(start, end, delta=timedelta(days=1), lower=Interval.CLOSED, upper=Interval.OPEN):\n    \"\"\"Returns a generator which creates the next value in the range on demand\"\"\"\n    date_interval = Interval(lower=lower, lower_value=start, upper_value=end, upper=upper)\n    current = start if start in date_interval else start + delta\n    while current in date_interval:\n        yield current\n        current = current + delta", "code_tokens": "def daterange ( start , end , delta = timedelta ( days = 1 ) , lower = Interval . CLOSED , upper = Interval . OPEN ) : date_interval = Interval ( lower = lower , lower_value = start , upper_value = end , upper = upper ) current = start if start in date_interval else start + delta while current in date_interval : yield current current = current + delta", "docstring_tokens": "Returns a generator which creates the next value in the range on demand", "label": 0}, {"idx": "cosqa-train-114", "doc": "call async function in python from another thread", "code": "async def _thread_coro(self, *args):\n        \"\"\" Coroutine called by MapAsync. It's wrapping the call of\n        run_in_executor to run the synchronous function as thread \"\"\"\n        return await self._loop.run_in_executor(\n            self._executor, self._function, *args)", "code_tokens": "async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "docstring_tokens": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread", "label": 0}, {"idx": "cosqa-train-115", "doc": "python dateime adjust date by month", "code": "def start_of_month(val):\n    \"\"\"\n    Return a new datetime.datetime object with values that represent\n    a start of a month.\n    :param val: Date to ...\n    :type val: datetime.datetime | datetime.date\n    :rtype: datetime.datetime\n    \"\"\"\n    if type(val) == date:\n        val = datetime.fromordinal(val.toordinal())\n    return start_of_day(val).replace(day=1)", "code_tokens": "def start_of_month ( val ) : if type ( val ) == date : val = datetime . fromordinal ( val . toordinal ( ) ) return start_of_day ( val ) . replace ( day = 1 )", "docstring_tokens": "Return a new datetime . datetime object with values that represent a start of a month . : param val : Date to ... : type val : datetime . datetime | datetime . date : rtype : datetime . datetime", "label": 0}, {"idx": "cosqa-train-116", "doc": "call external command and get output from python", "code": "def check_output(args, env=None, sp=subprocess):\n    \"\"\"Call an external binary and return its stdout.\"\"\"\n    log.debug('calling %s with env %s', args, env)\n    output = sp.check_output(args=args, env=env)\n    log.debug('output: %r', output)\n    return output", "code_tokens": "def check_output ( args , env = None , sp = subprocess ) : log . debug ( 'calling %s with env %s' , args , env ) output = sp . check_output ( args = args , env = env ) log . debug ( 'output: %r' , output ) return output", "docstring_tokens": "Call an external binary and return its stdout .", "label": 0}, {"idx": "cosqa-train-117", "doc": "python datetime calculate millisec", "code": "def datetime_to_ms(dt):\n    \"\"\"\n    Converts a datetime to a millisecond accuracy timestamp\n    \"\"\"\n    seconds = calendar.timegm(dt.utctimetuple())\n    return seconds * 1000 + int(dt.microsecond / 1000)", "code_tokens": "def datetime_to_ms ( dt ) : seconds = calendar . timegm ( dt . utctimetuple ( ) ) return seconds * 1000 + int ( dt . microsecond / 1000 )", "docstring_tokens": "Converts a datetime to a millisecond accuracy timestamp", "label": 0}, {"idx": "cosqa-train-118", "doc": "call function in the try condition python", "code": "def retry_on_signal(function):\n    \"\"\"Retries function until it doesn't raise an EINTR error\"\"\"\n    while True:\n        try:\n            return function()\n        except EnvironmentError, e:\n            if e.errno != errno.EINTR:\n                raise", "code_tokens": "def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise", "docstring_tokens": "Retries function until it doesn t raise an EINTR error", "label": 0}, {"idx": "cosqa-train-119", "doc": "python datetime covert to timezone", "code": "def datetime_to_timezone(date, tz=\"UTC\"):\n    \"\"\" convert naive datetime to timezone-aware datetime \"\"\"\n    if not date.tzinfo:\n        date = date.replace(tzinfo=timezone(get_timezone()))\n    return date.astimezone(timezone(tz))", "code_tokens": "def datetime_to_timezone ( date , tz = \"UTC\" ) : if not date . tzinfo : date = date . replace ( tzinfo = timezone ( get_timezone ( ) ) ) return date . astimezone ( timezone ( tz ) )", "docstring_tokens": "convert naive datetime to timezone - aware datetime", "label": 0}, {"idx": "cosqa-train-120", "doc": "call python tests from robotframework", "code": "def test(*args):\n    \"\"\"\n    Run unit tests.\n    \"\"\"\n    subprocess.call([\"py.test-2.7\"] + list(args))\n    subprocess.call([\"py.test-3.4\"] + list(args))", "code_tokens": "def test ( * args ) : subprocess . call ( [ \"py.test-2.7\" ] + list ( args ) ) subprocess . call ( [ \"py.test-3.4\" ] + list ( args ) )", "docstring_tokens": "Run unit tests .", "label": 0}, {"idx": "cosqa-train-121", "doc": "python datetime drop microseconds", "code": "def ToDatetime(self):\n    \"\"\"Converts Timestamp to datetime.\"\"\"\n    return datetime.utcfromtimestamp(\n        self.seconds + self.nanos / float(_NANOS_PER_SECOND))", "code_tokens": "def ToDatetime ( self ) : return datetime . utcfromtimestamp ( self . seconds + self . nanos / float ( _NANOS_PER_SECOND ) )", "docstring_tokens": "Converts Timestamp to datetime .", "label": 0}, {"idx": "cosqa-train-122", "doc": "callable title objects in python", "code": "def sortable_title(instance):\n    \"\"\"Uses the default Plone sortable_text index lower-case\n    \"\"\"\n    title = plone_sortable_title(instance)\n    if safe_callable(title):\n        title = title()\n    return title.lower()", "code_tokens": "def sortable_title ( instance ) : title = plone_sortable_title ( instance ) if safe_callable ( title ) : title = title ( ) return title . lower ( )", "docstring_tokens": "Uses the default Plone sortable_text index lower - case", "label": 1}, {"idx": "cosqa-train-123", "doc": "python datetime get local time zone", "code": "def localize(dt):\n    \"\"\"Localize a datetime object to local time.\"\"\"\n    if dt.tzinfo is UTC:\n        return (dt + LOCAL_UTC_OFFSET).replace(tzinfo=None)\n    # No TZ info so not going to assume anything, return as-is.\n    return dt", "code_tokens": "def localize ( dt ) : if dt . tzinfo is UTC : return ( dt + LOCAL_UTC_OFFSET ) . replace ( tzinfo = None ) # No TZ info so not going to assume anything, return as-is. return dt", "docstring_tokens": "Localize a datetime object to local time .", "label": 0}, {"idx": "cosqa-train-124", "doc": "callbacks for progress bars in python", "code": "def percent_cb(name, complete, total):\n    \"\"\" Callback for updating target progress \"\"\"\n    logger.debug(\n        \"{}: {} transferred out of {}\".format(\n            name, sizeof_fmt(complete), sizeof_fmt(total)\n        )\n    )\n    progress.update_target(name, complete, total)", "code_tokens": "def percent_cb ( name , complete , total ) : logger . debug ( \"{}: {} transferred out of {}\" . format ( name , sizeof_fmt ( complete ) , sizeof_fmt ( total ) ) ) progress . update_target ( name , complete , total )", "docstring_tokens": "Callback for updating target progress", "label": 0}, {"idx": "cosqa-train-125", "doc": "python datetime has no attribute utcnow", "code": "def now(self):\n\t\t\"\"\"\n\t\tReturn a :py:class:`datetime.datetime` instance representing the current time.\n\n\t\t:rtype: :py:class:`datetime.datetime`\n\t\t\"\"\"\n\t\tif self.use_utc:\n\t\t\treturn datetime.datetime.utcnow()\n\t\telse:\n\t\t\treturn datetime.datetime.now()", "code_tokens": "def now ( self ) : if self . use_utc : return datetime . datetime . utcnow ( ) else : return datetime . datetime . now ( )", "docstring_tokens": "Return a : py : class : datetime . datetime instance representing the current time .", "label": 0}, {"idx": "cosqa-train-126", "doc": "camel case to upper and underscore python", "code": "def to_pascal_case(s):\n    \"\"\"Transform underscore separated string to pascal case\n\n    \"\"\"\n    return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())", "code_tokens": "def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )", "docstring_tokens": "Transform underscore separated string to pascal case", "label": 0}, {"idx": "cosqa-train-127", "doc": "python datetime now as timezone", "code": "def now(self):\n\t\t\"\"\"\n\t\tReturn a :py:class:`datetime.datetime` instance representing the current time.\n\n\t\t:rtype: :py:class:`datetime.datetime`\n\t\t\"\"\"\n\t\tif self.use_utc:\n\t\t\treturn datetime.datetime.utcnow()\n\t\telse:\n\t\t\treturn datetime.datetime.now()", "code_tokens": "def now ( self ) : if self . use_utc : return datetime . datetime . utcnow ( ) else : return datetime . datetime . now ( )", "docstring_tokens": "Return a : py : class : datetime . datetime instance representing the current time .", "label": 0}, {"idx": "cosqa-train-128", "doc": "can a datetime object be a dictionary key python 3", "code": "def _convert_date_to_dict(field_date):\n        \"\"\"\n        Convert native python ``datetime.date`` object  to a format supported by the API\n        \"\"\"\n        return {DAY: field_date.day, MONTH: field_date.month, YEAR: field_date.year}", "code_tokens": "def _convert_date_to_dict ( field_date ) : return { DAY : field_date . day , MONTH : field_date . month , YEAR : field_date . year }", "docstring_tokens": "Convert native python datetime . date object to a format supported by the API", "label": 0}, {"idx": "cosqa-train-129", "doc": "python datetime round microseconds as object", "code": "def ToDatetime(self):\n    \"\"\"Converts Timestamp to datetime.\"\"\"\n    return datetime.utcfromtimestamp(\n        self.seconds + self.nanos / float(_NANOS_PER_SECOND))", "code_tokens": "def ToDatetime ( self ) : return datetime . utcfromtimestamp ( self . seconds + self . nanos / float ( _NANOS_PER_SECOND ) )", "docstring_tokens": "Converts Timestamp to datetime .", "label": 0}, {"idx": "cosqa-train-130", "doc": "can i change an arraylist to a list in python", "code": "def convert_array(array):\n    \"\"\"\n    Converts an ARRAY string stored in the database back into a Numpy array.\n\n    Parameters\n    ----------\n    array: ARRAY\n        The array object to be converted back into a Numpy array.\n\n    Returns\n    -------\n    array\n            The converted Numpy array.\n\n    \"\"\"\n    out = io.BytesIO(array)\n    out.seek(0)\n    return np.load(out)", "code_tokens": "def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )", "docstring_tokens": "Converts an ARRAY string stored in the database back into a Numpy array .", "label": 0}, {"idx": "cosqa-train-131", "doc": "python datetime timezone iso", "code": "def parse_timestamp(timestamp):\n    \"\"\"Parse ISO8601 timestamps given by github API.\"\"\"\n    dt = dateutil.parser.parse(timestamp)\n    return dt.astimezone(dateutil.tz.tzutc())", "code_tokens": "def parse_timestamp ( timestamp ) : dt = dateutil . parser . parse ( timestamp ) return dt . astimezone ( dateutil . tz . tzutc ( ) )", "docstring_tokens": "Parse ISO8601 timestamps given by github API .", "label": 0}, {"idx": "cosqa-train-132", "doc": "can i use javascript in python", "code": "def add_to_js(self, name, var):\n        \"\"\"Add an object to Javascript.\"\"\"\n        frame = self.page().mainFrame()\n        frame.addToJavaScriptWindowObject(name, var)", "code_tokens": "def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )", "docstring_tokens": "Add an object to Javascript .", "label": 0}, {"idx": "cosqa-train-133", "doc": "python datetime utcfromtimestamp local time zone", "code": "def fromtimestamp(cls, timestamp):\n    \"\"\"Returns a datetime object of a given timestamp (in local tz).\"\"\"\n    d = cls.utcfromtimestamp(timestamp)\n    return d.astimezone(localtz())", "code_tokens": "def fromtimestamp ( cls , timestamp ) : d = cls . utcfromtimestamp ( timestamp ) return d . astimezone ( localtz ( ) )", "docstring_tokens": "Returns a datetime object of a given timestamp ( in local tz ) .", "label": 0}, {"idx": "cosqa-train-134", "doc": "can latex compile documents from python code", "code": "def print_latex(o):\n    \"\"\"A function to generate the latex representation of sympy\n    expressions.\"\"\"\n    if can_print_latex(o):\n        s = latex(o, mode='plain')\n        s = s.replace('\\\\dag','\\\\dagger')\n        s = s.strip('$')\n        return '$$%s$$' % s\n    # Fallback to the string printer\n    return None", "code_tokens": "def print_latex ( o ) : if can_print_latex ( o ) : s = latex ( o , mode = 'plain' ) s = s . replace ( '\\\\dag' , '\\\\dagger' ) s = s . strip ( '$' ) return '$$%s$$' % s # Fallback to the string printer return None", "docstring_tokens": "A function to generate the latex representation of sympy expressions .", "label": 0}, {"idx": "cosqa-train-135", "doc": "python datetime64 ns separate", "code": "def datetime64_to_datetime(dt):\n    \"\"\" convert numpy's datetime64 to datetime \"\"\"\n    dt64 = np.datetime64(dt)\n    ts = (dt64 - np.datetime64('1970-01-01T00:00:00')) / np.timedelta64(1, 's')\n    return datetime.datetime.utcfromtimestamp(ts)", "code_tokens": "def datetime64_to_datetime ( dt ) : dt64 = np . datetime64 ( dt ) ts = ( dt64 - np . datetime64 ( '1970-01-01T00:00:00' ) ) / np . timedelta64 ( 1 , 's' ) return datetime . datetime . utcfromtimestamp ( ts )", "docstring_tokens": "convert numpy s datetime64 to datetime", "label": 0}, {"idx": "cosqa-train-136", "doc": "can python merge with tensorflow", "code": "def batch_tensor(self, name):\n        \"\"\" A buffer of a given value in a 'flat' (minibatch-indexed) format \"\"\"\n        if name in self.transition_tensors:\n            return tensor_util.merge_first_two_dims(self.transition_tensors[name])\n        else:\n            return self.rollout_tensors[name]", "code_tokens": "def batch_tensor ( self , name ) : if name in self . transition_tensors : return tensor_util . merge_first_two_dims ( self . transition_tensors [ name ] ) else : return self . rollout_tensors [ name ]", "docstring_tokens": "A buffer of a given value in a flat ( minibatch - indexed ) format", "label": 0}, {"idx": "cosqa-train-137", "doc": "python decide interactive mode", "code": "def isInteractive():\n    \"\"\"\n    A basic check of if the program is running in interactive mode\n    \"\"\"\n    if sys.stdout.isatty() and os.name != 'nt':\n        #Hopefully everything but ms supports '\\r'\n        try:\n            import threading\n        except ImportError:\n            return False\n        else:\n            return True\n    else:\n        return False", "code_tokens": "def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\\r' try : import threading except ImportError : return False else : return True else : return False", "docstring_tokens": "A basic check of if the program is running in interactive mode", "label": 0}, {"idx": "cosqa-train-138", "doc": "can python open windows symbolic links", "code": "def create_symlink(source, link_name):\n    \"\"\"\n    Creates symbolic link for either operating system.\n\n    http://stackoverflow.com/questions/6260149/os-symlink-support-in-windows\n    \"\"\"\n    os_symlink = getattr(os, \"symlink\", None)\n    if isinstance(os_symlink, collections.Callable):\n        os_symlink(source, link_name)\n    else:\n        import ctypes\n        csl = ctypes.windll.kernel32.CreateSymbolicLinkW\n        csl.argtypes = (ctypes.c_wchar_p, ctypes.c_wchar_p, ctypes.c_uint32)\n        csl.restype = ctypes.c_ubyte\n        flags = 1 if os.path.isdir(source) else 0\n        if csl(link_name, source, flags) == 0:\n            raise ctypes.WinError()", "code_tokens": "def create_symlink ( source , link_name ) : os_symlink = getattr ( os , \"symlink\" , None ) if isinstance ( os_symlink , collections . Callable ) : os_symlink ( source , link_name ) else : import ctypes csl = ctypes . windll . kernel32 . CreateSymbolicLinkW csl . argtypes = ( ctypes . c_wchar_p , ctypes . c_wchar_p , ctypes . c_uint32 ) csl . restype = ctypes . c_ubyte flags = 1 if os . path . isdir ( source ) else 0 if csl ( link_name , source , flags ) == 0 : raise ctypes . WinError ( )", "docstring_tokens": "Creates symbolic link for either operating system . http : // stackoverflow . com / questions / 6260149 / os - symlink - support - in - windows", "label": 0}, {"idx": "cosqa-train-139", "doc": "python decorate builtin methods", "code": "def export(defn):\n    \"\"\"Decorator to explicitly mark functions that are exposed in a lib.\"\"\"\n    globals()[defn.__name__] = defn\n    __all__.append(defn.__name__)\n    return defn", "code_tokens": "def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "docstring_tokens": "Decorator to explicitly mark functions that are exposed in a lib .", "label": 0}, {"idx": "cosqa-train-140", "doc": "can python xml parser parse comments", "code": "def parse(source, remove_comments=True, **kw):\n    \"\"\"Thin wrapper around ElementTree.parse\"\"\"\n    return ElementTree.parse(source, SourceLineParser(), **kw)", "code_tokens": "def parse ( source , remove_comments = True , * * kw ) : return ElementTree . parse ( source , SourceLineParser ( ) , * * kw )", "docstring_tokens": "Thin wrapper around ElementTree . parse", "label": 0}, {"idx": "cosqa-train-141", "doc": "python decorate function with optional", "code": "def decorator(func):\n  r\"\"\"Makes the passed decorators to support optional args.\n  \"\"\"\n  def wrapper(__decorated__=None, *Args, **KwArgs):\n    if __decorated__ is None: # the decorator has some optional arguments.\n      return lambda _func: func(_func, *Args, **KwArgs)\n\n    else:\n      return func(__decorated__, *Args, **KwArgs)\n\n  return wrap(wrapper, func)", "code_tokens": "def decorator ( func ) : def wrapper ( __decorated__ = None , * Args , * * KwArgs ) : if __decorated__ is None : # the decorator has some optional arguments. return lambda _func : func ( _func , * Args , * * KwArgs ) else : return func ( __decorated__ , * Args , * * KwArgs ) return wrap ( wrapper , func )", "docstring_tokens": "r Makes the passed decorators to support optional args .", "label": 0}, {"idx": "cosqa-train-142", "doc": "can we access img in django python", "code": "def show_image(self, key):\n        \"\"\"Show image (item is a PIL image)\"\"\"\n        data = self.model.get_data()\n        data[key].show()", "code_tokens": "def show_image ( self , key ) : data = self . model . get_data ( ) data [ key ] . show ( )", "docstring_tokens": "Show image ( item is a PIL image )", "label": 1}, {"idx": "cosqa-train-143", "doc": "python default input values for a function", "code": "def get_default_args(func):\n    \"\"\"\n    returns a dictionary of arg_name:default_values for the input function\n    \"\"\"\n    args, varargs, keywords, defaults = getargspec_no_self(func)\n    return dict(zip(args[-len(defaults):], defaults))", "code_tokens": "def get_default_args ( func ) : args , varargs , keywords , defaults = getargspec_no_self ( func ) return dict ( zip ( args [ - len ( defaults ) : ] , defaults ) )", "docstring_tokens": "returns a dictionary of arg_name : default_values for the input function", "label": 0}, {"idx": "cosqa-train-144", "doc": "can you create an array with different intervals in python", "code": "def _interval_to_bound_points(array):\n    \"\"\"\n    Helper function which returns an array\n    with the Intervals' boundaries.\n    \"\"\"\n\n    array_boundaries = np.array([x.left for x in array])\n    array_boundaries = np.concatenate(\n        (array_boundaries, np.array([array[-1].right])))\n\n    return array_boundaries", "code_tokens": "def _interval_to_bound_points ( array ) : array_boundaries = np . array ( [ x . left for x in array ] ) array_boundaries = np . concatenate ( ( array_boundaries , np . array ( [ array [ - 1 ] . right ] ) ) ) return array_boundaries", "docstring_tokens": "Helper function which returns an array with the Intervals boundaries .", "label": 0}, {"idx": "cosqa-train-145", "doc": "python delay before closing a popup", "code": "def closing_plugin(self, cancelable=False):\n        \"\"\"Perform actions before parent main window is closed\"\"\"\n        self.dialog_manager.close_all()\n        self.shell.exit_interpreter()\n        return True", "code_tokens": "def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True", "docstring_tokens": "Perform actions before parent main window is closed", "label": 0}, {"idx": "cosqa-train-146", "doc": "can you make a gui in spyder using python", "code": "def test():        \n    \"\"\"Local test.\"\"\"\n    from spyder.utils.qthelpers import qapplication\n    app = qapplication()\n    dlg = ProjectDialog(None)\n    dlg.show()\n    sys.exit(app.exec_())", "code_tokens": "def test ( ) : from spyder . utils . qthelpers import qapplication app = qapplication ( ) dlg = ProjectDialog ( None ) dlg . show ( ) sys . exit ( app . exec_ ( ) )", "docstring_tokens": "Local test .", "label": 0}, {"idx": "cosqa-train-147", "doc": "python delete a label", "code": "def del_label(self, name):\n        \"\"\"Delete a label by name.\"\"\"\n        labels_tag = self.root[0]\n        labels_tag.remove(self._find_label(name))", "code_tokens": "def del_label ( self , name ) : labels_tag = self . root [ 0 ] labels_tag . remove ( self . _find_label ( name ) )", "docstring_tokens": "Delete a label by name .", "label": 0}, {"idx": "cosqa-train-148", "doc": "capitalize an arguement in python", "code": "def mixedcase(path):\n    \"\"\"Removes underscores and capitalizes the neighbouring character\"\"\"\n    words = path.split('_')\n    return words[0] + ''.join(word.title() for word in words[1:])", "code_tokens": "def mixedcase ( path ) : words = path . split ( '_' ) return words [ 0 ] + '' . join ( word . title ( ) for word in words [ 1 : ] )", "docstring_tokens": "Removes underscores and capitalizes the neighbouring character", "label": 0}, {"idx": "cosqa-train-149", "doc": "python delete egg file", "code": "def delete_all_eggs(self):\n        \"\"\" delete all the eggs in the directory specified \"\"\"\n        path_to_delete = os.path.join(self.egg_directory, \"lib\", \"python\")\n        if os.path.exists(path_to_delete):\n            shutil.rmtree(path_to_delete)", "code_tokens": "def delete_all_eggs ( self ) : path_to_delete = os . path . join ( self . egg_directory , \"lib\" , \"python\" ) if os . path . exists ( path_to_delete ) : shutil . rmtree ( path_to_delete )", "docstring_tokens": "delete all the eggs in the directory specified", "label": 0}, {"idx": "cosqa-train-150", "doc": "capture the cpu utilisation by using python", "code": "def get_system_cpu_times():\n    \"\"\"Return system CPU times as a namedtuple.\"\"\"\n    user, nice, system, idle = _psutil_osx.get_system_cpu_times()\n    return _cputimes_ntuple(user, nice, system, idle)", "code_tokens": "def get_system_cpu_times ( ) : user , nice , system , idle = _psutil_osx . get_system_cpu_times ( ) return _cputimes_ntuple ( user , nice , system , idle )", "docstring_tokens": "Return system CPU times as a namedtuple .", "label": 0}, {"idx": "cosqa-train-151", "doc": "python delete solr doc", "code": "def remove(self, document_id, namespace, timestamp):\n        \"\"\"Removes documents from Solr\n\n        The input is a python dictionary that represents a mongo document.\n        \"\"\"\n        self.solr.delete(id=u(document_id),\n                         commit=(self.auto_commit_interval == 0))", "code_tokens": "def remove ( self , document_id , namespace , timestamp ) : self . solr . delete ( id = u ( document_id ) , commit = ( self . auto_commit_interval == 0 ) )", "docstring_tokens": "Removes documents from Solr", "label": 0}, {"idx": "cosqa-train-152", "doc": "cast hash to string python", "code": "def update_hash_from_str(hsh, str_input):\n    \"\"\"\n    Convert a str to object supporting buffer API and update a hash with it.\n    \"\"\"\n    byte_input = str(str_input).encode(\"UTF-8\")\n    hsh.update(byte_input)", "code_tokens": "def update_hash_from_str ( hsh , str_input ) : byte_input = str ( str_input ) . encode ( \"UTF-8\" ) hsh . update ( byte_input )", "docstring_tokens": "Convert a str to object supporting buffer API and update a hash with it .", "label": 0}, {"idx": "cosqa-train-153", "doc": "python delimit for regular expression", "code": "def make_regex(separator):\n    \"\"\"Utility function to create regexp for matching escaped separators\n    in strings.\n\n    \"\"\"\n    return re.compile(r'(?:' + re.escape(separator) + r')?((?:[^' +\n                      re.escape(separator) + r'\\\\]|\\\\.)+)')", "code_tokens": "def make_regex ( separator ) : return re . compile ( r'(?:' + re . escape ( separator ) + r')?((?:[^' + re . escape ( separator ) + r'\\\\]|\\\\.)+)' )", "docstring_tokens": "Utility function to create regexp for matching escaped separators in strings .", "label": 0}, {"idx": "cosqa-train-154", "doc": "cast nametuple to dictionary python", "code": "def dictify(a_named_tuple):\n    \"\"\"Transform a named tuple into a dictionary\"\"\"\n    return dict((s, getattr(a_named_tuple, s)) for s in a_named_tuple._fields)", "code_tokens": "def dictify ( a_named_tuple ) : return dict ( ( s , getattr ( a_named_tuple , s ) ) for s in a_named_tuple . _fields )", "docstring_tokens": "Transform a named tuple into a dictionary", "label": 0}, {"idx": "cosqa-train-155", "doc": "python delimited join strings", "code": "def _py2_and_3_joiner(sep, joinable):\n    \"\"\"\n    Allow '\\n'.join(...) statements to work in Py2 and Py3.\n    :param sep:\n    :param joinable:\n    :return:\n    \"\"\"\n    if ISPY3:\n        sep = bytes(sep, DEFAULT_ENCODING)\n    joined = sep.join(joinable)\n    return joined.decode(DEFAULT_ENCODING) if ISPY3 else joined", "code_tokens": "def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "docstring_tokens": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return :", "label": 0}, {"idx": "cosqa-train-156", "doc": "cast python string to c string", "code": "def c_str(string):\n    \"\"\"\"Convert a python string to C string.\"\"\"\n    if not isinstance(string, str):\n        string = string.decode('ascii')\n    return ctypes.c_char_p(string.encode('utf-8'))", "code_tokens": "def c_str ( string ) : if not isinstance ( string , str ) : string = string . decode ( 'ascii' ) return ctypes . c_char_p ( string . encode ( 'utf-8' ) )", "docstring_tokens": "Convert a python string to C string .", "label": 0}, {"idx": "cosqa-train-157", "doc": "python delimiter check for a file", "code": "def endline_semicolon_check(self, original, loc, tokens):\n        \"\"\"Check for semicolons at the end of lines.\"\"\"\n        return self.check_strict(\"semicolon at end of line\", original, loc, tokens)", "code_tokens": "def endline_semicolon_check ( self , original , loc , tokens ) : return self . check_strict ( \"semicolon at end of line\" , original , loc , tokens )", "docstring_tokens": "Check for semicolons at the end of lines .", "label": 0}, {"idx": "cosqa-train-158", "doc": "cast to datetime object python", "code": "def _datetime_to_date(arg):\n    \"\"\"\n    convert datetime/str to date\n    :param arg:\n    :return:\n    \"\"\"\n    _arg = parse(arg)\n    if isinstance(_arg, datetime.datetime):\n        _arg = _arg.date()\n    return _arg", "code_tokens": "def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "docstring_tokens": "convert datetime / str to date : param arg : : return :", "label": 0}, {"idx": "cosqa-train-159", "doc": "python deque pop block empty", "code": "def get(self):\n        \"\"\"Get the highest priority Processing Block from the queue.\"\"\"\n        with self._mutex:\n            entry = self._queue.pop()\n            del self._block_map[entry[2]]\n            return entry[2]", "code_tokens": "def get ( self ) : with self . _mutex : entry = self . _queue . pop ( ) del self . _block_map [ entry [ 2 ] ] return entry [ 2 ]", "docstring_tokens": "Get the highest priority Processing Block from the queue .", "label": 0}, {"idx": "cosqa-train-160", "doc": "center align text python", "code": "def center_text(text, width=80):\n    \"\"\"Center all lines of the text.\n\n    It is assumed that all lines width is smaller then B{width}, because the\n    line width will not be checked.\n\n    Args:\n        text (str): Text to wrap.\n        width (int): Maximum number of characters per line.\n\n    Returns:\n        str: Centered text.\n    \"\"\"\n    centered = []\n    for line in text.splitlines():\n        centered.append(line.center(width))\n    return \"\\n\".join(centered)", "code_tokens": "def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return \"\\n\" . join ( centered )", "docstring_tokens": "Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text .", "label": 1}, {"idx": "cosqa-train-161", "doc": "python deserializingjson to object", "code": "def from_json(cls, json_str):\n        \"\"\"Deserialize the object from a JSON string.\"\"\"\n        d = json.loads(json_str)\n        return cls.from_dict(d)", "code_tokens": "def from_json ( cls , json_str ) : d = json . loads ( json_str ) return cls . from_dict ( d )", "docstring_tokens": "Deserialize the object from a JSON string .", "label": 0}, {"idx": "cosqa-train-162", "doc": "centos yum remove python", "code": "def update(kernel=False):\n    \"\"\"\n    Upgrade all packages, skip obsoletes if ``obsoletes=0`` in ``yum.conf``.\n\n    Exclude *kernel* upgrades by default.\n    \"\"\"\n    manager = MANAGER\n    cmds = {'yum -y --color=never': {False: '--exclude=kernel* update', True: 'update'}}\n    cmd = cmds[manager][kernel]\n    run_as_root(\"%(manager)s %(cmd)s\" % locals())", "code_tokens": "def update ( kernel = False ) : manager = MANAGER cmds = { 'yum -y --color=never' : { False : '--exclude=kernel* update' , True : 'update' } } cmd = cmds [ manager ] [ kernel ] run_as_root ( \"%(manager)s %(cmd)s\" % locals ( ) )", "docstring_tokens": "Upgrade all packages skip obsoletes if obsoletes = 0 in yum . conf .", "label": 0}, {"idx": "cosqa-train-163", "doc": "python detect encoding in text", "code": "def guess_encoding(text, default=DEFAULT_ENCODING):\n    \"\"\"Guess string encoding.\n\n    Given a piece of text, apply character encoding detection to\n    guess the appropriate encoding of the text.\n    \"\"\"\n    result = chardet.detect(text)\n    return normalize_result(result, default=default)", "code_tokens": "def guess_encoding ( text , default = DEFAULT_ENCODING ) : result = chardet . detect ( text ) return normalize_result ( result , default = default )", "docstring_tokens": "Guess string encoding .", "label": 0}, {"idx": "cosqa-train-164", "doc": "chain iterable python one element followed by comma", "code": "def commajoin_as_strings(iterable):\n    \"\"\" Join the given iterable with ',' \"\"\"\n    return _(u',').join((six.text_type(i) for i in iterable))", "code_tokens": "def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )", "docstring_tokens": "Join the given iterable with", "label": 0}, {"idx": "cosqa-train-165", "doc": "python detect if color is on screen", "code": "def supports_color():\n    \"\"\"\n    Returns True if the running system's terminal supports color, and False\n    otherwise.\n    \"\"\"\n    unsupported_platform = (sys.platform in ('win32', 'Pocket PC'))\n    # isatty is not always implemented, #6223.\n    is_a_tty = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()\n    if unsupported_platform or not is_a_tty:\n        return False\n    return True", "code_tokens": "def supports_color ( ) : unsupported_platform = ( sys . platform in ( 'win32' , 'Pocket PC' ) ) # isatty is not always implemented, #6223. is_a_tty = hasattr ( sys . stdout , 'isatty' ) and sys . stdout . isatty ( ) if unsupported_platform or not is_a_tty : return False return True", "docstring_tokens": "Returns True if the running system s terminal supports color and False otherwise .", "label": 0}, {"idx": "cosqa-train-166", "doc": "change hhmmss format to seconds from midngiht in python", "code": "def seconds_to_hms(seconds):\n    \"\"\"\n    Converts seconds float to 'hh:mm:ss.ssssss' format.\n    \"\"\"\n    hours = int(seconds / 3600.0)\n    minutes = int((seconds / 60.0) % 60.0)\n    secs = float(seconds % 60.0)\n    return \"{0:02d}:{1:02d}:{2:02.6f}\".format(hours, minutes, secs)", "code_tokens": "def seconds_to_hms ( seconds ) : hours = int ( seconds / 3600.0 ) minutes = int ( ( seconds / 60.0 ) % 60.0 ) secs = float ( seconds % 60.0 ) return \"{0:02d}:{1:02d}:{2:02.6f}\" . format ( hours , minutes , secs )", "docstring_tokens": "Converts seconds float to hh : mm : ss . ssssss format .", "label": 0}, {"idx": "cosqa-train-167", "doc": "python detect if key is in dictionary", "code": "def __contains__(self, key):\n        \"\"\"\n        Invoked when determining whether a specific key is in the dictionary\n        using `key in d`.\n\n        The key is looked up case-insensitively.\n        \"\"\"\n        k = self._real_key(key)\n        return k in self._data", "code_tokens": "def __contains__ ( self , key ) : k = self . _real_key ( key ) return k in self . _data", "docstring_tokens": "Invoked when determining whether a specific key is in the dictionary using key in d .", "label": 0}, {"idx": "cosqa-train-168", "doc": "change nonetype to int python", "code": "def get_truetype(value):\n    \"\"\"Convert a string to a pythonized parameter.\"\"\"\n    if value in [\"true\", \"True\", \"y\", \"Y\", \"yes\"]:\n        return True\n    if value in [\"false\", \"False\", \"n\", \"N\", \"no\"]:\n        return False\n    if value.isdigit():\n        return int(value)\n    return str(value)", "code_tokens": "def get_truetype ( value ) : if value in [ \"true\" , \"True\" , \"y\" , \"Y\" , \"yes\" ] : return True if value in [ \"false\" , \"False\" , \"n\" , \"N\" , \"no\" ] : return False if value . isdigit ( ) : return int ( value ) return str ( value )", "docstring_tokens": "Convert a string to a pythonized parameter .", "label": 0}, {"idx": "cosqa-train-169", "doc": "python detect not json serializable", "code": "def Serializable(o):\n    \"\"\"Make sure an object is JSON-serializable\n    Use this to return errors and other info that does not need to be\n    deserialized or does not contain important app data. Best for returning\n    error info and such\"\"\"\n    if isinstance(o, (str, dict, int)):\n        return o\n    else:\n        try:\n            json.dumps(o)\n            return o\n        except Exception:\n            LOG.debug(\"Got a non-serilizeable object: %s\" % o)\n            return o.__repr__()", "code_tokens": "def Serializable ( o ) : if isinstance ( o , ( str , dict , int ) ) : return o else : try : json . dumps ( o ) return o except Exception : LOG . debug ( \"Got a non-serilizeable object: %s\" % o ) return o . __repr__ ( )", "docstring_tokens": "Make sure an object is JSON - serializable Use this to return errors and other info that does not need to be deserialized or does not contain important app data . Best for returning error info and such", "label": 0}, {"idx": "cosqa-train-170", "doc": "change path of log files using python rotatingfilehandler", "code": "def timed_rotating_file_handler(name, logname, filename, when='h',\n                                interval=1, backupCount=0,\n                                encoding=None, delay=False, utc=False):\n    \"\"\"\n    A Bark logging handler logging output to a named file.  At\n    intervals specified by the 'when', the file will be rotated, under\n    control of 'backupCount'.\n\n    Similar to logging.handlers.TimedRotatingFileHandler.\n    \"\"\"\n\n    return wrap_log_handler(logging.handlers.TimedRotatingFileHandler(\n        filename, when=when, interval=interval, backupCount=backupCount,\n        encoding=encoding, delay=delay, utc=utc))", "code_tokens": "def timed_rotating_file_handler ( name , logname , filename , when = 'h' , interval = 1 , backupCount = 0 , encoding = None , delay = False , utc = False ) : return wrap_log_handler ( logging . handlers . TimedRotatingFileHandler ( filename , when = when , interval = interval , backupCount = backupCount , encoding = encoding , delay = delay , utc = utc ) )", "docstring_tokens": "A Bark logging handler logging output to a named file . At intervals specified by the when the file will be rotated under control of backupCount .", "label": 1}, {"idx": "cosqa-train-171", "doc": "python deter is an invalid keyword", "code": "def is_identifier(string):\n    \"\"\"Check if string could be a valid python identifier\n\n    :param string: string to be tested\n    :returns: True if string can be a python identifier, False otherwise\n    :rtype: bool\n    \"\"\"\n    matched = PYTHON_IDENTIFIER_RE.match(string)\n    return bool(matched) and not keyword.iskeyword(string)", "code_tokens": "def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )", "docstring_tokens": "Check if string could be a valid python identifier", "label": 1}, {"idx": "cosqa-train-172", "doc": "change python enumerate iterator", "code": "def uniform_iterator(sequence):\n    \"\"\"Uniform (key, value) iteration on a `dict`,\n    or (idx, value) on a `list`.\"\"\"\n\n    if isinstance(sequence, abc.Mapping):\n        return six.iteritems(sequence)\n    else:\n        return enumerate(sequence)", "code_tokens": "def uniform_iterator ( sequence ) : if isinstance ( sequence , abc . Mapping ) : return six . iteritems ( sequence ) else : return enumerate ( sequence )", "docstring_tokens": "Uniform ( key value ) iteration on a dict or ( idx value ) on a list .", "label": 0}, {"idx": "cosqa-train-173", "doc": "python determine the type of a user input", "code": "def _guess_type(val):\n        \"\"\"Guess the input type of the parameter based off the default value, if unknown use text\"\"\"\n        if isinstance(val, bool):\n            return \"choice\"\n        elif isinstance(val, int):\n            return \"number\"\n        elif isinstance(val, float):\n            return \"number\"\n        elif isinstance(val, str):\n            return \"text\"\n        elif hasattr(val, 'read'):\n            return \"file\"\n        else:\n            return \"text\"", "code_tokens": "def _guess_type ( val ) : if isinstance ( val , bool ) : return \"choice\" elif isinstance ( val , int ) : return \"number\" elif isinstance ( val , float ) : return \"number\" elif isinstance ( val , str ) : return \"text\" elif hasattr ( val , 'read' ) : return \"file\" else : return \"text\"", "docstring_tokens": "Guess the input type of the parameter based off the default value if unknown use text", "label": 0}, {"idx": "cosqa-train-174", "doc": "change the data type in data frame in python", "code": "def _to_corrected_pandas_type(dt):\n    \"\"\"\n    When converting Spark SQL records to Pandas DataFrame, the inferred data type may be wrong.\n    This method gets the corrected data type for Pandas if that type may be inferred uncorrectly.\n    \"\"\"\n    import numpy as np\n    if type(dt) == ByteType:\n        return np.int8\n    elif type(dt) == ShortType:\n        return np.int16\n    elif type(dt) == IntegerType:\n        return np.int32\n    elif type(dt) == FloatType:\n        return np.float32\n    else:\n        return None", "code_tokens": "def _to_corrected_pandas_type ( dt ) : import numpy as np if type ( dt ) == ByteType : return np . int8 elif type ( dt ) == ShortType : return np . int16 elif type ( dt ) == IntegerType : return np . int32 elif type ( dt ) == FloatType : return np . float32 else : return None", "docstring_tokens": "When converting Spark SQL records to Pandas DataFrame the inferred data type may be wrong . This method gets the corrected data type for Pandas if that type may be inferred uncorrectly .", "label": 0}, {"idx": "cosqa-train-175", "doc": "python determine whether windows or linux", "code": "def _platform_is_windows(platform=sys.platform):\n        \"\"\"Is the current OS a Windows?\"\"\"\n        matched = platform in ('cygwin', 'win32', 'win64')\n        if matched:\n            error_msg = \"Windows isn't supported yet\"\n            raise OSError(error_msg)\n        return matched", "code_tokens": "def _platform_is_windows ( platform = sys . platform ) : matched = platform in ( 'cygwin' , 'win32' , 'win64' ) if matched : error_msg = \"Windows isn't supported yet\" raise OSError ( error_msg ) return matched", "docstring_tokens": "Is the current OS a Windows?", "label": 1}, {"idx": "cosqa-train-176", "doc": "change width of columns in all sheets python", "code": "def _xls2col_widths(self, worksheet, tab):\n        \"\"\"Updates col_widths in code_array\"\"\"\n\n        for col in xrange(worksheet.ncols):\n            try:\n                xls_width = worksheet.colinfo_map[col].width\n                pys_width = self.xls_width2pys_width(xls_width)\n                self.code_array.col_widths[col, tab] = pys_width\n\n            except KeyError:\n                pass", "code_tokens": "def _xls2col_widths ( self , worksheet , tab ) : for col in xrange ( worksheet . ncols ) : try : xls_width = worksheet . colinfo_map [ col ] . width pys_width = self . xls_width2pys_width ( xls_width ) self . code_array . col_widths [ col , tab ] = pys_width except KeyError : pass", "docstring_tokens": "Updates col_widths in code_array", "label": 0}, {"idx": "cosqa-train-177", "doc": "python dict case insensitive", "code": "def keys_to_snake_case(camel_case_dict):\n    \"\"\"\n    Make a copy of a dictionary with all keys converted to snake case. This is just calls to_snake_case on\n    each of the keys in the dictionary and returns a new dictionary.\n\n    :param camel_case_dict: Dictionary with the keys to convert.\n    :type camel_case_dict: Dictionary.\n\n    :return: Dictionary with the keys converted to snake case.\n    \"\"\"\n    return dict((to_snake_case(key), value) for (key, value) in camel_case_dict.items())", "code_tokens": "def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )", "docstring_tokens": "Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .", "label": 0}, {"idx": "cosqa-train-178", "doc": "changes bytes obj to json python", "code": "def _bytes_to_json(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\"\"\"\n    if isinstance(value, bytes):\n        value = base64.standard_b64encode(value).decode(\"ascii\")\n    return value", "code_tokens": "def _bytes_to_json ( value ) : if isinstance ( value , bytes ) : value = base64 . standard_b64encode ( value ) . decode ( \"ascii\" ) return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 0}, {"idx": "cosqa-train-179", "doc": "python dict get hash", "code": "def dict_hash(dct):\n    \"\"\"Return a hash of the contents of a dictionary\"\"\"\n    dct_s = json.dumps(dct, sort_keys=True)\n\n    try:\n        m = md5(dct_s)\n    except TypeError:\n        m = md5(dct_s.encode())\n\n    return m.hexdigest()", "code_tokens": "def dict_hash ( dct ) : dct_s = json . dumps ( dct , sort_keys = True ) try : m = md5 ( dct_s ) except TypeError : m = md5 ( dct_s . encode ( ) ) return m . hexdigest ( )", "docstring_tokens": "Return a hash of the contents of a dictionary", "label": 0}, {"idx": "cosqa-train-180", "doc": "changing date from int to date in python", "code": "def int_to_date(date):\n    \"\"\"\n    Convert an int of form yyyymmdd to a python date object.\n    \"\"\"\n\n    year = date // 10**4\n    month = date % 10**4 // 10**2\n    day = date % 10**2\n\n    return datetime.date(year, month, day)", "code_tokens": "def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )", "docstring_tokens": "Convert an int of form yyyymmdd to a python date object .", "label": 0}, {"idx": "cosqa-train-181", "doc": "check all attributes in an object python", "code": "def hasattrs(object, *names):\n    \"\"\"\n    Takes in an object and a variable length amount of named attributes,\n    and checks to see if the object has each property. If any of the\n    attributes are missing, this returns false.\n\n    :param object: an object that may or may not contain the listed attributes\n    :param names: a variable amount of attribute names to check for\n    :return: True if the object contains each named attribute, false otherwise\n    \"\"\"\n    for name in names:\n        if not hasattr(object, name):\n            return False\n    return True", "code_tokens": "def hasattrs ( object , * names ) : for name in names : if not hasattr ( object , name ) : return False return True", "docstring_tokens": "Takes in an object and a variable length amount of named attributes and checks to see if the object has each property . If any of the attributes are missing this returns false .", "label": 1}, {"idx": "cosqa-train-182", "doc": "python dict update none", "code": "def dict_update_newkeys(dict_, dict2):\n    \"\"\" Like dict.update, but does not overwrite items \"\"\"\n    for key, val in six.iteritems(dict2):\n        if key not in dict_:\n            dict_[key] = val", "code_tokens": "def dict_update_newkeys ( dict_ , dict2 ) : for key , val in six . iteritems ( dict2 ) : if key not in dict_ : dict_ [ key ] = val", "docstring_tokens": "Like dict . update but does not overwrite items", "label": 0}, {"idx": "cosqa-train-183", "doc": "check equality between arrays python", "code": "def numpy_aware_eq(a, b):\n    \"\"\"Return whether two objects are equal via recursion, using\n    :func:`numpy.array_equal` for comparing numpy arays.\n    \"\"\"\n    if isinstance(a, np.ndarray) or isinstance(b, np.ndarray):\n        return np.array_equal(a, b)\n    if ((isinstance(a, Iterable) and isinstance(b, Iterable)) and\n            not isinstance(a, str) and not isinstance(b, str)):\n        if len(a) != len(b):\n            return False\n        return all(numpy_aware_eq(x, y) for x, y in zip(a, b))\n    return a == b", "code_tokens": "def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b", "docstring_tokens": "Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays .", "label": 1}, {"idx": "cosqa-train-184", "doc": "python dictionary add one by one or", "code": "def update(self, other_dict):\n        \"\"\"update() extends rather than replaces existing key lists.\"\"\"\n        for key, value in iter_multi_items(other_dict):\n            MultiDict.add(self, key, value)", "code_tokens": "def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )", "docstring_tokens": "update () extends rather than replaces existing key lists .", "label": 0}, {"idx": "cosqa-train-185", "doc": "check for internet connection python", "code": "def _internet_on(address):\n    \"\"\"\n    Check to see if the internet is on by pinging a set address.\n    :param address: the IP or address to hit\n    :return: a boolean - true if can be reached, false if not.\n    \"\"\"\n    try:\n        urllib2.urlopen(address, timeout=1)\n        return True\n    except urllib2.URLError as err:\n        return False", "code_tokens": "def _internet_on ( address ) : try : urllib2 . urlopen ( address , timeout = 1 ) return True except urllib2 . URLError as err : return False", "docstring_tokens": "Check to see if the internet is on by pinging a set address . : param address : the IP or address to hit : return : a boolean - true if can be reached false if not .", "label": 0}, {"idx": "cosqa-train-186", "doc": "python dictionary if key not in dict make a default value", "code": "def _defaultdict(dct, fallback=_illegal_character):\n    \"\"\"Wraps the given dictionary such that the given fallback function will be called when a nonexistent key is\n    accessed.\n    \"\"\"\n    out = defaultdict(lambda: fallback)\n    for k, v in six.iteritems(dct):\n        out[k] = v\n    return out", "code_tokens": "def _defaultdict ( dct , fallback = _illegal_character ) : out = defaultdict ( lambda : fallback ) for k , v in six . iteritems ( dct ) : out [ k ] = v return out", "docstring_tokens": "Wraps the given dictionary such that the given fallback function will be called when a nonexistent key is accessed .", "label": 0}, {"idx": "cosqa-train-187", "doc": "check for json python", "code": "def is_json_file(filename, show_warnings = False):\n    \"\"\"Check configuration file type is JSON\n    Return a boolean indicating wheather the file is JSON format or not\n    \"\"\"\n    try:\n        config_dict = load_config(filename, file_type = \"json\")\n        is_json = True\n    except:\n        is_json = False\n    return(is_json)", "code_tokens": "def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = \"json\" ) is_json = True except : is_json = False return ( is_json )", "docstring_tokens": "Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not", "label": 0}, {"idx": "cosqa-train-188", "doc": "python dictionary remove key with value", "code": "def _remove_dict_keys_with_value(dict_, val):\n  \"\"\"Removes `dict` keys which have have `self` as value.\"\"\"\n  return {k: v for k, v in dict_.items() if v is not val}", "code_tokens": "def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }", "docstring_tokens": "Removes dict keys which have have self as value .", "label": 0}, {"idx": "cosqa-train-189", "doc": "check git commit messages python", "code": "def post_commit_hook(argv):\n    \"\"\"Hook: for checking commit message.\"\"\"\n    _, stdout, _ = run(\"git log -1 --format=%B HEAD\")\n    message = \"\\n\".join(stdout)\n    options = {\"allow_empty\": True}\n\n    if not _check_message(message, options):\n        click.echo(\n            \"Commit message errors (fix with 'git commit --amend').\",\n            file=sys.stderr)\n        return 1  # it should not fail with exit\n    return 0", "code_tokens": "def post_commit_hook ( argv ) : _ , stdout , _ = run ( \"git log -1 --format=%B HEAD\" ) message = \"\\n\" . join ( stdout ) options = { \"allow_empty\" : True } if not _check_message ( message , options ) : click . echo ( \"Commit message errors (fix with 'git commit --amend').\" , file = sys . stderr ) return 1 # it should not fail with exit return 0", "docstring_tokens": "Hook : for checking commit message .", "label": 0}, {"idx": "cosqa-train-190", "doc": "python dictionary setdefault nested", "code": "def setdefaults(dct, defaults):\n    \"\"\"Given a target dct and a dict of {key:default value} pairs,\n    calls setdefault for all of those pairs.\"\"\"\n    for key in defaults:\n        dct.setdefault(key, defaults[key])\n\n    return dct", "code_tokens": "def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct", "docstring_tokens": "Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs .", "label": 0}, {"idx": "cosqa-train-191", "doc": "check if a file is a valid image python", "code": "def is_image_file_valid(file_path_name):\n    \"\"\"\n    Indicate whether the specified image file is valid or not.\n\n\n    @param file_path_name: absolute path and file name of an image.\n\n\n    @return: ``True`` if the image file is valid, ``False`` if the file is\n        truncated or does not correspond to a supported image.\n    \"\"\"\n    # Image.verify is only implemented for PNG images, and it only verifies\n    # the CRC checksum in the image.  The only way to check from within\n    # Pillow is to load the image in a try/except and check the error.  If\n    # as much info as possible is from the image is needed,\n    # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it\n    # will attempt to parse as much as possible.\n    try:\n        with Image.open(file_path_name) as image:\n            image.load()\n    except IOError:\n        return False\n\n    return True", "code_tokens": "def is_image_file_valid ( file_path_name ) : # Image.verify is only implemented for PNG images, and it only verifies # the CRC checksum in the image.  The only way to check from within # Pillow is to load the image in a try/except and check the error.  If # as much info as possible is from the image is needed, # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it # will attempt to parse as much as possible. try : with Image . open ( file_path_name ) as image : image . load ( ) except IOError : return False return True", "docstring_tokens": "Indicate whether the specified image file is valid or not .", "label": 0}, {"idx": "cosqa-train-192", "doc": "python dictionary to html", "code": "def dict_to_html_attrs(dict_):\n    \"\"\"\n    Banana banana\n    \"\"\"\n    res = ' '.join('%s=\"%s\"' % (k, v) for k, v in dict_.items())\n    return res", "code_tokens": "def dict_to_html_attrs ( dict_ ) : res = ' ' . join ( '%s=\"%s\"' % ( k , v ) for k , v in dict_ . items ( ) ) return res", "docstring_tokens": "Banana banana", "label": 0}, {"idx": "cosqa-train-193", "doc": "check if a file is binary python", "code": "def is_binary(filename):\n    \"\"\" Returns True if the file is binary\n\n    \"\"\"\n    with open(filename, 'rb') as fp:\n        data = fp.read(1024)\n        if not data:\n            return False\n        if b'\\0' in data:\n            return True\n        return False", "code_tokens": "def is_binary ( filename ) : with open ( filename , 'rb' ) as fp : data = fp . read ( 1024 ) if not data : return False if b'\\0' in data : return True return False", "docstring_tokens": "Returns True if the file is binary", "label": 0}, {"idx": "cosqa-train-194", "doc": "python dictionary to query string", "code": "def dict_to_querystring(dictionary):\n    \"\"\"Converts a dict to a querystring suitable to be appended to a URL.\"\"\"\n    s = u\"\"\n    for d in dictionary.keys():\n        s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d])\n    return s[:-1]", "code_tokens": "def dict_to_querystring ( dictionary ) : s = u\"\" for d in dictionary . keys ( ) : s = unicode . format ( u\"{0}{1}={2}&\" , s , d , dictionary [ d ] ) return s [ : - 1 ]", "docstring_tokens": "Converts a dict to a querystring suitable to be appended to a URL .", "label": 0}, {"idx": "cosqa-train-195", "doc": "check if all elements in a list are the same python", "code": "def _check_elements_equal(lst):\n    \"\"\"\n    Returns true if all of the elements in the list are equal.\n    \"\"\"\n    assert isinstance(lst, list), \"Input value must be a list.\"\n    return not lst or lst.count(lst[0]) == len(lst)", "code_tokens": "def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , \"Input value must be a list.\" return not lst or lst . count ( lst [ 0 ] ) == len ( lst )", "docstring_tokens": "Returns true if all of the elements in the list are equal .", "label": 0}, {"idx": "cosqa-train-196", "doc": "python dictionary to querystring", "code": "def dict_to_querystring(dictionary):\n    \"\"\"Converts a dict to a querystring suitable to be appended to a URL.\"\"\"\n    s = u\"\"\n    for d in dictionary.keys():\n        s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d])\n    return s[:-1]", "code_tokens": "def dict_to_querystring ( dictionary ) : s = u\"\" for d in dictionary . keys ( ) : s = unicode . format ( u\"{0}{1}={2}&\" , s , d , dictionary [ d ] ) return s [ : - 1 ]", "docstring_tokens": "Converts a dict to a querystring suitable to be appended to a URL .", "label": 0}, {"idx": "cosqa-train-197", "doc": "check if all elements in list are same python", "code": "def _check_elements_equal(lst):\n    \"\"\"\n    Returns true if all of the elements in the list are equal.\n    \"\"\"\n    assert isinstance(lst, list), \"Input value must be a list.\"\n    return not lst or lst.count(lst[0]) == len(lst)", "code_tokens": "def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , \"Input value must be a list.\" return not lst or lst . count ( lst [ 0 ] ) == len ( lst )", "docstring_tokens": "Returns true if all of the elements in the list are equal .", "label": 0}, {"idx": "cosqa-train-198", "doc": "python dictionary with keys but no values", "code": "def nonull_dict(self):\n        \"\"\"Like dict, but does not hold any null values.\n\n        :return:\n\n        \"\"\"\n        return {k: v for k, v in six.iteritems(self.dict) if v and k != '_codes'}", "code_tokens": "def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }", "docstring_tokens": "Like dict but does not hold any null values .", "label": 0}, {"idx": "cosqa-train-199", "doc": "python dictonary as kwargs", "code": "def updateFromKwargs(self, properties, kwargs, collector, **unused):\n        \"\"\"Primary entry point to turn 'kwargs' into 'properties'\"\"\"\n        properties[self.name] = self.getFromKwargs(kwargs)", "code_tokens": "def updateFromKwargs ( self , properties , kwargs , collector , * * unused ) : properties [ self . name ] = self . getFromKwargs ( kwargs )", "docstring_tokens": "Primary entry point to turn kwargs into properties", "label": 0}, {"idx": "cosqa-train-200", "doc": "check if arg is function python", "code": "def is_callable(*p):\n    \"\"\" True if all the args are functions and / or subroutines\n    \"\"\"\n    import symbols\n    return all(isinstance(x, symbols.FUNCTION) for x in p)", "code_tokens": "def is_callable ( * p ) : import symbols return all ( isinstance ( x , symbols . FUNCTION ) for x in p )", "docstring_tokens": "True if all the args are functions and / or subroutines", "label": 1}, {"idx": "cosqa-train-201", "doc": "python disconnect shared connection", "code": "async def disconnect(self):\n        \"\"\" Disconnect from target. \"\"\"\n        if not self.connected:\n            return\n\n        self.writer.close()\n        self.reader = None\n        self.writer = None", "code_tokens": "async def disconnect ( self ) : if not self . connected : return self . writer . close ( ) self . reader = None self . writer = None", "docstring_tokens": "Disconnect from target .", "label": 1}, {"idx": "cosqa-train-202", "doc": "check if column is object in python", "code": "def is_dataframe(obj):\n    \"\"\"\n    Returns True if the given object is a Pandas Data Frame.\n\n    Parameters\n    ----------\n    obj: instance\n        The object to test whether or not is a Pandas DataFrame.\n    \"\"\"\n    try:\n        # This is the best method of type checking\n        from pandas import DataFrame\n        return isinstance(obj, DataFrame)\n    except ImportError:\n        # Pandas is not a dependency, so this is scary\n        return obj.__class__.__name__ == \"DataFrame\"", "code_tokens": "def is_dataframe ( obj ) : try : # This is the best method of type checking from pandas import DataFrame return isinstance ( obj , DataFrame ) except ImportError : # Pandas is not a dependency, so this is scary return obj . __class__ . __name__ == \"DataFrame\"", "docstring_tokens": "Returns True if the given object is a Pandas Data Frame .", "label": 1}, {"idx": "cosqa-train-203", "doc": "python discover unit tests", "code": "def test():\n    \"\"\"Run the unit tests.\"\"\"\n    import unittest\n    tests = unittest.TestLoader().discover('tests')\n    unittest.TextTestRunner(verbosity=2).run(tests)", "code_tokens": "def test ( ) : import unittest tests = unittest . TestLoader ( ) . discover ( 'tests' ) unittest . TextTestRunner ( verbosity = 2 ) . run ( tests )", "docstring_tokens": "Run the unit tests .", "label": 0}, {"idx": "cosqa-train-204", "doc": "check if datetime python", "code": "def is_datetime_like(dtype):\n    \"\"\"Check if a dtype is a subclass of the numpy datetime types\n    \"\"\"\n    return (np.issubdtype(dtype, np.datetime64) or\n            np.issubdtype(dtype, np.timedelta64))", "code_tokens": "def is_datetime_like ( dtype ) : return ( np . issubdtype ( dtype , np . datetime64 ) or np . issubdtype ( dtype , np . timedelta64 ) )", "docstring_tokens": "Check if a dtype is a subclass of the numpy datetime types", "label": 1}, {"idx": "cosqa-train-205", "doc": "python disctionary from json string", "code": "def serialize_json_string(self, value):\n        \"\"\"\n        Tries to load an encoded json string back into an object\n        :param json_string:\n        :return:\n        \"\"\"\n\n        # Check if the value might be a json string\n        if not isinstance(value, six.string_types):\n            return value\n\n        # Make sure it starts with a brace\n        if not value.startswith('{') or value.startswith('['):\n            return value\n\n        # Try to load the string\n        try:\n            return json.loads(value)\n        except:\n            return value", "code_tokens": "def serialize_json_string ( self , value ) : # Check if the value might be a json string if not isinstance ( value , six . string_types ) : return value # Make sure it starts with a brace if not value . startswith ( '{' ) or value . startswith ( '[' ) : return value # Try to load the string try : return json . loads ( value ) except : return value", "docstring_tokens": "Tries to load an encoded json string back into an object : param json_string : : return :", "label": 1}, {"idx": "cosqa-train-206", "doc": "check if function is defined python", "code": "def is_defined(self, objtxt, force_import=False):\n        \"\"\"Return True if object is defined\"\"\"\n        return self.interpreter.is_defined(objtxt, force_import)", "code_tokens": "def is_defined ( self , objtxt , force_import = False ) : return self . interpreter . is_defined ( objtxt , force_import )", "docstring_tokens": "Return True if object is defined", "label": 1}, {"idx": "cosqa-train-207", "doc": "python display horizontal line", "code": "def get_hline():\n    \"\"\" gets a horiztonal line \"\"\"\n    return Window(\n        width=LayoutDimension.exact(1),\n        height=LayoutDimension.exact(1),\n        content=FillControl('-', token=Token.Line))", "code_tokens": "def get_hline ( ) : return Window ( width = LayoutDimension . exact ( 1 ) , height = LayoutDimension . exact ( 1 ) , content = FillControl ( '-' , token = Token . Line ) )", "docstring_tokens": "gets a horiztonal line", "label": 0}, {"idx": "cosqa-train-208", "doc": "check if group exists python", "code": "def group_exists(groupname):\n    \"\"\"Check if a group exists\"\"\"\n    try:\n        grp.getgrnam(groupname)\n        group_exists = True\n    except KeyError:\n        group_exists = False\n    return group_exists", "code_tokens": "def group_exists ( groupname ) : try : grp . getgrnam ( groupname ) group_exists = True except KeyError : group_exists = False return group_exists", "docstring_tokens": "Check if a group exists", "label": 0}, {"idx": "cosqa-train-209", "doc": "python displaying data in two treeviews", "code": "def sync(self, recursive=False):\n        \"\"\"\n        Syncs the information from this item to the tree and view.\n        \"\"\"\n        self.syncTree(recursive=recursive)\n        self.syncView(recursive=recursive)", "code_tokens": "def sync ( self , recursive = False ) : self . syncTree ( recursive = recursive ) self . syncView ( recursive = recursive )", "docstring_tokens": "Syncs the information from this item to the tree and view .", "label": 0}, {"idx": "cosqa-train-210", "doc": "check if images are identical python", "code": "def is_same_shape(self, other_im, check_channels=False):\n        \"\"\" Checks if two images have the same height and width (and optionally channels).\n\n        Parameters\n        ----------\n        other_im : :obj:`Image`\n            image to compare\n        check_channels : bool\n            whether or not to check equality of the channels\n\n        Returns\n        -------\n        bool\n            True if the images are the same shape, False otherwise\n        \"\"\"\n        if self.height == other_im.height and self.width == other_im.width:\n            if check_channels and self.channels != other_im.channels:\n                return False\n            return True\n        return False", "code_tokens": "def is_same_shape ( self , other_im , check_channels = False ) : if self . height == other_im . height and self . width == other_im . width : if check_channels and self . channels != other_im . channels : return False return True return False", "docstring_tokens": "Checks if two images have the same height and width ( and optionally channels ) .", "label": 0}, {"idx": "cosqa-train-211", "doc": "python distance two points", "code": "def get_distance_between_two_points(self, one, two):\n        \"\"\"Returns the distance between two XYPoints.\"\"\"\n        dx = one.x - two.x\n        dy = one.y - two.y\n        return math.sqrt(dx * dx + dy * dy)", "code_tokens": "def get_distance_between_two_points ( self , one , two ) : dx = one . x - two . x dy = one . y - two . y return math . sqrt ( dx * dx + dy * dy )", "docstring_tokens": "Returns the distance between two XYPoints .", "label": 0}, {"idx": "cosqa-train-212", "doc": "check if images are similar python", "code": "def is_same_shape(self, other_im, check_channels=False):\n        \"\"\" Checks if two images have the same height and width (and optionally channels).\n\n        Parameters\n        ----------\n        other_im : :obj:`Image`\n            image to compare\n        check_channels : bool\n            whether or not to check equality of the channels\n\n        Returns\n        -------\n        bool\n            True if the images are the same shape, False otherwise\n        \"\"\"\n        if self.height == other_im.height and self.width == other_im.width:\n            if check_channels and self.channels != other_im.channels:\n                return False\n            return True\n        return False", "code_tokens": "def is_same_shape ( self , other_im , check_channels = False ) : if self . height == other_im . height and self . width == other_im . width : if check_channels and self . channels != other_im . channels : return False return True return False", "docstring_tokens": "Checks if two images have the same height and width ( and optionally channels ) .", "label": 0}, {"idx": "cosqa-train-213", "doc": "check if multiple variables are none python", "code": "def _not_none(items):\n    \"\"\"Whether the item is a placeholder or contains a placeholder.\"\"\"\n    if not isinstance(items, (tuple, list)):\n        items = (items,)\n    return all(item is not _none for item in items)", "code_tokens": "def _not_none ( items ) : if not isinstance ( items , ( tuple , list ) ) : items = ( items , ) return all ( item is not _none for item in items )", "docstring_tokens": "Whether the item is a placeholder or contains a placeholder .", "label": 0}, {"idx": "cosqa-train-214", "doc": "python django delete all rows in table", "code": "def delete_all_from_db():\n    \"\"\"Clear the database.\n\n    Used for testing and debugging.\n\n    \"\"\"\n    # The models.CASCADE property is set on all ForeignKey fields, so tables can\n    # be deleted in any order without breaking constraints.\n    for model in django.apps.apps.get_models():\n        model.objects.all().delete()", "code_tokens": "def delete_all_from_db ( ) : # The models.CASCADE property is set on all ForeignKey fields, so tables can # be deleted in any order without breaking constraints. for model in django . apps . apps . get_models ( ) : model . objects . all ( ) . delete ( )", "docstring_tokens": "Clear the database .", "label": 1}, {"idx": "cosqa-train-215", "doc": "check if number is complex python", "code": "def is_complex(dtype):\n  \"\"\"Returns whether this is a complex floating point type.\"\"\"\n  dtype = tf.as_dtype(dtype)\n  if hasattr(dtype, 'is_complex'):\n    return dtype.is_complex\n  return np.issubdtype(np.dtype(dtype), np.complex)", "code_tokens": "def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )", "docstring_tokens": "Returns whether this is a complex floating point type .", "label": 1}, {"idx": "cosqa-train-216", "doc": "python django delete project", "code": "def delete(build_folder):\n    \"\"\"Delete build directory and all its contents.\n    \"\"\"\n    if _meta_.del_build in [\"on\", \"ON\"] and os.path.exists(build_folder):\n        shutil.rmtree(build_folder)", "code_tokens": "def delete ( build_folder ) : if _meta_ . del_build in [ \"on\" , \"ON\" ] and os . path . exists ( build_folder ) : shutil . rmtree ( build_folder )", "docstring_tokens": "Delete build directory and all its contents .", "label": 0}, {"idx": "cosqa-train-217", "doc": "check if stdin exists python", "code": "def _stdin_ready_posix():\n    \"\"\"Return True if there's something to read on stdin (posix version).\"\"\"\n    infds, outfds, erfds = select.select([sys.stdin],[],[],0)\n    return bool(infds)", "code_tokens": "def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )", "docstring_tokens": "Return True if there s something to read on stdin ( posix version ) .", "label": 0}, {"idx": "cosqa-train-218", "doc": "python django return response status", "code": "def json_response(data, status=200):\n    \"\"\"Return a JsonResponse. Make sure you have django installed first.\"\"\"\n    from django.http import JsonResponse\n    return JsonResponse(data=data, status=status, safe=isinstance(data, dict))", "code_tokens": "def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )", "docstring_tokens": "Return a JsonResponse . Make sure you have django installed first .", "label": 0}, {"idx": "cosqa-train-219", "doc": "check if string is file or directory python", "code": "def _is_path(s):\n    \"\"\"Return whether an object is a path.\"\"\"\n    if isinstance(s, string_types):\n        try:\n            return op.exists(s)\n        except (OSError, ValueError):\n            return False\n    else:\n        return False", "code_tokens": "def _is_path ( s ) : if isinstance ( s , string_types ) : try : return op . exists ( s ) except ( OSError , ValueError ) : return False else : return False", "docstring_tokens": "Return whether an object is a path .", "label": 0}, {"idx": "cosqa-train-220", "doc": "python doc comment of a field", "code": "def see_doc(obj_with_doc):\n    \"\"\"Copy docstring from existing object to the decorated callable.\"\"\"\n    def decorator(fn):\n        fn.__doc__ = obj_with_doc.__doc__\n        return fn\n    return decorator", "code_tokens": "def see_doc ( obj_with_doc ) : def decorator ( fn ) : fn . __doc__ = obj_with_doc . __doc__ return fn return decorator", "docstring_tokens": "Copy docstring from existing object to the decorated callable .", "label": 0}, {"idx": "cosqa-train-221", "doc": "check if the radiobutton is selected in python", "code": "def isToneCal(self):\n        \"\"\"Whether the currently selected calibration stimulus type is the calibration curve\n\n        :returns: boolean -- if the current combo box selection is calibration curve\n        \"\"\"\n        return self.ui.calTypeCmbbx.currentIndex() == self.ui.calTypeCmbbx.count() -1", "code_tokens": "def isToneCal ( self ) : return self . ui . calTypeCmbbx . currentIndex ( ) == self . ui . calTypeCmbbx . count ( ) - 1", "docstring_tokens": "Whether the currently selected calibration stimulus type is the calibration curve", "label": 0}, {"idx": "cosqa-train-222", "doc": "python documentation radians to degrees", "code": "def hmsToDeg(h, m, s):\n    \"\"\"Convert RA hours, minutes, seconds into an angle in degrees.\"\"\"\n    return h * degPerHMSHour + m * degPerHMSMin + s * degPerHMSSec", "code_tokens": "def hmsToDeg ( h , m , s ) : return h * degPerHMSHour + m * degPerHMSMin + s * degPerHMSSec", "docstring_tokens": "Convert RA hours minutes seconds into an angle in degrees .", "label": 0}, {"idx": "cosqa-train-223", "doc": "check is string is date in python", "code": "def is_date(thing):\n    \"\"\"Checks if the given thing represents a date\n\n    :param thing: The object to check if it is a date\n    :type thing: arbitrary object\n    :returns: True if we have a date object\n    :rtype: bool\n    \"\"\"\n    # known date types\n    date_types = (datetime.datetime,\n                  datetime.date,\n                  DateTime)\n    return isinstance(thing, date_types)", "code_tokens": "def is_date ( thing ) : # known date types date_types = ( datetime . datetime , datetime . date , DateTime ) return isinstance ( thing , date_types )", "docstring_tokens": "Checks if the given thing represents a date", "label": 1}, {"idx": "cosqa-train-224", "doc": "python docx section' object has no attribute 'header'", "code": "def prepare(doc):\n    \"\"\"Sets the caption_found and plot_found variables to False.\"\"\"\n    doc.caption_found = False\n    doc.plot_found = False\n    doc.listings_counter = 0", "code_tokens": "def prepare ( doc ) : doc . caption_found = False doc . plot_found = False doc . listings_counter = 0", "docstring_tokens": "Sets the caption_found and plot_found variables to False .", "label": 0}, {"idx": "cosqa-train-225", "doc": "check key type python", "code": "def validate(key):\n    \"\"\"Check that the key is a string or bytestring.\n\n    That's the only valid type of key.\n    \"\"\"\n    if not isinstance(key, (str, bytes)):\n        raise KeyError('Key must be of type str or bytes, found type {}'.format(type(key)))", "code_tokens": "def validate ( key ) : if not isinstance ( key , ( str , bytes ) ) : raise KeyError ( 'Key must be of type str or bytes, found type {}' . format ( type ( key ) ) )", "docstring_tokens": "Check that the key is a string or bytestring .", "label": 0}, {"idx": "cosqa-train-226", "doc": "python doesn't return prompt", "code": "def _normal_prompt(self):\n        \"\"\"\n        Flushes the prompt before requesting the input\n\n        :return: The command line\n        \"\"\"\n        sys.stdout.write(self.__get_ps1())\n        sys.stdout.flush()\n        return safe_input()", "code_tokens": "def _normal_prompt ( self ) : sys . stdout . write ( self . __get_ps1 ( ) ) sys . stdout . flush ( ) return safe_input ( )", "docstring_tokens": "Flushes the prompt before requesting the input", "label": 0}, {"idx": "cosqa-train-227", "doc": "check max supported depth of recursion python", "code": "def maxDepth(self, currentDepth=0):\n        \"\"\"Compute the depth of the longest branch of the tree\"\"\"\n        if not any((self.left, self.right)):\n            return currentDepth\n        result = 0\n        for child in (self.left, self.right):\n            if child:\n                result = max(result, child.maxDepth(currentDepth + 1))\n        return result", "code_tokens": "def maxDepth ( self , currentDepth = 0 ) : if not any ( ( self . left , self . right ) ) : return currentDepth result = 0 for child in ( self . left , self . right ) : if child : result = max ( result , child . maxDepth ( currentDepth + 1 ) ) return result", "docstring_tokens": "Compute the depth of the longest branch of the tree", "label": 0}, {"idx": "cosqa-train-228", "doc": "python draw a box at random coordinates", "code": "def from_rectangle(box):\n        \"\"\" Create a vector randomly within the given rectangle. \"\"\"\n        x = box.left + box.width * random.uniform(0, 1)\n        y = box.bottom + box.height * random.uniform(0, 1)\n        return Vector(x, y)", "code_tokens": "def from_rectangle ( box ) : x = box . left + box . width * random . uniform ( 0 , 1 ) y = box . bottom + box . height * random . uniform ( 0 , 1 ) return Vector ( x , y )", "docstring_tokens": "Create a vector randomly within the given rectangle .", "label": 1}, {"idx": "cosqa-train-229", "doc": "check my python path", "code": "def launched():\n    \"\"\"Test whether the current python environment is the correct lore env.\n\n    :return:  :any:`True` if the environment is launched\n    :rtype: bool\n    \"\"\"\n    if not PREFIX:\n        return False\n\n    return os.path.realpath(sys.prefix) == os.path.realpath(PREFIX)", "code_tokens": "def launched ( ) : if not PREFIX : return False return os . path . realpath ( sys . prefix ) == os . path . realpath ( PREFIX )", "docstring_tokens": "Test whether the current python environment is the correct lore env .", "label": 1}, {"idx": "cosqa-train-230", "doc": "python draw a line", "code": "def hline(self, x, y, width, color):\n        \"\"\"Draw a horizontal line up to a given length.\"\"\"\n        self.rect(x, y, width, 1, color, fill=True)", "code_tokens": "def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )", "docstring_tokens": "Draw a horizontal line up to a given length .", "label": 1}, {"idx": "cosqa-train-231", "doc": "check not nonetype python", "code": "def is_sequence(obj):\n    \"\"\"Check if `obj` is a sequence, but not a string or bytes.\"\"\"\n    return isinstance(obj, Sequence) and not (\n        isinstance(obj, str) or BinaryClass.is_valid_type(obj))", "code_tokens": "def is_sequence ( obj ) : return isinstance ( obj , Sequence ) and not ( isinstance ( obj , str ) or BinaryClass . is_valid_type ( obj ) )", "docstring_tokens": "Check if obj is a sequence but not a string or bytes .", "label": 0}, {"idx": "cosqa-train-232", "doc": "check prefix of a list python", "code": "def starts_with_prefix_in_list(text, prefixes):\n    \"\"\"\n    Return True if the given string starts with one of the prefixes in the given list, otherwise\n    return False.\n\n    Arguments:\n        text (str): Text to check for prefixes.\n        prefixes (list): List of prefixes to check for.\n\n    Returns:\n        bool: True if the given text starts with any of the given prefixes, otherwise False.\n    \"\"\"\n    for prefix in prefixes:\n        if text.startswith(prefix):\n            return True\n    return False", "code_tokens": "def starts_with_prefix_in_list ( text , prefixes ) : for prefix in prefixes : if text . startswith ( prefix ) : return True return False", "docstring_tokens": "Return True if the given string starts with one of the prefixes in the given list otherwise return False .", "label": 0}, {"idx": "cosqa-train-233", "doc": "python dump dictionary to yaml pretty", "code": "def print_yaml(o):\n    \"\"\"Pretty print an object as YAML.\"\"\"\n    print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))", "code_tokens": "def print_yaml ( o ) : print ( yaml . dump ( o , default_flow_style = False , indent = 4 , encoding = 'utf-8' ) )", "docstring_tokens": "Pretty print an object as YAML .", "label": 0}, {"idx": "cosqa-train-234", "doc": "check set covers other set python", "code": "def issuperset(self, other):\n        \"\"\"Report whether this RangeSet contains another set.\"\"\"\n        self._binary_sanity_check(other)\n        return set.issuperset(self, other)", "code_tokens": "def issuperset ( self , other ) : self . _binary_sanity_check ( other ) return set . issuperset ( self , other )", "docstring_tokens": "Report whether this RangeSet contains another set .", "label": 1}, {"idx": "cosqa-train-235", "doc": "python dump numpy array to json", "code": "def deserialize_ndarray_npy(d):\n    \"\"\"\n    Deserializes a JSONified :obj:`numpy.ndarray` that was created using numpy's\n    :obj:`save` function.\n\n    Args:\n        d (:obj:`dict`): A dictionary representation of an :obj:`ndarray` object, created\n            using :obj:`numpy.save`.\n\n    Returns:\n        An :obj:`ndarray` object.\n    \"\"\"\n    with io.BytesIO() as f:\n        f.write(json.loads(d['npy']).encode('latin-1'))\n        f.seek(0)\n        return np.load(f)", "code_tokens": "def deserialize_ndarray_npy ( d ) : with io . BytesIO ( ) as f : f . write ( json . loads ( d [ 'npy' ] ) . encode ( 'latin-1' ) ) f . seek ( 0 ) return np . load ( f )", "docstring_tokens": "Deserializes a JSONified : obj : numpy . ndarray that was created using numpy s : obj : save function .", "label": 0}, {"idx": "cosqa-train-236", "doc": "check several strings empty in python", "code": "def check(text):\n    \"\"\"Check the text.\"\"\"\n    err = \"misc.currency\"\n    msg = u\"Incorrect use of symbols in {}.\"\n\n    symbols = [\n        \"\\$[\\d]* ?(?:dollars|usd|us dollars)\"\n    ]\n\n    return existence_check(text, symbols, err, msg)", "code_tokens": "def check ( text ) : err = \"misc.currency\" msg = u\"Incorrect use of symbols in {}.\" symbols = [ \"\\$[\\d]* ?(?:dollars|usd|us dollars)\" ] return existence_check ( text , symbols , err , msg )", "docstring_tokens": "Check the text .", "label": 0}, {"idx": "cosqa-train-237", "doc": "python dynamic type of an object", "code": "def listlike(obj):\n    \"\"\"Is an object iterable like a list (and not a string)?\"\"\"\n    \n    return hasattr(obj, \"__iter__\") \\\n    and not issubclass(type(obj), str)\\\n    and not issubclass(type(obj), unicode)", "code_tokens": "def listlike ( obj ) : return hasattr ( obj , \"__iter__\" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )", "docstring_tokens": "Is an object iterable like a list ( and not a string ) ?", "label": 0}, {"idx": "cosqa-train-238", "doc": "check specific header in python", "code": "def required_header(header):\n    \"\"\"Function that verify if the header parameter is a essential header\n\n    :param header:  A string represented a header\n    :returns:       A boolean value that represent if the header is required\n    \"\"\"\n    if header in IGNORE_HEADERS:\n        return False\n\n    if header.startswith('HTTP_') or header == 'CONTENT_TYPE':\n        return True\n\n    return False", "code_tokens": "def required_header ( header ) : if header in IGNORE_HEADERS : return False if header . startswith ( 'HTTP_' ) or header == 'CONTENT_TYPE' : return True return False", "docstring_tokens": "Function that verify if the header parameter is a essential header", "label": 1}, {"idx": "cosqa-train-239", "doc": "python dynamically make data go from one table to another", "code": "def _map_table_name(self, model_names):\n        \"\"\"\n        Pre foregin_keys potrbejeme pre z nazvu tabulky zistit class,\n        tak si to namapujme\n        \"\"\"\n\n        for model in model_names:\n            if isinstance(model, tuple):\n                model = model[0]\n\n            try:\n                model_cls = getattr(self.models, model)\n                self.table_to_class[class_mapper(model_cls).tables[0].name] = model\n            except AttributeError:\n                pass", "code_tokens": "def _map_table_name ( self , model_names ) : for model in model_names : if isinstance ( model , tuple ) : model = model [ 0 ] try : model_cls = getattr ( self . models , model ) self . table_to_class [ class_mapper ( model_cls ) . tables [ 0 ] . name ] = model except AttributeError : pass", "docstring_tokens": "Pre foregin_keys potrbejeme pre z nazvu tabulky zistit class tak si to namapujme", "label": 0}, {"idx": "cosqa-train-240", "doc": "check the status of windows service in python", "code": "def service_available(service_name):\n    \"\"\"Determine whether a system service is available\"\"\"\n    try:\n        subprocess.check_output(\n            ['service', service_name, 'status'],\n            stderr=subprocess.STDOUT).decode('UTF-8')\n    except subprocess.CalledProcessError as e:\n        return b'unrecognized service' not in e.output\n    else:\n        return True", "code_tokens": "def service_available ( service_name ) : try : subprocess . check_output ( [ 'service' , service_name , 'status' ] , stderr = subprocess . STDOUT ) . decode ( 'UTF-8' ) except subprocess . CalledProcessError as e : return b'unrecognized service' not in e . output else : return True", "docstring_tokens": "Determine whether a system service is available", "label": 0}, {"idx": "cosqa-train-241", "doc": "python dynamodb export all hash key", "code": "def keys(self):\n        \"\"\"Return a list of all keys in the dictionary.\n\n        Returns:\n            list of str: [key1,key2,...,keyN]\n        \"\"\"\n        all_keys = [k.decode('utf-8') for k,v in self.rdb.hgetall(self.session_hash).items()]\n        return all_keys", "code_tokens": "def keys ( self ) : all_keys = [ k . decode ( 'utf-8' ) for k , v in self . rdb . hgetall ( self . session_hash ) . items ( ) ] return all_keys", "docstring_tokens": "Return a list of all keys in the dictionary .", "label": 0}, {"idx": "cosqa-train-242", "doc": "check type throughout a list python", "code": "def _valid_other_type(x, types):\n    \"\"\"\n    Do all elements of x have a type from types?\n    \"\"\"\n    return all(any(isinstance(el, t) for t in types) for el in np.ravel(x))", "code_tokens": "def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )", "docstring_tokens": "Do all elements of x have a type from types?", "label": 0}, {"idx": "cosqa-train-243", "doc": "python editing text files to replace quotes in tex", "code": "def escape_tex(value):\n  \"\"\"\n  Make text tex safe\n  \"\"\"\n  newval = value\n  for pattern, replacement in LATEX_SUBS:\n    newval = pattern.sub(replacement, newval)\n  return newval", "code_tokens": "def escape_tex ( value ) : newval = value for pattern , replacement in LATEX_SUBS : newval = pattern . sub ( replacement , newval ) return newval", "docstring_tokens": "Make text tex safe", "label": 0}, {"idx": "cosqa-train-244", "doc": "python elasticsearch bulk index", "code": "def update_index(index):\n    \"\"\"Re-index every document in a named index.\"\"\"\n    logger.info(\"Updating search index: '%s'\", index)\n    client = get_client()\n    responses = []\n    for model in get_index_models(index):\n        logger.info(\"Updating search index model: '%s'\", model.search_doc_type)\n        objects = model.objects.get_search_queryset(index).iterator()\n        actions = bulk_actions(objects, index=index, action=\"index\")\n        response = helpers.bulk(client, actions, chunk_size=get_setting(\"chunk_size\"))\n        responses.append(response)\n    return responses", "code_tokens": "def update_index ( index ) : logger . info ( \"Updating search index: '%s'\" , index ) client = get_client ( ) responses = [ ] for model in get_index_models ( index ) : logger . info ( \"Updating search index model: '%s'\" , model . search_doc_type ) objects = model . objects . get_search_queryset ( index ) . iterator ( ) actions = bulk_actions ( objects , index = index , action = \"index\" ) response = helpers . bulk ( client , actions , chunk_size = get_setting ( \"chunk_size\" ) ) responses . append ( response ) return responses", "docstring_tokens": "Re - index every document in a named index .", "label": 1}, {"idx": "cosqa-train-245", "doc": "check whether column is datetime in python", "code": "def is_datetime_like(dtype):\n    \"\"\"Check if a dtype is a subclass of the numpy datetime types\n    \"\"\"\n    return (np.issubdtype(dtype, np.datetime64) or\n            np.issubdtype(dtype, np.timedelta64))", "code_tokens": "def is_datetime_like ( dtype ) : return ( np . issubdtype ( dtype , np . datetime64 ) or np . issubdtype ( dtype , np . timedelta64 ) )", "docstring_tokens": "Check if a dtype is a subclass of the numpy datetime types", "label": 0}, {"idx": "cosqa-train-246", "doc": "python empty cursor object", "code": "def hidden_cursor(self):\n        \"\"\"Return a context manager that hides the cursor while inside it and\n        makes it visible on leaving.\"\"\"\n        self.stream.write(self.hide_cursor)\n        try:\n            yield\n        finally:\n            self.stream.write(self.normal_cursor)", "code_tokens": "def hidden_cursor ( self ) : self . stream . write ( self . hide_cursor ) try : yield finally : self . stream . write ( self . normal_cursor )", "docstring_tokens": "Return a context manager that hides the cursor while inside it and makes it visible on leaving .", "label": 0}, {"idx": "cosqa-train-247", "doc": "check windows service status from python", "code": "def service_available(service_name):\n    \"\"\"Determine whether a system service is available\"\"\"\n    try:\n        subprocess.check_output(\n            ['service', service_name, 'status'],\n            stderr=subprocess.STDOUT).decode('UTF-8')\n    except subprocess.CalledProcessError as e:\n        return b'unrecognized service' not in e.output\n    else:\n        return True", "code_tokens": "def service_available ( service_name ) : try : subprocess . check_output ( [ 'service' , service_name , 'status' ] , stderr = subprocess . STDOUT ) . decode ( 'UTF-8' ) except subprocess . CalledProcessError as e : return b'unrecognized service' not in e . output else : return True", "docstring_tokens": "Determine whether a system service is available", "label": 0}, {"idx": "cosqa-train-248", "doc": "python emulate copy docx with style", "code": "def copy(doc, dest, src):\n    \"\"\"Copy element from sequence, member from mapping.\n\n    :param doc: the document base\n    :param dest: the destination\n    :type dest: Pointer\n    :param src: the source\n    :type src: Pointer\n    :return: the new object\n    \"\"\"\n\n    return Target(doc).copy(dest, src).document", "code_tokens": "def copy ( doc , dest , src ) : return Target ( doc ) . copy ( dest , src ) . document", "docstring_tokens": "Copy element from sequence member from mapping .", "label": 0}, {"idx": "cosqa-train-249", "doc": "checking if something is a string in python 3", "code": "def is_string(val):\n    \"\"\"Determines whether the passed value is a string, safe for 2/3.\"\"\"\n    try:\n        basestring\n    except NameError:\n        return isinstance(val, str)\n    return isinstance(val, basestring)", "code_tokens": "def is_string ( val ) : try : basestring except NameError : return isinstance ( val , str ) return isinstance ( val , basestring )", "docstring_tokens": "Determines whether the passed value is a string safe for 2 / 3 .", "label": 0}, {"idx": "cosqa-train-250", "doc": "python encoding to read files", "code": "def read_from_file(file_path, encoding=\"utf-8\"):\n    \"\"\"\n    Read helper method\n\n    :type file_path: str|unicode\n    :type encoding: str|unicode\n    :rtype: str|unicode\n    \"\"\"\n    with codecs.open(file_path, \"r\", encoding) as f:\n        return f.read()", "code_tokens": "def read_from_file ( file_path , encoding = \"utf-8\" ) : with codecs . open ( file_path , \"r\" , encoding ) as f : return f . read ( )", "docstring_tokens": "Read helper method", "label": 0}, {"idx": "cosqa-train-251", "doc": "checking to see if there is input from a serial port python", "code": "def _stdin_ready_posix():\n    \"\"\"Return True if there's something to read on stdin (posix version).\"\"\"\n    infds, outfds, erfds = select.select([sys.stdin],[],[],0)\n    return bool(infds)", "code_tokens": "def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )", "docstring_tokens": "Return True if there s something to read on stdin ( posix version ) .", "label": 0}, {"idx": "cosqa-train-252", "doc": "python ensure current user root", "code": "def _is_root():\n    \"\"\"Checks if the user is rooted.\"\"\"\n    import os\n    import ctypes\n    try:\n        return os.geteuid() == 0\n    except AttributeError:\n        return ctypes.windll.shell32.IsUserAnAdmin() != 0\n    return False", "code_tokens": "def _is_root ( ) : import os import ctypes try : return os . geteuid ( ) == 0 except AttributeError : return ctypes . windll . shell32 . IsUserAnAdmin ( ) != 0 return False", "docstring_tokens": "Checks if the user is rooted .", "label": 0}, {"idx": "cosqa-train-253", "doc": "checking types of elements inside of an 2d array python", "code": "def _valid_other_type(x, types):\n    \"\"\"\n    Do all elements of x have a type from types?\n    \"\"\"\n    return all(any(isinstance(el, t) for t in types) for el in np.ravel(x))", "code_tokens": "def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )", "docstring_tokens": "Do all elements of x have a type from types?", "label": 1}, {"idx": "cosqa-train-254", "doc": "python enum custom members", "code": "def describe_enum_value(enum_value):\n    \"\"\"Build descriptor for Enum instance.\n\n    Args:\n      enum_value: Enum value to provide descriptor for.\n\n    Returns:\n      Initialized EnumValueDescriptor instance describing the Enum instance.\n    \"\"\"\n    enum_value_descriptor = EnumValueDescriptor()\n    enum_value_descriptor.name = six.text_type(enum_value.name)\n    enum_value_descriptor.number = enum_value.number\n    return enum_value_descriptor", "code_tokens": "def describe_enum_value ( enum_value ) : enum_value_descriptor = EnumValueDescriptor ( ) enum_value_descriptor . name = six . text_type ( enum_value . name ) enum_value_descriptor . number = enum_value . number return enum_value_descriptor", "docstring_tokens": "Build descriptor for Enum instance .", "label": 0}, {"idx": "cosqa-train-255", "doc": "checking user in group python", "code": "def user_in_all_groups(user, groups):\n    \"\"\"Returns True if the given user is in all given groups\"\"\"\n    return user_is_superuser(user) or all(user_in_group(user, group) for group in groups)", "code_tokens": "def user_in_all_groups ( user , groups ) : return user_is_superuser ( user ) or all ( user_in_group ( user , group ) for group in groups )", "docstring_tokens": "Returns True if the given user is in all given groups", "label": 0}, {"idx": "cosqa-train-256", "doc": "python enum get all name", "code": "def items(self):\n    \"\"\"Return a list of the (name, value) pairs of the enum.\n\n    These are returned in the order they were defined in the .proto file.\n    \"\"\"\n    return [(value_descriptor.name, value_descriptor.number)\n            for value_descriptor in self._enum_type.values]", "code_tokens": "def items ( self ) : return [ ( value_descriptor . name , value_descriptor . number ) for value_descriptor in self . _enum_type . values ]", "docstring_tokens": "Return a list of the ( name value ) pairs of the enum .", "label": 0}, {"idx": "cosqa-train-257", "doc": "choose k from n python fact", "code": "def n_choose_k(n, k):\n    \"\"\" get the number of quartets as n-choose-k. This is used\n    in equal splits to decide whether a split should be exhaustively sampled\n    or randomly sampled. Edges near tips can be exhaustive while highly nested\n    edges probably have too many quartets\n    \"\"\"\n    return int(reduce(MUL, (Fraction(n-i, i+1) for i in range(k)), 1))", "code_tokens": "def n_choose_k ( n , k ) : return int ( reduce ( MUL , ( Fraction ( n - i , i + 1 ) for i in range ( k ) ) , 1 ) )", "docstring_tokens": "get the number of quartets as n - choose - k . This is used in equal splits to decide whether a split should be exhaustively sampled or randomly sampled . Edges near tips can be exhaustive while highly nested edges probably have too many quartets", "label": 0}, {"idx": "cosqa-train-258", "doc": "python enum get all values", "code": "def items(cls):\n        \"\"\"\n        All values for this enum\n        :return: list of tuples\n\n        \"\"\"\n        return [\n            cls.PRECIPITATION,\n            cls.WIND,\n            cls.TEMPERATURE,\n            cls.PRESSURE\n        ]", "code_tokens": "def items ( cls ) : return [ cls . PRECIPITATION , cls . WIND , cls . TEMPERATURE , cls . PRESSURE ]", "docstring_tokens": "All values for this enum : return : list of tuples", "label": 0}, {"idx": "cosqa-train-259", "doc": "cifar 10 python how to open", "code": "def revnet_164_cifar():\n  \"\"\"Tiny hparams suitable for CIFAR/etc.\"\"\"\n  hparams = revnet_cifar_base()\n  hparams.bottleneck = True\n  hparams.num_channels = [16, 32, 64]\n  hparams.num_layers_per_block = [8, 8, 8]\n  return hparams", "code_tokens": "def revnet_164_cifar ( ) : hparams = revnet_cifar_base ( ) hparams . bottleneck = True hparams . num_channels = [ 16 , 32 , 64 ] hparams . num_layers_per_block = [ 8 , 8 , 8 ] return hparams", "docstring_tokens": "Tiny hparams suitable for CIFAR / etc .", "label": 0}, {"idx": "cosqa-train-260", "doc": "python enum values to list", "code": "def items(cls):\n        \"\"\"\n        All values for this enum\n        :return: list of tuples\n\n        \"\"\"\n        return [\n            cls.PRECIPITATION,\n            cls.WIND,\n            cls.TEMPERATURE,\n            cls.PRESSURE\n        ]", "code_tokens": "def items ( cls ) : return [ cls . PRECIPITATION , cls . WIND , cls . TEMPERATURE , cls . PRESSURE ]", "docstring_tokens": "All values for this enum : return : list of tuples", "label": 0}, {"idx": "cosqa-train-261", "doc": "cifar10 python tensorflow example", "code": "def mtf_image_transformer_cifar_mp_4x():\n  \"\"\"Data parallel CIFAR parameters.\"\"\"\n  hparams = mtf_image_transformer_base_cifar()\n  hparams.mesh_shape = \"model:4;batch:8\"\n  hparams.layout = \"batch:batch;d_ff:model;heads:model\"\n  hparams.batch_size = 32\n  hparams.num_heads = 8\n  hparams.d_ff = 8192\n  return hparams", "code_tokens": "def mtf_image_transformer_cifar_mp_4x ( ) : hparams = mtf_image_transformer_base_cifar ( ) hparams . mesh_shape = \"model:4;batch:8\" hparams . layout = \"batch:batch;d_ff:model;heads:model\" hparams . batch_size = 32 hparams . num_heads = 8 hparams . d_ff = 8192 return hparams", "docstring_tokens": "Data parallel CIFAR parameters .", "label": 0}, {"idx": "cosqa-train-262", "doc": "python equal aspect ratio", "code": "def image_set_aspect(aspect=1.0, axes=\"gca\"):\n    \"\"\"\n    sets the aspect ratio of the current zoom level of the imshow image\n    \"\"\"\n    if axes is \"gca\": axes = _pylab.gca()\n\n    e = axes.get_images()[0].get_extent()\n    axes.set_aspect(abs((e[1]-e[0])/(e[3]-e[2]))/aspect)", "code_tokens": "def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "docstring_tokens": "sets the aspect ratio of the current zoom level of the imshow image", "label": 0}, {"idx": "cosqa-train-263", "doc": "clear memory python after each loop", "code": "def Flush(self):\n    \"\"\"Flush all items from cache.\"\"\"\n    while self._age:\n      node = self._age.PopLeft()\n      self.KillObject(node.data)\n\n    self._hash = dict()", "code_tokens": "def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )", "docstring_tokens": "Flush all items from cache .", "label": 0}, {"idx": "cosqa-train-264", "doc": "python equivalent of matlab movmean function", "code": "def _propagate_mean(mean, linop, dist):\n  \"\"\"Propagate a mean through linear Gaussian transformation.\"\"\"\n  return linop.matmul(mean) + dist.mean()[..., tf.newaxis]", "code_tokens": "def _propagate_mean ( mean , linop , dist ) : return linop . matmul ( mean ) + dist . mean ( ) [ ... , tf . newaxis ]", "docstring_tokens": "Propagate a mean through linear Gaussian transformation .", "label": 1}, {"idx": "cosqa-train-265", "doc": "clearing data from memory in python", "code": "def invalidate_cache(cpu, address, size):\n        \"\"\" remove decoded instruction from instruction cache \"\"\"\n        cache = cpu.instruction_cache\n        for offset in range(size):\n            if address + offset in cache:\n                del cache[address + offset]", "code_tokens": "def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]", "docstring_tokens": "remove decoded instruction from instruction cache", "label": 0}, {"idx": "cosqa-train-266", "doc": "python even or odd booleans only", "code": "def convertToBool():\n    \"\"\" Convert a byte value to boolean (0 or 1) if\n    the global flag strictBool is True\n    \"\"\"\n    if not OPTIONS.strictBool.value:\n        return []\n\n    REQUIRES.add('strictbool.asm')\n\n    result = []\n    result.append('pop af')\n    result.append('call __NORMALIZE_BOOLEAN')\n    result.append('push af')\n\n    return result", "code_tokens": "def convertToBool ( ) : if not OPTIONS . strictBool . value : return [ ] REQUIRES . add ( 'strictbool.asm' ) result = [ ] result . append ( 'pop af' ) result . append ( 'call __NORMALIZE_BOOLEAN' ) result . append ( 'push af' ) return result", "docstring_tokens": "Convert a byte value to boolean ( 0 or 1 ) if the global flag strictBool is True", "label": 0}, {"idx": "cosqa-train-267", "doc": "clip python truncate extreme", "code": "def normalize(x, min_value, max_value):\n    \"\"\"Normalize value between min and max values.\n    It also clips the values, so that you cannot have values higher or lower\n    than 0 - 1.\"\"\"\n    x = (x - min_value) / (max_value - min_value)\n    return clip(x, 0, 1)", "code_tokens": "def normalize ( x , min_value , max_value ) : x = ( x - min_value ) / ( max_value - min_value ) return clip ( x , 0 , 1 )", "docstring_tokens": "Normalize value between min and max values . It also clips the values so that you cannot have values higher or lower than 0 - 1 .", "label": 0}, {"idx": "cosqa-train-268", "doc": "python excpetion add attributes and reraise", "code": "def prepare_for_reraise(error, exc_info=None):\n    \"\"\"Prepares the exception for re-raising with reraise method.\n\n    This method attaches type and traceback info to the error object\n    so that reraise can properly reraise it using this info.\n\n    \"\"\"\n    if not hasattr(error, \"_type_\"):\n        if exc_info is None:\n            exc_info = sys.exc_info()\n        error._type_ = exc_info[0]\n        error._traceback = exc_info[2]\n    return error", "code_tokens": "def prepare_for_reraise ( error , exc_info = None ) : if not hasattr ( error , \"_type_\" ) : if exc_info is None : exc_info = sys . exc_info ( ) error . _type_ = exc_info [ 0 ] error . _traceback = exc_info [ 2 ] return error", "docstring_tokens": "Prepares the exception for re - raising with reraise method .", "label": 0}, {"idx": "cosqa-train-269", "doc": "close all figures at once python", "code": "def close_all_but_this(self):\n        \"\"\"Close all files but the current one\"\"\"\n        self.close_all_right()\n        for i in range(0, self.get_stack_count()-1  ):\n            self.close_file(0)", "code_tokens": "def close_all_but_this ( self ) : self . close_all_right ( ) for i in range ( 0 , self . get_stack_count ( ) - 1 ) : self . close_file ( 0 )", "docstring_tokens": "Close all files but the current one", "label": 0}, {"idx": "cosqa-train-270", "doc": "python exec string name not defined", "code": "def eval_in_system_namespace(self, exec_str):\n        \"\"\"\n            Get Callable for specified string (for GUI-based editing)\n        \"\"\"\n        ns = self.cmd_namespace\n        try:\n            return eval(exec_str, ns)\n        except Exception as e:\n            self.logger.warning('Could not execute %s, gave error %s', exec_str, e)\n            return None", "code_tokens": "def eval_in_system_namespace ( self , exec_str ) : ns = self . cmd_namespace try : return eval ( exec_str , ns ) except Exception as e : self . logger . warning ( 'Could not execute %s, gave error %s' , exec_str , e ) return None", "docstring_tokens": "Get Callable for specified string ( for GUI - based editing )", "label": 0}, {"idx": "cosqa-train-271", "doc": "close connection in server using sockets in python", "code": "def _close_socket(self):\n        \"\"\"Shutdown and close the Socket.\n\n        :return:\n        \"\"\"\n        try:\n            self.socket.shutdown(socket.SHUT_RDWR)\n        except (OSError, socket.error):\n            pass\n        self.socket.close()", "code_tokens": "def _close_socket ( self ) : try : self . socket . shutdown ( socket . SHUT_RDWR ) except ( OSError , socket . error ) : pass self . socket . close ( )", "docstring_tokens": "Shutdown and close the Socket .", "label": 0}, {"idx": "cosqa-train-272", "doc": "python execute function with locals", "code": "def exec_function(ast, globals_map):\n    \"\"\"Execute a python code object in the given environment.\n\n    Args:\n      globals_map: Dictionary to use as the globals context.\n    Returns:\n      locals_map: Dictionary of locals from the environment after execution.\n    \"\"\"\n    locals_map = globals_map\n    exec ast in globals_map, locals_map\n    return locals_map", "code_tokens": "def exec_function ( ast , globals_map ) : locals_map = globals_map exec ast in globals_map , locals_map return locals_map", "docstring_tokens": "Execute a python code object in the given environment .", "label": 1}, {"idx": "cosqa-train-273", "doc": "close connection python sqlalchemy", "code": "def cleanup(self, app):\n        \"\"\"Close all connections.\"\"\"\n        if hasattr(self.database.obj, 'close_all'):\n            self.database.close_all()", "code_tokens": "def cleanup ( self , app ) : if hasattr ( self . database . obj , 'close_all' ) : self . database . close_all ( )", "docstring_tokens": "Close all connections .", "label": 1}, {"idx": "cosqa-train-274", "doc": "python expected byte like object not a string object", "code": "def get_unicode_str(obj):\n    \"\"\"Makes sure obj is a unicode string.\"\"\"\n    if isinstance(obj, six.text_type):\n        return obj\n    if isinstance(obj, six.binary_type):\n        return obj.decode(\"utf-8\", errors=\"ignore\")\n    return six.text_type(obj)", "code_tokens": "def get_unicode_str ( obj ) : if isinstance ( obj , six . text_type ) : return obj if isinstance ( obj , six . binary_type ) : return obj . decode ( \"utf-8\" , errors = \"ignore\" ) return six . text_type ( obj )", "docstring_tokens": "Makes sure obj is a unicode string .", "label": 0}, {"idx": "cosqa-train-275", "doc": "close figure python example", "code": "def close_all_but_this(self):\n        \"\"\"Close all files but the current one\"\"\"\n        self.close_all_right()\n        for i in range(0, self.get_stack_count()-1  ):\n            self.close_file(0)", "code_tokens": "def close_all_but_this ( self ) : self . close_all_right ( ) for i in range ( 0 , self . get_stack_count ( ) - 1 ) : self . close_file ( 0 )", "docstring_tokens": "Close all files but the current one", "label": 0}, {"idx": "cosqa-train-276", "doc": "python exponential function fit", "code": "def exp_fit_fun(x, a, tau, c):\n    \"\"\"Function used to fit the exponential decay.\"\"\"\n    # pylint: disable=invalid-name\n    return a * np.exp(-x / tau) + c", "code_tokens": "def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "docstring_tokens": "Function used to fit the exponential decay .", "label": 0}, {"idx": "cosqa-train-277", "doc": "closest nonzero value in array python", "code": "def _findNearest(arr, value):\n    \"\"\" Finds the value in arr that value is closest to\n    \"\"\"\n    arr = np.array(arr)\n    # find nearest value in array\n    idx = (abs(arr-value)).argmin()\n    return arr[idx]", "code_tokens": "def _findNearest ( arr , value ) : arr = np . array ( arr ) # find nearest value in array idx = ( abs ( arr - value ) ) . argmin ( ) return arr [ idx ]", "docstring_tokens": "Finds the value in arr that value is closest to", "label": 0}, {"idx": "cosqa-train-278", "doc": "python express gaussian function", "code": "def gauss_pdf(x, mu, sigma):\n    \"\"\"Normalized Gaussian\"\"\"\n    return 1 / np.sqrt(2 * np.pi) / sigma * np.exp(-(x - mu) ** 2 / 2. / sigma ** 2)", "code_tokens": "def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )", "docstring_tokens": "Normalized Gaussian", "label": 0}, {"idx": "cosqa-train-279", "doc": "code that deletes any folder if empty python", "code": "def remove_examples_all():\n    \"\"\"remove arduino/examples/all directory.\n\n    :rtype: None\n\n    \"\"\"\n    d = examples_all_dir()\n    if d.exists():\n        log.debug('remove %s', d)\n        d.rmtree()\n    else:\n        log.debug('nothing to remove: %s', d)", "code_tokens": "def remove_examples_all ( ) : d = examples_all_dir ( ) if d . exists ( ) : log . debug ( 'remove %s' , d ) d . rmtree ( ) else : log . debug ( 'nothing to remove: %s' , d )", "docstring_tokens": "remove arduino / examples / all directory .", "label": 1}, {"idx": "cosqa-train-280", "doc": "python extract 5 pages at once from pdf", "code": "def resources(self):\n        \"\"\"Retrieve contents of each page of PDF\"\"\"\n        return [self.pdf.getPage(i) for i in range(self.pdf.getNumPages())]", "code_tokens": "def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "docstring_tokens": "Retrieve contents of each page of PDF", "label": 0}, {"idx": "cosqa-train-281", "doc": "code to use to terminate a program on python", "code": "def cli_command_quit(self, msg):\n        \"\"\"\\\n        kills the child and exits\n        \"\"\"\n        if self.state == State.RUNNING and self.sprocess and self.sprocess.proc:\n            self.sprocess.proc.kill()\n        else:\n            sys.exit(0)", "code_tokens": "def cli_command_quit ( self , msg ) : if self . state == State . RUNNING and self . sprocess and self . sprocess . proc : self . sprocess . proc . kill ( ) else : sys . exit ( 0 )", "docstring_tokens": "\\ kills the child and exits", "label": 0}, {"idx": "cosqa-train-282", "doc": "python fast dot product between matrices", "code": "def dot(self, w):\n        \"\"\"Return the dotproduct between self and another vector.\"\"\"\n\n        return sum([x * y for x, y in zip(self, w)])", "code_tokens": "def dot ( self , w ) : return sum ( [ x * y for x , y in zip ( self , w ) ] )", "docstring_tokens": "Return the dotproduct between self and another vector .", "label": 0}, {"idx": "cosqa-train-283", "doc": "colors for text in python code", "code": "def printc(cls, txt, color=colors.red):\n        \"\"\"Print in color.\"\"\"\n        print(cls.color_txt(txt, color))", "code_tokens": "def printc ( cls , txt , color = colors . red ) : print ( cls . color_txt ( txt , color ) )", "docstring_tokens": "Print in color .", "label": 0}, {"idx": "cosqa-train-284", "doc": "python fastest way to compare two files", "code": "def need_update(a, b):\n    \"\"\"\n    Check if file a is newer than file b and decide whether or not to update\n    file b. Can generalize to two lists.\n    \"\"\"\n    a = listify(a)\n    b = listify(b)\n\n    return any((not op.exists(x)) for x in b) or \\\n           all((os.stat(x).st_size == 0 for x in b)) or \\\n           any(is_newer_file(x, y) for x in a for y in b)", "code_tokens": "def need_update ( a , b ) : a = listify ( a ) b = listify ( b ) return any ( ( not op . exists ( x ) ) for x in b ) or all ( ( os . stat ( x ) . st_size == 0 for x in b ) ) or any ( is_newer_file ( x , y ) for x in a for y in b )", "docstring_tokens": "Check if file a is newer than file b and decide whether or not to update file b . Can generalize to two lists .", "label": 0}, {"idx": "cosqa-train-285", "doc": "column and row of matrix python", "code": "def lengths( self ):\n        \"\"\"\n        The cell lengths.\n\n        Args:\n            None\n\n        Returns:\n            (np.array(a,b,c)): The cell lengths.\n        \"\"\"\n        return( np.array( [ math.sqrt( sum( row**2 ) ) for row in self.matrix ] ) )", "code_tokens": "def lengths ( self ) : return ( np . array ( [ math . sqrt ( sum ( row ** 2 ) ) for row in self . matrix ] ) )", "docstring_tokens": "The cell lengths .", "label": 0}, {"idx": "cosqa-train-286", "doc": "python fastest way to create a string size n", "code": "def random_str(size=10):\n    \"\"\"\n    create random string of selected size\n\n    :param size: int, length of the string\n    :return: the string\n    \"\"\"\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(size))", "code_tokens": "def random_str ( size = 10 ) : return '' . join ( random . choice ( string . ascii_lowercase ) for _ in range ( size ) )", "docstring_tokens": "create random string of selected size", "label": 0}, {"idx": "cosqa-train-287", "doc": "column names in table sqlite3 python", "code": "def get_table_columns(dbconn, tablename):\n    \"\"\"\n    Return a list of tuples specifying the column name and type\n    \"\"\"\n    cur = dbconn.cursor()\n    cur.execute(\"PRAGMA table_info('%s');\" % tablename)\n    info = cur.fetchall()\n    cols = [(i[1], i[2]) for i in info]\n    return cols", "code_tokens": "def get_table_columns ( dbconn , tablename ) : cur = dbconn . cursor ( ) cur . execute ( \"PRAGMA table_info('%s');\" % tablename ) info = cur . fetchall ( ) cols = [ ( i [ 1 ] , i [ 2 ] ) for i in info ] return cols", "docstring_tokens": "Return a list of tuples specifying the column name and type", "label": 0}, {"idx": "cosqa-train-288", "doc": "python fastest way to remove duplicates from a list", "code": "def remove_duplicates(lst):\n    \"\"\"\n    Emulate what a Python ``set()`` does, but keeping the element's order.\n    \"\"\"\n    dset = set()\n    return [l for l in lst if l not in dset and not dset.add(l)]", "code_tokens": "def remove_duplicates ( lst ) : dset = set ( ) return [ l for l in lst if l not in dset and not dset . add ( l ) ]", "docstring_tokens": "Emulate what a Python set () does but keeping the element s order .", "label": 0}, {"idx": "cosqa-train-289", "doc": "combobox methods in tkinter python", "code": "def _on_select(self, *args):\n        \"\"\"\n        Function bound to event of selection in the Combobox, calls callback if callable\n        \n        :param args: Tkinter event\n        \"\"\"\n        if callable(self.__callback):\n            self.__callback(self.selection)", "code_tokens": "def _on_select ( self , * args ) : if callable ( self . __callback ) : self . __callback ( self . selection )", "docstring_tokens": "Function bound to event of selection in the Combobox calls callback if callable : param args : Tkinter event", "label": 0}, {"idx": "cosqa-train-290", "doc": "python fft high amplitude at 0", "code": "def fft_spectrum(frames, fft_points=512):\n    \"\"\"This function computes the one-dimensional n-point discrete Fourier\n    Transform (DFT) of a real-valued array by means of an efficient algorithm\n    called the Fast Fourier Transform (FFT). Please refer to\n    https://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.rfft.html\n    for further details.\n\n    Args:\n        frames (array): The frame array in which each row is a frame.\n        fft_points (int): The length of FFT. If fft_length is greater than frame_len, the frames will be zero-padded.\n\n    Returns:\n            array: The fft spectrum.\n            If frames is an num_frames x sample_per_frame matrix, output\n            will be num_frames x FFT_LENGTH.\n    \"\"\"\n    SPECTRUM_VECTOR = np.fft.rfft(frames, n=fft_points, axis=-1, norm=None)\n    return np.absolute(SPECTRUM_VECTOR)", "code_tokens": "def fft_spectrum ( frames , fft_points = 512 ) : SPECTRUM_VECTOR = np . fft . rfft ( frames , n = fft_points , axis = - 1 , norm = None ) return np . absolute ( SPECTRUM_VECTOR )", "docstring_tokens": "This function computes the one - dimensional n - point discrete Fourier Transform ( DFT ) of a real - valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . Please refer to https : // docs . scipy . org / doc / numpy / reference / generated / numpy . fft . rfft . html for further details .", "label": 0}, {"idx": "cosqa-train-291", "doc": "compare an empty set python", "code": "def isetdiff_flags(list1, list2):\n    \"\"\"\n    move to util_iter\n    \"\"\"\n    set2 = set(list2)\n    return (item not in set2 for item in list1)", "code_tokens": "def isetdiff_flags ( list1 , list2 ) : set2 = set ( list2 ) return ( item not in set2 for item in list1 )", "docstring_tokens": "move to util_iter", "label": 0}, {"idx": "cosqa-train-292", "doc": "python file chooser restrict file types", "code": "def guess_file_type(kind, filepath=None, youtube_id=None, web_url=None, encoding=None):\n    \"\"\" guess_file_class: determines what file the content is\n        Args:\n            filepath (str): filepath of file to check\n        Returns: string indicating file's class\n    \"\"\"\n    if youtube_id:\n        return FileTypes.YOUTUBE_VIDEO_FILE\n    elif web_url:\n        return FileTypes.WEB_VIDEO_FILE\n    elif encoding:\n        return FileTypes.BASE64_FILE\n    else:\n        ext = os.path.splitext(filepath)[1][1:].lower()\n        if kind in FILE_TYPE_MAPPING and ext in FILE_TYPE_MAPPING[kind]:\n            return FILE_TYPE_MAPPING[kind][ext]\n    return None", "code_tokens": "def guess_file_type ( kind , filepath = None , youtube_id = None , web_url = None , encoding = None ) : if youtube_id : return FileTypes . YOUTUBE_VIDEO_FILE elif web_url : return FileTypes . WEB_VIDEO_FILE elif encoding : return FileTypes . BASE64_FILE else : ext = os . path . splitext ( filepath ) [ 1 ] [ 1 : ] . lower ( ) if kind in FILE_TYPE_MAPPING and ext in FILE_TYPE_MAPPING [ kind ] : return FILE_TYPE_MAPPING [ kind ] [ ext ] return None", "docstring_tokens": "guess_file_class : determines what file the content is Args : filepath ( str ) : filepath of file to check Returns : string indicating file s class", "label": 1}, {"idx": "cosqa-train-293", "doc": "compare dict for equality python", "code": "def is_same_dict(d1, d2):\n    \"\"\"Test two dictionary is equal on values. (ignore order)\n    \"\"\"\n    for k, v in d1.items():\n        if isinstance(v, dict):\n            is_same_dict(v, d2[k])\n        else:\n            assert d1[k] == d2[k]\n\n    for k, v in d2.items():\n        if isinstance(v, dict):\n            is_same_dict(v, d1[k])\n        else:\n            assert d1[k] == d2[k]", "code_tokens": "def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]", "docstring_tokens": "Test two dictionary is equal on values . ( ignore order )", "label": 0}, {"idx": "cosqa-train-294", "doc": "python file flush doesnot work", "code": "def file_writelines_flush_sync(path, lines):\n    \"\"\"\n    Fill file at @path with @lines then flush all buffers\n    (Python and system buffers)\n    \"\"\"\n    fp = open(path, 'w')\n    try:\n        fp.writelines(lines)\n        flush_sync_file_object(fp)\n    finally:\n        fp.close()", "code_tokens": "def file_writelines_flush_sync ( path , lines ) : fp = open ( path , 'w' ) try : fp . writelines ( lines ) flush_sync_file_object ( fp ) finally : fp . close ( )", "docstring_tokens": "Fill file at", "label": 0}, {"idx": "cosqa-train-295", "doc": "compare numpy dtype to python type", "code": "def make_kind_check(python_types, numpy_kind):\n    \"\"\"\n    Make a function that checks whether a scalar or array is of a given kind\n    (e.g. float, int, datetime, timedelta).\n    \"\"\"\n    def check(value):\n        if hasattr(value, 'dtype'):\n            return value.dtype.kind == numpy_kind\n        return isinstance(value, python_types)\n    return check", "code_tokens": "def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check", "docstring_tokens": "Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) .", "label": 0}, {"idx": "cosqa-train-296", "doc": "python file is empty or not", "code": "def file_empty(fp):\n    \"\"\"Determine if a file is empty or not.\"\"\"\n    # for python 2 we need to use a homemade peek()\n    if six.PY2:\n        contents = fp.read()\n        fp.seek(0)\n        return not bool(contents)\n\n    else:\n        return not fp.peek()", "code_tokens": "def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )", "docstring_tokens": "Determine if a file is empty or not .", "label": 0}, {"idx": "cosqa-train-297", "doc": "compare primitive arrays for equality python", "code": "def all_equal(arg1,arg2):\n    \"\"\"\n    Return a single boolean for arg1==arg2, even for numpy arrays\n    using element-wise comparison.\n\n    Uses all(arg1==arg2) for sequences, and arg1==arg2 otherwise.\n\n    If both objects have an '_infinitely_iterable' attribute, they are\n    not be zipped together and are compared directly instead.\n    \"\"\"\n    if all(hasattr(el, '_infinitely_iterable') for el in [arg1,arg2]):\n        return arg1==arg2\n    try:\n        return all(a1 == a2 for a1, a2 in zip(arg1, arg2))\n    except TypeError:\n        return arg1==arg2", "code_tokens": "def all_equal ( arg1 , arg2 ) : if all ( hasattr ( el , '_infinitely_iterable' ) for el in [ arg1 , arg2 ] ) : return arg1 == arg2 try : return all ( a1 == a2 for a1 , a2 in zip ( arg1 , arg2 ) ) except TypeError : return arg1 == arg2", "docstring_tokens": "Return a single boolean for arg1 == arg2 even for numpy arrays using element - wise comparison .", "label": 0}, {"idx": "cosqa-train-298", "doc": "python file size determination", "code": "def get_file_size(filename):\n    \"\"\"\n    Get the file size of a given file\n\n    :param filename: string: pathname of a file\n    :return: human readable filesize\n    \"\"\"\n    if os.path.isfile(filename):\n        return convert_size(os.path.getsize(filename))\n    return None", "code_tokens": "def get_file_size ( filename ) : if os . path . isfile ( filename ) : return convert_size ( os . path . getsize ( filename ) ) return None", "docstring_tokens": "Get the file size of a given file", "label": 1}, {"idx": "cosqa-train-299", "doc": "comparing floats and ints python", "code": "def _check_for_int(x):\n    \"\"\"\n    This is a compatibility function that takes a C{float} and converts it to an\n    C{int} if the values are equal.\n    \"\"\"\n    try:\n        y = int(x)\n    except (OverflowError, ValueError):\n        pass\n    else:\n        # There is no way in AMF0 to distinguish between integers and floats\n        if x == x and y == x:\n            return y\n\n    return x", "code_tokens": "def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x", "docstring_tokens": "This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal .", "label": 0}, {"idx": "cosqa-train-300", "doc": "python fill a form", "code": "def fill_form(form, data):\n    \"\"\"Prefill form with data.\n\n    :param form: The form to fill.\n    :param data: The data to insert in the form.\n    :returns: A pre-filled form.\n    \"\"\"\n    for (key, value) in data.items():\n        if hasattr(form, key):\n            if isinstance(value, dict):\n                fill_form(getattr(form, key), value)\n            else:\n                getattr(form, key).data = value\n    return form", "code_tokens": "def fill_form ( form , data ) : for ( key , value ) in data . items ( ) : if hasattr ( form , key ) : if isinstance ( value , dict ) : fill_form ( getattr ( form , key ) , value ) else : getattr ( form , key ) . data = value return form", "docstring_tokens": "Prefill form with data .", "label": 0}, {"idx": "cosqa-train-301", "doc": "compile python with clang", "code": "def check_clang_apply_replacements_binary(args):\n  \"\"\"Checks if invoking supplied clang-apply-replacements binary works.\"\"\"\n  try:\n    subprocess.check_call([args.clang_apply_replacements_binary, '--version'])\n  except:\n    print('Unable to run clang-apply-replacements. Is clang-apply-replacements '\n          'binary correctly specified?', file=sys.stderr)\n    traceback.print_exc()\n    sys.exit(1)", "code_tokens": "def check_clang_apply_replacements_binary ( args ) : try : subprocess . check_call ( [ args . clang_apply_replacements_binary , '--version' ] ) except : print ( 'Unable to run clang-apply-replacements. Is clang-apply-replacements ' 'binary correctly specified?' , file = sys . stderr ) traceback . print_exc ( ) sys . exit ( 1 )", "docstring_tokens": "Checks if invoking supplied clang - apply - replacements binary works .", "label": 0}, {"idx": "cosqa-train-302", "doc": "python fillna if false", "code": "def _maybe_fill(arr, fill_value=np.nan):\n    \"\"\"\n    if we have a compatible fill_value and arr dtype, then fill\n    \"\"\"\n    if _isna_compat(arr, fill_value):\n        arr.fill(fill_value)\n    return arr", "code_tokens": "def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr", "docstring_tokens": "if we have a compatible fill_value and arr dtype then fill", "label": 0}, {"idx": "cosqa-train-303", "doc": "compression in python without using zlib", "code": "def extract_alzip (archive, compression, cmd, verbosity, interactive, outdir):\n    \"\"\"Extract a ALZIP archive.\"\"\"\n    return [cmd, '-d', outdir, archive]", "code_tokens": "def extract_alzip ( archive , compression , cmd , verbosity , interactive , outdir ) : return [ cmd , '-d' , outdir , archive ]", "docstring_tokens": "Extract a ALZIP archive .", "label": 0}, {"idx": "cosqa-train-304", "doc": "python fillna inplace not working", "code": "def _maybe_fill(arr, fill_value=np.nan):\n    \"\"\"\n    if we have a compatible fill_value and arr dtype, then fill\n    \"\"\"\n    if _isna_compat(arr, fill_value):\n        arr.fill(fill_value)\n    return arr", "code_tokens": "def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr", "docstring_tokens": "if we have a compatible fill_value and arr dtype then fill", "label": 1}, {"idx": "cosqa-train-305", "doc": "compute degrees from survey bearing python function", "code": "def get_lons_from_cartesian(x__, y__):\n    \"\"\"Get longitudes from cartesian coordinates.\n    \"\"\"\n    return rad2deg(arccos(x__ / sqrt(x__ ** 2 + y__ ** 2))) * sign(y__)", "code_tokens": "def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )", "docstring_tokens": "Get longitudes from cartesian coordinates .", "label": 0}, {"idx": "cosqa-train-306", "doc": "python filter str object is not callable", "code": "def filter_(stream_spec, filter_name, *args, **kwargs):\n    \"\"\"Alternate name for ``filter``, so as to not collide with the\n    built-in python ``filter`` operator.\n    \"\"\"\n    return filter(stream_spec, filter_name, *args, **kwargs)", "code_tokens": "def filter_ ( stream_spec , filter_name , * args , * * kwargs ) : return filter ( stream_spec , filter_name , * args , * * kwargs )", "docstring_tokens": "Alternate name for filter so as to not collide with the built - in python filter operator .", "label": 0}, {"idx": "cosqa-train-307", "doc": "compute distance from longitude and latitude python", "code": "def _calculate_distance(latlon1, latlon2):\n    \"\"\"Calculates the distance between two points on earth.\n    \"\"\"\n    lat1, lon1 = latlon1\n    lat2, lon2 = latlon2\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    R = 6371  # radius of the earth in kilometers\n    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * (np.sin(dlon / 2))**2\n    c = 2 * np.pi * R * np.arctan2(np.sqrt(a), np.sqrt(1 - a)) / 180\n    return c", "code_tokens": "def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c", "docstring_tokens": "Calculates the distance between two points on earth .", "label": 1}, {"idx": "cosqa-train-308", "doc": "python finding the smallest and largetst valuse in a list", "code": "def find_lt(a, x):\n    \"\"\"Find rightmost value less than x.\"\"\"\n    i = bs.bisect_left(a, x)\n    if i: return i - 1\n    raise ValueError", "code_tokens": "def find_lt ( a , x ) : i = bs . bisect_left ( a , x ) if i : return i - 1 raise ValueError", "docstring_tokens": "Find rightmost value less than x .", "label": 1}, {"idx": "cosqa-train-309", "doc": "compute eigenvalues of transition matrix in python", "code": "def get_stationary_distribution(self):\n        \"\"\"Compute the stationary distribution of states.\n        \"\"\"\n        # The stationary distribution is proportional to the left-eigenvector\n        # associated with the largest eigenvalue (i.e., 1) of the transition\n        # matrix.\n        check_is_fitted(self, \"transmat_\")\n        eigvals, eigvecs = np.linalg.eig(self.transmat_.T)\n        eigvec = np.real_if_close(eigvecs[:, np.argmax(eigvals)])\n        return eigvec / eigvec.sum()", "code_tokens": "def get_stationary_distribution ( self ) : # The stationary distribution is proportional to the left-eigenvector # associated with the largest eigenvalue (i.e., 1) of the transition # matrix. check_is_fitted ( self , \"transmat_\" ) eigvals , eigvecs = np . linalg . eig ( self . transmat_ . T ) eigvec = np . real_if_close ( eigvecs [ : , np . argmax ( eigvals ) ] ) return eigvec / eigvec . sum ( )", "docstring_tokens": "Compute the stationary distribution of states .", "label": 0}, {"idx": "cosqa-train-310", "doc": "python fit in 2 dimensions", "code": "def apply_fit(xy,coeffs):\n    \"\"\" Apply the coefficients from a linear fit to\n        an array of x,y positions.\n\n        The coeffs come from the 'coeffs' member of the\n        'fit_arrays()' output.\n    \"\"\"\n    x_new = coeffs[0][2] + coeffs[0][0]*xy[:,0] + coeffs[0][1]*xy[:,1]\n    y_new = coeffs[1][2] + coeffs[1][0]*xy[:,0] + coeffs[1][1]*xy[:,1]\n\n    return x_new,y_new", "code_tokens": "def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "docstring_tokens": "Apply the coefficients from a linear fit to an array of x y positions .", "label": 0}, {"idx": "cosqa-train-311", "doc": "compute euclidean distance between test set and training setin python", "code": "def _tf_squared_euclidean(X, Y):\n        \"\"\"Squared Euclidean distance between the rows of `X` and `Y`.\n        \"\"\"\n        return tf.reduce_sum(tf.pow(tf.subtract(X, Y), 2), axis=1)", "code_tokens": "def _tf_squared_euclidean ( X , Y ) : return tf . reduce_sum ( tf . pow ( tf . subtract ( X , Y ) , 2 ) , axis = 1 )", "docstring_tokens": "Squared Euclidean distance between the rows of X and Y .", "label": 0}, {"idx": "cosqa-train-312", "doc": "python fit to exponential function", "code": "def exp_fit_fun(x, a, tau, c):\n    \"\"\"Function used to fit the exponential decay.\"\"\"\n    # pylint: disable=invalid-name\n    return a * np.exp(-x / tau) + c", "code_tokens": "def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "docstring_tokens": "Function used to fit the exponential decay .", "label": 1}, {"idx": "cosqa-train-313", "doc": "compute euclidean distance python 2d", "code": "def euclidean(x, y):\n    \"\"\"Standard euclidean distance.\n\n    ..math::\n        D(x, y) = \\sqrt{\\sum_i (x_i - y_i)^2}\n    \"\"\"\n    result = 0.0\n    for i in range(x.shape[0]):\n        result += (x[i] - y[i]) ** 2\n    return np.sqrt(result)", "code_tokens": "def euclidean ( x , y ) : result = 0.0 for i in range ( x . shape [ 0 ] ) : result += ( x [ i ] - y [ i ] ) ** 2 return np . sqrt ( result )", "docstring_tokens": "Standard euclidean distance .", "label": 0}, {"idx": "cosqa-train-314", "doc": "python fits table add a column", "code": "def create_table_from_fits(fitsfile, hduname, colnames=None):\n    \"\"\"Memory efficient function for loading a table from a FITS\n    file.\"\"\"\n\n    if colnames is None:\n        return Table.read(fitsfile, hduname)\n\n    cols = []\n    with fits.open(fitsfile, memmap=True) as h:\n        for k in colnames:\n            data = h[hduname].data.field(k)\n            cols += [Column(name=k, data=data)]\n    return Table(cols)", "code_tokens": "def create_table_from_fits ( fitsfile , hduname , colnames = None ) : if colnames is None : return Table . read ( fitsfile , hduname ) cols = [ ] with fits . open ( fitsfile , memmap = True ) as h : for k in colnames : data = h [ hduname ] . data . field ( k ) cols += [ Column ( name = k , data = data ) ] return Table ( cols )", "docstring_tokens": "Memory efficient function for loading a table from a FITS file .", "label": 0}, {"idx": "cosqa-train-315", "doc": "compute gcd of a list of element in python", "code": "def _gcd_array(X):\n    \"\"\"\n    Return the largest real value h such that all elements in x are integer\n    multiples of h.\n    \"\"\"\n    greatest_common_divisor = 0.0\n    for x in X:\n        greatest_common_divisor = _gcd(greatest_common_divisor, x)\n\n    return greatest_common_divisor", "code_tokens": "def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor", "docstring_tokens": "Return the largest real value h such that all elements in x are integer multiples of h .", "label": 0}, {"idx": "cosqa-train-316", "doc": "python flake8 line too long", "code": "def lint(args):\n    \"\"\"Run lint checks using flake8.\"\"\"\n    application = get_current_application()\n    if not args:\n        args = [application.name, 'tests']\n    args = ['flake8'] + list(args)\n    run.main(args, standalone_mode=False)", "code_tokens": "def lint ( args ) : application = get_current_application ( ) if not args : args = [ application . name , 'tests' ] args = [ 'flake8' ] + list ( args ) run . main ( args , standalone_mode = False )", "docstring_tokens": "Run lint checks using flake8 .", "label": 0}, {"idx": "cosqa-train-317", "doc": "conactecate array python without numpy", "code": "def torecarray(*args, **kwargs):\n    \"\"\"\n    Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.\n\n    \"\"\"\n\n    import numpy as np\n    return toarray(*args, **kwargs).view(np.recarray)", "code_tokens": "def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )", "docstring_tokens": "Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) .", "label": 0}, {"idx": "cosqa-train-318", "doc": "python flask booleanfield center", "code": "def _type_bool(label,default=False):\n    \"\"\"Shortcut fot boolean like fields\"\"\"\n    return label, abstractSearch.nothing, abstractRender.boolen, default", "code_tokens": "def _type_bool ( label , default = False ) : return label , abstractSearch . nothing , abstractRender . boolen , default", "docstring_tokens": "Shortcut fot boolean like fields", "label": 0}, {"idx": "cosqa-train-319", "doc": "concate column names in python", "code": "def join_cols(cols):\n    \"\"\"Join list of columns into a string for a SQL query\"\"\"\n    return \", \".join([i for i in cols]) if isinstance(cols, (list, tuple, set)) else cols", "code_tokens": "def join_cols ( cols ) : return \", \" . join ( [ i for i in cols ] ) if isinstance ( cols , ( list , tuple , set ) ) else cols", "docstring_tokens": "Join list of columns into a string for a SQL query", "label": 0}, {"idx": "cosqa-train-320", "doc": "python flask get text from form post", "code": "def parse_form(self, req, name, field):\n        \"\"\"Pull a form value from the request.\"\"\"\n        return core.get_value(req.POST, name, field)", "code_tokens": "def parse_form ( self , req , name , field ) : return core . get_value ( req . POST , name , field )", "docstring_tokens": "Pull a form value from the request .", "label": 0}, {"idx": "cosqa-train-321", "doc": "python flask header cors allow", "code": "def cors_header(func):\n    \"\"\" @cors_header decorator adds CORS headers \"\"\"\n\n    @wraps(func)\n    def wrapper(self, request, *args, **kwargs):\n        res = func(self, request, *args, **kwargs)\n        request.setHeader('Access-Control-Allow-Origin', '*')\n        request.setHeader('Access-Control-Allow-Headers', 'Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With')\n        return res\n\n    return wrapper", "code_tokens": "def cors_header ( func ) : @ wraps ( func ) def wrapper ( self , request , * args , * * kwargs ) : res = func ( self , request , * args , * * kwargs ) request . setHeader ( 'Access-Control-Allow-Origin' , '*' ) request . setHeader ( 'Access-Control-Allow-Headers' , 'Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With' ) return res return wrapper", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-322", "doc": "conditional probability function in python", "code": "def pdf(x, mu, std):\n    \"\"\"Probability density function (normal distribution)\"\"\"\n    return (1.0 / (std * sqrt(2 * pi))) * np.exp(-(x - mu) ** 2 / (2 * std ** 2))", "code_tokens": "def pdf ( x , mu , std ) : return ( 1.0 / ( std * sqrt ( 2 * pi ) ) ) * np . exp ( - ( x - mu ) ** 2 / ( 2 * std ** 2 ) )", "docstring_tokens": "Probability density function ( normal distribution )", "label": 0}, {"idx": "cosqa-train-323", "doc": "python flask method for common request", "code": "def handleFlaskPostRequest(flaskRequest, endpoint):\n    \"\"\"\n    Handles the specified flask request for one of the POST URLS\n    Invokes the specified endpoint to generate a response.\n    \"\"\"\n    if flaskRequest.method == \"POST\":\n        return handleHttpPost(flaskRequest, endpoint)\n    elif flaskRequest.method == \"OPTIONS\":\n        return handleHttpOptions()\n    else:\n        raise exceptions.MethodNotAllowedException()", "code_tokens": "def handleFlaskPostRequest ( flaskRequest , endpoint ) : if flaskRequest . method == \"POST\" : return handleHttpPost ( flaskRequest , endpoint ) elif flaskRequest . method == \"OPTIONS\" : return handleHttpOptions ( ) else : raise exceptions . MethodNotAllowedException ( )", "docstring_tokens": "Handles the specified flask request for one of the POST URLS Invokes the specified endpoint to generate a response .", "label": 0}, {"idx": "cosqa-train-324", "doc": "conditional probability functions in python", "code": "def pdf(x, mu, std):\n    \"\"\"Probability density function (normal distribution)\"\"\"\n    return (1.0 / (std * sqrt(2 * pi))) * np.exp(-(x - mu) ** 2 / (2 * std ** 2))", "code_tokens": "def pdf ( x , mu , std ) : return ( 1.0 / ( std * sqrt ( 2 * pi ) ) ) * np . exp ( - ( x - mu ) ** 2 / ( 2 * std ** 2 ) )", "docstring_tokens": "Probability density function ( normal distribution )", "label": 0}, {"idx": "cosqa-train-325", "doc": "python flask mime types", "code": "def python_mime(fn):\n    \"\"\"\n    Decorator, which adds correct MIME type for python source to the decorated\n    bottle API function.\n    \"\"\"\n    @wraps(fn)\n    def python_mime_decorator(*args, **kwargs):\n        response.content_type = \"text/x-python\"\n\n        return fn(*args, **kwargs)\n\n    return python_mime_decorator", "code_tokens": "def python_mime ( fn ) : @ wraps ( fn ) def python_mime_decorator ( * args , * * kwargs ) : response . content_type = \"text/x-python\" return fn ( * args , * * kwargs ) return python_mime_decorator", "docstring_tokens": "Decorator which adds correct MIME type for python source to the decorated bottle API function .", "label": 0}, {"idx": "cosqa-train-326", "doc": "confluent kafka consume poll python", "code": "def _spawn_kafka_consumer_thread(self):\n        \"\"\"Spawns a kafka continuous consumer thread\"\"\"\n        self.logger.debug(\"Spawn kafka consumer thread\"\"\")\n        self._consumer_thread = Thread(target=self._consumer_loop)\n        self._consumer_thread.setDaemon(True)\n        self._consumer_thread.start()", "code_tokens": "def _spawn_kafka_consumer_thread ( self ) : self . logger . debug ( \"Spawn kafka consumer thread\" \"\" ) self . _consumer_thread = Thread ( target = self . _consumer_loop ) self . _consumer_thread . setDaemon ( True ) self . _consumer_thread . start ( )", "docstring_tokens": "Spawns a kafka continuous consumer thread", "label": 0}, {"idx": "cosqa-train-327", "doc": "python flask render list of files as links", "code": "def flatpages_link_list(request):\n    \"\"\"\n    Returns a HttpResponse whose content is a Javascript file representing a\n    list of links to flatpages.\n    \"\"\"\n    from django.contrib.flatpages.models import FlatPage\n    link_list = [(page.title, page.url) for page in FlatPage.objects.all()]\n    return render_to_link_list(link_list)", "code_tokens": "def flatpages_link_list ( request ) : from django . contrib . flatpages . models import FlatPage link_list = [ ( page . title , page . url ) for page in FlatPage . objects . all ( ) ] return render_to_link_list ( link_list )", "docstring_tokens": "Returns a HttpResponse whose content is a Javascript file representing a list of links to flatpages .", "label": 0}, {"idx": "cosqa-train-328", "doc": "contolling the x and y limits of plot in python", "code": "def values(self):\n        \"\"\"Gets the user enter max and min values of where the \n        raster points should appear on the y-axis\n\n        :returns: (float, float) -- (min, max) y-values to bound the raster plot by\n        \"\"\"\n        lower = float(self.lowerSpnbx.value())\n        upper = float(self.upperSpnbx.value())\n        return (lower, upper)", "code_tokens": "def values ( self ) : lower = float ( self . lowerSpnbx . value ( ) ) upper = float ( self . upperSpnbx . value ( ) ) return ( lower , upper )", "docstring_tokens": "Gets the user enter max and min values of where the raster points should appear on the y - axis", "label": 0}, {"idx": "cosqa-train-329", "doc": "python flask sqlalchemy query on a query", "code": "def sqlmany(self, stringname, *args):\n        \"\"\"Wrapper for executing many SQL calls on my connection.\n\n        First arg is the name of a query, either a key in the\n        precompiled JSON or a method name in\n        ``allegedb.alchemy.Alchemist``. Remaining arguments should be\n        tuples of argument sequences to be passed to the query.\n\n        \"\"\"\n        if hasattr(self, 'alchemist'):\n            return getattr(self.alchemist.many, stringname)(*args)\n        s = self.strings[stringname]\n        return self.connection.cursor().executemany(s, args)", "code_tokens": "def sqlmany ( self , stringname , * args ) : if hasattr ( self , 'alchemist' ) : return getattr ( self . alchemist . many , stringname ) ( * args ) s = self . strings [ stringname ] return self . connection . cursor ( ) . executemany ( s , args )", "docstring_tokens": "Wrapper for executing many SQL calls on my connection .", "label": 0}, {"idx": "cosqa-train-330", "doc": "convolve image with kernel python stack overflow", "code": "def convolve_gaussian_2d(image, gaussian_kernel_1d):\n    \"\"\"Convolve 2d gaussian.\"\"\"\n    result = scipy.ndimage.filters.correlate1d(\n        image, gaussian_kernel_1d, axis=0)\n    result = scipy.ndimage.filters.correlate1d(\n        result, gaussian_kernel_1d, axis=1)\n    return result", "code_tokens": "def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result", "docstring_tokens": "Convolve 2d gaussian .", "label": 0}, {"idx": "cosqa-train-331", "doc": "python flask template extend with context", "code": "def render_template_string(source, **context):\n    \"\"\"Renders a template from the given template source string\n    with the given context.\n\n    :param source: the sourcecode of the template to be\n                   rendered\n    :param context: the variables that should be available in the\n                    context of the template.\n    \"\"\"\n    ctx = _app_ctx_stack.top\n    ctx.app.update_template_context(context)\n    return _render(ctx.app.jinja_env.from_string(source),\n                   context, ctx.app)", "code_tokens": "def render_template_string ( source , * * context ) : ctx = _app_ctx_stack . top ctx . app . update_template_context ( context ) return _render ( ctx . app . jinja_env . from_string ( source ) , context , ctx . app )", "docstring_tokens": "Renders a template from the given template source string with the given context .", "label": 1}, {"idx": "cosqa-train-332", "doc": "coroutine blocking functions python", "code": "def asynchronous(function, event):\n    \"\"\"\n    Runs the function asynchronously taking care of exceptions.\n    \"\"\"\n    thread = Thread(target=synchronous, args=(function, event))\n    thread.daemon = True\n    thread.start()", "code_tokens": "def asynchronous ( function , event ) : thread = Thread ( target = synchronous , args = ( function , event ) ) thread . daemon = True thread . start ( )", "docstring_tokens": "Runs the function asynchronously taking care of exceptions .", "label": 0}, {"idx": "cosqa-train-333", "doc": "python flask template request status 403", "code": "def HttpResponse403(request, template=KEY_AUTH_403_TEMPLATE,\ncontent=KEY_AUTH_403_CONTENT, content_type=KEY_AUTH_403_CONTENT_TYPE):\n    \"\"\"\n    HTTP response for forbidden access (status code 403)\n    \"\"\"\n    return AccessFailedResponse(request, template, content, content_type, status=403)", "code_tokens": "def HttpResponse403 ( request , template = KEY_AUTH_403_TEMPLATE , content = KEY_AUTH_403_CONTENT , content_type = KEY_AUTH_403_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 403 )", "docstring_tokens": "HTTP response for forbidden access ( status code 403 )", "label": 0}, {"idx": "cosqa-train-334", "doc": "cosine similarity python query", "code": "def similarity(self, other):\n        \"\"\"Calculates the cosine similarity between this vector and another\n        vector.\"\"\"\n        if self.magnitude == 0 or other.magnitude == 0:\n            return 0\n\n        return self.dot(other) / self.magnitude", "code_tokens": "def similarity ( self , other ) : if self . magnitude == 0 or other . magnitude == 0 : return 0 return self . dot ( other ) / self . magnitude", "docstring_tokens": "Calculates the cosine similarity between this vector and another vector .", "label": 0}, {"idx": "cosqa-train-335", "doc": "python flask template static file", "code": "def default_static_path():\n    \"\"\"\n        Return the path to the javascript bundle\n    \"\"\"\n    fdir = os.path.dirname(__file__)\n    return os.path.abspath(os.path.join(fdir, '../assets/'))", "code_tokens": "def default_static_path ( ) : fdir = os . path . dirname ( __file__ ) return os . path . abspath ( os . path . join ( fdir , '../assets/' ) )", "docstring_tokens": "Return the path to the javascript bundle", "label": 0}, {"idx": "cosqa-train-336", "doc": "count frequency of unique values in list python", "code": "def count_list(the_list):\n    \"\"\"\n    Generates a count of the number of times each unique item appears in a list\n    \"\"\"\n    count = the_list.count\n    result = [(item, count(item)) for item in set(the_list)]\n    result.sort()\n    return result", "code_tokens": "def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result", "docstring_tokens": "Generates a count of the number of times each unique item appears in a list", "label": 0}, {"idx": "cosqa-train-337", "doc": "python float precision rounding", "code": "def round_to_float(number, precision):\n    \"\"\"Round a float to a precision\"\"\"\n    rounded = Decimal(str(floor((number + precision / 2) // precision))\n                      ) * Decimal(str(precision))\n    return float(rounded)", "code_tokens": "def round_to_float ( number , precision ) : rounded = Decimal ( str ( floor ( ( number + precision / 2 ) // precision ) ) ) * Decimal ( str ( precision ) ) return float ( rounded )", "docstring_tokens": "Round a float to a precision", "label": 1}, {"idx": "cosqa-train-338", "doc": "count number of overlaps in two python lists", "code": "def _calc_overlap_count(\n    markers1: dict,\n    markers2: dict,\n):\n    \"\"\"Calculate overlap count between the values of two dictionaries\n\n    Note: dict values must be sets\n    \"\"\"\n    overlaps=np.zeros((len(markers1), len(markers2)))\n\n    j=0\n    for marker_group in markers1:\n        tmp = [len(markers2[i].intersection(markers1[marker_group])) for i in markers2.keys()]\n        overlaps[j,:] = tmp\n        j += 1\n\n    return overlaps", "code_tokens": "def _calc_overlap_count ( markers1 : dict , markers2 : dict , ) : overlaps = np . zeros ( ( len ( markers1 ) , len ( markers2 ) ) ) j = 0 for marker_group in markers1 : tmp = [ len ( markers2 [ i ] . intersection ( markers1 [ marker_group ] ) ) for i in markers2 . keys ( ) ] overlaps [ j , : ] = tmp j += 1 return overlaps", "docstring_tokens": "Calculate overlap count between the values of two dictionaries", "label": 1}, {"idx": "cosqa-train-339", "doc": "python float to int cast round", "code": "def intround(value):\n    \"\"\"Given a float returns a rounded int. Should give the same result on\n    both Py2/3\n    \"\"\"\n\n    return int(decimal.Decimal.from_float(\n        value).to_integral_value(decimal.ROUND_HALF_EVEN))", "code_tokens": "def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )", "docstring_tokens": "Given a float returns a rounded int . Should give the same result on both Py2 / 3", "label": 0}, {"idx": "cosqa-train-340", "doc": "covert datetime date to datetime python", "code": "def _datetime_to_date(arg):\n    \"\"\"\n    convert datetime/str to date\n    :param arg:\n    :return:\n    \"\"\"\n    _arg = parse(arg)\n    if isinstance(_arg, datetime.datetime):\n        _arg = _arg.date()\n    return _arg", "code_tokens": "def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "docstring_tokens": "convert datetime / str to date : param arg : : return :", "label": 0}, {"idx": "cosqa-train-341", "doc": "python focusout comes before button", "code": "def focusInEvent(self, event):\n        \"\"\"Reimplement Qt method to send focus change notification\"\"\"\n        self.focus_changed.emit()\n        return super(PageControlWidget, self).focusInEvent(event)", "code_tokens": "def focusInEvent ( self , event ) : self . focus_changed . emit ( ) return super ( PageControlWidget , self ) . focusInEvent ( event )", "docstring_tokens": "Reimplement Qt method to send focus change notification", "label": 0}, {"idx": "cosqa-train-342", "doc": "creat new folder in python", "code": "def mkdir(dir, enter):\n    \"\"\"Create directory with template for topic of the current environment\n\n    \"\"\"\n\n    if not os.path.exists(dir):\n        os.makedirs(dir)", "code_tokens": "def mkdir ( dir , enter ) : if not os . path . exists ( dir ) : os . makedirs ( dir )", "docstring_tokens": "Create directory with template for topic of the current environment", "label": 0}, {"idx": "cosqa-train-343", "doc": "python for comprehension sum", "code": "def _accumulate(sequence, func):\n    \"\"\"\n    Python2 accumulate implementation taken from\n    https://docs.python.org/3/library/itertools.html#itertools.accumulate\n    \"\"\"\n    iterator = iter(sequence)\n    total = next(iterator)\n    yield total\n    for element in iterator:\n        total = func(total, element)\n        yield total", "code_tokens": "def _accumulate ( sequence , func ) : iterator = iter ( sequence ) total = next ( iterator ) yield total for element in iterator : total = func ( total , element ) yield total", "docstring_tokens": "Python2 accumulate implementation taken from https : // docs . python . org / 3 / library / itertools . html#itertools . accumulate", "label": 1}, {"idx": "cosqa-train-344", "doc": "create 2d array python numpy one hot encoding", "code": "def one_hot(x, size, dtype=np.float32):\n  \"\"\"Make a n+1 dim one-hot array from n dim int-categorical array.\"\"\"\n  return np.array(x[..., np.newaxis] == np.arange(size), dtype)", "code_tokens": "def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )", "docstring_tokens": "Make a n + 1 dim one - hot array from n dim int - categorical array .", "label": 0}, {"idx": "cosqa-train-345", "doc": "python for each regex match in a string", "code": "def iter_finds(regex_obj, s):\n    \"\"\"Generate all matches found within a string for a regex and yield each match as a string\"\"\"\n    if isinstance(regex_obj, str):\n        for m in re.finditer(regex_obj, s):\n            yield m.group()\n    else:\n        for m in regex_obj.finditer(s):\n            yield m.group()", "code_tokens": "def iter_finds ( regex_obj , s ) : if isinstance ( regex_obj , str ) : for m in re . finditer ( regex_obj , s ) : yield m . group ( ) else : for m in regex_obj . finditer ( s ) : yield m . group ( )", "docstring_tokens": "Generate all matches found within a string for a regex and yield each match as a string", "label": 0}, {"idx": "cosqa-train-346", "doc": "create 5 by 5 matrix in python", "code": "def a2s(a):\n    \"\"\"\n     convert 3,3 a matrix to 6 element \"s\" list  (see Tauxe 1998)\n    \"\"\"\n    s = np.zeros((6,), 'f')  # make the a matrix\n    for i in range(3):\n        s[i] = a[i][i]\n    s[3] = a[0][1]\n    s[4] = a[1][2]\n    s[5] = a[0][2]\n    return s", "code_tokens": "def a2s ( a ) : s = np . zeros ( ( 6 , ) , 'f' ) # make the a matrix for i in range ( 3 ) : s [ i ] = a [ i ] [ i ] s [ 3 ] = a [ 0 ] [ 1 ] s [ 4 ] = a [ 1 ] [ 2 ] s [ 5 ] = a [ 0 ] [ 2 ] return s", "docstring_tokens": "convert 3 3 a matrix to 6 element s list ( see Tauxe 1998 )", "label": 0}, {"idx": "cosqa-train-347", "doc": "python for multiple iterables", "code": "def concat(cls, iterables):\n    \"\"\"\n    Similar to #itertools.chain.from_iterable().\n    \"\"\"\n\n    def generator():\n      for it in iterables:\n        for element in it:\n          yield element\n    return cls(generator())", "code_tokens": "def concat ( cls , iterables ) : def generator ( ) : for it in iterables : for element in it : yield element return cls ( generator ( ) )", "docstring_tokens": "Similar to #itertools . chain . from_iterable () .", "label": 0}, {"idx": "cosqa-train-348", "doc": "create a dict as ordered dict in python", "code": "def format_result(input):\n        \"\"\"From: http://stackoverflow.com/questions/13062300/convert-a-dict-to-sorted-dict-in-python\n        \"\"\"\n        items = list(iteritems(input))\n        return OrderedDict(sorted(items, key=lambda x: x[0]))", "code_tokens": "def format_result ( input ) : items = list ( iteritems ( input ) ) return OrderedDict ( sorted ( items , key = lambda x : x [ 0 ] ) )", "docstring_tokens": "From : http : // stackoverflow . com / questions / 13062300 / convert - a - dict - to - sorted - dict - in - python", "label": 0}, {"idx": "cosqa-train-349", "doc": "python for sql server bulk load", "code": "def bulk_query(self, query, *multiparams):\n        \"\"\"Bulk insert or update.\"\"\"\n\n        with self.get_connection() as conn:\n            conn.bulk_query(query, *multiparams)", "code_tokens": "def bulk_query ( self , query , * multiparams ) : with self . get_connection ( ) as conn : conn . bulk_query ( query , * multiparams )", "docstring_tokens": "Bulk insert or update .", "label": 0}, {"idx": "cosqa-train-350", "doc": "create a trie with a words python", "code": "def Trie(S):\n    \"\"\"\n    :param S: set of words\n    :returns: trie containing all words from S\n    :complexity: linear in total word sizes from S\n    \"\"\"\n    T = None\n    for w in S:\n        T = add(T, w)\n    return T", "code_tokens": "def Trie ( S ) : T = None for w in S : T = add ( T , w ) return T", "docstring_tokens": ": param S : set of words : returns : trie containing all words from S : complexity : linear in total word sizes from S", "label": 0}, {"idx": "cosqa-train-351", "doc": "python foreign key to a foreign key", "code": "def __set__(self, instance, value):\n        \"\"\" Set a related object for an instance. \"\"\"\n\n        self.map[id(instance)] = (weakref.ref(instance), value)", "code_tokens": "def __set__ ( self , instance , value ) : self . map [ id ( instance ) ] = ( weakref . ref ( instance ) , value )", "docstring_tokens": "Set a related object for an instance .", "label": 1}, {"idx": "cosqa-train-352", "doc": "create an array in python without numpy", "code": "def recarray(self):\n        \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"\n        return numpy.rec.fromrecords(self.records, names=self.names)", "code_tokens": "def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "docstring_tokens": "Returns data as : class : numpy . recarray .", "label": 1}, {"idx": "cosqa-train-353", "doc": "python fork output incomplete", "code": "def go_to_background():\n    \"\"\" Daemonize the running process. \"\"\"\n    try:\n        if os.fork():\n            sys.exit()\n    except OSError as errmsg:\n        LOGGER.error('Fork failed: {0}'.format(errmsg))\n        sys.exit('Fork failed')", "code_tokens": "def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "docstring_tokens": "Daemonize the running process .", "label": 0}, {"idx": "cosqa-train-354", "doc": "create automatic unique id in python", "code": "def generate_unique_host_id():\n    \"\"\"Generate a unique ID, that is somewhat guaranteed to be unique among all\n    instances running at the same time.\"\"\"\n    host = \".\".join(reversed(socket.gethostname().split(\".\")))\n    pid = os.getpid()\n    return \"%s.%d\" % (host, pid)", "code_tokens": "def generate_unique_host_id ( ) : host = \".\" . join ( reversed ( socket . gethostname ( ) . split ( \".\" ) ) ) pid = os . getpid ( ) return \"%s.%d\" % ( host , pid )", "docstring_tokens": "Generate a unique ID that is somewhat guaranteed to be unique among all instances running at the same time .", "label": 0}, {"idx": "cosqa-train-355", "doc": "python form data to dict", "code": "def compress(self, data_list):\n        \"\"\"\n        Return the cleaned_data of the form, everything should already be valid\n        \"\"\"\n        data = {}\n        if data_list:\n            return dict(\n                (f.name, data_list[i]) for i, f in enumerate(self.form))\n        return data", "code_tokens": "def compress ( self , data_list ) : data = { } if data_list : return dict ( ( f . name , data_list [ i ] ) for i , f in enumerate ( self . form ) ) return data", "docstring_tokens": "Return the cleaned_data of the form everything should already be valid", "label": 0}, {"idx": "cosqa-train-356", "doc": "create database postgres python sqlalchemy", "code": "def init_db():\n    \"\"\"\n    Drops and re-creates the SQL schema\n    \"\"\"\n    db.drop_all()\n    db.configure_mappers()\n    db.create_all()\n    db.session.commit()", "code_tokens": "def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )", "docstring_tokens": "Drops and re - creates the SQL schema", "label": 0}, {"idx": "cosqa-train-357", "doc": "python format string pass varialbes", "code": "def safe_format(s, **kwargs):\n  \"\"\"\n  :type s str\n  \"\"\"\n  return string.Formatter().vformat(s, (), defaultdict(str, **kwargs))", "code_tokens": "def safe_format ( s , * * kwargs ) : return string . Formatter ( ) . vformat ( s , ( ) , defaultdict ( str , * * kwargs ) )", "docstring_tokens": ": type s str", "label": 0}, {"idx": "cosqa-train-358", "doc": "create dictionary python unique key", "code": "def _init_unique_sets(self):\n        \"\"\"Initialise sets used for uniqueness checking.\"\"\"\n\n        ks = dict()\n        for t in self._unique_checks:\n            key = t[0]\n            ks[key] = set() # empty set\n        return ks", "code_tokens": "def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks", "docstring_tokens": "Initialise sets used for uniqueness checking .", "label": 0}, {"idx": "cosqa-train-359", "doc": "python formatting a long line", "code": "def straight_line_show(title, length=100, linestyle=\"=\", pad=0):\n        \"\"\"Print a formatted straight line.\n        \"\"\"\n        print(StrTemplate.straight_line(\n            title=title, length=length, linestyle=linestyle, pad=pad))", "code_tokens": "def straight_line_show ( title , length = 100 , linestyle = \"=\" , pad = 0 ) : print ( StrTemplate . straight_line ( title = title , length = length , linestyle = linestyle , pad = pad ) )", "docstring_tokens": "Print a formatted straight line .", "label": 0}, {"idx": "cosqa-train-360", "doc": "create executable python script directly instead of chmod", "code": "def make_executable(script_path):\n    \"\"\"Make `script_path` executable.\n\n    :param script_path: The file to change\n    \"\"\"\n    status = os.stat(script_path)\n    os.chmod(script_path, status.st_mode | stat.S_IEXEC)", "code_tokens": "def make_executable ( script_path ) : status = os . stat ( script_path ) os . chmod ( script_path , status . st_mode | stat . S_IEXEC )", "docstring_tokens": "Make script_path executable .", "label": 0}, {"idx": "cosqa-train-361", "doc": "python formatting code into 2 lines", "code": "def  make_html_code( self, lines ):\n        \"\"\" convert a code sequence to HTML \"\"\"\n        line = code_header + '\\n'\n        for l in lines:\n            line = line + html_quote( l ) + '\\n'\n\n        return line + code_footer", "code_tokens": "def make_html_code ( self , lines ) : line = code_header + '\\n' for l in lines : line = line + html_quote ( l ) + '\\n' return line + code_footer", "docstring_tokens": "convert a code sequence to HTML", "label": 0}, {"idx": "cosqa-train-362", "doc": "create matrix from vectors python3", "code": "def cross_product_matrix(vec):\n    \"\"\"Returns a 3x3 cross-product matrix from a 3-element vector.\"\"\"\n    return np.array([[0, -vec[2], vec[1]],\n                     [vec[2], 0, -vec[0]],\n                     [-vec[1], vec[0], 0]])", "code_tokens": "def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )", "docstring_tokens": "Returns a 3x3 cross - product matrix from a 3 - element vector .", "label": 0}, {"idx": "cosqa-train-363", "doc": "python found to nearest integer", "code": "def index_nearest(value, array):\n    \"\"\"\n    expects a _n.array\n    returns the global minimum of (value-array)^2\n    \"\"\"\n\n    a = (array-value)**2\n    return index(a.min(), a)", "code_tokens": "def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )", "docstring_tokens": "expects a _n . array returns the global minimum of ( value - array ) ^2", "label": 0}, {"idx": "cosqa-train-364", "doc": "create parse args python script", "code": "def main(args=sys.argv):\n    \"\"\"\n    main entry point for the jardiff CLI\n    \"\"\"\n\n    parser = create_optparser(args[0])\n    return cli(parser.parse_args(args[1:]))", "code_tokens": "def main ( args = sys . argv ) : parser = create_optparser ( args [ 0 ] ) return cli ( parser . parse_args ( args [ 1 : ] ) )", "docstring_tokens": "main entry point for the jardiff CLI", "label": 0}, {"idx": "cosqa-train-365", "doc": "python free unused numpy array memory", "code": "def free(self):\n        \"\"\"Free the underlying C array\"\"\"\n        if self._ptr is None:\n            return\n        Gauged.array_free(self.ptr)\n        FloatArray.ALLOCATIONS -= 1\n        self._ptr = None", "code_tokens": "def free ( self ) : if self . _ptr is None : return Gauged . array_free ( self . ptr ) FloatArray . ALLOCATIONS -= 1 self . _ptr = None", "docstring_tokens": "Free the underlying C array", "label": 0}, {"idx": "cosqa-train-366", "doc": "create polygon from lists of points python", "code": "def from_points(cls, list_of_lists):\n        \"\"\"\n        Creates a *Polygon* instance out of a list of lists, each sublist being populated with\n        `pyowm.utils.geo.Point` instances\n        :param list_of_lists: list\n        :type: list_of_lists: iterable_of_polygons\n        :returns:  a *Polygon* instance\n\n        \"\"\"\n        result = []\n        for l in list_of_lists:\n            curve = []\n            for point in l:\n                curve.append((point.lon, point.lat))\n            result.append(curve)\n        return Polygon(result)", "code_tokens": "def from_points ( cls , list_of_lists ) : result = [ ] for l in list_of_lists : curve = [ ] for point in l : curve . append ( ( point . lon , point . lat ) ) result . append ( curve ) return Polygon ( result )", "docstring_tokens": "Creates a * Polygon * instance out of a list of lists each sublist being populated with pyowm . utils . geo . Point instances : param list_of_lists : list : type : list_of_lists : iterable_of_polygons : returns : a * Polygon * instance", "label": 1}, {"idx": "cosqa-train-367", "doc": "python ftp login and get file", "code": "def connect():\n    \"\"\"Connect to FTP server, login and return an ftplib.FTP instance.\"\"\"\n    ftp_class = ftplib.FTP if not SSL else ftplib.FTP_TLS\n    ftp = ftp_class(timeout=TIMEOUT)\n    ftp.connect(HOST, PORT)\n    ftp.login(USER, PASSWORD)\n    if SSL:\n        ftp.prot_p()  # secure data connection\n    return ftp", "code_tokens": "def connect ( ) : ftp_class = ftplib . FTP if not SSL else ftplib . FTP_TLS ftp = ftp_class ( timeout = TIMEOUT ) ftp . connect ( HOST , PORT ) ftp . login ( USER , PASSWORD ) if SSL : ftp . prot_p ( ) # secure data connection return ftp", "docstring_tokens": "Connect to FTP server login and return an ftplib . FTP instance .", "label": 0}, {"idx": "cosqa-train-368", "doc": "create temporary directory in python with a specific name", "code": "def tmpfile(prefix, direc):\n    \"\"\"Returns the path to a newly created temporary file.\"\"\"\n    return tempfile.mktemp(prefix=prefix, suffix='.pdb', dir=direc)", "code_tokens": "def tmpfile ( prefix , direc ) : return tempfile . mktemp ( prefix = prefix , suffix = '.pdb' , dir = direc )", "docstring_tokens": "Returns the path to a newly created temporary file .", "label": 0}, {"idx": "cosqa-train-369", "doc": "python ftp server user name and password", "code": "def connect(host, port, username, password):\n        \"\"\"Connect and login to an FTP server and return ftplib.FTP object.\"\"\"\n        # Instantiate ftplib client\n        session = ftplib.FTP()\n\n        # Connect to host without auth\n        session.connect(host, port)\n\n        # Authenticate connection\n        session.login(username, password)\n        return session", "code_tokens": "def connect ( host , port , username , password ) : # Instantiate ftplib client session = ftplib . FTP ( ) # Connect to host without auth session . connect ( host , port ) # Authenticate connection session . login ( username , password ) return session", "docstring_tokens": "Connect and login to an FTP server and return ftplib . FTP object .", "label": 0}, {"idx": "cosqa-train-370", "doc": "create unique list from a list in python", "code": "def unique_list(lst):\n    \"\"\"Make a list unique, retaining order of initial appearance.\"\"\"\n    uniq = []\n    for item in lst:\n        if item not in uniq:\n            uniq.append(item)\n    return uniq", "code_tokens": "def unique_list ( lst ) : uniq = [ ] for item in lst : if item not in uniq : uniq . append ( item ) return uniq", "docstring_tokens": "Make a list unique retaining order of initial appearance .", "label": 0}, {"idx": "cosqa-train-371", "doc": "python ftps implicit ssl", "code": "def connect():\n    \"\"\"Connect to FTP server, login and return an ftplib.FTP instance.\"\"\"\n    ftp_class = ftplib.FTP if not SSL else ftplib.FTP_TLS\n    ftp = ftp_class(timeout=TIMEOUT)\n    ftp.connect(HOST, PORT)\n    ftp.login(USER, PASSWORD)\n    if SSL:\n        ftp.prot_p()  # secure data connection\n    return ftp", "code_tokens": "def connect ( ) : ftp_class = ftplib . FTP if not SSL else ftplib . FTP_TLS ftp = ftp_class ( timeout = TIMEOUT ) ftp . connect ( HOST , PORT ) ftp . login ( USER , PASSWORD ) if SSL : ftp . prot_p ( ) # secure data connection return ftp", "docstring_tokens": "Connect to FTP server login and return an ftplib . FTP instance .", "label": 0}, {"idx": "cosqa-train-372", "doc": "creating a function to fit exponential curve python", "code": "def exp_fit_fun(x, a, tau, c):\n    \"\"\"Function used to fit the exponential decay.\"\"\"\n    # pylint: disable=invalid-name\n    return a * np.exp(-x / tau) + c", "code_tokens": "def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "docstring_tokens": "Function used to fit the exponential decay .", "label": 0}, {"idx": "cosqa-train-373", "doc": "python fucntion if every element is true", "code": "def All(sequence):\n  \"\"\"\n  :param sequence: Any sequence whose elements can be evaluated as booleans.\n  :returns: true if all elements of the sequence satisfy True and x.\n  \"\"\"\n  return bool(reduce(lambda x, y: x and y, sequence, True))", "code_tokens": "def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )", "docstring_tokens": ": param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x .", "label": 0}, {"idx": "cosqa-train-374", "doc": "creating a matrix in python tensorflow", "code": "def zero_state(self, batch_size):\n        \"\"\" Initial state of the network \"\"\"\n        return torch.zeros(batch_size, self.state_dim, dtype=torch.float32)", "code_tokens": "def zero_state ( self , batch_size ) : return torch . zeros ( batch_size , self . state_dim , dtype = torch . float32 )", "docstring_tokens": "Initial state of the network", "label": 0}, {"idx": "cosqa-train-375", "doc": "python fully qualified filename", "code": "def _fullname(o):\n    \"\"\"Return the fully-qualified name of a function.\"\"\"\n    return o.__module__ + \".\" + o.__name__ if o.__module__ else o.__name__", "code_tokens": "def _fullname ( o ) : return o . __module__ + \".\" + o . __name__ if o . __module__ else o . __name__", "docstring_tokens": "Return the fully - qualified name of a function .", "label": 0}, {"idx": "cosqa-train-376", "doc": "creating an index file in python", "code": "def create_index(config):\n    \"\"\"Create the root index.\"\"\"\n    filename = pathlib.Path(config.cache_path) / \"index.json\"\n    index = {\"version\": __version__}\n    with open(filename, \"w\") as out:\n        out.write(json.dumps(index, indent=2))", "code_tokens": "def create_index ( config ) : filename = pathlib . Path ( config . cache_path ) / \"index.json\" index = { \"version\" : __version__ } with open ( filename , \"w\" ) as out : out . write ( json . dumps ( index , indent = 2 ) )", "docstring_tokens": "Create the root index .", "label": 0}, {"idx": "cosqa-train-377", "doc": "python function states whether a list is sorted", "code": "def issorted(list_, op=operator.le):\n    \"\"\"\n    Determines if a list is sorted\n\n    Args:\n        list_ (list):\n        op (func): sorted operation (default=operator.le)\n\n    Returns:\n        bool : True if the list is sorted\n    \"\"\"\n    return all(op(list_[ix], list_[ix + 1]) for ix in range(len(list_) - 1))", "code_tokens": "def issorted ( list_ , op = operator . le ) : return all ( op ( list_ [ ix ] , list_ [ ix + 1 ] ) for ix in range ( len ( list_ ) - 1 ) )", "docstring_tokens": "Determines if a list is sorted", "label": 0}, {"idx": "cosqa-train-378", "doc": "credit card number check digit python", "code": "def is_valid(number):\n    \"\"\"determines whether the card number is valid.\"\"\"\n    n = str(number)\n    if not n.isdigit():\n        return False\n    return int(n[-1]) == get_check_digit(n[:-1])", "code_tokens": "def is_valid ( number ) : n = str ( number ) if not n . isdigit ( ) : return False return int ( n [ - 1 ] ) == get_check_digit ( n [ : - 1 ] )", "docstring_tokens": "determines whether the card number is valid .", "label": 0}, {"idx": "cosqa-train-379", "doc": "python function stating with underscore", "code": "def us2mc(string):\n    \"\"\"Transform an underscore_case string to a mixedCase string\"\"\"\n    return re.sub(r'_([a-z])', lambda m: (m.group(1).upper()), string)", "code_tokens": "def us2mc ( string ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , string )", "docstring_tokens": "Transform an underscore_case string to a mixedCase string", "label": 0}, {"idx": "cosqa-train-380", "doc": "csv to yaml python", "code": "def csv2yaml(in_file, out_file=None):\n    \"\"\"Convert a CSV SampleSheet to YAML run_info format.\n    \"\"\"\n    if out_file is None:\n        out_file = \"%s.yaml\" % os.path.splitext(in_file)[0]\n    barcode_ids = _generate_barcode_ids(_read_input_csv(in_file))\n    lanes = _organize_lanes(_read_input_csv(in_file), barcode_ids)\n    with open(out_file, \"w\") as out_handle:\n        out_handle.write(yaml.safe_dump(lanes, default_flow_style=False))\n    return out_file", "code_tokens": "def csv2yaml ( in_file , out_file = None ) : if out_file is None : out_file = \"%s.yaml\" % os . path . splitext ( in_file ) [ 0 ] barcode_ids = _generate_barcode_ids ( _read_input_csv ( in_file ) ) lanes = _organize_lanes ( _read_input_csv ( in_file ) , barcode_ids ) with open ( out_file , \"w\" ) as out_handle : out_handle . write ( yaml . safe_dump ( lanes , default_flow_style = False ) ) return out_file", "docstring_tokens": "Convert a CSV SampleSheet to YAML run_info format .", "label": 0}, {"idx": "cosqa-train-381", "doc": "python function that returns the average of each length of words in a string", "code": "def get_average_length_of_string(strings):\n    \"\"\"Computes average length of words\n\n    :param strings: list of words\n    :return: Average length of word on list\n    \"\"\"\n    if not strings:\n        return 0\n\n    return sum(len(word) for word in strings) / len(strings)", "code_tokens": "def get_average_length_of_string ( strings ) : if not strings : return 0 return sum ( len ( word ) for word in strings ) / len ( strings )", "docstring_tokens": "Computes average length of words", "label": 0}, {"idx": "cosqa-train-382", "doc": "cumulative sum of list python", "code": "def cumsum(inlist):\n    \"\"\"\nReturns a list consisting of the cumulative sum of the items in the\npassed list.\n\nUsage:   lcumsum(inlist)\n\"\"\"\n    newlist = copy.deepcopy(inlist)\n    for i in range(1, len(newlist)):\n        newlist[i] = newlist[i] + newlist[i - 1]\n    return newlist", "code_tokens": "def cumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist", "docstring_tokens": "Returns a list consisting of the cumulative sum of the items in the passed list .", "label": 1}, {"idx": "cosqa-train-383", "doc": "python function to bold the print statemetn", "code": "def good(txt):\n    \"\"\"Print, emphasized 'good', the given 'txt' message\"\"\"\n\n    print(\"%s# %s%s%s\" % (PR_GOOD_CC, get_time_stamp(), txt, PR_NC))\n    sys.stdout.flush()", "code_tokens": "def good ( txt ) : print ( \"%s# %s%s%s\" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "docstring_tokens": "Print emphasized good the given txt message", "label": 0}, {"idx": "cosqa-train-384", "doc": "cursor movement in game using python", "code": "def move_to(self, ypos, xpos):\n        \"\"\"\n            move the cursor to the given co-ordinates.  Co-ordinates are 1\n            based, as listed in the status area of the terminal.\n        \"\"\"\n        # the screen's co-ordinates are 1 based, but the command is 0 based\n        xpos -= 1\n        ypos -= 1\n        self.exec_command(\"MoveCursor({0}, {1})\".format(ypos, xpos).encode(\"ascii\"))", "code_tokens": "def move_to ( self , ypos , xpos ) : # the screen's co-ordinates are 1 based, but the command is 0 based xpos -= 1 ypos -= 1 self . exec_command ( \"MoveCursor({0}, {1})\" . format ( ypos , xpos ) . encode ( \"ascii\" ) )", "docstring_tokens": "move the cursor to the given co - ordinates . Co - ordinates are 1 based as listed in the status area of the terminal .", "label": 0}, {"idx": "cosqa-train-385", "doc": "python function to get object attributes", "code": "def dict_from_object(obj: object):\n    \"\"\"Convert a object into dictionary with all of its readable attributes.\"\"\"\n\n    # If object is a dict instance, no need to convert.\n    return (obj if isinstance(obj, dict)\n            else {attr: getattr(obj, attr)\n                  for attr in dir(obj) if not attr.startswith('_')})", "code_tokens": "def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )", "docstring_tokens": "Convert a object into dictionary with all of its readable attributes .", "label": 0}, {"idx": "cosqa-train-386", "doc": "cursor position graphics python", "code": "def ensure_hbounds(self):\n        \"\"\"Ensure the cursor is within horizontal screen bounds.\"\"\"\n        self.cursor.x = min(max(0, self.cursor.x), self.columns - 1)", "code_tokens": "def ensure_hbounds ( self ) : self . cursor . x = min ( max ( 0 , self . cursor . x ) , self . columns - 1 )", "docstring_tokens": "Ensure the cursor is within horizontal screen bounds .", "label": 1}, {"idx": "cosqa-train-387", "doc": "python function to remove spaces in a string", "code": "def strip_spaces(s):\n    \"\"\" Strip excess spaces from a string \"\"\"\n    return u\" \".join([c for c in s.split(u' ') if c])", "code_tokens": "def strip_spaces ( s ) : return u\" \" . join ( [ c for c in s . split ( u' ' ) if c ] )", "docstring_tokens": "Strip excess spaces from a string", "label": 0}, {"idx": "cosqa-train-388", "doc": "custom scatter plot marker with png python", "code": "def scatter(self, *args, **kwargs):\n        \"\"\"Add a scatter plot.\"\"\"\n        cls = _make_class(ScatterVisual,\n                          _default_marker=kwargs.pop('marker', None),\n                          )\n        return self._add_item(cls, *args, **kwargs)", "code_tokens": "def scatter ( self , * args , * * kwargs ) : cls = _make_class ( ScatterVisual , _default_marker = kwargs . pop ( 'marker' , None ) , ) return self . _add_item ( cls , * args , * * kwargs )", "docstring_tokens": "Add a scatter plot .", "label": 0}, {"idx": "cosqa-train-389", "doc": "python function to upload file to s3", "code": "def download_file_from_bucket(self, bucket, file_path, key):\n        \"\"\" Download file from S3 Bucket \"\"\"\n        with open(file_path, 'wb') as data:\n            self.__s3.download_fileobj(bucket, key, data)\n            return file_path", "code_tokens": "def download_file_from_bucket ( self , bucket , file_path , key ) : with open ( file_path , 'wb' ) as data : self . __s3 . download_fileobj ( bucket , key , data ) return file_path", "docstring_tokens": "Download file from S3 Bucket", "label": 0}, {"idx": "cosqa-train-390", "doc": "cv2 python load image", "code": "def imdecode(image_path):\n    \"\"\"Return BGR image read by opencv\"\"\"\n    import os\n    assert os.path.exists(image_path), image_path + ' not found'\n    im = cv2.imread(image_path)\n    return im", "code_tokens": "def imdecode ( image_path ) : import os assert os . path . exists ( image_path ) , image_path + ' not found' im = cv2 . imread ( image_path ) return im", "docstring_tokens": "Return BGR image read by opencv", "label": 0}, {"idx": "cosqa-train-391", "doc": "python function use variable defined in outer scope", "code": "def ex(self, cmd):\n        \"\"\"Execute a normal python statement in user namespace.\"\"\"\n        with self.builtin_trap:\n            exec cmd in self.user_global_ns, self.user_ns", "code_tokens": "def ex ( self , cmd ) : with self . builtin_trap : exec cmd in self . user_global_ns , self . user_ns", "docstring_tokens": "Execute a normal python statement in user namespace .", "label": 0}, {"idx": "cosqa-train-392", "doc": "cython python2 bool function", "code": "def isbinary(*args):\n    \"\"\"Checks if value can be part of binary/bitwise operations.\"\"\"\n    return all(map(lambda c: isnumber(c) or isbool(c), args))", "code_tokens": "def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )", "docstring_tokens": "Checks if value can be part of binary / bitwise operations .", "label": 1}, {"idx": "cosqa-train-393", "doc": "python function used to explode a string into a list of strings", "code": "def split(s):\n  \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"\n  l = [_split(x) for x in _SPLIT_RE.split(s)]\n  return [item for sublist in l for item in sublist]", "code_tokens": "def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Uses dynamic programming to infer the location of spaces in a string without spaces .", "label": 0}, {"idx": "cosqa-train-394", "doc": "date to jday python", "code": "def dt2jd(dt):\n    \"\"\"Convert datetime to julian date\n    \"\"\"\n    a = (14 - dt.month)//12\n    y = dt.year + 4800 - a\n    m = dt.month + 12*a - 3\n    return dt.day + ((153*m + 2)//5) + 365*y + y//4 - y//100 + y//400 - 32045", "code_tokens": "def dt2jd ( dt ) : a = ( 14 - dt . month ) // 12 y = dt . year + 4800 - a m = dt . month + 12 * a - 3 return dt . day + ( ( 153 * m + 2 ) // 5 ) + 365 * y + y // 4 - y // 100 + y // 400 - 32045", "docstring_tokens": "Convert datetime to julian date", "label": 0}, {"idx": "cosqa-train-395", "doc": "python gaussian filter blur image", "code": "def smooth_gaussian(image, sigma=1):\n    \"\"\"Returns Gaussian smoothed image.\n\n    :param image: numpy array or :class:`jicimagelib.image.Image`\n    :param sigma: standard deviation\n    :returns: :class:`jicimagelib.image.Image`\n    \"\"\"\n    return scipy.ndimage.filters.gaussian_filter(image, sigma=sigma, mode=\"nearest\")", "code_tokens": "def smooth_gaussian ( image , sigma = 1 ) : return scipy . ndimage . filters . gaussian_filter ( image , sigma = sigma , mode = \"nearest\" )", "docstring_tokens": "Returns Gaussian smoothed image .", "label": 0}, {"idx": "cosqa-train-396", "doc": "datetime to json in python", "code": "def _time_to_json(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\"\"\"\n    if isinstance(value, datetime.time):\n        value = value.isoformat()\n    return value", "code_tokens": "def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 0}, {"idx": "cosqa-train-397", "doc": "python gaussian pdf plot", "code": "def EvalGaussianPdf(x, mu, sigma):\n    \"\"\"Computes the unnormalized PDF of the normal distribution.\n\n    x: value\n    mu: mean\n    sigma: standard deviation\n    \n    returns: float probability density\n    \"\"\"\n    return scipy.stats.norm.pdf(x, mu, sigma)", "code_tokens": "def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )", "docstring_tokens": "Computes the unnormalized PDF of the normal distribution .", "label": 0}, {"idx": "cosqa-train-398", "doc": "datetime to timestamp ironpython", "code": "def convert_timestamp(timestamp):\n    \"\"\"\n    Converts bokehJS timestamp to datetime64.\n    \"\"\"\n    datetime = dt.datetime.utcfromtimestamp(timestamp/1000.)\n    return np.datetime64(datetime.replace(tzinfo=None))", "code_tokens": "def convert_timestamp ( timestamp ) : datetime = dt . datetime . utcfromtimestamp ( timestamp / 1000. ) return np . datetime64 ( datetime . replace ( tzinfo = None ) )", "docstring_tokens": "Converts bokehJS timestamp to datetime64 .", "label": 0}, {"idx": "cosqa-train-399", "doc": "python generate a string based on a list", "code": "def _make_cmd_list(cmd_list):\n    \"\"\"\n    Helper function to easily create the proper json formated string from a list of strs\n    :param cmd_list: list of strings\n    :return: str json formatted\n    \"\"\"\n    cmd = ''\n    for i in cmd_list:\n        cmd = cmd + '\"' + i + '\",'\n    cmd = cmd[:-1]\n    return cmd", "code_tokens": "def _make_cmd_list ( cmd_list ) : cmd = '' for i in cmd_list : cmd = cmd + '\"' + i + '\",' cmd = cmd [ : - 1 ] return cmd", "docstring_tokens": "Helper function to easily create the proper json formated string from a list of strs : param cmd_list : list of strings : return : str json formatted", "label": 0}, {"idx": "cosqa-train-400", "doc": "decision tree for the data with all the categorical data in python", "code": "def accuracy(self):\n        \"\"\"\n        Calculates the accuracy of the tree by comparing\n        the model predictions to the dataset\n        (TP + TN) / (TP + TN + FP + FN) == (T / (T + F))\n        \"\"\"\n        sub_observed = np.array([self.observed.metadata[i] for i in self.observed.arr])\n        return float((self.model_predictions() == sub_observed).sum()) / self.data_size", "code_tokens": "def accuracy ( self ) : sub_observed = np . array ( [ self . observed . metadata [ i ] for i in self . observed . arr ] ) return float ( ( self . model_predictions ( ) == sub_observed ) . sum ( ) ) / self . data_size", "docstring_tokens": "Calculates the accuracy of the tree by comparing the model predictions to the dataset ( TP + TN ) / ( TP + TN + FP + FN ) == ( T / ( T + F ))", "label": 0}, {"idx": "cosqa-train-401", "doc": "python generate code from json schema definition", "code": "def cli(yamlfile, format, context):\n    \"\"\" Generate JSONLD file from biolink schema \"\"\"\n    print(JSONLDGenerator(yamlfile, format).serialize(context=context))", "code_tokens": "def cli ( yamlfile , format , context ) : print ( JSONLDGenerator ( yamlfile , format ) . serialize ( context = context ) )", "docstring_tokens": "Generate JSONLD file from biolink schema", "label": 0}, {"idx": "cosqa-train-402", "doc": "declaring a hash in python", "code": "def double_sha256(data):\n    \"\"\"A standard compound hash.\"\"\"\n    return bytes_as_revhex(hashlib.sha256(hashlib.sha256(data).digest()).digest())", "code_tokens": "def double_sha256 ( data ) : return bytes_as_revhex ( hashlib . sha256 ( hashlib . sha256 ( data ) . digest ( ) ) . digest ( ) )", "docstring_tokens": "A standard compound hash .", "label": 0}, {"idx": "cosqa-train-403", "doc": "python generate list of cononants", "code": "def get_cantons(self):\n        \"\"\"\n        Return the list of unique cantons, sorted by name.\n        \"\"\"\n        return sorted(list(set([\n            location.canton for location in self.get_locations().values()\n        ])))", "code_tokens": "def get_cantons ( self ) : return sorted ( list ( set ( [ location . canton for location in self . get_locations ( ) . values ( ) ] ) ) )", "docstring_tokens": "Return the list of unique cantons sorted by name .", "label": 0}, {"idx": "cosqa-train-404", "doc": "default function arg in python", "code": "def get_default_args(func):\n    \"\"\"\n    returns a dictionary of arg_name:default_values for the input function\n    \"\"\"\n    args, varargs, keywords, defaults = getargspec_no_self(func)\n    return dict(zip(args[-len(defaults):], defaults))", "code_tokens": "def get_default_args ( func ) : args , varargs , keywords , defaults = getargspec_no_self ( func ) return dict ( zip ( args [ - len ( defaults ) : ] , defaults ) )", "docstring_tokens": "returns a dictionary of arg_name : default_values for the input function", "label": 0}, {"idx": "cosqa-train-405", "doc": "python generate method name", "code": "def get_method_name(method):\n    \"\"\"\n    Returns given method name.\n\n    :param method: Method to retrieve the name.\n    :type method: object\n    :return: Method name.\n    :rtype: unicode\n    \"\"\"\n\n    name = get_object_name(method)\n    if name.startswith(\"__\") and not name.endswith(\"__\"):\n        name = \"_{0}{1}\".format(get_object_name(method.im_class), name)\n    return name", "code_tokens": "def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( \"__\" ) and not name . endswith ( \"__\" ) : name = \"_{0}{1}\" . format ( get_object_name ( method . im_class ) , name ) return name", "docstring_tokens": "Returns given method name .", "label": 0}, {"idx": "cosqa-train-406", "doc": "default value in argparse python", "code": "def _add_default_arguments(parser):\n    \"\"\"Add the default arguments to the parser.\n\n    :param argparse.ArgumentParser parser: The argument parser\n\n    \"\"\"\n    parser.add_argument('-c', '--config', action='store', dest='config',\n                        help='Path to the configuration file')\n    parser.add_argument('-f', '--foreground', action='store_true', dest='foreground',\n                        help='Run the application interactively')", "code_tokens": "def _add_default_arguments ( parser ) : parser . add_argument ( '-c' , '--config' , action = 'store' , dest = 'config' , help = 'Path to the configuration file' ) parser . add_argument ( '-f' , '--foreground' , action = 'store_true' , dest = 'foreground' , help = 'Run the application interactively' )", "docstring_tokens": "Add the default arguments to the parser .", "label": 0}, {"idx": "cosqa-train-407", "doc": "python get all callables from an object", "code": "def get_methods(*objs):\n    \"\"\" Return the names of all callable attributes of an object\"\"\"\n    return set(\n        attr\n        for obj in objs\n        for attr in dir(obj)\n        if not attr.startswith('_') and callable(getattr(obj, attr))\n    )", "code_tokens": "def get_methods ( * objs ) : return set ( attr for obj in objs for attr in dir ( obj ) if not attr . startswith ( '_' ) and callable ( getattr ( obj , attr ) ) )", "docstring_tokens": "Return the names of all callable attributes of an object", "label": 0}, {"idx": "cosqa-train-408", "doc": "define an empty column in a data frame in python", "code": "def add_blank_row(self, label):\n        \"\"\"\n        Add a blank row with only an index value to self.df.\n        This is done inplace.\n        \"\"\"\n        col_labels = self.df.columns\n        blank_item = pd.Series({}, index=col_labels, name=label)\n        # use .loc to add in place (append won't do that)\n        self.df.loc[blank_item.name] = blank_item\n        return self.df", "code_tokens": "def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df", "docstring_tokens": "Add a blank row with only an index value to self . df . This is done inplace .", "label": 1}, {"idx": "cosqa-train-409", "doc": "python get all keys in a section configparser", "code": "def items(self, section_name):\n        \"\"\":return: list((option, value), ...) pairs of all items in the given section\"\"\"\n        return [(k, v) for k, v in super(GitConfigParser, self).items(section_name) if k != '__name__']", "code_tokens": "def items ( self , section_name ) : return [ ( k , v ) for k , v in super ( GitConfigParser , self ) . items ( section_name ) if k != '__name__' ]", "docstring_tokens": ": return : list (( option value ) ... ) pairs of all items in the given section", "label": 0}, {"idx": "cosqa-train-410", "doc": "delaunay triangulation polygon python", "code": "def computeDelaunayTriangulation(points):\n    \"\"\" Takes a list of point objects (which must have x and y fields).\n        Returns a list of 3-tuples: the indices of the points that form a\n        Delaunay triangle.\n    \"\"\"\n    siteList = SiteList(points)\n    context  = Context()\n    context.triangulate = True\n    voronoi(siteList,context)\n    return context.triangles", "code_tokens": "def computeDelaunayTriangulation ( points ) : siteList = SiteList ( points ) context = Context ( ) context . triangulate = True voronoi ( siteList , context ) return context . triangles", "docstring_tokens": "Takes a list of point objects ( which must have x and y fields ) . Returns a list of 3 - tuples : the indices of the points that form a Delaunay triangle .", "label": 0}, {"idx": "cosqa-train-411", "doc": "python get all keys in object", "code": "def get_keys_from_class(cc):\n    \"\"\"Return list of the key property names for a class \"\"\"\n    return [prop.name for prop in cc.properties.values() \\\n            if 'key' in prop.qualifiers]", "code_tokens": "def get_keys_from_class ( cc ) : return [ prop . name for prop in cc . properties . values ( ) if 'key' in prop . qualifiers ]", "docstring_tokens": "Return list of the key property names for a class", "label": 0}, {"idx": "cosqa-train-412", "doc": "delete a python virtual env", "code": "def rm(venv_name):\n    \"\"\" Removes the venv by name \"\"\"\n    inenv = InenvManager()\n    venv = inenv.get_venv(venv_name)\n    click.confirm(\"Delete dir {}\".format(venv.path))\n    shutil.rmtree(venv.path)", "code_tokens": "def rm ( venv_name ) : inenv = InenvManager ( ) venv = inenv . get_venv ( venv_name ) click . confirm ( \"Delete dir {}\" . format ( venv . path ) ) shutil . rmtree ( venv . path )", "docstring_tokens": "Removes the venv by name", "label": 0}, {"idx": "cosqa-train-413", "doc": "python get all the function names in this model", "code": "def columns(self):\n        \"\"\"Return names of all the addressable columns (including foreign keys) referenced in user supplied model\"\"\"\n        res = [col['name'] for col in self.column_definitions]\n        res.extend([col['name'] for col in self.foreign_key_definitions])\n        return res", "code_tokens": "def columns ( self ) : res = [ col [ 'name' ] for col in self . column_definitions ] res . extend ( [ col [ 'name' ] for col in self . foreign_key_definitions ] ) return res", "docstring_tokens": "Return names of all the addressable columns ( including foreign keys ) referenced in user supplied model", "label": 0}, {"idx": "cosqa-train-414", "doc": "delete all columns except one in python", "code": "def remove_non_magic_cols(self):\n        \"\"\"\n        Remove all non-MagIC columns from all tables.\n        \"\"\"\n        for table_name in self.tables:\n            table = self.tables[table_name]\n            table.remove_non_magic_cols_from_table()", "code_tokens": "def remove_non_magic_cols ( self ) : for table_name in self . tables : table = self . tables [ table_name ] table . remove_non_magic_cols_from_table ( )", "docstring_tokens": "Remove all non - MagIC columns from all tables .", "label": 0}, {"idx": "cosqa-train-415", "doc": "python get an objects id", "code": "def get_obj(ref):\n    \"\"\"Get object from string reference.\"\"\"\n    oid = int(ref)\n    return server.id2ref.get(oid) or server.id2obj[oid]", "code_tokens": "def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]", "docstring_tokens": "Get object from string reference .", "label": 0}, {"idx": "cosqa-train-416", "doc": "delete commas from a string python", "code": "def _split_comma_separated(string):\n    \"\"\"Return a set of strings.\"\"\"\n    return set(text.strip() for text in string.split(',') if text.strip())", "code_tokens": "def _split_comma_separated ( string ) : return set ( text . strip ( ) for text in string . split ( ',' ) if text . strip ( ) )", "docstring_tokens": "Return a set of strings .", "label": 1}, {"idx": "cosqa-train-417", "doc": "python get angle from x, y", "code": "def angle(x0, y0, x1, y1):\n    \"\"\" Returns the angle between two points.\n    \"\"\"\n    return degrees(atan2(y1-y0, x1-x0))", "code_tokens": "def angle ( x0 , y0 , x1 , y1 ) : return degrees ( atan2 ( y1 - y0 , x1 - x0 ) )", "docstring_tokens": "Returns the angle between two points .", "label": 0}, {"idx": "cosqa-train-418", "doc": "delete duplicates in an array python", "code": "def delete_duplicates(seq):\n    \"\"\"\n    Remove duplicates from an iterable, preserving the order.\n\n    Args:\n        seq: Iterable of various type.\n\n    Returns:\n        list: List of unique objects.\n\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "Remove duplicates from an iterable preserving the order .", "label": 0}, {"idx": "cosqa-train-419", "doc": "python get appropriate extension for file", "code": "def guess_extension(amimetype, normalize=False):\n    \"\"\"\n    Tries to guess extension for a mimetype.\n\n    @param amimetype: name of a mimetype\n    @time amimetype: string\n    @return: the extension\n    @rtype: string\n    \"\"\"\n    ext = _mimes.guess_extension(amimetype)\n    if ext and normalize:\n        # Normalize some common magic mis-interpreation\n        ext = {'.asc': '.txt', '.obj': '.bin'}.get(ext, ext)\n        from invenio.legacy.bibdocfile.api_normalizer import normalize_format\n        return normalize_format(ext)\n    return ext", "code_tokens": "def guess_extension ( amimetype , normalize = False ) : ext = _mimes . guess_extension ( amimetype ) if ext and normalize : # Normalize some common magic mis-interpreation ext = { '.asc' : '.txt' , '.obj' : '.bin' } . get ( ext , ext ) from invenio . legacy . bibdocfile . api_normalizer import normalize_format return normalize_format ( ext ) return ext", "docstring_tokens": "Tries to guess extension for a mimetype .", "label": 0}, {"idx": "cosqa-train-420", "doc": "delete flask data in python", "code": "def reset():\n    \"\"\"Delete the session and clear temporary directories\n\n    \"\"\"\n    shutil.rmtree(session['img_input_dir'])\n    shutil.rmtree(session['img_output_dir'])\n    session.clear()\n    return jsonify(ok='true')", "code_tokens": "def reset ( ) : shutil . rmtree ( session [ 'img_input_dir' ] ) shutil . rmtree ( session [ 'img_output_dir' ] ) session . clear ( ) return jsonify ( ok = 'true' )", "docstring_tokens": "Delete the session and clear temporary directories", "label": 0}, {"idx": "cosqa-train-421", "doc": "delete spaces and non number terms from a string python", "code": "def detokenize(s):\n    \"\"\" Detokenize a string by removing spaces before punctuation.\"\"\"\n    print(s)\n    s = re.sub(\"\\s+([;:,\\.\\?!])\", \"\\\\1\", s)\n    s = re.sub(\"\\s+(n't)\", \"\\\\1\", s)\n    return s", "code_tokens": "def detokenize ( s ) : print ( s ) s = re . sub ( \"\\s+([;:,\\.\\?!])\" , \"\\\\1\" , s ) s = re . sub ( \"\\s+(n't)\" , \"\\\\1\" , s ) return s", "docstring_tokens": "Detokenize a string by removing spaces before punctuation .", "label": 1}, {"idx": "cosqa-train-422", "doc": "python get colors in image", "code": "def get_colors(img):\n    \"\"\"\n    Returns a list of all the image's colors.\n    \"\"\"\n    w, h = img.size\n    return [color[:3] for count, color in img.convert('RGB').getcolors(w * h)]", "code_tokens": "def get_colors ( img ) : w , h = img . size return [ color [ : 3 ] for count , color in img . convert ( 'RGB' ) . getcolors ( w * h ) ]", "docstring_tokens": "Returns a list of all the image s colors .", "label": 0}, {"idx": "cosqa-train-423", "doc": "python get current process memory", "code": "def memory():\n    \"\"\"Determine memory specifications of the machine.\n\n    Returns\n    -------\n    mem_info : dictonary\n        Holds the current values for the total, free and used memory of the system.\n    \"\"\"\n\n    mem_info = dict()\n\n    for k, v in psutil.virtual_memory()._asdict().items():\n           mem_info[k] = int(v)\n           \n    return mem_info", "code_tokens": "def memory ( ) : mem_info = dict ( ) for k , v in psutil . virtual_memory ( ) . _asdict ( ) . items ( ) : mem_info [ k ] = int ( v ) return mem_info", "docstring_tokens": "Determine memory specifications of the machine .", "label": 0}, {"idx": "cosqa-train-424", "doc": "delete zeros in sparse matrix python", "code": "def check_precomputed_distance_matrix(X):\n    \"\"\"Perform check_array(X) after removing infinite values (numpy.inf) from the given distance matrix.\n    \"\"\"\n    tmp = X.copy()\n    tmp[np.isinf(tmp)] = 1\n    check_array(tmp)", "code_tokens": "def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "docstring_tokens": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix .", "label": 0}, {"idx": "cosqa-train-425", "doc": "python get day number of month", "code": "def calculate_month(birth_date):\n    \"\"\"\n    Calculates and returns a month number basing on PESEL standard.\n    \"\"\"\n    year = int(birth_date.strftime('%Y'))\n    month = int(birth_date.strftime('%m')) + ((int(year / 100) - 14) % 5) * 20\n\n    return month", "code_tokens": "def calculate_month ( birth_date ) : year = int ( birth_date . strftime ( '%Y' ) ) month = int ( birth_date . strftime ( '%m' ) ) + ( ( int ( year / 100 ) - 14 ) % 5 ) * 20 return month", "docstring_tokens": "Calculates and returns a month number basing on PESEL standard .", "label": 0}, {"idx": "cosqa-train-426", "doc": "delimit list by tabs in python", "code": "def linedelimited (inlist,delimiter):\n    \"\"\"\nReturns a string composed of elements in inlist, with each element\nseparated by 'delimiter.'  Used by function writedelimited.  Use '\\t'\nfor tab-delimiting.\n\nUsage:   linedelimited (inlist,delimiter)\n\"\"\"\n    outstr = ''\n    for item in inlist:\n        if type(item) != StringType:\n            item = str(item)\n        outstr = outstr + item + delimiter\n    outstr = outstr[0:-1]\n    return outstr", "code_tokens": "def linedelimited ( inlist , delimiter ) : outstr = '' for item in inlist : if type ( item ) != StringType : item = str ( item ) outstr = outstr + item + delimiter outstr = outstr [ 0 : - 1 ] return outstr", "docstring_tokens": "Returns a string composed of elements in inlist with each element separated by delimiter . Used by function writedelimited . Use \\ t for tab - delimiting .", "label": 0}, {"idx": "cosqa-train-427", "doc": "python get days in month", "code": "def get_month_start_end_day():\n    \"\"\"\n    Get the month start date a nd end date\n    \"\"\"\n    t = date.today()\n    n = mdays[t.month]\n    return (date(t.year, t.month, 1), date(t.year, t.month, n))", "code_tokens": "def get_month_start_end_day ( ) : t = date . today ( ) n = mdays [ t . month ] return ( date ( t . year , t . month , 1 ) , date ( t . year , t . month , n ) )", "docstring_tokens": "Get the month start date a nd end date", "label": 0}, {"idx": "cosqa-train-428", "doc": "dequeue check for item python", "code": "def dequeue(self, block=True):\n        \"\"\"Dequeue a record and return item.\"\"\"\n        return self.queue.get(block, self.queue_get_timeout)", "code_tokens": "def dequeue ( self , block = True ) : return self . queue . get ( block , self . queue_get_timeout )", "docstring_tokens": "Dequeue a record and return item .", "label": 0}, {"idx": "cosqa-train-429", "doc": "python get decorated function's value", "code": "def return_value(self, *args, **kwargs):\n        \"\"\"Extracts the real value to be returned from the wrapping callable.\n\n        :return: The value the double should return when called.\n        \"\"\"\n\n        self._called()\n        return self._return_value(*args, **kwargs)", "code_tokens": "def return_value ( self , * args , * * kwargs ) : self . _called ( ) return self . _return_value ( * args , * * kwargs )", "docstring_tokens": "Extracts the real value to be returned from the wrapping callable .", "label": 0}, {"idx": "cosqa-train-430", "doc": "detect char encoding python", "code": "def get_best_encoding(stream):\n    \"\"\"Returns the default stream encoding if not found.\"\"\"\n    rv = getattr(stream, 'encoding', None) or sys.getdefaultencoding()\n    if is_ascii_encoding(rv):\n        return 'utf-8'\n    return rv", "code_tokens": "def get_best_encoding ( stream ) : rv = getattr ( stream , 'encoding' , None ) or sys . getdefaultencoding ( ) if is_ascii_encoding ( rv ) : return 'utf-8' return rv", "docstring_tokens": "Returns the default stream encoding if not found .", "label": 0}, {"idx": "cosqa-train-431", "doc": "python get directory of self", "code": "def relpath(self):\n        \"\"\" Return this path as a relative path,\n        based from the current working directory.\n        \"\"\"\n        cwd = self.__class__(os.getcwdu())\n        return cwd.relpathto(self)", "code_tokens": "def relpath ( self ) : cwd = self . __class__ ( os . getcwdu ( ) ) return cwd . relpathto ( self )", "docstring_tokens": "Return this path as a relative path based from the current working directory .", "label": 0}, {"idx": "cosqa-train-432", "doc": "detect is host in in the network python", "code": "def we_are_in_lyon():\n    \"\"\"Check if we are on a Lyon machine\"\"\"\n    import socket\n    try:\n        hostname = socket.gethostname()\n        ip = socket.gethostbyname(hostname)\n    except socket.gaierror:\n        return False\n    return ip.startswith(\"134.158.\")", "code_tokens": "def we_are_in_lyon ( ) : import socket try : hostname = socket . gethostname ( ) ip = socket . gethostbyname ( hostname ) except socket . gaierror : return False return ip . startswith ( \"134.158.\" )", "docstring_tokens": "Check if we are on a Lyon machine", "label": 0}, {"idx": "cosqa-train-433", "doc": "python get distance between two lat lon", "code": "def _calculate_distance(latlon1, latlon2):\n    \"\"\"Calculates the distance between two points on earth.\n    \"\"\"\n    lat1, lon1 = latlon1\n    lat2, lon2 = latlon2\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    R = 6371  # radius of the earth in kilometers\n    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * (np.sin(dlon / 2))**2\n    c = 2 * np.pi * R * np.arctan2(np.sqrt(a), np.sqrt(1 - a)) / 180\n    return c", "code_tokens": "def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c", "docstring_tokens": "Calculates the distance between two points on earth .", "label": 0}, {"idx": "cosqa-train-434", "doc": "determine if passed variable a function python", "code": "def is_callable(*p):\n    \"\"\" True if all the args are functions and / or subroutines\n    \"\"\"\n    import symbols\n    return all(isinstance(x, symbols.FUNCTION) for x in p)", "code_tokens": "def is_callable ( * p ) : import symbols return all ( isinstance ( x , symbols . FUNCTION ) for x in p )", "docstring_tokens": "True if all the args are functions and / or subroutines", "label": 0}, {"idx": "cosqa-train-435", "doc": "determine whether two strings are the same python", "code": "def eqstr(a, b):\n    \"\"\"\n    Determine whether two strings are equivalent.\n\n    http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/eqstr_c.html\n\n    :param a: Arbitrary character string.\n    :type a: str\n    :param b: Arbitrary character string.\n    :type b: str\n    :return: True if A and B are equivalent.\n    :rtype: bool\n    \"\"\"\n    return bool(libspice.eqstr_c(stypes.stringToCharP(a), stypes.stringToCharP(b)))", "code_tokens": "def eqstr ( a , b ) : return bool ( libspice . eqstr_c ( stypes . stringToCharP ( a ) , stypes . stringToCharP ( b ) ) )", "docstring_tokens": "Determine whether two strings are equivalent .", "label": 0}, {"idx": "cosqa-train-436", "doc": "python get element by name", "code": "def get_by(self, name):\n    \"\"\"get element by name\"\"\"\n    return next((item for item in self if item.name == name), None)", "code_tokens": "def get_by ( self , name ) : return next ( ( item for item in self if item . name == name ) , None )", "docstring_tokens": "get element by name", "label": 0}, {"idx": "cosqa-train-437", "doc": "dictionary schema validation python", "code": "def validate(self, *args, **kwargs): # pylint: disable=arguments-differ\n        \"\"\"\n        Validate a parameter dict against a parameter schema from an ocrd-tool.json\n\n        Args:\n            obj (dict):\n            schema (dict):\n        \"\"\"\n        return super(ParameterValidator, self)._validate(*args, **kwargs)", "code_tokens": "def validate ( self , * args , * * kwargs ) : # pylint: disable=arguments-differ return super ( ParameterValidator , self ) . _validate ( * args , * * kwargs )", "docstring_tokens": "Validate a parameter dict against a parameter schema from an ocrd - tool . json", "label": 0}, {"idx": "cosqa-train-438", "doc": "python get file parent path name", "code": "def get_parent_dir(name):\n    \"\"\"Get the parent directory of a filename.\"\"\"\n    parent_dir = os.path.dirname(os.path.dirname(name))\n    if parent_dir:\n        return parent_dir\n    return os.path.abspath('.')", "code_tokens": "def get_parent_dir ( name ) : parent_dir = os . path . dirname ( os . path . dirname ( name ) ) if parent_dir : return parent_dir return os . path . abspath ( '.' )", "docstring_tokens": "Get the parent directory of a filename .", "label": 0}, {"idx": "cosqa-train-439", "doc": "discord bot python mention user", "code": "def me(self):\n        \"\"\"Similar to :attr:`.Guild.me` except it may return the :class:`.ClientUser` in private message contexts.\"\"\"\n        return self.guild.me if self.guild is not None else self.bot.user", "code_tokens": "def me ( self ) : return self . guild . me if self . guild is not None else self . bot . user", "docstring_tokens": "Similar to : attr : . Guild . me except it may return the : class : . ClientUser in private message contexts .", "label": 0}, {"idx": "cosqa-train-440", "doc": "python get file size in gb", "code": "def get_size_in_bytes(self, handle):\n        \"\"\"Return the size in bytes.\"\"\"\n        fpath = self._fpath_from_handle(handle)\n        return os.stat(fpath).st_size", "code_tokens": "def get_size_in_bytes ( self , handle ) : fpath = self . _fpath_from_handle ( handle ) return os . stat ( fpath ) . st_size", "docstring_tokens": "Return the size in bytes .", "label": 0}, {"idx": "cosqa-train-441", "doc": "display table in html now reflaticing data only blanck box using python flask'", "code": "def show_guestbook():\n    \"\"\"Returns all existing guestbook records.\"\"\"\n    cursor = flask.g.db.execute(\n        'SELECT name, message FROM entry ORDER BY id DESC;')\n    entries = [{'name': row[0], 'message': row[1]} for row in cursor.fetchall()]\n    return jinja2.Template(LAYOUT).render(entries=entries)", "code_tokens": "def show_guestbook ( ) : cursor = flask . g . db . execute ( 'SELECT name, message FROM entry ORDER BY id DESC;' ) entries = [ { 'name' : row [ 0 ] , 'message' : row [ 1 ] } for row in cursor . fetchall ( ) ] return jinja2 . Template ( LAYOUT ) . render ( entries = entries )", "docstring_tokens": "Returns all existing guestbook records .", "label": 0}, {"idx": "cosqa-train-442", "doc": "python get first date month", "code": "def get_month_start(day=None):\n    \"\"\"Returns the first day of the given month.\"\"\"\n    day = add_timezone(day or datetime.date.today())\n    return day.replace(day=1)", "code_tokens": "def get_month_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( day = 1 )", "docstring_tokens": "Returns the first day of the given month .", "label": 0}, {"idx": "cosqa-train-443", "doc": "display the count of index in adjacent position python", "code": "def rank(idx, dim):\n    \"\"\"Calculate the index rank according to Bertran's notation.\"\"\"\n    idxm = multi_index(idx, dim)\n    out = 0\n    while idxm[-1:] == (0,):\n        out += 1\n        idxm = idxm[:-1]\n    return out", "code_tokens": "def rank ( idx , dim ) : idxm = multi_index ( idx , dim ) out = 0 while idxm [ - 1 : ] == ( 0 , ) : out += 1 idxm = idxm [ : - 1 ] return out", "docstring_tokens": "Calculate the index rank according to Bertran s notation .", "label": 1}, {"idx": "cosqa-train-444", "doc": "python get git lastest commit", "code": "def get_last_commit(git_path=None):\n    \"\"\"\n    Get the HEAD commit SHA1 of repository in current dir.\n    \"\"\"\n    if git_path is None: git_path = GIT_PATH\n    line = get_last_commit_line(git_path)\n    revision_id = line.split()[1]\n    return revision_id", "code_tokens": "def get_last_commit ( git_path = None ) : if git_path is None : git_path = GIT_PATH line = get_last_commit_line ( git_path ) revision_id = line . split ( ) [ 1 ] return revision_id", "docstring_tokens": "Get the HEAD commit SHA1 of repository in current dir .", "label": 0}, {"idx": "cosqa-train-445", "doc": "displaying tabular data stream python", "code": "def csvpretty(csvfile: csvfile=sys.stdin):\n    \"\"\" Pretty print a CSV file. \"\"\"\n    shellish.tabulate(csv.reader(csvfile))", "code_tokens": "def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )", "docstring_tokens": "Pretty print a CSV file .", "label": 0}, {"idx": "cosqa-train-446", "doc": "python get length of array]", "code": "def array_dim(arr):\n    \"\"\"Return the size of a multidimansional array.\n    \"\"\"\n    dim = []\n    while True:\n        try:\n            dim.append(len(arr))\n            arr = arr[0]\n        except TypeError:\n            return dim", "code_tokens": "def array_dim ( arr ) : dim = [ ] while True : try : dim . append ( len ( arr ) ) arr = arr [ 0 ] except TypeError : return dim", "docstring_tokens": "Return the size of a multidimansional array .", "label": 0}, {"idx": "cosqa-train-447", "doc": "divide the string into n parts in python", "code": "def _split_str(s, n):\n    \"\"\"\n    split string into list of strings by specified number.\n    \"\"\"\n    length = len(s)\n    return [s[i:i + n] for i in range(0, length, n)]", "code_tokens": "def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]", "docstring_tokens": "split string into list of strings by specified number .", "label": 0}, {"idx": "cosqa-train-448", "doc": "python get length of queue", "code": "def qsize(self):\n        \"\"\"Return the approximate size of the queue (not reliable!).\"\"\"\n        self.mutex.acquire()\n        n = self._qsize()\n        self.mutex.release()\n        return n", "code_tokens": "def qsize ( self ) : self . mutex . acquire ( ) n = self . _qsize ( ) self . mutex . release ( ) return n", "docstring_tokens": "Return the approximate size of the queue ( not reliable! ) .", "label": 0}, {"idx": "cosqa-train-449", "doc": "django python check if static file exists", "code": "def is_static(self, filename):\n        \"\"\"Check if a file is a static file (which should be copied, rather\n        than compiled using Jinja2).\n\n        A file is considered static if it lives in any of the directories\n        specified in ``staticpaths``.\n\n        :param filename: the name of the file to check\n\n        \"\"\"\n        if self.staticpaths is None:\n            # We're not using static file support\n            return False\n\n        for path in self.staticpaths:\n            if filename.startswith(path):\n                return True\n        return False", "code_tokens": "def is_static ( self , filename ) : if self . staticpaths is None : # We're not using static file support return False for path in self . staticpaths : if filename . startswith ( path ) : return True return False", "docstring_tokens": "Check if a file is a static file ( which should be copied rather than compiled using Jinja2 ) .", "label": 0}, {"idx": "cosqa-train-450", "doc": "python get list of enum names", "code": "def items(self):\n    \"\"\"Return a list of the (name, value) pairs of the enum.\n\n    These are returned in the order they were defined in the .proto file.\n    \"\"\"\n    return [(value_descriptor.name, value_descriptor.number)\n            for value_descriptor in self._enum_type.values]", "code_tokens": "def items ( self ) : return [ ( value_descriptor . name , value_descriptor . number ) for value_descriptor in self . _enum_type . values ]", "docstring_tokens": "Return a list of the ( name value ) pairs of the enum .", "label": 0}, {"idx": "cosqa-train-451", "doc": "django static files in templates working but not in python code", "code": "def serve_static(request, path, insecure=False, **kwargs):\n    \"\"\"Collect and serve static files.\n\n    This view serves up static files, much like Django's\n    :py:func:`~django.views.static.serve` view, with the addition that it\n    collects static files first (if enabled). This allows images, fonts, and\n    other assets to be served up without first loading a page using the\n    ``{% javascript %}`` or ``{% stylesheet %}`` template tags.\n\n    You can use this view by adding the following to any :file:`urls.py`::\n\n        urlpatterns += static('static/', view='pipeline.views.serve_static')\n    \"\"\"\n    # Follow the same logic Django uses for determining access to the\n    # static-serving view.\n    if not django_settings.DEBUG and not insecure:\n        raise ImproperlyConfigured(\"The staticfiles view can only be used in \"\n                                   \"debug mode or if the --insecure \"\n                                   \"option of 'runserver' is used\")\n\n    if not settings.PIPELINE_ENABLED and settings.PIPELINE_COLLECTOR_ENABLED:\n        # Collect only the requested file, in order to serve the result as\n        # fast as possible. This won't interfere with the template tags in any\n        # way, as those will still cause Django to collect all media.\n        default_collector.collect(request, files=[path])\n\n    return serve(request, path, document_root=django_settings.STATIC_ROOT,\n                 **kwargs)", "code_tokens": "def serve_static ( request , path , insecure = False , * * kwargs ) : # Follow the same logic Django uses for determining access to the # static-serving view. if not django_settings . DEBUG and not insecure : raise ImproperlyConfigured ( \"The staticfiles view can only be used in \" \"debug mode or if the --insecure \" \"option of 'runserver' is used\" ) if not settings . PIPELINE_ENABLED and settings . PIPELINE_COLLECTOR_ENABLED : # Collect only the requested file, in order to serve the result as # fast as possible. This won't interfere with the template tags in any # way, as those will still cause Django to collect all media. default_collector . collect ( request , files = [ path ] ) return serve ( request , path , document_root = django_settings . STATIC_ROOT , * * kwargs )", "docstring_tokens": "Collect and serve static files .", "label": 0}, {"idx": "cosqa-train-452", "doc": "python get list of enum values", "code": "def items(cls):\n        \"\"\"\n        All values for this enum\n        :return: list of tuples\n\n        \"\"\"\n        return [\n            cls.PRECIPITATION,\n            cls.WIND,\n            cls.TEMPERATURE,\n            cls.PRESSURE\n        ]", "code_tokens": "def items ( cls ) : return [ cls . PRECIPITATION , cls . WIND , cls . TEMPERATURE , cls . PRESSURE ]", "docstring_tokens": "All values for this enum : return : list of tuples", "label": 0}, {"idx": "cosqa-train-453", "doc": "do i press enter or tab to start new line in python", "code": "def go_to_new_line(self):\n        \"\"\"Go to the end of the current line and create a new line\"\"\"\n        self.stdkey_end(False, False)\n        self.insert_text(self.get_line_separator())", "code_tokens": "def go_to_new_line ( self ) : self . stdkey_end ( False , False ) self . insert_text ( self . get_line_separator ( ) )", "docstring_tokens": "Go to the end of the current line and create a new line", "label": 0}, {"idx": "cosqa-train-454", "doc": "python get list of fonts", "code": "def get_font_list():\n    \"\"\"Returns a sorted list of all system font names\"\"\"\n\n    font_map = pangocairo.cairo_font_map_get_default()\n    font_list = [f.get_name() for f in font_map.list_families()]\n    font_list.sort()\n\n    return font_list", "code_tokens": "def get_font_list ( ) : font_map = pangocairo . cairo_font_map_get_default ( ) font_list = [ f . get_name ( ) for f in font_map . list_families ( ) ] font_list . sort ( ) return font_list", "docstring_tokens": "Returns a sorted list of all system font names", "label": 0}, {"idx": "cosqa-train-455", "doc": "does a tree node have parent node associated with it using python", "code": "def has_parent(self, term):\n        \"\"\"Return True if this GO object has a parent GO ID.\"\"\"\n        for parent in self.parents:\n            if parent.item_id == term or parent.has_parent(term):\n                return True\n        return False", "code_tokens": "def has_parent ( self , term ) : for parent in self . parents : if parent . item_id == term or parent . has_parent ( term ) : return True return False", "docstring_tokens": "Return True if this GO object has a parent GO ID .", "label": 1}, {"idx": "cosqa-train-456", "doc": "python get list of values sorted by dict key", "code": "def unique_list_dicts(dlist, key):\n    \"\"\"Return a list of dictionaries which are sorted for only unique entries.\n\n    :param dlist:\n    :param key:\n    :return list:\n    \"\"\"\n\n    return list(dict((val[key], val) for val in dlist).values())", "code_tokens": "def unique_list_dicts ( dlist , key ) : return list ( dict ( ( val [ key ] , val ) for val in dlist ) . values ( ) )", "docstring_tokens": "Return a list of dictionaries which are sorted for only unique entries .", "label": 0}, {"idx": "cosqa-train-457", "doc": "does python automatically deallocate memory", "code": "def invalidate_cache(cpu, address, size):\n        \"\"\" remove decoded instruction from instruction cache \"\"\"\n        cache = cpu.instruction_cache\n        for offset in range(size):\n            if address + offset in cache:\n                del cache[address + offset]", "code_tokens": "def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]", "docstring_tokens": "remove decoded instruction from instruction cache", "label": 0}, {"idx": "cosqa-train-458", "doc": "python get local ipa address", "code": "def _get_local_ip():\n        \"\"\"\n        Get the local ip of this device\n\n        :return: Ip of this computer\n        :rtype: str\n        \"\"\"\n        return set([x[4][0] for x in socket.getaddrinfo(\n            socket.gethostname(),\n            80,\n            socket.AF_INET\n        )]).pop()", "code_tokens": "def _get_local_ip ( ) : return set ( [ x [ 4 ] [ 0 ] for x in socket . getaddrinfo ( socket . gethostname ( ) , 80 , socket . AF_INET ) ] ) . pop ( )", "docstring_tokens": "Get the local ip of this device", "label": 0}, {"idx": "cosqa-train-459", "doc": "does python do camelcase", "code": "def keys_to_snake_case(camel_case_dict):\n    \"\"\"\n    Make a copy of a dictionary with all keys converted to snake case. This is just calls to_snake_case on\n    each of the keys in the dictionary and returns a new dictionary.\n\n    :param camel_case_dict: Dictionary with the keys to convert.\n    :type camel_case_dict: Dictionary.\n\n    :return: Dictionary with the keys converted to snake case.\n    \"\"\"\n    return dict((to_snake_case(key), value) for (key, value) in camel_case_dict.items())", "code_tokens": "def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )", "docstring_tokens": "Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .", "label": 0}, {"idx": "cosqa-train-460", "doc": "python get methods and properties of an object", "code": "def get_public_members(obj):\n    \"\"\"\n    Retrieves a list of member-like objects (members or properties) that are\n    publically exposed.\n\n    :param obj: The object to probe.\n    :return:    A list of strings.\n    \"\"\"\n    return {attr: getattr(obj, attr) for attr in dir(obj)\n            if not attr.startswith(\"_\")\n            and not hasattr(getattr(obj, attr), '__call__')}", "code_tokens": "def get_public_members ( obj ) : return { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( \"_\" ) and not hasattr ( getattr ( obj , attr ) , '__call__' ) }", "docstring_tokens": "Retrieves a list of member - like objects ( members or properties ) that are publically exposed .", "label": 0}, {"idx": "cosqa-train-461", "doc": "does python have a built in timer", "code": "def timer():\n    \"\"\"\n    Timer used for calculate time elapsed\n    \"\"\"\n    if sys.platform == \"win32\":\n        default_timer = time.clock\n    else:\n        default_timer = time.time\n\n    return default_timer()", "code_tokens": "def timer ( ) : if sys . platform == \"win32\" : default_timer = time . clock else : default_timer = time . time return default_timer ( )", "docstring_tokens": "Timer used for calculate time elapsed", "label": 0}, {"idx": "cosqa-train-462", "doc": "python get month last date", "code": "def last_day(year=_year, month=_month):\n    \"\"\"\n    get the current month's last day\n    :param year:  default to current year\n    :param month:  default to current month\n    :return: month's last day\n    \"\"\"\n    last_day = calendar.monthrange(year, month)[1]\n    return datetime.date(year=year, month=month, day=last_day)", "code_tokens": "def last_day ( year = _year , month = _month ) : last_day = calendar . monthrange ( year , month ) [ 1 ] return datetime . date ( year = year , month = month , day = last_day )", "docstring_tokens": "get the current month s last day : param year : default to current year : param month : default to current month : return : month s last day", "label": 0}, {"idx": "cosqa-train-463", "doc": "does python have an inverse tangent function", "code": "def unit_tangent(self, t):\n        \"\"\"returns the unit tangent vector of the segment at t (centered at\n        the origin and expressed as a complex number).\"\"\"\n        dseg = self.derivative(t)\n        return dseg/abs(dseg)", "code_tokens": "def unit_tangent ( self , t ) : dseg = self . derivative ( t ) return dseg / abs ( dseg )", "docstring_tokens": "returns the unit tangent vector of the segment at t ( centered at the origin and expressed as a complex number ) .", "label": 0}, {"idx": "cosqa-train-464", "doc": "python get object columns for dataset", "code": "def get_obj_cols(df):\n    \"\"\"\n    Returns names of 'object' columns in the DataFrame.\n    \"\"\"\n    obj_cols = []\n    for idx, dt in enumerate(df.dtypes):\n        if dt == 'object' or is_category(dt):\n            obj_cols.append(df.columns.values[idx])\n\n    return obj_cols", "code_tokens": "def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols", "docstring_tokens": "Returns names of object columns in the DataFrame .", "label": 0}, {"idx": "cosqa-train-465", "doc": "double the pixels without changing the aspect ration python", "code": "def match_aspect_to_viewport(self):\n        \"\"\"Updates Camera.aspect to match the viewport's aspect ratio.\"\"\"\n        viewport = self.viewport\n        self.aspect = float(viewport.width) / viewport.height", "code_tokens": "def match_aspect_to_viewport ( self ) : viewport = self . viewport self . aspect = float ( viewport . width ) / viewport . height", "docstring_tokens": "Updates Camera . aspect to match the viewport s aspect ratio .", "label": 0}, {"idx": "cosqa-train-466", "doc": "python get object property by name", "code": "def get_property_by_name(pif, name):\n    \"\"\"Get a property by name\"\"\"\n    return next((x for x in pif.properties if x.name == name), None)", "code_tokens": "def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )", "docstring_tokens": "Get a property by name", "label": 1}, {"idx": "cosqa-train-467", "doc": "double underscore function python", "code": "def us2mc(string):\n    \"\"\"Transform an underscore_case string to a mixedCase string\"\"\"\n    return re.sub(r'_([a-z])', lambda m: (m.group(1).upper()), string)", "code_tokens": "def us2mc ( string ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , string )", "docstring_tokens": "Transform an underscore_case string to a mixedCase string", "label": 1}, {"idx": "cosqa-train-468", "doc": "python get only unique values from list", "code": "def _uniquify(_list):\n    \"\"\"Remove duplicates in a list.\"\"\"\n    seen = set()\n    result = []\n    for x in _list:\n        if x not in seen:\n            result.append(x)\n            seen.add(x)\n    return result", "code_tokens": "def _uniquify ( _list ) : seen = set ( ) result = [ ] for x in _list : if x not in seen : result . append ( x ) seen . add ( x ) return result", "docstring_tokens": "Remove duplicates in a list .", "label": 0}, {"idx": "cosqa-train-469", "doc": "duration format in python django", "code": "def fmt_duration(secs):\n    \"\"\"Format a duration in seconds.\"\"\"\n    return ' '.join(fmt.human_duration(secs, 0, precision=2, short=True).strip().split())", "code_tokens": "def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )", "docstring_tokens": "Format a duration in seconds .", "label": 0}, {"idx": "cosqa-train-470", "doc": "python get path of a function", "code": "def get_module_path(modname):\n    \"\"\"Return module *modname* base path\"\"\"\n    return osp.abspath(osp.dirname(sys.modules[modname].__file__))", "code_tokens": "def get_module_path ( modname ) : return osp . abspath ( osp . dirname ( sys . modules [ modname ] . __file__ ) )", "docstring_tokens": "Return module * modname * base path", "label": 0}, {"idx": "cosqa-train-471", "doc": "efficient way to calculate a checksum of an array in python", "code": "def np_hash(a):\n    \"\"\"Return a hash of a NumPy array.\"\"\"\n    if a is None:\n        return hash(None)\n    # Ensure that hashes are equal whatever the ordering in memory (C or\n    # Fortran)\n    a = np.ascontiguousarray(a)\n    # Compute the digest and return a decimal int\n    return int(hashlib.sha1(a.view(a.dtype)).hexdigest(), 16)", "code_tokens": "def np_hash ( a ) : if a is None : return hash ( None ) # Ensure that hashes are equal whatever the ordering in memory (C or # Fortran) a = np . ascontiguousarray ( a ) # Compute the digest and return a decimal int return int ( hashlib . sha1 ( a . view ( a . dtype ) ) . hexdigest ( ) , 16 )", "docstring_tokens": "Return a hash of a NumPy array .", "label": 0}, {"idx": "cosqa-train-472", "doc": "python get pinyin from characters python", "code": "def get(s, delimiter='', format=\"diacritical\"):\n    \"\"\"Return pinyin of string, the string must be unicode\n    \"\"\"\n    return delimiter.join(_pinyin_generator(u(s), format=format))", "code_tokens": "def get ( s , delimiter = '' , format = \"diacritical\" ) : return delimiter . join ( _pinyin_generator ( u ( s ) , format = format ) )", "docstring_tokens": "Return pinyin of string the string must be unicode", "label": 0}, {"idx": "cosqa-train-473", "doc": "eigen values calculation in python", "code": "def center_eigenvalue_diff(mat):\n    \"\"\"Compute the eigvals of mat and then find the center eigval difference.\"\"\"\n    N = len(mat)\n    evals = np.sort(la.eigvals(mat))\n    diff = np.abs(evals[N/2] - evals[N/2-1])\n    return diff", "code_tokens": "def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff", "docstring_tokens": "Compute the eigvals of mat and then find the center eigval difference .", "label": 0}, {"idx": "cosqa-train-474", "doc": "python get property value by name", "code": "def get_property_by_name(pif, name):\n    \"\"\"Get a property by name\"\"\"\n    return next((x for x in pif.properties if x.name == name), None)", "code_tokens": "def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )", "docstring_tokens": "Get a property by name", "label": 0}, {"idx": "cosqa-train-475", "doc": "eigen values of gradients of images, python", "code": "def center_eigenvalue_diff(mat):\n    \"\"\"Compute the eigvals of mat and then find the center eigval difference.\"\"\"\n    N = len(mat)\n    evals = np.sort(la.eigvals(mat))\n    diff = np.abs(evals[N/2] - evals[N/2-1])\n    return diff", "code_tokens": "def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff", "docstring_tokens": "Compute the eigvals of mat and then find the center eigval difference .", "label": 1}, {"idx": "cosqa-train-476", "doc": "python get size of an open file", "code": "def get_file_size(fileobj):\n    \"\"\"\n    Returns the size of a file-like object.\n    \"\"\"\n    currpos = fileobj.tell()\n    fileobj.seek(0, 2)\n    total_size = fileobj.tell()\n    fileobj.seek(currpos)\n    return total_size", "code_tokens": "def get_file_size ( fileobj ) : currpos = fileobj . tell ( ) fileobj . seek ( 0 , 2 ) total_size = fileobj . tell ( ) fileobj . seek ( currpos ) return total_size", "docstring_tokens": "Returns the size of a file - like object .", "label": 0}, {"idx": "cosqa-train-477", "doc": "eigenvalues of a matrix in python code", "code": "def center_eigenvalue_diff(mat):\n    \"\"\"Compute the eigvals of mat and then find the center eigval difference.\"\"\"\n    N = len(mat)\n    evals = np.sort(la.eigvals(mat))\n    diff = np.abs(evals[N/2] - evals[N/2-1])\n    return diff", "code_tokens": "def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff", "docstring_tokens": "Compute the eigvals of mat and then find the center eigval difference .", "label": 0}, {"idx": "cosqa-train-478", "doc": "python get size of cytpes array in memory", "code": "def array_bytes(array):\n    \"\"\" Estimates the memory of the supplied array in bytes \"\"\"\n    return np.product(array.shape)*np.dtype(array.dtype).itemsize", "code_tokens": "def array_bytes ( array ) : return np . product ( array . shape ) * np . dtype ( array . dtype ) . itemsize", "docstring_tokens": "Estimates the memory of the supplied array in bytes", "label": 0}, {"idx": "cosqa-train-479", "doc": "elasticsearch delete by query python", "code": "def clear_es():\n        \"\"\"Clear all indexes in the es core\"\"\"\n        # TODO: should receive a catalog slug.\n        ESHypermap.es.indices.delete(ESHypermap.index_name, ignore=[400, 404])\n        LOGGER.debug('Elasticsearch: Index cleared')", "code_tokens": "def clear_es ( ) : # TODO: should receive a catalog slug. ESHypermap . es . indices . delete ( ESHypermap . index_name , ignore = [ 400 , 404 ] ) LOGGER . debug ( 'Elasticsearch: Index cleared' )", "docstring_tokens": "Clear all indexes in the es core", "label": 0}, {"idx": "cosqa-train-480", "doc": "python get specific indexes list", "code": "def get_idx_rect(index_list):\n    \"\"\"Extract the boundaries from a list of indexes\"\"\"\n    rows, cols = list(zip(*[(i.row(), i.column()) for i in index_list]))\n    return ( min(rows), max(rows), min(cols), max(cols) )", "code_tokens": "def get_idx_rect ( index_list ) : rows , cols = list ( zip ( * [ ( i . row ( ) , i . column ( ) ) for i in index_list ] ) ) return ( min ( rows ) , max ( rows ) , min ( cols ) , max ( cols ) )", "docstring_tokens": "Extract the boundaries from a list of indexes", "label": 0}, {"idx": "cosqa-train-481", "doc": "elementtree get parent python", "code": "def _get_node_parent(self, age, pos):\n        \"\"\"Get the parent node of node, whch is located in tree's node list.\n\n        Returns:\n            object: The parent node.\n        \"\"\"\n        return self.nodes[age][int(pos / self.comp)]", "code_tokens": "def _get_node_parent ( self , age , pos ) : return self . nodes [ age ] [ int ( pos / self . comp ) ]", "docstring_tokens": "Get the parent node of node whch is located in tree s node list .", "label": 1}, {"idx": "cosqa-train-482", "doc": "python get str rep of object", "code": "def __repr__(self):\n        \"\"\"Return list-lookalike of representation string of objects\"\"\"\n        strings = []\n        for currItem in self:\n            strings.append(\"%s\" % currItem)\n        return \"(%s)\" % (\", \".join(strings))", "code_tokens": "def __repr__ ( self ) : strings = [ ] for currItem in self : strings . append ( \"%s\" % currItem ) return \"(%s)\" % ( \", \" . join ( strings ) )", "docstring_tokens": "Return list - lookalike of representation string of objects", "label": 0}, {"idx": "cosqa-train-483", "doc": "eliminate duplicate entries python list", "code": "def dedup_list(l):\n    \"\"\"Given a list (l) will removing duplicates from the list,\n       preserving the original order of the list. Assumes that\n       the list entrie are hashable.\"\"\"\n    dedup = set()\n    return [ x for x in l if not (x in dedup or dedup.add(x))]", "code_tokens": "def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]", "docstring_tokens": "Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable .", "label": 1}, {"idx": "cosqa-train-484", "doc": "python get tensorflow ver", "code": "def tf2():\n  \"\"\"Provide the root module of a TF-2.0 API for use within TensorBoard.\n\n  Returns:\n    The root module of a TF-2.0 API, if available.\n\n  Raises:\n    ImportError: if a TF-2.0 API is not available.\n  \"\"\"\n  # Import the `tf` compat API from this file and check if it's already TF 2.0.\n  if tf.__version__.startswith('2.'):\n    return tf\n  elif hasattr(tf, 'compat') and hasattr(tf.compat, 'v2'):\n    # As a fallback, try `tensorflow.compat.v2` if it's defined.\n    return tf.compat.v2\n  raise ImportError('cannot import tensorflow 2.0 API')", "code_tokens": "def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )", "docstring_tokens": "Provide the root module of a TF - 2 . 0 API for use within TensorBoard .", "label": 0}, {"idx": "cosqa-train-485", "doc": "email strto list python", "code": "def split_addresses(email_string_list):\n    \"\"\"\n    Converts a string containing comma separated email addresses\n    into a list of email addresses.\n    \"\"\"\n    return [f for f in [s.strip() for s in email_string_list.split(\",\")] if f]", "code_tokens": "def split_addresses ( email_string_list ) : return [ f for f in [ s . strip ( ) for s in email_string_list . split ( \",\" ) ] if f ]", "docstring_tokens": "Converts a string containing comma separated email addresses into a list of email addresses .", "label": 0}, {"idx": "cosqa-train-486", "doc": "python get the char width number of shell window", "code": "def size():\n    \"\"\"Determines the height and width of the console window\n\n        Returns:\n            tuple of int: The height in lines, then width in characters\n    \"\"\"\n    try:\n        assert os != 'nt' and sys.stdout.isatty()\n        rows, columns = os.popen('stty size', 'r').read().split()\n    except (AssertionError, AttributeError, ValueError):\n        # in case of failure, use dimensions of a full screen 13\" laptop\n        rows, columns = DEFAULT_HEIGHT, DEFAULT_WIDTH\n\n    return int(rows), int(columns)", "code_tokens": "def size ( ) : try : assert os != 'nt' and sys . stdout . isatty ( ) rows , columns = os . popen ( 'stty size' , 'r' ) . read ( ) . split ( ) except ( AssertionError , AttributeError , ValueError ) : # in case of failure, use dimensions of a full screen 13\" laptop rows , columns = DEFAULT_HEIGHT , DEFAULT_WIDTH return int ( rows ) , int ( columns )", "docstring_tokens": "Determines the height and width of the console window", "label": 1}, {"idx": "cosqa-train-487", "doc": "encode boolean to binary python", "code": "def _encode_bool(name, value, dummy0, dummy1):\n    \"\"\"Encode a python boolean (True/False).\"\"\"\n    return b\"\\x08\" + name + (value and b\"\\x01\" or b\"\\x00\")", "code_tokens": "def _encode_bool ( name , value , dummy0 , dummy1 ) : return b\"\\x08\" + name + ( value and b\"\\x01\" or b\"\\x00\" )", "docstring_tokens": "Encode a python boolean ( True / False ) .", "label": 0}, {"idx": "cosqa-train-488", "doc": "python get the index of a list item", "code": "def get_list_index(lst, index_or_name):\n    \"\"\"\n    Return the index of an element in the list.\n\n    Args:\n        lst (list): The list.\n        index_or_name (int or str): The value of the reference element, or directly its numeric index.\n\n    Returns:\n        (int) The index of the element in the list.\n    \"\"\"\n    if isinstance(index_or_name, six.integer_types):\n        return index_or_name\n\n    return lst.index(index_or_name)", "code_tokens": "def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )", "docstring_tokens": "Return the index of an element in the list .", "label": 0}, {"idx": "cosqa-train-489", "doc": "enum en python definicion", "code": "def write_enum(fo, datum, schema):\n    \"\"\"An enum is encoded by a int, representing the zero-based position of\n    the symbol in the schema.\"\"\"\n    index = schema['symbols'].index(datum)\n    write_int(fo, index)", "code_tokens": "def write_enum ( fo , datum , schema ) : index = schema [ 'symbols' ] . index ( datum ) write_int ( fo , index )", "docstring_tokens": "An enum is encoded by a int representing the zero - based position of the symbol in the schema .", "label": 1}, {"idx": "cosqa-train-490", "doc": "python get the index of top va;ie", "code": "def get_bottomrect_idx(self, pos):\n        \"\"\" Determine if cursor is on bottom right corner of a hot spot.\"\"\"\n        for i, r in enumerate(self.link_bottom_rects):\n            if r.Contains(pos):\n                return i\n        return -1", "code_tokens": "def get_bottomrect_idx ( self , pos ) : for i , r in enumerate ( self . link_bottom_rects ) : if r . Contains ( pos ) : return i return - 1", "docstring_tokens": "Determine if cursor is on bottom right corner of a hot spot .", "label": 0}, {"idx": "cosqa-train-491", "doc": "epoch for datetime python", "code": "def _dt_to_epoch(dt):\n        \"\"\"Convert datetime to epoch seconds.\"\"\"\n        try:\n            epoch = dt.timestamp()\n        except AttributeError:  # py2\n            epoch = (dt - datetime(1970, 1, 1)).total_seconds()\n        return epoch", "code_tokens": "def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch", "docstring_tokens": "Convert datetime to epoch seconds .", "label": 0}, {"idx": "cosqa-train-492", "doc": "python get top three row index", "code": "def table_top_abs(self):\n        \"\"\"Returns the absolute position of table top\"\"\"\n        table_height = np.array([0, 0, self.table_full_size[2]])\n        return string_to_array(self.floor.get(\"pos\")) + table_height", "code_tokens": "def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( \"pos\" ) ) + table_height", "docstring_tokens": "Returns the absolute position of table top", "label": 0}, {"idx": "cosqa-train-493", "doc": "epsilon in plot in python", "code": "def plot_epsilon_residuals(self):\n        \"\"\"Plots the epsilon residuals for the variogram fit.\"\"\"\n        fig = plt.figure()\n        ax = fig.add_subplot(111)\n        ax.scatter(range(self.epsilon.size), self.epsilon, c='k', marker='*')\n        ax.axhline(y=0.0)\n        plt.show()", "code_tokens": "def plot_epsilon_residuals ( self ) : fig = plt . figure ( ) ax = fig . add_subplot ( 111 ) ax . scatter ( range ( self . epsilon . size ) , self . epsilon , c = 'k' , marker = '*' ) ax . axhline ( y = 0.0 ) plt . show ( )", "docstring_tokens": "Plots the epsilon residuals for the variogram fit .", "label": 0}, {"idx": "cosqa-train-494", "doc": "python get type of property by name", "code": "def get_property_by_name(pif, name):\n    \"\"\"Get a property by name\"\"\"\n    return next((x for x in pif.properties if x.name == name), None)", "code_tokens": "def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )", "docstring_tokens": "Get a property by name", "label": 0}, {"idx": "cosqa-train-495", "doc": "equal aspect plot in python with large different axes ranges", "code": "def image_set_aspect(aspect=1.0, axes=\"gca\"):\n    \"\"\"\n    sets the aspect ratio of the current zoom level of the imshow image\n    \"\"\"\n    if axes is \"gca\": axes = _pylab.gca()\n\n    e = axes.get_images()[0].get_extent()\n    axes.set_aspect(abs((e[1]-e[0])/(e[3]-e[2]))/aspect)", "code_tokens": "def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "docstring_tokens": "sets the aspect ratio of the current zoom level of the imshow image", "label": 0}, {"idx": "cosqa-train-496", "doc": "es bulk update python", "code": "def forceupdate(self, *args, **kw):\n        \"\"\"Like a bulk :meth:`forceput`.\"\"\"\n        self._update(False, self._ON_DUP_OVERWRITE, *args, **kw)", "code_tokens": "def forceupdate ( self , * args , * * kw ) : self . _update ( False , self . _ON_DUP_OVERWRITE , * args , * * kw )", "docstring_tokens": "Like a bulk : meth : forceput .", "label": 0}, {"idx": "cosqa-train-497", "doc": "python get uid on windows", "code": "def get_nt_system_uid():\n    \"\"\"Get the MachineGuid from\n    HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Cryptography\\MachineGuid\n    \"\"\"\n    try:\n        import _winreg as winreg\n    except ImportError:\n        import winreg\n    lm = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n    try:\n        key = winreg.OpenKey(lm, r\"Software\\Microsoft\\Cryptography\")\n        try:\n            return winreg.QueryValueEx(key, \"MachineGuid\")[0]\n        finally:\n            key.Close()\n    finally:\n        lm.Close()", "code_tokens": "def get_nt_system_uid ( ) : try : import _winreg as winreg except ImportError : import winreg lm = winreg . ConnectRegistry ( None , winreg . HKEY_LOCAL_MACHINE ) try : key = winreg . OpenKey ( lm , r\"Software\\Microsoft\\Cryptography\" ) try : return winreg . QueryValueEx ( key , \"MachineGuid\" ) [ 0 ] finally : key . Close ( ) finally : lm . Close ( )", "docstring_tokens": "Get the MachineGuid from HKEY_LOCAL_MACHINE \\ Software \\ Microsoft \\ Cryptography \\ MachineGuid", "label": 0}, {"idx": "cosqa-train-498", "doc": "python get url element by id", "code": "def get_element_with_id(self, id):\n        \"\"\"Return the element with the specified ID.\"\"\"\n        # Should we maintain a hashmap of ids to make this more efficient? Probably overkill.\n        # TODO: Elements can contain nested elements (captions, footnotes, table cells, etc.)\n        return next((el for el in self.elements if el.id == id), None)", "code_tokens": "def get_element_with_id ( self , id ) : # Should we maintain a hashmap of ids to make this more efficient? Probably overkill. # TODO: Elements can contain nested elements (captions, footnotes, table cells, etc.) return next ( ( el for el in self . elements if el . id == id ) , None )", "docstring_tokens": "Return the element with the specified ID .", "label": 0}, {"idx": "cosqa-train-499", "doc": "euclidean distance between two vectors python", "code": "def vector_distance(a, b):\n    \"\"\"The Euclidean distance between two vectors.\"\"\"\n    a = np.array(a)\n    b = np.array(b)\n    return np.linalg.norm(a - b)", "code_tokens": "def vector_distance ( a , b ) : a = np . array ( a ) b = np . array ( b ) return np . linalg . norm ( a - b )", "docstring_tokens": "The Euclidean distance between two vectors .", "label": 0}, {"idx": "cosqa-train-500", "doc": "python get url in browser", "code": "def url(self):\n        \"\"\" The url of this window \"\"\"\n        with switch_window(self._browser, self.name):\n            return self._browser.url", "code_tokens": "def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "docstring_tokens": "The url of this window", "label": 0}, {"idx": "cosqa-train-501", "doc": "euclidean distance of two lists python", "code": "def euclidean(c1, c2):\n    \"\"\"Square of the euclidean distance\"\"\"\n    diffs = ((i - j) for i, j in zip(c1, c2))\n    return sum(x * x for x in diffs)", "code_tokens": "def euclidean ( c1 , c2 ) : diffs = ( ( i - j ) for i , j in zip ( c1 , c2 ) ) return sum ( x * x for x in diffs )", "docstring_tokens": "Square of the euclidean distance", "label": 0}, {"idx": "cosqa-train-502", "doc": "python get used memory info", "code": "def get_free_memory_win():\n    \"\"\"Return current free memory on the machine for windows.\n\n    Warning : this script is really not robust\n    Return in MB unit\n    \"\"\"\n    stat = MEMORYSTATUSEX()\n    ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(stat))\n    return int(stat.ullAvailPhys / 1024 / 1024)", "code_tokens": "def get_free_memory_win ( ) : stat = MEMORYSTATUSEX ( ) ctypes . windll . kernel32 . GlobalMemoryStatusEx ( ctypes . byref ( stat ) ) return int ( stat . ullAvailPhys / 1024 / 1024 )", "docstring_tokens": "Return current free memory on the machine for windows .", "label": 0}, {"idx": "cosqa-train-503", "doc": "evaluate expression python xpath", "code": "def xpathEvalExpression(self, str):\n        \"\"\"Evaluate the XPath expression in the given context. \"\"\"\n        ret = libxml2mod.xmlXPathEvalExpression(str, self._o)\n        if ret is None:raise xpathError('xmlXPathEvalExpression() failed')\n        return xpathObjectRet(ret)", "code_tokens": "def xpathEvalExpression ( self , str ) : ret = libxml2mod . xmlXPathEvalExpression ( str , self . _o ) if ret is None : raise xpathError ( 'xmlXPathEvalExpression() failed' ) return xpathObjectRet ( ret )", "docstring_tokens": "Evaluate the XPath expression in the given context .", "label": 0}, {"idx": "cosqa-train-504", "doc": "python get value from enum", "code": "def EnumValueName(self, enum, value):\n    \"\"\"Returns the string name of an enum value.\n\n    This is just a small helper method to simplify a common operation.\n\n    Args:\n      enum: string name of the Enum.\n      value: int, value of the enum.\n\n    Returns:\n      string name of the enum value.\n\n    Raises:\n      KeyError if either the Enum doesn't exist or the value is not a valid\n        value for the enum.\n    \"\"\"\n    return self.enum_types_by_name[enum].values_by_number[value].name", "code_tokens": "def EnumValueName ( self , enum , value ) : return self . enum_types_by_name [ enum ] . values_by_number [ value ] . name", "docstring_tokens": "Returns the string name of an enum value .", "label": 0}, {"idx": "cosqa-train-505", "doc": "evaluate if a set of points are inside of a polygon python", "code": "def is_in(self, point_x, point_y):\n        \"\"\" Test if a point is within this polygonal region \"\"\"\n\n        point_array = array(((point_x, point_y),))\n        vertices = array(self.points)\n        winding = self.inside_rule == \"winding\"\n        result = points_in_polygon(point_array, vertices, winding)\n        return result[0]", "code_tokens": "def is_in ( self , point_x , point_y ) : point_array = array ( ( ( point_x , point_y ) , ) ) vertices = array ( self . points ) winding = self . inside_rule == \"winding\" result = points_in_polygon ( point_array , vertices , winding ) return result [ 0 ]", "docstring_tokens": "Test if a point is within this polygonal region", "label": 1}, {"idx": "cosqa-train-506", "doc": "python get volume size", "code": "def extent_count(self):\n        \"\"\"\n        Returns the volume group extent count.\n        \"\"\"\n        self.open()\n        count = lvm_vg_get_extent_count(self.handle)\n        self.close()\n        return count", "code_tokens": "def extent_count ( self ) : self . open ( ) count = lvm_vg_get_extent_count ( self . handle ) self . close ( ) return count", "docstring_tokens": "Returns the volume group extent count .", "label": 0}, {"idx": "cosqa-train-507", "doc": "evaluate if two ndarrays are equal python", "code": "def numpy_aware_eq(a, b):\n    \"\"\"Return whether two objects are equal via recursion, using\n    :func:`numpy.array_equal` for comparing numpy arays.\n    \"\"\"\n    if isinstance(a, np.ndarray) or isinstance(b, np.ndarray):\n        return np.array_equal(a, b)\n    if ((isinstance(a, Iterable) and isinstance(b, Iterable)) and\n            not isinstance(a, str) and not isinstance(b, str)):\n        if len(a) != len(b):\n            return False\n        return all(numpy_aware_eq(x, y) for x, y in zip(a, b))\n    return a == b", "code_tokens": "def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b", "docstring_tokens": "Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays .", "label": 0}, {"idx": "cosqa-train-508", "doc": "python get window title of selected window", "code": "def title(self):\n        \"\"\" The title of this window \"\"\"\n        with switch_window(self._browser, self.name):\n            return self._browser.title", "code_tokens": "def title ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . title", "docstring_tokens": "The title of this window", "label": 0}, {"idx": "cosqa-train-509", "doc": "evaluting boolean values in python function", "code": "def visit_BoolOp(self, node):\n        \"\"\" Return type may come from any boolop operand. \"\"\"\n        return sum((self.visit(value) for value in node.values), [])", "code_tokens": "def visit_BoolOp ( self , node ) : return sum ( ( self . visit ( value ) for value in node . values ) , [ ] )", "docstring_tokens": "Return type may come from any boolop operand .", "label": 0}, {"idx": "cosqa-train-510", "doc": "python get xml text", "code": "def __get_xml_text(root):\n    \"\"\" Return the text for the given root node (xml.dom.minidom). \"\"\"\n    txt = \"\"\n    for e in root.childNodes:\n        if (e.nodeType == e.TEXT_NODE):\n            txt += e.data\n    return txt", "code_tokens": "def __get_xml_text ( root ) : txt = \"\" for e in root . childNodes : if ( e . nodeType == e . TEXT_NODE ) : txt += e . data return txt", "docstring_tokens": "Return the text for the given root node ( xml . dom . minidom ) .", "label": 0}, {"idx": "cosqa-train-511", "doc": "execute code line by line in python", "code": "def runcode(code):\n\t\"\"\"Run the given code line by line with printing, as list of lines, and return variable 'ans'.\"\"\"\n\tfor line in code:\n\t\tprint('# '+line)\n\t\texec(line,globals())\n\tprint('# return ans')\n\treturn ans", "code_tokens": "def runcode ( code ) : for line in code : print ( '# ' + line ) exec ( line , globals ( ) ) print ( '# return ans' ) return ans", "docstring_tokens": "Run the given code line by line with printing as list of lines and return variable ans .", "label": 0}, {"idx": "cosqa-train-512", "doc": "python gevent pool paralle", "code": "def fetch_event(urls):\n    \"\"\"\n    This parallel fetcher uses gevent one uses gevent\n    \"\"\"\n    rs = (grequests.get(u) for u in urls)\n    return [content.json() for content in grequests.map(rs)]", "code_tokens": "def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]", "docstring_tokens": "This parallel fetcher uses gevent one uses gevent", "label": 0}, {"idx": "cosqa-train-513", "doc": "execute order based on value python", "code": "def get_order(self, codes):\n        \"\"\"Return evidence codes in order shown in code2name.\"\"\"\n        return sorted(codes, key=lambda e: [self.ev2idx.get(e)])", "code_tokens": "def get_order ( self , codes ) : return sorted ( codes , key = lambda e : [ self . ev2idx . get ( e ) ] )", "docstring_tokens": "Return evidence codes in order shown in code2name .", "label": 0}, {"idx": "cosqa-train-514", "doc": "python given an array of boolean to decide values of another array", "code": "def equal(list1, list2):\n    \"\"\" takes flags returns indexes of True values \"\"\"\n    return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]", "code_tokens": "def equal ( list1 , list2 ) : return [ item1 == item2 for item1 , item2 in broadcast_zip ( list1 , list2 ) ]", "docstring_tokens": "takes flags returns indexes of True values", "label": 0}, {"idx": "cosqa-train-515", "doc": "execute(query, arg) cursor python", "code": "def select(self, cmd, *args, **kwargs):\n        \"\"\" Execute the SQL command and return the data rows as tuples\n        \"\"\"\n        self.cursor.execute(cmd, *args, **kwargs)\n        return self.cursor.fetchall()", "code_tokens": "def select ( self , cmd , * args , * * kwargs ) : self . cursor . execute ( cmd , * args , * * kwargs ) return self . cursor . fetchall ( )", "docstring_tokens": "Execute the SQL command and return the data rows as tuples", "label": 0}, {"idx": "cosqa-train-516", "doc": "python go to parent folder", "code": "def go_to_parent_directory(self):\n        \"\"\"Go to parent directory\"\"\"\n        self.chdir(osp.abspath(osp.join(getcwd_or_home(), os.pardir)))", "code_tokens": "def go_to_parent_directory ( self ) : self . chdir ( osp . abspath ( osp . join ( getcwd_or_home ( ) , os . pardir ) ) )", "docstring_tokens": "Go to parent directory", "label": 0}, {"idx": "cosqa-train-517", "doc": "expected string got float instead python", "code": "def _convert_to_float_if_possible(s):\n    \"\"\"\n    A small helper function to convert a string to a numeric value\n    if appropriate\n\n    :param s: the string to be converted\n    :type s: str\n    \"\"\"\n    try:\n        ret = float(s)\n    except (ValueError, TypeError):\n        ret = s\n    return ret", "code_tokens": "def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret", "docstring_tokens": "A small helper function to convert a string to a numeric value if appropriate", "label": 0}, {"idx": "cosqa-train-518", "doc": "python go to the bottom of a listbox", "code": "def _top(self):\n        \"\"\" g \"\"\"\n        # Goto top of the list\n        self.top.body.focus_position = 2 if self.compact is False else 0\n        self.top.keypress(self.size, \"\")", "code_tokens": "def _top ( self ) : # Goto top of the list self . top . body . focus_position = 2 if self . compact is False else 0 self . top . keypress ( self . size , \"\" )", "docstring_tokens": "g", "label": 0}, {"idx": "cosqa-train-519", "doc": "exponential decay python fit", "code": "def exp_fit_fun(x, a, tau, c):\n    \"\"\"Function used to fit the exponential decay.\"\"\"\n    # pylint: disable=invalid-name\n    return a * np.exp(-x / tau) + c", "code_tokens": "def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "docstring_tokens": "Function used to fit the exponential decay .", "label": 0}, {"idx": "cosqa-train-520", "doc": "python gps coordinates to x, y, z", "code": "def to_gtp(coord):\n    \"\"\"Converts from a Minigo coordinate to a GTP coordinate.\"\"\"\n    if coord is None:\n        return 'pass'\n    y, x = coord\n    return '{}{}'.format(_GTP_COLUMNS[x], go.N - y)", "code_tokens": "def to_gtp ( coord ) : if coord is None : return 'pass' y , x = coord return '{}{}' . format ( _GTP_COLUMNS [ x ] , go . N - y )", "docstring_tokens": "Converts from a Minigo coordinate to a GTP coordinate .", "label": 0}, {"idx": "cosqa-train-521", "doc": "export ipynb as python file", "code": "def nb_to_python(nb_path):\n    \"\"\"convert notebook to python script\"\"\"\n    exporter = python.PythonExporter()\n    output, resources = exporter.from_filename(nb_path)\n    return output", "code_tokens": "def nb_to_python ( nb_path ) : exporter = python . PythonExporter ( ) output , resources = exporter . from_filename ( nb_path ) return output", "docstring_tokens": "convert notebook to python script", "label": 1}, {"idx": "cosqa-train-522", "doc": "python grab last n elments", "code": "def searchlast(self,n=10):\n        \"\"\"Return the last n results (or possibly less if not found). Note that the last results are not necessarily the best ones! Depending on the search type.\"\"\"            \n        solutions = deque([], n)\n        for solution in self:\n            solutions.append(solution)\n        return solutions", "code_tokens": "def searchlast ( self , n = 10 ) : solutions = deque ( [ ] , n ) for solution in self : solutions . append ( solution ) return solutions", "docstring_tokens": "Return the last n results ( or possibly less if not found ) . Note that the last results are not necessarily the best ones! Depending on the search type .", "label": 0}, {"idx": "cosqa-train-523", "doc": "expose data in json format in python using data frame", "code": "def to_json(df, state_index, color_index, fills):\n        \"\"\"Transforms dataframe to json response\"\"\"\n        records = {}\n        for i, row in df.iterrows():\n\n            records[row[state_index]] = {\n                \"fillKey\": row[color_index]\n            }\n\n        return {\n            \"data\": records,\n            \"fills\": fills\n        }", "code_tokens": "def to_json ( df , state_index , color_index , fills ) : records = { } for i , row in df . iterrows ( ) : records [ row [ state_index ] ] = { \"fillKey\" : row [ color_index ] } return { \"data\" : records , \"fills\" : fills }", "docstring_tokens": "Transforms dataframe to json response", "label": 0}, {"idx": "cosqa-train-524", "doc": "python graphviz format png", "code": "def _text_to_graphiz(self, text):\n        \"\"\"create a graphviz graph from text\"\"\"\n        dot = Source(text, format='svg')\n        return dot.pipe().decode('utf-8')", "code_tokens": "def _text_to_graphiz ( self , text ) : dot = Source ( text , format = 'svg' ) return dot . pipe ( ) . decode ( 'utf-8' )", "docstring_tokens": "create a graphviz graph from text", "label": 0}, {"idx": "cosqa-train-525", "doc": "extract color components of an image in python", "code": "def get_colors(img):\n    \"\"\"\n    Returns a list of all the image's colors.\n    \"\"\"\n    w, h = img.size\n    return [color[:3] for count, color in img.convert('RGB').getcolors(w * h)]", "code_tokens": "def get_colors ( img ) : w , h = img . size return [ color [ : 3 ] for count , color in img . convert ( 'RGB' ) . getcolors ( w * h ) ]", "docstring_tokens": "Returns a list of all the image s colors .", "label": 0}, {"idx": "cosqa-train-526", "doc": "python group minute data into half hour", "code": "def _round_half_hour(record):\n    \"\"\"\n    Round a time DOWN to half nearest half-hour.\n    \"\"\"\n    k = record.datetime + timedelta(minutes=-(record.datetime.minute % 30))\n    return datetime(k.year, k.month, k.day, k.hour, k.minute, 0)", "code_tokens": "def _round_half_hour ( record ) : k = record . datetime + timedelta ( minutes = - ( record . datetime . minute % 30 ) ) return datetime ( k . year , k . month , k . day , k . hour , k . minute , 0 )", "docstring_tokens": "Round a time DOWN to half nearest half - hour .", "label": 0}, {"idx": "cosqa-train-527", "doc": "extract first array in python", "code": "def get_X0(X):\n    \"\"\" Return zero-th element of a one-element data container.\n    \"\"\"\n    if pandas_available and isinstance(X, pd.DataFrame):\n        assert len(X) == 1\n        x = np.array(X.iloc[0])\n    else:\n        x, = X\n    return x", "code_tokens": "def get_X0 ( X ) : if pandas_available and isinstance ( X , pd . DataFrame ) : assert len ( X ) == 1 x = np . array ( X . iloc [ 0 ] ) else : x , = X return x", "docstring_tokens": "Return zero - th element of a one - element data container .", "label": 0}, {"idx": "cosqa-train-528", "doc": "python gtk starting separate thread but doesn't run", "code": "def threads_init(gtk=True):\n    \"\"\"Enables multithreading support in Xlib and PyGTK.\n    See the module docstring for more info.\n    \n    :Parameters:\n      gtk : bool\n        May be set to False to skip the PyGTK module.\n    \"\"\"\n    # enable X11 multithreading\n    x11.XInitThreads()\n    if gtk:\n        from gtk.gdk import threads_init\n        threads_init()", "code_tokens": "def threads_init ( gtk = True ) : # enable X11 multithreading x11 . XInitThreads ( ) if gtk : from gtk . gdk import threads_init threads_init ( )", "docstring_tokens": "Enables multithreading support in Xlib and PyGTK . See the module docstring for more info . : Parameters : gtk : bool May be set to False to skip the PyGTK module .", "label": 0}, {"idx": "cosqa-train-529", "doc": "extract pdf fields in python", "code": "def security(self):\n        \"\"\"Print security object information for a pdf document\"\"\"\n        return {k: v for i in self.pdf.resolvedObjects.items() for k, v in i[1].items()}", "code_tokens": "def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "docstring_tokens": "Print security object information for a pdf document", "label": 0}, {"idx": "cosqa-train-530", "doc": "python gtk3 not work on window", "code": "def enable_gtk3(self, app=None):\n        \"\"\"Enable event loop integration with Gtk3 (gir bindings).\n\n        Parameters\n        ----------\n        app : ignored\n           Ignored, it's only a placeholder to keep the call signature of all\n           gui activation methods consistent, which simplifies the logic of\n           supporting magics.\n\n        Notes\n        -----\n        This methods sets the PyOS_InputHook for Gtk3, which allows\n        the Gtk3 to integrate with terminal based applications like\n        IPython.\n        \"\"\"\n        from pydev_ipython.inputhookgtk3 import create_inputhook_gtk3\n        self.set_inputhook(create_inputhook_gtk3(self._stdin_file))\n        self._current_gui = GUI_GTK", "code_tokens": "def enable_gtk3 ( self , app = None ) : from pydev_ipython . inputhookgtk3 import create_inputhook_gtk3 self . set_inputhook ( create_inputhook_gtk3 ( self . _stdin_file ) ) self . _current_gui = GUI_GTK", "docstring_tokens": "Enable event loop integration with Gtk3 ( gir bindings ) .", "label": 0}, {"idx": "cosqa-train-531", "doc": "fast matrix dot products in python", "code": "def dot(a, b):\n    \"\"\"Take arrays `a` and `b` and form the dot product between the last axis\n    of `a` and the first of `b`.\n    \"\"\"\n    b = numpy.asarray(b)\n    return numpy.dot(a, b.reshape(b.shape[0], -1)).reshape(a.shape[:-1] + b.shape[1:])", "code_tokens": "def dot ( a , b ) : b = numpy . asarray ( b ) return numpy . dot ( a , b . reshape ( b . shape [ 0 ] , - 1 ) ) . reshape ( a . shape [ : - 1 ] + b . shape [ 1 : ] )", "docstring_tokens": "Take arrays a and b and form the dot product between the last axis of a and the first of b .", "label": 0}, {"idx": "cosqa-train-532", "doc": "python guess text encoding", "code": "def guess_encoding(text, default=DEFAULT_ENCODING):\n    \"\"\"Guess string encoding.\n\n    Given a piece of text, apply character encoding detection to\n    guess the appropriate encoding of the text.\n    \"\"\"\n    result = chardet.detect(text)\n    return normalize_result(result, default=default)", "code_tokens": "def guess_encoding ( text , default = DEFAULT_ENCODING ) : result = chardet . detect ( text ) return normalize_result ( result , default = default )", "docstring_tokens": "Guess string encoding .", "label": 0}, {"idx": "cosqa-train-533", "doc": "fast way of setting certain elements in array to zero python", "code": "def check_precomputed_distance_matrix(X):\n    \"\"\"Perform check_array(X) after removing infinite values (numpy.inf) from the given distance matrix.\n    \"\"\"\n    tmp = X.copy()\n    tmp[np.isinf(tmp)] = 1\n    check_array(tmp)", "code_tokens": "def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "docstring_tokens": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix .", "label": 0}, {"idx": "cosqa-train-534", "doc": "python gzip compress a file", "code": "def __gzip(filename):\n\t\t\"\"\" Compress a file returning the new filename (.gz)\n\t\t\"\"\"\n\t\tzipname = filename + '.gz'\n\t\tfile_pointer = open(filename,'rb')\n\t\tzip_pointer = gzip.open(zipname,'wb')\n\t\tzip_pointer.writelines(file_pointer)\n\t\tfile_pointer.close()\n\t\tzip_pointer.close()\n\t\treturn zipname", "code_tokens": "def __gzip ( filename ) : zipname = filename + '.gz' file_pointer = open ( filename , 'rb' ) zip_pointer = gzip . open ( zipname , 'wb' ) zip_pointer . writelines ( file_pointer ) file_pointer . close ( ) zip_pointer . close ( ) return zipname", "docstring_tokens": "Compress a file returning the new filename ( . gz )", "label": 0}, {"idx": "cosqa-train-535", "doc": "faster update bulk in python mysql", "code": "def forceupdate(self, *args, **kw):\n        \"\"\"Like a bulk :meth:`forceput`.\"\"\"\n        self._update(False, self._ON_DUP_OVERWRITE, *args, **kw)", "code_tokens": "def forceupdate ( self , * args , * * kw ) : self . _update ( False , self . _ON_DUP_OVERWRITE , * args , * * kw )", "docstring_tokens": "Like a bulk : meth : forceput .", "label": 1}, {"idx": "cosqa-train-536", "doc": "python h5 file how to decrease size", "code": "def create_h5py_with_large_cache(filename, cache_size_mb):\n    \"\"\"\nAllows to open the hdf5 file with specified cache size\n    \"\"\"\n    # h5py does not allow to control the cache size from the high level\n    # we employ the workaround\n    # sources:\n    #http://stackoverflow.com/questions/14653259/how-to-set-cache-settings-while-using-h5py-high-level-interface\n    #https://groups.google.com/forum/#!msg/h5py/RVx1ZB6LpE4/KH57vq5yw2AJ\n    propfaid = h5py.h5p.create(h5py.h5p.FILE_ACCESS)\n    settings = list(propfaid.get_cache())\n    settings[2] = 1024 * 1024 * cache_size_mb\n    propfaid.set_cache(*settings)\n    fid = h5py.h5f.create(filename, flags=h5py.h5f.ACC_EXCL, fapl=propfaid)\n    fin = h5py.File(fid)\n    return fin", "code_tokens": "def create_h5py_with_large_cache ( filename , cache_size_mb ) : # h5py does not allow to control the cache size from the high level # we employ the workaround # sources: #http://stackoverflow.com/questions/14653259/how-to-set-cache-settings-while-using-h5py-high-level-interface #https://groups.google.com/forum/#!msg/h5py/RVx1ZB6LpE4/KH57vq5yw2AJ propfaid = h5py . h5p . create ( h5py . h5p . FILE_ACCESS ) settings = list ( propfaid . get_cache ( ) ) settings [ 2 ] = 1024 * 1024 * cache_size_mb propfaid . set_cache ( * settings ) fid = h5py . h5f . create ( filename , flags = h5py . h5f . ACC_EXCL , fapl = propfaid ) fin = h5py . File ( fid ) return fin", "docstring_tokens": "Allows to open the hdf5 file with specified cache size", "label": 0}, {"idx": "cosqa-train-537", "doc": "fft 2d spectrum python", "code": "def rfft2d_freqs(h, w):\n    \"\"\"Computes 2D spectrum frequencies.\"\"\"\n\n    fy = np.fft.fftfreq(h)[:, None]\n    # when we have an odd input dimension we need to keep one additional\n    # frequency and later cut off 1 pixel\n    if w % 2 == 1:\n        fx = np.fft.fftfreq(w)[: w // 2 + 2]\n    else:\n        fx = np.fft.fftfreq(w)[: w // 2 + 1]\n    return np.sqrt(fx * fx + fy * fy)", "code_tokens": "def rfft2d_freqs ( h , w ) : fy = np . fft . fftfreq ( h ) [ : , None ] # when we have an odd input dimension we need to keep one additional # frequency and later cut off 1 pixel if w % 2 == 1 : fx = np . fft . fftfreq ( w ) [ : w // 2 + 2 ] else : fx = np . fft . fftfreq ( w ) [ : w // 2 + 1 ] return np . sqrt ( fx * fx + fy * fy )", "docstring_tokens": "Computes 2D spectrum frequencies .", "label": 0}, {"idx": "cosqa-train-538", "doc": "python h5file force read into memory", "code": "def md5_hash_file(fh):\n    \"\"\"Return the md5 hash of the given file-object\"\"\"\n    md5 = hashlib.md5()\n    while True:\n        data = fh.read(8192)\n        if not data:\n            break\n        md5.update(data)\n    return md5.hexdigest()", "code_tokens": "def md5_hash_file ( fh ) : md5 = hashlib . md5 ( ) while True : data = fh . read ( 8192 ) if not data : break md5 . update ( data ) return md5 . hexdigest ( )", "docstring_tokens": "Return the md5 hash of the given file - object", "label": 0}, {"idx": "cosqa-train-539", "doc": "fibonacci with function for in python", "code": "def software_fibonacci(n):\n    \"\"\" a normal old python function to return the Nth fibonacci number. \"\"\"\n    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    return a", "code_tokens": "def software_fibonacci ( n ) : a , b = 0 , 1 for i in range ( n ) : a , b = b , a + b return a", "docstring_tokens": "a normal old python function to return the Nth fibonacci number .", "label": 0}, {"idx": "cosqa-train-540", "doc": "python h5py read data", "code": "def h5ToDict(h5, readH5pyDataset=True):\n    \"\"\" Read a hdf5 file into a dictionary \"\"\"\n    h = h5py.File(h5, \"r\")\n    ret = unwrapArray(h, recursive=True, readH5pyDataset=readH5pyDataset)\n    if readH5pyDataset: h.close()\n    return ret", "code_tokens": "def h5ToDict ( h5 , readH5pyDataset = True ) : h = h5py . File ( h5 , \"r\" ) ret = unwrapArray ( h , recursive = True , readH5pyDataset = readH5pyDataset ) if readH5pyDataset : h . close ( ) return ret", "docstring_tokens": "Read a hdf5 file into a dictionary", "label": 0}, {"idx": "cosqa-train-541", "doc": "file is not a zip file python", "code": "def current_zipfile():\n    \"\"\"A function to vend the current zipfile, if any\"\"\"\n    if zipfile.is_zipfile(sys.argv[0]):\n        fd = open(sys.argv[0], \"rb\")\n        return zipfile.ZipFile(fd)", "code_tokens": "def current_zipfile ( ) : if zipfile . is_zipfile ( sys . argv [ 0 ] ) : fd = open ( sys . argv [ 0 ] , \"rb\" ) return zipfile . ZipFile ( fd )", "docstring_tokens": "A function to vend the current zipfile if any", "label": 0}, {"idx": "cosqa-train-542", "doc": "python handling windows paths in strings", "code": "def __unixify(self, s):\n        \"\"\" stupid windows. converts the backslash to forwardslash for consistency \"\"\"\n        return os.path.normpath(s).replace(os.sep, \"/\")", "code_tokens": "def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , \"/\" )", "docstring_tokens": "stupid windows . converts the backslash to forwardslash for consistency", "label": 0}, {"idx": "cosqa-train-543", "doc": "fileinput python specify encoding", "code": "def __init__(self, encoding='utf-8'):\n    \"\"\"Initializes an stdin input reader.\n\n    Args:\n      encoding (Optional[str]): input encoding.\n    \"\"\"\n    super(StdinInputReader, self).__init__(sys.stdin, encoding=encoding)", "code_tokens": "def __init__ ( self , encoding = 'utf-8' ) : super ( StdinInputReader , self ) . __init__ ( sys . stdin , encoding = encoding )", "docstring_tokens": "Initializes an stdin input reader .", "label": 0}, {"idx": "cosqa-train-544", "doc": "python hash bang line", "code": "def _add_hash(source):\n    \"\"\"Add a leading hash '#' at the beginning of every line in the source.\"\"\"\n    source = '\\n'.join('# ' + line.rstrip()\n                       for line in source.splitlines())\n    return source", "code_tokens": "def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "docstring_tokens": "Add a leading hash # at the beginning of every line in the source .", "label": 0}, {"idx": "cosqa-train-545", "doc": "fille a vector in a parallelize way python", "code": "def apply(f, obj, *args, **kwargs):\n    \"\"\"Apply a function in parallel to each element of the input\"\"\"\n    return vectorize(f)(obj, *args, **kwargs)", "code_tokens": "def apply ( f , obj , * args , * * kwargs ) : return vectorize ( f ) ( obj , * args , * * kwargs )", "docstring_tokens": "Apply a function in parallel to each element of the input", "label": 0}, {"idx": "cosqa-train-546", "doc": "python hashlib return string", "code": "def double_sha256(data):\n    \"\"\"A standard compound hash.\"\"\"\n    return bytes_as_revhex(hashlib.sha256(hashlib.sha256(data).digest()).digest())", "code_tokens": "def double_sha256 ( data ) : return bytes_as_revhex ( hashlib . sha256 ( hashlib . sha256 ( data ) . digest ( ) ) . digest ( ) )", "docstring_tokens": "A standard compound hash .", "label": 0}, {"idx": "cosqa-train-547", "doc": "filter empty rows python", "code": "def drop_empty(rows):\n    \"\"\"Transpose the columns into rows, remove all of the rows that are empty after the first cell, then\n    transpose back. The result is that columns that have a header but no data in the body are removed, assuming\n    the header is the first row. \"\"\"\n    return zip(*[col for col in zip(*rows) if bool(filter(bool, col[1:]))])", "code_tokens": "def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )", "docstring_tokens": "Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row .", "label": 0}, {"idx": "cosqa-train-548", "doc": "python heap limit length", "code": "def heappush_max(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown_max(heap, 0, len(heap) - 1)", "code_tokens": "def heappush_max ( heap , item ) : heap . append ( item ) _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "docstring_tokens": "Push item onto heap maintaining the heap invariant .", "label": 0}, {"idx": "cosqa-train-549", "doc": "filter list using regex email example python", "code": "def split_addresses(email_string_list):\n    \"\"\"\n    Converts a string containing comma separated email addresses\n    into a list of email addresses.\n    \"\"\"\n    return [f for f in [s.strip() for s in email_string_list.split(\",\")] if f]", "code_tokens": "def split_addresses ( email_string_list ) : return [ f for f in [ s . strip ( ) for s in email_string_list . split ( \",\" ) ] if f ]", "docstring_tokens": "Converts a string containing comma separated email addresses into a list of email addresses .", "label": 0}, {"idx": "cosqa-train-550", "doc": "python heap sort stackoverflow", "code": "def _heappush_max(heap, item):\n    \"\"\" why is this not in heapq \"\"\"\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap) - 1)", "code_tokens": "def _heappush_max ( heap , item ) : heap . append ( item ) heapq . _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "docstring_tokens": "why is this not in heapq", "label": 0}, {"idx": "cosqa-train-551", "doc": "filter stopwords from a dictionary python", "code": "def _remove_keywords(d):\n    \"\"\"\n    copy the dict, filter_keywords\n\n    Parameters\n    ----------\n    d : dict\n    \"\"\"\n    return { k:v for k, v in iteritems(d) if k not in RESERVED }", "code_tokens": "def _remove_keywords ( d ) : return { k : v for k , v in iteritems ( d ) if k not in RESERVED }", "docstring_tokens": "copy the dict filter_keywords", "label": 0}, {"idx": "cosqa-train-552", "doc": "python heapify time complexity", "code": "def _heapify_max(x):\n    \"\"\"Transform list into a maxheap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    for i in reversed(range(n//2)):\n        _siftup_max(x, i)", "code_tokens": "def _heapify_max ( x ) : n = len ( x ) for i in reversed ( range ( n // 2 ) ) : _siftup_max ( x , i )", "docstring_tokens": "Transform list into a maxheap in - place in O ( len ( x )) time .", "label": 0}, {"idx": "cosqa-train-553", "doc": "filter uniques from python list", "code": "def uniq(seq):\n    \"\"\" Return a copy of seq without duplicates. \"\"\"\n    seen = set()\n    return [x for x in seq if str(x) not in seen and not seen.add(str(x))]", "code_tokens": "def uniq ( seq ) : seen = set ( ) return [ x for x in seq if str ( x ) not in seen and not seen . add ( str ( x ) ) ]", "docstring_tokens": "Return a copy of seq without duplicates .", "label": 0}, {"idx": "cosqa-train-554", "doc": "python heapq get last element", "code": "def pop(h):\n    \"\"\"Pop the heap value from the heap.\"\"\"\n    n = h.size() - 1\n    h.swap(0, n)\n    down(h, 0, n)\n    return h.pop()", "code_tokens": "def pop ( h ) : n = h . size ( ) - 1 h . swap ( 0 , n ) down ( h , 0 , n ) return h . pop ( )", "docstring_tokens": "Pop the heap value from the heap .", "label": 0}, {"idx": "cosqa-train-555", "doc": "find/replace in a file python", "code": "def replace_all(filepath, searchExp, replaceExp):\n    \"\"\"\n    Replace all the ocurrences (in a file) of a string with another value.\n    \"\"\"\n    for line in fileinput.input(filepath, inplace=1):\n        if searchExp in line:\n            line = line.replace(searchExp, replaceExp)\n        sys.stdout.write(line)", "code_tokens": "def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )", "docstring_tokens": "Replace all the ocurrences ( in a file ) of a string with another value .", "label": 0}, {"idx": "cosqa-train-556", "doc": "python histogram matplotlib kwargs", "code": "def __call__(self, kind: Optional[str] = None, **kwargs):\n        \"\"\"Use the plotter as callable.\"\"\"\n        return plot(self.histogram, kind=kind, **kwargs)", "code_tokens": "def __call__ ( self , kind : Optional [ str ] = None , * * kwargs ) : return plot ( self . histogram , kind = kind , * * kwargs )", "docstring_tokens": "Use the plotter as callable .", "label": 0}, {"idx": "cosqa-train-557", "doc": "finding 25 percent points in distribution python", "code": "def ci(a, which=95, axis=None):\n    \"\"\"Return a percentile range from an array of values.\"\"\"\n    p = 50 - which / 2, 50 + which / 2\n    return percentiles(a, p, axis)", "code_tokens": "def ci ( a , which = 95 , axis = None ) : p = 50 - which / 2 , 50 + which / 2 return percentiles ( a , p , axis )", "docstring_tokens": "Return a percentile range from an array of values .", "label": 0}, {"idx": "cosqa-train-558", "doc": "python how do i know what data type", "code": "def dtype(self):\n        \"\"\"Pixel data type.\"\"\"\n        try:\n            return self.data.dtype\n        except AttributeError:\n            return numpy.dtype('%s%d' % (self._sample_type, self._sample_bytes))", "code_tokens": "def dtype ( self ) : try : return self . data . dtype except AttributeError : return numpy . dtype ( '%s%d' % ( self . _sample_type , self . _sample_bytes ) )", "docstring_tokens": "Pixel data type .", "label": 0}, {"idx": "cosqa-train-559", "doc": "finding a string in a python tuple", "code": "def tuple_search(t, i, v):\n    \"\"\"\n    Search tuple array by index and value\n    :param t: tuple array\n    :param i: index of the value in each tuple\n    :param v: value\n    :return: the first tuple in the array with the specific index / value\n    \"\"\"\n    for e in t:\n        if e[i] == v:\n            return e\n    return None", "code_tokens": "def tuple_search ( t , i , v ) : for e in t : if e [ i ] == v : return e return None", "docstring_tokens": "Search tuple array by index and value : param t : tuple array : param i : index of the value in each tuple : param v : value : return : the first tuple in the array with the specific index / value", "label": 0}, {"idx": "cosqa-train-560", "doc": "python how join to lists as pairs", "code": "def from_pairs_to_array_values(pairs):\n    \"\"\"\n        Like from pairs but combines duplicate key values into arrays\n    :param pairs:\n    :return:\n    \"\"\"\n    result = {}\n    for pair in pairs:\n        result[pair[0]] = concat(prop_or([], pair[0], result), [pair[1]])\n    return result", "code_tokens": "def from_pairs_to_array_values ( pairs ) : result = { } for pair in pairs : result [ pair [ 0 ] ] = concat ( prop_or ( [ ] , pair [ 0 ] , result ) , [ pair [ 1 ] ] ) return result", "docstring_tokens": "Like from pairs but combines duplicate key values into arrays : param pairs : : return :", "label": 0}, {"idx": "cosqa-train-561", "doc": "finding area of an irregular polygon python", "code": "def area(x,y):\n    \"\"\"\n    Calculate the area of a polygon given as x(...),y(...)\n    Implementation of Shoelace formula\n    \"\"\"\n    # http://stackoverflow.com/questions/24467972/calculate-area-of-polygon-given-x-y-coordinates\n    return 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1)))", "code_tokens": "def area ( x , y ) : # http://stackoverflow.com/questions/24467972/calculate-area-of-polygon-given-x-y-coordinates return 0.5 * np . abs ( np . dot ( x , np . roll ( y , 1 ) ) - np . dot ( y , np . roll ( x , 1 ) ) )", "docstring_tokens": "Calculate the area of a polygon given as x ( ... ) y ( ... ) Implementation of Shoelace formula", "label": 0}, {"idx": "cosqa-train-562", "doc": "python how to autocomplate to show super method", "code": "def _getSuperFunc(self, s, func):\n        \"\"\"Return the the super function.\"\"\"\n\n        return getattr(super(self.cls(), s), func.__name__)", "code_tokens": "def _getSuperFunc ( self , s , func ) : return getattr ( super ( self . cls ( ) , s ) , func . __name__ )", "docstring_tokens": "Return the the super function .", "label": 0}, {"idx": "cosqa-train-563", "doc": "finding center of histogram bins python", "code": "def val_to_bin(edges, x):\n    \"\"\"Convert axis coordinate to bin index.\"\"\"\n    ibin = np.digitize(np.array(x, ndmin=1), edges) - 1\n    return ibin", "code_tokens": "def val_to_bin ( edges , x ) : ibin = np . digitize ( np . array ( x , ndmin = 1 ) , edges ) - 1 return ibin", "docstring_tokens": "Convert axis coordinate to bin index .", "label": 0}, {"idx": "cosqa-train-564", "doc": "python how to calculate bins from bin edges", "code": "def val_to_bin(edges, x):\n    \"\"\"Convert axis coordinate to bin index.\"\"\"\n    ibin = np.digitize(np.array(x, ndmin=1), edges) - 1\n    return ibin", "code_tokens": "def val_to_bin ( edges , x ) : ibin = np . digitize ( np . array ( x , ndmin = 1 ) , edges ) - 1 return ibin", "docstring_tokens": "Convert axis coordinate to bin index .", "label": 0}, {"idx": "cosqa-train-565", "doc": "finding common values in dictionaries python", "code": "def compare(dicts):\n    \"\"\"Compare by iteration\"\"\"\n\n    common_members = {}\n    common_keys = reduce(lambda x, y: x & y, map(dict.keys, dicts))\n    for k in common_keys:\n        common_members[k] = list(\n            reduce(lambda x, y: x & y, [set(d[k]) for d in dicts]))\n\n    return common_members", "code_tokens": "def compare ( dicts ) : common_members = { } common_keys = reduce ( lambda x , y : x & y , map ( dict . keys , dicts ) ) for k in common_keys : common_members [ k ] = list ( reduce ( lambda x , y : x & y , [ set ( d [ k ] ) for d in dicts ] ) ) return common_members", "docstring_tokens": "Compare by iteration", "label": 0}, {"idx": "cosqa-train-566", "doc": "python how to cast string to timestamp", "code": "def convert_timestamp(timestamp):\n    \"\"\"\n    Converts bokehJS timestamp to datetime64.\n    \"\"\"\n    datetime = dt.datetime.utcfromtimestamp(timestamp/1000.)\n    return np.datetime64(datetime.replace(tzinfo=None))", "code_tokens": "def convert_timestamp ( timestamp ) : datetime = dt . datetime . utcfromtimestamp ( timestamp / 1000. ) return np . datetime64 ( datetime . replace ( tzinfo = None ) )", "docstring_tokens": "Converts bokehJS timestamp to datetime64 .", "label": 0}, {"idx": "cosqa-train-567", "doc": "finding extensions of files through python", "code": "def _get_compiled_ext():\n    \"\"\"Official way to get the extension of compiled files (.pyc or .pyo)\"\"\"\n    for ext, mode, typ in imp.get_suffixes():\n        if typ == imp.PY_COMPILED:\n            return ext", "code_tokens": "def _get_compiled_ext ( ) : for ext , mode , typ in imp . get_suffixes ( ) : if typ == imp . PY_COMPILED : return ext", "docstring_tokens": "Official way to get the extension of compiled files ( . pyc or . pyo )", "label": 0}, {"idx": "cosqa-train-568", "doc": "python how to change list items to capital", "code": "def list_add_capitalize(l):\n    \"\"\"\n    @type l: list\n    @return: list\n    \"\"\"\n    nl = []\n\n    for i in l:\n        nl.append(i)\n\n        if hasattr(i, \"capitalize\"):\n            nl.append(i.capitalize())\n\n    return list(set(nl))", "code_tokens": "def list_add_capitalize ( l ) : nl = [ ] for i in l : nl . append ( i ) if hasattr ( i , \"capitalize\" ) : nl . append ( i . capitalize ( ) ) return list ( set ( nl ) )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-569", "doc": "finding inverse of matrix in python", "code": "def inh(table):\n    \"\"\"\n    inverse hyperbolic sine transformation\n    \"\"\"\n    t = []\n    for i in table:\n        t.append(np.ndarray.tolist(np.arcsinh(i)))\n    return t", "code_tokens": "def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "docstring_tokens": "inverse hyperbolic sine transformation", "label": 0}, {"idx": "cosqa-train-570", "doc": "python how to change text to uppercase", "code": "def to_camel_case(text):\n    \"\"\"Convert to camel case.\n\n    :param str text:\n    :rtype: str\n    :return:\n    \"\"\"\n    split = text.split('_')\n    return split[0] + \"\".join(x.title() for x in split[1:])", "code_tokens": "def to_camel_case ( text ) : split = text . split ( '_' ) return split [ 0 ] + \"\" . join ( x . title ( ) for x in split [ 1 : ] )", "docstring_tokens": "Convert to camel case .", "label": 0}, {"idx": "cosqa-train-571", "doc": "finding median of list python", "code": "def median(lst):\n    \"\"\" Calcuates the median value in a @lst \"\"\"\n    #: http://stackoverflow.com/a/24101534\n    sortedLst = sorted(lst)\n    lstLen = len(lst)\n    index = (lstLen - 1) // 2\n    if (lstLen % 2):\n        return sortedLst[index]\n    else:\n        return (sortedLst[index] + sortedLst[index + 1])/2.0", "code_tokens": "def median ( lst ) : #: http://stackoverflow.com/a/24101534 sortedLst = sorted ( lst ) lstLen = len ( lst ) index = ( lstLen - 1 ) // 2 if ( lstLen % 2 ) : return sortedLst [ index ] else : return ( sortedLst [ index ] + sortedLst [ index + 1 ] ) / 2.0", "docstring_tokens": "Calcuates the median value in a", "label": 0}, {"idx": "cosqa-train-572", "doc": "python how to check if a database query failed", "code": "def _IsRetryable(error):\n  \"\"\"Returns whether error is likely to be retryable.\"\"\"\n  if not isinstance(error, MySQLdb.OperationalError):\n    return False\n  if not error.args:\n    return False\n  code = error.args[0]\n  return code in _RETRYABLE_ERRORS", "code_tokens": "def _IsRetryable ( error ) : if not isinstance ( error , MySQLdb . OperationalError ) : return False if not error . args : return False code = error . args [ 0 ] return code in _RETRYABLE_ERRORS", "docstring_tokens": "Returns whether error is likely to be retryable .", "label": 0}, {"idx": "cosqa-train-573", "doc": "finding multiple strings using regex in python", "code": "def iter_finds(regex_obj, s):\n    \"\"\"Generate all matches found within a string for a regex and yield each match as a string\"\"\"\n    if isinstance(regex_obj, str):\n        for m in re.finditer(regex_obj, s):\n            yield m.group()\n    else:\n        for m in regex_obj.finditer(s):\n            yield m.group()", "code_tokens": "def iter_finds ( regex_obj , s ) : if isinstance ( regex_obj , str ) : for m in re . finditer ( regex_obj , s ) : yield m . group ( ) else : for m in regex_obj . finditer ( s ) : yield m . group ( )", "docstring_tokens": "Generate all matches found within a string for a regex and yield each match as a string", "label": 0}, {"idx": "cosqa-train-574", "doc": "python how to check if a process exists by pid", "code": "def pid_exists(pid):\n    \"\"\" Determines if a system process identifer exists in process table.\n        \"\"\"\n    try:\n        os.kill(pid, 0)\n    except OSError as exc:\n        return exc.errno == errno.EPERM\n    else:\n        return True", "code_tokens": "def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True", "docstring_tokens": "Determines if a system process identifer exists in process table .", "label": 0}, {"idx": "cosqa-train-575", "doc": "finding prime and divisors python", "code": "def getPrimeFactors(n):\n    \"\"\"\n    Get all the prime factor of given integer\n    @param n integer\n    @return list [1, ..., n]\n    \"\"\"\n    lo = [1]\n    n2 = n // 2\n    k = 2\n    for k in range(2, n2 + 1):\n        if (n // k)*k == n:\n            lo.append(k)\n    return lo + [n, ]", "code_tokens": "def getPrimeFactors ( n ) : lo = [ 1 ] n2 = n // 2 k = 2 for k in range ( 2 , n2 + 1 ) : if ( n // k ) * k == n : lo . append ( k ) return lo + [ n , ]", "docstring_tokens": "Get all the prime factor of given integer", "label": 0}, {"idx": "cosqa-train-576", "doc": "python how to check if datattype is string", "code": "def _isstring(dtype):\n    \"\"\"Given a numpy dtype, determines whether it is a string. Returns True\n    if the dtype is string or unicode.\n    \"\"\"\n    return dtype.type == numpy.unicode_ or dtype.type == numpy.string_", "code_tokens": "def _isstring ( dtype ) : return dtype . type == numpy . unicode_ or dtype . type == numpy . string_", "docstring_tokens": "Given a numpy dtype determines whether it is a string . Returns True if the dtype is string or unicode .", "label": 0}, {"idx": "cosqa-train-577", "doc": "finding the two smallest values in a list python", "code": "def find_lt(a, x):\n    \"\"\"Find rightmost value less than x.\"\"\"\n    i = bs.bisect_left(a, x)\n    if i: return i - 1\n    raise ValueError", "code_tokens": "def find_lt ( a , x ) : i = bs . bisect_left ( a , x ) if i : return i - 1 raise ValueError", "docstring_tokens": "Find rightmost value less than x .", "label": 0}, {"idx": "cosqa-train-578", "doc": "python how to check if method is overload", "code": "def _is_override(meta, method):\n        \"\"\"Checks whether given class or instance method has been marked\n        with the ``@override`` decorator.\n        \"\"\"\n        from taipan.objective.modifiers import _OverriddenMethod\n        return isinstance(method, _OverriddenMethod)", "code_tokens": "def _is_override ( meta , method ) : from taipan . objective . modifiers import _OverriddenMethod return isinstance ( method , _OverriddenMethod )", "docstring_tokens": "Checks whether given class or instance method has been marked with the", "label": 1}, {"idx": "cosqa-train-579", "doc": "finding what points are contained in polygon python", "code": "def is_in(self, point_x, point_y):\n        \"\"\" Test if a point is within this polygonal region \"\"\"\n\n        point_array = array(((point_x, point_y),))\n        vertices = array(self.points)\n        winding = self.inside_rule == \"winding\"\n        result = points_in_polygon(point_array, vertices, winding)\n        return result[0]", "code_tokens": "def is_in ( self , point_x , point_y ) : point_array = array ( ( ( point_x , point_y ) , ) ) vertices = array ( self . points ) winding = self . inside_rule == \"winding\" result = points_in_polygon ( point_array , vertices , winding ) return result [ 0 ]", "docstring_tokens": "Test if a point is within this polygonal region", "label": 0}, {"idx": "cosqa-train-580", "doc": "python how to check logging is disabled", "code": "def should_skip_logging(func):\n    \"\"\"\n    Should we skip logging for this handler?\n\n    \"\"\"\n    disabled = strtobool(request.headers.get(\"x-request-nolog\", \"false\"))\n    return disabled or getattr(func, SKIP_LOGGING, False)", "code_tokens": "def should_skip_logging ( func ) : disabled = strtobool ( request . headers . get ( \"x-request-nolog\" , \"false\" ) ) return disabled or getattr ( func , SKIP_LOGGING , False )", "docstring_tokens": "Should we skip logging for this handler?", "label": 1}, {"idx": "cosqa-train-581", "doc": "fit r like formula model in python without intercept", "code": "def calc_cR(Q2, sigma):\n    \"\"\"Returns the cR statistic for the variogram fit (see [1]).\"\"\"\n    return Q2 * np.exp(np.sum(np.log(sigma**2))/sigma.shape[0])", "code_tokens": "def calc_cR ( Q2 , sigma ) : return Q2 * np . exp ( np . sum ( np . log ( sigma ** 2 ) ) / sigma . shape [ 0 ] )", "docstring_tokens": "Returns the cR statistic for the variogram fit ( see [ 1 ] ) .", "label": 0}, {"idx": "cosqa-train-582", "doc": "python how to check methods implemented in a type", "code": "def is_builtin_type(tp):\n    \"\"\"Checks if the given type is a builtin one.\n    \"\"\"\n    return hasattr(__builtins__, tp.__name__) and tp is getattr(__builtins__, tp.__name__)", "code_tokens": "def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )", "docstring_tokens": "Checks if the given type is a builtin one .", "label": 0}, {"idx": "cosqa-train-583", "doc": "fit the variables into a equation python", "code": "def apply_fit(xy,coeffs):\n    \"\"\" Apply the coefficients from a linear fit to\n        an array of x,y positions.\n\n        The coeffs come from the 'coeffs' member of the\n        'fit_arrays()' output.\n    \"\"\"\n    x_new = coeffs[0][2] + coeffs[0][0]*xy[:,0] + coeffs[0][1]*xy[:,1]\n    y_new = coeffs[1][2] + coeffs[1][0]*xy[:,0] + coeffs[1][1]*xy[:,1]\n\n    return x_new,y_new", "code_tokens": "def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "docstring_tokens": "Apply the coefficients from a linear fit to an array of x y positions .", "label": 0}, {"idx": "cosqa-train-584", "doc": "python how to clear a variables value", "code": "def forget_coords(self):\n        \"\"\"Forget all loaded coordinates.\"\"\"\n        self.w.ntotal.set_text('0')\n        self.coords_dict.clear()\n        self.redo()", "code_tokens": "def forget_coords ( self ) : self . w . ntotal . set_text ( '0' ) self . coords_dict . clear ( ) self . redo ( )", "docstring_tokens": "Forget all loaded coordinates .", "label": 0}, {"idx": "cosqa-train-585", "doc": "flatten list of list python using yield", "code": "def flat_list(lst):\n    \"\"\"This function flatten given nested list.\n    Argument:\n        nested list\n    Returns:\n        flat list\n    \"\"\"\n    if isinstance(lst, list):\n        for item in lst:\n            for i in flat_list(item):\n                yield i\n    else:\n        yield lst", "code_tokens": "def flat_list ( lst ) : if isinstance ( lst , list ) : for item in lst : for i in flat_list ( item ) : yield i else : yield lst", "docstring_tokens": "This function flatten given nested list . Argument : nested list Returns : flat list", "label": 0}, {"idx": "cosqa-train-586", "doc": "python how to close and if", "code": "def safe_exit(output):\n    \"\"\"exit without breaking pipes.\"\"\"\n    try:\n        sys.stdout.write(output)\n        sys.stdout.flush()\n    except IOError:\n        pass", "code_tokens": "def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass", "docstring_tokens": "exit without breaking pipes .", "label": 0}, {"idx": "cosqa-train-587", "doc": "flip a 1d vector python", "code": "def imflip(img, direction='horizontal'):\n    \"\"\"Flip an image horizontally or vertically.\n\n    Args:\n        img (ndarray): Image to be flipped.\n        direction (str): The flip direction, either \"horizontal\" or \"vertical\".\n\n    Returns:\n        ndarray: The flipped image.\n    \"\"\"\n    assert direction in ['horizontal', 'vertical']\n    if direction == 'horizontal':\n        return np.flip(img, axis=1)\n    else:\n        return np.flip(img, axis=0)", "code_tokens": "def imflip ( img , direction = 'horizontal' ) : assert direction in [ 'horizontal' , 'vertical' ] if direction == 'horizontal' : return np . flip ( img , axis = 1 ) else : return np . flip ( img , axis = 0 )", "docstring_tokens": "Flip an image horizontally or vertically .", "label": 0}, {"idx": "cosqa-train-588", "doc": "python how to create a ordered dict", "code": "def get_order(self):\n        \"\"\"\n        Return a list of dicionaries. See `set_order`.\n        \"\"\"\n        return [dict(reverse=r[0], key=r[1]) for r in self.get_model()]", "code_tokens": "def get_order ( self ) : return [ dict ( reverse = r [ 0 ] , key = r [ 1 ] ) for r in self . get_model ( ) ]", "docstring_tokens": "Return a list of dicionaries . See set_order .", "label": 0}, {"idx": "cosqa-train-589", "doc": "flip image vertical python", "code": "def hflip(img):\n    \"\"\"Horizontally flip the given PIL Image.\n\n    Args:\n        img (PIL Image): Image to be flipped.\n\n    Returns:\n        PIL Image:  Horizontall flipped image.\n    \"\"\"\n    if not _is_pil_image(img):\n        raise TypeError('img should be PIL Image. Got {}'.format(type(img)))\n\n    return img.transpose(Image.FLIP_LEFT_RIGHT)", "code_tokens": "def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )", "docstring_tokens": "Horizontally flip the given PIL Image .", "label": 0}, {"idx": "cosqa-train-590", "doc": "python how to create dir", "code": "def mkdir(dir, enter):\n    \"\"\"Create directory with template for topic of the current environment\n\n    \"\"\"\n\n    if not os.path.exists(dir):\n        os.makedirs(dir)", "code_tokens": "def mkdir ( dir , enter ) : if not os . path . exists ( dir ) : os . makedirs ( dir )", "docstring_tokens": "Create directory with template for topic of the current environment", "label": 0}, {"idx": "cosqa-train-591", "doc": "frequency of a word in a document python", "code": "def get_document_frequency(self, term):\n        \"\"\"\n        Returns the number of documents the specified term appears in.\n        \"\"\"\n        if term not in self._terms:\n            raise IndexError(TERM_DOES_NOT_EXIST)\n        else:\n            return len(self._terms[term])", "code_tokens": "def get_document_frequency ( self , term ) : if term not in self . _terms : raise IndexError ( TERM_DOES_NOT_EXIST ) else : return len ( self . _terms [ term ] )", "docstring_tokens": "Returns the number of documents the specified term appears in .", "label": 0}, {"idx": "cosqa-train-592", "doc": "python how to disconnect signal from a widget", "code": "def destroy(self):\n        \"\"\" Cleanup the activty lifecycle listener \"\"\"\n        if self.widget:\n            self.set_active(False)\n        super(AndroidBarcodeView, self).destroy()", "code_tokens": "def destroy ( self ) : if self . widget : self . set_active ( False ) super ( AndroidBarcodeView , self ) . destroy ( )", "docstring_tokens": "Cleanup the activty lifecycle listener", "label": 0}, {"idx": "cosqa-train-593", "doc": "ftplib python secure connection", "code": "def connect():\n    \"\"\"Connect to FTP server, login and return an ftplib.FTP instance.\"\"\"\n    ftp_class = ftplib.FTP if not SSL else ftplib.FTP_TLS\n    ftp = ftp_class(timeout=TIMEOUT)\n    ftp.connect(HOST, PORT)\n    ftp.login(USER, PASSWORD)\n    if SSL:\n        ftp.prot_p()  # secure data connection\n    return ftp", "code_tokens": "def connect ( ) : ftp_class = ftplib . FTP if not SSL else ftplib . FTP_TLS ftp = ftp_class ( timeout = TIMEOUT ) ftp . connect ( HOST , PORT ) ftp . login ( USER , PASSWORD ) if SSL : ftp . prot_p ( ) # secure data connection return ftp", "docstring_tokens": "Connect to FTP server login and return an ftplib . FTP instance .", "label": 1}, {"idx": "cosqa-train-594", "doc": "python how to dowload all dependencies", "code": "def one_for_all(self, deps):\n        \"\"\"Because there are dependencies that depend on other\n        dependencies are created lists into other lists.\n        Thus creating this loop create one-dimensional list and\n        remove double packages from dependencies.\n        \"\"\"\n        requires, dependencies = [], []\n        deps.reverse()\n        # Inverting the list brings the\n        # dependencies in order to be installed.\n        requires = Utils().dimensional_list(deps)\n        dependencies = Utils().remove_dbs(requires)\n        return dependencies", "code_tokens": "def one_for_all ( self , deps ) : requires , dependencies = [ ] , [ ] deps . reverse ( ) # Inverting the list brings the # dependencies in order to be installed. requires = Utils ( ) . dimensional_list ( deps ) dependencies = Utils ( ) . remove_dbs ( requires ) return dependencies", "docstring_tokens": "Because there are dependencies that depend on other dependencies are created lists into other lists . Thus creating this loop create one - dimensional list and remove double packages from dependencies .", "label": 0}, {"idx": "cosqa-train-595", "doc": "full screen in python tkinter", "code": "def trigger_fullscreen_action(self, fullscreen):\n        \"\"\"\n        Toggle fullscreen from outside the GUI,\n        causes the GUI to updated and run all its actions.\n        \"\"\"\n        action = self.action_group.get_action('fullscreen')\n        action.set_active(fullscreen)", "code_tokens": "def trigger_fullscreen_action ( self , fullscreen ) : action = self . action_group . get_action ( 'fullscreen' ) action . set_active ( fullscreen )", "docstring_tokens": "Toggle fullscreen from outside the GUI causes the GUI to updated and run all its actions .", "label": 1}, {"idx": "cosqa-train-596", "doc": "python how to download a json url", "code": "def download_json(local_filename, url, clobber=False):\n    \"\"\"Download the given JSON file, and pretty-print before we output it.\"\"\"\n    with open(local_filename, 'w') as json_file:\n        json_file.write(json.dumps(requests.get(url).json(), sort_keys=True, indent=2, separators=(',', ': ')))", "code_tokens": "def download_json ( local_filename , url , clobber = False ) : with open ( local_filename , 'w' ) as json_file : json_file . write ( json . dumps ( requests . get ( url ) . json ( ) , sort_keys = True , indent = 2 , separators = ( ',' , ': ' ) ) )", "docstring_tokens": "Download the given JSON file and pretty - print before we output it .", "label": 0}, {"idx": "cosqa-train-597", "doc": "function to check strngth of password with regex in python", "code": "def is_password_valid(password):\n    \"\"\"\n    Check if a password is valid\n    \"\"\"\n    pattern = re.compile(r\"^.{4,75}$\")\n    return bool(pattern.match(password))", "code_tokens": "def is_password_valid ( password ) : pattern = re . compile ( r\"^.{4,75}$\" ) return bool ( pattern . match ( password ) )", "docstring_tokens": "Check if a password is valid", "label": 0}, {"idx": "cosqa-train-598", "doc": "python how to drag a element to another element and stay at second element", "code": "def drag_and_drop(self, droppable):\n        \"\"\"\n        Performs drag a element to another elmenet.\n\n        Currently works only on Chrome driver.\n        \"\"\"\n        self.scroll_to()\n        ActionChains(self.parent.driver).drag_and_drop(self._element, droppable._element).perform()", "code_tokens": "def drag_and_drop ( self , droppable ) : self . scroll_to ( ) ActionChains ( self . parent . driver ) . drag_and_drop ( self . _element , droppable . _element ) . perform ( )", "docstring_tokens": "Performs drag a element to another elmenet .", "label": 1}, {"idx": "cosqa-train-599", "doc": "gaussian distribution python formula", "code": "def gauss_pdf(x, mu, sigma):\n    \"\"\"Normalized Gaussian\"\"\"\n    return 1 / np.sqrt(2 * np.pi) / sigma * np.exp(-(x - mu) ** 2 / 2. / sigma ** 2)", "code_tokens": "def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )", "docstring_tokens": "Normalized Gaussian", "label": 0}, {"idx": "cosqa-train-600", "doc": "python how to encode url", "code": "def url_encode(url):\n    \"\"\"\n    Convert special characters using %xx escape.\n\n    :param url: str\n    :return: str - encoded url\n    \"\"\"\n    if isinstance(url, text_type):\n        url = url.encode('utf8')\n    return quote(url, ':/%?&=')", "code_tokens": "def url_encode ( url ) : if isinstance ( url , text_type ) : url = url . encode ( 'utf8' ) return quote ( url , ':/%?&=' )", "docstring_tokens": "Convert special characters using %xx escape .", "label": 1}, {"idx": "cosqa-train-601", "doc": "gaussian distribution python function", "code": "def gauss_pdf(x, mu, sigma):\n    \"\"\"Normalized Gaussian\"\"\"\n    return 1 / np.sqrt(2 * np.pi) / sigma * np.exp(-(x - mu) ** 2 / 2. / sigma ** 2)", "code_tokens": "def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )", "docstring_tokens": "Normalized Gaussian", "label": 0}, {"idx": "cosqa-train-602", "doc": "python how to enter a new line", "code": "def go_to_new_line(self):\n        \"\"\"Go to the end of the current line and create a new line\"\"\"\n        self.stdkey_end(False, False)\n        self.insert_text(self.get_line_separator())", "code_tokens": "def go_to_new_line ( self ) : self . stdkey_end ( False , False ) self . insert_text ( self . get_line_separator ( ) )", "docstring_tokens": "Go to the end of the current line and create a new line", "label": 0}, {"idx": "cosqa-train-603", "doc": "gdb execute python expression", "code": "def ExecuteRaw(self, position, command):\n    \"\"\"Send a command string to gdb.\"\"\"\n    self.EnsureGdbPosition(position[0], None, None)\n    return gdb.execute(command, to_string=True)", "code_tokens": "def ExecuteRaw ( self , position , command ) : self . EnsureGdbPosition ( position [ 0 ] , None , None ) return gdb . execute ( command , to_string = True )", "docstring_tokens": "Send a command string to gdb .", "label": 0}, {"idx": "cosqa-train-604", "doc": "python how to exit script for all threads", "code": "def finish():\n    \"\"\"Print warning about interrupt and empty the job queue.\"\"\"\n    out.warn(\"Interrupted!\")\n    for t in threads:\n        t.stop()\n    jobs.clear()\n    out.warn(\"Waiting for download threads to finish.\")", "code_tokens": "def finish ( ) : out . warn ( \"Interrupted!\" ) for t in threads : t . stop ( ) jobs . clear ( ) out . warn ( \"Waiting for download threads to finish.\" )", "docstring_tokens": "Print warning about interrupt and empty the job queue .", "label": 0}, {"idx": "cosqa-train-605", "doc": "generalized normal distribution python", "code": "def rlognormal(mu, tau, size=None):\n    \"\"\"\n    Return random lognormal variates.\n    \"\"\"\n\n    return np.random.lognormal(mu, np.sqrt(1. / tau), size)", "code_tokens": "def rlognormal ( mu , tau , size = None ) : return np . random . lognormal ( mu , np . sqrt ( 1. / tau ) , size )", "docstring_tokens": "Return random lognormal variates .", "label": 0}, {"idx": "cosqa-train-606", "doc": "python how to get a small bounding box around lat lon coordinate", "code": "def calculate_boundingbox(lng, lat, miles):\n    \"\"\"\n    Given a latitude, longitude and a distance in miles, calculate\n    the co-ordinates of the bounding box 2*miles on long each side with the\n    given co-ordinates at the center.\n    \"\"\"\n\n    latChange = change_in_latitude(miles)\n    latSouth = lat - latChange\n    latNorth = lat + latChange\n    lngChange = change_in_longitude(lat, miles)\n    lngWest = lng + lngChange\n    lngEast = lng - lngChange\n    return (lngWest, latSouth, lngEast, latNorth)", "code_tokens": "def calculate_boundingbox ( lng , lat , miles ) : latChange = change_in_latitude ( miles ) latSouth = lat - latChange latNorth = lat + latChange lngChange = change_in_longitude ( lat , miles ) lngWest = lng + lngChange lngEast = lng - lngChange return ( lngWest , latSouth , lngEast , latNorth )", "docstring_tokens": "Given a latitude longitude and a distance in miles calculate the co - ordinates of the bounding box 2 * miles on long each side with the given co - ordinates at the center .", "label": 0}, {"idx": "cosqa-train-607", "doc": "generarating random strings in python", "code": "def uniqueID(size=6, chars=string.ascii_uppercase + string.digits):\n    \"\"\"A quick and dirty way to get a unique string\"\"\"\n    return ''.join(random.choice(chars) for x in xrange(size))", "code_tokens": "def uniqueID ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return '' . join ( random . choice ( chars ) for x in xrange ( size ) )", "docstring_tokens": "A quick and dirty way to get a unique string", "label": 0}, {"idx": "cosqa-train-608", "doc": "python how to get base64 encoded string", "code": "def toBase64(s):\n    \"\"\"Represent string / bytes s as base64, omitting newlines\"\"\"\n    if isinstance(s, str):\n        s = s.encode(\"utf-8\")\n    return binascii.b2a_base64(s)[:-1]", "code_tokens": "def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( \"utf-8\" ) return binascii . b2a_base64 ( s ) [ : - 1 ]", "docstring_tokens": "Represent string / bytes s as base64 omitting newlines", "label": 0}, {"idx": "cosqa-train-609", "doc": "generate maps between entities in python", "code": "def _generate_key_map(entity_list, key, entity_class):\n    \"\"\" Helper method to generate map from key to entity object for given list of dicts.\n\n    Args:\n      entity_list: List consisting of dict.\n      key: Key in each dict which will be key in the map.\n      entity_class: Class representing the entity.\n\n    Returns:\n      Map mapping key to entity object.\n    \"\"\"\n\n    key_map = {}\n    for obj in entity_list:\n      key_map[obj[key]] = entity_class(**obj)\n\n    return key_map", "code_tokens": "def _generate_key_map ( entity_list , key , entity_class ) : key_map = { } for obj in entity_list : key_map [ obj [ key ] ] = entity_class ( * * obj ) return key_map", "docstring_tokens": "Helper method to generate map from key to entity object for given list of dicts .", "label": 1}, {"idx": "cosqa-train-610", "doc": "python how to get dict intersection", "code": "def intersect(d1, d2):\n    \"\"\"Intersect dictionaries d1 and d2 by key *and* value.\"\"\"\n    return dict((k, d1[k]) for k in d1 if k in d2 and d1[k] == d2[k])", "code_tokens": "def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )", "docstring_tokens": "Intersect dictionaries d1 and d2 by key * and * value .", "label": 1}, {"idx": "cosqa-train-611", "doc": "generate random (x,y) pairs python", "code": "def _rndPointDisposition(dx, dy):\n        \"\"\"Return random disposition point.\"\"\"\n        x = int(random.uniform(-dx, dx))\n        y = int(random.uniform(-dy, dy))\n        return (x, y)", "code_tokens": "def _rndPointDisposition ( dx , dy ) : x = int ( random . uniform ( - dx , dx ) ) y = int ( random . uniform ( - dy , dy ) ) return ( x , y )", "docstring_tokens": "Return random disposition point .", "label": 0}, {"idx": "cosqa-train-612", "doc": "python how to get length of array", "code": "def array_dim(arr):\n    \"\"\"Return the size of a multidimansional array.\n    \"\"\"\n    dim = []\n    while True:\n        try:\n            dim.append(len(arr))\n            arr = arr[0]\n        except TypeError:\n            return dim", "code_tokens": "def array_dim ( arr ) : dim = [ ] while True : try : dim . append ( len ( arr ) ) arr = arr [ 0 ] except TypeError : return dim", "docstring_tokens": "Return the size of a multidimansional array .", "label": 0}, {"idx": "cosqa-train-613", "doc": "generate sine wave python", "code": "def sine_wave(frequency):\n  \"\"\"Emit a sine wave at the given frequency.\"\"\"\n  xs = tf.reshape(tf.range(_samples(), dtype=tf.float32), [1, _samples(), 1])\n  ts = xs / FLAGS.sample_rate\n  return tf.sin(2 * math.pi * frequency * ts)", "code_tokens": "def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )", "docstring_tokens": "Emit a sine wave at the given frequency .", "label": 0}, {"idx": "cosqa-train-614", "doc": "python how to get the index of a rank", "code": "def rank(idx, dim):\n    \"\"\"Calculate the index rank according to Bertran's notation.\"\"\"\n    idxm = multi_index(idx, dim)\n    out = 0\n    while idxm[-1:] == (0,):\n        out += 1\n        idxm = idxm[:-1]\n    return out", "code_tokens": "def rank ( idx , dim ) : idxm = multi_index ( idx , dim ) out = 0 while idxm [ - 1 : ] == ( 0 , ) : out += 1 idxm = idxm [ : - 1 ] return out", "docstring_tokens": "Calculate the index rank according to Bertran s notation .", "label": 1}, {"idx": "cosqa-train-615", "doc": "generate string from array python", "code": "def bitsToString(arr):\n  \"\"\"Returns a string representing a numpy array of 0's and 1's\"\"\"\n  s = array('c','.'*len(arr))\n  for i in xrange(len(arr)):\n    if arr[i] == 1:\n      s[i]='*'\n  return s", "code_tokens": "def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s", "docstring_tokens": "Returns a string representing a numpy array of 0 s and 1 s", "label": 1}, {"idx": "cosqa-train-616", "doc": "python how to get the index of minimum value in an array", "code": "def find_nearest_index(arr, value):\n    \"\"\"For a given value, the function finds the nearest value\n    in the array and returns its index.\"\"\"\n    arr = np.array(arr)\n    index = (abs(arr-value)).argmin()\n    return index", "code_tokens": "def find_nearest_index ( arr , value ) : arr = np . array ( arr ) index = ( abs ( arr - value ) ) . argmin ( ) return index", "docstring_tokens": "For a given value the function finds the nearest value in the array and returns its index .", "label": 1}, {"idx": "cosqa-train-617", "doc": "generating random strings from a variable in python", "code": "def _get_random_id():\n    \"\"\" Get a random (i.e., unique) string identifier\"\"\"\n    symbols = string.ascii_uppercase + string.ascii_lowercase + string.digits\n    return ''.join(random.choice(symbols) for _ in range(15))", "code_tokens": "def _get_random_id ( ) : symbols = string . ascii_uppercase + string . ascii_lowercase + string . digits return '' . join ( random . choice ( symbols ) for _ in range ( 15 ) )", "docstring_tokens": "Get a random ( i . e . unique ) string identifier", "label": 0}, {"idx": "cosqa-train-618", "doc": "python how to jump to next calculation", "code": "def do_next(self, args):\n        \"\"\"Step over the next statement\n        \"\"\"\n        self._do_print_from_last_cmd = True\n        self._interp.step_over()\n        return True", "code_tokens": "def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "docstring_tokens": "Step over the next statement", "label": 0}, {"idx": "cosqa-train-619", "doc": "generating random unique strings in python", "code": "def uniqueID(size=6, chars=string.ascii_uppercase + string.digits):\n    \"\"\"A quick and dirty way to get a unique string\"\"\"\n    return ''.join(random.choice(chars) for x in xrange(size))", "code_tokens": "def uniqueID ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return '' . join ( random . choice ( chars ) for x in xrange ( size ) )", "docstring_tokens": "A quick and dirty way to get a unique string", "label": 0}, {"idx": "cosqa-train-620", "doc": "python how to keep file permissions after transferring files", "code": "def make_file_read_only(file_path):\n    \"\"\"\n    Removes the write permissions for the given file for owner, groups and others.\n\n    :param file_path: The file whose privileges are revoked.\n    :raise FileNotFoundError: If the given file does not exist.\n    \"\"\"\n    old_permissions = os.stat(file_path).st_mode\n    os.chmod(file_path, old_permissions & ~WRITE_PERMISSIONS)", "code_tokens": "def make_file_read_only ( file_path ) : old_permissions = os . stat ( file_path ) . st_mode os . chmod ( file_path , old_permissions & ~ WRITE_PERMISSIONS )", "docstring_tokens": "Removes the write permissions for the given file for owner groups and others .", "label": 0}, {"idx": "cosqa-train-621", "doc": "get angle given three points python", "code": "def angle(x0, y0, x1, y1):\n    \"\"\" Returns the angle between two points.\n    \"\"\"\n    return degrees(atan2(y1-y0, x1-x0))", "code_tokens": "def angle ( x0 , y0 , x1 , y1 ) : return degrees ( atan2 ( y1 - y0 , x1 - x0 ) )", "docstring_tokens": "Returns the angle between two points .", "label": 0}, {"idx": "cosqa-train-622", "doc": "python how to make a deepcopy of a dictionary", "code": "def copy(self):\n        \"\"\"\n        Return a copy of the dictionary.\n\n        This is a middle-deep copy; the copy is independent of the original in\n        all attributes that have mutable types except for:\n\n        * The values in the dictionary\n\n        Note that the Python functions :func:`py:copy.copy` and\n        :func:`py:copy.deepcopy` can be used to create completely shallow or\n        completely deep copies of objects of this class.\n        \"\"\"\n        result = NocaseDict()\n        result._data = self._data.copy()  # pylint: disable=protected-access\n        return result", "code_tokens": "def copy ( self ) : result = NocaseDict ( ) result . _data = self . _data . copy ( ) # pylint: disable=protected-access return result", "docstring_tokens": "Return a copy of the dictionary .", "label": 0}, {"idx": "cosqa-train-623", "doc": "get array with longest length python", "code": "def longest_run(da, dim='time'):\n    \"\"\"Return the length of the longest consecutive run of True values.\n\n        Parameters\n        ----------\n        arr : N-dimensional array (boolean)\n          Input array\n        dim : Xarray dimension (default = 'time')\n          Dimension along which to calculate consecutive run\n\n        Returns\n        -------\n        N-dimensional array (int)\n          Length of longest run of True values along dimension\n        \"\"\"\n\n    d = rle(da, dim=dim)\n    rl_long = d.max(dim=dim)\n\n    return rl_long", "code_tokens": "def longest_run ( da , dim = 'time' ) : d = rle ( da , dim = dim ) rl_long = d . max ( dim = dim ) return rl_long", "docstring_tokens": "Return the length of the longest consecutive run of True values .", "label": 1}, {"idx": "cosqa-train-624", "doc": "python how to make a file read only in python", "code": "def fopenat(base_fd, path):\n    \"\"\"\n    Does openat read-only, then does fdopen to get a file object\n    \"\"\"\n\n    return os.fdopen(openat(base_fd, path, os.O_RDONLY), 'rb')", "code_tokens": "def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )", "docstring_tokens": "Does openat read - only then does fdopen to get a file object", "label": 0}, {"idx": "cosqa-train-625", "doc": "get attributes of all ancestors python", "code": "def vars_class(cls):\n    \"\"\"Return a dict of vars for the given class, including all ancestors.\n\n    This differs from the usual behaviour of `vars` which returns attributes\n    belonging to the given class and not its ancestors.\n    \"\"\"\n    return dict(chain.from_iterable(\n        vars(cls).items() for cls in reversed(cls.__mro__)))", "code_tokens": "def vars_class ( cls ) : return dict ( chain . from_iterable ( vars ( cls ) . items ( ) for cls in reversed ( cls . __mro__ ) ) )", "docstring_tokens": "Return a dict of vars for the given class including all ancestors .", "label": 0}, {"idx": "cosqa-train-626", "doc": "python how to make a flaten list", "code": "def flatten(l, types=(list, float)):\n    \"\"\"\n    Flat nested list of lists into a single list.\n    \"\"\"\n    l = [item if isinstance(item, types) else [item] for item in l]\n    return [item for sublist in l for item in sublist]", "code_tokens": "def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Flat nested list of lists into a single list .", "label": 0}, {"idx": "cosqa-train-627", "doc": "get average of date array python", "code": "def mean_date(dt_list):\n    \"\"\"Calcuate mean datetime from datetime list\n    \"\"\"\n    dt_list_sort = sorted(dt_list)\n    dt_list_sort_rel = [dt - dt_list_sort[0] for dt in dt_list_sort]\n    avg_timedelta = sum(dt_list_sort_rel, timedelta())/len(dt_list_sort_rel)\n    return dt_list_sort[0] + avg_timedelta", "code_tokens": "def mean_date ( dt_list ) : dt_list_sort = sorted ( dt_list ) dt_list_sort_rel = [ dt - dt_list_sort [ 0 ] for dt in dt_list_sort ] avg_timedelta = sum ( dt_list_sort_rel , timedelta ( ) ) / len ( dt_list_sort_rel ) return dt_list_sort [ 0 ] + avg_timedelta", "docstring_tokens": "Calcuate mean datetime from datetime list", "label": 0}, {"idx": "cosqa-train-628", "doc": "python how to make a function return a tuple", "code": "def _ensure_element(tup, elem):\n    \"\"\"\n    Create a tuple containing all elements of tup, plus elem.\n\n    Returns the new tuple and the index of elem in the new tuple.\n    \"\"\"\n    try:\n        return tup, tup.index(elem)\n    except ValueError:\n        return tuple(chain(tup, (elem,))), len(tup)", "code_tokens": "def _ensure_element ( tup , elem ) : try : return tup , tup . index ( elem ) except ValueError : return tuple ( chain ( tup , ( elem , ) ) ) , len ( tup )", "docstring_tokens": "Create a tuple containing all elements of tup plus elem .", "label": 0}, {"idx": "cosqa-train-629", "doc": "get bit depth of audio python", "code": "def bitdepth(self):\n        \"\"\"The number of bits per sample in the audio encoding (an int).\n        Only available for certain file formats (zero where\n        unavailable).\n        \"\"\"\n        if hasattr(self.mgfile.info, 'bits_per_sample'):\n            return self.mgfile.info.bits_per_sample\n        return 0", "code_tokens": "def bitdepth ( self ) : if hasattr ( self . mgfile . info , 'bits_per_sample' ) : return self . mgfile . info . bits_per_sample return 0", "docstring_tokens": "The number of bits per sample in the audio encoding ( an int ) . Only available for certain file formats ( zero where unavailable ) .", "label": 0}, {"idx": "cosqa-train-630", "doc": "python how to make an enum", "code": "def to_python(self, value):\n        \"\"\"\n        Convert a string from a form into an Enum value.\n        \"\"\"\n        if value is None:\n            return value\n        if isinstance(value, self.enum):\n            return value\n        return self.enum[value]", "code_tokens": "def to_python ( self , value ) : if value is None : return value if isinstance ( value , self . enum ) : return value return self . enum [ value ]", "docstring_tokens": "Convert a string from a form into an Enum value .", "label": 0}, {"idx": "cosqa-train-631", "doc": "get column names in a data frame python", "code": "def get_obj_cols(df):\n    \"\"\"\n    Returns names of 'object' columns in the DataFrame.\n    \"\"\"\n    obj_cols = []\n    for idx, dt in enumerate(df.dtypes):\n        if dt == 'object' or is_category(dt):\n            obj_cols.append(df.columns.values[idx])\n\n    return obj_cols", "code_tokens": "def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols", "docstring_tokens": "Returns names of object columns in the DataFrame .", "label": 0}, {"idx": "cosqa-train-632", "doc": "python how to make an iterable variable", "code": "def force_iterable(f):\n    \"\"\"Will make any functions return an iterable objects by wrapping its result in a list.\"\"\"\n    def wrapper(*args, **kwargs):\n        r = f(*args, **kwargs)\n        if hasattr(r, '__iter__'):\n            return r\n        else:\n            return [r]\n    return wrapper", "code_tokens": "def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper", "docstring_tokens": "Will make any functions return an iterable objects by wrapping its result in a list .", "label": 1}, {"idx": "cosqa-train-633", "doc": "get date from string in python", "code": "def _read_date_from_string(str1):\n    \"\"\"\n    Reads the date from a string in the format YYYY/MM/DD and returns\n    :class: datetime.date\n    \"\"\"\n    full_date = [int(x) for x in str1.split('/')]\n    return datetime.date(full_date[0], full_date[1], full_date[2])", "code_tokens": "def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )", "docstring_tokens": "Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date", "label": 0}, {"idx": "cosqa-train-634", "doc": "python how to merge cells", "code": "def wr_row_mergeall(self, worksheet, txtstr, fmt, row_idx):\n        \"\"\"Merge all columns and place text string in widened cell.\"\"\"\n        hdridxval = len(self.hdrs) - 1\n        worksheet.merge_range(row_idx, 0, row_idx, hdridxval, txtstr, fmt)\n        return row_idx + 1", "code_tokens": "def wr_row_mergeall ( self , worksheet , txtstr , fmt , row_idx ) : hdridxval = len ( self . hdrs ) - 1 worksheet . merge_range ( row_idx , 0 , row_idx , hdridxval , txtstr , fmt ) return row_idx + 1", "docstring_tokens": "Merge all columns and place text string in widened cell .", "label": 0}, {"idx": "cosqa-train-635", "doc": "get days in between two dates in python", "code": "def dates_in_range(start_date, end_date):\n    \"\"\"Returns all dates between two dates.\n\n    Inclusive of the start date but not the end date.\n\n    Args:\n        start_date (datetime.date)\n        end_date (datetime.date)\n\n    Returns:\n        (list) of datetime.date objects\n    \"\"\"\n    return [\n        start_date + timedelta(n)\n        for n in range(int((end_date - start_date).days))\n    ]", "code_tokens": "def dates_in_range ( start_date , end_date ) : return [ start_date + timedelta ( n ) for n in range ( int ( ( end_date - start_date ) . days ) ) ]", "docstring_tokens": "Returns all dates between two dates .", "label": 0}, {"idx": "cosqa-train-636", "doc": "python how to move to next command in for loop", "code": "def do_next(self, args):\n        \"\"\"Step over the next statement\n        \"\"\"\n        self._do_print_from_last_cmd = True\n        self._interp.step_over()\n        return True", "code_tokens": "def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "docstring_tokens": "Step over the next statement", "label": 1}, {"idx": "cosqa-train-637", "doc": "get distinct items in list python", "code": "def unique(input_list):\n    \"\"\"\n    Return a list of unique items (similar to set functionality).\n\n    Parameters\n    ----------\n    input_list : list\n        A list containg some items that can occur more than once.\n\n    Returns\n    -------\n    list\n        A list with only unique occurances of an item.\n\n    \"\"\"\n    output = []\n    for item in input_list:\n        if item not in output:\n            output.append(item)\n    return output", "code_tokens": "def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output", "docstring_tokens": "Return a list of unique items ( similar to set functionality ) .", "label": 1}, {"idx": "cosqa-train-638", "doc": "python how to order a date list", "code": "def sort_fn_list(fn_list):\n    \"\"\"Sort input filename list by datetime\n    \"\"\"\n    dt_list = get_dt_list(fn_list)\n    fn_list_sort = [fn for (dt,fn) in sorted(zip(dt_list,fn_list))]\n    return fn_list_sort", "code_tokens": "def sort_fn_list ( fn_list ) : dt_list = get_dt_list ( fn_list ) fn_list_sort = [ fn for ( dt , fn ) in sorted ( zip ( dt_list , fn_list ) ) ] return fn_list_sort", "docstring_tokens": "Sort input filename list by datetime", "label": 0}, {"idx": "cosqa-train-639", "doc": "get distinct values from a column in python", "code": "def fast_distinct(self):\n        \"\"\"\n        Because standard distinct used on the all fields are very slow and works only with PostgreSQL database\n        this method provides alternative to the standard distinct method.\n        :return: qs with unique objects\n        \"\"\"\n        return self.model.objects.filter(pk__in=self.values_list('pk', flat=True))", "code_tokens": "def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )", "docstring_tokens": "Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects", "label": 0}, {"idx": "cosqa-train-640", "doc": "python how to pass reference to method", "code": "def Proxy(f):\n  \"\"\"A helper to create a proxy method in a class.\"\"\"\n\n  def Wrapped(self, *args):\n    return getattr(self, f)(*args)\n\n  return Wrapped", "code_tokens": "def Proxy ( f ) : def Wrapped ( self , * args ) : return getattr ( self , f ) ( * args ) return Wrapped", "docstring_tokens": "A helper to create a proxy method in a class .", "label": 0}, {"idx": "cosqa-train-641", "doc": "get elevation from lat long python", "code": "def metres2latlon(mx, my, origin_shift= 2 * pi * 6378137 / 2.0):\n    \"\"\"Converts XY point from Spherical Mercator EPSG:900913 to lat/lon in\n    WGS84 Datum\"\"\"\n    lon = (mx / origin_shift) * 180.0\n    lat = (my / origin_shift) * 180.0\n\n    lat = 180 / pi * (2 * atan( exp( lat * pi / 180.0)) - pi / 2.0)\n    return lat, lon", "code_tokens": "def metres2latlon ( mx , my , origin_shift = 2 * pi * 6378137 / 2.0 ) : lon = ( mx / origin_shift ) * 180.0 lat = ( my / origin_shift ) * 180.0 lat = 180 / pi * ( 2 * atan ( exp ( lat * pi / 180.0 ) ) - pi / 2.0 ) return lat , lon", "docstring_tokens": "Converts XY point from Spherical Mercator EPSG : 900913 to lat / lon in WGS84 Datum", "label": 0}, {"idx": "cosqa-train-642", "doc": "python how to read content of bufferedreader", "code": "def next (self):    # File-like object.\n\n        \"\"\"This is to support iterators over a file-like object.\n        \"\"\"\n\n        result = self.readline()\n        if result == self._empty_buffer:\n            raise StopIteration\n        return result", "code_tokens": "def next ( self ) : # File-like object. result = self . readline ( ) if result == self . _empty_buffer : raise StopIteration return result", "docstring_tokens": "This is to support iterators over a file - like object .", "label": 0}, {"idx": "cosqa-train-643", "doc": "python how to remove elements from an iterated list", "code": "def unique(seq):\n    \"\"\"Return the unique elements of a collection even if those elements are\n       unhashable and unsortable, like dicts and sets\"\"\"\n    cleaned = []\n    for each in seq:\n        if each not in cleaned:\n            cleaned.append(each)\n    return cleaned", "code_tokens": "def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned", "docstring_tokens": "Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets", "label": 1}, {"idx": "cosqa-train-644", "doc": "get file md5 python", "code": "def get_md5_for_file(file):\n    \"\"\"Get the md5 hash for a file.\n\n    :param file: the file to get the md5 hash for\n    \"\"\"\n    md5 = hashlib.md5()\n\n    while True:\n        data = file.read(md5.block_size)\n\n        if not data:\n            break\n\n        md5.update(data)\n\n    return md5.hexdigest()", "code_tokens": "def get_md5_for_file ( file ) : md5 = hashlib . md5 ( ) while True : data = file . read ( md5 . block_size ) if not data : break md5 . update ( data ) return md5 . hexdigest ( )", "docstring_tokens": "Get the md5 hash for a file .", "label": 0}, {"idx": "cosqa-train-645", "doc": "python how to remove spaces and add hashtag", "code": "def _add_hash(source):\n    \"\"\"Add a leading hash '#' at the beginning of every line in the source.\"\"\"\n    source = '\\n'.join('# ' + line.rstrip()\n                       for line in source.splitlines())\n    return source", "code_tokens": "def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "docstring_tokens": "Add a leading hash # at the beginning of every line in the source .", "label": 1}, {"idx": "cosqa-train-646", "doc": "get greatest index from bag of words python", "code": "def _rank(self, ranking, n):\n    \"\"\" return the first n sentences with highest ranking \"\"\"\n    return nlargest(n, ranking, key=ranking.get)", "code_tokens": "def _rank ( self , ranking , n ) : return nlargest ( n , ranking , key = ranking . get )", "docstring_tokens": "return the first n sentences with highest ranking", "label": 0}, {"idx": "cosqa-train-647", "doc": "python how to reset index and drop old index", "code": "def drop_indexes(self):\n        \"\"\"Delete all indexes for the database\"\"\"\n        LOG.warning(\"Dropping all indexe\")\n        for collection_name in INDEXES:\n            LOG.warning(\"Dropping all indexes for collection name %s\", collection_name)\n            self.db[collection_name].drop_indexes()", "code_tokens": "def drop_indexes ( self ) : LOG . warning ( \"Dropping all indexe\" ) for collection_name in INDEXES : LOG . warning ( \"Dropping all indexes for collection name %s\" , collection_name ) self . db [ collection_name ] . drop_indexes ( )", "docstring_tokens": "Delete all indexes for the database", "label": 0}, {"idx": "cosqa-train-648", "doc": "get last line of file python without reading it", "code": "def last(self):\n        \"\"\"Get the last object in file.\"\"\"\n        # End of file\n        self.__file.seek(0, 2)\n\n        # Get the last struct\n        data = self.get(self.length - 1)\n\n        return data", "code_tokens": "def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data", "docstring_tokens": "Get the last object in file .", "label": 0}, {"idx": "cosqa-train-649", "doc": "python how to run doctest in cmd", "code": "def debug_src(src, pm=False, globs=None):\n    \"\"\"Debug a single doctest docstring, in argument `src`'\"\"\"\n    testsrc = script_from_examples(src)\n    debug_script(testsrc, pm, globs)", "code_tokens": "def debug_src ( src , pm = False , globs = None ) : testsrc = script_from_examples ( src ) debug_script ( testsrc , pm , globs )", "docstring_tokens": "Debug a single doctest docstring in argument src", "label": 0}, {"idx": "cosqa-train-650", "doc": "get last list element pythong", "code": "def get_last_row(dbconn, tablename, n=1, uuid=None):\n    \"\"\"\n    Returns the last `n` rows in the table\n    \"\"\"\n    return fetch(dbconn, tablename, n, uuid, end=True)", "code_tokens": "def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )", "docstring_tokens": "Returns the last n rows in the table", "label": 0}, {"idx": "cosqa-train-651", "doc": "python how to save object to pickle", "code": "def save(self, fname: str):\n        \"\"\"\n        Saves this training state to fname.\n        \"\"\"\n        with open(fname, \"wb\") as fp:\n            pickle.dump(self, fp)", "code_tokens": "def save ( self , fname : str ) : with open ( fname , \"wb\" ) as fp : pickle . dump ( self , fp )", "docstring_tokens": "Saves this training state to fname .", "label": 0}, {"idx": "cosqa-train-652", "doc": "get length text python", "code": "def display_len(text):\n    \"\"\"\n    Get the display length of a string. This can differ from the character\n    length if the string contains wide characters.\n    \"\"\"\n    text = unicodedata.normalize('NFD', text)\n    return sum(char_width(char) for char in text)", "code_tokens": "def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )", "docstring_tokens": "Get the display length of a string . This can differ from the character length if the string contains wide characters .", "label": 0}, {"idx": "cosqa-train-653", "doc": "python how to say if not string", "code": "def isString(s):\n    \"\"\"Convenience method that works with all 2.x versions of Python\n    to determine whether or not something is stringlike.\"\"\"\n    try:\n        return isinstance(s, unicode) or isinstance(s, basestring)\n    except NameError:\n        return isinstance(s, str)", "code_tokens": "def isString ( s ) : try : return isinstance ( s , unicode ) or isinstance ( s , basestring ) except NameError : return isinstance ( s , str )", "docstring_tokens": "Convenience method that works with all 2 . x versions of Python to determine whether or not something is stringlike .", "label": 0}, {"idx": "cosqa-train-654", "doc": "get local path in python2", "code": "def rel_path(filename):\n    \"\"\"\n    Function that gets relative path to the filename\n    \"\"\"\n    return os.path.join(os.getcwd(), os.path.dirname(__file__), filename)", "code_tokens": "def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )", "docstring_tokens": "Function that gets relative path to the filename", "label": 0}, {"idx": "cosqa-train-655", "doc": "python how to see local variables in spyder", "code": "def test():        \n    \"\"\"Local test.\"\"\"\n    from spyder.utils.qthelpers import qapplication\n    app = qapplication()\n    dlg = ProjectDialog(None)\n    dlg.show()\n    sys.exit(app.exec_())", "code_tokens": "def test ( ) : from spyder . utils . qthelpers import qapplication app = qapplication ( ) dlg = ProjectDialog ( None ) dlg . show ( ) sys . exit ( app . exec_ ( ) )", "docstring_tokens": "Local test .", "label": 0}, {"idx": "cosqa-train-656", "doc": "get method name python", "code": "def get_method_name(method):\n    \"\"\"\n    Returns given method name.\n\n    :param method: Method to retrieve the name.\n    :type method: object\n    :return: Method name.\n    :rtype: unicode\n    \"\"\"\n\n    name = get_object_name(method)\n    if name.startswith(\"__\") and not name.endswith(\"__\"):\n        name = \"_{0}{1}\".format(get_object_name(method.im_class), name)\n    return name", "code_tokens": "def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( \"__\" ) and not name . endswith ( \"__\" ) : name = \"_{0}{1}\" . format ( get_object_name ( method . im_class ) , name ) return name", "docstring_tokens": "Returns given method name .", "label": 0}, {"idx": "cosqa-train-657", "doc": "python how to set numpy random seed", "code": "def const_rand(size, seed=23980):\n    \"\"\" Generate a random array with a fixed seed.\n    \"\"\"\n    old_seed = np.random.seed()\n    np.random.seed(seed)\n    out = np.random.rand(size)\n    np.random.seed(old_seed)\n    return out", "code_tokens": "def const_rand ( size , seed = 23980 ) : old_seed = np . random . seed ( ) np . random . seed ( seed ) out = np . random . rand ( size ) np . random . seed ( old_seed ) return out", "docstring_tokens": "Generate a random array with a fixed seed .", "label": 0}, {"idx": "cosqa-train-658", "doc": "get methods from python suds", "code": "def get_action_methods(self):\n        \"\"\"\n        return a list of methods on this class for executing actions.\n        methods are return as a list of (name, func) tuples\n        \"\"\"\n        return [(name, getattr(self, name))\n                for name, _ in Action.get_command_types()]", "code_tokens": "def get_action_methods ( self ) : return [ ( name , getattr ( self , name ) ) for name , _ in Action . get_command_types ( ) ]", "docstring_tokens": "return a list of methods on this class for executing actions . methods are return as a list of ( name func ) tuples", "label": 0}, {"idx": "cosqa-train-659", "doc": "python how to start a thread in bottle", "code": "def start():\n    \"\"\"Starts the web server.\"\"\"\n    global app\n    bottle.run(app, host=conf.WebHost, port=conf.WebPort,\n               debug=conf.WebAutoReload, reloader=conf.WebAutoReload,\n               quiet=conf.WebQuiet)", "code_tokens": "def start ( ) : global app bottle . run ( app , host = conf . WebHost , port = conf . WebPort , debug = conf . WebAutoReload , reloader = conf . WebAutoReload , quiet = conf . WebQuiet )", "docstring_tokens": "Starts the web server .", "label": 1}, {"idx": "cosqa-train-660", "doc": "get network details from device logs appium python", "code": "async def sysinfo(dev: Device):\n    \"\"\"Print out system information (version, MAC addrs).\"\"\"\n    click.echo(await dev.get_system_info())\n    click.echo(await dev.get_interface_information())", "code_tokens": "async def sysinfo ( dev : Device ) : click . echo ( await dev . get_system_info ( ) ) click . echo ( await dev . get_interface_information ( ) )", "docstring_tokens": "Print out system information ( version MAC addrs ) .", "label": 1}, {"idx": "cosqa-train-661", "doc": "python how to use a string to access list index", "code": "def get_list_index(lst, index_or_name):\n    \"\"\"\n    Return the index of an element in the list.\n\n    Args:\n        lst (list): The list.\n        index_or_name (int or str): The value of the reference element, or directly its numeric index.\n\n    Returns:\n        (int) The index of the element in the list.\n    \"\"\"\n    if isinstance(index_or_name, six.integer_types):\n        return index_or_name\n\n    return lst.index(index_or_name)", "code_tokens": "def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )", "docstring_tokens": "Return the index of an element in the list .", "label": 1}, {"idx": "cosqa-train-662", "doc": "get number of rows in data frame in python", "code": "def count_(self):\n        \"\"\"\n        Returns the number of rows of the main dataframe\n        \"\"\"\n        try:\n            num = len(self.df.index)\n        except Exception as e:\n            self.err(e, \"Can not count data\")\n            return\n        return num", "code_tokens": "def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , \"Can not count data\" ) return return num", "docstring_tokens": "Returns the number of rows of the main dataframe", "label": 0}, {"idx": "cosqa-train-663", "doc": "python how to write async api", "code": "def post_object_async(self, path, **kwds):\n    \"\"\"POST to an object.\"\"\"\n    return self.do_request_async(self.api_url + path, 'POST', **kwds)", "code_tokens": "def post_object_async ( self , path , * * kwds ) : return self . do_request_async ( self . api_url + path , 'POST' , * * kwds )", "docstring_tokens": "POST to an object .", "label": 0}, {"idx": "cosqa-train-664", "doc": "get only first occurance of a value based on the condition using python", "code": "def findfirst(f, coll):\n    \"\"\"Return first occurrence matching f, otherwise None\"\"\"\n    result = list(dropwhile(f, coll))\n    return result[0] if result else None", "code_tokens": "def findfirst ( f , coll ) : result = list ( dropwhile ( f , coll ) ) return result [ 0 ] if result else None", "docstring_tokens": "Return first occurrence matching f otherwise None", "label": 0}, {"idx": "cosqa-train-665", "doc": "python http server in the background", "code": "def start(self):\n        \"\"\"Create a background thread for httpd and serve 'forever'\"\"\"\n        self._process = threading.Thread(target=self._background_runner)\n        self._process.start()", "code_tokens": "def start ( self ) : self . _process = threading . Thread ( target = self . _background_runner ) self . _process . start ( )", "docstring_tokens": "Create a background thread for httpd and serve forever", "label": 0}, {"idx": "cosqa-train-666", "doc": "get only letters from string python", "code": "def return_letters_from_string(text):\n    \"\"\"Get letters from string only.\"\"\"\n    out = \"\"\n    for letter in text:\n        if letter.isalpha():\n            out += letter\n    return out", "code_tokens": "def return_letters_from_string ( text ) : out = \"\" for letter in text : if letter . isalpha ( ) : out += letter return out", "docstring_tokens": "Get letters from string only .", "label": 1}, {"idx": "cosqa-train-667", "doc": "python httpd run server for an amount of time", "code": "def start(self):\n        \"\"\"Create a background thread for httpd and serve 'forever'\"\"\"\n        self._process = threading.Thread(target=self._background_runner)\n        self._process.start()", "code_tokens": "def start ( self ) : self . _process = threading . Thread ( target = self . _background_runner ) self . _process . start ( )", "docstring_tokens": "Create a background thread for httpd and serve forever", "label": 0}, {"idx": "cosqa-train-668", "doc": "get query string from request python", "code": "def parse_querystring(self, req, name, field):\n        \"\"\"Pull a querystring value from the request.\"\"\"\n        return core.get_value(req.args, name, field)", "code_tokens": "def parse_querystring ( self , req , name , field ) : return core . get_value ( req . args , name , field )", "docstring_tokens": "Pull a querystring value from the request .", "label": 0}, {"idx": "cosqa-train-669", "doc": "python httpserver both non ssl and ssl", "code": "def inject_into_urllib3():\n    \"\"\"\n    Monkey-patch urllib3 with SecureTransport-backed SSL-support.\n    \"\"\"\n    util.ssl_.SSLContext = SecureTransportContext\n    util.HAS_SNI = HAS_SNI\n    util.ssl_.HAS_SNI = HAS_SNI\n    util.IS_SECURETRANSPORT = True\n    util.ssl_.IS_SECURETRANSPORT = True", "code_tokens": "def inject_into_urllib3 ( ) : util . ssl_ . SSLContext = SecureTransportContext util . HAS_SNI = HAS_SNI util . ssl_ . HAS_SNI = HAS_SNI util . IS_SECURETRANSPORT = True util . ssl_ . IS_SECURETRANSPORT = True", "docstring_tokens": "Monkey - patch urllib3 with SecureTransport - backed SSL - support .", "label": 0}, {"idx": "cosqa-train-670", "doc": "get rid of spaces in str python", "code": "def strip_spaces(x):\n    \"\"\"\n    Strips spaces\n    :param x:\n    :return:\n    \"\"\"\n    x = x.replace(b' ', b'')\n    x = x.replace(b'\\t', b'')\n    return x", "code_tokens": "def strip_spaces ( x ) : x = x . replace ( b' ' , b'' ) x = x . replace ( b'\\t' , b'' ) return x", "docstring_tokens": "Strips spaces : param x : : return :", "label": 1}, {"idx": "cosqa-train-671", "doc": "python human readable timedelta", "code": "def fmt_duration(secs):\n    \"\"\"Format a duration in seconds.\"\"\"\n    return ' '.join(fmt.human_duration(secs, 0, precision=2, short=True).strip().split())", "code_tokens": "def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )", "docstring_tokens": "Format a duration in seconds .", "label": 0}, {"idx": "cosqa-train-672", "doc": "get sort index python numpy", "code": "def argsort_indices(a, axis=-1):\n    \"\"\"Like argsort, but returns an index suitable for sorting the\n    the original array even if that array is multidimensional\n    \"\"\"\n    a = np.asarray(a)\n    ind = list(np.ix_(*[np.arange(d) for d in a.shape]))\n    ind[axis] = a.argsort(axis)\n    return tuple(ind)", "code_tokens": "def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )", "docstring_tokens": "Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional", "label": 1}, {"idx": "cosqa-train-673", "doc": "python if a function default return is", "code": "def file_or_default(path, default, function = None):\n    \"\"\" Return a default value if a file does not exist \"\"\"\n    try:\n        result = file_get_contents(path)\n        if function != None: return function(result)\n        return result\n    except IOError as e:\n        if e.errno == errno.ENOENT: return default\n        raise", "code_tokens": "def file_or_default ( path , default , function = None ) : try : result = file_get_contents ( path ) if function != None : return function ( result ) return result except IOError as e : if e . errno == errno . ENOENT : return default raise", "docstring_tokens": "Return a default value if a file does not exist", "label": 0}, {"idx": "cosqa-train-674", "doc": "get start and end date of quarter in python", "code": "def this_quarter():\n        \"\"\" Return start and end date of this quarter. \"\"\"\n        since = TODAY + delta(day=1)\n        while since.month % 3 != 0:\n            since -= delta(months=1)\n        until = since + delta(months=3)\n        return Date(since), Date(until)", "code_tokens": "def this_quarter ( ) : since = TODAY + delta ( day = 1 ) while since . month % 3 != 0 : since -= delta ( months = 1 ) until = since + delta ( months = 3 ) return Date ( since ) , Date ( until )", "docstring_tokens": "Return start and end date of this quarter .", "label": 0}, {"idx": "cosqa-train-675", "doc": "python if bool assume true", "code": "def strToBool(val):\n    \"\"\"\n    Helper function to turn a string representation of \"true\" into\n    boolean True.\n    \"\"\"\n    if isinstance(val, str):\n        val = val.lower()\n\n    return val in ['true', 'on', 'yes', True]", "code_tokens": "def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]", "docstring_tokens": "Helper function to turn a string representation of true into boolean True .", "label": 0}, {"idx": "cosqa-train-676", "doc": "get start day for a month python", "code": "def get_month_start(day=None):\n    \"\"\"Returns the first day of the given month.\"\"\"\n    day = add_timezone(day or datetime.date.today())\n    return day.replace(day=1)", "code_tokens": "def get_month_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( day = 1 )", "docstring_tokens": "Returns the first day of the given month .", "label": 0}, {"idx": "cosqa-train-677", "doc": "python if empty value in list", "code": "def clear_list_value(self, value):\n        \"\"\"\n        Clean the argument value to eliminate None or Falsy values if needed.\n        \"\"\"\n        # Don't go any further: this value is empty.\n        if not value:\n            return self.empty_value\n        # Clean empty items if wanted\n        if self.clean_empty:\n            value = [v for v in value if v]\n        return value or self.empty_value", "code_tokens": "def clear_list_value ( self , value ) : # Don't go any further: this value is empty. if not value : return self . empty_value # Clean empty items if wanted if self . clean_empty : value = [ v for v in value if v ] return value or self . empty_value", "docstring_tokens": "Clean the argument value to eliminate None or Falsy values if needed .", "label": 0}, {"idx": "cosqa-train-678", "doc": "get stdout from python call", "code": "def call_out(command):\n  \"\"\"\n  Run the given command (with shell=False) and return a tuple of\n  (int returncode, str output). Strip the output of enclosing whitespace.\n  \"\"\"\n  # start external command process\n  p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n  # get outputs\n  out, _ = p.communicate()\n\n  return p.returncode, out.strip()", "code_tokens": "def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "docstring_tokens": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace .", "label": 0}, {"idx": "cosqa-train-679", "doc": "python if field is empty", "code": "def run(self, value):\n        \"\"\" Determines if value value is empty.\n        Keyword arguments:\n        value str -- the value of the associated field to compare\n        \"\"\"\n        if self.pass_ and not value.strip():\n            return True\n\n        if not value:\n            return False\n        return True", "code_tokens": "def run ( self , value ) : if self . pass_ and not value . strip ( ) : return True if not value : return False return True", "docstring_tokens": "Determines if value value is empty . Keyword arguments : value str -- the value of the associated field to compare", "label": 0}, {"idx": "cosqa-train-680", "doc": "get string width with font python", "code": "def _string_width(self, s):\n        \"\"\"Get width of a string in the current font\"\"\"\n        s = str(s)\n        w = 0\n        for i in s:\n            w += self.character_widths[i]\n        return w * self.font_size / 1000.0", "code_tokens": "def _string_width ( self , s ) : s = str ( s ) w = 0 for i in s : w += self . character_widths [ i ] return w * self . font_size / 1000.0", "docstring_tokens": "Get width of a string in the current font", "label": 0}, {"idx": "cosqa-train-681", "doc": "python if object is a string do something", "code": "def isString(s):\n    \"\"\"Convenience method that works with all 2.x versions of Python\n    to determine whether or not something is stringlike.\"\"\"\n    try:\n        return isinstance(s, unicode) or isinstance(s, basestring)\n    except NameError:\n        return isinstance(s, str)", "code_tokens": "def isString ( s ) : try : return isinstance ( s , unicode ) or isinstance ( s , basestring ) except NameError : return isinstance ( s , str )", "docstring_tokens": "Convenience method that works with all 2 . x versions of Python to determine whether or not something is stringlike .", "label": 0}, {"idx": "cosqa-train-682", "doc": "get te left most value of a column in python", "code": "def find_le(a, x):\n    \"\"\"Find rightmost value less than or equal to x.\"\"\"\n    i = bs.bisect_right(a, x)\n    if i: return i - 1\n    raise ValueError", "code_tokens": "def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError", "docstring_tokens": "Find rightmost value less than or equal to x .", "label": 1}, {"idx": "cosqa-train-683", "doc": "python image crop box", "code": "def crop_box(im, box=False, **kwargs):\n    \"\"\"Uses box coordinates to crop an image without resizing it first.\"\"\"\n    if box:\n        im = im.crop(box)\n    return im", "code_tokens": "def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im", "docstring_tokens": "Uses box coordinates to crop an image without resizing it first .", "label": 0}, {"idx": "cosqa-train-684", "doc": "get the data type in python code", "code": "def datatype(dbtype, description, cursor):\n    \"\"\"Google AppEngine Helper to convert a data type into a string.\"\"\"\n    dt = cursor.db.introspection.get_field_type(dbtype, description)\n    if type(dt) is tuple:\n        return dt[0]\n    else:\n        return dt", "code_tokens": "def datatype ( dbtype , description , cursor ) : dt = cursor . db . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt", "docstring_tokens": "Google AppEngine Helper to convert a data type into a string .", "label": 1}, {"idx": "cosqa-train-685", "doc": "python image normalize to 0 255", "code": "def normalize(im, invert=False, scale=None, dtype=np.float64):\n    \"\"\"\n    Normalize a field to a (min, max) exposure range, default is (0, 255).\n    (min, max) exposure values. Invert the image if requested.\n    \"\"\"\n    if dtype not in {np.float16, np.float32, np.float64}:\n        raise ValueError('dtype must be numpy.float16, float32, or float64.')\n    out = im.astype('float').copy()\n\n    scale = scale or (0.0, 255.0)\n    l, u = (float(i) for i in scale)\n    out = (out - l) / (u - l)\n    if invert:\n        out = -out + (out.max() + out.min())\n    return out.astype(dtype)", "code_tokens": "def normalize ( im , invert = False , scale = None , dtype = np . float64 ) : if dtype not in { np . float16 , np . float32 , np . float64 } : raise ValueError ( 'dtype must be numpy.float16, float32, or float64.' ) out = im . astype ( 'float' ) . copy ( ) scale = scale or ( 0.0 , 255.0 ) l , u = ( float ( i ) for i in scale ) out = ( out - l ) / ( u - l ) if invert : out = - out + ( out . max ( ) + out . min ( ) ) return out . astype ( dtype )", "docstring_tokens": "Normalize a field to a ( min max ) exposure range default is ( 0 255 ) . ( min max ) exposure values . Invert the image if requested .", "label": 0}, {"idx": "cosqa-train-686", "doc": "get the index of the last item iterated in list python", "code": "def end_index(self):\n        \"\"\"Return the 1-based index of the last item on this page.\"\"\"\n        paginator = self.paginator\n        # Special case for the last page because there can be orphans.\n        if self.number == paginator.num_pages:\n            return paginator.count\n        return (self.number - 1) * paginator.per_page + paginator.first_page", "code_tokens": "def end_index ( self ) : paginator = self . paginator # Special case for the last page because there can be orphans. if self . number == paginator . num_pages : return paginator . count return ( self . number - 1 ) * paginator . per_page + paginator . first_page", "docstring_tokens": "Return the 1 - based index of the last item on this page .", "label": 0}, {"idx": "cosqa-train-687", "doc": "python image processing fft ifft", "code": "def filtered_image(self, im):\n        \"\"\"Returns a filtered image after applying the Fourier-space filters\"\"\"\n        q = np.fft.fftn(im)\n        for k,v in self.filters:\n            q[k] -= v\n        return np.real(np.fft.ifftn(q))", "code_tokens": "def filtered_image ( self , im ) : q = np . fft . fftn ( im ) for k , v in self . filters : q [ k ] -= v return np . real ( np . fft . ifftn ( q ) )", "docstring_tokens": "Returns a filtered image after applying the Fourier - space filters", "label": 0}, {"idx": "cosqa-train-688", "doc": "get the last column of a group by in python", "code": "def get_last_row(dbconn, tablename, n=1, uuid=None):\n    \"\"\"\n    Returns the last `n` rows in the table\n    \"\"\"\n    return fetch(dbconn, tablename, n, uuid, end=True)", "code_tokens": "def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )", "docstring_tokens": "Returns the last n rows in the table", "label": 0}, {"idx": "cosqa-train-689", "doc": "python image to buffer", "code": "def get_buffer(self, data_np, header, format, output=None):\n        \"\"\"Get image as a buffer in (format).\n        Format should be 'jpeg', 'png', etc.\n        \"\"\"\n        if not have_pil:\n            raise Exception(\"Install PIL to use this method\")\n        image = PILimage.fromarray(data_np)\n        buf = output\n        if buf is None:\n            buf = BytesIO()\n        image.save(buf, format)\n        return buf", "code_tokens": "def get_buffer ( self , data_np , header , format , output = None ) : if not have_pil : raise Exception ( \"Install PIL to use this method\" ) image = PILimage . fromarray ( data_np ) buf = output if buf is None : buf = BytesIO ( ) image . save ( buf , format ) return buf", "docstring_tokens": "Get image as a buffer in ( format ) . Format should be jpeg png etc .", "label": 1}, {"idx": "cosqa-train-690", "doc": "get unique set in list python", "code": "def delete_duplicates(seq):\n    \"\"\"\n    Remove duplicates from an iterable, preserving the order.\n\n    Args:\n        seq: Iterable of various type.\n\n    Returns:\n        list: List of unique objects.\n\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "Remove duplicates from an iterable preserving the order .", "label": 0}, {"idx": "cosqa-train-691", "doc": "python image to uint8", "code": "def uint32_to_uint8(cls, img):\n        \"\"\"\n        Cast uint32 RGB image to 4 uint8 channels.\n        \"\"\"\n        return np.flipud(img.view(dtype=np.uint8).reshape(img.shape + (4,)))", "code_tokens": "def uint32_to_uint8 ( cls , img ) : return np . flipud ( img . view ( dtype = np . uint8 ) . reshape ( img . shape + ( 4 , ) ) )", "docstring_tokens": "Cast uint32 RGB image to 4 uint8 channels .", "label": 0}, {"idx": "cosqa-train-692", "doc": "get user based on uid python", "code": "def get_user_by_id(self, id):\n        \"\"\"Retrieve a User object by ID.\"\"\"\n        return self.db_adapter.get_object(self.UserClass, id=id)", "code_tokens": "def get_user_by_id ( self , id ) : return self . db_adapter . get_object ( self . UserClass , id = id )", "docstring_tokens": "Retrieve a User object by ID .", "label": 0}, {"idx": "cosqa-train-693", "doc": "python impossible to call blocking function in the event loop callback", "code": "def asynchronous(function, event):\n    \"\"\"\n    Runs the function asynchronously taking care of exceptions.\n    \"\"\"\n    thread = Thread(target=synchronous, args=(function, event))\n    thread.daemon = True\n    thread.start()", "code_tokens": "def asynchronous ( function , event ) : thread = Thread ( target = synchronous , args = ( function , event ) ) thread . daemon = True thread . start ( )", "docstring_tokens": "Runs the function asynchronously taking care of exceptions .", "label": 0}, {"idx": "cosqa-train-694", "doc": "python increase the upper limit of gpu memory", "code": "def _EnforceProcessMemoryLimit(self, memory_limit):\n    \"\"\"Enforces a process memory limit.\n\n    Args:\n      memory_limit (int): maximum number of bytes the process is allowed\n          to allocate, where 0 represents no limit and None a default of\n          4 GiB.\n    \"\"\"\n    # Resource is not supported on Windows.\n    if resource:\n      if memory_limit is None:\n        memory_limit = 4 * 1024 * 1024 * 1024\n      elif memory_limit == 0:\n        memory_limit = resource.RLIM_INFINITY\n\n      resource.setrlimit(resource.RLIMIT_DATA, (memory_limit, memory_limit))", "code_tokens": "def _EnforceProcessMemoryLimit ( self , memory_limit ) : # Resource is not supported on Windows. if resource : if memory_limit is None : memory_limit = 4 * 1024 * 1024 * 1024 elif memory_limit == 0 : memory_limit = resource . RLIM_INFINITY resource . setrlimit ( resource . RLIMIT_DATA , ( memory_limit , memory_limit ) )", "docstring_tokens": "Enforces a process memory limit .", "label": 0}, {"idx": "cosqa-train-695", "doc": "get values of a domain in python", "code": "def check_many(self, domains):\n        \"\"\"\n        Check availability for a number of domains. Returns a dictionary\n        mapping the domain names to their statuses as a string\n        (\"active\"/\"free\").\n        \"\"\"\n        return dict((item.domain, item.status) for item in self.check_domain_request(domains))", "code_tokens": "def check_many ( self , domains ) : return dict ( ( item . domain , item . status ) for item in self . check_domain_request ( domains ) )", "docstring_tokens": "Check availability for a number of domains . Returns a dictionary mapping the domain names to their statuses as a string ( active / free ) .", "label": 0}, {"idx": "cosqa-train-696", "doc": "python indent all but first line", "code": "def end_block(self):\n        \"\"\"Ends an indentation block, leaving an empty line afterwards\"\"\"\n        self.current_indent -= 1\n\n        # If we did not add a new line automatically yet, now it's the time!\n        if not self.auto_added_line:\n            self.writeln()\n            self.auto_added_line = True", "code_tokens": "def end_block ( self ) : self . current_indent -= 1 # If we did not add a new line automatically yet, now it's the time! if not self . auto_added_line : self . writeln ( ) self . auto_added_line = True", "docstring_tokens": "Ends an indentation block leaving an empty line afterwards", "label": 0}, {"idx": "cosqa-train-697", "doc": "get weights from keras model python", "code": "def get_weights_from_kmodel(kmodel):\n        \"\"\"\n        Convert kmodel's weights to bigdl format.\n        We are supposing the order is the same as the execution order.\n        :param kmodel: keras model\n        :return: list of ndarray\n        \"\"\"\n        layers_with_weights = [layer for layer in kmodel.layers if layer.weights]\n        bweights = []\n        for klayer in layers_with_weights:\n            # bws would be [weights, bias] or [weights]\n            bws = WeightsConverter.get_bigdl_weights_from_klayer(klayer)\n            for w in bws:\n                bweights.append(w)\n        return bweights", "code_tokens": "def get_weights_from_kmodel ( kmodel ) : layers_with_weights = [ layer for layer in kmodel . layers if layer . weights ] bweights = [ ] for klayer in layers_with_weights : # bws would be [weights, bias] or [weights] bws = WeightsConverter . get_bigdl_weights_from_klayer ( klayer ) for w in bws : bweights . append ( w ) return bweights", "docstring_tokens": "Convert kmodel s weights to bigdl format . We are supposing the order is the same as the execution order . : param kmodel : keras model : return : list of ndarray", "label": 0}, {"idx": "cosqa-train-698", "doc": "python index of maximum value of an array", "code": "def MultiArgMax(x):\n  \"\"\"\n  Get tuple (actually a generator) of indices where the max value of\n  array x occurs. Requires that x have a max() method, as x.max()\n  (in the case of NumPy) is much faster than max(x).\n  For a simpler, faster argmax when there is only a single maximum entry,\n  or when knowing only the first index where the maximum occurs,\n  call argmax() on a NumPy array.\n\n  :param x: Any sequence that has a max() method.\n  :returns: Generator with the indices where the max value occurs.\n  \"\"\"\n  m = x.max()\n  return (i for i, v in enumerate(x) if v == m)", "code_tokens": "def MultiArgMax ( x ) : m = x . max ( ) return ( i for i , v in enumerate ( x ) if v == m )", "docstring_tokens": "Get tuple ( actually a generator ) of indices where the max value of array x occurs . Requires that x have a max () method as x . max () ( in the case of NumPy ) is much faster than max ( x ) . For a simpler faster argmax when there is only a single maximum entry or when knowing only the first index where the maximum occurs call argmax () on a NumPy array .", "label": 0}, {"idx": "cosqa-train-699", "doc": "get windows uuid with python", "code": "def get_nt_system_uid():\n    \"\"\"Get the MachineGuid from\n    HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Cryptography\\MachineGuid\n    \"\"\"\n    try:\n        import _winreg as winreg\n    except ImportError:\n        import winreg\n    lm = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n    try:\n        key = winreg.OpenKey(lm, r\"Software\\Microsoft\\Cryptography\")\n        try:\n            return winreg.QueryValueEx(key, \"MachineGuid\")[0]\n        finally:\n            key.Close()\n    finally:\n        lm.Close()", "code_tokens": "def get_nt_system_uid ( ) : try : import _winreg as winreg except ImportError : import winreg lm = winreg . ConnectRegistry ( None , winreg . HKEY_LOCAL_MACHINE ) try : key = winreg . OpenKey ( lm , r\"Software\\Microsoft\\Cryptography\" ) try : return winreg . QueryValueEx ( key , \"MachineGuid\" ) [ 0 ] finally : key . Close ( ) finally : lm . Close ( )", "docstring_tokens": "Get the MachineGuid from HKEY_LOCAL_MACHINE \\ Software \\ Microsoft \\ Cryptography \\ MachineGuid", "label": 0}, {"idx": "cosqa-train-700", "doc": "python init mixins different args", "code": "def __init__(self, find, subcon):\n        \"\"\"Initialize.\"\"\"\n        Subconstruct.__init__(self, subcon)\n        self.find = find", "code_tokens": "def __init__ ( self , find , subcon ) : Subconstruct . __init__ ( self , subcon ) self . find = find", "docstring_tokens": "Initialize .", "label": 0}, {"idx": "cosqa-train-701", "doc": "getattr return property object python", "code": "def value(self):\n        \"\"\"Value of property.\"\"\"\n        if self._prop.fget is None:\n            raise AttributeError('Unable to read attribute')\n        return self._prop.fget(self._obj)", "code_tokens": "def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )", "docstring_tokens": "Value of property .", "label": 1}, {"idx": "cosqa-train-702", "doc": "gettingvariables names inside a dataset in python", "code": "def find_coord_vars(ncds):\n    \"\"\"\n    Finds all coordinate variables in a dataset.\n\n    A variable with the same name as a dimension is called a coordinate variable.\n    \"\"\"\n    coord_vars = []\n\n    for d in ncds.dimensions:\n        if d in ncds.variables and ncds.variables[d].dimensions == (d,):\n            coord_vars.append(ncds.variables[d])\n\n    return coord_vars", "code_tokens": "def find_coord_vars ( ncds ) : coord_vars = [ ] for d in ncds . dimensions : if d in ncds . variables and ncds . variables [ d ] . dimensions == ( d , ) : coord_vars . append ( ncds . variables [ d ] ) return coord_vars", "docstring_tokens": "Finds all coordinate variables in a dataset .", "label": 0}, {"idx": "cosqa-train-703", "doc": "python inspect name of function", "code": "def get_func_posargs_name(f):\n    \"\"\"Returns the name of the function f's keyword argument parameter if it exists, otherwise None\"\"\"\n    sigparams = inspect.signature(f).parameters\n    for p in sigparams:\n        if sigparams[p].kind == inspect.Parameter.VAR_POSITIONAL:\n            return sigparams[p].name\n    return None", "code_tokens": "def get_func_posargs_name ( f ) : sigparams = inspect . signature ( f ) . parameters for p in sigparams : if sigparams [ p ] . kind == inspect . Parameter . VAR_POSITIONAL : return sigparams [ p ] . name return None", "docstring_tokens": "Returns the name of the function f s keyword argument parameter if it exists otherwise None", "label": 0}, {"idx": "cosqa-train-704", "doc": "git of python is not working", "code": "def check_git():\n    \"\"\"Check if git command is available.\"\"\"\n    try:\n        with open(os.devnull, \"wb\") as devnull:\n            subprocess.check_call([\"git\", \"--version\"], stdout=devnull, stderr=devnull)\n    except:\n        raise RuntimeError(\"Please make sure git is installed and on your path.\")", "code_tokens": "def check_git ( ) : try : with open ( os . devnull , \"wb\" ) as devnull : subprocess . check_call ( [ \"git\" , \"--version\" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( \"Please make sure git is installed and on your path.\" )", "docstring_tokens": "Check if git command is available .", "label": 0}, {"idx": "cosqa-train-705", "doc": "python instance into list", "code": "def as_list(self):\n        \"\"\"Return all child objects in nested lists of strings.\"\"\"\n        return [self.name, self.value, [x.as_list for x in self.children]]", "code_tokens": "def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]", "docstring_tokens": "Return all child objects in nested lists of strings .", "label": 1}, {"idx": "cosqa-train-706", "doc": "give a variable a random integer value in python", "code": "def positive_integer(anon, obj, field, val):\n    \"\"\"\n    Returns a random positive integer (for a Django PositiveIntegerField)\n    \"\"\"\n    return anon.faker.positive_integer(field=field)", "code_tokens": "def positive_integer ( anon , obj , field , val ) : return anon . faker . positive_integer ( field = field )", "docstring_tokens": "Returns a random positive integer ( for a Django PositiveIntegerField )", "label": 0}, {"idx": "cosqa-train-707", "doc": "python instance method decorate", "code": "def method(func):\n    \"\"\"Wrap a function as a method.\"\"\"\n    attr = abc.abstractmethod(func)\n    attr.__imethod__ = True\n    return attr", "code_tokens": "def method ( func ) : attr = abc . abstractmethod ( func ) attr . __imethod__ = True return attr", "docstring_tokens": "Wrap a function as a method .", "label": 0}, {"idx": "cosqa-train-708", "doc": "give index of specific line in python", "code": "def get_lines(handle, line):\n    \"\"\"\n    Get zero-indexed line from an open file-like.\n    \"\"\"\n    for i, l in enumerate(handle):\n        if i == line:\n            return l", "code_tokens": "def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l", "docstring_tokens": "Get zero - indexed line from an open file - like .", "label": 0}, {"idx": "cosqa-train-709", "doc": "python int and float coerce", "code": "def type_converter(text):\n    \"\"\" I convert strings into integers, floats, and strings! \"\"\"\n    if text.isdigit():\n        return int(text), int\n\n    try:\n        return float(text), float\n    except ValueError:\n        return text, STRING_TYPE", "code_tokens": "def type_converter ( text ) : if text . isdigit ( ) : return int ( text ) , int try : return float ( text ) , float except ValueError : return text , STRING_TYPE", "docstring_tokens": "I convert strings into integers floats and strings!", "label": 0}, {"idx": "cosqa-train-710", "doc": "giving python a directory path and create its path", "code": "def create_path(path):\n    \"\"\"Creates a absolute path in the file system.\n\n    :param path: The path to be created\n    \"\"\"\n    import os\n    if not os.path.exists(path):\n        os.makedirs(path)", "code_tokens": "def create_path ( path ) : import os if not os . path . exists ( path ) : os . makedirs ( path )", "docstring_tokens": "Creates a absolute path in the file system .", "label": 0}, {"idx": "cosqa-train-711", "doc": "python int value boolean true false", "code": "def is_int(value):\n    \"\"\"Return `True` if ``value`` is an integer.\"\"\"\n    if isinstance(value, bool):\n        return False\n    try:\n        int(value)\n        return True\n    except (ValueError, TypeError):\n        return False", "code_tokens": "def is_int ( value ) : if isinstance ( value , bool ) : return False try : int ( value ) return True except ( ValueError , TypeError ) : return False", "docstring_tokens": "Return True if value is an integer .", "label": 0}, {"idx": "cosqa-train-712", "doc": "hdf5 python h5py read data by", "code": "def h5ToDict(h5, readH5pyDataset=True):\n    \"\"\" Read a hdf5 file into a dictionary \"\"\"\n    h = h5py.File(h5, \"r\")\n    ret = unwrapArray(h, recursive=True, readH5pyDataset=readH5pyDataset)\n    if readH5pyDataset: h.close()\n    return ret", "code_tokens": "def h5ToDict ( h5 , readH5pyDataset = True ) : h = h5py . File ( h5 , \"r\" ) ret = unwrapArray ( h , recursive = True , readH5pyDataset = readH5pyDataset ) if readH5pyDataset : h . close ( ) return ret", "docstring_tokens": "Read a hdf5 file into a dictionary", "label": 0}, {"idx": "cosqa-train-713", "doc": "python int yyyymmdd to datetime", "code": "def int_to_date(date):\n    \"\"\"\n    Convert an int of form yyyymmdd to a python date object.\n    \"\"\"\n\n    year = date // 10**4\n    month = date % 10**4 // 10**2\n    day = date % 10**2\n\n    return datetime.date(year, month, day)", "code_tokens": "def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )", "docstring_tokens": "Convert an int of form yyyymmdd to a python date object .", "label": 0}, {"idx": "cosqa-train-714", "doc": "histogram probability density function python normed", "code": "def norm(x, mu, sigma=1.0):\n    \"\"\" Scipy norm function \"\"\"\n    return stats.norm(loc=mu, scale=sigma).pdf(x)", "code_tokens": "def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )", "docstring_tokens": "Scipy norm function", "label": 0}, {"idx": "cosqa-train-715", "doc": "python interactive behavior different", "code": "def isInteractive():\n    \"\"\"\n    A basic check of if the program is running in interactive mode\n    \"\"\"\n    if sys.stdout.isatty() and os.name != 'nt':\n        #Hopefully everything but ms supports '\\r'\n        try:\n            import threading\n        except ImportError:\n            return False\n        else:\n            return True\n    else:\n        return False", "code_tokens": "def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\\r' try : import threading except ImportError : return False else : return True else : return False", "docstring_tokens": "A basic check of if the program is running in interactive mode", "label": 0}, {"idx": "cosqa-train-716", "doc": "how add noise in python", "code": "def add_noise(Y, sigma):\n    \"\"\"Adds noise to Y\"\"\"\n    return Y + np.random.normal(0, sigma, Y.shape)", "code_tokens": "def add_noise ( Y , sigma ) : return Y + np . random . normal ( 0 , sigma , Y . shape )", "docstring_tokens": "Adds noise to Y", "label": 0}, {"idx": "cosqa-train-717", "doc": "python interpolate time data at specific datetimes", "code": "def spline_interpolate_by_datetime(datetime_axis, y_axis, datetime_new_axis):\n    \"\"\"A datetime-version that takes datetime object list as x_axis\n    \"\"\"\n    numeric_datetime_axis = [\n        totimestamp(a_datetime) for a_datetime in datetime_axis\n    ]\n\n    numeric_datetime_new_axis = [\n        totimestamp(a_datetime) for a_datetime in datetime_new_axis\n    ]\n\n    return spline_interpolate(\n        numeric_datetime_axis, y_axis, numeric_datetime_new_axis)", "code_tokens": "def spline_interpolate_by_datetime ( datetime_axis , y_axis , datetime_new_axis ) : numeric_datetime_axis = [ totimestamp ( a_datetime ) for a_datetime in datetime_axis ] numeric_datetime_new_axis = [ totimestamp ( a_datetime ) for a_datetime in datetime_new_axis ] return spline_interpolate ( numeric_datetime_axis , y_axis , numeric_datetime_new_axis )", "docstring_tokens": "A datetime - version that takes datetime object list as x_axis", "label": 0}, {"idx": "cosqa-train-718", "doc": "how can i access dataimages from a dataset in hdf5 file in python", "code": "def _load_data(filepath):\n  \"\"\"Loads the images and latent values into Numpy arrays.\"\"\"\n  with h5py.File(filepath, \"r\") as h5dataset:\n    image_array = np.array(h5dataset[\"images\"])\n    # The 'label' data set in the hdf5 file actually contains the float values\n    # and not the class labels.\n    values_array = np.array(h5dataset[\"labels\"])\n  return image_array, values_array", "code_tokens": "def _load_data ( filepath ) : with h5py . File ( filepath , \"r\" ) as h5dataset : image_array = np . array ( h5dataset [ \"images\" ] ) # The 'label' data set in the hdf5 file actually contains the float values # and not the class labels. values_array = np . array ( h5dataset [ \"labels\" ] ) return image_array , values_array", "docstring_tokens": "Loads the images and latent values into Numpy arrays .", "label": 1}, {"idx": "cosqa-train-719", "doc": "python inverse dictionary with key and value", "code": "def invertDictMapping(d):\n    \"\"\" Invert mapping of dictionary (i.e. map values to list of keys) \"\"\"\n    inv_map = {}\n    for k, v in d.items():\n        inv_map[v] = inv_map.get(v, [])\n        inv_map[v].append(k)\n    return inv_map", "code_tokens": "def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map", "docstring_tokens": "Invert mapping of dictionary ( i . e . map values to list of keys )", "label": 0}, {"idx": "cosqa-train-720", "doc": "how can i mke a list in python that is n long with equal icrements", "code": "def chunk_list(l, n):\n    \"\"\"Return `n` size lists from a given list `l`\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Return n size lists from a given list l", "label": 0}, {"idx": "cosqa-train-721", "doc": "python ipaddress how to test for errors", "code": "def is_valid_ip(ip_address):\n    \"\"\"\n    Check Validity of an IP address\n    \"\"\"\n    valid = True\n    try:\n        socket.inet_aton(ip_address.strip())\n    except:\n        valid = False\n    return valid", "code_tokens": "def is_valid_ip ( ip_address ) : valid = True try : socket . inet_aton ( ip_address . strip ( ) ) except : valid = False return valid", "docstring_tokens": "Check Validity of an IP address", "label": 0}, {"idx": "cosqa-train-722", "doc": "how can i sleep within a while loop but not slow it down python", "code": "def main(idle):\n    \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"\n    while True:\n\n        LOG.debug(\"Sleeping for {0} seconds.\".format(idle))\n        time.sleep(idle)", "code_tokens": "def main ( idle ) : while True : LOG . debug ( \"Sleeping for {0} seconds.\" . format ( idle ) ) time . sleep ( idle )", "docstring_tokens": "Any normal python logic which runs a loop . Can take arguments .", "label": 0}, {"idx": "cosqa-train-723", "doc": "python is empty set", "code": "def unique(_list):\n    \"\"\"\n    Makes the list have unique items only and maintains the order\n\n    list(set()) won't provide that\n\n    :type _list list\n    :rtype: list\n    \"\"\"\n    ret = []\n\n    for item in _list:\n        if item not in ret:\n            ret.append(item)\n\n    return ret", "code_tokens": "def unique ( _list ) : ret = [ ] for item in _list : if item not in ret : ret . append ( item ) return ret", "docstring_tokens": "Makes the list have unique items only and maintains the order", "label": 0}, {"idx": "cosqa-train-724", "doc": "how check unique values in python", "code": "def _init_unique_sets(self):\n        \"\"\"Initialise sets used for uniqueness checking.\"\"\"\n\n        ks = dict()\n        for t in self._unique_checks:\n            key = t[0]\n            ks[key] = set() # empty set\n        return ks", "code_tokens": "def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks", "docstring_tokens": "Initialise sets used for uniqueness checking .", "label": 0}, {"idx": "cosqa-train-725", "doc": "python is none nonetype", "code": "def is_a_sequence(var, allow_none=False):\n    \"\"\" Returns True if var is a list or a tuple (but not a string!)\n    \"\"\"\n    return isinstance(var, (list, tuple)) or (var is None and allow_none)", "code_tokens": "def is_a_sequence ( var , allow_none = False ) : return isinstance ( var , ( list , tuple ) ) or ( var is None and allow_none )", "docstring_tokens": "Returns True if var is a list or a tuple ( but not a string! )", "label": 0}, {"idx": "cosqa-train-726", "doc": "how do i check if a string is in a list in python", "code": "def isin(elems, line):\n    \"\"\"Check if an element from a list is in a string.\n\n    :type elems: list\n    :type line: str\n\n    \"\"\"\n    found = False\n    for e in elems:\n        if e in line.lower():\n            found = True\n            break\n    return found", "code_tokens": "def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found", "docstring_tokens": "Check if an element from a list is in a string .", "label": 1}, {"idx": "cosqa-train-727", "doc": "python is null boolean filter", "code": "def _notnull(expr):\n    \"\"\"\n    Return a sequence or scalar according to the input indicating if the values are not null.\n\n    :param expr: sequence or scalar\n    :return: sequence or scalar\n    \"\"\"\n\n    if isinstance(expr, SequenceExpr):\n        return NotNull(_input=expr, _data_type=types.boolean)\n    elif isinstance(expr, Scalar):\n        return NotNull(_input=expr, _value_type=types.boolean)", "code_tokens": "def _notnull ( expr ) : if isinstance ( expr , SequenceExpr ) : return NotNull ( _input = expr , _data_type = types . boolean ) elif isinstance ( expr , Scalar ) : return NotNull ( _input = expr , _value_type = types . boolean )", "docstring_tokens": "Return a sequence or scalar according to the input indicating if the values are not null .", "label": 0}, {"idx": "cosqa-train-728", "doc": "how do i create a dictionary in python", "code": "def conv_dict(self):\n        \"\"\"dictionary of conversion\"\"\"\n        return dict(integer=self.integer, real=self.real, no_type=self.no_type)", "code_tokens": "def conv_dict ( self ) : return dict ( integer = self . integer , real = self . real , no_type = self . no_type )", "docstring_tokens": "dictionary of conversion", "label": 0}, {"idx": "cosqa-train-729", "doc": "python is there a list of prime factors", "code": "def getPrimeFactors(n):\n    \"\"\"\n    Get all the prime factor of given integer\n    @param n integer\n    @return list [1, ..., n]\n    \"\"\"\n    lo = [1]\n    n2 = n // 2\n    k = 2\n    for k in range(2, n2 + 1):\n        if (n // k)*k == n:\n            lo.append(k)\n    return lo + [n, ]", "code_tokens": "def getPrimeFactors ( n ) : lo = [ 1 ] n2 = n // 2 k = 2 for k in range ( 2 , n2 + 1 ) : if ( n // k ) * k == n : lo . append ( k ) return lo + [ n , ]", "docstring_tokens": "Get all the prime factor of given integer", "label": 0}, {"idx": "cosqa-train-730", "doc": "how do i draw a horizontal line in python", "code": "def get_hline():\n    \"\"\" gets a horiztonal line \"\"\"\n    return Window(\n        width=LayoutDimension.exact(1),\n        height=LayoutDimension.exact(1),\n        content=FillControl('-', token=Token.Line))", "code_tokens": "def get_hline ( ) : return Window ( width = LayoutDimension . exact ( 1 ) , height = LayoutDimension . exact ( 1 ) , content = FillControl ( '-' , token = Token . Line ) )", "docstring_tokens": "gets a horiztonal line", "label": 0}, {"idx": "cosqa-train-731", "doc": "python is writeable directory test", "code": "def _writable_dir(path):\n    \"\"\"Whether `path` is a directory, to which the user has write access.\"\"\"\n    return os.path.isdir(path) and os.access(path, os.W_OK)", "code_tokens": "def _writable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . W_OK )", "docstring_tokens": "Whether path is a directory to which the user has write access .", "label": 0}, {"idx": "cosqa-train-732", "doc": "how do i get sympy into python", "code": "def make_qs(n, m=None):\n    \"\"\"Make sympy symbols q0, q1, ...\n    \n    Args:\n        n(int), m(int, optional):\n            If specified both n and m, returns [qn, q(n+1), ..., qm],\n            Only n is specified, returns[q0, q1, ..., qn].\n\n    Return:\n        tuple(Symbol): Tuple of sympy symbols.\n    \"\"\"\n    try:\n        import sympy\n    except ImportError:\n        raise ImportError(\"This function requires sympy. Please install it.\")\n    if m is None:\n        syms = sympy.symbols(\" \".join(f\"q{i}\" for i in range(n)))\n        if isinstance(syms, tuple):\n            return syms\n        else:\n            return (syms,)\n    syms = sympy.symbols(\" \".join(f\"q{i}\" for i in range(n, m)))\n    if isinstance(syms, tuple):\n        return syms\n    else:\n        return (syms,)", "code_tokens": "def make_qs ( n , m = None ) : try : import sympy except ImportError : raise ImportError ( \"This function requires sympy. Please install it.\" ) if m is None : syms = sympy . symbols ( \" \" . join ( f\"q{i}\" for i in range ( n ) ) ) if isinstance ( syms , tuple ) : return syms else : return ( syms , ) syms = sympy . symbols ( \" \" . join ( f\"q{i}\" for i in range ( n , m ) ) ) if isinstance ( syms , tuple ) : return syms else : return ( syms , )", "docstring_tokens": "Make sympy symbols q0 q1 ... Args : n ( int ) m ( int optional ) : If specified both n and m returns [ qn q ( n + 1 ) ... qm ] Only n is specified returns [ q0 q1 ... qn ] .", "label": 1}, {"idx": "cosqa-train-733", "doc": "python isdir invalid syntax", "code": "def isdir(path, **kwargs):\n    \"\"\"Check if *path* is a directory\"\"\"\n    import os.path\n    return os.path.isdir(path, **kwargs)", "code_tokens": "def isdir ( path , * * kwargs ) : import os . path return os . path . isdir ( path , * * kwargs )", "docstring_tokens": "Check if * path * is a directory", "label": 0}, {"idx": "cosqa-train-734", "doc": "python isfinite false is not in list", "code": "def is_float_array(l):\n    r\"\"\"Checks if l is a numpy array of floats (any dimension\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.dtype.kind == 'f':\n            return True\n    return False", "code_tokens": "def is_float_array ( l ) : if isinstance ( l , np . ndarray ) : if l . dtype . kind == 'f' : return True return False", "docstring_tokens": "r Checks if l is a numpy array of floats ( any dimension", "label": 0}, {"idx": "cosqa-train-735", "doc": "how do i replace a string with another string in python", "code": "def myreplace(astr, thefind, thereplace):\n    \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"\n    alist = astr.split(thefind)\n    new_s = alist.split(thereplace)\n    return new_s", "code_tokens": "def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "docstring_tokens": "in string astr replace all occurences of thefind with thereplace", "label": 0}, {"idx": "cosqa-train-736", "doc": "python isinstance tuple or list", "code": "def is_iter_non_string(obj):\n    \"\"\"test if object is a list or tuple\"\"\"\n    if isinstance(obj, list) or isinstance(obj, tuple):\n        return True\n    return False", "code_tokens": "def is_iter_non_string ( obj ) : if isinstance ( obj , list ) or isinstance ( obj , tuple ) : return True return False", "docstring_tokens": "test if object is a list or tuple", "label": 0}, {"idx": "cosqa-train-737", "doc": "how do i round to two decimal places in python", "code": "def round_to_x_digits(number, digits):\n    \"\"\"\n    Returns 'number' rounded to 'digits' digits.\n    \"\"\"\n    return round(number * math.pow(10, digits)) / math.pow(10, digits)", "code_tokens": "def round_to_x_digits ( number , digits ) : return round ( number * math . pow ( 10 , digits ) ) / math . pow ( 10 , digits )", "docstring_tokens": "Returns number rounded to digits digits .", "label": 0}, {"idx": "cosqa-train-738", "doc": "python iter has no next", "code": "def __next__(self):\n    \"\"\"Pop the head off the iterator and return it.\"\"\"\n    res = self._head\n    self._fill()\n    if res is None:\n      raise StopIteration()\n    return res", "code_tokens": "def __next__ ( self ) : res = self . _head self . _fill ( ) if res is None : raise StopIteration ( ) return res", "docstring_tokens": "Pop the head off the iterator and return it .", "label": 0}, {"idx": "cosqa-train-739", "doc": "how do you center text python", "code": "def center_text(text, width=80):\n    \"\"\"Center all lines of the text.\n\n    It is assumed that all lines width is smaller then B{width}, because the\n    line width will not be checked.\n\n    Args:\n        text (str): Text to wrap.\n        width (int): Maximum number of characters per line.\n\n    Returns:\n        str: Centered text.\n    \"\"\"\n    centered = []\n    for line in text.splitlines():\n        centered.append(line.center(width))\n    return \"\\n\".join(centered)", "code_tokens": "def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return \"\\n\" . join ( centered )", "docstring_tokens": "Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text .", "label": 0}, {"idx": "cosqa-train-740", "doc": "python iter with read", "code": "def next (self):    # File-like object.\n\n        \"\"\"This is to support iterators over a file-like object.\n        \"\"\"\n\n        result = self.readline()\n        if result == self._empty_buffer:\n            raise StopIteration\n        return result", "code_tokens": "def next ( self ) : # File-like object. result = self . readline ( ) if result == self . _empty_buffer : raise StopIteration return result", "docstring_tokens": "This is to support iterators over a file - like object .", "label": 0}, {"idx": "cosqa-train-741", "doc": "how do you change list into tuple python", "code": "def as_tuple(self, value):\n        \"\"\"Utility function which converts lists to tuples.\"\"\"\n        if isinstance(value, list):\n            value = tuple(value)\n        return value", "code_tokens": "def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value", "docstring_tokens": "Utility function which converts lists to tuples .", "label": 0}, {"idx": "cosqa-train-742", "doc": "python iterate in reverse order", "code": "def __reversed__(self):\n        \"\"\"\n        Return a reversed iterable over the items in the dictionary. Items are\n        iterated over in their reverse sort order.\n\n        Iterating views while adding or deleting entries in the dictionary may\n        raise a RuntimeError or fail to iterate over all entries.\n        \"\"\"\n        _dict = self._dict\n        return iter((key, _dict[key]) for key in reversed(self._list))", "code_tokens": "def __reversed__ ( self ) : _dict = self . _dict return iter ( ( key , _dict [ key ] ) for key in reversed ( self . _list ) )", "docstring_tokens": "Return a reversed iterable over the items in the dictionary . Items are iterated over in their reverse sort order .", "label": 0}, {"idx": "cosqa-train-743", "doc": "how do you code in lemmatizer python", "code": "def register_modele(self, modele: Modele):\n        \"\"\" Register a modele onto the lemmatizer\n\n        :param modele: Modele to register\n        \"\"\"\n        self.lemmatiseur._modeles[modele.gr()] = modele", "code_tokens": "def register_modele ( self , modele : Modele ) : self . lemmatiseur . _modeles [ modele . gr ( ) ] = modele", "docstring_tokens": "Register a modele onto the lemmatizer", "label": 1}, {"idx": "cosqa-train-744", "doc": "python iterate over every 10 items iterable", "code": "def split_every(n, iterable):\n    \"\"\"Returns a generator that spits an iteratable into n-sized chunks. The last chunk may have\n    less than n elements.\n\n    See http://stackoverflow.com/a/22919323/503377.\"\"\"\n    items = iter(iterable)\n    return itertools.takewhile(bool, (list(itertools.islice(items, n)) for _ in itertools.count()))", "code_tokens": "def split_every ( n , iterable ) : items = iter ( iterable ) return itertools . takewhile ( bool , ( list ( itertools . islice ( items , n ) ) for _ in itertools . count ( ) ) )", "docstring_tokens": "Returns a generator that spits an iteratable into n - sized chunks . The last chunk may have less than n elements .", "label": 0}, {"idx": "cosqa-train-745", "doc": "how do you flatten a list in python", "code": "def flatten(l):\n    \"\"\"Flatten a nested list.\"\"\"\n    return sum(map(flatten, l), []) \\\n        if isinstance(l, list) or isinstance(l, tuple) else [l]", "code_tokens": "def flatten ( l ) : return sum ( map ( flatten , l ) , [ ] ) if isinstance ( l , list ) or isinstance ( l , tuple ) else [ l ]", "docstring_tokens": "Flatten a nested list .", "label": 0}, {"idx": "cosqa-train-746", "doc": "python iterate through all the files in a directory", "code": "def directory_files(path):\n    \"\"\"Yield directory file names.\"\"\"\n\n    for entry in os.scandir(path):\n        if not entry.name.startswith('.') and entry.is_file():\n            yield entry.name", "code_tokens": "def directory_files ( path ) : for entry in os . scandir ( path ) : if not entry . name . startswith ( '.' ) and entry . is_file ( ) : yield entry . name", "docstring_tokens": "Yield directory file names .", "label": 0}, {"idx": "cosqa-train-747", "doc": "how do you load python numpy", "code": "def read_array(path, mmap_mode=None):\n    \"\"\"Read a .npy array.\"\"\"\n    file_ext = op.splitext(path)[1]\n    if file_ext == '.npy':\n        return np.load(path, mmap_mode=mmap_mode)\n    raise NotImplementedError(\"The file extension `{}` \".format(file_ext) +\n                              \"is not currently supported.\")", "code_tokens": "def read_array ( path , mmap_mode = None ) : file_ext = op . splitext ( path ) [ 1 ] if file_ext == '.npy' : return np . load ( path , mmap_mode = mmap_mode ) raise NotImplementedError ( \"The file extension `{}` \" . format ( file_ext ) + \"is not currently supported.\" )", "docstring_tokens": "Read a . npy array .", "label": 1}, {"idx": "cosqa-train-748", "doc": "python itertools groupby multiple keys", "code": "def group_by(iterable, key_func):\n    \"\"\"Wrap itertools.groupby to make life easier.\"\"\"\n    groups = (\n        list(sub) for key, sub in groupby(iterable, key_func)\n    )\n    return zip(groups, groups)", "code_tokens": "def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "docstring_tokens": "Wrap itertools . groupby to make life easier .", "label": 0}, {"idx": "cosqa-train-749", "doc": "how do you put python is in windows path", "code": "def get_python():\n    \"\"\"Determine the path to the virtualenv python\"\"\"\n    if sys.platform == 'win32':\n        python = path.join(VE_ROOT, 'Scripts', 'python.exe')\n    else:\n        python = path.join(VE_ROOT, 'bin', 'python')\n    return python", "code_tokens": "def get_python ( ) : if sys . platform == 'win32' : python = path . join ( VE_ROOT , 'Scripts' , 'python.exe' ) else : python = path . join ( VE_ROOT , 'bin' , 'python' ) return python", "docstring_tokens": "Determine the path to the virtualenv python", "label": 0}, {"idx": "cosqa-train-750", "doc": "python jinja2 template function calling", "code": "def render_template(template_name, **context):\n    \"\"\"Render a template into a response.\"\"\"\n    tmpl = jinja_env.get_template(template_name)\n    context[\"url_for\"] = url_for\n    return Response(tmpl.render(context), mimetype=\"text/html\")", "code_tokens": "def render_template ( template_name , * * context ) : tmpl = jinja_env . get_template ( template_name ) context [ \"url_for\" ] = url_for return Response ( tmpl . render ( context ) , mimetype = \"text/html\" )", "docstring_tokens": "Render a template into a response .", "label": 0}, {"idx": "cosqa-train-751", "doc": "how do you tell python to drop a column with no values", "code": "def selectnone(table, field, complement=False):\n    \"\"\"Select rows where the given field is `None`.\"\"\"\n\n    return select(table, field, lambda v: v is None, complement=complement)", "code_tokens": "def selectnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is None , complement = complement )", "docstring_tokens": "Select rows where the given field is None .", "label": 0}, {"idx": "cosqa-train-752", "doc": "python join data frame", "code": "def _join(verb):\n    \"\"\"\n    Join helper\n    \"\"\"\n    data = pd.merge(verb.x, verb.y, **verb.kwargs)\n\n    # Preserve x groups\n    if isinstance(verb.x, GroupedDataFrame):\n        data.plydata_groups = list(verb.x.plydata_groups)\n    return data", "code_tokens": "def _join ( verb ) : data = pd . merge ( verb . x , verb . y , * * verb . kwargs ) # Preserve x groups if isinstance ( verb . x , GroupedDataFrame ) : data . plydata_groups = list ( verb . x . plydata_groups ) return data", "docstring_tokens": "Join helper", "label": 0}, {"idx": "cosqa-train-753", "doc": "how do you use nbytes in python", "code": "def stn(s, length, encoding, errors):\n    \"\"\"Convert a string to a null-terminated bytes object.\n    \"\"\"\n    s = s.encode(encoding, errors)\n    return s[:length] + (length - len(s)) * NUL", "code_tokens": "def stn ( s , length , encoding , errors ) : s = s . encode ( encoding , errors ) return s [ : length ] + ( length - len ( s ) ) * NUL", "docstring_tokens": "Convert a string to a null - terminated bytes object .", "label": 0}, {"idx": "cosqa-train-754", "doc": "python join images into one", "code": "def join_images(img_files, out_file):\n    \"\"\"Join the list of images into the out file\"\"\"\n    images = [PIL.Image.open(f) for f in img_files]\n    joined = PIL.Image.new(\n        'RGB',\n        (sum(i.size[0] for i in images), max(i.size[1] for i in images))\n    )\n    left = 0\n    for img in images:\n        joined.paste(im=img, box=(left, 0))\n        left = left + img.size[0]\n    joined.save(out_file)", "code_tokens": "def join_images ( img_files , out_file ) : images = [ PIL . Image . open ( f ) for f in img_files ] joined = PIL . Image . new ( 'RGB' , ( sum ( i . size [ 0 ] for i in images ) , max ( i . size [ 1 ] for i in images ) ) ) left = 0 for img in images : joined . paste ( im = img , box = ( left , 0 ) ) left = left + img . size [ 0 ] joined . save ( out_file )", "docstring_tokens": "Join the list of images into the out file", "label": 0}, {"idx": "cosqa-train-755", "doc": "python join only part of a list", "code": "def get_join_cols(by_entry):\n  \"\"\" helper function used for joins\n  builds left and right join list for join function\n  \"\"\"\n  left_cols = []\n  right_cols = []\n  for col in by_entry:\n    if isinstance(col, str):\n      left_cols.append(col)\n      right_cols.append(col)\n    else:\n      left_cols.append(col[0])\n      right_cols.append(col[1])\n  return left_cols, right_cols", "code_tokens": "def get_join_cols ( by_entry ) : left_cols = [ ] right_cols = [ ] for col in by_entry : if isinstance ( col , str ) : left_cols . append ( col ) right_cols . append ( col ) else : left_cols . append ( col [ 0 ] ) right_cols . append ( col [ 1 ] ) return left_cols , right_cols", "docstring_tokens": "helper function used for joins builds left and right join list for join function", "label": 1}, {"idx": "cosqa-train-756", "doc": "how is a python script compiled", "code": "def IPYTHON_MAIN():\n    \"\"\"Decide if the Ipython command line is running code.\"\"\"\n    import pkg_resources\n\n    runner_frame = inspect.getouterframes(inspect.currentframe())[-2]\n    return (\n        getattr(runner_frame, \"function\", None)\n        == pkg_resources.load_entry_point(\"ipython\", \"console_scripts\", \"ipython\").__name__\n    )", "code_tokens": "def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , \"function\" , None ) == pkg_resources . load_entry_point ( \"ipython\" , \"console_scripts\" , \"ipython\" ) . __name__ )", "docstring_tokens": "Decide if the Ipython command line is running code .", "label": 1}, {"idx": "cosqa-train-757", "doc": "python join to dict", "code": "def flatten_dict_join_keys(dct, join_symbol=\" \"):\n    \"\"\" Flatten dict with defined key join symbol.\n\n    :param dct: dict to flatten\n    :param join_symbol: default value is \" \"\n    :return:\n    \"\"\"\n    return dict( flatten_dict(dct, join=lambda a,b:a+join_symbol+b) )", "code_tokens": "def flatten_dict_join_keys ( dct , join_symbol = \" \" ) : return dict ( flatten_dict ( dct , join = lambda a , b : a + join_symbol + b ) )", "docstring_tokens": "Flatten dict with defined key join symbol .", "label": 1}, {"idx": "cosqa-train-758", "doc": "how python hash a tuple", "code": "def hash_iterable(it):\n\t\"\"\"Perform a O(1) memory hash of an iterable of arbitrary length.\n\n\thash(tuple(it)) creates a temporary tuple containing all values from it\n\twhich could be a problem if it is large.\n\n\tSee discussion at:\n\thttps://groups.google.com/forum/#!msg/python-ideas/XcuC01a8SYs/e-doB9TbDwAJ\n\t\"\"\"\n\thash_value = hash(type(it))\n\tfor value in it:\n\t\thash_value = hash((hash_value, value))\n\treturn hash_value", "code_tokens": "def hash_iterable ( it ) : hash_value = hash ( type ( it ) ) for value in it : hash_value = hash ( ( hash_value , value ) ) return hash_value", "docstring_tokens": "Perform a O ( 1 ) memory hash of an iterable of arbitrary length .", "label": 1}, {"idx": "cosqa-train-759", "doc": "python join used in listcomprehension", "code": "def get_join_cols(by_entry):\n  \"\"\" helper function used for joins\n  builds left and right join list for join function\n  \"\"\"\n  left_cols = []\n  right_cols = []\n  for col in by_entry:\n    if isinstance(col, str):\n      left_cols.append(col)\n      right_cols.append(col)\n    else:\n      left_cols.append(col[0])\n      right_cols.append(col[1])\n  return left_cols, right_cols", "code_tokens": "def get_join_cols ( by_entry ) : left_cols = [ ] right_cols = [ ] for col in by_entry : if isinstance ( col , str ) : left_cols . append ( col ) right_cols . append ( col ) else : left_cols . append ( col [ 0 ] ) right_cols . append ( col [ 1 ] ) return left_cols , right_cols", "docstring_tokens": "helper function used for joins builds left and right join list for join function", "label": 0}, {"idx": "cosqa-train-760", "doc": "how to a matrix diagonally dominant in python", "code": "def _to_diagonally_dominant(mat):\n    \"\"\"Make matrix unweighted diagonally dominant using the Laplacian.\"\"\"\n    mat += np.diag(np.sum(mat != 0, axis=1) + 0.01)\n    return mat", "code_tokens": "def _to_diagonally_dominant ( mat ) : mat += np . diag ( np . sum ( mat != 0 , axis = 1 ) + 0.01 ) return mat", "docstring_tokens": "Make matrix unweighted diagonally dominant using the Laplacian .", "label": 0}, {"idx": "cosqa-train-761", "doc": "python join with delimiter", "code": "def _py2_and_3_joiner(sep, joinable):\n    \"\"\"\n    Allow '\\n'.join(...) statements to work in Py2 and Py3.\n    :param sep:\n    :param joinable:\n    :return:\n    \"\"\"\n    if ISPY3:\n        sep = bytes(sep, DEFAULT_ENCODING)\n    joined = sep.join(joinable)\n    return joined.decode(DEFAULT_ENCODING) if ISPY3 else joined", "code_tokens": "def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "docstring_tokens": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return :", "label": 0}, {"idx": "cosqa-train-762", "doc": "how to acces setter method property python", "code": "def traverse_setter(obj, attribute, value):\n    \"\"\"\n    Traverses the object and sets the supplied attribute on the\n    object. Supports Dimensioned and DimensionedPlot types.\n    \"\"\"\n    obj.traverse(lambda x: setattr(x, attribute, value))", "code_tokens": "def traverse_setter ( obj , attribute , value ) : obj . traverse ( lambda x : setattr ( x , attribute , value ) )", "docstring_tokens": "Traverses the object and sets the supplied attribute on the object . Supports Dimensioned and DimensionedPlot types .", "label": 0}, {"idx": "cosqa-train-763", "doc": "python js object passing", "code": "def add_to_js(self, name, var):\n        \"\"\"Add an object to Javascript.\"\"\"\n        frame = self.page().mainFrame()\n        frame.addToJavaScriptWindowObject(name, var)", "code_tokens": "def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )", "docstring_tokens": "Add an object to Javascript .", "label": 0}, {"idx": "cosqa-train-764", "doc": "how to access aws s3 bucket file in python", "code": "def read_key(self, key, bucket_name=None):\n        \"\"\"\n        Reads a key from S3\n\n        :param key: S3 key that will point to the file\n        :type key: str\n        :param bucket_name: Name of the bucket in which the file is stored\n        :type bucket_name: str\n        \"\"\"\n\n        obj = self.get_key(key, bucket_name)\n        return obj.get()['Body'].read().decode('utf-8')", "code_tokens": "def read_key ( self , key , bucket_name = None ) : obj = self . get_key ( key , bucket_name ) return obj . get ( ) [ 'Body' ] . read ( ) . decode ( 'utf-8' )", "docstring_tokens": "Reads a key from S3", "label": 0}, {"idx": "cosqa-train-765", "doc": "python json dump beautifier", "code": "def dump_json(obj):\n    \"\"\"Dump Python object as JSON string.\"\"\"\n    return simplejson.dumps(obj, ignore_nan=True, default=json_util.default)", "code_tokens": "def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )", "docstring_tokens": "Dump Python object as JSON string .", "label": 0}, {"idx": "cosqa-train-766", "doc": "how to access file properties python", "code": "def get_property(self, filename):\n        \"\"\"Opens the file and reads the value\"\"\"\n\n        with open(self.filepath(filename)) as f:\n            return f.read().strip()", "code_tokens": "def get_property ( self , filename ) : with open ( self . filepath ( filename ) ) as f : return f . read ( ) . strip ( )", "docstring_tokens": "Opens the file and reads the value", "label": 0}, {"idx": "cosqa-train-767", "doc": "python json dump pretty format", "code": "def pretty_dict_str(d, indent=2):\n    \"\"\"shows JSON indented representation of d\"\"\"\n    b = StringIO()\n    write_pretty_dict_str(b, d, indent=indent)\n    return b.getvalue()", "code_tokens": "def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )", "docstring_tokens": "shows JSON indented representation of d", "label": 0}, {"idx": "cosqa-train-768", "doc": "how to access python help", "code": "def help_for_command(command):\n    \"\"\"Get the help text (signature + docstring) for a command (function).\"\"\"\n    help_text = pydoc.text.document(command)\n    # remove backspaces\n    return re.subn('.\\\\x08', '', help_text)[0]", "code_tokens": "def help_for_command ( command ) : help_text = pydoc . text . document ( command ) # remove backspaces return re . subn ( '.\\\\x08' , '' , help_text ) [ 0 ]", "docstring_tokens": "Get the help text ( signature + docstring ) for a command ( function ) .", "label": 0}, {"idx": "cosqa-train-769", "doc": "python json save file new file", "code": "def save(self, fname):\n        \"\"\" Saves the dictionary in json format\n        :param fname: file to save to\n        \"\"\"\n        with open(fname, 'wb') as f:\n            json.dump(self, f)", "code_tokens": "def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )", "docstring_tokens": "Saves the dictionary in json format : param fname : file to save to", "label": 0}, {"idx": "cosqa-train-770", "doc": "how to add a line to the end of a python file", "code": "def prepend_line(filepath, line):\n    \"\"\"Rewrite a file adding a line to its beginning.\n    \"\"\"\n    with open(filepath) as f:\n        lines = f.readlines()\n\n    lines.insert(0, line)\n\n    with open(filepath, 'w') as f:\n        f.writelines(lines)", "code_tokens": "def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )", "docstring_tokens": "Rewrite a file adding a line to its beginning .", "label": 0}, {"idx": "cosqa-train-771", "doc": "python json schema validation", "code": "def validate(raw_schema, target=None, **kwargs):\n    \"\"\"\n    Given the python representation of a JSONschema as defined in the swagger\n    spec, validate that the schema complies to spec.  If `target` is provided,\n    that target will be validated against the provided schema.\n    \"\"\"\n    schema = schema_validator(raw_schema, **kwargs)\n    if target is not None:\n        validate_object(target, schema=schema, **kwargs)", "code_tokens": "def validate ( raw_schema , target = None , * * kwargs ) : schema = schema_validator ( raw_schema , * * kwargs ) if target is not None : validate_object ( target , schema = schema , * * kwargs )", "docstring_tokens": "Given the python representation of a JSONschema as defined in the swagger spec validate that the schema complies to spec . If target is provided that target will be validated against the provided schema .", "label": 1}, {"idx": "cosqa-train-772", "doc": "how to add all outputs python", "code": "def build_output(self, fout):\n        \"\"\"Squash self.out into string.\n\n        Join every line in self.out with a new line and write the\n        result to the output file.\n        \"\"\"\n        fout.write('\\n'.join([s for s in self.out]))", "code_tokens": "def build_output ( self , fout ) : fout . write ( '\\n' . join ( [ s for s in self . out ] ) )", "docstring_tokens": "Squash self . out into string .", "label": 0}, {"idx": "cosqa-train-773", "doc": "python json serialize types", "code": "def json_serial(obj):\n    \"\"\"JSON serializer for objects not serializable by default json code\"\"\"\n    if isinstance(obj, LegipyModel):\n        return obj.to_json()\n    elif isinstance(obj, (datetime.date, datetime.datetime)):\n        return obj.isoformat()\n    raise TypeError(\"Type {0} not serializable\".format(repr(type(obj))))", "code_tokens": "def json_serial ( obj ) : if isinstance ( obj , LegipyModel ) : return obj . to_json ( ) elif isinstance ( obj , ( datetime . date , datetime . datetime ) ) : return obj . isoformat ( ) raise TypeError ( \"Type {0} not serializable\" . format ( repr ( type ( obj ) ) ) )", "docstring_tokens": "JSON serializer for objects not serializable by default json code", "label": 0}, {"idx": "cosqa-train-774", "doc": "how to add helper function in python", "code": "def generic_add(a, b):\n    \"\"\"Simple function to add two numbers\"\"\"\n    logger.debug('Called generic_add({}, {})'.format(a, b))\n    return a + b", "code_tokens": "def generic_add ( a , b ) : logger . debug ( 'Called generic_add({}, {})' . format ( a , b ) ) return a + b", "docstring_tokens": "Simple function to add two numbers", "label": 0}, {"idx": "cosqa-train-775", "doc": "python json to attributes", "code": "def _unjsonify(x, isattributes=False):\n    \"\"\"Convert JSON string to an ordered defaultdict.\"\"\"\n    if isattributes:\n        obj = json.loads(x)\n        return dict_class(obj)\n    return json.loads(x)", "code_tokens": "def _unjsonify ( x , isattributes = False ) : if isattributes : obj = json . loads ( x ) return dict_class ( obj ) return json . loads ( x )", "docstring_tokens": "Convert JSON string to an ordered defaultdict .", "label": 0}, {"idx": "cosqa-train-776", "doc": "how to add local abs file path in python 3", "code": "def get_absolute_path(*args):\n    \"\"\"Transform relative pathnames into absolute pathnames.\"\"\"\n    directory = os.path.dirname(os.path.abspath(__file__))\n    return os.path.join(directory, *args)", "code_tokens": "def get_absolute_path ( * args ) : directory = os . path . dirname ( os . path . abspath ( __file__ ) ) return os . path . join ( directory , * args )", "docstring_tokens": "Transform relative pathnames into absolute pathnames .", "label": 0}, {"idx": "cosqa-train-777", "doc": "python jsonify database query", "code": "def graphql_queries_to_json(*queries):\n    \"\"\"\n    Queries should be a list of GraphQL objects\n    \"\"\"\n    rtn = {}\n    for i, query in enumerate(queries):\n        rtn[\"q{}\".format(i)] = query.value\n    return json.dumps(rtn)", "code_tokens": "def graphql_queries_to_json ( * queries ) : rtn = { } for i , query in enumerate ( queries ) : rtn [ \"q{}\" . format ( i ) ] = query . value return json . dumps ( rtn )", "docstring_tokens": "Queries should be a list of GraphQL objects", "label": 0}, {"idx": "cosqa-train-778", "doc": "how to add noise to sound in python", "code": "def synthesize(self, duration):\n        \"\"\"\n        Synthesize white noise\n\n        Args:\n            duration (numpy.timedelta64): The duration of the synthesized sound\n        \"\"\"\n        sr = self.samplerate.samples_per_second\n        seconds = duration / Seconds(1)\n        samples = np.random.uniform(low=-1., high=1., size=int(sr * seconds))\n        return AudioSamples(samples, self.samplerate)", "code_tokens": "def synthesize ( self , duration ) : sr = self . samplerate . samples_per_second seconds = duration / Seconds ( 1 ) samples = np . random . uniform ( low = - 1. , high = 1. , size = int ( sr * seconds ) ) return AudioSamples ( samples , self . samplerate )", "docstring_tokens": "Synthesize white noise", "label": 1}, {"idx": "cosqa-train-779", "doc": "python judge empty dict", "code": "def _clean_dict(target_dict, whitelist=None):\n    \"\"\" Convenience function that removes a dicts keys that have falsy values\n    \"\"\"\n    assert isinstance(target_dict, dict)\n    return {\n        ustr(k).strip(): ustr(v).strip()\n        for k, v in target_dict.items()\n        if v not in (None, Ellipsis, [], (), \"\")\n        and (not whitelist or k in whitelist)\n    }", "code_tokens": "def _clean_dict ( target_dict , whitelist = None ) : assert isinstance ( target_dict , dict ) return { ustr ( k ) . strip ( ) : ustr ( v ) . strip ( ) for k , v in target_dict . items ( ) if v not in ( None , Ellipsis , [ ] , ( ) , \"\" ) and ( not whitelist or k in whitelist ) }", "docstring_tokens": "Convenience function that removes a dicts keys that have falsy values", "label": 1}, {"idx": "cosqa-train-780", "doc": "how to align text in center with python", "code": "def center_text(text, width=80):\n    \"\"\"Center all lines of the text.\n\n    It is assumed that all lines width is smaller then B{width}, because the\n    line width will not be checked.\n\n    Args:\n        text (str): Text to wrap.\n        width (int): Maximum number of characters per line.\n\n    Returns:\n        str: Centered text.\n    \"\"\"\n    centered = []\n    for line in text.splitlines():\n        centered.append(line.center(width))\n    return \"\\n\".join(centered)", "code_tokens": "def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return \"\\n\" . join ( centered )", "docstring_tokens": "Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text .", "label": 0}, {"idx": "cosqa-train-781", "doc": "python keras get embedding", "code": "def calculate_embedding(self, batch_image_bytes):\n    \"\"\"Get the embeddings for a given JPEG image.\n\n    Args:\n      batch_image_bytes: As if returned from [ff.read() for ff in file_list].\n\n    Returns:\n      The Inception embeddings (bottleneck layer output)\n    \"\"\"\n    return self.tf_session.run(\n        self.embedding, feed_dict={self.input_jpeg: batch_image_bytes})", "code_tokens": "def calculate_embedding ( self , batch_image_bytes ) : return self . tf_session . run ( self . embedding , feed_dict = { self . input_jpeg : batch_image_bytes } )", "docstring_tokens": "Get the embeddings for a given JPEG image .", "label": 1}, {"idx": "cosqa-train-782", "doc": "how to align text python", "code": "def center_text(text, width=80):\n    \"\"\"Center all lines of the text.\n\n    It is assumed that all lines width is smaller then B{width}, because the\n    line width will not be checked.\n\n    Args:\n        text (str): Text to wrap.\n        width (int): Maximum number of characters per line.\n\n    Returns:\n        str: Centered text.\n    \"\"\"\n    centered = []\n    for line in text.splitlines():\n        centered.append(line.center(width))\n    return \"\\n\".join(centered)", "code_tokens": "def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return \"\\n\" . join ( centered )", "docstring_tokens": "Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text .", "label": 0}, {"idx": "cosqa-train-783", "doc": "python kill process if time out", "code": "def timeout_thread_handler(timeout, stop_event):\n    \"\"\"A background thread to kill the process if it takes too long.\n\n    Args:\n        timeout (float): The number of seconds to wait before killing\n            the process.\n        stop_event (Event): An optional event to cleanly stop the background\n            thread if required during testing.\n    \"\"\"\n\n    stop_happened = stop_event.wait(timeout)\n    if stop_happened is False:\n        print(\"Killing program due to %f second timeout\" % timeout)\n\n    os._exit(2)", "code_tokens": "def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( \"Killing program due to %f second timeout\" % timeout ) os . _exit ( 2 )", "docstring_tokens": "A background thread to kill the process if it takes too long .", "label": 0}, {"idx": "cosqa-train-784", "doc": "how to allow python permission to copy files", "code": "def copy_no_perm(src, dst):\n    \"\"\"\n    Copies a file from *src* to *dst* including meta data except for permission bits.\n    \"\"\"\n    shutil.copy(src, dst)\n    perm = os.stat(dst).st_mode\n    shutil.copystat(src, dst)\n    os.chmod(dst, perm)", "code_tokens": "def copy_no_perm ( src , dst ) : shutil . copy ( src , dst ) perm = os . stat ( dst ) . st_mode shutil . copystat ( src , dst ) os . chmod ( dst , perm )", "docstring_tokens": "Copies a file from * src * to * dst * including meta data except for permission bits .", "label": 0}, {"idx": "cosqa-train-785", "doc": "how to append data to a json file python", "code": "def store_data(data):\n    \"\"\"Use this function to store data in a JSON file.\n\n    This function is used for loading up a JSON file and appending additional\n    data to the JSON file.\n\n    :param data: the data to add to the JSON file.\n    :type data: dict\n    \"\"\"\n    with open(url_json_path) as json_file:\n        try:\n            json_file_data = load(json_file)\n            json_file_data.update(data)\n        except (AttributeError, JSONDecodeError):\n            json_file_data = data\n    with open(url_json_path, 'w') as json_file:\n        dump(json_file_data, json_file, indent=4, sort_keys=True)", "code_tokens": "def store_data ( data ) : with open ( url_json_path ) as json_file : try : json_file_data = load ( json_file ) json_file_data . update ( data ) except ( AttributeError , JSONDecodeError ) : json_file_data = data with open ( url_json_path , 'w' ) as json_file : dump ( json_file_data , json_file , indent = 4 , sort_keys = True )", "docstring_tokens": "Use this function to store data in a JSON file .", "label": 0}, {"idx": "cosqa-train-786", "doc": "python lambda join dict values", "code": "def flatten_dict_join_keys(dct, join_symbol=\" \"):\n    \"\"\" Flatten dict with defined key join symbol.\n\n    :param dct: dict to flatten\n    :param join_symbol: default value is \" \"\n    :return:\n    \"\"\"\n    return dict( flatten_dict(dct, join=lambda a,b:a+join_symbol+b) )", "code_tokens": "def flatten_dict_join_keys ( dct , join_symbol = \" \" ) : return dict ( flatten_dict ( dct , join = lambda a , b : a + join_symbol + b ) )", "docstring_tokens": "Flatten dict with defined key join symbol .", "label": 0}, {"idx": "cosqa-train-787", "doc": "how to append text file name in python", "code": "def filename_addstring(filename, text):\n    \"\"\"\n    Add `text` to filename, keeping the extension in place\n    For example when adding a timestamp to the filename\n    \"\"\"\n    fn, ext = os.path.splitext(filename)\n    return fn + text + ext", "code_tokens": "def filename_addstring ( filename , text ) : fn , ext = os . path . splitext ( filename ) return fn + text + ext", "docstring_tokens": "Add text to filename keeping the extension in place For example when adding a timestamp to the filename", "label": 0}, {"idx": "cosqa-train-788", "doc": "python last element in stack", "code": "def pop(self):\n        \"\"\"\n        return the last stack element and delete it from the list\n        \"\"\"\n        if not self.empty():\n            val = self.stack[-1]\n            del self.stack[-1]\n            return val", "code_tokens": "def pop ( self ) : if not self . empty ( ) : val = self . stack [ - 1 ] del self . stack [ - 1 ] return val", "docstring_tokens": "return the last stack element and delete it from the list", "label": 0}, {"idx": "cosqa-train-789", "doc": "how to apply a log scale in python", "code": "def interpolate_logscale_single(start, end, coefficient):\n    \"\"\" Cosine interpolation \"\"\"\n    return np.exp(np.log(start) + (np.log(end) - np.log(start)) * coefficient)", "code_tokens": "def interpolate_logscale_single ( start , end , coefficient ) : return np . exp ( np . log ( start ) + ( np . log ( end ) - np . log ( start ) ) * coefficient )", "docstring_tokens": "Cosine interpolation", "label": 0}, {"idx": "cosqa-train-790", "doc": "python last modified file in directory", "code": "def get_last_modified_timestamp(self):\n        \"\"\"\n        Looks at the files in a git root directory and grabs the last modified timestamp\n        \"\"\"\n        cmd = \"find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '\"\n        ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        output = ps.communicate()[0]\n        print output", "code_tokens": "def get_last_modified_timestamp ( self ) : cmd = \"find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '\" ps = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) output = ps . communicate ( ) [ 0 ] print output", "docstring_tokens": "Looks at the files in a git root directory and grabs the last modified timestamp", "label": 0}, {"idx": "cosqa-train-791", "doc": "how to ask for input on python 3", "code": "def _stdin_(p):\n    \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"\n    _v = sys.version[0]\n    return input(p) if _v is '3' else raw_input(p)", "code_tokens": "def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "docstring_tokens": "Takes input from user . Works for Python 2 and 3 .", "label": 0}, {"idx": "cosqa-train-792", "doc": "python len of dimension list", "code": "def get_list_dimensions(_list):\n    \"\"\"\n    Takes a nested list and returns the size of each dimension followed\n    by the element type in the list\n    \"\"\"\n    if isinstance(_list, list) or isinstance(_list, tuple):\n        return [len(_list)] + get_list_dimensions(_list[0])\n    return []", "code_tokens": "def get_list_dimensions ( _list ) : if isinstance ( _list , list ) or isinstance ( _list , tuple ) : return [ len ( _list ) ] + get_list_dimensions ( _list [ 0 ] ) return [ ]", "docstring_tokens": "Takes a nested list and returns the size of each dimension followed by the element type in the list", "label": 0}, {"idx": "cosqa-train-793", "doc": "how to automatically sort files based on name, python", "code": "def sort_filenames(filenames):\n    \"\"\"\n    sort a list of files by filename only, ignoring the directory names\n    \"\"\"\n    basenames = [os.path.basename(x) for x in filenames]\n    indexes = [i[0] for i in sorted(enumerate(basenames), key=lambda x:x[1])]\n    return [filenames[x] for x in indexes]", "code_tokens": "def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "docstring_tokens": "sort a list of files by filename only ignoring the directory names", "label": 0}, {"idx": "cosqa-train-794", "doc": "python levenshtein ratio is wrong", "code": "def levenshtein_distance_metric(a, b):\n    \"\"\" 1 - farthest apart (same number of words, all diff). 0 - same\"\"\"\n    return (levenshtein_distance(a, b) / (2.0 * max(len(a), len(b), 1)))", "code_tokens": "def levenshtein_distance_metric ( a , b ) : return ( levenshtein_distance ( a , b ) / ( 2.0 * max ( len ( a ) , len ( b ) , 1 ) ) )", "docstring_tokens": "1 - farthest apart ( same number of words all diff ) . 0 - same", "label": 0}, {"idx": "cosqa-train-795", "doc": "how to block python code before executing", "code": "def wait_until_exit(self):\n        \"\"\" Wait until thread exit\n\n            Used for testing purpose only\n        \"\"\"\n\n        if self._timeout is None:\n            raise Exception(\"Thread will never exit. Use stop or specify timeout when starting it!\")\n\n        self._thread.join()\n        self.stop()", "code_tokens": "def wait_until_exit ( self ) : if self . _timeout is None : raise Exception ( \"Thread will never exit. Use stop or specify timeout when starting it!\" ) self . _thread . join ( ) self . stop ( )", "docstring_tokens": "Wait until thread exit", "label": 1}, {"idx": "cosqa-train-796", "doc": "python limit the execution time of the given function", "code": "def timed (log=sys.stderr, limit=2.0):\n    \"\"\"Decorator to run a function with timing info.\"\"\"\n    return lambda func: timeit(func, log, limit)", "code_tokens": "def timed ( log = sys . stderr , limit = 2.0 ) : return lambda func : timeit ( func , log , limit )", "docstring_tokens": "Decorator to run a function with timing info .", "label": 0}, {"idx": "cosqa-train-797", "doc": "how to build json param object in python", "code": "def dict_jsonp(param):\n    \"\"\"Convert the parameter into a dictionary before calling jsonp, if it's not already one\"\"\"\n    if not isinstance(param, dict):\n        param = dict(param)\n    return jsonp(param)", "code_tokens": "def dict_jsonp ( param ) : if not isinstance ( param , dict ) : param = dict ( param ) return jsonp ( param )", "docstring_tokens": "Convert the parameter into a dictionary before calling jsonp if it s not already one", "label": 0}, {"idx": "cosqa-train-798", "doc": "python line by line parse file yield", "code": "def txt_line_iterator(path):\n  \"\"\"Iterate through lines of file.\"\"\"\n  with tf.gfile.Open(path) as f:\n    for line in f:\n      yield line.strip()", "code_tokens": "def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )", "docstring_tokens": "Iterate through lines of file .", "label": 0}, {"idx": "cosqa-train-799", "doc": "how to calculate object size in python", "code": "def get_size(objects):\n    \"\"\"Compute the total size of all elements in objects.\"\"\"\n    res = 0\n    for o in objects:\n        try:\n            res += _getsizeof(o)\n        except AttributeError:\n            print(\"IGNORING: type=%s; o=%s\" % (str(type(o)), str(o)))\n    return res", "code_tokens": "def get_size ( objects ) : res = 0 for o in objects : try : res += _getsizeof ( o ) except AttributeError : print ( \"IGNORING: type=%s; o=%s\" % ( str ( type ( o ) ) , str ( o ) ) ) return res", "docstring_tokens": "Compute the total size of all elements in objects .", "label": 0}, {"idx": "cosqa-train-800", "doc": "python list all elements distinct", "code": "def distinct(xs):\n    \"\"\"Get the list of distinct values with preserving order.\"\"\"\n    # don't use collections.OrderedDict because we do support Python 2.6\n    seen = set()\n    return [x for x in xs if x not in seen and not seen.add(x)]", "code_tokens": "def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]", "docstring_tokens": "Get the list of distinct values with preserving order .", "label": 0}, {"idx": "cosqa-train-801", "doc": "how to calculate standard error on python", "code": "def stderr(a):\n    \"\"\"\n    Calculate the standard error of a.\n    \"\"\"\n    return np.nanstd(a) / np.sqrt(sum(np.isfinite(a)))", "code_tokens": "def stderr ( a ) : return np . nanstd ( a ) / np . sqrt ( sum ( np . isfinite ( a ) ) )", "docstring_tokens": "Calculate the standard error of a .", "label": 0}, {"idx": "cosqa-train-802", "doc": "python list all tables in sqlite", "code": "def get_table_names(connection):\n\t\"\"\"\n\tReturn a list of the table names in the database.\n\t\"\"\"\n\tcursor = connection.cursor()\n\tcursor.execute(\"SELECT name FROM sqlite_master WHERE type == 'table'\")\n\treturn [name for (name,) in cursor]", "code_tokens": "def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( \"SELECT name FROM sqlite_master WHERE type == 'table'\" ) return [ name for ( name , ) in cursor ]", "docstring_tokens": "Return a list of the table names in the database .", "label": 0}, {"idx": "cosqa-train-803", "doc": "how to calculate time to execute function python", "code": "def time(func, *args, **kwargs):\n    \"\"\"\n    Call the supplied function with the supplied arguments,\n    and return the total execution time as a float in seconds.\n\n    The precision of the returned value depends on the precision of\n    `time.time()` on your platform.\n\n    Arguments:\n        func: the function to run.\n        *args: positional arguments to pass into the function.\n        **kwargs: keyword arguments to pass into the function.\n    Returns:\n        Execution time of the function as a float in seconds.\n    \"\"\"\n    start_time = time_module.time()\n    func(*args, **kwargs)\n    end_time = time_module.time()\n    return end_time - start_time", "code_tokens": "def time ( func , * args , * * kwargs ) : start_time = time_module . time ( ) func ( * args , * * kwargs ) end_time = time_module . time ( ) return end_time - start_time", "docstring_tokens": "Call the supplied function with the supplied arguments and return the total execution time as a float in seconds .", "label": 0}, {"idx": "cosqa-train-804", "doc": "python list comprehension over two indexes", "code": "def equal(list1, list2):\n    \"\"\" takes flags returns indexes of True values \"\"\"\n    return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]", "code_tokens": "def equal ( list1 , list2 ) : return [ item1 == item2 for item1 , item2 in broadcast_zip ( list1 , list2 ) ]", "docstring_tokens": "takes flags returns indexes of True values", "label": 1}, {"idx": "cosqa-train-805", "doc": "how to capitalize a certain letter in a string in python", "code": "def camel_case_from_underscores(string):\n    \"\"\"generate a CamelCase string from an underscore_string.\"\"\"\n    components = string.split('_')\n    string = ''\n    for component in components:\n        string += component[0].upper() + component[1:]\n    return string", "code_tokens": "def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "docstring_tokens": "generate a CamelCase string from an underscore_string .", "label": 0}, {"idx": "cosqa-train-806", "doc": "python list get index with default", "code": "def list_get(l, idx, default=None):\n    \"\"\"\n    Get from a list with an optional default value.\n    \"\"\"\n    try:\n        if l[idx]:\n            return l[idx]\n        else:\n            return default\n    except IndexError:\n        return default", "code_tokens": "def list_get ( l , idx , default = None ) : try : if l [ idx ] : return l [ idx ] else : return default except IndexError : return default", "docstring_tokens": "Get from a list with an optional default value .", "label": 1}, {"idx": "cosqa-train-807", "doc": "how to captolize the first letter of a varriable string in python", "code": "def classnameify(s):\n  \"\"\"\n  Makes a classname\n  \"\"\"\n  return ''.join(w if w in ACRONYMS else w.title() for w in s.split('_'))", "code_tokens": "def classnameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '_' ) )", "docstring_tokens": "Makes a classname", "label": 0}, {"idx": "cosqa-train-808", "doc": "python list how to duplicate", "code": "def dedupe_list(l):\n    \"\"\"Remove duplicates from a list preserving the order.\n\n    We might be tempted to use the list(set(l)) idiom, but it doesn't preserve\n    the order, which hinders testability and does not work for lists with\n    unhashable elements.\n    \"\"\"\n    result = []\n\n    for el in l:\n        if el not in result:\n            result.append(el)\n\n    return result", "code_tokens": "def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result", "docstring_tokens": "Remove duplicates from a list preserving the order .", "label": 0}, {"idx": "cosqa-train-809", "doc": "how to cast to string in python", "code": "def force_to_string(unknown):\n    \"\"\"\n    converts and unknown type to string for display purposes.\n    \n    \"\"\"\n    result = ''\n    if type(unknown) is str:\n        result = unknown\n    if type(unknown) is int:\n        result = str(unknown)\n    if type(unknown) is float:\n        result = str(unknown)\n    if type(unknown) is dict:\n        result = Dict2String(unknown)\n    if type(unknown) is list:\n        result = List2String(unknown)\n    return result", "code_tokens": "def force_to_string ( unknown ) : result = '' if type ( unknown ) is str : result = unknown if type ( unknown ) is int : result = str ( unknown ) if type ( unknown ) is float : result = str ( unknown ) if type ( unknown ) is dict : result = Dict2String ( unknown ) if type ( unknown ) is list : result = List2String ( unknown ) return result", "docstring_tokens": "converts and unknown type to string for display purposes .", "label": 0}, {"idx": "cosqa-train-810", "doc": "python list of nan values", "code": "def nan_pixels(self):\n        \"\"\" Return an array of the NaN pixels.\n\n        Returns\n        -------\n        :obj:`numpy.ndarray`\n             Nx2 array of the NaN pixels\n        \"\"\"\n        nan_px = np.where(np.isnan(np.sum(self.raw_data, axis=2)))\n        nan_px = np.c_[nan_px[0], nan_px[1]]\n        return nan_px", "code_tokens": "def nan_pixels ( self ) : nan_px = np . where ( np . isnan ( np . sum ( self . raw_data , axis = 2 ) ) ) nan_px = np . c_ [ nan_px [ 0 ] , nan_px [ 1 ] ] return nan_px", "docstring_tokens": "Return an array of the NaN pixels .", "label": 0}, {"idx": "cosqa-train-811", "doc": "how to catch errors and store it in python", "code": "def clean_error(err):\n    \"\"\"\n    Take stderr bytes returned from MicroPython and attempt to create a\n    non-verbose error message.\n    \"\"\"\n    if err:\n        decoded = err.decode('utf-8')\n        try:\n            return decoded.split('\\r\\n')[-2]\n        except Exception:\n            return decoded\n    return 'There was an error.'", "code_tokens": "def clean_error ( err ) : if err : decoded = err . decode ( 'utf-8' ) try : return decoded . split ( '\\r\\n' ) [ - 2 ] except Exception : return decoded return 'There was an error.'", "docstring_tokens": "Take stderr bytes returned from MicroPython and attempt to create a non - verbose error message .", "label": 0}, {"idx": "cosqa-train-812", "doc": "python list of numpy array", "code": "def recarray(self):\n        \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"\n        return numpy.rec.fromrecords(self.records, names=self.names)", "code_tokens": "def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "docstring_tokens": "Returns data as : class : numpy . recarray .", "label": 0}, {"idx": "cosqa-train-813", "doc": "how to change a string to a lower case string within a list in python", "code": "def downcaseTokens(s,l,t):\n    \"\"\"Helper parse action to convert tokens to lower case.\"\"\"\n    return [ tt.lower() for tt in map(_ustr,t) ]", "code_tokens": "def downcaseTokens ( s , l , t ) : return [ tt . lower ( ) for tt in map ( _ustr , t ) ]", "docstring_tokens": "Helper parse action to convert tokens to lower case .", "label": 0}, {"idx": "cosqa-train-814", "doc": "python list of numpy arrays", "code": "def torecarray(*args, **kwargs):\n    \"\"\"\n    Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.\n\n    \"\"\"\n\n    import numpy as np\n    return toarray(*args, **kwargs).view(np.recarray)", "code_tokens": "def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )", "docstring_tokens": "Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) .", "label": 0}, {"idx": "cosqa-train-815", "doc": "how to change an array of lists into an array python", "code": "def arr_to_vector(arr):\n    \"\"\"Reshape a multidimensional array to a vector.\n    \"\"\"\n    dim = array_dim(arr)\n    tmp_arr = []\n    for n in range(len(dim) - 1):\n        for inner in arr:\n            for i in inner:\n                tmp_arr.append(i)\n        arr = tmp_arr\n        tmp_arr = []\n    return arr", "code_tokens": "def arr_to_vector ( arr ) : dim = array_dim ( arr ) tmp_arr = [ ] for n in range ( len ( dim ) - 1 ) : for inner in arr : for i in inner : tmp_arr . append ( i ) arr = tmp_arr tmp_arr = [ ] return arr", "docstring_tokens": "Reshape a multidimensional array to a vector .", "label": 0}, {"idx": "cosqa-train-816", "doc": "python list of objet methods", "code": "def get_all_attributes(klass_or_instance):\n    \"\"\"Get all attribute members (attribute, property style method).\n    \"\"\"\n    pairs = list()\n    for attr, value in inspect.getmembers(\n            klass_or_instance, lambda x: not inspect.isroutine(x)):\n        if not (attr.startswith(\"__\") or attr.endswith(\"__\")):\n            pairs.append((attr, value))\n    return pairs", "code_tokens": "def get_all_attributes ( klass_or_instance ) : pairs = list ( ) for attr , value in inspect . getmembers ( klass_or_instance , lambda x : not inspect . isroutine ( x ) ) : if not ( attr . startswith ( \"__\" ) or attr . endswith ( \"__\" ) ) : pairs . append ( ( attr , value ) ) return pairs", "docstring_tokens": "Get all attribute members ( attribute property style method ) .", "label": 0}, {"idx": "cosqa-train-817", "doc": "how to change epoch time into zulu time python 3", "code": "def session_to_epoch(timestamp):\n    \"\"\" converts Synergy Timestamp for session to UTC zone seconds since epoch \"\"\"\n    utc_timetuple = datetime.strptime(timestamp, SYNERGY_SESSION_PATTERN).replace(tzinfo=None).utctimetuple()\n    return calendar.timegm(utc_timetuple)", "code_tokens": "def session_to_epoch ( timestamp ) : utc_timetuple = datetime . strptime ( timestamp , SYNERGY_SESSION_PATTERN ) . replace ( tzinfo = None ) . utctimetuple ( ) return calendar . timegm ( utc_timetuple )", "docstring_tokens": "converts Synergy Timestamp for session to UTC zone seconds since epoch", "label": 0}, {"idx": "cosqa-train-818", "doc": "python list of zero numpy", "code": "def zero_pixels(self):\n        \"\"\" Return an array of the zero pixels.\n\n        Returns\n        -------\n        :obj:`numpy.ndarray`\n             Nx2 array of the zero pixels\n        \"\"\"\n        zero_px = np.where(np.sum(self.raw_data, axis=2) == 0)\n        zero_px = np.c_[zero_px[0], zero_px[1]]\n        return zero_px", "code_tokens": "def zero_pixels ( self ) : zero_px = np . where ( np . sum ( self . raw_data , axis = 2 ) == 0 ) zero_px = np . c_ [ zero_px [ 0 ] , zero_px [ 1 ] ] return zero_px", "docstring_tokens": "Return an array of the zero pixels .", "label": 0}, {"idx": "cosqa-train-819", "doc": "how to change headers of table in python", "code": "def end_table_header(self):\n        r\"\"\"End the table header which will appear on every page.\"\"\"\n\n        if self.header:\n            msg = \"Table already has a header\"\n            raise TableError(msg)\n\n        self.header = True\n\n        self.append(Command(r'endhead'))", "code_tokens": "def end_table_header ( self ) : if self . header : msg = \"Table already has a header\" raise TableError ( msg ) self . header = True self . append ( Command ( r'endhead' ) )", "docstring_tokens": "r End the table header which will appear on every page .", "label": 0}, {"idx": "cosqa-train-820", "doc": "python load argparse from json", "code": "def main(args=sys.argv):\n    \"\"\"\n    main entry point for the jardiff CLI\n    \"\"\"\n\n    parser = create_optparser(args[0])\n    return cli(parser.parse_args(args[1:]))", "code_tokens": "def main ( args = sys . argv ) : parser = create_optparser ( args [ 0 ] ) return cli ( parser . parse_args ( args [ 1 : ] ) )", "docstring_tokens": "main entry point for the jardiff CLI", "label": 0}, {"idx": "cosqa-train-821", "doc": "how to change ioerror python3", "code": "def raise_os_error(_errno, path=None):\n    \"\"\"\n    Helper for raising the correct exception under Python 3 while still\n    being able to raise the same common exception class in Python 2.7.\n    \"\"\"\n\n    msg = \"%s: '%s'\" % (strerror(_errno), path) if path else strerror(_errno)\n    raise OSError(_errno, msg)", "code_tokens": "def raise_os_error ( _errno , path = None ) : msg = \"%s: '%s'\" % ( strerror ( _errno ) , path ) if path else strerror ( _errno ) raise OSError ( _errno , msg )", "docstring_tokens": "Helper for raising the correct exception under Python 3 while still being able to raise the same common exception class in Python 2 . 7 .", "label": 0}, {"idx": "cosqa-train-822", "doc": "python load mnist data no numpy", "code": "def get_mnist(data_type=\"train\", location=\"/tmp/mnist\"):\n    \"\"\"\n    Get mnist dataset with features and label as ndarray.\n    Data would be downloaded automatically if it doesn't present at the specific location.\n\n    :param data_type: \"train\" for training data and \"test\" for testing data.\n    :param location: Location to store mnist dataset.\n    :return: (features: ndarray, label: ndarray)\n    \"\"\"\n    X, Y = mnist.read_data_sets(location, data_type)\n    return X, Y + 1", "code_tokens": "def get_mnist ( data_type = \"train\" , location = \"/tmp/mnist\" ) : X , Y = mnist . read_data_sets ( location , data_type ) return X , Y + 1", "docstring_tokens": "Get mnist dataset with features and label as ndarray . Data would be downloaded automatically if it doesn t present at the specific location .", "label": 1}, {"idx": "cosqa-train-823", "doc": "how to change max line length in python", "code": "def _multiline_width(multiline_s, line_width_fn=len):\n    \"\"\"Visible width of a potentially multiline content.\"\"\"\n    return max(map(line_width_fn, re.split(\"[\\r\\n]\", multiline_s)))", "code_tokens": "def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( \"[\\r\\n]\" , multiline_s ) ) )", "docstring_tokens": "Visible width of a potentially multiline content .", "label": 0}, {"idx": "cosqa-train-824", "doc": "python load variable into environment from function", "code": "def exec_function(ast, globals_map):\n    \"\"\"Execute a python code object in the given environment.\n\n    Args:\n      globals_map: Dictionary to use as the globals context.\n    Returns:\n      locals_map: Dictionary of locals from the environment after execution.\n    \"\"\"\n    locals_map = globals_map\n    exec ast in globals_map, locals_map\n    return locals_map", "code_tokens": "def exec_function ( ast , globals_map ) : locals_map = globals_map exec ast in globals_map , locals_map return locals_map", "docstring_tokens": "Execute a python code object in the given environment .", "label": 0}, {"idx": "cosqa-train-825", "doc": "how to change name of a column in python data frame", "code": "def col_rename(df,col_name,new_col_name):\n    \"\"\" Changes a column name in a DataFrame\n    Parameters:\n    df - DataFrame\n        DataFrame to operate on\n    col_name - string\n        Name of column to change\n    new_col_name - string\n        New name of column\n    \"\"\"\n    col_list = list(df.columns)\n    for index,value in enumerate(col_list):\n        if value == col_name:\n            col_list[index] = new_col_name\n            break\n    df.columns = col_list", "code_tokens": "def col_rename ( df , col_name , new_col_name ) : col_list = list ( df . columns ) for index , value in enumerate ( col_list ) : if value == col_name : col_list [ index ] = new_col_name break df . columns = col_list", "docstring_tokens": "Changes a column name in a DataFrame Parameters : df - DataFrame DataFrame to operate on col_name - string Name of column to change new_col_name - string New name of column", "label": 0}, {"idx": "cosqa-train-826", "doc": "python load yaml inline", "code": "def _include_yaml(loader, node):\n    \"\"\"Load another YAML file and embeds it using the !include tag.\n\n    Example:\n        device_tracker: !include device_tracker.yaml\n    \"\"\"\n    return load_yaml(os.path.join(os.path.dirname(loader.name), node.value))", "code_tokens": "def _include_yaml ( loader , node ) : return load_yaml ( os . path . join ( os . path . dirname ( loader . name ) , node . value ) )", "docstring_tokens": "Load another YAML file and embeds it using the !include tag .", "label": 0}, {"idx": "cosqa-train-827", "doc": "how to change strings to float in python", "code": "def comma_converter(float_string):\n    \"\"\"Convert numbers to floats whether the decimal point is '.' or ','\"\"\"\n    trans_table = maketrans(b',', b'.')\n    return float(float_string.translate(trans_table))", "code_tokens": "def comma_converter ( float_string ) : trans_table = maketrans ( b',' , b'.' ) return float ( float_string . translate ( trans_table ) )", "docstring_tokens": "Convert numbers to floats whether the decimal point is . or", "label": 0}, {"idx": "cosqa-train-828", "doc": "python local time to utc", "code": "def datetime_local_to_utc(local):\n    \"\"\"\n    Simple function to convert naive :std:`datetime.datetime` object containing\n    local time to a naive :std:`datetime.datetime` object with UTC time.\n    \"\"\"\n    timestamp = time.mktime(local.timetuple())\n    return datetime.datetime.utcfromtimestamp(timestamp)", "code_tokens": "def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )", "docstring_tokens": "Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time .", "label": 0}, {"idx": "cosqa-train-829", "doc": "how to change the case of any string data python", "code": "def to_identifier(s):\n  \"\"\"\n  Convert snake_case to camel_case.\n  \"\"\"\n  if s.startswith('GPS'):\n      s = 'Gps' + s[3:]\n  return ''.join([i.capitalize() for i in s.split('_')]) if '_' in s else s", "code_tokens": "def to_identifier ( s ) : if s . startswith ( 'GPS' ) : s = 'Gps' + s [ 3 : ] return '' . join ( [ i . capitalize ( ) for i in s . split ( '_' ) ] ) if '_' in s else s", "docstring_tokens": "Convert snake_case to camel_case .", "label": 0}, {"idx": "cosqa-train-830", "doc": "python locate item in a tuple", "code": "def tuple_search(t, i, v):\n    \"\"\"\n    Search tuple array by index and value\n    :param t: tuple array\n    :param i: index of the value in each tuple\n    :param v: value\n    :return: the first tuple in the array with the specific index / value\n    \"\"\"\n    for e in t:\n        if e[i] == v:\n            return e\n    return None", "code_tokens": "def tuple_search ( t , i , v ) : for e in t : if e [ i ] == v : return e return None", "docstring_tokens": "Search tuple array by index and value : param t : tuple array : param i : index of the value in each tuple : param v : value : return : the first tuple in the array with the specific index / value", "label": 0}, {"idx": "cosqa-train-831", "doc": "how to check aspect ratio photo in python", "code": "def image_set_aspect(aspect=1.0, axes=\"gca\"):\n    \"\"\"\n    sets the aspect ratio of the current zoom level of the imshow image\n    \"\"\"\n    if axes is \"gca\": axes = _pylab.gca()\n\n    e = axes.get_images()[0].get_extent()\n    axes.set_aspect(abs((e[1]-e[0])/(e[3]-e[2]))/aspect)", "code_tokens": "def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "docstring_tokens": "sets the aspect ratio of the current zoom level of the imshow image", "label": 0}, {"idx": "cosqa-train-832", "doc": "python lock if already aquired", "code": "def lock(self, block=True):\n\t\t\"\"\"\n\t\tLock connection from being used else where\n\t\t\"\"\"\n\t\tself._locked = True\n\t\treturn self._lock.acquire(block)", "code_tokens": "def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )", "docstring_tokens": "Lock connection from being used else where", "label": 0}, {"idx": "cosqa-train-833", "doc": "how to check column format in python", "code": "def _validate_pos(df):\n    \"\"\"Validates the returned positional object\n    \"\"\"\n    assert isinstance(df, pd.DataFrame)\n    assert [\"seqname\", \"position\", \"strand\"] == df.columns.tolist()\n    assert df.position.dtype == np.dtype(\"int64\")\n    assert df.strand.dtype == np.dtype(\"O\")\n    assert df.seqname.dtype == np.dtype(\"O\")\n    return df", "code_tokens": "def _validate_pos ( df ) : assert isinstance ( df , pd . DataFrame ) assert [ \"seqname\" , \"position\" , \"strand\" ] == df . columns . tolist ( ) assert df . position . dtype == np . dtype ( \"int64\" ) assert df . strand . dtype == np . dtype ( \"O\" ) assert df . seqname . dtype == np . dtype ( \"O\" ) return df", "docstring_tokens": "Validates the returned positional object", "label": 0}, {"idx": "cosqa-train-834", "doc": "python loess with gaussian kernel", "code": "def lognorm(x, mu, sigma=1.0):\n    \"\"\" Log-normal function from scipy \"\"\"\n    return stats.lognorm(sigma, scale=mu).pdf(x)", "code_tokens": "def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )", "docstring_tokens": "Log - normal function from scipy", "label": 1}, {"idx": "cosqa-train-835", "doc": "how to check data type of variable in python", "code": "def autoconvert(string):\n    \"\"\"Try to convert variables into datatypes.\"\"\"\n    for fn in (boolify, int, float):\n        try:\n            return fn(string)\n        except ValueError:\n            pass\n    return string", "code_tokens": "def autoconvert ( string ) : for fn in ( boolify , int , float ) : try : return fn ( string ) except ValueError : pass return string", "docstring_tokens": "Try to convert variables into datatypes .", "label": 1}, {"idx": "cosqa-train-836", "doc": "python log distribution between two numbers numpy", "code": "def to_distribution_values(self, values):\n        \"\"\"\n        Returns numpy array of natural logarithms of ``values``.\n        \"\"\"\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            # avoid RuntimeWarning: divide by zero encountered in log\n            return numpy.log(values)", "code_tokens": "def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( \"ignore\" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )", "docstring_tokens": "Returns numpy array of natural logarithms of values .", "label": 0}, {"idx": "cosqa-train-837", "doc": "how to check datatype in list in python", "code": "def _valid_other_type(x, types):\n    \"\"\"\n    Do all elements of x have a type from types?\n    \"\"\"\n    return all(any(isinstance(el, t) for t in types) for el in np.ravel(x))", "code_tokens": "def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )", "docstring_tokens": "Do all elements of x have a type from types?", "label": 0}, {"idx": "cosqa-train-838", "doc": "python log get handlers", "code": "def find_console_handler(logger):\n    \"\"\"Return a stream handler, if it exists.\"\"\"\n    for handler in logger.handlers:\n        if (isinstance(handler, logging.StreamHandler) and\n                handler.stream == sys.stderr):\n            return handler", "code_tokens": "def find_console_handler ( logger ) : for handler in logger . handlers : if ( isinstance ( handler , logging . StreamHandler ) and handler . stream == sys . stderr ) : return handler", "docstring_tokens": "Return a stream handler if it exists .", "label": 0}, {"idx": "cosqa-train-839", "doc": "how to check for non ascii in python", "code": "def unicode_is_ascii(u_string):\n    \"\"\"Determine if unicode string only contains ASCII characters.\n\n    :param str u_string: unicode string to check. Must be unicode\n        and not Python 2 `str`.\n    :rtype: bool\n    \"\"\"\n    assert isinstance(u_string, str)\n    try:\n        u_string.encode('ascii')\n        return True\n    except UnicodeEncodeError:\n        return False", "code_tokens": "def unicode_is_ascii ( u_string ) : assert isinstance ( u_string , str ) try : u_string . encode ( 'ascii' ) return True except UnicodeEncodeError : return False", "docstring_tokens": "Determine if unicode string only contains ASCII characters .", "label": 0}, {"idx": "cosqa-train-840", "doc": "python logger remove color", "code": "def clog(color):\n    \"\"\"Same to ``log``, but this one centralizes the message first.\"\"\"\n    logger = log(color)\n    return lambda msg: logger(centralize(msg).rstrip())", "code_tokens": "def clog ( color ) : logger = log ( color ) return lambda msg : logger ( centralize ( msg ) . rstrip ( ) )", "docstring_tokens": "Same to log but this one centralizes the message first .", "label": 0}, {"idx": "cosqa-train-841", "doc": "how to check function definition in python spyder", "code": "def is_defined(self, obj, force_import=False):\n        \"\"\"Return True if object is defined in current namespace\"\"\"\n        from spyder_kernels.utils.dochelpers import isdefined\n\n        ns = self._get_current_namespace(with_magics=True)\n        return isdefined(obj, force_import=force_import, namespace=ns)", "code_tokens": "def is_defined ( self , obj , force_import = False ) : from spyder_kernels . utils . dochelpers import isdefined ns = self . _get_current_namespace ( with_magics = True ) return isdefined ( obj , force_import = force_import , namespace = ns )", "docstring_tokens": "Return True if object is defined in current namespace", "label": 0}, {"idx": "cosqa-train-842", "doc": "python logging custom format", "code": "def format(self, record, *args, **kwargs):\n        \"\"\"\n        Format a message in the log\n\n        Act like the normal format, but indent anything that is a\n        newline within the message.\n\n        \"\"\"\n        return logging.Formatter.format(\n            self, record, *args, **kwargs).replace('\\n', '\\n' + ' ' * 8)", "code_tokens": "def format ( self , record , * args , * * kwargs ) : return logging . Formatter . format ( self , record , * args , * * kwargs ) . replace ( '\\n' , '\\n' + ' ' * 8 )", "docstring_tokens": "Format a message in the log", "label": 0}, {"idx": "cosqa-train-843", "doc": "how to check if a string contains any punctuation marks in python", "code": "def is_delimiter(line):\n    \"\"\" True if a line consists only of a single punctuation character.\"\"\"\n    return bool(line) and line[0] in punctuation and line[0]*len(line) == line", "code_tokens": "def is_delimiter ( line ) : return bool ( line ) and line [ 0 ] in punctuation and line [ 0 ] * len ( line ) == line", "docstring_tokens": "True if a line consists only of a single punctuation character .", "label": 0}, {"idx": "cosqa-train-844", "doc": "python logging fileconfig add config", "code": "def load_config(filename=\"logging.ini\", *args, **kwargs):\n    \"\"\"\n    Load logger config from file\n    \n    Keyword arguments:\n    filename -- configuration filename (Default: \"logging.ini\")\n    *args -- options passed to fileConfig\n    **kwargs -- options passed to fileConfigg\n    \n    \"\"\"\n    logging.config.fileConfig(filename, *args, **kwargs)", "code_tokens": "def load_config ( filename = \"logging.ini\" , * args , * * kwargs ) : logging . config . fileConfig ( filename , * args , * * kwargs )", "docstring_tokens": "Load logger config from file Keyword arguments : filename -- configuration filename ( Default : logging . ini ) * args -- options passed to fileConfig ** kwargs -- options passed to fileConfigg", "label": 0}, {"idx": "cosqa-train-845", "doc": "how to check if element is callable python", "code": "def is_parameter(self):\n        \"\"\"Whether this is a function parameter.\"\"\"\n        return (isinstance(self.scope, CodeFunction)\n                and self in self.scope.parameters)", "code_tokens": "def is_parameter ( self ) : return ( isinstance ( self . scope , CodeFunction ) and self in self . scope . parameters )", "docstring_tokens": "Whether this is a function parameter .", "label": 0}, {"idx": "cosqa-train-846", "doc": "how to check if iterable in python", "code": "def is_seq(obj):\n    \"\"\" Returns True if object is not a string but is iterable \"\"\"\n    if not hasattr(obj, '__iter__'):\n        return False\n    if isinstance(obj, basestring):\n        return False\n    return True", "code_tokens": "def is_seq ( obj ) : if not hasattr ( obj , '__iter__' ) : return False if isinstance ( obj , basestring ) : return False return True", "docstring_tokens": "Returns True if object is not a string but is iterable", "label": 0}, {"idx": "cosqa-train-847", "doc": "python logging only my code", "code": "def logger(message, level=10):\n    \"\"\"Handle logging.\"\"\"\n    logging.getLogger(__name__).log(level, str(message))", "code_tokens": "def logger ( message , level = 10 ) : logging . getLogger ( __name__ ) . log ( level , str ( message ) )", "docstring_tokens": "Handle logging .", "label": 0}, {"idx": "cosqa-train-848", "doc": "how to check if something is a nested list python", "code": "def is_listish(obj):\n    \"\"\"Check if something quacks like a list.\"\"\"\n    if isinstance(obj, (list, tuple, set)):\n        return True\n    return is_sequence(obj)", "code_tokens": "def is_listish ( obj ) : if isinstance ( obj , ( list , tuple , set ) ) : return True return is_sequence ( obj )", "docstring_tokens": "Check if something quacks like a list .", "label": 0}, {"idx": "cosqa-train-849", "doc": "python make 1d array into 2d array", "code": "def _convert_to_array(array_like, dtype):\n        \"\"\"\n        Convert Matrix attributes which are array-like or buffer to array.\n        \"\"\"\n        if isinstance(array_like, bytes):\n            return np.frombuffer(array_like, dtype=dtype)\n        return np.asarray(array_like, dtype=dtype)", "code_tokens": "def _convert_to_array ( array_like , dtype ) : if isinstance ( array_like , bytes ) : return np . frombuffer ( array_like , dtype = dtype ) return np . asarray ( array_like , dtype = dtype )", "docstring_tokens": "Convert Matrix attributes which are array - like or buffer to array .", "label": 0}, {"idx": "cosqa-train-850", "doc": "python make array to string", "code": "def bitsToString(arr):\n  \"\"\"Returns a string representing a numpy array of 0's and 1's\"\"\"\n  s = array('c','.'*len(arr))\n  for i in xrange(len(arr)):\n    if arr[i] == 1:\n      s[i]='*'\n  return s", "code_tokens": "def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s", "docstring_tokens": "Returns a string representing a numpy array of 0 s and 1 s", "label": 1}, {"idx": "cosqa-train-851", "doc": "how to check if string input is empty python", "code": "def is_non_empty_string(input_string):\n    \"\"\"\n    Validate if non empty string\n\n    :param input_string: Input is a *str*.\n    :return: True if input is string and non empty.\n       Raise :exc:`Exception` otherwise.\n    \"\"\"\n    try:\n        if not input_string.strip():\n            raise ValueError()\n    except AttributeError as error:\n        raise TypeError(error)\n\n    return True", "code_tokens": "def is_non_empty_string ( input_string ) : try : if not input_string . strip ( ) : raise ValueError ( ) except AttributeError as error : raise TypeError ( error ) return True", "docstring_tokens": "Validate if non empty string", "label": 0}, {"idx": "cosqa-train-852", "doc": "python make datetime naive", "code": "def get_naive(dt):\n  \"\"\"Gets a naive datetime from a datetime.\n\n  datetime_tz objects can't just have tzinfo replaced with None, you need to\n  call asdatetime.\n\n  Args:\n    dt: datetime object.\n\n  Returns:\n    datetime object without any timezone information.\n  \"\"\"\n  if not dt.tzinfo:\n    return dt\n  if hasattr(dt, \"asdatetime\"):\n    return dt.asdatetime()\n  return dt.replace(tzinfo=None)", "code_tokens": "def get_naive ( dt ) : if not dt . tzinfo : return dt if hasattr ( dt , \"asdatetime\" ) : return dt . asdatetime ( ) return dt . replace ( tzinfo = None )", "docstring_tokens": "Gets a naive datetime from a datetime .", "label": 0}, {"idx": "cosqa-train-853", "doc": "how to check if there's a match not case senseitive python string", "code": "def _match_literal(self, a, b=None):\n        \"\"\"Match two names.\"\"\"\n\n        return a.lower() == b if not self.case_sensitive else a == b", "code_tokens": "def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b", "docstring_tokens": "Match two names .", "label": 0}, {"idx": "cosqa-train-854", "doc": "python make dictionary immutable values", "code": "def make_symmetric(dict):\n    \"\"\"Makes the given dictionary symmetric. Values are assumed to be unique.\"\"\"\n    for key, value in list(dict.items()):\n        dict[value] = key\n    return dict", "code_tokens": "def make_symmetric ( dict ) : for key , value in list ( dict . items ( ) ) : dict [ value ] = key return dict", "docstring_tokens": "Makes the given dictionary symmetric . Values are assumed to be unique .", "label": 0}, {"idx": "cosqa-train-855", "doc": "how to check multiple data type in python", "code": "def isnumber(*args):\n    \"\"\"Checks if value is an integer, long integer or float.\n\n    NOTE: Treats booleans as numbers, where True=1 and False=0.\n    \"\"\"\n    return all(map(lambda c: isinstance(c, int) or isinstance(c, float), args))", "code_tokens": "def isnumber ( * args ) : return all ( map ( lambda c : isinstance ( c , int ) or isinstance ( c , float ) , args ) )", "docstring_tokens": "Checks if value is an integer long integer or float .", "label": 0}, {"idx": "cosqa-train-856", "doc": "python make path absolute", "code": "def relpath(path):\n    \"\"\"Path helper, gives you a path relative to this file\"\"\"\n    return os.path.normpath(\n        os.path.join(os.path.abspath(os.path.dirname(__file__)), path)\n    )", "code_tokens": "def relpath ( path ) : return os . path . normpath ( os . path . join ( os . path . abspath ( os . path . dirname ( __file__ ) ) , path ) )", "docstring_tokens": "Path helper gives you a path relative to this file", "label": 0}, {"idx": "cosqa-train-857", "doc": "how to check python cuda devices", "code": "def cudaDriverGetVersion():\n    \"\"\"\n    Get installed CUDA driver version.\n\n    Return the version of the installed CUDA driver as an integer. If\n    no driver is detected, 0 is returned.\n\n    Returns\n    -------\n    version : int\n        Driver version.\n\n    \"\"\"\n\n    version = ctypes.c_int()\n    status = _libcudart.cudaDriverGetVersion(ctypes.byref(version))\n    cudaCheckStatus(status)\n    return version.value", "code_tokens": "def cudaDriverGetVersion ( ) : version = ctypes . c_int ( ) status = _libcudart . cudaDriverGetVersion ( ctypes . byref ( version ) ) cudaCheckStatus ( status ) return version . value", "docstring_tokens": "Get installed CUDA driver version .", "label": 0}, {"idx": "cosqa-train-858", "doc": "python make pty raw", "code": "def israw(self, **kwargs):\n        \"\"\"\n        Returns True if the PTY should operate in raw mode.\n\n        If the container was not started with tty=True, this will return False.\n        \"\"\"\n\n        if self.raw is None:\n            info = self._container_info()\n            self.raw = self.stdout.isatty() and info['Config']['Tty']\n\n        return self.raw", "code_tokens": "def israw ( self , * * kwargs ) : if self . raw is None : info = self . _container_info ( ) self . raw = self . stdout . isatty ( ) and info [ 'Config' ] [ 'Tty' ] return self . raw", "docstring_tokens": "Returns True if the PTY should operate in raw mode .", "label": 0}, {"idx": "cosqa-train-859", "doc": "how to check the distance between two columns in python in python", "code": "def skip_connection_distance(a, b):\n    \"\"\"The distance between two skip-connections.\"\"\"\n    if a[2] != b[2]:\n        return 1.0\n    len_a = abs(a[1] - a[0])\n    len_b = abs(b[1] - b[0])\n    return (abs(a[0] - b[0]) + abs(len_a - len_b)) / (max(a[0], b[0]) + max(len_a, len_b))", "code_tokens": "def skip_connection_distance ( a , b ) : if a [ 2 ] != b [ 2 ] : return 1.0 len_a = abs ( a [ 1 ] - a [ 0 ] ) len_b = abs ( b [ 1 ] - b [ 0 ] ) return ( abs ( a [ 0 ] - b [ 0 ] ) + abs ( len_a - len_b ) ) / ( max ( a [ 0 ] , b [ 0 ] ) + max ( len_a , len_b ) )", "docstring_tokens": "The distance between two skip - connections .", "label": 0}, {"idx": "cosqa-train-860", "doc": "python make table from list", "code": "def html(header_rows):\n    \"\"\"\n    Convert a list of tuples describing a table into a HTML string\n    \"\"\"\n    name = 'table%d' % next(tablecounter)\n    return HtmlTable([map(str, row) for row in header_rows], name).render()", "code_tokens": "def html ( header_rows ) : name = 'table%d' % next ( tablecounter ) return HtmlTable ( [ map ( str , row ) for row in header_rows ] , name ) . render ( )", "docstring_tokens": "Convert a list of tuples describing a table into a HTML string", "label": 0}, {"idx": "cosqa-train-861", "doc": "how to check to see if matrix is square in python", "code": "def isSquare(matrix):\n    \"\"\"Check that ``matrix`` is square.\n\n    Returns\n    =======\n    is_square : bool\n        ``True`` if ``matrix`` is square, ``False`` otherwise.\n\n    \"\"\"\n    try:\n        try:\n            dim1, dim2 = matrix.shape\n        except AttributeError:\n            dim1, dim2 = _np.array(matrix).shape\n    except ValueError:\n        return False\n    if dim1 == dim2:\n        return True\n    return False", "code_tokens": "def isSquare ( matrix ) : try : try : dim1 , dim2 = matrix . shape except AttributeError : dim1 , dim2 = _np . array ( matrix ) . shape except ValueError : return False if dim1 == dim2 : return True return False", "docstring_tokens": "Check that matrix is square .", "label": 0}, {"idx": "cosqa-train-862", "doc": "python make tuple out of string", "code": "def ver_to_tuple(value):\n    \"\"\"\n    Convert version like string to a tuple of integers.\n    \"\"\"\n    return tuple(int(_f) for _f in re.split(r'\\D+', value) if _f)", "code_tokens": "def ver_to_tuple ( value ) : return tuple ( int ( _f ) for _f in re . split ( r'\\D+' , value ) if _f )", "docstring_tokens": "Convert version like string to a tuple of integers .", "label": 0}, {"idx": "cosqa-train-863", "doc": "how to check what type something is python", "code": "def is_type(value):\n        \"\"\"Determine if value is an instance or subclass of the class Type.\"\"\"\n        if isinstance(value, type):\n            return issubclass(value, Type)\n        return isinstance(value, Type)", "code_tokens": "def is_type ( value ) : if isinstance ( value , type ) : return issubclass ( value , Type ) return isinstance ( value , Type )", "docstring_tokens": "Determine if value is an instance or subclass of the class Type .", "label": 0}, {"idx": "cosqa-train-864", "doc": "python make variable format percentage", "code": "def _strvar(a, prec='{:G}'):\n    r\"\"\"Return variable as a string to print, with given precision.\"\"\"\n    return ' '.join([prec.format(i) for i in np.atleast_1d(a)])", "code_tokens": "def _strvar ( a , prec = '{:G}' ) : return ' ' . join ( [ prec . format ( i ) for i in np . atleast_1d ( a ) ] )", "docstring_tokens": "r Return variable as a string to print with given precision .", "label": 0}, {"idx": "cosqa-train-865", "doc": "how to check whether a filename contains certain characters in python", "code": "def check_filename(filename):\n    \"\"\"\n    Returns a boolean stating if the filename is safe to use or not. Note that\n    this does not test for \"legal\" names accepted, but a more restricted set of:\n    Letters, numbers, spaces, hyphens, underscores and periods.\n\n    :param filename: name of a file as a string\n    :return: boolean if it is a safe file name\n    \"\"\"\n    if not isinstance(filename, str):\n        raise TypeError(\"filename must be a string\")\n    if regex.path.linux.filename.search(filename):\n        return True\n    return False", "code_tokens": "def check_filename ( filename ) : if not isinstance ( filename , str ) : raise TypeError ( \"filename must be a string\" ) if regex . path . linux . filename . search ( filename ) : return True return False", "docstring_tokens": "Returns a boolean stating if the filename is safe to use or not . Note that this does not test for legal names accepted but a more restricted set of : Letters numbers spaces hyphens underscores and periods .", "label": 0}, {"idx": "cosqa-train-866", "doc": "python making a valid password", "code": "def GeneratePassphrase(length=20):\n  \"\"\"Create a 20 char passphrase with easily typeable chars.\"\"\"\n  valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  valid_chars += \"0123456789 ,-_&$#\"\n  return \"\".join(random.choice(valid_chars) for i in range(length))", "code_tokens": "def GeneratePassphrase ( length = 20 ) : valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" valid_chars += \"0123456789 ,-_&$#\" return \"\" . join ( random . choice ( valid_chars ) for i in range ( length ) )", "docstring_tokens": "Create a 20 char passphrase with easily typeable chars .", "label": 0}, {"idx": "cosqa-train-867", "doc": "how to check whether a type is float python", "code": "def is_float(value):\n    \"\"\"must be a float\"\"\"\n    return isinstance(value, float) or isinstance(value, int) or isinstance(value, np.float64), float(value)", "code_tokens": "def is_float ( value ) : return isinstance ( value , float ) or isinstance ( value , int ) or isinstance ( value , np . float64 ) , float ( value )", "docstring_tokens": "must be a float", "label": 0}, {"idx": "cosqa-train-868", "doc": "python many regex sub calls", "code": "def _sub_patterns(patterns, text):\n    \"\"\"\n    Apply re.sub to bunch of (pattern, repl)\n    \"\"\"\n    for pattern, repl in patterns:\n        text = re.sub(pattern, repl, text)\n    return text", "code_tokens": "def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text", "docstring_tokens": "Apply re . sub to bunch of ( pattern repl )", "label": 0}, {"idx": "cosqa-train-869", "doc": "how to choose a directory path using tkinter in python", "code": "def on_source_directory_chooser_clicked(self):\n        \"\"\"Autoconnect slot activated when tbSourceDir is clicked.\"\"\"\n\n        title = self.tr('Set the source directory for script and scenario')\n        self.choose_directory(self.source_directory, title)", "code_tokens": "def on_source_directory_chooser_clicked ( self ) : title = self . tr ( 'Set the source directory for script and scenario' ) self . choose_directory ( self . source_directory , title )", "docstring_tokens": "Autoconnect slot activated when tbSourceDir is clicked .", "label": 0}, {"idx": "cosqa-train-870", "doc": "python map json to list of object", "code": "def from_json_list(cls, api_client, data):\n        \"\"\"Convert a list of JSON values to a list of models\n        \"\"\"\n        return [cls.from_json(api_client, item) for item in data]", "code_tokens": "def from_json_list ( cls , api_client , data ) : return [ cls . from_json ( api_client , item ) for item in data ]", "docstring_tokens": "Convert a list of JSON values to a list of models", "label": 0}, {"idx": "cosqa-train-871", "doc": "how to clean up python sp cache", "code": "def clean_all(self, args):\n        \"\"\"Delete all build components; the package cache, package builds,\n        bootstrap builds and distributions.\"\"\"\n        self.clean_dists(args)\n        self.clean_builds(args)\n        self.clean_download_cache(args)", "code_tokens": "def clean_all ( self , args ) : self . clean_dists ( args ) self . clean_builds ( args ) self . clean_download_cache ( args )", "docstring_tokens": "Delete all build components ; the package cache package builds bootstrap builds and distributions .", "label": 0}, {"idx": "cosqa-train-872", "doc": "python map two functions", "code": "def _merge_maps(m1, m2):\n    \"\"\"merge two Mapping objects, keeping the type of the first mapping\"\"\"\n    return type(m1)(chain(m1.items(), m2.items()))", "code_tokens": "def _merge_maps ( m1 , m2 ) : return type ( m1 ) ( chain ( m1 . items ( ) , m2 . items ( ) ) )", "docstring_tokens": "merge two Mapping objects keeping the type of the first mapping", "label": 0}, {"idx": "cosqa-train-873", "doc": "how to clear all cells in python notrebook", "code": "def strip(notebook):\n    \"\"\"Remove outputs from a notebook.\"\"\"\n    for cell in notebook.cells:\n        if cell.cell_type == 'code':\n            cell.outputs = []\n            cell.execution_count = None", "code_tokens": "def strip ( notebook ) : for cell in notebook . cells : if cell . cell_type == 'code' : cell . outputs = [ ] cell . execution_count = None", "docstring_tokens": "Remove outputs from a notebook .", "label": 0}, {"idx": "cosqa-train-874", "doc": "python match not start with a word", "code": "def find_whole_word(w):\n    \"\"\"\n    Scan through string looking for a location where this word produces a match,\n    and return a corresponding MatchObject instance.\n    Return None if no position in the string matches the pattern;\n    note that this is different from finding a zero-length match at some point in the string.\n    \"\"\"\n    return re.compile(r'\\b({0})\\b'.format(w), flags=re.IGNORECASE).search", "code_tokens": "def find_whole_word ( w ) : return re . compile ( r'\\b({0})\\b' . format ( w ) , flags = re . IGNORECASE ) . search", "docstring_tokens": "Scan through string looking for a location where this word produces a match and return a corresponding MatchObject instance . Return None if no position in the string matches the pattern ; note that this is different from finding a zero - length match at some point in the string .", "label": 0}, {"idx": "cosqa-train-875", "doc": "how to clear cache in python", "code": "def __delitem__(self, resource):\n        \"\"\"Remove resource instance from internal cache\"\"\"\n        self.__caches[type(resource)].pop(resource.get_cache_internal_key(), None)", "code_tokens": "def __delitem__ ( self , resource ) : self . __caches [ type ( resource ) ] . pop ( resource . get_cache_internal_key ( ) , None )", "docstring_tokens": "Remove resource instance from internal cache", "label": 1}, {"idx": "cosqa-train-876", "doc": "python matplotlib axis range auto", "code": "def autozoom(self, n=None):\n        \"\"\"\n        Auto-scales the axes to fit all the data in plot index n. If n == None,\n        auto-scale everyone.\n        \"\"\"\n        if n==None:\n            for p in self.plot_widgets: p.autoRange()\n        else:        self.plot_widgets[n].autoRange()\n\n        return self", "code_tokens": "def autozoom ( self , n = None ) : if n == None : for p in self . plot_widgets : p . autoRange ( ) else : self . plot_widgets [ n ] . autoRange ( ) return self", "docstring_tokens": "Auto - scales the axes to fit all the data in plot index n . If n == None auto - scale everyone .", "label": 0}, {"idx": "cosqa-train-877", "doc": "how to clear the cpu memory in python", "code": "def invalidate_cache(cpu, address, size):\n        \"\"\" remove decoded instruction from instruction cache \"\"\"\n        cache = cpu.instruction_cache\n        for offset in range(size):\n            if address + offset in cache:\n                del cache[address + offset]", "code_tokens": "def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]", "docstring_tokens": "remove decoded instruction from instruction cache", "label": 0}, {"idx": "cosqa-train-878", "doc": "python matplotlib generate hex color string", "code": "def color_to_hex(color):\n    \"\"\"Convert matplotlib color code to hex color code\"\"\"\n    if color is None or colorConverter.to_rgba(color)[3] == 0:\n        return 'none'\n    else:\n        rgb = colorConverter.to_rgb(color)\n        return '#{0:02X}{1:02X}{2:02X}'.format(*(int(255 * c) for c in rgb))", "code_tokens": "def color_to_hex ( color ) : if color is None or colorConverter . to_rgba ( color ) [ 3 ] == 0 : return 'none' else : rgb = colorConverter . to_rgb ( color ) return '#{0:02X}{1:02X}{2:02X}' . format ( * ( int ( 255 * c ) for c in rgb ) )", "docstring_tokens": "Convert matplotlib color code to hex color code", "label": 0}, {"idx": "cosqa-train-879", "doc": "how to clear the previous line in python", "code": "def erase_lines(n=1):\n    \"\"\" Erases n lines from the screen and moves the cursor up to follow\n    \"\"\"\n    for _ in range(n):\n        print(codes.cursor[\"up\"], end=\"\")\n        print(codes.cursor[\"eol\"], end=\"\")", "code_tokens": "def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ \"up\" ] , end = \"\" ) print ( codes . cursor [ \"eol\" ] , end = \"\" )", "docstring_tokens": "Erases n lines from the screen and moves the cursor up to follow", "label": 0}, {"idx": "cosqa-train-880", "doc": "python matplotlib how to plot a line parallel to x axis", "code": "def horizontal_line(ax, scale, i, **kwargs):\n    \"\"\"\n    Draws the i-th horizontal line parallel to the lower axis.\n\n    Parameters\n    ----------\n    ax: Matplotlib AxesSubplot\n        The subplot to draw on.\n    scale: float, 1.0\n        Simplex scale size.\n    i: float\n        The index of the line to draw\n    kwargs: Dictionary\n        Any kwargs to pass through to Matplotlib.\n    \"\"\"\n\n    p1 = (0, i, scale - i)\n    p2 = (scale - i, i, 0)\n    line(ax, p1, p2, **kwargs)", "code_tokens": "def horizontal_line ( ax , scale , i , * * kwargs ) : p1 = ( 0 , i , scale - i ) p2 = ( scale - i , i , 0 ) line ( ax , p1 , p2 , * * kwargs )", "docstring_tokens": "Draws the i - th horizontal line parallel to the lower axis .", "label": 0}, {"idx": "cosqa-train-881", "doc": "how to close all threads in a thread array in python3", "code": "def terminate(self):\n        \"\"\"Terminate all workers and threads.\"\"\"\n        for t in self._threads:\n            t.quit()\n        self._thread = []\n        self._workers = []", "code_tokens": "def terminate ( self ) : for t in self . _threads : t . quit ( ) self . _thread = [ ] self . _workers = [ ]", "docstring_tokens": "Terminate all workers and threads .", "label": 1}, {"idx": "cosqa-train-882", "doc": "python matplotlib open in window", "code": "def raise_figure_window(f=0):\n    \"\"\"\n    Raises the supplied figure number or figure window.\n    \"\"\"\n    if _fun.is_a_number(f): f = _pylab.figure(f)\n    f.canvas.manager.window.raise_()", "code_tokens": "def raise_figure_window ( f = 0 ) : if _fun . is_a_number ( f ) : f = _pylab . figure ( f ) f . canvas . manager . window . raise_ ( )", "docstring_tokens": "Raises the supplied figure number or figure window .", "label": 0}, {"idx": "cosqa-train-883", "doc": "how to code python sum least of squares regression", "code": "def linregress(x, y, return_stats=False):\n    \"\"\"linear regression calculation\n\n    Parameters\n    ----\n    x :         independent variable (series)\n    y :         dependent variable (series)\n    return_stats : returns statistical values as well if required (bool)\n    \n\n    Returns\n    ----\n    list of parameters (and statistics)\n    \"\"\"\n    a1, a0, r_value, p_value, stderr = scipy.stats.linregress(x, y)\n\n    retval = a1, a0\n    if return_stats:\n        retval += r_value, p_value, stderr\n\n    return retval", "code_tokens": "def linregress ( x , y , return_stats = False ) : a1 , a0 , r_value , p_value , stderr = scipy . stats . linregress ( x , y ) retval = a1 , a0 if return_stats : retval += r_value , p_value , stderr return retval", "docstring_tokens": "linear regression calculation", "label": 0}, {"idx": "cosqa-train-884", "doc": "python matplotlib remove axis ticks", "code": "def clear_matplotlib_ticks(self, axis=\"both\"):\n        \"\"\"Clears the default matplotlib ticks.\"\"\"\n        ax = self.get_axes()\n        plotting.clear_matplotlib_ticks(ax=ax, axis=axis)", "code_tokens": "def clear_matplotlib_ticks ( self , axis = \"both\" ) : ax = self . get_axes ( ) plotting . clear_matplotlib_ticks ( ax = ax , axis = axis )", "docstring_tokens": "Clears the default matplotlib ticks .", "label": 0}, {"idx": "cosqa-train-885", "doc": "how to code tables in python using latex", "code": "def get_latex_table(self, parameters=None, transpose=False, caption=None,\n                        label=\"tab:model_params\", hlines=True, blank_fill=\"--\"):  # pragma: no cover\n        \"\"\" Generates a LaTeX table from parameter summaries.\n\n        Parameters\n        ----------\n        parameters : list[str], optional\n            A list of what parameters to include in the table. By default, includes all parameters\n        transpose : bool, optional\n            Defaults to False, which gives each column as a parameter, each chain (framework)\n            as a row. You can swap it so that you have a parameter each row and a framework\n            each column by setting this to True\n        caption : str, optional\n            If you want to generate a caption for the table through Python, use this.\n            Defaults to an empty string\n        label : str, optional\n            If you want to generate a label for the table through Python, use this.\n            Defaults to an empty string\n        hlines : bool, optional\n            Inserts ``\\\\hline`` before and after the header, and at the end of table.\n        blank_fill : str, optional\n            If a framework does not have a particular parameter, will fill that cell of\n            the table with this string.\n\n        Returns\n        -------\n        str\n            the LaTeX table.\n        \"\"\"\n        if parameters is None:\n            parameters = self.parent._all_parameters\n        for p in parameters:\n            assert isinstance(p, str), \\\n                \"Generating a LaTeX table requires all parameters have labels\"\n        num_parameters = len(parameters)\n        num_chains = len(self.parent.chains)\n        fit_values = self.get_summary(squeeze=False)\n        if label is None:\n            label = \"\"\n        if caption is None:\n            caption = \"\"\n\n        end_text = \" \\\\\\\\ \\n\"\n        if transpose:\n            column_text = \"c\" * (num_chains + 1)\n        else:\n            column_text = \"c\" * (num_parameters + 1)\n\n        center_text = \"\"\n        hline_text = \"\\\\hline\\n\"\n        if hlines:\n            center_text += hline_text + \"\\t\\t\"\n        if transpose:\n            center_text += \" & \".join([\"Parameter\"] + [c.name for c in self.parent.chains]) + end_text\n            if hlines:\n                center_text += \"\\t\\t\" + hline_text\n            for p in parameters:\n                arr = [\"\\t\\t\" + p]\n                for chain_res in fit_values:\n                    if p in chain_res:\n                        arr.append(self.get_parameter_text(*chain_res[p], wrap=True))\n                    else:\n                        arr.append(blank_fill)\n                center_text += \" & \".join(arr) + end_text\n        else:\n            center_text += \" & \".join([\"Model\"] + parameters) + end_text\n            if hlines:\n                center_text += \"\\t\\t\" + hline_text\n            for name, chain_res in zip([c.name for c in self.parent.chains], fit_values):\n                arr = [\"\\t\\t\" + name]\n                for p in parameters:\n                    if p in chain_res:\n                        arr.append(self.get_parameter_text(*chain_res[p], wrap=True))\n                    else:\n                        arr.append(blank_fill)\n                center_text += \" & \".join(arr) + end_text\n        if hlines:\n            center_text += \"\\t\\t\" + hline_text\n        final_text = get_latex_table_frame(caption, label) % (column_text, center_text)\n\n        return final_text", "code_tokens": "def get_latex_table ( self , parameters = None , transpose = False , caption = None , label = \"tab:model_params\" , hlines = True , blank_fill = \"--\" ) : # pragma: no cover if parameters is None : parameters = self . parent . _all_parameters for p in parameters : assert isinstance ( p , str ) , \"Generating a LaTeX table requires all parameters have labels\" num_parameters = len ( parameters ) num_chains = len ( self . parent . chains ) fit_values = self . get_summary ( squeeze = False ) if label is None : label = \"\" if caption is None : caption = \"\" end_text = \" \\\\\\\\ \\n\" if transpose : column_text = \"c\" * ( num_chains + 1 ) else : column_text = \"c\" * ( num_parameters + 1 ) center_text = \"\" hline_text = \"\\\\hline\\n\" if hlines : center_text += hline_text + \"\\t\\t\" if transpose : center_text += \" & \" . join ( [ \"Parameter\" ] + [ c . name for c in self . parent . chains ] ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text for p in parameters : arr = [ \"\\t\\t\" + p ] for chain_res in fit_values : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += \" & \" . join ( arr ) + end_text else : center_text += \" & \" . join ( [ \"Model\" ] + parameters ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text for name , chain_res in zip ( [ c . name for c in self . parent . chains ] , fit_values ) : arr = [ \"\\t\\t\" + name ] for p in parameters : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += \" & \" . join ( arr ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text final_text = get_latex_table_frame ( caption , label ) % ( column_text , center_text ) return final_text", "docstring_tokens": "Generates a LaTeX table from parameter summaries .", "label": 1}, {"idx": "cosqa-train-886", "doc": "python matplotlib set ylimit for subplot", "code": "def set_ylimits(self, row, column, min=None, max=None):\n        \"\"\"Set y-axis limits of a subplot.\n\n        :param row,column: specify the subplot.\n        :param min: minimal axis value\n        :param max: maximum axis value\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_ylimits(min, max)", "code_tokens": "def set_ylimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_ylimits ( min , max )", "docstring_tokens": "Set y - axis limits of a subplot .", "label": 0}, {"idx": "cosqa-train-887", "doc": "how to code the norm in python", "code": "def _norm(self, x):\n    \"\"\"Compute the safe norm.\"\"\"\n    return tf.sqrt(tf.reduce_sum(tf.square(x), keepdims=True, axis=-1) + 1e-7)", "code_tokens": "def _norm ( self , x ) : return tf . sqrt ( tf . reduce_sum ( tf . square ( x ) , keepdims = True , axis = - 1 ) + 1e-7 )", "docstring_tokens": "Compute the safe norm .", "label": 0}, {"idx": "cosqa-train-888", "doc": "python matplotlib show multiple images", "code": "def show(self, imgs, ax=None):\n        \"\"\" Visualize the persistence image\n\n        \"\"\"\n\n        ax = ax or plt.gca()\n\n        if type(imgs) is not list:\n            imgs = [imgs]\n\n        for i, img in enumerate(imgs):\n            ax.imshow(img, cmap=plt.get_cmap(\"plasma\"))\n            ax.axis(\"off\")", "code_tokens": "def show ( self , imgs , ax = None ) : ax = ax or plt . gca ( ) if type ( imgs ) is not list : imgs = [ imgs ] for i , img in enumerate ( imgs ) : ax . imshow ( img , cmap = plt . get_cmap ( \"plasma\" ) ) ax . axis ( \"off\" )", "docstring_tokens": "Visualize the persistence image", "label": 1}, {"idx": "cosqa-train-889", "doc": "how to combine two data frame with same columns python", "code": "def cross_join(df1, df2):\n    \"\"\"\n    Return a dataframe that is a cross between dataframes\n    df1 and df2\n\n    ref: https://github.com/pydata/pandas/issues/5401\n    \"\"\"\n    if len(df1) == 0:\n        return df2\n\n    if len(df2) == 0:\n        return df1\n\n    # Add as lists so that the new index keeps the items in\n    # the order that they are added together\n    all_columns = pd.Index(list(df1.columns) + list(df2.columns))\n    df1['key'] = 1\n    df2['key'] = 1\n    return pd.merge(df1, df2, on='key').loc[:, all_columns]", "code_tokens": "def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]", "docstring_tokens": "Return a dataframe that is a cross between dataframes df1 and df2", "label": 0}, {"idx": "cosqa-train-890", "doc": "python matrix random select k points", "code": "def downsample(array, k):\n    \"\"\"Choose k random elements of array.\"\"\"\n    length = array.shape[0]\n    indices = random.sample(xrange(length), k)\n    return array[indices]", "code_tokens": "def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]", "docstring_tokens": "Choose k random elements of array .", "label": 0}, {"idx": "cosqa-train-891", "doc": "how to compare file content in python", "code": "def cmp_contents(filename1, filename2):\n    \"\"\" Returns True if contents of the files are the same\n\n    Parameters\n    ----------\n    filename1 : str\n        filename of first file to compare\n    filename2 : str\n        filename of second file to compare\n\n    Returns\n    -------\n    tf : bool\n        True if binary contents of `filename1` is same as binary contents of\n        `filename2`, False otherwise.\n    \"\"\"\n    with open_readable(filename1, 'rb') as fobj:\n        contents1 = fobj.read()\n    with open_readable(filename2, 'rb') as fobj:\n        contents2 = fobj.read()\n    return contents1 == contents2", "code_tokens": "def cmp_contents ( filename1 , filename2 ) : with open_readable ( filename1 , 'rb' ) as fobj : contents1 = fobj . read ( ) with open_readable ( filename2 , 'rb' ) as fobj : contents2 = fobj . read ( ) return contents1 == contents2", "docstring_tokens": "Returns True if contents of the files are the same", "label": 0}, {"idx": "cosqa-train-892", "doc": "python max an min integers", "code": "def _digits(minval, maxval):\n    \"\"\"Digits needed to comforatbly display values in [minval, maxval]\"\"\"\n    if minval == maxval:\n        return 3\n    else:\n        return min(10, max(2, int(1 + abs(np.log10(maxval - minval)))))", "code_tokens": "def _digits ( minval , maxval ) : if minval == maxval : return 3 else : return min ( 10 , max ( 2 , int ( 1 + abs ( np . log10 ( maxval - minval ) ) ) ) )", "docstring_tokens": "Digits needed to comforatbly display values in [ minval maxval ]", "label": 0}, {"idx": "cosqa-train-893", "doc": "how to compare two matrices for accuracy python", "code": "def compare(a, b):\n    \"\"\"\n     Compare items in 2 arrays. Returns sum(abs(a(i)-b(i)))\n    \"\"\"\n    s=0\n    for i in range(len(a)):\n        s=s+abs(a[i]-b[i])\n    return s", "code_tokens": "def compare ( a , b ) : s = 0 for i in range ( len ( a ) ) : s = s + abs ( a [ i ] - b [ i ] ) return s", "docstring_tokens": "Compare items in 2 arrays . Returns sum ( abs ( a ( i ) - b ( i )))", "label": 0}, {"idx": "cosqa-train-894", "doc": "python max length of one line", "code": "def _multiline_width(multiline_s, line_width_fn=len):\n    \"\"\"Visible width of a potentially multiline content.\"\"\"\n    return max(map(line_width_fn, re.split(\"[\\r\\n]\", multiline_s)))", "code_tokens": "def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( \"[\\r\\n]\" , multiline_s ) ) )", "docstring_tokens": "Visible width of a potentially multiline content .", "label": 1}, {"idx": "cosqa-train-895", "doc": "how to compare zip files in python", "code": "def compare(left, right):\n    \"\"\"\n    yields EVENT,ENTRY pairs describing the differences between left\n    and right, which are filenames for a pair of zip files\n    \"\"\"\n\n    with open_zip(left) as l:\n        with open_zip(right) as r:\n            return compare_zips(l, r)", "code_tokens": "def compare ( left , right ) : with open_zip ( left ) as l : with open_zip ( right ) as r : return compare_zips ( l , r )", "docstring_tokens": "yields EVENT ENTRY pairs describing the differences between left and right which are filenames for a pair of zip files", "label": 0}, {"idx": "cosqa-train-896", "doc": "python measure coverage from bash script", "code": "def coverage():\n    \"\"\"Run coverage tests.\"\"\"\n    # Note: coverage options are controlled by .coveragerc file\n    install()\n    test_setup()\n    sh(\"%s -m coverage run %s\" % (PYTHON, TEST_SCRIPT))\n    sh(\"%s -m coverage report\" % PYTHON)\n    sh(\"%s -m coverage html\" % PYTHON)\n    sh(\"%s -m webbrowser -t htmlcov/index.html\" % PYTHON)", "code_tokens": "def coverage ( ) : # Note: coverage options are controlled by .coveragerc file install ( ) test_setup ( ) sh ( \"%s -m coverage run %s\" % ( PYTHON , TEST_SCRIPT ) ) sh ( \"%s -m coverage report\" % PYTHON ) sh ( \"%s -m coverage html\" % PYTHON ) sh ( \"%s -m webbrowser -t htmlcov/index.html\" % PYTHON )", "docstring_tokens": "Run coverage tests .", "label": 0}, {"idx": "cosqa-train-897", "doc": "how to compares if two python dictionaries are equal", "code": "def is_same_dict(d1, d2):\n    \"\"\"Test two dictionary is equal on values. (ignore order)\n    \"\"\"\n    for k, v in d1.items():\n        if isinstance(v, dict):\n            is_same_dict(v, d2[k])\n        else:\n            assert d1[k] == d2[k]\n\n    for k, v in d2.items():\n        if isinstance(v, dict):\n            is_same_dict(v, d1[k])\n        else:\n            assert d1[k] == d2[k]", "code_tokens": "def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]", "docstring_tokens": "Test two dictionary is equal on values . ( ignore order )", "label": 0}, {"idx": "cosqa-train-898", "doc": "python memory usage of a function", "code": "def m(name='', **kwargs):\n    \"\"\"\n    Print out memory usage at this point in time\n\n    http://docs.python.org/2/library/resource.html\n    http://stackoverflow.com/a/15448600/5006\n    http://stackoverflow.com/questions/110259/which-python-memory-profiler-is-recommended\n    \"\"\"\n    with Reflect.context(**kwargs) as r:\n        kwargs[\"name\"] = name\n        instance = M_CLASS(r, stream, **kwargs)\n        instance()", "code_tokens": "def m ( name = '' , * * kwargs ) : with Reflect . context ( * * kwargs ) as r : kwargs [ \"name\" ] = name instance = M_CLASS ( r , stream , * * kwargs ) instance ( )", "docstring_tokens": "Print out memory usage at this point in time", "label": 0}, {"idx": "cosqa-train-899", "doc": "how to compile c++ with python", "code": "def cpp_prog_builder(build_context, target):\n    \"\"\"Build a C++ binary executable\"\"\"\n    yprint(build_context.conf, 'Build CppProg', target)\n    workspace_dir = build_context.get_workspace('CppProg', target.name)\n    build_cpp(build_context, target, target.compiler_config, workspace_dir)", "code_tokens": "def cpp_prog_builder ( build_context , target ) : yprint ( build_context . conf , 'Build CppProg' , target ) workspace_dir = build_context . get_workspace ( 'CppProg' , target . name ) build_cpp ( build_context , target , target . compiler_config , workspace_dir )", "docstring_tokens": "Build a C ++ binary executable", "label": 0}, {"idx": "cosqa-train-900", "doc": "python merge and update dictionaries", "code": "def dictmerge(x, y):\n    \"\"\"\n    merge two dictionaries\n    \"\"\"\n    z = x.copy()\n    z.update(y)\n    return z", "code_tokens": "def dictmerge ( x , y ) : z = x . copy ( ) z . update ( y ) return z", "docstring_tokens": "merge two dictionaries", "label": 0}, {"idx": "cosqa-train-901", "doc": "how to continue from a line to next in python", "code": "def advance_one_line(self):\n    \"\"\"Advances to next line.\"\"\"\n\n    current_line = self._current_token.line_number\n    while current_line == self._current_token.line_number:\n      self._current_token = ConfigParser.Token(*next(self._token_generator))", "code_tokens": "def advance_one_line ( self ) : current_line = self . _current_token . line_number while current_line == self . _current_token . line_number : self . _current_token = ConfigParser . Token ( * next ( self . _token_generator ) )", "docstring_tokens": "Advances to next line .", "label": 0}, {"idx": "cosqa-train-902", "doc": "python merge object not callable", "code": "def merge(self, other):\n        \"\"\" Merge another stats. \"\"\"\n        Stats.merge(self, other)\n        self.changes += other.changes", "code_tokens": "def merge ( self , other ) : Stats . merge ( self , other ) self . changes += other . changes", "docstring_tokens": "Merge another stats .", "label": 0}, {"idx": "cosqa-train-903", "doc": "how to control the display string length python", "code": "def display_len(text):\n    \"\"\"\n    Get the display length of a string. This can differ from the character\n    length if the string contains wide characters.\n    \"\"\"\n    text = unicodedata.normalize('NFD', text)\n    return sum(char_width(char) for char in text)", "code_tokens": "def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )", "docstring_tokens": "Get the display length of a string . This can differ from the character length if the string contains wide characters .", "label": 0}, {"idx": "cosqa-train-904", "doc": "python method wraps instance", "code": "def Proxy(f):\n  \"\"\"A helper to create a proxy method in a class.\"\"\"\n\n  def Wrapped(self, *args):\n    return getattr(self, f)(*args)\n\n  return Wrapped", "code_tokens": "def Proxy ( f ) : def Wrapped ( self , * args ) : return getattr ( self , f ) ( * args ) return Wrapped", "docstring_tokens": "A helper to create a proxy method in a class .", "label": 0}, {"idx": "cosqa-train-905", "doc": "how to conver email message object to string in python", "code": "def _message_to_string(message, data=None):\n    \"\"\" Gives a string representation of a PB2 message. \"\"\"\n    if data is None:\n        data = _json_from_message(message)\n\n    return \"Message {} from {} to {}: {}\".format(\n        message.namespace, message.source_id, message.destination_id, data)", "code_tokens": "def _message_to_string ( message , data = None ) : if data is None : data = _json_from_message ( message ) return \"Message {} from {} to {}: {}\" . format ( message . namespace , message . source_id , message . destination_id , data )", "docstring_tokens": "Gives a string representation of a PB2 message .", "label": 0}, {"idx": "cosqa-train-906", "doc": "python minimum of np matrix", "code": "def fn_min(self, a, axis=None):\n        \"\"\"\n        Return the minimum of an array, ignoring any NaNs.\n\n        :param a: The array.\n        :return: The minimum value of the array.\n        \"\"\"\n\n        return numpy.nanmin(self._to_ndarray(a), axis=axis)", "code_tokens": "def fn_min ( self , a , axis = None ) : return numpy . nanmin ( self . _to_ndarray ( a ) , axis = axis )", "docstring_tokens": "Return the minimum of an array ignoring any NaNs .", "label": 1}, {"idx": "cosqa-train-907", "doc": "how to conver to array python", "code": "def arr_to_vector(arr):\n    \"\"\"Reshape a multidimensional array to a vector.\n    \"\"\"\n    dim = array_dim(arr)\n    tmp_arr = []\n    for n in range(len(dim) - 1):\n        for inner in arr:\n            for i in inner:\n                tmp_arr.append(i)\n        arr = tmp_arr\n        tmp_arr = []\n    return arr", "code_tokens": "def arr_to_vector ( arr ) : dim = array_dim ( arr ) tmp_arr = [ ] for n in range ( len ( dim ) - 1 ) : for inner in arr : for i in inner : tmp_arr . append ( i ) arr = tmp_arr tmp_arr = [ ] return arr", "docstring_tokens": "Reshape a multidimensional array to a vector .", "label": 0}, {"idx": "cosqa-train-908", "doc": "python minmaxscaler with range", "code": "def min_values(args):\n    \"\"\" Return possible range for min function. \"\"\"\n    return Interval(min(x.low for x in args), min(x.high for x in args))", "code_tokens": "def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )", "docstring_tokens": "Return possible range for min function .", "label": 0}, {"idx": "cosqa-train-909", "doc": "how to correct the image of perspective transform using python", "code": "def post_process(self):\n        \"\"\" Apply last 2D transforms\"\"\"\n        self.image.putdata(self.pixels)\n        self.image = self.image.transpose(Image.ROTATE_90)", "code_tokens": "def post_process ( self ) : self . image . putdata ( self . pixels ) self . image = self . image . transpose ( Image . ROTATE_90 )", "docstring_tokens": "Apply last 2D transforms", "label": 0}, {"idx": "cosqa-train-910", "doc": "python mkdir mode examples", "code": "def makedirs(path, mode=0o777, exist_ok=False):\n    \"\"\"A wrapper of os.makedirs().\"\"\"\n    os.makedirs(path, mode, exist_ok)", "code_tokens": "def makedirs ( path , mode = 0o777 , exist_ok = False ) : os . makedirs ( path , mode , exist_ok )", "docstring_tokens": "A wrapper of os . makedirs () .", "label": 0}, {"idx": "cosqa-train-911", "doc": "how to correct typing errors in python", "code": "def autoconvert(string):\n    \"\"\"Try to convert variables into datatypes.\"\"\"\n    for fn in (boolify, int, float):\n        try:\n            return fn(string)\n        except ValueError:\n            pass\n    return string", "code_tokens": "def autoconvert ( string ) : for fn in ( boolify , int , float ) : try : return fn ( string ) except ValueError : pass return string", "docstring_tokens": "Try to convert variables into datatypes .", "label": 0}, {"idx": "cosqa-train-912", "doc": "python mongodb model how to initialize collection from json", "code": "def _from_dict(cls, _dict):\n        \"\"\"Initialize a ListCollectionsResponse object from a json dictionary.\"\"\"\n        args = {}\n        if 'collections' in _dict:\n            args['collections'] = [\n                Collection._from_dict(x) for x in (_dict.get('collections'))\n            ]\n        return cls(**args)", "code_tokens": "def _from_dict ( cls , _dict ) : args = { } if 'collections' in _dict : args [ 'collections' ] = [ Collection . _from_dict ( x ) for x in ( _dict . get ( 'collections' ) ) ] return cls ( * * args )", "docstring_tokens": "Initialize a ListCollectionsResponse object from a json dictionary .", "label": 0}, {"idx": "cosqa-train-913", "doc": "how to count the number of occurences of each unique combination in th list in python", "code": "def most_common(items):\n    \"\"\"\n    Wanted functionality from Counters (new in Python 2.7).\n    \"\"\"\n    counts = {}\n    for i in items:\n        counts.setdefault(i, 0)\n        counts[i] += 1\n    return max(six.iteritems(counts), key=operator.itemgetter(1))", "code_tokens": "def most_common ( items ) : counts = { } for i in items : counts . setdefault ( i , 0 ) counts [ i ] += 1 return max ( six . iteritems ( counts ) , key = operator . itemgetter ( 1 ) )", "docstring_tokens": "Wanted functionality from Counters ( new in Python 2 . 7 ) .", "label": 0}, {"idx": "cosqa-train-914", "doc": "python mongoengine findone object", "code": "def find_one(cls, *args, **kwargs):\n        \"\"\"Run a find_one on this model's collection.  The arguments to\n        ``Model.find_one`` are the same as to ``pymongo.Collection.find_one``.\"\"\"\n        database, collection = cls._collection_key.split('.')\n        return current()[database][collection].find_one(*args, **kwargs)", "code_tokens": "def find_one ( cls , * args , * * kwargs ) : database , collection = cls . _collection_key . split ( '.' ) return current ( ) [ database ] [ collection ] . find_one ( * args , * * kwargs )", "docstring_tokens": "Run a find_one on this model s collection . The arguments to Model . find_one are the same as to pymongo . Collection . find_one .", "label": 0}, {"idx": "cosqa-train-915", "doc": "how to cout the number of indents in a string i python", "code": "def indentsize(line):\n    \"\"\"Return the indent size, in spaces, at the start of a line of text.\"\"\"\n    expline = string.expandtabs(line)\n    return len(expline) - len(string.lstrip(expline))", "code_tokens": "def indentsize ( line ) : expline = string . expandtabs ( line ) return len ( expline ) - len ( string . lstrip ( expline ) )", "docstring_tokens": "Return the indent size in spaces at the start of a line of text .", "label": 0}, {"idx": "cosqa-train-916", "doc": "python most common element in a list", "code": "def mostCommonItem(lst):\n    \"\"\"Choose the most common item from the list, or the first item if all\n    items are unique.\"\"\"\n    # This elegant solution from: http://stackoverflow.com/a/1518632/1760218\n    lst = [l for l in lst if l]\n    if lst:\n        return max(set(lst), key=lst.count)\n    else:\n        return None", "code_tokens": "def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None", "docstring_tokens": "Choose the most common item from the list or the first item if all items are unique .", "label": 0}, {"idx": "cosqa-train-917", "doc": "how to create a concat key in python", "code": "def make_env_key(app_name, key):\n    \"\"\"Creates an environment key-equivalent for the given key\"\"\"\n    key = key.replace('-', '_').replace(' ', '_')\n    return str(\"_\".join((x.upper() for x in (app_name, key))))", "code_tokens": "def make_env_key ( app_name , key ) : key = key . replace ( '-' , '_' ) . replace ( ' ' , '_' ) return str ( \"_\" . join ( ( x . upper ( ) for x in ( app_name , key ) ) ) )", "docstring_tokens": "Creates an environment key - equivalent for the given key", "label": 0}, {"idx": "cosqa-train-918", "doc": "python most frequent element multidimension", "code": "def _gcd_array(X):\n    \"\"\"\n    Return the largest real value h such that all elements in x are integer\n    multiples of h.\n    \"\"\"\n    greatest_common_divisor = 0.0\n    for x in X:\n        greatest_common_divisor = _gcd(greatest_common_divisor, x)\n\n    return greatest_common_divisor", "code_tokens": "def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor", "docstring_tokens": "Return the largest real value h such that all elements in x are integer multiples of h .", "label": 1}, {"idx": "cosqa-train-919", "doc": "how to create a list of prime numbers in python", "code": "def getPrimeFactors(n):\n    \"\"\"\n    Get all the prime factor of given integer\n    @param n integer\n    @return list [1, ..., n]\n    \"\"\"\n    lo = [1]\n    n2 = n // 2\n    k = 2\n    for k in range(2, n2 + 1):\n        if (n // k)*k == n:\n            lo.append(k)\n    return lo + [n, ]", "code_tokens": "def getPrimeFactors ( n ) : lo = [ 1 ] n2 = n // 2 k = 2 for k in range ( 2 , n2 + 1 ) : if ( n // k ) * k == n : lo . append ( k ) return lo + [ n , ]", "docstring_tokens": "Get all the prime factor of given integer", "label": 0}, {"idx": "cosqa-train-920", "doc": "python move cursor to secific line", "code": "def _go_to_line(editor, line):\n    \"\"\"\n    Move cursor to this line in the current buffer.\n    \"\"\"\n    b = editor.application.current_buffer\n    b.cursor_position = b.document.translate_row_col_to_index(max(0, int(line) - 1), 0)", "code_tokens": "def _go_to_line ( editor , line ) : b = editor . application . current_buffer b . cursor_position = b . document . translate_row_col_to_index ( max ( 0 , int ( line ) - 1 ) , 0 )", "docstring_tokens": "Move cursor to this line in the current buffer .", "label": 1}, {"idx": "cosqa-train-921", "doc": "how to create bucket through python scripts", "code": "def touch():\n    \"\"\"Create new bucket.\"\"\"\n    from .models import Bucket\n    bucket = Bucket.create()\n    db.session.commit()\n    click.secho(str(bucket), fg='green')", "code_tokens": "def touch ( ) : from . models import Bucket bucket = Bucket . create ( ) db . session . commit ( ) click . secho ( str ( bucket ) , fg = 'green' )", "docstring_tokens": "Create new bucket .", "label": 1}, {"idx": "cosqa-train-922", "doc": "python move file pointer back", "code": "def align_file_position(f, size):\n    \"\"\" Align the position in the file to the next block of specified size \"\"\"\n    align = (size - 1) - (f.tell() % size)\n    f.seek(align, 1)", "code_tokens": "def align_file_position ( f , size ) : align = ( size - 1 ) - ( f . tell ( ) % size ) f . seek ( align , 1 )", "docstring_tokens": "Align the position in the file to the next block of specified size", "label": 0}, {"idx": "cosqa-train-923", "doc": "how to create cell separator in python", "code": "def format_header_cell(val):\n    \"\"\"\n    Formats given header column. This involves changing '_Px_' to '(', '_xP_' to ')' and\n    all other '_' to spaces.\n    \"\"\"\n    return re.sub('_', ' ', re.sub(r'(_Px_)', '(', re.sub(r'(_xP_)', ')', str(val) )))", "code_tokens": "def format_header_cell ( val ) : return re . sub ( '_' , ' ' , re . sub ( r'(_Px_)' , '(' , re . sub ( r'(_xP_)' , ')' , str ( val ) ) ) )", "docstring_tokens": "Formats given header column . This involves changing _Px_ to ( _xP_ to ) and all other _ to spaces .", "label": 0}, {"idx": "cosqa-train-924", "doc": "python move to next position in a line", "code": "def go_to_line(self, line):\n        \"\"\"\n        Moves the text cursor to given line.\n\n        :param line: Line to go to.\n        :type line: int\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        cursor = self.textCursor()\n        cursor.setPosition(self.document().findBlockByNumber(line - 1).position())\n        self.setTextCursor(cursor)\n        return True", "code_tokens": "def go_to_line ( self , line ) : cursor = self . textCursor ( ) cursor . setPosition ( self . document ( ) . findBlockByNumber ( line - 1 ) . position ( ) ) self . setTextCursor ( cursor ) return True", "docstring_tokens": "Moves the text cursor to given line .", "label": 0}, {"idx": "cosqa-train-925", "doc": "how to create copy of python ordered dictionary", "code": "def copy(self):\n        \"\"\"Return a shallow copy of the sorted dictionary.\"\"\"\n        return self.__class__(self._key, self._load, self._iteritems())", "code_tokens": "def copy ( self ) : return self . __class__ ( self . _key , self . _load , self . _iteritems ( ) )", "docstring_tokens": "Return a shallow copy of the sorted dictionary .", "label": 0}, {"idx": "cosqa-train-926", "doc": "python multi instance singleton", "code": "def singleton(class_):\n    \"\"\"Singleton definition.\n\n    Method 1 from\n    https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python\n    \"\"\"\n    instances = {}\n\n    def get_instance(*args, **kwargs):\n        if class_ not in instances:\n            instances[class_] = class_(*args, **kwargs)\n        return instances[class_]\n    return get_instance", "code_tokens": "def singleton ( class_ ) : instances = { } def get_instance ( * args , * * kwargs ) : if class_ not in instances : instances [ class_ ] = class_ ( * args , * * kwargs ) return instances [ class_ ] return get_instance", "docstring_tokens": "Singleton definition .", "label": 0}, {"idx": "cosqa-train-927", "doc": "how to create dictionary in python from string", "code": "def list_string_to_dict(string):\n    \"\"\"Inputs ``['a', 'b', 'c']``, returns ``{'a': 0, 'b': 1, 'c': 2}``.\"\"\"\n    dictionary = {}\n    for idx, c in enumerate(string):\n        dictionary.update({c: idx})\n    return dictionary", "code_tokens": "def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary", "docstring_tokens": "Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } .", "label": 0}, {"idx": "cosqa-train-928", "doc": "python multiline string and multiline comments", "code": "def _match_space_at_line(line):\n    \"\"\"Return a re.match object if an empty comment was found on line.\"\"\"\n    regex = re.compile(r\"^{0}$\".format(_MDL_COMMENT))\n    return regex.match(line)", "code_tokens": "def _match_space_at_line ( line ) : regex = re . compile ( r\"^{0}$\" . format ( _MDL_COMMENT ) ) return regex . match ( line )", "docstring_tokens": "Return a re . match object if an empty comment was found on line .", "label": 0}, {"idx": "cosqa-train-929", "doc": "how to create soft link in python os", "code": "def create_symlink(source, link_name):\n    \"\"\"\n    Creates symbolic link for either operating system.\n\n    http://stackoverflow.com/questions/6260149/os-symlink-support-in-windows\n    \"\"\"\n    os_symlink = getattr(os, \"symlink\", None)\n    if isinstance(os_symlink, collections.Callable):\n        os_symlink(source, link_name)\n    else:\n        import ctypes\n        csl = ctypes.windll.kernel32.CreateSymbolicLinkW\n        csl.argtypes = (ctypes.c_wchar_p, ctypes.c_wchar_p, ctypes.c_uint32)\n        csl.restype = ctypes.c_ubyte\n        flags = 1 if os.path.isdir(source) else 0\n        if csl(link_name, source, flags) == 0:\n            raise ctypes.WinError()", "code_tokens": "def create_symlink ( source , link_name ) : os_symlink = getattr ( os , \"symlink\" , None ) if isinstance ( os_symlink , collections . Callable ) : os_symlink ( source , link_name ) else : import ctypes csl = ctypes . windll . kernel32 . CreateSymbolicLinkW csl . argtypes = ( ctypes . c_wchar_p , ctypes . c_wchar_p , ctypes . c_uint32 ) csl . restype = ctypes . c_ubyte flags = 1 if os . path . isdir ( source ) else 0 if csl ( link_name , source , flags ) == 0 : raise ctypes . WinError ( )", "docstring_tokens": "Creates symbolic link for either operating system . http : // stackoverflow . com / questions / 6260149 / os - symlink - support - in - windows", "label": 0}, {"idx": "cosqa-train-930", "doc": "python multiline string with comment", "code": "def _comment(string):\n    \"\"\"return string as a comment\"\"\"\n    lines = [line.strip() for line in string.splitlines()]\n    return \"# \" + (\"%s# \" % linesep).join(lines)", "code_tokens": "def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return \"# \" + ( \"%s# \" % linesep ) . join ( lines )", "docstring_tokens": "return string as a comment", "label": 0}, {"idx": "cosqa-train-931", "doc": "how to cuont the number of items produced in python", "code": "def count_generator(generator, memory_efficient=True):\n    \"\"\"Count number of item in generator.\n\n    memory_efficient=True, 3 times slower, but memory_efficient.\n    memory_efficient=False, faster, but cost more memory.\n    \"\"\"\n    if memory_efficient:\n        counter = 0\n        for _ in generator:\n            counter += 1\n        return counter\n    else:\n        return len(list(generator))", "code_tokens": "def count_generator ( generator , memory_efficient = True ) : if memory_efficient : counter = 0 for _ in generator : counter += 1 return counter else : return len ( list ( generator ) )", "docstring_tokens": "Count number of item in generator .", "label": 1}, {"idx": "cosqa-train-932", "doc": "python multiple context managers", "code": "def replace_sys_args(new_args):\n    \"\"\"Temporarily replace sys.argv with current arguments\n\n    Restores sys.argv upon exit of the context manager.\n    \"\"\"\n    # Replace sys.argv arguments\n    # for module import\n    old_args = sys.argv\n    sys.argv = new_args\n    try:\n        yield\n    finally:\n        sys.argv = old_args", "code_tokens": "def replace_sys_args ( new_args ) : # Replace sys.argv arguments # for module import old_args = sys . argv sys . argv = new_args try : yield finally : sys . argv = old_args", "docstring_tokens": "Temporarily replace sys . argv with current arguments", "label": 0}, {"idx": "cosqa-train-933", "doc": "how to define a list of n size in python", "code": "def chunk_list(l, n):\n    \"\"\"Return `n` size lists from a given list `l`\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Return n size lists from a given list l", "label": 0}, {"idx": "cosqa-train-934", "doc": "python multiple context vars", "code": "def export_context(cls, context):\n\t\t\"\"\" Export the specified context to be capable context transferring\n\n\t\t:param context: context to export\n\t\t:return: tuple\n\t\t\"\"\"\n\t\tif context is None:\n\t\t\treturn\n\t\tresult = [(x.context_name(), x.context_value()) for x in context]\n\t\tresult.reverse()\n\t\treturn tuple(result)", "code_tokens": "def export_context ( cls , context ) : if context is None : return result = [ ( x . context_name ( ) , x . context_value ( ) ) for x in context ] result . reverse ( ) return tuple ( result )", "docstring_tokens": "Export the specified context to be capable context transferring", "label": 0}, {"idx": "cosqa-train-935", "doc": "how to define a matrix of random numbers in python", "code": "def generate_matrices(dim = 40):\n  \"\"\"\n  Generates the matrices that positive and negative samples are multiplied\n  with.  The matrix for positive samples is randomly drawn from a uniform\n  distribution, with elements in [-1, 1].  The matrix for negative examples\n  is the sum of the positive matrix with a matrix drawn from a normal\n  distribution with mean 0 variance 1.\n  \"\"\"\n  positive = numpy.random.uniform(-1, 1, (dim, dim))\n  negative = positive + numpy.random.normal(0, 1, (dim, dim))\n  return positive, negative", "code_tokens": "def generate_matrices ( dim = 40 ) : positive = numpy . random . uniform ( - 1 , 1 , ( dim , dim ) ) negative = positive + numpy . random . normal ( 0 , 1 , ( dim , dim ) ) return positive , negative", "docstring_tokens": "Generates the matrices that positive and negative samples are multiplied with . The matrix for positive samples is randomly drawn from a uniform distribution with elements in [ - 1 1 ] . The matrix for negative examples is the sum of the positive matrix with a matrix drawn from a normal distribution with mean 0 variance 1 .", "label": 0}, {"idx": "cosqa-train-936", "doc": "python multiple qr codes from one image", "code": "def qr(self,text):\n        \"\"\" Print QR Code for the provided string \"\"\"\n        qr_code = qrcode.QRCode(version=4, box_size=4, border=1)\n        qr_code.add_data(text)\n        qr_code.make(fit=True)\n        qr_img = qr_code.make_image()\n        im = qr_img._img.convert(\"RGB\")\n        # Convert the RGB image in printable image\n        self._convert_image(im)", "code_tokens": "def qr ( self , text ) : qr_code = qrcode . QRCode ( version = 4 , box_size = 4 , border = 1 ) qr_code . add_data ( text ) qr_code . make ( fit = True ) qr_img = qr_code . make_image ( ) im = qr_img . _img . convert ( \"RGB\" ) # Convert the RGB image in printable image self . _convert_image ( im )", "docstring_tokens": "Print QR Code for the provided string", "label": 0}, {"idx": "cosqa-train-937", "doc": "how to define unichr in python", "code": "def to_unicode_repr( _letter ):\n    \"\"\" helpful in situations where browser/app may recognize Unicode encoding\n        in the \\u0b8e type syntax but not actual unicode glyph/code-point\"\"\"\n    # Python 2-3 compatible\n    return u\"u'\"+ u\"\".join( [ u\"\\\\u%04x\"%ord(l) for l in _letter ] ) + u\"'\"", "code_tokens": "def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u\"u'\" + u\"\" . join ( [ u\"\\\\u%04x\" % ord ( l ) for l in _letter ] ) + u\"'\"", "docstring_tokens": "helpful in situations where browser / app may recognize Unicode encoding in the \\ u0b8e type syntax but not actual unicode glyph / code - point", "label": 0}, {"idx": "cosqa-train-938", "doc": "python multiprocess pool function", "code": "def compute(args):\n    x, y, params = args\n    \"\"\"Callable function for the multiprocessing pool.\"\"\"\n    return x, y, mandelbrot(x, y, params)", "code_tokens": "def compute ( args ) : x , y , params = args return x , y , mandelbrot ( x , y , params )", "docstring_tokens": "Callable function for the multiprocessing pool .", "label": 0}, {"idx": "cosqa-train-939", "doc": "how to delclare a variable global in python", "code": "def clear_global(self):\n        \"\"\"Clear only any cached global data.\n\n        \"\"\"\n        vname = self.varname\n        logger.debug(f'global clearning {vname}')\n        if vname in globals():\n            logger.debug('removing global instance var: {}'.format(vname))\n            del globals()[vname]", "code_tokens": "def clear_global ( self ) : vname = self . varname logger . debug ( f'global clearning {vname}' ) if vname in globals ( ) : logger . debug ( 'removing global instance var: {}' . format ( vname ) ) del globals ( ) [ vname ]", "docstring_tokens": "Clear only any cached global data .", "label": 0}, {"idx": "cosqa-train-940", "doc": "python multiprocessing pool get results while pool is still running", "code": "def get(self):\n        \"\"\"retrieve a result from the pool\n\n        if nothing is already completed when this method is called, it will\n        block until something comes back\n\n        if the pool's function exited via exception, that will come back as\n        a result here as well, but will be re-raised in :meth:`get`.\n\n        .. note::\n            if there is nothing in the pool's output queue when this method is\n            called, it will block until something is ready\n\n        :returns:\n            a return value from one of the function's invocations if it exited\n            normally\n\n        :raises:\n            :class:`PoolClosed` if the pool was closed before a result could be\n            produced for thie call\n\n        :raises: any exception that was raised inside the worker function\n        \"\"\"\n        if self.closed:\n            raise PoolClosed()\n\n        while self._getcount not in self._cache:\n            counter, result = self.outq.get()\n            self._cache[counter] = result\n\n        result, succeeded = self._cache.pop(self._getcount)\n        self._getcount += 1\n\n        if not succeeded:\n            klass, exc, tb = result\n            raise klass, exc, tb\n        return result", "code_tokens": "def get ( self ) : if self . closed : raise PoolClosed ( ) while self . _getcount not in self . _cache : counter , result = self . outq . get ( ) self . _cache [ counter ] = result result , succeeded = self . _cache . pop ( self . _getcount ) self . _getcount += 1 if not succeeded : klass , exc , tb = result raise klass , exc , tb return result", "docstring_tokens": "retrieve a result from the pool", "label": 0}, {"idx": "cosqa-train-941", "doc": "how to deleat all references of an object python'", "code": "def _release(self):\n        \"\"\"Destroy self since closures cannot be called again.\"\"\"\n        del self.funcs\n        del self.variables\n        del self.variable_values\n        del self.satisfied", "code_tokens": "def _release ( self ) : del self . funcs del self . variables del self . variable_values del self . satisfied", "docstring_tokens": "Destroy self since closures cannot be called again .", "label": 0}, {"idx": "cosqa-train-942", "doc": "python multiprocessing pool lock", "code": "def compute_capture(args):\n    x, y, w, h, params = args\n    \"\"\"Callable function for the multiprocessing pool.\"\"\"\n    return x, y, mandelbrot_capture(x, y, w, h, params)", "code_tokens": "def compute_capture ( args ) : x , y , w , h , params = args return x , y , mandelbrot_capture ( x , y , w , h , params )", "docstring_tokens": "Callable function for the multiprocessing pool .", "label": 0}, {"idx": "cosqa-train-943", "doc": "how to delete an entry from the dictionary python", "code": "def __delitem__(self, key):\n        \"\"\"Remove a variable from this dataset.\n        \"\"\"\n        del self._variables[key]\n        self._coord_names.discard(key)", "code_tokens": "def __delitem__ ( self , key ) : del self . _variables [ key ] self . _coord_names . discard ( key )", "docstring_tokens": "Remove a variable from this dataset .", "label": 1}, {"idx": "cosqa-train-944", "doc": "python multiprocessing queue get last", "code": "def get(self):\n        \"\"\"Get the highest priority Processing Block from the queue.\"\"\"\n        with self._mutex:\n            entry = self._queue.pop()\n            del self._block_map[entry[2]]\n            return entry[2]", "code_tokens": "def get ( self ) : with self . _mutex : entry = self . _queue . pop ( ) del self . _block_map [ entry [ 2 ] ] return entry [ 2 ]", "docstring_tokens": "Get the highest priority Processing Block from the queue .", "label": 0}, {"idx": "cosqa-train-945", "doc": "how to delete columns from dataset in python", "code": "def remove_columns(self, data, columns):\n        \"\"\" This method removes columns in data\n\n        :param data: original Pandas dataframe\n        :param columns: list of columns to remove\n        :type data: pandas.DataFrame\n        :type columns: list of strings\n\n        :returns: Pandas dataframe with removed columns\n        :rtype: pandas.DataFrame\n        \"\"\"\n\n        for column in columns:\n            if column in data.columns:\n                data = data.drop(column, axis=1)\n\n        return data", "code_tokens": "def remove_columns ( self , data , columns ) : for column in columns : if column in data . columns : data = data . drop ( column , axis = 1 ) return data", "docstring_tokens": "This method removes columns in data", "label": 0}, {"idx": "cosqa-train-946", "doc": "python multiprocessing synchronize lock", "code": "def _synced(method, self, args, kwargs):\n    \"\"\"Underlying synchronized wrapper.\"\"\"\n    with self._lock:\n        return method(*args, **kwargs)", "code_tokens": "def _synced ( method , self , args , kwargs ) : with self . _lock : return method ( * args , * * kwargs )", "docstring_tokens": "Underlying synchronized wrapper .", "label": 0}, {"idx": "cosqa-train-947", "doc": "how to delete file on python", "code": "def _delete_local(self, filename):\n        \"\"\"Deletes the specified file from the local filesystem.\"\"\"\n\n        if os.path.exists(filename):\n            os.remove(filename)", "code_tokens": "def _delete_local ( self , filename ) : if os . path . exists ( filename ) : os . remove ( filename )", "docstring_tokens": "Deletes the specified file from the local filesystem .", "label": 0}, {"idx": "cosqa-train-948", "doc": "python mysqldb get all tables name", "code": "def get_table_names(connection):\n\t\"\"\"\n\tReturn a list of the table names in the database.\n\t\"\"\"\n\tcursor = connection.cursor()\n\tcursor.execute(\"SELECT name FROM sqlite_master WHERE type == 'table'\")\n\treturn [name for (name,) in cursor]", "code_tokens": "def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( \"SELECT name FROM sqlite_master WHERE type == 'table'\" ) return [ name for ( name , ) in cursor ]", "docstring_tokens": "Return a list of the table names in the database .", "label": 0}, {"idx": "cosqa-train-949", "doc": "how to delete multiple copies in a list python", "code": "def remove_elements(target, indices):\n    \"\"\"Remove multiple elements from a list and return result.\n    This implementation is faster than the alternative below.\n    Also note the creation of a new list to avoid altering the\n    original. We don't have any current use for the original\n    intact list, but may in the future...\"\"\"\n\n    copied = list(target)\n\n    for index in reversed(indices):\n        del copied[index]\n    return copied", "code_tokens": "def remove_elements ( target , indices ) : copied = list ( target ) for index in reversed ( indices ) : del copied [ index ] return copied", "docstring_tokens": "Remove multiple elements from a list and return result . This implementation is faster than the alternative below . Also note the creation of a new list to avoid altering the original . We don t have any current use for the original intact list but may in the future ...", "label": 0}, {"idx": "cosqa-train-950", "doc": "python name of parent window", "code": "def get_window(self): \n        \"\"\"\n        Returns the object's parent window. Returns None if no window found.\n        \"\"\"\n        x = self\n        while not x._parent == None and \\\n              not isinstance(x._parent, Window): \n                  x = x._parent\n        return x._parent", "code_tokens": "def get_window ( self ) : x = self while not x . _parent == None and not isinstance ( x . _parent , Window ) : x = x . _parent return x . _parent", "docstring_tokens": "Returns the object s parent window . Returns None if no window found .", "label": 1}, {"idx": "cosqa-train-951", "doc": "how to delete string in python", "code": "def remove_bad(string):\n    \"\"\"\n    remove problem characters from string\n    \"\"\"\n    remove = [':', ',', '(', ')', ' ', '|', ';', '\\'']\n    for c in remove:\n        string = string.replace(c, '_')\n    return string", "code_tokens": "def remove_bad ( string ) : remove = [ ':' , ',' , '(' , ')' , ' ' , '|' , ';' , '\\'' ] for c in remove : string = string . replace ( c , '_' ) return string", "docstring_tokens": "remove problem characters from string", "label": 0}, {"idx": "cosqa-train-952", "doc": "python navigationtoolbar remove zoom", "code": "def restore_scrollbar_position(self):\n        \"\"\"Restoring scrollbar position after main window is visible\"\"\"\n        scrollbar_pos = self.get_option('scrollbar_position', None)\n        if scrollbar_pos is not None:\n            self.explorer.treewidget.set_scrollbar_position(scrollbar_pos)", "code_tokens": "def restore_scrollbar_position ( self ) : scrollbar_pos = self . get_option ( 'scrollbar_position' , None ) if scrollbar_pos is not None : self . explorer . treewidget . set_scrollbar_position ( scrollbar_pos )", "docstring_tokens": "Restoring scrollbar position after main window is visible", "label": 0}, {"idx": "cosqa-train-953", "doc": "how to delete things in an list in python", "code": "def rm_empty_indices(*args):\n    \"\"\"\n    Remove unwanted list indices. First argument is the list\n    of indices to remove. Other elements are the lists\n    to trim.\n    \"\"\"\n    rm_inds = args[0]\n\n    if not rm_inds:\n        return args[1:]\n\n    keep_inds = [i for i in range(len(args[1])) if i not in rm_inds]\n\n    return [[a[i] for i in keep_inds] for a in args[1:]]", "code_tokens": "def rm_empty_indices ( * args ) : rm_inds = args [ 0 ] if not rm_inds : return args [ 1 : ] keep_inds = [ i for i in range ( len ( args [ 1 ] ) ) if i not in rm_inds ] return [ [ a [ i ] for i in keep_inds ] for a in args [ 1 : ] ]", "docstring_tokens": "Remove unwanted list indices . First argument is the list of indices to remove . Other elements are the lists to trim .", "label": 0}, {"idx": "cosqa-train-954", "doc": "python nearest value in array", "code": "def index_nearest(value, array):\n    \"\"\"\n    expects a _n.array\n    returns the global minimum of (value-array)^2\n    \"\"\"\n\n    a = (array-value)**2\n    return index(a.min(), a)", "code_tokens": "def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )", "docstring_tokens": "expects a _n . array returns the global minimum of ( value - array ) ^2", "label": 0}, {"idx": "cosqa-train-955", "doc": "python networkx remove node", "code": "def remove_node(self, node):\n        \"\"\" Remove a node from this network. \"\"\"\n        if _debug: Network._debug(\"remove_node %r\", node)\n\n        self.nodes.remove(node)\n        node.lan = None", "code_tokens": "def remove_node ( self , node ) : if _debug : Network . _debug ( \"remove_node %r\" , node ) self . nodes . remove ( node ) node . lan = None", "docstring_tokens": "Remove a node from this network .", "label": 0}, {"idx": "cosqa-train-956", "doc": "how to deprecate a function un python", "code": "def deprecate(func):\n  \"\"\" A deprecation warning emmiter as a decorator. \"\"\"\n  @wraps(func)\n  def wrapper(*args, **kwargs):\n    warn(\"Deprecated, this will be removed in the future\", DeprecationWarning)\n    return func(*args, **kwargs)\n  wrapper.__doc__ = \"Deprecated.\\n\" + (wrapper.__doc__ or \"\")\n  return wrapper", "code_tokens": "def deprecate ( func ) : @ wraps ( func ) def wrapper ( * args , * * kwargs ) : warn ( \"Deprecated, this will be removed in the future\" , DeprecationWarning ) return func ( * args , * * kwargs ) wrapper . __doc__ = \"Deprecated.\\n\" + ( wrapper . __doc__ or \"\" ) return wrapper", "docstring_tokens": "A deprecation warning emmiter as a decorator .", "label": 0}, {"idx": "cosqa-train-957", "doc": "python nltk remove stopwords punctuation kaggle", "code": "def wordify(text):\n    \"\"\"Generate a list of words given text, removing punctuation.\n\n    Parameters\n    ----------\n    text : unicode\n        A piece of english text.\n\n    Returns\n    -------\n    words : list\n        List of words.\n    \"\"\"\n    stopset = set(nltk.corpus.stopwords.words('english'))\n    tokens = nltk.WordPunctTokenizer().tokenize(text)\n    return [w for w in tokens if w not in stopset]", "code_tokens": "def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]", "docstring_tokens": "Generate a list of words given text removing punctuation .", "label": 0}, {"idx": "cosqa-train-958", "doc": "how to detect if cmd is running as administrator/has elevated privileges python", "code": "def is_admin(self):\n        \"\"\"Is the user a system administrator\"\"\"\n        return self.role == self.roles.administrator.value and self.state == State.approved", "code_tokens": "def is_admin ( self ) : return self . role == self . roles . administrator . value and self . state == State . approved", "docstring_tokens": "Is the user a system administrator", "label": 0}, {"idx": "cosqa-train-959", "doc": "python no connection could be made because target machine actively thread", "code": "def start_connect(self):\n    \"\"\"Tries to connect to the Heron Server\n\n    ``loop()`` method needs to be called after this.\n    \"\"\"\n    Log.debug(\"In start_connect() of %s\" % self._get_classname())\n    # TODO: specify buffer size, exception handling\n    self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    # when ready, handle_connect is called\n    self._connecting = True\n    self.connect(self.endpoint)", "code_tokens": "def start_connect ( self ) : Log . debug ( \"In start_connect() of %s\" % self . _get_classname ( ) ) # TODO: specify buffer size, exception handling self . create_socket ( socket . AF_INET , socket . SOCK_STREAM ) # when ready, handle_connect is called self . _connecting = True self . connect ( self . endpoint )", "docstring_tokens": "Tries to connect to the Heron Server", "label": 0}, {"idx": "cosqa-train-960", "doc": "how to detect if list in python has no elements", "code": "def contains_empty(features):\n    \"\"\"Check features data are not empty\n\n    :param features: The features data to check.\n    :type features: list of numpy arrays.\n\n    :return: True if one of the array is empty, False else.\n\n    \"\"\"\n    if not features:\n        return True\n    for feature in features:\n        if feature.shape[0] == 0:\n            return True\n    return False", "code_tokens": "def contains_empty ( features ) : if not features : return True for feature in features : if feature . shape [ 0 ] == 0 : return True return False", "docstring_tokens": "Check features data are not empty", "label": 1}, {"idx": "cosqa-train-961", "doc": "python non unique items in a list", "code": "def unique(input_list):\n    \"\"\"\n    Return a list of unique items (similar to set functionality).\n\n    Parameters\n    ----------\n    input_list : list\n        A list containg some items that can occur more than once.\n\n    Returns\n    -------\n    list\n        A list with only unique occurances of an item.\n\n    \"\"\"\n    output = []\n    for item in input_list:\n        if item not in output:\n            output.append(item)\n    return output", "code_tokens": "def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output", "docstring_tokens": "Return a list of unique items ( similar to set functionality ) .", "label": 0}, {"idx": "cosqa-train-962", "doc": "how to detect str in python 3", "code": "def isString(s):\n    \"\"\"Convenience method that works with all 2.x versions of Python\n    to determine whether or not something is stringlike.\"\"\"\n    try:\n        return isinstance(s, unicode) or isinstance(s, basestring)\n    except NameError:\n        return isinstance(s, str)", "code_tokens": "def isString ( s ) : try : return isinstance ( s , unicode ) or isinstance ( s , basestring ) except NameError : return isinstance ( s , str )", "docstring_tokens": "Convenience method that works with all 2 . x versions of Python to determine whether or not something is stringlike .", "label": 0}, {"idx": "cosqa-train-963", "doc": "python normal distribution maximum likelihood estimation", "code": "def lognorm(x, mu, sigma=1.0):\n    \"\"\" Log-normal function from scipy \"\"\"\n    return stats.lognorm(sigma, scale=mu).pdf(x)", "code_tokens": "def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )", "docstring_tokens": "Log - normal function from scipy", "label": 0}, {"idx": "cosqa-train-964", "doc": "how to determine api type python", "code": "def _api_type(self, value):\n        \"\"\"\n        Returns the API type of the given value based on its python type.\n\n        \"\"\"\n        if isinstance(value, six.string_types):\n            return 'string'\n        elif isinstance(value, six.integer_types):\n            return 'integer'\n        elif type(value) is datetime.datetime:\n            return 'date'", "code_tokens": "def _api_type ( self , value ) : if isinstance ( value , six . string_types ) : return 'string' elif isinstance ( value , six . integer_types ) : return 'integer' elif type ( value ) is datetime . datetime : return 'date'", "docstring_tokens": "Returns the API type of the given value based on its python type .", "label": 0}, {"idx": "cosqa-train-965", "doc": "python normalize an image into p0,1]", "code": "def denorm(self,arr):\n        \"\"\"Reverse the normalization done to a batch of images.\n\n        Arguments:\n            arr: of shape/size (N,3,sz,sz)\n        \"\"\"\n        if type(arr) is not np.ndarray: arr = to_np(arr)\n        if len(arr.shape)==3: arr = arr[None]\n        return self.transform.denorm(np.rollaxis(arr,1,4))", "code_tokens": "def denorm ( self , arr ) : if type ( arr ) is not np . ndarray : arr = to_np ( arr ) if len ( arr . shape ) == 3 : arr = arr [ None ] return self . transform . denorm ( np . rollaxis ( arr , 1 , 4 ) )", "docstring_tokens": "Reverse the normalization done to a batch of images .", "label": 0}, {"idx": "cosqa-train-966", "doc": "how to determine if a variable is as sequence in python", "code": "def is_seq(obj):\n    \"\"\"\n    Check if an object is a sequence.\n    \"\"\"\n    return (not is_str(obj) and not is_dict(obj) and\n            (hasattr(obj, \"__getitem__\") or hasattr(obj, \"__iter__\")))", "code_tokens": "def is_seq ( obj ) : return ( not is_str ( obj ) and not is_dict ( obj ) and ( hasattr ( obj , \"__getitem__\" ) or hasattr ( obj , \"__iter__\" ) ) )", "docstring_tokens": "Check if an object is a sequence .", "label": 0}, {"idx": "cosqa-train-967", "doc": "python nose skip test", "code": "def isTestCaseDisabled(test_case_class, method_name):\n    \"\"\"\n    I check to see if a method on a TestCase has been disabled via nose's\n    convention for disabling a TestCase.  This makes it so that users can\n    mix nose's parameterized tests with green as a runner.\n    \"\"\"\n    test_method = getattr(test_case_class, method_name)\n    return getattr(test_method, \"__test__\", 'not nose') is False", "code_tokens": "def isTestCaseDisabled ( test_case_class , method_name ) : test_method = getattr ( test_case_class , method_name ) return getattr ( test_method , \"__test__\" , 'not nose' ) is False", "docstring_tokens": "I check to see if a method on a TestCase has been disabled via nose s convention for disabling a TestCase . This makes it so that users can mix nose s parameterized tests with green as a runner .", "label": 0}, {"idx": "cosqa-train-968", "doc": "how to determine number of bins in a histogram python", "code": "def _histplot_bins(column, bins=100):\n    \"\"\"Helper to get bins for histplot.\"\"\"\n    col_min = np.min(column)\n    col_max = np.max(column)\n    return range(col_min, col_max + 2, max((col_max - col_min) // bins, 1))", "code_tokens": "def _histplot_bins ( column , bins = 100 ) : col_min = np . min ( column ) col_max = np . max ( column ) return range ( col_min , col_max + 2 , max ( ( col_max - col_min ) // bins , 1 ) )", "docstring_tokens": "Helper to get bins for histplot .", "label": 1}, {"idx": "cosqa-train-969", "doc": "python not showing up in documents", "code": "def prepare(doc):\n    \"\"\"Sets the caption_found and plot_found variables to False.\"\"\"\n    doc.caption_found = False\n    doc.plot_found = False\n    doc.listings_counter = 0", "code_tokens": "def prepare ( doc ) : doc . caption_found = False doc . plot_found = False doc . listings_counter = 0", "docstring_tokens": "Sets the caption_found and plot_found variables to False .", "label": 1}, {"idx": "cosqa-train-970", "doc": "how to determine the path of a directory in python", "code": "def path_for_import(name):\n    \"\"\"\n    Returns the directory path for the given package or module.\n    \"\"\"\n    return os.path.dirname(os.path.abspath(import_module(name).__file__))", "code_tokens": "def path_for_import ( name ) : return os . path . dirname ( os . path . abspath ( import_module ( name ) . __file__ ) )", "docstring_tokens": "Returns the directory path for the given package or module .", "label": 1}, {"idx": "cosqa-train-971", "doc": "python numpy array as float", "code": "def as_float_array(a):\n    \"\"\"View the quaternion array as an array of floats\n\n    This function is fast (of order 1 microsecond) because no data is\n    copied; the returned quantity is just a \"view\" of the original.\n\n    The output view has one more dimension (of size 4) than the input\n    array, but is otherwise the same shape.\n\n    \"\"\"\n    return np.asarray(a, dtype=np.quaternion).view((np.double, 4))", "code_tokens": "def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )", "docstring_tokens": "View the quaternion array as an array of floats", "label": 1}, {"idx": "cosqa-train-972", "doc": "how to detokenize in python", "code": "def tokenize(string):\n    \"\"\"Match and yield all the tokens of the input string.\"\"\"\n    for match in TOKENS_REGEX.finditer(string):\n        yield Token(match.lastgroup, match.group().strip(), match.span())", "code_tokens": "def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "docstring_tokens": "Match and yield all the tokens of the input string .", "label": 0}, {"idx": "cosqa-train-973", "doc": "python numpy array iterable", "code": "def A(*a):\n    \"\"\"convert iterable object into numpy array\"\"\"\n    return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "code_tokens": "def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]", "docstring_tokens": "convert iterable object into numpy array", "label": 1}, {"idx": "cosqa-train-974", "doc": "how to devide a list into 5 same length lists python", "code": "def chunked(l, n):\n    \"\"\"Chunk one big list into few small lists.\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunked ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Chunk one big list into few small lists .", "label": 0}, {"idx": "cosqa-train-975", "doc": "python numpy array output as type", "code": "def contains_all(self, array):\n        \"\"\"Test if `array` is an array of real numbers.\"\"\"\n        dtype = getattr(array, 'dtype', None)\n        if dtype is None:\n            dtype = np.result_type(*array)\n        return is_real_dtype(dtype)", "code_tokens": "def contains_all ( self , array ) : dtype = getattr ( array , 'dtype' , None ) if dtype is None : dtype = np . result_type ( * array ) return is_real_dtype ( dtype )", "docstring_tokens": "Test if array is an array of real numbers .", "label": 0}, {"idx": "cosqa-train-976", "doc": "how to display an error message and stop the code execution in python", "code": "def quit(self):\n        \"\"\" Exit the program due to user's choices.\n        \"\"\"\n        self.script.LOG.warn(\"Abort due to user choice!\")\n        sys.exit(self.QUIT_RC)", "code_tokens": "def quit ( self ) : self . script . LOG . warn ( \"Abort due to user choice!\" ) sys . exit ( self . QUIT_RC )", "docstring_tokens": "Exit the program due to user s choices .", "label": 0}, {"idx": "cosqa-train-977", "doc": "python numpy generate list from array", "code": "def recarray(self):\n        \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"\n        return numpy.rec.fromrecords(self.records, names=self.names)", "code_tokens": "def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "docstring_tokens": "Returns data as : class : numpy . recarray .", "label": 0}, {"idx": "cosqa-train-978", "doc": "how to display images in a list python", "code": "def print_images(self, *printable_images):\n        \"\"\"\n        This method allows printing several images in one shot. This is useful if the client code does not want the\n        printer to make pause during printing\n        \"\"\"\n        printable_image = reduce(lambda x, y: x.append(y), list(printable_images))\n        self.print_image(printable_image)", "code_tokens": "def print_images ( self , * printable_images ) : printable_image = reduce ( lambda x , y : x . append ( y ) , list ( printable_images ) ) self . print_image ( printable_image )", "docstring_tokens": "This method allows printing several images in one shot . This is useful if the client code does not want the printer to make pause during printing", "label": 0}, {"idx": "cosqa-train-979", "doc": "python numpy get nonzero list", "code": "def ma(self):\n        \"\"\"Represent data as a masked array.\n\n        The array is returned with column-first indexing, i.e. for a data file with\n        columns X Y1 Y2 Y3 ... the array a will be a[0] = X, a[1] = Y1, ... .\n\n        inf and nan are filtered via :func:`numpy.isfinite`.\n        \"\"\"\n        a = self.array\n        return numpy.ma.MaskedArray(a, mask=numpy.logical_not(numpy.isfinite(a)))", "code_tokens": "def ma ( self ) : a = self . array return numpy . ma . MaskedArray ( a , mask = numpy . logical_not ( numpy . isfinite ( a ) ) )", "docstring_tokens": "Represent data as a masked array .", "label": 0}, {"idx": "cosqa-train-980", "doc": "how to divide one tensor with another in python", "code": "def _divide(self, x1, x2, out):\n        \"\"\"Raw pointwise multiplication of two elements.\"\"\"\n        self.tspace._divide(x1.tensor, x2.tensor, out.tensor)", "code_tokens": "def _divide ( self , x1 , x2 , out ) : self . tspace . _divide ( x1 . tensor , x2 . tensor , out . tensor )", "docstring_tokens": "Raw pointwise multiplication of two elements .", "label": 0}, {"idx": "cosqa-train-981", "doc": "python object properties to dict", "code": "def _to_json(self):\n        \"\"\" Gets a dict of this object's properties so that it can be used to send a dump to the client \"\"\"\n        return dict(( (k, v) for k, v in self.__dict__.iteritems() if k != 'server'))", "code_tokens": "def _to_json ( self ) : return dict ( ( ( k , v ) for k , v in self . __dict__ . iteritems ( ) if k != 'server' ) )", "docstring_tokens": "Gets a dict of this object s properties so that it can be used to send a dump to the client", "label": 0}, {"idx": "cosqa-train-982", "doc": "how to do if answer is not python", "code": "def _user_yes_no_query(self, question):\n        \"\"\" Helper asking if the user want to download the file\n\n        Note:\n            Dowloading huge file can take a while\n\n        \"\"\"\n        sys.stdout.write('%s [y/n]\\n' % question)\n        while True:\n            try:\n                return strtobool(raw_input().lower())\n            except ValueError:\n                sys.stdout.write('Please respond with \\'y\\' or \\'n\\'.\\n')", "code_tokens": "def _user_yes_no_query ( self , question ) : sys . stdout . write ( '%s [y/n]\\n' % question ) while True : try : return strtobool ( raw_input ( ) . lower ( ) ) except ValueError : sys . stdout . write ( 'Please respond with \\'y\\' or \\'n\\'.\\n' )", "docstring_tokens": "Helper asking if the user want to download the file", "label": 0}, {"idx": "cosqa-train-983", "doc": "python object with datetime to json", "code": "def json_datetime_serial(obj):\n    \"\"\"JSON serializer for objects not serializable by default json code\"\"\"\n    if isinstance(obj, (datetime, date)):\n        serial = obj.isoformat()\n        return serial\n\n    if ObjectId is not None and isinstance(obj, ObjectId):\n        # TODO: try to use bson.json_util instead\n        return str(obj)\n\n    raise TypeError(\"Type not serializable\")", "code_tokens": "def json_datetime_serial ( obj ) : if isinstance ( obj , ( datetime , date ) ) : serial = obj . isoformat ( ) return serial if ObjectId is not None and isinstance ( obj , ObjectId ) : # TODO: try to use bson.json_util instead return str ( obj ) raise TypeError ( \"Type not serializable\" )", "docstring_tokens": "JSON serializer for objects not serializable by default json code", "label": 0}, {"idx": "cosqa-train-984", "doc": "how to do lower case function in python", "code": "def downcaseTokens(s,l,t):\n    \"\"\"Helper parse action to convert tokens to lower case.\"\"\"\n    return [ tt.lower() for tt in map(_ustr,t) ]", "code_tokens": "def downcaseTokens ( s , l , t ) : return [ tt . lower ( ) for tt in map ( _ustr , t ) ]", "docstring_tokens": "Helper parse action to convert tokens to lower case .", "label": 0}, {"idx": "cosqa-train-985", "doc": "python onehotencoding for categorical variables", "code": "def to_one_hot(dataY):\n    \"\"\"Convert the vector of labels dataY into one-hot encoding.\n\n    :param dataY: vector of labels\n    :return: one-hot encoded labels\n    \"\"\"\n    nc = 1 + np.max(dataY)\n    onehot = [np.zeros(nc, dtype=np.int8) for _ in dataY]\n    for i, j in enumerate(dataY):\n        onehot[i][j] = 1\n    return onehot", "code_tokens": "def to_one_hot ( dataY ) : nc = 1 + np . max ( dataY ) onehot = [ np . zeros ( nc , dtype = np . int8 ) for _ in dataY ] for i , j in enumerate ( dataY ) : onehot [ i ] [ j ] = 1 return onehot", "docstring_tokens": "Convert the vector of labels dataY into one - hot encoding .", "label": 0}, {"idx": "cosqa-train-986", "doc": "how to do python syntax check run in spyder", "code": "def matrix_at_check(self, original, loc, tokens):\n        \"\"\"Check for Python 3.5 matrix multiplication.\"\"\"\n        return self.check_py(\"35\", \"matrix multiplication\", original, loc, tokens)", "code_tokens": "def matrix_at_check ( self , original , loc , tokens ) : return self . check_py ( \"35\" , \"matrix multiplication\" , original , loc , tokens )", "docstring_tokens": "Check for Python 3 . 5 matrix multiplication .", "label": 0}, {"idx": "cosqa-train-987", "doc": "python only list files with specific extension", "code": "def glob_by_extensions(directory, extensions):\n    \"\"\" Returns files matched by all extensions in the extensions list \"\"\"\n    directorycheck(directory)\n    files = []\n    xt = files.extend\n    for ex in extensions:\n        xt(glob.glob('{0}/*.{1}'.format(directory, ex)))\n    return files", "code_tokens": "def glob_by_extensions ( directory , extensions ) : directorycheck ( directory ) files = [ ] xt = files . extend for ex in extensions : xt ( glob . glob ( '{0}/*.{1}' . format ( directory , ex ) ) ) return files", "docstring_tokens": "Returns files matched by all extensions in the extensions list", "label": 1}, {"idx": "cosqa-train-988", "doc": "how to do string comparison in python", "code": "def is_equal_strings_ignore_case(first, second):\n    \"\"\"The function compares strings ignoring case\"\"\"\n    if first and second:\n        return first.upper() == second.upper()\n    else:\n        return not (first or second)", "code_tokens": "def is_equal_strings_ignore_case ( first , second ) : if first and second : return first . upper ( ) == second . upper ( ) else : return not ( first or second )", "docstring_tokens": "The function compares strings ignoring case", "label": 0}, {"idx": "cosqa-train-989", "doc": "python only make property setter", "code": "def _fix_up(self, cls, code_name):\n    \"\"\"Internal helper called to tell the property its name.\n\n    This is called by _fix_up_properties() which is called by\n    MetaModel when finishing the construction of a Model subclass.\n    The name passed in is the name of the class attribute to which the\n    Property is assigned (a.k.a. the code name).  Note that this means\n    that each Property instance must be assigned to (at most) one\n    class attribute.  E.g. to declare three strings, you must call\n    StringProperty() three times, you cannot write\n\n      foo = bar = baz = StringProperty()\n    \"\"\"\n    self._code_name = code_name\n    if self._name is None:\n      self._name = code_name", "code_tokens": "def _fix_up ( self , cls , code_name ) : self . _code_name = code_name if self . _name is None : self . _name = code_name", "docstring_tokens": "Internal helper called to tell the property its name .", "label": 0}, {"idx": "cosqa-train-990", "doc": "how to dot two vectors in python", "code": "def dot_v3(v, w):\n    \"\"\"Return the dotproduct of two vectors.\"\"\"\n\n    return sum([x * y for x, y in zip(v, w)])", "code_tokens": "def dot_v3 ( v , w ) : return sum ( [ x * y for x , y in zip ( v , w ) ] )", "docstring_tokens": "Return the dotproduct of two vectors .", "label": 0}, {"idx": "cosqa-train-991", "doc": "python only update dict with values not present", "code": "def dict_update_newkeys(dict_, dict2):\n    \"\"\" Like dict.update, but does not overwrite items \"\"\"\n    for key, val in six.iteritems(dict2):\n        if key not in dict_:\n            dict_[key] = val", "code_tokens": "def dict_update_newkeys ( dict_ , dict2 ) : for key , val in six . iteritems ( dict2 ) : if key not in dict_ : dict_ [ key ] = val", "docstring_tokens": "Like dict . update but does not overwrite items", "label": 0}, {"idx": "cosqa-train-992", "doc": "how to download a json file in python", "code": "def download_json(local_filename, url, clobber=False):\n    \"\"\"Download the given JSON file, and pretty-print before we output it.\"\"\"\n    with open(local_filename, 'w') as json_file:\n        json_file.write(json.dumps(requests.get(url).json(), sort_keys=True, indent=2, separators=(',', ': ')))", "code_tokens": "def download_json ( local_filename , url , clobber = False ) : with open ( local_filename , 'w' ) as json_file : json_file . write ( json . dumps ( requests . get ( url ) . json ( ) , sort_keys = True , indent = 2 , separators = ( ',' , ': ' ) ) )", "docstring_tokens": "Download the given JSON file and pretty - print before we output it .", "label": 0}, {"idx": "cosqa-train-993", "doc": "python open cv image dimension", "code": "def read_img(path):\n    \"\"\" Reads image specified by path into numpy.ndarray\"\"\"\n    img = cv2.resize(cv2.imread(path, 0), (80, 30)).astype(np.float32) / 255\n    img = np.expand_dims(img.transpose(1, 0), 0)\n    return img", "code_tokens": "def read_img ( path ) : img = cv2 . resize ( cv2 . imread ( path , 0 ) , ( 80 , 30 ) ) . astype ( np . float32 ) / 255 img = np . expand_dims ( img . transpose ( 1 , 0 ) , 0 ) return img", "docstring_tokens": "Reads image specified by path into numpy . ndarray", "label": 0}, {"idx": "cosqa-train-994", "doc": "how to download a json in python", "code": "def download_json(local_filename, url, clobber=False):\n    \"\"\"Download the given JSON file, and pretty-print before we output it.\"\"\"\n    with open(local_filename, 'w') as json_file:\n        json_file.write(json.dumps(requests.get(url).json(), sort_keys=True, indent=2, separators=(',', ': ')))", "code_tokens": "def download_json ( local_filename , url , clobber = False ) : with open ( local_filename , 'w' ) as json_file : json_file . write ( json . dumps ( requests . get ( url ) . json ( ) , sort_keys = True , indent = 2 , separators = ( ',' , ': ' ) ) )", "docstring_tokens": "Download the given JSON file and pretty - print before we output it .", "label": 0}, {"idx": "cosqa-train-995", "doc": "python open file as raw string", "code": "def file_to_str(fname):\n    \"\"\"\n    Read a file into a string\n    PRE: fname is a small file (to avoid hogging memory and its discontents)\n    \"\"\"\n    data = None\n    # rU = read with Universal line terminator\n    with open(fname, 'rU') as fd:\n        data = fd.read()\n    return data", "code_tokens": "def file_to_str ( fname ) : data = None # rU = read with Universal line terminator with open ( fname , 'rU' ) as fd : data = fd . read ( ) return data", "docstring_tokens": "Read a file into a string PRE : fname is a small file ( to avoid hogging memory and its discontents )", "label": 0}, {"idx": "cosqa-train-996", "doc": "how to download requests python 3", "code": "def _download_py3(link, path, __hdr__):\n    \"\"\"Download a file from a link in Python 3.\"\"\"\n    try:\n        req = urllib.request.Request(link, headers=__hdr__)\n        u = urllib.request.urlopen(req)\n    except Exception as e:\n        raise Exception(' Download failed with the error:\\n{}'.format(e))\n\n    with open(path, 'wb') as outf:\n        for l in u:\n            outf.write(l)\n    u.close()", "code_tokens": "def _download_py3 ( link , path , __hdr__ ) : try : req = urllib . request . Request ( link , headers = __hdr__ ) u = urllib . request . urlopen ( req ) except Exception as e : raise Exception ( ' Download failed with the error:\\n{}' . format ( e ) ) with open ( path , 'wb' ) as outf : for l in u : outf . write ( l ) u . close ( )", "docstring_tokens": "Download a file from a link in Python 3 .", "label": 0}, {"idx": "cosqa-train-997", "doc": "python open symbolic link on windows", "code": "def create_symlink(source, link_name):\n    \"\"\"\n    Creates symbolic link for either operating system.\n\n    http://stackoverflow.com/questions/6260149/os-symlink-support-in-windows\n    \"\"\"\n    os_symlink = getattr(os, \"symlink\", None)\n    if isinstance(os_symlink, collections.Callable):\n        os_symlink(source, link_name)\n    else:\n        import ctypes\n        csl = ctypes.windll.kernel32.CreateSymbolicLinkW\n        csl.argtypes = (ctypes.c_wchar_p, ctypes.c_wchar_p, ctypes.c_uint32)\n        csl.restype = ctypes.c_ubyte\n        flags = 1 if os.path.isdir(source) else 0\n        if csl(link_name, source, flags) == 0:\n            raise ctypes.WinError()", "code_tokens": "def create_symlink ( source , link_name ) : os_symlink = getattr ( os , \"symlink\" , None ) if isinstance ( os_symlink , collections . Callable ) : os_symlink ( source , link_name ) else : import ctypes csl = ctypes . windll . kernel32 . CreateSymbolicLinkW csl . argtypes = ( ctypes . c_wchar_p , ctypes . c_wchar_p , ctypes . c_uint32 ) csl . restype = ctypes . c_ubyte flags = 1 if os . path . isdir ( source ) else 0 if csl ( link_name , source , flags ) == 0 : raise ctypes . WinError ( )", "docstring_tokens": "Creates symbolic link for either operating system . http : // stackoverflow . com / questions / 6260149 / os - symlink - support - in - windows", "label": 1}, {"idx": "cosqa-train-998", "doc": "how to draw dot in python", "code": "def to_dotfile(self):\n        \"\"\" Writes a DOT graphviz file of the domain structure, and returns the filename\"\"\"\n        domain = self.get_domain()\n        filename = \"%s.dot\" % (self.__class__.__name__)\n        nx.write_dot(domain, filename)\n        return filename", "code_tokens": "def to_dotfile ( self ) : domain = self . get_domain ( ) filename = \"%s.dot\" % ( self . __class__ . __name__ ) nx . write_dot ( domain , filename ) return filename", "docstring_tokens": "Writes a DOT graphviz file of the domain structure and returns the filename", "label": 0}, {"idx": "cosqa-train-999", "doc": "python openpyxl open workbook and keep visible", "code": "def _openpyxl_read_xl(xl_path: str):\n    \"\"\" Use openpyxl to read an Excel file. \"\"\"\n    try:\n        wb = load_workbook(filename=xl_path, read_only=True)\n    except:\n        raise\n    else:\n        return wb", "code_tokens": "def _openpyxl_read_xl ( xl_path : str ) : try : wb = load_workbook ( filename = xl_path , read_only = True ) except : raise else : return wb", "docstring_tokens": "Use openpyxl to read an Excel file .", "label": 0}, {"idx": "cosqa-train-1000", "doc": "python order based on lookup", "code": "def get_order(self, codes):\n        \"\"\"Return evidence codes in order shown in code2name.\"\"\"\n        return sorted(codes, key=lambda e: [self.ev2idx.get(e)])", "code_tokens": "def get_order ( self , codes ) : return sorted ( codes , key = lambda e : [ self . ev2idx . get ( e ) ] )", "docstring_tokens": "Return evidence codes in order shown in code2name .", "label": 0}, {"idx": "cosqa-train-1001", "doc": "how to ecept upper and lower case in python", "code": "def upcaseTokens(s,l,t):\n    \"\"\"Helper parse action to convert tokens to upper case.\"\"\"\n    return [ tt.upper() for tt in map(_ustr,t) ]", "code_tokens": "def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]", "docstring_tokens": "Helper parse action to convert tokens to upper case .", "label": 0}, {"idx": "cosqa-train-1002", "doc": "python ordereddict values to numpy array", "code": "def C_dict2array(C):\n    \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"\n    return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "code_tokens": "def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )", "docstring_tokens": "Convert an OrderedDict containing C values to a 1D array .", "label": 0}, {"idx": "cosqa-train-1003", "doc": "how to eliminate duplicates from a list in python", "code": "def remove_duplicates(lst):\n    \"\"\"\n    Emulate what a Python ``set()`` does, but keeping the element's order.\n    \"\"\"\n    dset = set()\n    return [l for l in lst if l not in dset and not dset.add(l)]", "code_tokens": "def remove_duplicates ( lst ) : dset = set ( ) return [ l for l in lst if l not in dset and not dset . add ( l ) ]", "docstring_tokens": "Emulate what a Python set () does but keeping the element s order .", "label": 0}, {"idx": "cosqa-train-1004", "doc": "python os path normalize", "code": "def normalize_path(path):\n    \"\"\"\n    Convert a path to its canonical, case-normalized, absolute version.\n\n    \"\"\"\n    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))", "code_tokens": "def normalize_path ( path ) : return os . path . normcase ( os . path . realpath ( os . path . expanduser ( path ) ) )", "docstring_tokens": "Convert a path to its canonical case - normalized absolute version .", "label": 0}, {"idx": "cosqa-train-1005", "doc": "how to evaluate sin in degrees python", "code": "def haversine(x):\n    \"\"\"Return the haversine of an angle\n\n    haversine(x) = sin(x/2)**2, where x is an angle in radians\n    \"\"\"\n    y = .5*x\n    y = np.sin(y)\n    return y*y", "code_tokens": "def haversine ( x ) : y = .5 * x y = np . sin ( y ) return y * y", "docstring_tokens": "Return the haversine of an angle", "label": 0}, {"idx": "cosqa-train-1006", "doc": "python out of range float values are not json compliant", "code": "def __get_float(section, name):\n    \"\"\"Get the forecasted float from json section.\"\"\"\n    try:\n        return float(section[name])\n    except (ValueError, TypeError, KeyError):\n        return float(0)", "code_tokens": "def __get_float ( section , name ) : try : return float ( section [ name ] ) except ( ValueError , TypeError , KeyError ) : return float ( 0 )", "docstring_tokens": "Get the forecasted float from json section .", "label": 1}, {"idx": "cosqa-train-1007", "doc": "how to exclude values from range function python 3", "code": "def min_values(args):\n    \"\"\" Return possible range for min function. \"\"\"\n    return Interval(min(x.low for x in args), min(x.high for x in args))", "code_tokens": "def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )", "docstring_tokens": "Return possible range for min function .", "label": 0}, {"idx": "cosqa-train-1008", "doc": "how to explicitly close a port in python", "code": "def close(self):\n        \"\"\"Close port.\"\"\"\n        os.close(self.in_d)\n        os.close(self.out_d)", "code_tokens": "def close ( self ) : os . close ( self . in_d ) os . close ( self . out_d )", "docstring_tokens": "Close port .", "label": 0}, {"idx": "cosqa-train-1009", "doc": "python pages that scrap a pdf file", "code": "def resources(self):\n        \"\"\"Retrieve contents of each page of PDF\"\"\"\n        return [self.pdf.getPage(i) for i in range(self.pdf.getNumPages())]", "code_tokens": "def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "docstring_tokens": "Retrieve contents of each page of PDF", "label": 0}, {"idx": "cosqa-train-1010", "doc": "how to extract keywords for a given text in python", "code": "def extract_keywords_from_text(self, text):\n        \"\"\"Method to extract keywords from the text provided.\n\n        :param text: Text to extract keywords from, provided as a string.\n        \"\"\"\n        sentences = nltk.tokenize.sent_tokenize(text)\n        self.extract_keywords_from_sentences(sentences)", "code_tokens": "def extract_keywords_from_text ( self , text ) : sentences = nltk . tokenize . sent_tokenize ( text ) self . extract_keywords_from_sentences ( sentences )", "docstring_tokens": "Method to extract keywords from the text provided .", "label": 0}, {"idx": "cosqa-train-1011", "doc": "python parse a string into a datetime object", "code": "def deserialize_date(string):\n    \"\"\"\n    Deserializes string to date.\n\n    :param string: str.\n    :type string: str\n    :return: date.\n    :rtype: date\n    \"\"\"\n    try:\n        from dateutil.parser import parse\n        return parse(string).date()\n    except ImportError:\n        return string", "code_tokens": "def deserialize_date ( string ) : try : from dateutil . parser import parse return parse ( string ) . date ( ) except ImportError : return string", "docstring_tokens": "Deserializes string to date .", "label": 0}, {"idx": "cosqa-train-1012", "doc": "how to fetch the contents of a webpage using requests in python", "code": "def get_soup(page=''):\n    \"\"\"\n    Returns a bs4 object of the page requested\n    \"\"\"\n    content = requests.get('%s/%s' % (BASE_URL, page)).text\n    return BeautifulSoup(content)", "code_tokens": "def get_soup ( page = '' ) : content = requests . get ( '%s/%s' % ( BASE_URL , page ) ) . text return BeautifulSoup ( content )", "docstring_tokens": "Returns a bs4 object of the page requested", "label": 0}, {"idx": "cosqa-train-1013", "doc": "python parse date string to date object", "code": "def parse_date(s):\n    \"\"\"\n    Parse a date using dateutil.parser.parse if available,\n    falling back to datetime.datetime.strptime if not\n    \"\"\"\n    if isinstance(s, (datetime.datetime, datetime.date)):\n        return s\n    try:\n        from dateutil.parser import parse\n    except ImportError:\n        parse = lambda d: datetime.datetime.strptime(d, \"%Y-%m-%d\")\n    return parse(s)", "code_tokens": "def parse_date ( s ) : if isinstance ( s , ( datetime . datetime , datetime . date ) ) : return s try : from dateutil . parser import parse except ImportError : parse = lambda d : datetime . datetime . strptime ( d , \"%Y-%m-%d\" ) return parse ( s )", "docstring_tokens": "Parse a date using dateutil . parser . parse if available falling back to datetime . datetime . strptime if not", "label": 0}, {"idx": "cosqa-train-1014", "doc": "how to fill in null values in python fillna", "code": "def clean_dataframe(df):\n    \"\"\"Fill NaNs with the previous value, the next value or if all are NaN then 1.0\"\"\"\n    df = df.fillna(method='ffill')\n    df = df.fillna(0.0)\n    return df", "code_tokens": "def clean_dataframe ( df ) : df = df . fillna ( method = 'ffill' ) df = df . fillna ( 0.0 ) return df", "docstring_tokens": "Fill NaNs with the previous value the next value or if all are NaN then 1 . 0", "label": 0}, {"idx": "cosqa-train-1015", "doc": "python pass a synchronized object", "code": "def _synced(method, self, args, kwargs):\n    \"\"\"Underlying synchronized wrapper.\"\"\"\n    with self._lock:\n        return method(*args, **kwargs)", "code_tokens": "def _synced ( method , self , args , kwargs ) : with self . _lock : return method ( * args , * * kwargs )", "docstring_tokens": "Underlying synchronized wrapper .", "label": 0}, {"idx": "cosqa-train-1016", "doc": "how to finda substring after certain index in python", "code": "def fsliceafter(astr, sub):\n    \"\"\"Return the slice after at sub in string astr\"\"\"\n    findex = astr.find(sub)\n    return astr[findex + len(sub):]", "code_tokens": "def fsliceafter ( astr , sub ) : findex = astr . find ( sub ) return astr [ findex + len ( sub ) : ]", "docstring_tokens": "Return the slice after at sub in string astr", "label": 0}, {"idx": "cosqa-train-1017", "doc": "python pass function to map", "code": "def map_wrap(f):\n    \"\"\"Wrap standard function to easily pass into 'map' processing.\n    \"\"\"\n    @functools.wraps(f)\n    def wrapper(*args, **kwargs):\n        return f(*args, **kwargs)\n    return wrapper", "code_tokens": "def map_wrap ( f ) : @ functools . wraps ( f ) def wrapper ( * args , * * kwargs ) : return f ( * args , * * kwargs ) return wrapper", "docstring_tokens": "Wrap standard function to easily pass into map processing .", "label": 0}, {"idx": "cosqa-train-1018", "doc": "how to flat a list python", "code": "def flatten(l, types=(list, float)):\n    \"\"\"\n    Flat nested list of lists into a single list.\n    \"\"\"\n    l = [item if isinstance(item, types) else [item] for item in l]\n    return [item for sublist in l for item in sublist]", "code_tokens": "def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Flat nested list of lists into a single list .", "label": 0}, {"idx": "cosqa-train-1019", "doc": "python pass list to format", "code": "def list_formatter(handler, item, value):\n    \"\"\"Format list.\"\"\"\n    return u', '.join(str(v) for v in value)", "code_tokens": "def list_formatter ( handler , item , value ) : return u', ' . join ( str ( v ) for v in value )", "docstring_tokens": "Format list .", "label": 1}, {"idx": "cosqa-train-1020", "doc": "python pass method name for logger", "code": "def debug(self, text):\n\t\t\"\"\" Ajout d'un message de log de type DEBUG \"\"\"\n\t\tself.logger.debug(\"{}{}\".format(self.message_prefix, text))", "code_tokens": "def debug ( self , text ) : self . logger . debug ( \"{}{}\" . format ( self . message_prefix , text ) )", "docstring_tokens": "Ajout d un message de log de type DEBUG", "label": 0}, {"idx": "cosqa-train-1021", "doc": "how to force python to integers", "code": "def safe_int_conv(number):\n    \"\"\"Safely convert a single number to integer.\"\"\"\n    try:\n        return int(np.array(number).astype(int, casting='safe'))\n    except TypeError:\n        raise ValueError('cannot safely convert {} to integer'.format(number))", "code_tokens": "def safe_int_conv ( number ) : try : return int ( np . array ( number ) . astype ( int , casting = 'safe' ) ) except TypeError : raise ValueError ( 'cannot safely convert {} to integer' . format ( number ) )", "docstring_tokens": "Safely convert a single number to integer .", "label": 0}, {"idx": "cosqa-train-1022", "doc": "python passing a string with quotes", "code": "def quote(self, s):\n        \"\"\"Return a shell-escaped version of the string s.\"\"\"\n\n        if six.PY2:\n            from pipes import quote\n        else:\n            from shlex import quote\n\n        return quote(s)", "code_tokens": "def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )", "docstring_tokens": "Return a shell - escaped version of the string s .", "label": 0}, {"idx": "cosqa-train-1023", "doc": "how to force python to return an integer", "code": "def safe_int_conv(number):\n    \"\"\"Safely convert a single number to integer.\"\"\"\n    try:\n        return int(np.array(number).astype(int, casting='safe'))\n    except TypeError:\n        raise ValueError('cannot safely convert {} to integer'.format(number))", "code_tokens": "def safe_int_conv ( number ) : try : return int ( np . array ( number ) . astype ( int , casting = 'safe' ) ) except TypeError : raise ValueError ( 'cannot safely convert {} to integer' . format ( number ) )", "docstring_tokens": "Safely convert a single number to integer .", "label": 0}, {"idx": "cosqa-train-1024", "doc": "python pathlib create directory", "code": "def create_path(path):\n    \"\"\"Creates a absolute path in the file system.\n\n    :param path: The path to be created\n    \"\"\"\n    import os\n    if not os.path.exists(path):\n        os.makedirs(path)", "code_tokens": "def create_path ( path ) : import os if not os . path . exists ( path ) : os . makedirs ( path )", "docstring_tokens": "Creates a absolute path in the file system .", "label": 0}, {"idx": "cosqa-train-1025", "doc": "how to fourier transform python", "code": "def translate_fourier(image, dx):\n    \"\"\" Translate an image in fourier-space with plane waves \"\"\"\n    N = image.shape[0]\n\n    f = 2*np.pi*np.fft.fftfreq(N)\n    kx,ky,kz = np.meshgrid(*(f,)*3, indexing='ij')\n    kv = np.array([kx,ky,kz]).T\n\n    q = np.fft.fftn(image)*np.exp(-1.j*(kv*dx).sum(axis=-1)).T\n    return np.real(np.fft.ifftn(q))", "code_tokens": "def translate_fourier ( image , dx ) : N = image . shape [ 0 ] f = 2 * np . pi * np . fft . fftfreq ( N ) kx , ky , kz = np . meshgrid ( * ( f , ) * 3 , indexing = 'ij' ) kv = np . array ( [ kx , ky , kz ] ) . T q = np . fft . fftn ( image ) * np . exp ( - 1.j * ( kv * dx ) . sum ( axis = - 1 ) ) . T return np . real ( np . fft . ifftn ( q ) )", "docstring_tokens": "Translate an image in fourier - space with plane waves", "label": 0}, {"idx": "cosqa-train-1026", "doc": "python pca based on covariance matrix", "code": "def perform_pca(A):\n    \"\"\"\n    Computes eigenvalues and eigenvectors of covariance matrix of A.\n    The rows of a correspond to observations, the columns to variables.\n    \"\"\"\n    # First subtract the mean\n    M = (A-numpy.mean(A.T, axis=1)).T\n    # Get eigenvectors and values of covariance matrix\n    return numpy.linalg.eig(numpy.cov(M))", "code_tokens": "def perform_pca ( A ) : # First subtract the mean M = ( A - numpy . mean ( A . T , axis = 1 ) ) . T # Get eigenvectors and values of covariance matrix return numpy . linalg . eig ( numpy . cov ( M ) )", "docstring_tokens": "Computes eigenvalues and eigenvectors of covariance matrix of A . The rows of a correspond to observations the columns to variables .", "label": 1}, {"idx": "cosqa-train-1027", "doc": "how to fresh the window created in python maya", "code": "def main_func(args=None):\n    \"\"\"Main funcion when executing this module as script\n\n    :param args: commandline arguments\n    :type args: list\n    :returns: None\n    :rtype: None\n    :raises: None\n    \"\"\"\n    # we have to initialize a gui even if we dont need one right now.\n    # as soon as you call maya.standalone.initialize(), a QApplication\n    # with type Tty is created. This is the type for conosle apps.\n    # Because i have not found a way to replace that, we just init the gui.\n    guimain.init_gui()\n\n    main.init()\n    launcher = Launcher()\n    parsed, unknown = launcher.parse_args(args)\n    parsed.func(parsed, unknown)", "code_tokens": "def main_func ( args = None ) : # we have to initialize a gui even if we dont need one right now. # as soon as you call maya.standalone.initialize(), a QApplication # with type Tty is created. This is the type for conosle apps. # Because i have not found a way to replace that, we just init the gui. guimain . init_gui ( ) main . init ( ) launcher = Launcher ( ) parsed , unknown = launcher . parse_args ( args ) parsed . func ( parsed , unknown )", "docstring_tokens": "Main funcion when executing this module as script", "label": 0}, {"idx": "cosqa-train-1028", "doc": "python pdb print stack trace", "code": "def debug_on_error(type, value, tb):\n    \"\"\"Code due to Thomas Heller - published in Python Cookbook (O'Reilley)\"\"\"\n    traceback.print_exc(type, value, tb)\n    print()\n    pdb.pm()", "code_tokens": "def debug_on_error ( type , value , tb ) : traceback . print_exc ( type , value , tb ) print ( ) pdb . pm ( )", "docstring_tokens": "Code due to Thomas Heller - published in Python Cookbook ( O Reilley )", "label": 0}, {"idx": "cosqa-train-1029", "doc": "how to generate random rectangles in python", "code": "def from_rectangle(box):\n        \"\"\" Create a vector randomly within the given rectangle. \"\"\"\n        x = box.left + box.width * random.uniform(0, 1)\n        y = box.bottom + box.height * random.uniform(0, 1)\n        return Vector(x, y)", "code_tokens": "def from_rectangle ( box ) : x = box . left + box . width * random . uniform ( 0 , 1 ) y = box . bottom + box . height * random . uniform ( 0 , 1 ) return Vector ( x , y )", "docstring_tokens": "Create a vector randomly within the given rectangle .", "label": 0}, {"idx": "cosqa-train-1030", "doc": "python pdb set trace", "code": "def set_trace():\n    \"\"\"Start a Pdb instance at the calling frame, with stdout routed to sys.__stdout__.\"\"\"\n    # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py\n    pdb.Pdb(stdout=sys.__stdout__).set_trace(sys._getframe().f_back)", "code_tokens": "def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )", "docstring_tokens": "Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ .", "label": 0}, {"idx": "cosqa-train-1031", "doc": "how to generate unique id for each object in python", "code": "def _remove_duplicates(objects):\n    \"\"\"Removes duplicate objects.\n\n    http://www.peterbe.com/plog/uniqifiers-benchmark.\n    \"\"\"\n    seen, uniq = set(), []\n    for obj in objects:\n        obj_id = id(obj)\n        if obj_id in seen:\n            continue\n        seen.add(obj_id)\n        uniq.append(obj)\n    return uniq", "code_tokens": "def _remove_duplicates ( objects ) : seen , uniq = set ( ) , [ ] for obj in objects : obj_id = id ( obj ) if obj_id in seen : continue seen . add ( obj_id ) uniq . append ( obj ) return uniq", "docstring_tokens": "Removes duplicate objects .", "label": 0}, {"idx": "cosqa-train-1032", "doc": "python pdb stack trace", "code": "def set_trace():\n    \"\"\"Start a Pdb instance at the calling frame, with stdout routed to sys.__stdout__.\"\"\"\n    # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py\n    pdb.Pdb(stdout=sys.__stdout__).set_trace(sys._getframe().f_back)", "code_tokens": "def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )", "docstring_tokens": "Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ .", "label": 0}, {"idx": "cosqa-train-1033", "doc": "how to get a letter displayed as uppercase in python", "code": "def to_camel_case(snake_case_string):\n    \"\"\"\n    Convert a string from snake case to camel case. For example, \"some_var\" would become \"someVar\".\n\n    :param snake_case_string: Snake-cased string to convert to camel case.\n    :returns: Camel-cased version of snake_case_string.\n    \"\"\"\n    parts = snake_case_string.lstrip('_').split('_')\n    return parts[0] + ''.join([i.title() for i in parts[1:]])", "code_tokens": "def to_camel_case ( snake_case_string ) : parts = snake_case_string . lstrip ( '_' ) . split ( '_' ) return parts [ 0 ] + '' . join ( [ i . title ( ) for i in parts [ 1 : ] ] )", "docstring_tokens": "Convert a string from snake case to camel case . For example some_var would become someVar .", "label": 0}, {"idx": "cosqa-train-1034", "doc": "python pdfkit page height in pixels", "code": "def dimensions(self):\n        \"\"\"Get width and height of a PDF\"\"\"\n        size = self.pdf.getPage(0).mediaBox\n        return {'w': float(size[2]), 'h': float(size[3])}", "code_tokens": "def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "docstring_tokens": "Get width and height of a PDF", "label": 0}, {"idx": "cosqa-train-1035", "doc": "how to get a past command history python", "code": "def do_history(self, line):\n        \"\"\"history Display a list of commands that have been entered.\"\"\"\n        self._split_args(line, 0, 0)\n        for idx, item in enumerate(self._history):\n            d1_cli.impl.util.print_info(\"{0: 3d} {1}\".format(idx, item))", "code_tokens": "def do_history ( self , line ) : self . _split_args ( line , 0 , 0 ) for idx , item in enumerate ( self . _history ) : d1_cli . impl . util . print_info ( \"{0: 3d} {1}\" . format ( idx , item ) )", "docstring_tokens": "history Display a list of commands that have been entered .", "label": 0}, {"idx": "cosqa-train-1036", "doc": "python percent sign to character", "code": "def quote(s, unsafe='/'):\n    \"\"\"Pass in a dictionary that has unsafe characters as the keys, and the percent\n    encoded value as the value.\"\"\"\n    res = s.replace('%', '%25')\n    for c in unsafe:\n        res = res.replace(c, '%' + (hex(ord(c)).upper())[2:])\n    return res", "code_tokens": "def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res", "docstring_tokens": "Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value .", "label": 0}, {"idx": "cosqa-train-1037", "doc": "how to get a return from a process python", "code": "def call_out(command):\n  \"\"\"\n  Run the given command (with shell=False) and return a tuple of\n  (int returncode, str output). Strip the output of enclosing whitespace.\n  \"\"\"\n  # start external command process\n  p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n  # get outputs\n  out, _ = p.communicate()\n\n  return p.returncode, out.strip()", "code_tokens": "def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "docstring_tokens": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace .", "label": 0}, {"idx": "cosqa-train-1038", "doc": "python permute a set of booleans", "code": "def visit_BoolOp(self, node):\n        \"\"\" Return type may come from any boolop operand. \"\"\"\n        return sum((self.visit(value) for value in node.values), [])", "code_tokens": "def visit_BoolOp ( self , node ) : return sum ( ( self . visit ( value ) for value in node . values ) , [ ] )", "docstring_tokens": "Return type may come from any boolop operand .", "label": 0}, {"idx": "cosqa-train-1039", "doc": "how to get a summary of linear regression in python", "code": "def linearRegressionAnalysis(series):\n    \"\"\"\n    Returns factor and offset of linear regression function by least\n    squares method.\n\n    \"\"\"\n    n = safeLen(series)\n    sumI = sum([i for i, v in enumerate(series) if v is not None])\n    sumV = sum([v for i, v in enumerate(series) if v is not None])\n    sumII = sum([i * i for i, v in enumerate(series) if v is not None])\n    sumIV = sum([i * v for i, v in enumerate(series) if v is not None])\n    denominator = float(n * sumII - sumI * sumI)\n    if denominator == 0:\n        return None\n    else:\n        factor = (n * sumIV - sumI * sumV) / denominator / series.step\n        offset = sumII * sumV - sumIV * sumI\n        offset = offset / denominator - factor * series.start\n        return factor, offset", "code_tokens": "def linearRegressionAnalysis ( series ) : n = safeLen ( series ) sumI = sum ( [ i for i , v in enumerate ( series ) if v is not None ] ) sumV = sum ( [ v for i , v in enumerate ( series ) if v is not None ] ) sumII = sum ( [ i * i for i , v in enumerate ( series ) if v is not None ] ) sumIV = sum ( [ i * v for i , v in enumerate ( series ) if v is not None ] ) denominator = float ( n * sumII - sumI * sumI ) if denominator == 0 : return None else : factor = ( n * sumIV - sumI * sumV ) / denominator / series . step offset = sumII * sumV - sumIV * sumI offset = offset / denominator - factor * series . start return factor , offset", "docstring_tokens": "Returns factor and offset of linear regression function by least squares method .", "label": 0}, {"idx": "cosqa-train-1040", "doc": "python pil image frombytes", "code": "def from_bytes(cls, b):\n\t\t\"\"\"Create :class:`PNG` from raw bytes.\n\t\t\n\t\t:arg bytes b: The raw bytes of the PNG file.\n\t\t:rtype: :class:`PNG`\n\t\t\"\"\"\n\t\tim = cls()\n\t\tim.chunks = list(parse_chunks(b))\n\t\tim.init()\n\t\treturn im", "code_tokens": "def from_bytes ( cls , b ) : im = cls ( ) im . chunks = list ( parse_chunks ( b ) ) im . init ( ) return im", "docstring_tokens": "Create : class : PNG from raw bytes . : arg bytes b : The raw bytes of the PNG file . : rtype : : class : PNG", "label": 1}, {"idx": "cosqa-train-1041", "doc": "how to get all but last n elements python", "code": "def searchlast(self,n=10):\n        \"\"\"Return the last n results (or possibly less if not found). Note that the last results are not necessarily the best ones! Depending on the search type.\"\"\"            \n        solutions = deque([], n)\n        for solution in self:\n            solutions.append(solution)\n        return solutions", "code_tokens": "def searchlast ( self , n = 10 ) : solutions = deque ( [ ] , n ) for solution in self : solutions . append ( solution ) return solutions", "docstring_tokens": "Return the last n results ( or possibly less if not found ) . Note that the last results are not necessarily the best ones! Depending on the search type .", "label": 0}, {"idx": "cosqa-train-1042", "doc": "python placeholder symble for boolean", "code": "def less_strict_bool(x):\n    \"\"\"Idempotent and None-safe version of strict_bool.\"\"\"\n    if x is None:\n        return False\n    elif x is True or x is False:\n        return x\n    else:\n        return strict_bool(x)", "code_tokens": "def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )", "docstring_tokens": "Idempotent and None - safe version of strict_bool .", "label": 1}, {"idx": "cosqa-train-1043", "doc": "how to get an oauth2 access token from python", "code": "def _get_token(self, oauth_request, token_type='access'):\n        \"\"\"Try to find the token for the provided request token key.\"\"\"\n        token_field = oauth_request.get_parameter('oauth_token')\n        token = self.data_store.lookup_token(token_type, token_field)\n        if not token:\n            raise OAuthError('Invalid %s token: %s' % (token_type, token_field))\n        return token", "code_tokens": "def _get_token ( self , oauth_request , token_type = 'access' ) : token_field = oauth_request . get_parameter ( 'oauth_token' ) token = self . data_store . lookup_token ( token_type , token_field ) if not token : raise OAuthError ( 'Invalid %s token: %s' % ( token_type , token_field ) ) return token", "docstring_tokens": "Try to find the token for the provided request token key .", "label": 0}, {"idx": "cosqa-train-1044", "doc": "python playsound stop sound", "code": "def pause(self):\n        \"\"\"Pause the music\"\"\"\n        mixer.music.pause()\n        self.pause_time = self.get_time()\n        self.paused = True", "code_tokens": "def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True", "docstring_tokens": "Pause the music", "label": 0}, {"idx": "cosqa-train-1045", "doc": "how to get array's minimum in python", "code": "def fn_min(self, a, axis=None):\n        \"\"\"\n        Return the minimum of an array, ignoring any NaNs.\n\n        :param a: The array.\n        :return: The minimum value of the array.\n        \"\"\"\n\n        return numpy.nanmin(self._to_ndarray(a), axis=axis)", "code_tokens": "def fn_min ( self , a , axis = None ) : return numpy . nanmin ( self . _to_ndarray ( a ) , axis = axis )", "docstring_tokens": "Return the minimum of an array ignoring any NaNs .", "label": 0}, {"idx": "cosqa-train-1046", "doc": "python plt dynamic render a image", "code": "def draw_image(self, ax, image):\n        \"\"\"Process a matplotlib image object and call renderer.draw_image\"\"\"\n        self.renderer.draw_image(imdata=utils.image_to_base64(image),\n                                 extent=image.get_extent(),\n                                 coordinates=\"data\",\n                                 style={\"alpha\": image.get_alpha(),\n                                        \"zorder\": image.get_zorder()},\n                                 mplobj=image)", "code_tokens": "def draw_image ( self , ax , image ) : self . renderer . draw_image ( imdata = utils . image_to_base64 ( image ) , extent = image . get_extent ( ) , coordinates = \"data\" , style = { \"alpha\" : image . get_alpha ( ) , \"zorder\" : image . get_zorder ( ) } , mplobj = image )", "docstring_tokens": "Process a matplotlib image object and call renderer . draw_image", "label": 0}, {"idx": "cosqa-train-1047", "doc": "how to get average python for loop", "code": "def average(iterator):\n    \"\"\"Iterative mean.\"\"\"\n    count = 0\n    total = 0\n    for num in iterator:\n        count += 1\n        total += num\n    return float(total)/count", "code_tokens": "def average ( iterator ) : count = 0 total = 0 for num in iterator : count += 1 total += num return float ( total ) / count", "docstring_tokens": "Iterative mean .", "label": 0}, {"idx": "cosqa-train-1048", "doc": "python polar coordinates to vector", "code": "def cart2pol(x, y):\n    \"\"\"Cartesian to Polar coordinates conversion.\"\"\"\n    theta = np.arctan2(y, x)\n    rho = np.hypot(x, y)\n    return theta, rho", "code_tokens": "def cart2pol ( x , y ) : theta = np . arctan2 ( y , x ) rho = np . hypot ( x , y ) return theta , rho", "docstring_tokens": "Cartesian to Polar coordinates conversion .", "label": 0}, {"idx": "cosqa-train-1049", "doc": "python pool map async", "code": "def asyncStarCmap(asyncCallable, iterable):\n    \"\"\"itertools.starmap for deferred callables using cooperative multitasking\n    \"\"\"\n    results = []\n    yield coopStar(asyncCallable, results.append, iterable)\n    returnValue(results)", "code_tokens": "def asyncStarCmap ( asyncCallable , iterable ) : results = [ ] yield coopStar ( asyncCallable , results . append , iterable ) returnValue ( results )", "docstring_tokens": "itertools . starmap for deferred callables using cooperative multitasking", "label": 0}, {"idx": "cosqa-train-1050", "doc": "how to get column names of a data frame python", "code": "def get_obj_cols(df):\n    \"\"\"\n    Returns names of 'object' columns in the DataFrame.\n    \"\"\"\n    obj_cols = []\n    for idx, dt in enumerate(df.dtypes):\n        if dt == 'object' or is_category(dt):\n            obj_cols.append(df.columns.values[idx])\n\n    return obj_cols", "code_tokens": "def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols", "docstring_tokens": "Returns names of object columns in the DataFrame .", "label": 0}, {"idx": "cosqa-train-1051", "doc": "python popen kill process tree", "code": "def _psutil_kill_pid(pid):\n    \"\"\"\n    http://stackoverflow.com/questions/1230669/subprocess-deleting-child-processes-in-windows\n    \"\"\"\n    try:\n        parent = Process(pid)\n        for child in parent.children(recursive=True):\n            child.kill()\n        parent.kill()\n    except NoSuchProcess:\n        return", "code_tokens": "def _psutil_kill_pid ( pid ) : try : parent = Process ( pid ) for child in parent . children ( recursive = True ) : child . kill ( ) parent . kill ( ) except NoSuchProcess : return", "docstring_tokens": "http : // stackoverflow . com / questions / 1230669 / subprocess - deleting - child - processes - in - windows", "label": 0}, {"idx": "cosqa-train-1052", "doc": "how to get column names of df in python", "code": "def get_obj_cols(df):\n    \"\"\"\n    Returns names of 'object' columns in the DataFrame.\n    \"\"\"\n    obj_cols = []\n    for idx, dt in enumerate(df.dtypes):\n        if dt == 'object' or is_category(dt):\n            obj_cols.append(df.columns.values[idx])\n\n    return obj_cols", "code_tokens": "def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols", "docstring_tokens": "Returns names of object columns in the DataFrame .", "label": 1}, {"idx": "cosqa-train-1053", "doc": "python pos and mat to draw a cube", "code": "def paint_cube(self, x, y):\n        \"\"\"\n        Paints a cube at a certain position a color.\n\n        Parameters\n        ----------\n        x: int\n            Horizontal position of the upper left corner of the cube.\n        y: int\n            Vertical position of the upper left corner of the cube.\n\n        \"\"\"\n        # get the color\n        color = self.next_color()\n        # calculate the position\n        cube_pos = [x, y, x + self.cube_size, y + self.cube_size]\n        # draw the cube\n        draw = ImageDraw.Draw(im=self.image)\n        draw.rectangle(xy=cube_pos, fill=color)", "code_tokens": "def paint_cube ( self , x , y ) : # get the color color = self . next_color ( ) # calculate the position cube_pos = [ x , y , x + self . cube_size , y + self . cube_size ] # draw the cube draw = ImageDraw . Draw ( im = self . image ) draw . rectangle ( xy = cube_pos , fill = color )", "docstring_tokens": "Paints a cube at a certain position a color .", "label": 1}, {"idx": "cosqa-train-1054", "doc": "how to get combobox to call method from selected value python", "code": "def onchange(self, value):\n        \"\"\"Called when a new DropDownItem gets selected.\n        \"\"\"\n        log.debug('combo box. selected %s' % value)\n        self.select_by_value(value)\n        return (value, )", "code_tokens": "def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )", "docstring_tokens": "Called when a new DropDownItem gets selected .", "label": 0}, {"idx": "cosqa-train-1055", "doc": "python postfix expression calculator", "code": "def p_postfix_expr(self, p):\n        \"\"\"postfix_expr : left_hand_side_expr\n                        | left_hand_side_expr PLUSPLUS\n                        | left_hand_side_expr MINUSMINUS\n        \"\"\"\n        if len(p) == 2:\n            p[0] = p[1]\n        else:\n            p[0] = ast.UnaryOp(op=p[2], value=p[1], postfix=True)", "code_tokens": "def p_postfix_expr ( self , p ) : if len ( p ) == 2 : p [ 0 ] = p [ 1 ] else : p [ 0 ] = ast . UnaryOp ( op = p [ 2 ] , value = p [ 1 ] , postfix = True )", "docstring_tokens": "postfix_expr : left_hand_side_expr | left_hand_side_expr PLUSPLUS | left_hand_side_expr MINUSMINUS", "label": 0}, {"idx": "cosqa-train-1056", "doc": "how to get data using phantomjs and python", "code": "def phantomjs_retrieve(url, data=None):\n    \"\"\"Retrieve the given URL using PhantomJS.\n    PhantomJS will evaluate all scripts and return the HTML after body.onload.\n    \n    url  - The page URL to retrieve\n    data - The form data. TODO: Currently ignored.\n\n    Returns a status code (e.g. 200) and the HTML as a unicode string.\n    \"\"\"\n    range_limit()\n    print \"pGET\", url\n    process = subprocess.Popen(['phantomjs', PHANTOM_SCRIPT, url], stdout=subprocess.PIPE)\n    out = process.communicate()\n    process.wait()\n    response = out[0].decode('utf-8', 'ignore')\n    status = response[:2]\n    body = response[3:] # After the 'ok ' part.\n    if status == 'ok':\n        return 200, body\n    else:\n        return 404, body", "code_tokens": "def phantomjs_retrieve ( url , data = None ) : range_limit ( ) print \"pGET\" , url process = subprocess . Popen ( [ 'phantomjs' , PHANTOM_SCRIPT , url ] , stdout = subprocess . PIPE ) out = process . communicate ( ) process . wait ( ) response = out [ 0 ] . decode ( 'utf-8' , 'ignore' ) status = response [ : 2 ] body = response [ 3 : ] # After the 'ok ' part. if status == 'ok' : return 200 , body else : return 404 , body", "docstring_tokens": "Retrieve the given URL using PhantomJS . PhantomJS will evaluate all scripts and return the HTML after body . onload . url - The page URL to retrieve data - The form data . TODO : Currently ignored .", "label": 0}, {"idx": "cosqa-train-1057", "doc": "python print contents of oredereddict", "code": "def pprint_for_ordereddict():\n    \"\"\"\n    Context manager that causes pprint() to print OrderedDict objects as nicely\n    as standard Python dictionary objects.\n    \"\"\"\n    od_saved = OrderedDict.__repr__\n    try:\n        OrderedDict.__repr__ = dict.__repr__\n        yield\n    finally:\n        OrderedDict.__repr__ = od_saved", "code_tokens": "def pprint_for_ordereddict ( ) : od_saved = OrderedDict . __repr__ try : OrderedDict . __repr__ = dict . __repr__ yield finally : OrderedDict . __repr__ = od_saved", "docstring_tokens": "Context manager that causes pprint () to print OrderedDict objects as nicely as standard Python dictionary objects .", "label": 1}, {"idx": "cosqa-train-1058", "doc": "how to get dimension from python list", "code": "def get_list_dimensions(_list):\n    \"\"\"\n    Takes a nested list and returns the size of each dimension followed\n    by the element type in the list\n    \"\"\"\n    if isinstance(_list, list) or isinstance(_list, tuple):\n        return [len(_list)] + get_list_dimensions(_list[0])\n    return []", "code_tokens": "def get_list_dimensions ( _list ) : if isinstance ( _list , list ) or isinstance ( _list , tuple ) : return [ len ( _list ) ] + get_list_dimensions ( _list [ 0 ] ) return [ ]", "docstring_tokens": "Takes a nested list and returns the size of each dimension followed by the element type in the list", "label": 0}, {"idx": "cosqa-train-1059", "doc": "python print custom type to string", "code": "def getTypeStr(_type):\n  r\"\"\"Gets the string representation of the given type.\n  \"\"\"\n  if isinstance(_type, CustomType):\n    return str(_type)\n\n  if hasattr(_type, '__name__'):\n    return _type.__name__\n\n  return ''", "code_tokens": "def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''", "docstring_tokens": "r Gets the string representation of the given type .", "label": 0}, {"idx": "cosqa-train-1060", "doc": "how to get elements of a list python slice", "code": "def iget_list_column_slice(list_, start=None, stop=None, stride=None):\n    \"\"\" iterator version of get_list_column \"\"\"\n    if isinstance(start, slice):\n        slice_ = start\n    else:\n        slice_ = slice(start, stop, stride)\n    return (row[slice_] for row in list_)", "code_tokens": "def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )", "docstring_tokens": "iterator version of get_list_column", "label": 0}, {"idx": "cosqa-train-1061", "doc": "python print formatting in fixed length", "code": "def pformat(o, indent=1, width=80, depth=None):\n    \"\"\"Format a Python o into a pretty-printed representation.\"\"\"\n    return PrettyPrinter(indent=indent, width=width, depth=depth).pformat(o)", "code_tokens": "def pformat ( o , indent = 1 , width = 80 , depth = None ) : return PrettyPrinter ( indent = indent , width = width , depth = depth ) . pformat ( o )", "docstring_tokens": "Format a Python o into a pretty - printed representation .", "label": 0}, {"idx": "cosqa-train-1062", "doc": "how to get end quarter dates in python", "code": "def this_quarter():\n        \"\"\" Return start and end date of this quarter. \"\"\"\n        since = TODAY + delta(day=1)\n        while since.month % 3 != 0:\n            since -= delta(months=1)\n        until = since + delta(months=3)\n        return Date(since), Date(until)", "code_tokens": "def this_quarter ( ) : since = TODAY + delta ( day = 1 ) while since . month % 3 != 0 : since -= delta ( months = 1 ) until = since + delta ( months = 3 ) return Date ( since ) , Date ( until )", "docstring_tokens": "Return start and end date of this quarter .", "label": 0}, {"idx": "cosqa-train-1063", "doc": "python print full traceback", "code": "def print_trace(self):\n        \"\"\"\n        Prints stack trace for current exceptions chain.\n        \"\"\"\n        traceback.print_exc()\n        for tb in self.tracebacks:\n            print tb,\n        print ''", "code_tokens": "def print_trace ( self ) : traceback . print_exc ( ) for tb in self . tracebacks : print tb , print ''", "docstring_tokens": "Prints stack trace for current exceptions chain .", "label": 0}, {"idx": "cosqa-train-1064", "doc": "how to get function help in python", "code": "def help_for_command(command):\n    \"\"\"Get the help text (signature + docstring) for a command (function).\"\"\"\n    help_text = pydoc.text.document(command)\n    # remove backspaces\n    return re.subn('.\\\\x08', '', help_text)[0]", "code_tokens": "def help_for_command ( command ) : help_text = pydoc . text . document ( command ) # remove backspaces return re . subn ( '.\\\\x08' , '' , help_text ) [ 0 ]", "docstring_tokens": "Get the help text ( signature + docstring ) for a command ( function ) .", "label": 0}, {"idx": "cosqa-train-1065", "doc": "how to get git to work in python", "code": "def check_git():\n    \"\"\"Check if git command is available.\"\"\"\n    try:\n        with open(os.devnull, \"wb\") as devnull:\n            subprocess.check_call([\"git\", \"--version\"], stdout=devnull, stderr=devnull)\n    except:\n        raise RuntimeError(\"Please make sure git is installed and on your path.\")", "code_tokens": "def check_git ( ) : try : with open ( os . devnull , \"wb\" ) as devnull : subprocess . check_call ( [ \"git\" , \"--version\" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( \"Please make sure git is installed and on your path.\" )", "docstring_tokens": "Check if git command is available .", "label": 0}, {"idx": "cosqa-train-1066", "doc": "python print object to file", "code": "def py(self, output):\n        \"\"\"Output data as a nicely-formatted python data structure\"\"\"\n        import pprint\n        pprint.pprint(output, stream=self.outfile)", "code_tokens": "def py ( self , output ) : import pprint pprint . pprint ( output , stream = self . outfile )", "docstring_tokens": "Output data as a nicely - formatted python data structure", "label": 0}, {"idx": "cosqa-train-1067", "doc": "how to get keys of a table along with values in python", "code": "def get_column_keys_and_names(table):\n    \"\"\"\n    Return a generator of tuples k, c such that k is the name of the python attribute for\n    the column and c is the name of the column in the sql table.\n    \"\"\"\n    ins = inspect(table)\n    return ((k, c.name) for k, c in ins.mapper.c.items())", "code_tokens": "def get_column_keys_and_names ( table ) : ins = inspect ( table ) return ( ( k , c . name ) for k , c in ins . mapper . c . items ( ) )", "docstring_tokens": "Return a generator of tuples k c such that k is the name of the python attribute for the column and c is the name of the column in the sql table .", "label": 1}, {"idx": "cosqa-train-1068", "doc": "python print object to string", "code": "def pretty(obj, verbose=False, max_width=79, newline='\\n'):\n    \"\"\"\n    Pretty print the object's representation.\n    \"\"\"\n    stream = StringIO()\n    printer = RepresentationPrinter(stream, verbose, max_width, newline)\n    printer.pretty(obj)\n    printer.flush()\n    return stream.getvalue()", "code_tokens": "def pretty ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : stream = StringIO ( ) printer = RepresentationPrinter ( stream , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) return stream . getvalue ( )", "docstring_tokens": "Pretty print the object s representation .", "label": 0}, {"idx": "cosqa-train-1069", "doc": "how to get length of file contents using python function", "code": "def file_length(file_obj):\n    \"\"\"\n    Returns the length in bytes of a given file object.\n    Necessary because os.fstat only works on real files and not file-like\n    objects. This works on more types of streams, primarily StringIO.\n    \"\"\"\n    file_obj.seek(0, 2)\n    length = file_obj.tell()\n    file_obj.seek(0)\n    return length", "code_tokens": "def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length", "docstring_tokens": "Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO .", "label": 0}, {"idx": "cosqa-train-1070", "doc": "python print the object", "code": "def prnt(self):\n        \"\"\"\n        Prints DB data representation of the object.\n        \"\"\"\n        print(\"= = = =\\n\\n%s object key: \\033[32m%s\\033[0m\" % (self.__class__.__name__, self.key))\n        pprnt(self._data or self.clean_value())", "code_tokens": "def prnt ( self ) : print ( \"= = = =\\n\\n%s object key: \\033[32m%s\\033[0m\" % ( self . __class__ . __name__ , self . key ) ) pprnt ( self . _data or self . clean_value ( ) )", "docstring_tokens": "Prints DB data representation of the object .", "label": 0}, {"idx": "cosqa-train-1071", "doc": "how to get microseconds in python", "code": "def timestamp_to_microseconds(timestamp):\n    \"\"\"Convert a timestamp string into a microseconds value\n    :param timestamp\n    :return time in microseconds\n    \"\"\"\n    timestamp_str = datetime.datetime.strptime(timestamp, ISO_DATETIME_REGEX)\n    epoch_time_secs = calendar.timegm(timestamp_str.timetuple())\n    epoch_time_mus = epoch_time_secs * 1e6 + timestamp_str.microsecond\n    return epoch_time_mus", "code_tokens": "def timestamp_to_microseconds ( timestamp ) : timestamp_str = datetime . datetime . strptime ( timestamp , ISO_DATETIME_REGEX ) epoch_time_secs = calendar . timegm ( timestamp_str . timetuple ( ) ) epoch_time_mus = epoch_time_secs * 1e6 + timestamp_str . microsecond return epoch_time_mus", "docstring_tokens": "Convert a timestamp string into a microseconds value : param timestamp : return time in microseconds", "label": 0}, {"idx": "cosqa-train-1072", "doc": "python prints characters from buffer after script is run", "code": "def stdout_display():\n    \"\"\" Print results straight to stdout \"\"\"\n    if sys.version_info[0] == 2:\n        yield SmartBuffer(sys.stdout)\n    else:\n        yield SmartBuffer(sys.stdout.buffer)", "code_tokens": "def stdout_display ( ) : if sys . version_info [ 0 ] == 2 : yield SmartBuffer ( sys . stdout ) else : yield SmartBuffer ( sys . stdout . buffer )", "docstring_tokens": "Print results straight to stdout", "label": 0}, {"idx": "cosqa-train-1073", "doc": "how to get most common value in list python", "code": "def mostCommonItem(lst):\n    \"\"\"Choose the most common item from the list, or the first item if all\n    items are unique.\"\"\"\n    # This elegant solution from: http://stackoverflow.com/a/1518632/1760218\n    lst = [l for l in lst if l]\n    if lst:\n        return max(set(lst), key=lst.count)\n    else:\n        return None", "code_tokens": "def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None", "docstring_tokens": "Choose the most common item from the list or the first item if all items are unique .", "label": 0}, {"idx": "cosqa-train-1074", "doc": "python process join doesn't return", "code": "def start(self, timeout=None):\n        \"\"\"\n        Startup of the node.\n        :param join: optionally wait for the process to end (default : True)\n        :return: None\n        \"\"\"\n\n        assert super(PyrosBase, self).start(timeout=timeout)\n        # Because we currently use this to setup connection\n        return self.name", "code_tokens": "def start ( self , timeout = None ) : assert super ( PyrosBase , self ) . start ( timeout = timeout ) # Because we currently use this to setup connection return self . name", "docstring_tokens": "Startup of the node . : param join : optionally wait for the process to end ( default : True ) : return : None", "label": 0}, {"idx": "cosqa-train-1075", "doc": "how to get multiple matches on a regex python", "code": "def filter_regex(names, regex):\n    \"\"\"\n    Return a tuple of strings that match the regular expression pattern.\n    \"\"\"\n    return tuple(name for name in names\n                 if regex.search(name) is not None)", "code_tokens": "def filter_regex ( names , regex ) : return tuple ( name for name in names if regex . search ( name ) is not None )", "docstring_tokens": "Return a tuple of strings that match the regular expression pattern .", "label": 0}, {"idx": "cosqa-train-1076", "doc": "python property within a property", "code": "def value(self):\n        \"\"\"Value of property.\"\"\"\n        if self._prop.fget is None:\n            raise AttributeError('Unable to read attribute')\n        return self._prop.fget(self._obj)", "code_tokens": "def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )", "docstring_tokens": "Value of property .", "label": 0}, {"idx": "cosqa-train-1077", "doc": "how to get number of lines of a file python", "code": "def line_count(fn):\n    \"\"\" Get line count of file\n\n    Args:\n        fn (str): Path to file\n\n    Return:\n          Number of lines in file (int)\n    \"\"\"\n\n    with open(fn) as f:\n        for i, l in enumerate(f):\n            pass\n    return i + 1", "code_tokens": "def line_count ( fn ) : with open ( fn ) as f : for i , l in enumerate ( f ) : pass return i + 1", "docstring_tokens": "Get line count of file", "label": 1}, {"idx": "cosqa-train-1078", "doc": "python public proxy list", "code": "def load(self):\n        \"\"\"Load proxy list from configured proxy source\"\"\"\n        self._list = self._source.load()\n        self._list_iter = itertools.cycle(self._list)", "code_tokens": "def load ( self ) : self . _list = self . _source . load ( ) self . _list_iter = itertools . cycle ( self . _list )", "docstring_tokens": "Load proxy list from configured proxy source", "label": 1}, {"idx": "cosqa-train-1079", "doc": "how to get points in python", "code": "def _get_points(self):\n        \"\"\"\n        Subclasses may override this method.\n        \"\"\"\n        return tuple([self._getitem__points(i)\n                     for i in range(self._len__points())])", "code_tokens": "def _get_points ( self ) : return tuple ( [ self . _getitem__points ( i ) for i in range ( self . _len__points ( ) ) ] )", "docstring_tokens": "Subclasses may override this method .", "label": 0}, {"idx": "cosqa-train-1080", "doc": "python pylint disable unused", "code": "def format_pylint_disables(error_names, tag=True):\n    \"\"\"\n    Format a list of error_names into a 'pylint: disable=' line.\n    \"\"\"\n    tag_str = \"lint-amnesty, \" if tag else \"\"\n    if error_names:\n        return u\"  # {tag}pylint: disable={disabled}\".format(\n            disabled=\", \".join(sorted(error_names)),\n            tag=tag_str,\n        )\n    else:\n        return \"\"", "code_tokens": "def format_pylint_disables ( error_names , tag = True ) : tag_str = \"lint-amnesty, \" if tag else \"\" if error_names : return u\"  # {tag}pylint: disable={disabled}\" . format ( disabled = \", \" . join ( sorted ( error_names ) ) , tag = tag_str , ) else : return \"\"", "docstring_tokens": "Format a list of error_names into a pylint : disable = line .", "label": 0}, {"idx": "cosqa-train-1081", "doc": "how to get real quantum random values python", "code": "def qrandom(n):\n  \"\"\"\n  Creates an array of n true random numbers obtained from the quantum random\n  number generator at qrng.anu.edu.au\n\n  This function requires the package quantumrandom and an internet connection.\n\n  Args:\n    n (int):\n      length of the random array\n\n  Return:\n    array of ints:\n      array of truly random unsigned 16 bit int values\n  \"\"\"\n  import quantumrandom\n  return np.concatenate([\n    quantumrandom.get_data(data_type='uint16', array_length=1024)\n    for i in range(int(np.ceil(n/1024.0)))\n  ])[:n]", "code_tokens": "def qrandom ( n ) : import quantumrandom return np . concatenate ( [ quantumrandom . get_data ( data_type = 'uint16' , array_length = 1024 ) for i in range ( int ( np . ceil ( n / 1024.0 ) ) ) ] ) [ : n ]", "docstring_tokens": "Creates an array of n true random numbers obtained from the quantum random number generator at qrng . anu . edu . au", "label": 0}, {"idx": "cosqa-train-1082", "doc": "python pyodbc delete table function", "code": "def clear_table(dbconn, table_name):\n    \"\"\"\n    Delete all rows from a table\n    :param dbconn: data base connection\n    :param table_name: name of the table\n    :return:\n    \"\"\"\n    cur = dbconn.cursor()\n    cur.execute(\"DELETE FROM '{name}'\".format(name=table_name))\n    dbconn.commit()", "code_tokens": "def clear_table ( dbconn , table_name ) : cur = dbconn . cursor ( ) cur . execute ( \"DELETE FROM '{name}'\" . format ( name = table_name ) ) dbconn . commit ( )", "docstring_tokens": "Delete all rows from a table : param dbconn : data base connection : param table_name : name of the table : return :", "label": 0}, {"idx": "cosqa-train-1083", "doc": "how to get rid of the space in between the word and punctuation in python", "code": "def lowstrip(term):\n    \"\"\"Convert to lowercase and strip spaces\"\"\"\n    term = re.sub('\\s+', ' ', term)\n    term = term.lower()\n    return term", "code_tokens": "def lowstrip ( term ) : term = re . sub ( '\\s+' , ' ' , term ) term = term . lower ( ) return term", "docstring_tokens": "Convert to lowercase and strip spaces", "label": 0}, {"idx": "cosqa-train-1084", "doc": "python pysftp put file on server chmod", "code": "def chmod(self, mode):\n        \"\"\"\n        Change the mode (permissions) of this file.  The permissions are\n        unix-style and identical to those used by python's C{os.chmod}\n        function.\n\n        @param mode: new permissions\n        @type mode: int\n        \"\"\"\n        self.sftp._log(DEBUG, 'chmod(%s, %r)' % (hexlify(self.handle), mode))\n        attr = SFTPAttributes()\n        attr.st_mode = mode\n        self.sftp._request(CMD_FSETSTAT, self.handle, attr)", "code_tokens": "def chmod ( self , mode ) : self . sftp . _log ( DEBUG , 'chmod(%s, %r)' % ( hexlify ( self . handle ) , mode ) ) attr = SFTPAttributes ( ) attr . st_mode = mode self . sftp . _request ( CMD_FSETSTAT , self . handle , attr )", "docstring_tokens": "Change the mode ( permissions ) of this file . The permissions are unix - style and identical to those used by python s C { os . chmod } function .", "label": 0}, {"idx": "cosqa-train-1085", "doc": "how to get segment of array at a time in python", "code": "def region_from_segment(image, segment):\n    \"\"\"given a segment (rectangle) and an image, returns it's corresponding subimage\"\"\"\n    x, y, w, h = segment\n    return image[y:y + h, x:x + w]", "code_tokens": "def region_from_segment ( image , segment ) : x , y , w , h = segment return image [ y : y + h , x : x + w ]", "docstring_tokens": "given a segment ( rectangle ) and an image returns it s corresponding subimage", "label": 1}, {"idx": "cosqa-train-1086", "doc": "python pytest test as though called from command line", "code": "def test(ctx, all=False, verbose=False):\n    \"\"\"Run the tests.\"\"\"\n    cmd = 'tox' if all else 'py.test'\n    if verbose:\n        cmd += ' -v'\n    return ctx.run(cmd, pty=True).return_code", "code_tokens": "def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code", "docstring_tokens": "Run the tests .", "label": 0}, {"idx": "cosqa-train-1087", "doc": "how to get specific column from dmatrix python", "code": "def get_column(self, X, column):\n        \"\"\"Return a column of the given matrix.\n\n        Args:\n            X: `numpy.ndarray` or `pandas.DataFrame`.\n            column: `int` or `str`.\n\n        Returns:\n            np.ndarray: Selected column.\n        \"\"\"\n        if isinstance(X, pd.DataFrame):\n            return X[column].values\n\n        return X[:, column]", "code_tokens": "def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]", "docstring_tokens": "Return a column of the given matrix .", "label": 0}, {"idx": "cosqa-train-1088", "doc": "python qcheckbox ischecked false", "code": "def set_value(self, value):\n        \"\"\"Set value of the checkbox.\n\n        Parameters\n        ----------\n        value : bool\n            value for the checkbox\n\n        \"\"\"\n        if value:\n            self.setCheckState(Qt.Checked)\n        else:\n            self.setCheckState(Qt.Unchecked)", "code_tokens": "def set_value ( self , value ) : if value : self . setCheckState ( Qt . Checked ) else : self . setCheckState ( Qt . Unchecked )", "docstring_tokens": "Set value of the checkbox .", "label": 0}, {"idx": "cosqa-train-1089", "doc": "how to get subplotunder xis python", "code": "def show_xticklabels(self, row, column):\n        \"\"\"Show the x-axis tick labels for a subplot.\n\n        :param row,column: specify the subplot.\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.show_xticklabels()", "code_tokens": "def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "docstring_tokens": "Show the x - axis tick labels for a subplot .", "label": 0}, {"idx": "cosqa-train-1090", "doc": "python qgraphicsview resizeevent firinview", "code": "def resizeEvent(self, event):\n        \"\"\"Reimplement Qt method\"\"\"\n        if not self.isMaximized() and not self.fullscreen_flag:\n            self.window_size = self.size()\n        QMainWindow.resizeEvent(self, event)\n\n        # To be used by the tour to be able to resize\n        self.sig_resized.emit(event)", "code_tokens": "def resizeEvent ( self , event ) : if not self . isMaximized ( ) and not self . fullscreen_flag : self . window_size = self . size ( ) QMainWindow . resizeEvent ( self , event ) # To be used by the tour to be able to resize\n self . sig_resized . emit ( event )", "docstring_tokens": "Reimplement Qt method", "label": 0}, {"idx": "cosqa-train-1091", "doc": "how to get summary of table in python", "code": "def PrintSummaryTable(self):\n    \"\"\"Prints a summary table.\"\"\"\n    print(\"\"\"\n\nAs of {0:s} the repository contains:\n\n| **File paths covered** | **{1:d}** |\n| :------------------ | ------: |\n| **Registry keys covered** | **{2:d}** |\n| **Total artifacts** | **{3:d}** |\n\"\"\".format(\n    time.strftime('%Y-%m-%d'), self.path_count, self.reg_key_count,\n    self.total_count))", "code_tokens": "def PrintSummaryTable ( self ) : print ( \"\"\"\n\nAs of {0:s} the repository contains:\n\n| **File paths covered** | **{1:d}** |\n| :------------------ | ------: |\n| **Registry keys covered** | **{2:d}** |\n| **Total artifacts** | **{3:d}** |\n\"\"\" . format ( time . strftime ( '%Y-%m-%d' ) , self . path_count , self . reg_key_count , self . total_count ) )", "docstring_tokens": "Prints a summary table .", "label": 0}, {"idx": "cosqa-train-1092", "doc": "python query socket state", "code": "def state(self):\n    \"\"\"Returns the current LED state by querying the remote controller.\"\"\"\n    ev = self._query_waiters.request(self.__do_query_state)\n    ev.wait(1.0)\n    return self._state", "code_tokens": "def state ( self ) : ev = self . _query_waiters . request ( self . __do_query_state ) ev . wait ( 1.0 ) return self . _state", "docstring_tokens": "Returns the current LED state by querying the remote controller .", "label": 0}, {"idx": "cosqa-train-1093", "doc": "how to get swagger on flask python", "code": "def refresh_swagger(self):\n        \"\"\"\n        Manually refresh the swagger document. This can help resolve errors communicate with the API.\n        \"\"\"\n        try:\n            os.remove(self._get_swagger_filename(self.swagger_url))\n        except EnvironmentError as e:\n            logger.warn(os.strerror(e.errno))\n        else:\n            self.__init__()", "code_tokens": "def refresh_swagger ( self ) : try : os . remove ( self . _get_swagger_filename ( self . swagger_url ) ) except EnvironmentError as e : logger . warn ( os . strerror ( e . errno ) ) else : self . __init__ ( )", "docstring_tokens": "Manually refresh the swagger document . This can help resolve errors communicate with the API .", "label": 0}, {"idx": "cosqa-train-1094", "doc": "python queue count consumed items", "code": "def full(self):\n        \"\"\"Return True if the queue is full\"\"\"\n        if not self.size: return False\n        return len(self.pq) == (self.size + self.removed_count)", "code_tokens": "def full ( self ) : if not self . size : return False return len ( self . pq ) == ( self . size + self . removed_count )", "docstring_tokens": "Return True if the queue is full", "label": 0}, {"idx": "cosqa-train-1095", "doc": "how to get tables from sqlite database python", "code": "def get_tablenames(cur):\n    \"\"\" Conveinience: \"\"\"\n    cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n    tablename_list_ = cur.fetchall()\n    tablename_list = [str(tablename[0]) for tablename in tablename_list_ ]\n    return tablename_list", "code_tokens": "def get_tablenames ( cur ) : cur . execute ( \"SELECT name FROM sqlite_master WHERE type='table'\" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list", "docstring_tokens": "Conveinience :", "label": 0}, {"idx": "cosqa-train-1096", "doc": "python quickest way get rid of duplicates in a list", "code": "def remove_duplicates(lst):\n    \"\"\"\n    Emulate what a Python ``set()`` does, but keeping the element's order.\n    \"\"\"\n    dset = set()\n    return [l for l in lst if l not in dset and not dset.add(l)]", "code_tokens": "def remove_duplicates ( lst ) : dset = set ( ) return [ l for l in lst if l not in dset and not dset . add ( l ) ]", "docstring_tokens": "Emulate what a Python set () does but keeping the element s order .", "label": 0}, {"idx": "cosqa-train-1097", "doc": "how to get the directory path in python", "code": "def rel_path(filename):\n    \"\"\"\n    Function that gets relative path to the filename\n    \"\"\"\n    return os.path.join(os.getcwd(), os.path.dirname(__file__), filename)", "code_tokens": "def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )", "docstring_tokens": "Function that gets relative path to the filename", "label": 0}, {"idx": "cosqa-train-1098", "doc": "python quickfix timestamp with microseconds", "code": "def convert_timestamp(timestamp):\n    \"\"\"\n    Converts bokehJS timestamp to datetime64.\n    \"\"\"\n    datetime = dt.datetime.utcfromtimestamp(timestamp/1000.)\n    return np.datetime64(datetime.replace(tzinfo=None))", "code_tokens": "def convert_timestamp ( timestamp ) : datetime = dt . datetime . utcfromtimestamp ( timestamp / 1000. ) return np . datetime64 ( datetime . replace ( tzinfo = None ) )", "docstring_tokens": "Converts bokehJS timestamp to datetime64 .", "label": 0}, {"idx": "cosqa-train-1099", "doc": "how to get the filename of a file in python", "code": "def get_file_name(url):\n  \"\"\"Returns file name of file at given url.\"\"\"\n  return os.path.basename(urllib.parse.urlparse(url).path) or 'unknown_name'", "code_tokens": "def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'", "docstring_tokens": "Returns file name of file at given url .", "label": 0}, {"idx": "cosqa-train-1100", "doc": "python quit from outside function", "code": "def _quit(self, *args):\n        \"\"\" quit crash \"\"\"\n        self.logger.warn('Bye!')\n        sys.exit(self.exit())", "code_tokens": "def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )", "docstring_tokens": "quit crash", "label": 0}, {"idx": "cosqa-train-1101", "doc": "python rabbitmq connection refused", "code": "def prepare(self):\n        \"\"\"Prepare the handler, ensuring RabbitMQ is connected or start a new\n        connection attempt.\n\n        \"\"\"\n        super(RabbitMQRequestHandler, self).prepare()\n        if self._rabbitmq_is_closed:\n            self._connect_to_rabbitmq()", "code_tokens": "def prepare ( self ) : super ( RabbitMQRequestHandler , self ) . prepare ( ) if self . _rabbitmq_is_closed : self . _connect_to_rabbitmq ( )", "docstring_tokens": "Prepare the handler ensuring RabbitMQ is connected or start a new connection attempt .", "label": 0}, {"idx": "cosqa-train-1102", "doc": "how to get the index of the element in a list python", "code": "def sorted_index(values, x):\n    \"\"\"\n    For list, values, returns the index location of element x. If x does not exist will raise an error.\n\n    :param values: list\n    :param x: item\n    :return: integer index\n    \"\"\"\n    i = bisect_left(values, x)\n    j = bisect_right(values, x)\n    return values[i:j].index(x) + i", "code_tokens": "def sorted_index ( values , x ) : i = bisect_left ( values , x ) j = bisect_right ( values , x ) return values [ i : j ] . index ( x ) + i", "docstring_tokens": "For list values returns the index location of element x . If x does not exist will raise an error .", "label": 0}, {"idx": "cosqa-train-1103", "doc": "python random gen normal distribution", "code": "def rnormal(mu, tau, size=None):\n    \"\"\"\n    Random normal variates.\n    \"\"\"\n    return np.random.normal(mu, 1. / np.sqrt(tau), size)", "code_tokens": "def rnormal ( mu , tau , size = None ) : return np . random . normal ( mu , 1. / np . sqrt ( tau ) , size )", "docstring_tokens": "Random normal variates .", "label": 0}, {"idx": "cosqa-train-1104", "doc": "how to get the maximum number of core in a machine using python", "code": "def _num_cpus_darwin():\n    \"\"\"Return the number of active CPUs on a Darwin system.\"\"\"\n    p = subprocess.Popen(['sysctl','-n','hw.ncpu'],stdout=subprocess.PIPE)\n    return p.stdout.read()", "code_tokens": "def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )", "docstring_tokens": "Return the number of active CPUs on a Darwin system .", "label": 0}, {"idx": "cosqa-train-1105", "doc": "python random permutation of a set", "code": "def endless_permutations(N, random_state=None):\n    \"\"\"\n    Generate an endless sequence of random integers from permutations of the\n    set [0, ..., N).\n\n    If we call this N times, we will sweep through the entire set without\n    replacement, on the (N+1)th call a new permutation will be created, etc.\n\n    Parameters\n    ----------\n    N: int\n        the length of the set\n    random_state: int or RandomState, optional\n        random seed\n\n    Yields\n    ------\n    int:\n        a random int from the set [0, ..., N)\n    \"\"\"\n    generator = check_random_state(random_state)\n    while True:\n        batch_inds = generator.permutation(N)\n        for b in batch_inds:\n            yield b", "code_tokens": "def endless_permutations ( N , random_state = None ) : generator = check_random_state ( random_state ) while True : batch_inds = generator . permutation ( N ) for b in batch_inds : yield b", "docstring_tokens": "Generate an endless sequence of random integers from permutations of the set [ 0 ... N ) .", "label": 1}, {"idx": "cosqa-train-1106", "doc": "how to get the most recent file from a list python", "code": "def newest_file(file_iterable):\n  \"\"\"\n  Returns the name of the newest file given an iterable of file names.\n\n  \"\"\"\n  return max(file_iterable, key=lambda fname: os.path.getmtime(fname))", "code_tokens": "def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )", "docstring_tokens": "Returns the name of the newest file given an iterable of file names .", "label": 0}, {"idx": "cosqa-train-1107", "doc": "python random uniform points with random coordinates", "code": "def _rndPointDisposition(dx, dy):\n        \"\"\"Return random disposition point.\"\"\"\n        x = int(random.uniform(-dx, dx))\n        y = int(random.uniform(-dy, dy))\n        return (x, y)", "code_tokens": "def _rndPointDisposition ( dx , dy ) : x = int ( random . uniform ( - dx , dx ) ) y = int ( random . uniform ( - dy , dy ) ) return ( x , y )", "docstring_tokens": "Return random disposition point .", "label": 1}, {"idx": "cosqa-train-1108", "doc": "how to get the python path", "code": "def get_module_path(modname):\n    \"\"\"Return module *modname* base path\"\"\"\n    return osp.abspath(osp.dirname(sys.modules[modname].__file__))", "code_tokens": "def get_module_path ( modname ) : return osp . abspath ( osp . dirname ( sys . modules [ modname ] . __file__ ) )", "docstring_tokens": "Return module * modname * base path", "label": 0}, {"idx": "cosqa-train-1109", "doc": "python raw strings single quote", "code": "def quote(self, s):\n        \"\"\"Return a shell-escaped version of the string s.\"\"\"\n\n        if six.PY2:\n            from pipes import quote\n        else:\n            from shlex import quote\n\n        return quote(s)", "code_tokens": "def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )", "docstring_tokens": "Return a shell - escaped version of the string s .", "label": 1}, {"idx": "cosqa-train-1110", "doc": "how to get time of output in python", "code": "def timeit(output):\n    \"\"\"\n    If output is string, then print the string and also time used\n    \"\"\"\n    b = time.time()\n    yield\n    print output, 'time used: %.3fs' % (time.time()-b)", "code_tokens": "def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )", "docstring_tokens": "If output is string then print the string and also time used", "label": 0}, {"idx": "cosqa-train-1111", "doc": "python read bytes in a file", "code": "def read_string(buff, byteorder='big'):\n    \"\"\"Read a string from a file-like object.\"\"\"\n    length = read_numeric(USHORT, buff, byteorder)\n    return buff.read(length).decode('utf-8')", "code_tokens": "def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )", "docstring_tokens": "Read a string from a file - like object .", "label": 0}, {"idx": "cosqa-train-1112", "doc": "how to get toolbar on python", "code": "def add_to_toolbar(self, toolbar, widget):\n        \"\"\"Add widget actions to toolbar\"\"\"\n        actions = widget.toolbar_actions\n        if actions is not None:\n            add_actions(toolbar, actions)", "code_tokens": "def add_to_toolbar ( self , toolbar , widget ) : actions = widget . toolbar_actions if actions is not None : add_actions ( toolbar , actions )", "docstring_tokens": "Add widget actions to toolbar", "label": 0}, {"idx": "cosqa-train-1113", "doc": "python read csv as matrix", "code": "def load_data(filename):\n    \"\"\"\n    :rtype : numpy matrix\n    \"\"\"\n    data = pandas.read_csv(filename, header=None, delimiter='\\t', skiprows=9)\n    return data.as_matrix()", "code_tokens": "def load_data ( filename ) : data = pandas . read_csv ( filename , header = None , delimiter = '\\t' , skiprows = 9 ) return data . as_matrix ( )", "docstring_tokens": ": rtype : numpy matrix", "label": 0}, {"idx": "cosqa-train-1114", "doc": "how to get user id of a process using python", "code": "def get_system_uid():\n    \"\"\"Get a (probably) unique ID to identify a system.\n    Used to differentiate votes.\n    \"\"\"\n    try:\n        if os.name == 'nt':\n            return get_nt_system_uid()\n        if sys.platform == 'darwin':\n            return get_osx_system_uid()\n    except Exception:\n        return get_mac_uid()\n    else:\n        return get_mac_uid()", "code_tokens": "def get_system_uid ( ) : try : if os . name == 'nt' : return get_nt_system_uid ( ) if sys . platform == 'darwin' : return get_osx_system_uid ( ) except Exception : return get_mac_uid ( ) else : return get_mac_uid ( )", "docstring_tokens": "Get a ( probably ) unique ID to identify a system . Used to differentiate votes .", "label": 0}, {"idx": "cosqa-train-1115", "doc": "python read document and remove line breaks", "code": "def lines(input):\n    \"\"\"Remove comments and empty lines\"\"\"\n    for raw_line in input:\n        line = raw_line.strip()\n        if line and not line.startswith('#'):\n            yield strip_comments(line)", "code_tokens": "def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )", "docstring_tokens": "Remove comments and empty lines", "label": 0}, {"idx": "cosqa-train-1116", "doc": "how to get user name in python", "code": "def get_user_name():\n    \"\"\"Get user name provide by operating system\n    \"\"\"\n\n    if sys.platform == 'win32':\n        #user = os.getenv('USERPROFILE')\n        user = os.getenv('USERNAME')\n    else:\n        user = os.getenv('LOGNAME')\n\n    return user", "code_tokens": "def get_user_name ( ) : if sys . platform == 'win32' : #user = os.getenv('USERPROFILE') user = os . getenv ( 'USERNAME' ) else : user = os . getenv ( 'LOGNAME' ) return user", "docstring_tokens": "Get user name provide by operating system", "label": 0}, {"idx": "cosqa-train-1117", "doc": "python read file cache", "code": "def getlines(filename, module_globals=None):\n    \"\"\"Get the lines for a file from the cache.\n    Update the cache if it doesn't contain an entry for this file already.\"\"\"\n\n    if filename in cache:\n        return cache[filename][2]\n\n    try:\n        return updatecache(filename, module_globals)\n    except MemoryError:\n        clearcache()\n        return []", "code_tokens": "def getlines ( filename , module_globals = None ) : if filename in cache : return cache [ filename ] [ 2 ] try : return updatecache ( filename , module_globals ) except MemoryError : clearcache ( ) return [ ]", "docstring_tokens": "Get the lines for a file from the cache . Update the cache if it doesn t contain an entry for this file already .", "label": 0}, {"idx": "cosqa-train-1118", "doc": "how to get variable coefficients in python", "code": "def compute_y(self, coefficients, num_x):\n        \"\"\" Return calculated y-values for the domain of x-values in [1, num_x]. \"\"\"\n        y_vals = []\n\n        for x in range(1, num_x + 1):\n            y = sum([c * x ** i for i, c in enumerate(coefficients[::-1])])\n            y_vals.append(y)\n\n        return y_vals", "code_tokens": "def compute_y ( self , coefficients , num_x ) : y_vals = [ ] for x in range ( 1 , num_x + 1 ) : y = sum ( [ c * x ** i for i , c in enumerate ( coefficients [ : : - 1 ] ) ] ) y_vals . append ( y ) return y_vals", "docstring_tokens": "Return calculated y - values for the domain of x - values in [ 1 num_x ] .", "label": 0}, {"idx": "cosqa-train-1119", "doc": "python read file untill certain char", "code": "def _readuntil(f, end=_TYPE_END):\n\t\"\"\"Helper function to read bytes until a certain end byte is hit\"\"\"\n\tbuf = bytearray()\n\tbyte = f.read(1)\n\twhile byte != end:\n\t\tif byte == b'':\n\t\t\traise ValueError('File ended unexpectedly. Expected end byte {}.'.format(end))\n\t\tbuf += byte\n\t\tbyte = f.read(1)\n\treturn buf", "code_tokens": "def _readuntil ( f , end = _TYPE_END ) : buf = bytearray ( ) byte = f . read ( 1 ) while byte != end : if byte == b'' : raise ValueError ( 'File ended unexpectedly. Expected end byte {}.' . format ( end ) ) buf += byte byte = f . read ( 1 ) return buf", "docstring_tokens": "Helper function to read bytes until a certain end byte is hit", "label": 0}, {"idx": "cosqa-train-1120", "doc": "how to give object in tokenization in python 3", "code": "def _add_pos1(token):\n    \"\"\"\n    Adds a 'pos1' element to a frog token.\n    \"\"\"\n    result = token.copy()\n    result['pos1'] = _POSMAP[token['pos'].split(\"(\")[0]]\n    return result", "code_tokens": "def _add_pos1 ( token ) : result = token . copy ( ) result [ 'pos1' ] = _POSMAP [ token [ 'pos' ] . split ( \"(\" ) [ 0 ] ] return result", "docstring_tokens": "Adds a pos1 element to a frog token .", "label": 0}, {"idx": "cosqa-train-1121", "doc": "python read file with any encoding", "code": "def read_string_from_file(path, encoding=\"utf8\"):\n  \"\"\"\n  Read entire contents of file into a string.\n  \"\"\"\n  with codecs.open(path, \"rb\", encoding=encoding) as f:\n    value = f.read()\n  return value", "code_tokens": "def read_string_from_file ( path , encoding = \"utf8\" ) : with codecs . open ( path , \"rb\" , encoding = encoding ) as f : value = f . read ( ) return value", "docstring_tokens": "Read entire contents of file into a string .", "label": 0}, {"idx": "cosqa-train-1122", "doc": "how to handle the file paths in python", "code": "def relative_path(path):\n    \"\"\"\n    Return the given path relative to this file.\n    \"\"\"\n    return os.path.join(os.path.dirname(__file__), path)", "code_tokens": "def relative_path ( path ) : return os . path . join ( os . path . dirname ( __file__ ) , path )", "docstring_tokens": "Return the given path relative to this file .", "label": 0}, {"idx": "cosqa-train-1123", "doc": "python read first line of a file to a string", "code": "def getfirstline(file, default):\n    \"\"\"\n    Returns the first line of a file.\n    \"\"\"\n    with open(file, 'rb') as fh:\n        content = fh.readlines()\n        if len(content) == 1:\n            return content[0].decode('utf-8').strip('\\n')\n\n    return default", "code_tokens": "def getfirstline ( file , default ) : with open ( file , 'rb' ) as fh : content = fh . readlines ( ) if len ( content ) == 1 : return content [ 0 ] . decode ( 'utf-8' ) . strip ( '\\n' ) return default", "docstring_tokens": "Returns the first line of a file .", "label": 1}, {"idx": "cosqa-train-1124", "doc": "how to hide python interactive windows", "code": "def page_guiref(arg_s=None):\n    \"\"\"Show a basic reference about the GUI Console.\"\"\"\n    from IPython.core import page\n    page.page(gui_reference, auto_html=True)", "code_tokens": "def page_guiref ( arg_s = None ) : from IPython . core import page page . page ( gui_reference , auto_html = True )", "docstring_tokens": "Show a basic reference about the GUI Console .", "label": 0}, {"idx": "cosqa-train-1125", "doc": "python read from stdin until eof", "code": "def _read_stdin():\n    \"\"\"\n    Generator for reading from standard input in nonblocking mode.\n\n    Other ways of reading from ``stdin`` in python waits, until the buffer is\n    big enough, or until EOF character is sent.\n\n    This functions yields immediately after each line.\n    \"\"\"\n    line = sys.stdin.readline()\n    while line:\n        yield line\n        line = sys.stdin.readline()", "code_tokens": "def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )", "docstring_tokens": "Generator for reading from standard input in nonblocking mode .", "label": 0}, {"idx": "cosqa-train-1126", "doc": "how to include an excel file in python", "code": "def save_excel(self, fd):\n        \"\"\" Saves the case as an Excel spreadsheet.\n        \"\"\"\n        from pylon.io.excel import ExcelWriter\n        ExcelWriter(self).write(fd)", "code_tokens": "def save_excel ( self , fd ) : from pylon . io . excel import ExcelWriter ExcelWriter ( self ) . write ( fd )", "docstring_tokens": "Saves the case as an Excel spreadsheet .", "label": 0}, {"idx": "cosqa-train-1127", "doc": "python read input non blocking", "code": "async def async_input(prompt):\n    \"\"\"\n    Python's ``input()`` is blocking, which means the event loop we set\n    above can't be running while we're blocking there. This method will\n    let the loop run while we wait for input.\n    \"\"\"\n    print(prompt, end='', flush=True)\n    return (await loop.run_in_executor(None, sys.stdin.readline)).rstrip()", "code_tokens": "async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "docstring_tokens": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input .", "label": 0}, {"idx": "cosqa-train-1128", "doc": "how to increase the text size in python", "code": "def set_font_size(self, size):\n        \"\"\"Convenience method for just changing font size.\"\"\"\n        if self.font.font_size == size:\n            pass\n        else:\n            self.font._set_size(size)", "code_tokens": "def set_font_size ( self , size ) : if self . font . font_size == size : pass else : self . font . _set_size ( size )", "docstring_tokens": "Convenience method for just changing font size .", "label": 0}, {"idx": "cosqa-train-1129", "doc": "python read only file using json", "code": "def open_json(file_name):\n    \"\"\"\n    returns json contents as string\n    \"\"\"\n    with open(file_name, \"r\") as json_data:\n        data = json.load(json_data)\n        return data", "code_tokens": "def open_json ( file_name ) : with open ( file_name , \"r\" ) as json_data : data = json . load ( json_data ) return data", "docstring_tokens": "returns json contents as string", "label": 0}, {"idx": "cosqa-train-1130", "doc": "how to index lines in a file python 2", "code": "def get_lines(handle, line):\n    \"\"\"\n    Get zero-indexed line from an open file-like.\n    \"\"\"\n    for i, l in enumerate(handle):\n        if i == line:\n            return l", "code_tokens": "def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l", "docstring_tokens": "Get zero - indexed line from an open file - like .", "label": 0}, {"idx": "cosqa-train-1131", "doc": "python read only mode", "code": "def is_read_only(object):\n    \"\"\"\n    Returns if given object is read only ( built-in or extension ).\n\n    :param object: Object.\n    :type object: object\n    :return: Is object read only.\n    :rtype: bool\n    \"\"\"\n\n    try:\n        attribute = \"_trace__read__\"\n        setattr(object, attribute, True)\n        delattr(object, attribute)\n        return False\n    except (TypeError, AttributeError):\n        return True", "code_tokens": "def is_read_only ( object ) : try : attribute = \"_trace__read__\" setattr ( object , attribute , True ) delattr ( object , attribute ) return False except ( TypeError , AttributeError ) : return True", "docstring_tokens": "Returns if given object is read only ( built - in or extension ) .", "label": 0}, {"idx": "cosqa-train-1132", "doc": "how to insert underline in python", "code": "def draw_header(self, stream, header):\n        \"\"\"Draw header with underline\"\"\"\n        stream.writeln('=' * (len(header) + 4))\n        stream.writeln('| ' + header + ' |')\n        stream.writeln('=' * (len(header) + 4))\n        stream.writeln()", "code_tokens": "def draw_header ( self , stream , header ) : stream . writeln ( '=' * ( len ( header ) + 4 ) ) stream . writeln ( '| ' + header + ' |' ) stream . writeln ( '=' * ( len ( header ) + 4 ) ) stream . writeln ( )", "docstring_tokens": "Draw header with underline", "label": 1}, {"idx": "cosqa-train-1133", "doc": "python read raw txt from url", "code": "def url_read_text(url, verbose=True):\n    r\"\"\"\n    Directly reads text data from url\n    \"\"\"\n    data = url_read(url, verbose)\n    text = data.decode('utf8')\n    return text", "code_tokens": "def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text", "docstring_tokens": "r Directly reads text data from url", "label": 1}, {"idx": "cosqa-train-1134", "doc": "how to interpolate raster using gdal python", "code": "def get_xy_grids(ds, stride=1, getval=False):\n    \"\"\"Return 2D arrays of x and y map coordinates for input GDAL Dataset \n    \"\"\"\n    gt = ds.GetGeoTransform()\n    #stride = stride_m/gt[1]\n    pX = np.arange(0, ds.RasterXSize, stride)\n    pY = np.arange(0, ds.RasterYSize, stride)\n    psamp = np.meshgrid(pX, pY)\n    mX, mY = pixelToMap(psamp[0], psamp[1], gt)\n    return mX, mY", "code_tokens": "def get_xy_grids ( ds , stride = 1 , getval = False ) : gt = ds . GetGeoTransform ( ) #stride = stride_m/gt[1] pX = np . arange ( 0 , ds . RasterXSize , stride ) pY = np . arange ( 0 , ds . RasterYSize , stride ) psamp = np . meshgrid ( pX , pY ) mX , mY = pixelToMap ( psamp [ 0 ] , psamp [ 1 ] , gt ) return mX , mY", "docstring_tokens": "Return 2D arrays of x and y map coordinates for input GDAL Dataset", "label": 0}, {"idx": "cosqa-train-1135", "doc": "python reading a yaml config file", "code": "def _parse_config(config_file_path):\n    \"\"\" Parse Config File from yaml file. \"\"\"\n    config_file = open(config_file_path, 'r')\n    config = yaml.load(config_file)\n    config_file.close()\n    return config", "code_tokens": "def _parse_config ( config_file_path ) : config_file = open ( config_file_path , 'r' ) config = yaml . load ( config_file ) config_file . close ( ) return config", "docstring_tokens": "Parse Config File from yaml file .", "label": 0}, {"idx": "cosqa-train-1136", "doc": "how to invert a dct in one line python", "code": "def invertDictMapping(d):\n    \"\"\" Invert mapping of dictionary (i.e. map values to list of keys) \"\"\"\n    inv_map = {}\n    for k, v in d.items():\n        inv_map[v] = inv_map.get(v, [])\n        inv_map[v].append(k)\n    return inv_map", "code_tokens": "def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map", "docstring_tokens": "Invert mapping of dictionary ( i . e . map values to list of keys )", "label": 0}, {"idx": "cosqa-train-1137", "doc": "python recommended way to check empty string", "code": "def is_non_empty_string(input_string):\n    \"\"\"\n    Validate if non empty string\n\n    :param input_string: Input is a *str*.\n    :return: True if input is string and non empty.\n       Raise :exc:`Exception` otherwise.\n    \"\"\"\n    try:\n        if not input_string.strip():\n            raise ValueError()\n    except AttributeError as error:\n        raise TypeError(error)\n\n    return True", "code_tokens": "def is_non_empty_string ( input_string ) : try : if not input_string . strip ( ) : raise ValueError ( ) except AttributeError as error : raise TypeError ( error ) return True", "docstring_tokens": "Validate if non empty string", "label": 1}, {"idx": "cosqa-train-1138", "doc": "how to iterate over a json file in python", "code": "def json_iter (path):\n    \"\"\"\n    iterator for JSON-per-line in a file pattern\n    \"\"\"\n    with open(path, 'r') as f:\n        for line in f.readlines():\n            yield json.loads(line)", "code_tokens": "def json_iter ( path ) : with open ( path , 'r' ) as f : for line in f . readlines ( ) : yield json . loads ( line )", "docstring_tokens": "iterator for JSON - per - line in a file pattern", "label": 1}, {"idx": "cosqa-train-1139", "doc": "python record mouse movement", "code": "def mouse_move_event(self, event):\n        \"\"\"\n        Forward mouse cursor position events to the example\n        \"\"\"\n        self.example.mouse_position_event(event.x(), event.y())", "code_tokens": "def mouse_move_event ( self , event ) : self . example . mouse_position_event ( event . x ( ) , event . y ( ) )", "docstring_tokens": "Forward mouse cursor position events to the example", "label": 0}, {"idx": "cosqa-train-1140", "doc": "how to join two data frames python", "code": "def cross_join(df1, df2):\n    \"\"\"\n    Return a dataframe that is a cross between dataframes\n    df1 and df2\n\n    ref: https://github.com/pydata/pandas/issues/5401\n    \"\"\"\n    if len(df1) == 0:\n        return df2\n\n    if len(df2) == 0:\n        return df1\n\n    # Add as lists so that the new index keeps the items in\n    # the order that they are added together\n    all_columns = pd.Index(list(df1.columns) + list(df2.columns))\n    df1['key'] = 1\n    df2['key'] = 1\n    return pd.merge(df1, df2, on='key').loc[:, all_columns]", "code_tokens": "def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]", "docstring_tokens": "Return a dataframe that is a cross between dataframes df1 and df2", "label": 1}, {"idx": "cosqa-train-1141", "doc": "python redis close conn", "code": "def exit(self):\n        \"\"\"\n        Closes the connection\n        \"\"\"\n        self.pubsub.unsubscribe()\n        self.client.connection_pool.disconnect()\n\n        logger.info(\"Connection to Redis closed\")", "code_tokens": "def exit ( self ) : self . pubsub . unsubscribe ( ) self . client . connection_pool . disconnect ( ) logger . info ( \"Connection to Redis closed\" )", "docstring_tokens": "Closes the connection", "label": 1}, {"idx": "cosqa-train-1142", "doc": "how to know the type of a python variable", "code": "def get_var_type(self, name):\n        \"\"\"\n        Return type string, compatible with numpy.\n        \"\"\"\n        name = create_string_buffer(name)\n        type_ = create_string_buffer(MAXSTRLEN)\n        self.library.get_var_type.argtypes = [c_char_p, c_char_p]\n        self.library.get_var_type(name, type_)\n        return type_.value", "code_tokens": "def get_var_type ( self , name ) : name = create_string_buffer ( name ) type_ = create_string_buffer ( MAXSTRLEN ) self . library . get_var_type . argtypes = [ c_char_p , c_char_p ] self . library . get_var_type ( name , type_ ) return type_ . value", "docstring_tokens": "Return type string compatible with numpy .", "label": 0}, {"idx": "cosqa-train-1143", "doc": "python redis conncurent lock", "code": "def acquire_node(self, node):\n        \"\"\"\n        acquire a single redis node\n        \"\"\"\n        try:\n            return node.set(self.resource, self.lock_key, nx=True, px=self.ttl)\n        except (redis.exceptions.ConnectionError, redis.exceptions.TimeoutError):\n            return False", "code_tokens": "def acquire_node ( self , node ) : try : return node . set ( self . resource , self . lock_key , nx = True , px = self . ttl ) except ( redis . exceptions . ConnectionError , redis . exceptions . TimeoutError ) : return False", "docstring_tokens": "acquire a single redis node", "label": 0}, {"idx": "cosqa-train-1144", "doc": "how to learn python if i know java", "code": "def java_version():\n    \"\"\"Call java and return version information.\n\n    :return unicode: Java version string\n    \"\"\"\n    result = subprocess.check_output(\n        [c.JAVA, '-version'], stderr=subprocess.STDOUT\n    )\n    first_line = result.splitlines()[0]\n    return first_line.decode()", "code_tokens": "def java_version ( ) : result = subprocess . check_output ( [ c . JAVA , '-version' ] , stderr = subprocess . STDOUT ) first_line = result . splitlines ( ) [ 0 ] return first_line . decode ( )", "docstring_tokens": "Call java and return version information .", "label": 0}, {"idx": "cosqa-train-1145", "doc": "python redis hmset expire", "code": "def expireat(self, key, when):\n        \"\"\"Emulate expireat\"\"\"\n        expire_time = datetime.fromtimestamp(when)\n        key = self._encode(key)\n        if key in self.redis:\n            self.timeouts[key] = expire_time\n            return True\n        return False", "code_tokens": "def expireat ( self , key , when ) : expire_time = datetime . fromtimestamp ( when ) key = self . _encode ( key ) if key in self . redis : self . timeouts [ key ] = expire_time return True return False", "docstring_tokens": "Emulate expireat", "label": 0}, {"idx": "cosqa-train-1146", "doc": "how to list out python native functions", "code": "def init_checks_registry():\n    \"\"\"Register all globally visible functions.\n\n    The first argument name is either 'physical_line' or 'logical_line'.\n    \"\"\"\n    mod = inspect.getmodule(register_check)\n    for (name, function) in inspect.getmembers(mod, inspect.isfunction):\n        register_check(function)", "code_tokens": "def init_checks_registry ( ) : mod = inspect . getmodule ( register_check ) for ( name , function ) in inspect . getmembers ( mod , inspect . isfunction ) : register_check ( function )", "docstring_tokens": "Register all globally visible functions .", "label": 0}, {"idx": "cosqa-train-1147", "doc": "python reference to parent object", "code": "def find_root(self):\n        \"\"\" Traverse parent refs to top. \"\"\"\n        cmd = self\n        while cmd.parent:\n            cmd = cmd.parent\n        return cmd", "code_tokens": "def find_root ( self ) : cmd = self while cmd . parent : cmd = cmd . parent return cmd", "docstring_tokens": "Traverse parent refs to top .", "label": 0}, {"idx": "cosqa-train-1148", "doc": "how to load a image on opengl python", "code": "def _load_texture(file_name, resolver):\n    \"\"\"\n    Load a texture from a file into a PIL image.\n    \"\"\"\n    file_data = resolver.get(file_name)\n    image = PIL.Image.open(util.wrap_as_stream(file_data))\n    return image", "code_tokens": "def _load_texture ( file_name , resolver ) : file_data = resolver . get ( file_name ) image = PIL . Image . open ( util . wrap_as_stream ( file_data ) ) return image", "docstring_tokens": "Load a texture from a file into a PIL image .", "label": 0}, {"idx": "cosqa-train-1149", "doc": "python refrence print formatting in a list", "code": "def _tuple_repr(data):\n    \"\"\"Return a repr() for a list/tuple\"\"\"\n    if len(data) == 1:\n        return \"(%s,)\" % rpr(data[0])\n    else:\n        return \"(%s)\" % \", \".join([rpr(x) for x in data])", "code_tokens": "def _tuple_repr ( data ) : if len ( data ) == 1 : return \"(%s,)\" % rpr ( data [ 0 ] ) else : return \"(%s)\" % \", \" . join ( [ rpr ( x ) for x in data ] )", "docstring_tokens": "Return a repr () for a list / tuple", "label": 0}, {"idx": "cosqa-train-1150", "doc": "how to load a text file line by line in python", "code": "def Load(file):\n    \"\"\" Loads a model from specified file \"\"\"\n    with open(file, 'rb') as file:\n        model = dill.load(file)\n        return model", "code_tokens": "def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model", "docstring_tokens": "Loads a model from specified file", "label": 0}, {"idx": "cosqa-train-1151", "doc": "python regex finditer example", "code": "def iter_finds(regex_obj, s):\n    \"\"\"Generate all matches found within a string for a regex and yield each match as a string\"\"\"\n    if isinstance(regex_obj, str):\n        for m in re.finditer(regex_obj, s):\n            yield m.group()\n    else:\n        for m in regex_obj.finditer(s):\n            yield m.group()", "code_tokens": "def iter_finds ( regex_obj , s ) : if isinstance ( regex_obj , str ) : for m in re . finditer ( regex_obj , s ) : yield m . group ( ) else : for m in regex_obj . finditer ( s ) : yield m . group ( )", "docstring_tokens": "Generate all matches found within a string for a regex and yield each match as a string", "label": 0}, {"idx": "cosqa-train-1152", "doc": "how to make a binary tree in python", "code": "def make_bintree(levels):\n    \"\"\"Make a symmetrical binary tree with @levels\"\"\"\n    G = nx.DiGraph()\n    root = '0'\n    G.add_node(root)\n    add_children(G, root, levels, 2)\n    return G", "code_tokens": "def make_bintree ( levels ) : G = nx . DiGraph ( ) root = '0' G . add_node ( root ) add_children ( G , root , levels , 2 ) return G", "docstring_tokens": "Make a symmetrical binary tree with", "label": 0}, {"idx": "cosqa-train-1153", "doc": "python regex validity check", "code": "def is_valid_regex(string):\n    \"\"\"\n    Checks whether the re module can compile the given regular expression.\n\n    Parameters\n    ----------\n    string: str\n\n    Returns\n    -------\n    boolean\n    \"\"\"\n    try:\n        re.compile(string)\n        is_valid = True\n    except re.error:\n        is_valid = False\n    return is_valid", "code_tokens": "def is_valid_regex ( string ) : try : re . compile ( string ) is_valid = True except re . error : is_valid = False return is_valid", "docstring_tokens": "Checks whether the re module can compile the given regular expression .", "label": 1}, {"idx": "cosqa-train-1154", "doc": "how to make a clone of something in python", "code": "def _makes_clone(_func, *args, **kw):\n    \"\"\"\n    A decorator that returns a clone of the current object so that\n    we can re-use the object for similar requests.\n    \"\"\"\n    self = args[0]._clone()\n    _func(self, *args[1:], **kw)\n    return self", "code_tokens": "def _makes_clone ( _func , * args , * * kw ) : self = args [ 0 ] . _clone ( ) _func ( self , * args [ 1 : ] , * * kw ) return self", "docstring_tokens": "A decorator that returns a clone of the current object so that we can re - use the object for similar requests .", "label": 0}, {"idx": "cosqa-train-1155", "doc": "python regression with constraint", "code": "def linregress(x, y, return_stats=False):\n    \"\"\"linear regression calculation\n\n    Parameters\n    ----\n    x :         independent variable (series)\n    y :         dependent variable (series)\n    return_stats : returns statistical values as well if required (bool)\n    \n\n    Returns\n    ----\n    list of parameters (and statistics)\n    \"\"\"\n    a1, a0, r_value, p_value, stderr = scipy.stats.linregress(x, y)\n\n    retval = a1, a0\n    if return_stats:\n        retval += r_value, p_value, stderr\n\n    return retval", "code_tokens": "def linregress ( x , y , return_stats = False ) : a1 , a0 , r_value , p_value , stderr = scipy . stats . linregress ( x , y ) retval = a1 , a0 if return_stats : retval += r_value , p_value , stderr return retval", "docstring_tokens": "linear regression calculation", "label": 1}, {"idx": "cosqa-train-1156", "doc": "how to make a column a comma separated list in python", "code": "def linedelimited (inlist,delimiter):\n    \"\"\"\nReturns a string composed of elements in inlist, with each element\nseparated by 'delimiter.'  Used by function writedelimited.  Use '\\t'\nfor tab-delimiting.\n\nUsage:   linedelimited (inlist,delimiter)\n\"\"\"\n    outstr = ''\n    for item in inlist:\n        if type(item) != StringType:\n            item = str(item)\n        outstr = outstr + item + delimiter\n    outstr = outstr[0:-1]\n    return outstr", "code_tokens": "def linedelimited ( inlist , delimiter ) : outstr = '' for item in inlist : if type ( item ) != StringType : item = str ( item ) outstr = outstr + item + delimiter outstr = outstr [ 0 : - 1 ] return outstr", "docstring_tokens": "Returns a string composed of elements in inlist with each element separated by delimiter . Used by function writedelimited . Use \\ t for tab - delimiting .", "label": 0}, {"idx": "cosqa-train-1157", "doc": "python reindex to multindex", "code": "def validate_multiindex(self, obj):\n        \"\"\"validate that we can store the multi-index; reset and return the\n        new object\n        \"\"\"\n        levels = [l if l is not None else \"level_{0}\".format(i)\n                  for i, l in enumerate(obj.index.names)]\n        try:\n            return obj.reset_index(), levels\n        except ValueError:\n            raise ValueError(\"duplicate names/columns in the multi-index when \"\n                             \"storing as a table\")", "code_tokens": "def validate_multiindex ( self , obj ) : levels = [ l if l is not None else \"level_{0}\" . format ( i ) for i , l in enumerate ( obj . index . names ) ] try : return obj . reset_index ( ) , levels except ValueError : raise ValueError ( \"duplicate names/columns in the multi-index when \" \"storing as a table\" )", "docstring_tokens": "validate that we can store the multi - index ; reset and return the new object", "label": 0}, {"idx": "cosqa-train-1158", "doc": "how to make a custom messagebox python tkinter", "code": "def alert(text='', title='', button=OK_TEXT, root=None, timeout=None):\n    \"\"\"Displays a simple message box with text and a single OK button. Returns the text of the button clicked on.\"\"\"\n    assert TKINTER_IMPORT_SUCCEEDED, 'Tkinter is required for pymsgbox'\n    return _buttonbox(msg=text, title=title, choices=[str(button)], root=root, timeout=timeout)", "code_tokens": "def alert ( text = '' , title = '' , button = OK_TEXT , root = None , timeout = None ) : assert TKINTER_IMPORT_SUCCEEDED , 'Tkinter is required for pymsgbox' return _buttonbox ( msg = text , title = title , choices = [ str ( button ) ] , root = root , timeout = timeout )", "docstring_tokens": "Displays a simple message box with text and a single OK button . Returns the text of the button clicked on .", "label": 0}, {"idx": "cosqa-train-1159", "doc": "python reindexing only valid with uniquely valued index objects", "code": "def cmd_reindex():\n    \"\"\"Uses CREATE INDEX CONCURRENTLY to create a duplicate index, then tries to swap the new index for the original.\n\n    The index swap is done using a short lock timeout to prevent it from interfering with running queries. Retries until\n    the rename succeeds.\n    \"\"\"\n    db = connect(args.database)\n    for idx in args.indexes:\n        pg_reindex(db, idx)", "code_tokens": "def cmd_reindex ( ) : db = connect ( args . database ) for idx in args . indexes : pg_reindex ( db , idx )", "docstring_tokens": "Uses CREATE INDEX CONCURRENTLY to create a duplicate index then tries to swap the new index for the original .", "label": 0}, {"idx": "cosqa-train-1160", "doc": "how to make a list not case sensitive in python", "code": "def list_add_capitalize(l):\n    \"\"\"\n    @type l: list\n    @return: list\n    \"\"\"\n    nl = []\n\n    for i in l:\n        nl.append(i)\n\n        if hasattr(i, \"capitalize\"):\n            nl.append(i.capitalize())\n\n    return list(set(nl))", "code_tokens": "def list_add_capitalize ( l ) : nl = [ ] for i in l : nl . append ( i ) if hasattr ( i , \"capitalize\" ) : nl . append ( i . capitalize ( ) ) return list ( set ( nl ) )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-1161", "doc": "python reload page drop down", "code": "def update_redirect(self):\n        \"\"\"\n            Call it on your own endpoint's to update the back history navigation.\n            If you bypass it, the next submit or back will go over it.\n        \"\"\"\n        page_history = Stack(session.get(\"page_history\", []))\n        page_history.push(request.url)\n        session[\"page_history\"] = page_history.to_json()", "code_tokens": "def update_redirect ( self ) : page_history = Stack ( session . get ( \"page_history\" , [ ] ) ) page_history . push ( request . url ) session [ \"page_history\" ] = page_history . to_json ( )", "docstring_tokens": "Call it on your own endpoint s to update the back history navigation . If you bypass it the next submit or back will go over it .", "label": 0}, {"idx": "cosqa-train-1162", "doc": "how to make a list the coloumn names for an sql in python", "code": "def get_column_keys_and_names(table):\n    \"\"\"\n    Return a generator of tuples k, c such that k is the name of the python attribute for\n    the column and c is the name of the column in the sql table.\n    \"\"\"\n    ins = inspect(table)\n    return ((k, c.name) for k, c in ins.mapper.c.items())", "code_tokens": "def get_column_keys_and_names ( table ) : ins = inspect ( table ) return ( ( k , c . name ) for k , c in ins . mapper . c . items ( ) )", "docstring_tokens": "Return a generator of tuples k c such that k is the name of the python attribute for the column and c is the name of the column in the sql table .", "label": 0}, {"idx": "cosqa-train-1163", "doc": "python remove a list of keyes from dict", "code": "def filter_dict_by_key(d, keys):\n    \"\"\"Filter the dict *d* to remove keys not in *keys*.\"\"\"\n    return {k: v for k, v in d.items() if k in keys}", "code_tokens": "def filter_dict_by_key ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "docstring_tokens": "Filter the dict * d * to remove keys not in * keys * .", "label": 0}, {"idx": "cosqa-train-1164", "doc": "how to make a list words out sentence in python", "code": "def sent2features(sentence, template):\n    \"\"\" extract features in a sentence\n\n    :type sentence: list of token, each token is a list of tag\n    \"\"\"\n    return [word2features(sentence, i, template) for i in range(len(sentence))]", "code_tokens": "def sent2features ( sentence , template ) : return [ word2features ( sentence , i , template ) for i in range ( len ( sentence ) ) ]", "docstring_tokens": "extract features in a sentence", "label": 0}, {"idx": "cosqa-train-1165", "doc": "python remove all tab and whitespace", "code": "def handle_whitespace(text):\n    r\"\"\"Handles whitespace cleanup.\n\n    Tabs are \"smartly\" retabbed (see sub_retab). Lines that contain\n    only whitespace are truncated to a single newline.\n    \"\"\"\n    text = re_retab.sub(sub_retab, text)\n    text = re_whitespace.sub('', text).strip()\n    return text", "code_tokens": "def handle_whitespace ( text ) : text = re_retab . sub ( sub_retab , text ) text = re_whitespace . sub ( '' , text ) . strip ( ) return text", "docstring_tokens": "r Handles whitespace cleanup .", "label": 0}, {"idx": "cosqa-train-1166", "doc": "how to make a neat table in python", "code": "def get_table(ports):\n    \"\"\"\n    This function returns a pretty table used to display the port results.\n\n    :param ports: list of found ports\n    :return: the table to display\n    \"\"\"\n    table = PrettyTable([\"Name\", \"Port\", \"Protocol\", \"Description\"])\n    table.align[\"Name\"] = \"l\"\n    table.align[\"Description\"] = \"l\"\n    table.padding_width = 1\n\n    for port in ports:\n        table.add_row(port)\n\n    return table", "code_tokens": "def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "docstring_tokens": "This function returns a pretty table used to display the port results .", "label": 0}, {"idx": "cosqa-train-1167", "doc": "python remove all zeros from list", "code": "def _remove_blank(l):\n        \"\"\" Removes trailing zeros in the list of integers and returns a new list of integers\"\"\"\n        ret = []\n        for i, _ in enumerate(l):\n            if l[i] == 0:\n                break\n            ret.append(l[i])\n        return ret", "code_tokens": "def _remove_blank ( l ) : ret = [ ] for i , _ in enumerate ( l ) : if l [ i ] == 0 : break ret . append ( l [ i ] ) return ret", "docstring_tokens": "Removes trailing zeros in the list of integers and returns a new list of integers", "label": 0}, {"idx": "cosqa-train-1168", "doc": "how to make a python print go to the next line", "code": "def erase_lines(n=1):\n    \"\"\" Erases n lines from the screen and moves the cursor up to follow\n    \"\"\"\n    for _ in range(n):\n        print(codes.cursor[\"up\"], end=\"\")\n        print(codes.cursor[\"eol\"], end=\"\")", "code_tokens": "def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ \"up\" ] , end = \"\" ) print ( codes . cursor [ \"eol\" ] , end = \"\" )", "docstring_tokens": "Erases n lines from the screen and moves the cursor up to follow", "label": 0}, {"idx": "cosqa-train-1169", "doc": "python remove colored output from shell", "code": "def auto():\n\t\"\"\"set colouring on if STDOUT is a terminal device, off otherwise\"\"\"\n\ttry:\n\t\tStyle.enabled = False\n\t\tStyle.enabled = sys.stdout.isatty()\n\texcept (AttributeError, TypeError):\n\t\tpass", "code_tokens": "def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass", "docstring_tokens": "set colouring on if STDOUT is a terminal device off otherwise", "label": 0}, {"idx": "cosqa-train-1170", "doc": "how to make a smaller sphere in python", "code": "def Fsphere(q, R):\n    \"\"\"Scattering form-factor amplitude of a sphere normalized to F(q=0)=V\n\n    Inputs:\n    -------\n        ``q``: independent variable\n        ``R``: sphere radius\n\n    Formula:\n    --------\n        ``4*pi/q^3 * (sin(qR) - qR*cos(qR))``\n    \"\"\"\n    return 4 * np.pi / q ** 3 * (np.sin(q * R) - q * R * np.cos(q * R))", "code_tokens": "def Fsphere ( q , R ) : return 4 * np . pi / q ** 3 * ( np . sin ( q * R ) - q * R * np . cos ( q * R ) )", "docstring_tokens": "Scattering form - factor amplitude of a sphere normalized to F ( q = 0 ) = V", "label": 0}, {"idx": "cosqa-train-1171", "doc": "python remove dict values based", "code": "def _remove_dict_keys_with_value(dict_, val):\n  \"\"\"Removes `dict` keys which have have `self` as value.\"\"\"\n  return {k: v for k, v in dict_.items() if v is not val}", "code_tokens": "def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }", "docstring_tokens": "Removes dict keys which have have self as value .", "label": 0}, {"idx": "cosqa-train-1172", "doc": "how to make a square plot in python aspect ratio", "code": "def figsize(x=8, y=7., aspect=1.):\n    \"\"\" manually set the default figure size of plots\n    ::Arguments::\n        x (float): x-axis size\n        y (float): y-axis size\n        aspect (float): aspect ratio scalar\n    \"\"\"\n    # update rcparams with adjusted figsize params\n    mpl.rcParams.update({'figure.figsize': (x*aspect, y)})", "code_tokens": "def figsize ( x = 8 , y = 7. , aspect = 1. ) : # update rcparams with adjusted figsize params mpl . rcParams . update ( { 'figure.figsize' : ( x * aspect , y ) } )", "docstring_tokens": "manually set the default figure size of plots :: Arguments :: x ( float ) : x - axis size y ( float ) : y - axis size aspect ( float ) : aspect ratio scalar", "label": 1}, {"idx": "cosqa-train-1173", "doc": "how to make a string full caps with python", "code": "def to_identifier(s):\n  \"\"\"\n  Convert snake_case to camel_case.\n  \"\"\"\n  if s.startswith('GPS'):\n      s = 'Gps' + s[3:]\n  return ''.join([i.capitalize() for i in s.split('_')]) if '_' in s else s", "code_tokens": "def to_identifier ( s ) : if s . startswith ( 'GPS' ) : s = 'Gps' + s [ 3 : ] return '' . join ( [ i . capitalize ( ) for i in s . split ( '_' ) ] ) if '_' in s else s", "docstring_tokens": "Convert snake_case to camel_case .", "label": 0}, {"idx": "cosqa-train-1174", "doc": "python remove every other item in list", "code": "def unique(_list):\n    \"\"\"\n    Makes the list have unique items only and maintains the order\n\n    list(set()) won't provide that\n\n    :type _list list\n    :rtype: list\n    \"\"\"\n    ret = []\n\n    for item in _list:\n        if item not in ret:\n            ret.append(item)\n\n    return ret", "code_tokens": "def unique ( _list ) : ret = [ ] for item in _list : if item not in ret : ret . append ( item ) return ret", "docstring_tokens": "Makes the list have unique items only and maintains the order", "label": 0}, {"idx": "cosqa-train-1175", "doc": "how to make a string that removes vowels in python", "code": "def vowels(self):\n        \"\"\"\n        Return a new IPAString, containing only the vowels in the current string.\n\n        :rtype: IPAString\n        \"\"\"\n        return IPAString(ipa_chars=[c for c in self.ipa_chars if c.is_vowel])", "code_tokens": "def vowels ( self ) : return IPAString ( ipa_chars = [ c for c in self . ipa_chars if c . is_vowel ] )", "docstring_tokens": "Return a new IPAString containing only the vowels in the current string .", "label": 0}, {"idx": "cosqa-train-1176", "doc": "python remove first n itrems from list", "code": "def prune(self, n):\n        \"\"\"prune all but the first (=best) n items\"\"\"\n        if self.minimize:\n            self.data = self.data[:n]\n        else:\n            self.data = self.data[-1 * n:]", "code_tokens": "def prune ( self , n ) : if self . minimize : self . data = self . data [ : n ] else : self . data = self . data [ - 1 * n : ]", "docstring_tokens": "prune all but the first ( = best ) n items", "label": 0}, {"idx": "cosqa-train-1177", "doc": "how to make a submit button in html run python", "code": "def submitbutton(self, request, tag):\n        \"\"\"\n        Render an INPUT element of type SUBMIT which will post this form to the\n        server.\n        \"\"\"\n        return tags.input(type='submit',\n                          name='__submit__',\n                          value=self._getDescription())", "code_tokens": "def submitbutton ( self , request , tag ) : return tags . input ( type = 'submit' , name = '__submit__' , value = self . _getDescription ( ) )", "docstring_tokens": "Render an INPUT element of type SUBMIT which will post this form to the server .", "label": 0}, {"idx": "cosqa-train-1178", "doc": "python remove folder recursively", "code": "def rrmdir(directory):\n    \"\"\"\n    Recursivly delete a directory\n\n    :param directory: directory to remove\n    \"\"\"\n    for root, dirs, files in os.walk(directory, topdown=False):\n        for name in files:\n            os.remove(os.path.join(root, name))\n        for name in dirs:\n            os.rmdir(os.path.join(root, name))\n    os.rmdir(directory)", "code_tokens": "def rrmdir ( directory ) : for root , dirs , files in os . walk ( directory , topdown = False ) : for name in files : os . remove ( os . path . join ( root , name ) ) for name in dirs : os . rmdir ( os . path . join ( root , name ) ) os . rmdir ( directory )", "docstring_tokens": "Recursivly delete a directory", "label": 0}, {"idx": "cosqa-train-1179", "doc": "how to make all elements in array as list elements python", "code": "def flatten_list(l):\n    \"\"\" Nested lists to single-level list, does not split strings\"\"\"\n    return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "code_tokens": "def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )", "docstring_tokens": "Nested lists to single - level list does not split strings", "label": 0}, {"idx": "cosqa-train-1180", "doc": "python remove key from dictionary if key value", "code": "def rm_keys_from_dict(d, keys):\n    \"\"\"\n    Given a dictionary and a key list, remove any data in the dictionary with the given keys.\n\n    :param dict d: Metadata\n    :param list keys: Keys to be removed\n    :return dict d: Metadata\n    \"\"\"\n    # Loop for each key given\n    for key in keys:\n        # Is the key in the dictionary?\n        if key in d:\n            try:\n                d.pop(key, None)\n            except KeyError:\n                # Not concerned with an error. Keep going.\n                pass\n    return d", "code_tokens": "def rm_keys_from_dict ( d , keys ) : # Loop for each key given for key in keys : # Is the key in the dictionary? if key in d : try : d . pop ( key , None ) except KeyError : # Not concerned with an error. Keep going. pass return d", "docstring_tokens": "Given a dictionary and a key list remove any data in the dictionary with the given keys .", "label": 0}, {"idx": "cosqa-train-1181", "doc": "how to make an ellipse in python", "code": "def create_ellipse(width,height,angle):\n    \"\"\"Create parametric ellipse from 200 points.\"\"\"\n    angle = angle / 180.0 * np.pi\n    thetas = np.linspace(0,2*np.pi,200)\n    a = width / 2.0\n    b = height / 2.0\n\n    x = a*np.cos(thetas)*np.cos(angle) - b*np.sin(thetas)*np.sin(angle)\n    y = a*np.cos(thetas)*np.sin(angle) + b*np.sin(thetas)*np.cos(angle)\n    z = np.zeros(thetas.shape)\n    return np.vstack((x,y,z)).T", "code_tokens": "def create_ellipse ( width , height , angle ) : angle = angle / 180.0 * np . pi thetas = np . linspace ( 0 , 2 * np . pi , 200 ) a = width / 2.0 b = height / 2.0 x = a * np . cos ( thetas ) * np . cos ( angle ) - b * np . sin ( thetas ) * np . sin ( angle ) y = a * np . cos ( thetas ) * np . sin ( angle ) + b * np . sin ( thetas ) * np . cos ( angle ) z = np . zeros ( thetas . shape ) return np . vstack ( ( x , y , z ) ) . T", "docstring_tokens": "Create parametric ellipse from 200 points .", "label": 0}, {"idx": "cosqa-train-1182", "doc": "python remove none dict value", "code": "def purge_dict(idict):\n    \"\"\"Remove null items from a dictionary \"\"\"\n    odict = {}\n    for key, val in idict.items():\n        if is_null(val):\n            continue\n        odict[key] = val\n    return odict", "code_tokens": "def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict", "docstring_tokens": "Remove null items from a dictionary", "label": 0}, {"idx": "cosqa-train-1183", "doc": "how to make black background for python", "code": "def set_color(self, fg=None, bg=None, intensify=False, target=sys.stdout):\n        \"\"\"Set foreground- and background colors and intensity.\"\"\"\n        raise NotImplementedError", "code_tokens": "def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError", "docstring_tokens": "Set foreground - and background colors and intensity .", "label": 0}, {"idx": "cosqa-train-1184", "doc": "python remove the ith element", "code": "def pop(self, index=-1):\n\t\t\"\"\"Remove and return the item at index.\"\"\"\n\t\tvalue = self._list.pop(index)\n\t\tdel self._dict[value]\n\t\treturn value", "code_tokens": "def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value", "docstring_tokens": "Remove and return the item at index .", "label": 0}, {"idx": "cosqa-train-1185", "doc": "how to make boolean column python based on several criteria", "code": "def selecttrue(table, field, complement=False):\n    \"\"\"Select rows where the given field evaluates `True`.\"\"\"\n\n    return select(table, field, lambda v: bool(v), complement=complement)", "code_tokens": "def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )", "docstring_tokens": "Select rows where the given field evaluates True .", "label": 0}, {"idx": "cosqa-train-1186", "doc": "python removing accents from words", "code": "def unaccentuate(s):\n    \"\"\" Replace accentuated chars in string by their non accentuated equivalent. \"\"\"\n    return \"\".join(c for c in unicodedata.normalize(\"NFKD\", s) if not unicodedata.combining(c))", "code_tokens": "def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "docstring_tokens": "Replace accentuated chars in string by their non accentuated equivalent .", "label": 0}, {"idx": "cosqa-train-1187", "doc": "how to make booleans in python global", "code": "def less_strict_bool(x):\n    \"\"\"Idempotent and None-safe version of strict_bool.\"\"\"\n    if x is None:\n        return False\n    elif x is True or x is False:\n        return x\n    else:\n        return strict_bool(x)", "code_tokens": "def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )", "docstring_tokens": "Idempotent and None - safe version of strict_bool .", "label": 1}, {"idx": "cosqa-train-1188", "doc": "python replace a pattern regex iterative", "code": "def subn_filter(s, find, replace, count=0):\n    \"\"\"A non-optimal implementation of a regex filter\"\"\"\n    return re.gsub(find, replace, count, s)", "code_tokens": "def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )", "docstring_tokens": "A non - optimal implementation of a regex filter", "label": 0}, {"idx": "cosqa-train-1189", "doc": "how to make centered text in python", "code": "def center_text(text, width=80):\n    \"\"\"Center all lines of the text.\n\n    It is assumed that all lines width is smaller then B{width}, because the\n    line width will not be checked.\n\n    Args:\n        text (str): Text to wrap.\n        width (int): Maximum number of characters per line.\n\n    Returns:\n        str: Centered text.\n    \"\"\"\n    centered = []\n    for line in text.splitlines():\n        centered.append(line.center(width))\n    return \"\\n\".join(centered)", "code_tokens": "def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return \"\\n\" . join ( centered )", "docstring_tokens": "Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text .", "label": 0}, {"idx": "cosqa-train-1190", "doc": "python replace dos slash with unix slash", "code": "def __unixify(self, s):\n        \"\"\" stupid windows. converts the backslash to forwardslash for consistency \"\"\"\n        return os.path.normpath(s).replace(os.sep, \"/\")", "code_tokens": "def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , \"/\" )", "docstring_tokens": "stupid windows . converts the backslash to forwardslash for consistency", "label": 0}, {"idx": "cosqa-train-1191", "doc": "how to make multiple slices in a list in python", "code": "def batch(items, size):\n    \"\"\"Batches a list into a list of lists, with sub-lists sized by a specified\n    batch size.\"\"\"\n    return [items[x:x + size] for x in xrange(0, len(items), size)]", "code_tokens": "def batch ( items , size ) : return [ items [ x : x + size ] for x in xrange ( 0 , len ( items ) , size ) ]", "docstring_tokens": "Batches a list into a list of lists with sub - lists sized by a specified batch size .", "label": 1}, {"idx": "cosqa-train-1192", "doc": "python replace text between two strings", "code": "def multi_replace(instr, search_list=[], repl_list=None):\n    \"\"\"\n    Does a string replace with a list of search and replacements\n\n    TODO: rename\n    \"\"\"\n    repl_list = [''] * len(search_list) if repl_list is None else repl_list\n    for ser, repl in zip(search_list, repl_list):\n        instr = instr.replace(ser, repl)\n    return instr", "code_tokens": "def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr", "docstring_tokens": "Does a string replace with a list of search and replacements", "label": 0}, {"idx": "cosqa-train-1193", "doc": "how to make python generate relations", "code": "def configure_relation(graph, ns, mappings):\n    \"\"\"\n    Register relation endpoint(s) between two resources.\n\n    \"\"\"\n    convention = RelationConvention(graph)\n    convention.configure(ns, mappings)", "code_tokens": "def configure_relation ( graph , ns , mappings ) : convention = RelationConvention ( graph ) convention . configure ( ns , mappings )", "docstring_tokens": "Register relation endpoint ( s ) between two resources .", "label": 0}, {"idx": "cosqa-train-1194", "doc": "python replacing value with nan conditionally", "code": "def _replace_nan(a, val):\n    \"\"\"\n    replace nan in a by val, and returns the replaced array and the nan\n    position\n    \"\"\"\n    mask = isnull(a)\n    return where_method(val, mask, a), mask", "code_tokens": "def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask", "docstring_tokens": "replace nan in a by val and returns the replaced array and the nan position", "label": 0}, {"idx": "cosqa-train-1195", "doc": "how to make python print different colors in command line", "code": "def cprint(string, fg=None, bg=None, end='\\n', target=sys.stdout):\n    \"\"\"Print a colored string to the target handle.\n\n    fg and bg specify foreground- and background colors, respectively. The\n    remaining keyword arguments are the same as for Python's built-in print\n    function. Colors are returned to their defaults before the function\n    returns.\n\n    \"\"\"\n    _color_manager.set_color(fg, bg)\n    target.write(string + end)\n    target.flush()  # Needed for Python 3.x\n    _color_manager.set_defaults()", "code_tokens": "def cprint ( string , fg = None , bg = None , end = '\\n' , target = sys . stdout ) : _color_manager . set_color ( fg , bg ) target . write ( string + end ) target . flush ( ) # Needed for Python 3.x _color_manager . set_defaults ( )", "docstring_tokens": "Print a colored string to the target handle .", "label": 0}, {"idx": "cosqa-train-1196", "doc": "python request get json type response", "code": "def http_request_json(*args, **kwargs):\n    \"\"\"\n\n    See: http_request\n    \"\"\"\n    ret, status = http_request(*args, **kwargs)\n    return json.loads(ret), status", "code_tokens": "def http_request_json ( * args , * * kwargs ) : ret , status = http_request ( * args , * * kwargs ) return json . loads ( ret ) , status", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-1197", "doc": "how to make python print in one line", "code": "def stdoutwriteline(*args):\n    \"\"\"\n    @type args: tuple\n    @return: None\n    \"\"\"\n    s = \"\"\n\n    for i in args:\n        s += str(i) + \" \"\n\n    s = s.strip()\n    sys.stdout.write(str(s) + \"\\n\")\n    sys.stdout.flush()\n\n    return s", "code_tokens": "def stdoutwriteline ( * args ) : s = \"\" for i in args : s += str ( i ) + \" \" s = s . strip ( ) sys . stdout . write ( str ( s ) + \"\\n\" ) sys . stdout . flush ( ) return s", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-1198", "doc": "python request user agent chrome", "code": "def copy_user_agent_from_driver(self):\n        \"\"\" Updates requests' session user-agent with the driver's user agent\n\n        This method will start the browser process if its not already running.\n        \"\"\"\n        selenium_user_agent = self.driver.execute_script(\"return navigator.userAgent;\")\n        self.headers.update({\"user-agent\": selenium_user_agent})", "code_tokens": "def copy_user_agent_from_driver ( self ) : selenium_user_agent = self . driver . execute_script ( \"return navigator.userAgent;\" ) self . headers . update ( { \"user-agent\" : selenium_user_agent } )", "docstring_tokens": "Updates requests session user - agent with the driver s user agent", "label": 0}, {"idx": "cosqa-train-1199", "doc": "how to make python print something to a printer", "code": "def _show(self, message, indent=0, enable_verbose=True):  # pragma: no cover\n        \"\"\"Message printer.\n        \"\"\"\n        if enable_verbose:\n            print(\"    \" * indent + message)", "code_tokens": "def _show ( self , message , indent = 0 , enable_verbose = True ) : # pragma: no cover if enable_verbose : print ( \"    \" * indent + message )", "docstring_tokens": "Message printer .", "label": 0}, {"idx": "cosqa-train-1200", "doc": "python requests save session for future use", "code": "def save_session_to_file(self, sessionfile):\n        \"\"\"Not meant to be used directly, use :meth:`Instaloader.save_session_to_file`.\"\"\"\n        pickle.dump(requests.utils.dict_from_cookiejar(self._session.cookies), sessionfile)", "code_tokens": "def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )", "docstring_tokens": "Not meant to be used directly use : meth : Instaloader . save_session_to_file .", "label": 0}, {"idx": "cosqa-train-1201", "doc": "how to make python round a float to int", "code": "def intround(value):\n    \"\"\"Given a float returns a rounded int. Should give the same result on\n    both Py2/3\n    \"\"\"\n\n    return int(decimal.Decimal.from_float(\n        value).to_integral_value(decimal.ROUND_HALF_EVEN))", "code_tokens": "def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )", "docstring_tokens": "Given a float returns a rounded int . Should give the same result on both Py2 / 3", "label": 1}, {"idx": "cosqa-train-1202", "doc": "python requests see if port open", "code": "def is_http_running_on(port):\n  \"\"\" Check if an http server runs on a given port.\n\n  Args:\n    The port to check.\n  Returns:\n    True if it is used by an http server. False otherwise.\n  \"\"\"\n  try:\n    conn = httplib.HTTPConnection('127.0.0.1:' + str(port))\n    conn.connect()\n    conn.close()\n    return True\n  except Exception:\n    return False", "code_tokens": "def is_http_running_on ( port ) : try : conn = httplib . HTTPConnection ( '127.0.0.1:' + str ( port ) ) conn . connect ( ) conn . close ( ) return True except Exception : return False", "docstring_tokens": "Check if an http server runs on a given port .", "label": 0}, {"idx": "cosqa-train-1203", "doc": "python requests set request encoding", "code": "def download(url, encoding='utf-8'):\n    \"\"\"Returns the text fetched via http GET from URL, read as `encoding`\"\"\"\n    import requests\n    response = requests.get(url)\n    response.encoding = encoding\n    return response.text", "code_tokens": "def download ( url , encoding = 'utf-8' ) : import requests response = requests . get ( url ) response . encoding = encoding return response . text", "docstring_tokens": "Returns the text fetched via http GET from URL read as encoding", "label": 0}, {"idx": "cosqa-train-1204", "doc": "how to make sentence to list of words python", "code": "def sent2features(sentence, template):\n    \"\"\" extract features in a sentence\n\n    :type sentence: list of token, each token is a list of tag\n    \"\"\"\n    return [word2features(sentence, i, template) for i in range(len(sentence))]", "code_tokens": "def sent2features ( sentence , template ) : return [ word2features ( sentence , i , template ) for i in range ( len ( sentence ) ) ]", "docstring_tokens": "extract features in a sentence", "label": 0}, {"idx": "cosqa-train-1205", "doc": "python reset or clear plot", "code": "def clear(self):\n        \"\"\" clear plot \"\"\"\n        self.axes.cla()\n        self.conf.ntrace = 0\n        self.conf.xlabel = ''\n        self.conf.ylabel = ''\n        self.conf.title  = ''", "code_tokens": "def clear ( self ) : self . axes . cla ( ) self . conf . ntrace = 0 self . conf . xlabel = '' self . conf . ylabel = '' self . conf . title = ''", "docstring_tokens": "clear plot", "label": 0}, {"idx": "cosqa-train-1206", "doc": "how to make something follow the mouse python", "code": "def __init__(self, pos, cell, motion, cellmotion):\n        self.pos = pos\n        \"\"\"(x, y) position of the mouse on the screen.\n        type: (int, int)\"\"\"\n        self.cell = cell\n        \"\"\"(x, y) position of the mouse snapped to a cell on the root console.\n        type: (int, int)\"\"\"\n        self.motion = motion\n        \"\"\"(x, y) motion of the mouse on the screen.\n        type: (int, int)\"\"\"\n        self.cellmotion = cellmotion\n        \"\"\"(x, y) mostion of the mouse moving over cells on the root console.\n        type: (int, int)\"\"\"", "code_tokens": "def __init__ ( self , pos , cell , motion , cellmotion ) : self . pos = pos self . cell = cell \"\"\"(x, y) position of the mouse snapped to a cell on the root console.\n        type: (int, int)\"\"\" self . motion = motion \"\"\"(x, y) motion of the mouse on the screen.\n        type: (int, int)\"\"\" self . cellmotion = cellmotion \"\"\"(x, y) mostion of the mouse moving over cells on the root console.\n        type: (int, int)\"\"\"", "docstring_tokens": "( x y ) position of the mouse on the screen . type : ( int int )", "label": 0}, {"idx": "cosqa-train-1207", "doc": "python resize array with none", "code": "def resize(self, size):\n\t\t\"\"\" Resize current array. If size is None, then array became nonfixed-length array. If new size is\n\t\tless then current size and value, then value will be truncated (lesser significant bits will be\n\t\ttruncated).\n\n\t\t:param size:\n\t\t:return:\n\t\t\"\"\"\n\t\tif size is not None:\n\t\t\tself.__value = int(WBinArray(self.__value)[:size])\n\t\tself.__size = size", "code_tokens": "def resize ( self , size ) : if size is not None : self . __value = int ( WBinArray ( self . __value ) [ : size ] ) self . __size = size", "docstring_tokens": "Resize current array . If size is None then array became nonfixed - length array . If new size is less then current size and value then value will be truncated ( lesser significant bits will be truncated ) .", "label": 0}, {"idx": "cosqa-train-1208", "doc": "how to make special method for print python", "code": "def print_out(self, *lst):\n      \"\"\" Print list of strings to the predefined stdout. \"\"\"\n      self.print2file(self.stdout, True, True, *lst)", "code_tokens": "def print_out ( self , * lst ) : self . print2file ( self . stdout , True , True , * lst )", "docstring_tokens": "Print list of strings to the predefined stdout .", "label": 0}, {"idx": "cosqa-train-1209", "doc": "python response raise for status", "code": "def raise_for_not_ok_status(response):\n    \"\"\"\n    Raises a `requests.exceptions.HTTPError` if the response has a non-200\n    status code.\n    \"\"\"\n    if response.code != OK:\n        raise HTTPError('Non-200 response code (%s) for url: %s' % (\n            response.code, uridecode(response.request.absoluteURI)))\n\n    return response", "code_tokens": "def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response", "docstring_tokens": "Raises a requests . exceptions . HTTPError if the response has a non - 200 status code .", "label": 1}, {"idx": "cosqa-train-1210", "doc": "how to make the cursor disappear on python", "code": "def disable_busy_cursor():\n    \"\"\"Disable the hourglass cursor and listen for layer changes.\"\"\"\n    while QgsApplication.instance().overrideCursor() is not None and \\\n            QgsApplication.instance().overrideCursor().shape() == \\\n            QtCore.Qt.WaitCursor:\n        QgsApplication.instance().restoreOverrideCursor()", "code_tokens": "def disable_busy_cursor ( ) : while QgsApplication . instance ( ) . overrideCursor ( ) is not None and QgsApplication . instance ( ) . overrideCursor ( ) . shape ( ) == QtCore . Qt . WaitCursor : QgsApplication . instance ( ) . restoreOverrideCursor ( )", "docstring_tokens": "Disable the hourglass cursor and listen for layer changes .", "label": 0}, {"idx": "cosqa-train-1211", "doc": "python response to text", "code": "async def json_or_text(response):\n    \"\"\"Turns response into a properly formatted json or text object\"\"\"\n    text = await response.text()\n    if response.headers['Content-Type'] == 'application/json; charset=utf-8':\n        return json.loads(text)\n    return text", "code_tokens": "async def json_or_text ( response ) : text = await response . text ( ) if response . headers [ 'Content-Type' ] == 'application/json; charset=utf-8' : return json . loads ( text ) return text", "docstring_tokens": "Turns response into a properly formatted json or text object", "label": 0}, {"idx": "cosqa-train-1212", "doc": "how to make username and password login on python", "code": "def get_auth():\n    \"\"\"Get authentication.\"\"\"\n    import getpass\n    user = input(\"User Name: \")  # noqa\n    pswd = getpass.getpass('Password: ')\n    return Github(user, pswd)", "code_tokens": "def get_auth ( ) : import getpass user = input ( \"User Name: \" ) # noqa pswd = getpass . getpass ( 'Password: ' ) return Github ( user , pswd )", "docstring_tokens": "Get authentication .", "label": 0}, {"idx": "cosqa-train-1213", "doc": "python rest docstring for kwargs", "code": "def http(self, *args, **kwargs):\n        \"\"\"Starts the process of building a new HTTP route linked to this API instance\"\"\"\n        kwargs['api'] = self.api\n        return http(*args, **kwargs)", "code_tokens": "def http ( self , * args , * * kwargs ) : kwargs [ 'api' ] = self . api return http ( * args , * * kwargs )", "docstring_tokens": "Starts the process of building a new HTTP route linked to this API instance", "label": 0}, {"idx": "cosqa-train-1214", "doc": "how to make variables case insensitive in python", "code": "def ILIKE(pattern):\n    \"\"\"Unix shell-style wildcards. Case-insensitive\"\"\"\n    return P(lambda x: fnmatch.fnmatch(x.lower(), pattern.lower()))", "code_tokens": "def ILIKE ( pattern ) : return P ( lambda x : fnmatch . fnmatch ( x . lower ( ) , pattern . lower ( ) ) )", "docstring_tokens": "Unix shell - style wildcards . Case - insensitive", "label": 0}, {"idx": "cosqa-train-1215", "doc": "python rest self document", "code": "def documentation(self):\n        \"\"\"\n        Get the documentation that the server sends for the API.\n        \"\"\"\n        newclient = self.__class__(self.session, self.root_url)\n        return newclient.get_raw('/')", "code_tokens": "def documentation ( self ) : newclient = self . __class__ ( self . session , self . root_url ) return newclient . get_raw ( '/' )", "docstring_tokens": "Get the documentation that the server sends for the API .", "label": 0}, {"idx": "cosqa-train-1216", "doc": "how to mass de indent python", "code": "def _add_indent(string, indent):\n    \"\"\"Add indent of ``indent`` spaces to ``string.split(\"\\n\")[1:]``\n\n    Useful for formatting in strings to already indented blocks\n    \"\"\"\n    lines = string.split(\"\\n\")\n    first, lines = lines[0], lines[1:]\n    lines = [\"{indent}{s}\".format(indent=\" \" * indent, s=s)\n             for s in lines]\n    lines = [first] + lines\n    return \"\\n\".join(lines)", "code_tokens": "def _add_indent ( string , indent ) : lines = string . split ( \"\\n\" ) first , lines = lines [ 0 ] , lines [ 1 : ] lines = [ \"{indent}{s}\" . format ( indent = \" \" * indent , s = s ) for s in lines ] lines = [ first ] + lines return \"\\n\" . join ( lines )", "docstring_tokens": "Add indent of indent spaces to string . split ( \\ n ) [ 1 : ]", "label": 0}, {"idx": "cosqa-train-1217", "doc": "python retrieve keys in orer", "code": "def get_key_goids(self, goids):\n        \"\"\"Given GO IDs, return key GO IDs.\"\"\"\n        go2obj = self.go2obj\n        return set(go2obj[go].id for go in goids)", "code_tokens": "def get_key_goids ( self , goids ) : go2obj = self . go2obj return set ( go2obj [ go ] . id for go in goids )", "docstring_tokens": "Given GO IDs return key GO IDs .", "label": 0}, {"idx": "cosqa-train-1218", "doc": "how to mimick a post request in python", "code": "def requests_post(url, data=None, json=None, **kwargs):\n    \"\"\"Requests-mock requests.post wrapper.\"\"\"\n    return requests_request('post', url, data=data, json=json, **kwargs)", "code_tokens": "def requests_post ( url , data = None , json = None , * * kwargs ) : return requests_request ( 'post' , url , data = data , json = json , * * kwargs )", "docstring_tokens": "Requests - mock requests . post wrapper .", "label": 0}, {"idx": "cosqa-train-1219", "doc": "python return elements of index range", "code": "def get_idx_rect(index_list):\n    \"\"\"Extract the boundaries from a list of indexes\"\"\"\n    rows, cols = list(zip(*[(i.row(), i.column()) for i in index_list]))\n    return ( min(rows), max(rows), min(cols), max(cols) )", "code_tokens": "def get_idx_rect ( index_list ) : rows , cols = list ( zip ( * [ ( i . row ( ) , i . column ( ) ) for i in index_list ] ) ) return ( min ( rows ) , max ( rows ) , min ( cols ) , max ( cols ) )", "docstring_tokens": "Extract the boundaries from a list of indexes", "label": 0}, {"idx": "cosqa-train-1220", "doc": "how to move cursor to previous line in python", "code": "def _go_to_line(editor, line):\n    \"\"\"\n    Move cursor to this line in the current buffer.\n    \"\"\"\n    b = editor.application.current_buffer\n    b.cursor_position = b.document.translate_row_col_to_index(max(0, int(line) - 1), 0)", "code_tokens": "def _go_to_line ( editor , line ) : b = editor . application . current_buffer b . cursor_position = b . document . translate_row_col_to_index ( max ( 0 , int ( line ) - 1 ) , 0 )", "docstring_tokens": "Move cursor to this line in the current buffer .", "label": 0}, {"idx": "cosqa-train-1221", "doc": "python return index of start of continuous variable", "code": "def find_start_point(self):\n        \"\"\"\n        Find the first location in our array that is not empty\n        \"\"\"\n        for i, row in enumerate(self.data):\n            for j, _ in enumerate(row):\n                if self.data[i, j] != 0:  # or not np.isfinite(self.data[i,j]):\n                    return i, j", "code_tokens": "def find_start_point ( self ) : for i , row in enumerate ( self . data ) : for j , _ in enumerate ( row ) : if self . data [ i , j ] != 0 : # or not np.isfinite(self.data[i,j]): return i , j", "docstring_tokens": "Find the first location in our array that is not empty", "label": 0}, {"idx": "cosqa-train-1222", "doc": "how to only return unique values in a python list", "code": "def uniquify_list(L):\n    \"\"\"Same order unique list using only a list compression.\"\"\"\n    return [e for i, e in enumerate(L) if L.index(e) == i]", "code_tokens": "def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]", "docstring_tokens": "Same order unique list using only a list compression .", "label": 0}, {"idx": "cosqa-train-1223", "doc": "python return length of a vector", "code": "def norm_vec(vector):\n    \"\"\"Normalize the length of a vector to one\"\"\"\n    assert len(vector) == 3\n    v = np.array(vector)\n    return v/np.sqrt(np.sum(v**2))", "code_tokens": "def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )", "docstring_tokens": "Normalize the length of a vector to one", "label": 0}, {"idx": "cosqa-train-1224", "doc": "how to open a file from a path in python", "code": "def get_file_string(filepath):\n    \"\"\"Get string from file.\"\"\"\n    with open(os.path.abspath(filepath)) as f:\n        return f.read()", "code_tokens": "def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )", "docstring_tokens": "Get string from file .", "label": 0}, {"idx": "cosqa-train-1225", "doc": "python return regex match groups as tuple", "code": "def filter_regex(names, regex):\n    \"\"\"\n    Return a tuple of strings that match the regular expression pattern.\n    \"\"\"\n    return tuple(name for name in names\n                 if regex.search(name) is not None)", "code_tokens": "def filter_regex ( names , regex ) : return tuple ( name for name in names if regex . search ( name ) is not None )", "docstring_tokens": "Return a tuple of strings that match the regular expression pattern .", "label": 0}, {"idx": "cosqa-train-1226", "doc": "how to open a sql file with python", "code": "def _get_sql(filename):\n    \"\"\"Returns the contents of the sql file from the given ``filename``.\"\"\"\n    with open(os.path.join(SQL_DIR, filename), 'r') as f:\n        return f.read()", "code_tokens": "def _get_sql ( filename ) : with open ( os . path . join ( SQL_DIR , filename ) , 'r' ) as f : return f . read ( )", "docstring_tokens": "Returns the contents of the sql file from the given filename .", "label": 0}, {"idx": "cosqa-train-1227", "doc": "python return shapes ofarrays", "code": "def out_shape_from_array(arr):\n    \"\"\"Get the output shape from an array.\"\"\"\n    arr = np.asarray(arr)\n    if arr.ndim == 1:\n        return arr.shape\n    else:\n        return (arr.shape[1],)", "code_tokens": "def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "docstring_tokens": "Get the output shape from an array .", "label": 1}, {"idx": "cosqa-train-1228", "doc": "how to open s3 uri python", "code": "def parse_s3_url(url):\n    \"\"\"\n    Parses S3 URL.\n\n    Returns bucket (domain) and file (full path).\n    \"\"\"\n    bucket = ''\n    path = ''\n    if url:\n        result = urlparse(url)\n        bucket = result.netloc\n        path = result.path.strip('/')\n    return bucket, path", "code_tokens": "def parse_s3_url ( url ) : bucket = '' path = '' if url : result = urlparse ( url ) bucket = result . netloc path = result . path . strip ( '/' ) return bucket , path", "docstring_tokens": "Parses S3 URL .", "label": 0}, {"idx": "cosqa-train-1229", "doc": "python return strings that match a regexp", "code": "def filter_regex(names, regex):\n    \"\"\"\n    Return a tuple of strings that match the regular expression pattern.\n    \"\"\"\n    return tuple(name for name in names\n                 if regex.search(name) is not None)", "code_tokens": "def filter_regex ( names , regex ) : return tuple ( name for name in names if regex . search ( name ) is not None )", "docstring_tokens": "Return a tuple of strings that match the regular expression pattern .", "label": 0}, {"idx": "cosqa-train-1230", "doc": "how to opena and check the contents of file in python using load and pickle", "code": "def pickle_load(fname):\n    \"\"\"return the contents of a pickle file\"\"\"\n    assert type(fname) is str and os.path.exists(fname)\n    print(\"loaded\",fname)\n    return pickle.load(open(fname,\"rb\"))", "code_tokens": "def pickle_load ( fname ) : assert type ( fname ) is str and os . path . exists ( fname ) print ( \"loaded\" , fname ) return pickle . load ( open ( fname , \"rb\" ) )", "docstring_tokens": "return the contents of a pickle file", "label": 0}, {"idx": "cosqa-train-1231", "doc": "python return the value of a key in a dictionary", "code": "def get_key_by_value(dictionary, search_value):\n    \"\"\"\n    searchs a value in a dicionary and returns the key of the first occurrence\n\n    :param dictionary: dictionary to search in\n    :param search_value: value to search for\n    \"\"\"\n    for key, value in dictionary.iteritems():\n        if value == search_value:\n            return ugettext(key)", "code_tokens": "def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )", "docstring_tokens": "searchs a value in a dicionary and returns the key of the first occurrence", "label": 0}, {"idx": "cosqa-train-1232", "doc": "how to overlay normal dist on histogram python", "code": "def plot_dist_normal(s, mu, sigma):\n    \"\"\"\n    plot distribution\n    \"\"\"\n    import matplotlib.pyplot as plt\n    count, bins, ignored = plt.hist(s, 30, normed=True)\n    plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) \\\n            * np.exp( - (bins - mu)**2 / (2 * sigma**2) ), \\\n            linewidth = 2, color = 'r')\n    plt.show()", "code_tokens": "def plot_dist_normal ( s , mu , sigma ) : import matplotlib . pyplot as plt count , bins , ignored = plt . hist ( s , 30 , normed = True ) plt . plot ( bins , 1 / ( sigma * np . sqrt ( 2 * np . pi ) ) * np . exp ( - ( bins - mu ) ** 2 / ( 2 * sigma ** 2 ) ) , linewidth = 2 , color = 'r' ) plt . show ( )", "docstring_tokens": "plot distribution", "label": 0}, {"idx": "cosqa-train-1233", "doc": "how to parse proto python", "code": "def _dict_to_proto(py_dict, proto):\n        \"\"\"\n        Converts a python dictionary to the proto supplied\n\n        :param py_dict: The dictionary to convert\n        :type py_dict: dict\n        :param proto: The proto object to merge with dictionary\n        :type proto: protobuf\n        :return: A parsed python dictionary in provided proto format\n        :raises:\n            ParseError: On JSON parsing problems.\n        \"\"\"\n        dict_json_str = json.dumps(py_dict)\n        return json_format.Parse(dict_json_str, proto)", "code_tokens": "def _dict_to_proto ( py_dict , proto ) : dict_json_str = json . dumps ( py_dict ) return json_format . Parse ( dict_json_str , proto )", "docstring_tokens": "Converts a python dictionary to the proto supplied", "label": 0}, {"idx": "cosqa-train-1234", "doc": "python round down np", "code": "def round_to_n(x, n):\n    \"\"\"\n    Round to sig figs\n    \"\"\"\n    return round(x, -int(np.floor(np.log10(x))) + (n - 1))", "code_tokens": "def round_to_n ( x , n ) : return round ( x , - int ( np . floor ( np . log10 ( x ) ) ) + ( n - 1 ) )", "docstring_tokens": "Round to sig figs", "label": 0}, {"idx": "cosqa-train-1235", "doc": "how to pass an arguement between functions python", "code": "def trigger(self, target: str, trigger: str, parameters: Dict[str, Any]={}):\n\t\t\"\"\"Calls the specified Trigger of another Area with the optionally given parameters.\n\n\t\tArgs:\n\t\t\ttarget: The name of the target Area.\n\t\t\ttrigger: The name of the Trigger.\n\t\t\tparameters: The parameters of the function call.\n\t\t\"\"\"\n\t\tpass", "code_tokens": "def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass", "docstring_tokens": "Calls the specified Trigger of another Area with the optionally given parameters .", "label": 0}, {"idx": "cosqa-train-1236", "doc": "python round to another significant digit", "code": "def get_rounded(self, digits):\n        \"\"\" Return a vector with the elements rounded to the given number of digits. \"\"\"\n        result = self.copy()\n        result.round(digits)\n        return result", "code_tokens": "def get_rounded ( self , digits ) : result = self . copy ( ) result . round ( digits ) return result", "docstring_tokens": "Return a vector with the elements rounded to the given number of digits .", "label": 1}, {"idx": "cosqa-train-1237", "doc": "how to pass encoding with open in python", "code": "def open_with_encoding(filename, encoding, mode='r'):\n    \"\"\"Return opened file with a specific encoding.\"\"\"\n    return io.open(filename, mode=mode, encoding=encoding,\n                   newline='')", "code_tokens": "def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )", "docstring_tokens": "Return opened file with a specific encoding .", "label": 0}, {"idx": "cosqa-train-1238", "doc": "python run command after exit", "code": "def call_and_exit(self, cmd, shell=True):\n        \"\"\"Run the *cmd* and exit with the proper exit code.\"\"\"\n        sys.exit(subprocess.call(cmd, shell=shell))", "code_tokens": "def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )", "docstring_tokens": "Run the * cmd * and exit with the proper exit code .", "label": 0}, {"idx": "cosqa-train-1239", "doc": "how to perform outer join python", "code": "def merge(left, right, how='inner', key=None, left_key=None, right_key=None,\n          left_as='left', right_as='right'):\n    \"\"\" Performs a join using the union join function. \"\"\"\n    return join(left, right, how, key, left_key, right_key,\n                join_fn=make_union_join(left_as, right_as))", "code_tokens": "def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "docstring_tokens": "Performs a join using the union join function .", "label": 1}, {"idx": "cosqa-train-1240", "doc": "python run task async while returning first a value", "code": "async def result_processor(tasks):\n    \"\"\"An async result aggregator that combines all the results\n       This gets executed in unsync.loop and unsync.thread\"\"\"\n    output = {}\n    for task in tasks:\n        num, res = await task\n        output[num] = res\n    return output", "code_tokens": "async def result_processor ( tasks ) : output = { } for task in tasks : num , res = await task output [ num ] = res return output", "docstring_tokens": "An async result aggregator that combines all the results This gets executed in unsync . loop and unsync . thread", "label": 0}, {"idx": "cosqa-train-1241", "doc": "how to place text in a matplotlib plot in python without knowing scales", "code": "def add_text(text, x=0.01, y=0.01, axes=\"gca\", draw=True, **kwargs):\n    \"\"\"\n    Adds text to the axes at the specified position.\n\n    **kwargs go to the axes.text() function.\n    \"\"\"\n    if axes==\"gca\": axes = _pylab.gca()\n    axes.text(x, y, text, transform=axes.transAxes, **kwargs)\n    if draw: _pylab.draw()", "code_tokens": "def add_text ( text , x = 0.01 , y = 0.01 , axes = \"gca\" , draw = True , * * kwargs ) : if axes == \"gca\" : axes = _pylab . gca ( ) axes . text ( x , y , text , transform = axes . transAxes , * * kwargs ) if draw : _pylab . draw ( )", "docstring_tokens": "Adds text to the axes at the specified position .", "label": 0}, {"idx": "cosqa-train-1242", "doc": "python safe html output", "code": "def safe_quotes(text, escape_single_quotes=False):\n    \"\"\"htmlify string\"\"\"\n    if isinstance(text, str):\n        safe_text = text.replace('\"', \"&quot;\")\n        if escape_single_quotes:\n            safe_text = safe_text.replace(\"'\", \"&#92;'\")\n        return safe_text.replace('True', 'true')\n    return text", "code_tokens": "def safe_quotes ( text , escape_single_quotes = False ) : if isinstance ( text , str ) : safe_text = text . replace ( '\"' , \"&quot;\" ) if escape_single_quotes : safe_text = safe_text . replace ( \"'\" , \"&#92;'\" ) return safe_text . replace ( 'True' , 'true' ) return text", "docstring_tokens": "htmlify string", "label": 0}, {"idx": "cosqa-train-1243", "doc": "how to post with requests in python", "code": "def make_post_request(self, url, auth, json_payload):\n        \"\"\"This function executes the request with the provided\n        json payload and return the json response\"\"\"\n        response = requests.post(url, auth=auth, json=json_payload)\n        return response.json()", "code_tokens": "def make_post_request ( self , url , auth , json_payload ) : response = requests . post ( url , auth = auth , json = json_payload ) return response . json ( )", "docstring_tokens": "This function executes the request with the provided json payload and return the json response", "label": 0}, {"idx": "cosqa-train-1244", "doc": "python save plot as svg", "code": "def fig2x(figure, format):\n    \"\"\"Returns svg from matplotlib chart\"\"\"\n\n    # Save svg to file like object svg_io\n    io = StringIO()\n    figure.savefig(io, format=format)\n\n    # Rewind the file like object\n    io.seek(0)\n\n    data = io.getvalue()\n    io.close()\n\n    return data", "code_tokens": "def fig2x ( figure , format ) : # Save svg to file like object svg_io io = StringIO ( ) figure . savefig ( io , format = format ) # Rewind the file like object io . seek ( 0 ) data = io . getvalue ( ) io . close ( ) return data", "docstring_tokens": "Returns svg from matplotlib chart", "label": 0}, {"idx": "cosqa-train-1245", "doc": "how to print an error message in python for inputs", "code": "def error(*args):\n    \"\"\"Display error message via stderr or GUI.\"\"\"\n    if sys.stdin.isatty():\n        print('ERROR:', *args, file=sys.stderr)\n    else:\n        notify_error(*args)", "code_tokens": "def error ( * args ) : if sys . stdin . isatty ( ) : print ( 'ERROR:' , * args , file = sys . stderr ) else : notify_error ( * args )", "docstring_tokens": "Display error message via stderr or GUI .", "label": 0}, {"idx": "cosqa-train-1246", "doc": "python save plot but dont show it", "code": "def close(*args, **kwargs):\n    r\"\"\"Close last created figure, alias to ``plt.close()``.\"\"\"\n    _, plt, _ = _import_plt()\n    plt.close(*args, **kwargs)", "code_tokens": "def close ( * args , * * kwargs ) : _ , plt , _ = _import_plt ( ) plt . close ( * args , * * kwargs )", "docstring_tokens": "r Close last created figure alias to plt . close () .", "label": 0}, {"idx": "cosqa-train-1247", "doc": "how to print first 20 lines in file handling python", "code": "def head(filename, n=10):\n    \"\"\" prints the top `n` lines of a file \"\"\"\n    with freader(filename) as fr:\n        for _ in range(n):\n            print(fr.readline().strip())", "code_tokens": "def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )", "docstring_tokens": "prints the top n lines of a file", "label": 1}, {"idx": "cosqa-train-1248", "doc": "python save session to file", "code": "def save_session_to_file(self, sessionfile):\n        \"\"\"Not meant to be used directly, use :meth:`Instaloader.save_session_to_file`.\"\"\"\n        pickle.dump(requests.utils.dict_from_cookiejar(self._session.cookies), sessionfile)", "code_tokens": "def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )", "docstring_tokens": "Not meant to be used directly use : meth : Instaloader . save_session_to_file .", "label": 0}, {"idx": "cosqa-train-1249", "doc": "how to print out only certain letters in a string python", "code": "def return_letters_from_string(text):\n    \"\"\"Get letters from string only.\"\"\"\n    out = \"\"\n    for letter in text:\n        if letter.isalpha():\n            out += letter\n    return out", "code_tokens": "def return_letters_from_string ( text ) : out = \"\" for letter in text : if letter . isalpha ( ) : out += letter return out", "docstring_tokens": "Get letters from string only .", "label": 0}, {"idx": "cosqa-train-1250", "doc": "python saving object in session", "code": "def save_session_to_file(self, sessionfile):\n        \"\"\"Not meant to be used directly, use :meth:`Instaloader.save_session_to_file`.\"\"\"\n        pickle.dump(requests.utils.dict_from_cookiejar(self._session.cookies), sessionfile)", "code_tokens": "def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )", "docstring_tokens": "Not meant to be used directly use : meth : Instaloader . save_session_to_file .", "label": 0}, {"idx": "cosqa-train-1251", "doc": "how to print python 3 traceback object", "code": "def format_exc(limit=None):\n    \"\"\"Like print_exc() but return a string. Backport for Python 2.3.\"\"\"\n    try:\n        etype, value, tb = sys.exc_info()\n        return ''.join(traceback.format_exception(etype, value, tb, limit))\n    finally:\n        etype = value = tb = None", "code_tokens": "def format_exc ( limit = None ) : try : etype , value , tb = sys . exc_info ( ) return '' . join ( traceback . format_exception ( etype , value , tb , limit ) ) finally : etype = value = tb = None", "docstring_tokens": "Like print_exc () but return a string . Backport for Python 2 . 3 .", "label": 0}, {"idx": "cosqa-train-1252", "doc": "python scipy convolution 2d with stride 2", "code": "def conv1x1(in_planes, out_planes, stride=1):\n    \"\"\"1x1 convolution\"\"\"\n    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)", "code_tokens": "def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )", "docstring_tokens": "1x1 convolution", "label": 0}, {"idx": "cosqa-train-1253", "doc": "how to print the name of a key in python", "code": "def _get_name(self, key):\n        \"\"\" get display name for a key, or mangle for display \"\"\"\n        if key in self.display_names:\n            return self.display_names[key]\n\n        return key.capitalize()", "code_tokens": "def _get_name ( self , key ) : if key in self . display_names : return self . display_names [ key ] return key . capitalize ( )", "docstring_tokens": "get display name for a key or mangle for display", "label": 0}, {"idx": "cosqa-train-1254", "doc": "python scipy sparse matrix", "code": "def scipy_sparse_to_spmatrix(A):\n    \"\"\"Efficient conversion from scipy sparse matrix to cvxopt sparse matrix\"\"\"\n    coo = A.tocoo()\n    SP = spmatrix(coo.data.tolist(), coo.row.tolist(), coo.col.tolist(), size=A.shape)\n    return SP", "code_tokens": "def scipy_sparse_to_spmatrix ( A ) : coo = A . tocoo ( ) SP = spmatrix ( coo . data . tolist ( ) , coo . row . tolist ( ) , coo . col . tolist ( ) , size = A . shape ) return SP", "docstring_tokens": "Efficient conversion from scipy sparse matrix to cvxopt sparse matrix", "label": 1}, {"idx": "cosqa-train-1255", "doc": "how to print without starting a new line in python", "code": "def _screen(self, s, newline=False):\n        \"\"\"Print something on screen when self.verbose == True\"\"\"\n        if self.verbose:\n            if newline:\n                print(s)\n            else:\n                print(s, end=' ')", "code_tokens": "def _screen ( self , s , newline = False ) : if self . verbose : if newline : print ( s ) else : print ( s , end = ' ' )", "docstring_tokens": "Print something on screen when self . verbose == True", "label": 0}, {"idx": "cosqa-train-1256", "doc": "python scipy sparse matrix product", "code": "def scipy_sparse_to_spmatrix(A):\n    \"\"\"Efficient conversion from scipy sparse matrix to cvxopt sparse matrix\"\"\"\n    coo = A.tocoo()\n    SP = spmatrix(coo.data.tolist(), coo.row.tolist(), coo.col.tolist(), size=A.shape)\n    return SP", "code_tokens": "def scipy_sparse_to_spmatrix ( A ) : coo = A . tocoo ( ) SP = spmatrix ( coo . data . tolist ( ) , coo . row . tolist ( ) , coo . col . tolist ( ) , size = A . shape ) return SP", "docstring_tokens": "Efficient conversion from scipy sparse matrix to cvxopt sparse matrix", "label": 0}, {"idx": "cosqa-train-1257", "doc": "how to printout behave python std out", "code": "def _stdout_raw(self, s):\n        \"\"\"Writes the string to stdout\"\"\"\n        print(s, end='', file=sys.stdout)\n        sys.stdout.flush()", "code_tokens": "def _stdout_raw ( self , s ) : print ( s , end = '' , file = sys . stdout ) sys . stdout . flush ( )", "docstring_tokens": "Writes the string to stdout", "label": 0}, {"idx": "cosqa-train-1258", "doc": "python scipy wav write", "code": "def write_wav(path, samples, sr=16000):\n    \"\"\"\n    Write to given samples to a wav file.\n    The samples are expected to be floating point numbers\n    in the range of -1.0 to 1.0.\n\n    Args:\n        path (str): The path to write the wav to.\n        samples (np.array): A float array .\n        sr (int): The sampling rate.\n    \"\"\"\n    max_value = np.abs(np.iinfo(np.int16).min)\n    data = (samples * max_value).astype(np.int16)\n    scipy.io.wavfile.write(path, sr, data)", "code_tokens": "def write_wav ( path , samples , sr = 16000 ) : max_value = np . abs ( np . iinfo ( np . int16 ) . min ) data = ( samples * max_value ) . astype ( np . int16 ) scipy . io . wavfile . write ( path , sr , data )", "docstring_tokens": "Write to given samples to a wav file . The samples are expected to be floating point numbers in the range of - 1 . 0 to 1 . 0 .", "label": 1}, {"idx": "cosqa-train-1259", "doc": "how to pull a dictionary from inside a string python", "code": "def string_to_identity(identity_str):\n    \"\"\"Parse string into Identity dictionary.\"\"\"\n    m = _identity_regexp.match(identity_str)\n    result = m.groupdict()\n    log.debug('parsed identity: %s', result)\n    return {k: v for k, v in result.items() if v}", "code_tokens": "def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }", "docstring_tokens": "Parse string into Identity dictionary .", "label": 0}, {"idx": "cosqa-train-1260", "doc": "python scrape requests beautifulsoup urllib", "code": "def get_soup(page=''):\n    \"\"\"\n    Returns a bs4 object of the page requested\n    \"\"\"\n    content = requests.get('%s/%s' % (BASE_URL, page)).text\n    return BeautifulSoup(content)", "code_tokens": "def get_soup ( page = '' ) : content = requests . get ( '%s/%s' % ( BASE_URL , page ) ) . text return BeautifulSoup ( content )", "docstring_tokens": "Returns a bs4 object of the page requested", "label": 0}, {"idx": "cosqa-train-1261", "doc": "how to pull functions from definitions python", "code": "def init_checks_registry():\n    \"\"\"Register all globally visible functions.\n\n    The first argument name is either 'physical_line' or 'logical_line'.\n    \"\"\"\n    mod = inspect.getmodule(register_check)\n    for (name, function) in inspect.getmembers(mod, inspect.isfunction):\n        register_check(function)", "code_tokens": "def init_checks_registry ( ) : mod = inspect . getmodule ( register_check ) for ( name , function ) in inspect . getmembers ( mod , inspect . isfunction ) : register_check ( function )", "docstring_tokens": "Register all globally visible functions .", "label": 0}, {"idx": "cosqa-train-1262", "doc": "python scroll to element", "code": "def mouse_out(self):\n        \"\"\"\n        Performs a mouse out the element.\n\n        Currently works only on Chrome driver.\n        \"\"\"\n        self.scroll_to()\n        ActionChains(self.parent.driver).move_by_offset(0, 0).click().perform()", "code_tokens": "def mouse_out ( self ) : self . scroll_to ( ) ActionChains ( self . parent . driver ) . move_by_offset ( 0 , 0 ) . click ( ) . perform ( )", "docstring_tokens": "Performs a mouse out the element .", "label": 0}, {"idx": "cosqa-train-1263", "doc": "how to push two objects on a stack in python", "code": "def push(h, x):\n    \"\"\"Push a new value into heap.\"\"\"\n    h.push(x)\n    up(h, h.size()-1)", "code_tokens": "def push ( h , x ) : h . push ( x ) up ( h , h . size ( ) - 1 )", "docstring_tokens": "Push a new value into heap .", "label": 0}, {"idx": "cosqa-train-1264", "doc": "python scrolling tkinter canvas", "code": "def _set_scroll_v(self, *args):\n        \"\"\"Scroll both categories Canvas and scrolling container\"\"\"\n        self._canvas_categories.yview(*args)\n        self._canvas_scroll.yview(*args)", "code_tokens": "def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "docstring_tokens": "Scroll both categories Canvas and scrolling container", "label": 0}, {"idx": "cosqa-train-1265", "doc": "how to put a bash command in a python script", "code": "def bash(filename):\n    \"\"\"Runs a bash script in the local directory\"\"\"\n    sys.stdout.flush()\n    subprocess.call(\"bash {}\".format(filename), shell=True)", "code_tokens": "def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( \"bash {}\" . format ( filename ) , shell = True )", "docstring_tokens": "Runs a bash script in the local directory", "label": 0}, {"idx": "cosqa-train-1266", "doc": "python see if stdin", "code": "def stdin_readable():\n    \"\"\"Determine whether stdin has any data to read.\"\"\"\n    if not WINDOWS:\n        try:\n            return bool(select([sys.stdin], [], [], 0)[0])\n        except Exception:\n            logger.log_exc()\n    try:\n        return not sys.stdin.isatty()\n    except Exception:\n        logger.log_exc()\n    return False", "code_tokens": "def stdin_readable ( ) : if not WINDOWS : try : return bool ( select ( [ sys . stdin ] , [ ] , [ ] , 0 ) [ 0 ] ) except Exception : logger . log_exc ( ) try : return not sys . stdin . isatty ( ) except Exception : logger . log_exc ( ) return False", "docstring_tokens": "Determine whether stdin has any data to read .", "label": 1}, {"idx": "cosqa-train-1267", "doc": "how to put a hashtag on python lines", "code": "def _add_hash(source):\n    \"\"\"Add a leading hash '#' at the beginning of every line in the source.\"\"\"\n    source = '\\n'.join('# ' + line.rstrip()\n                       for line in source.splitlines())\n    return source", "code_tokens": "def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "docstring_tokens": "Add a leading hash # at the beginning of every line in the source .", "label": 0}, {"idx": "cosqa-train-1268", "doc": "python select a column based on a condition", "code": "def selecttrue(table, field, complement=False):\n    \"\"\"Select rows where the given field evaluates `True`.\"\"\"\n\n    return select(table, field, lambda v: bool(v), complement=complement)", "code_tokens": "def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )", "docstring_tokens": "Select rows where the given field evaluates True .", "label": 0}, {"idx": "cosqa-train-1269", "doc": "how to put a process in background python", "code": "def execute_in_background(self):\n        \"\"\"Executes a (shell) command in the background\n\n        :return: the process' pid\n        \"\"\"\n        # http://stackoverflow.com/questions/1605520\n        args = shlex.split(self.cmd)\n        p = Popen(args)\n        return p.pid", "code_tokens": "def execute_in_background ( self ) : # http://stackoverflow.com/questions/1605520 args = shlex . split ( self . cmd ) p = Popen ( args ) return p . pid", "docstring_tokens": "Executes a ( shell ) command in the background", "label": 0}, {"idx": "cosqa-train-1270", "doc": "python select columns with condition", "code": "def selecttrue(table, field, complement=False):\n    \"\"\"Select rows where the given field evaluates `True`.\"\"\"\n\n    return select(table, field, lambda v: bool(v), complement=complement)", "code_tokens": "def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )", "docstring_tokens": "Select rows where the given field evaluates True .", "label": 1}, {"idx": "cosqa-train-1271", "doc": "how to put javascript variable into python", "code": "def add_to_js(self, name, var):\n        \"\"\"Add an object to Javascript.\"\"\"\n        frame = self.page().mainFrame()\n        frame.addToJavaScriptWindowObject(name, var)", "code_tokens": "def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )", "docstring_tokens": "Add an object to Javascript .", "label": 0}, {"idx": "cosqa-train-1272", "doc": "python select conditional rows based on column value", "code": "def selecttrue(table, field, complement=False):\n    \"\"\"Select rows where the given field evaluates `True`.\"\"\"\n\n    return select(table, field, lambda v: bool(v), complement=complement)", "code_tokens": "def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )", "docstring_tokens": "Select rows where the given field evaluates True .", "label": 0}, {"idx": "cosqa-train-1273", "doc": "how to put percentage in python", "code": "def ratio_and_percentage(current, total, time_remaining):\n    \"\"\"Returns the progress ratio and percentage.\"\"\"\n    return \"{} / {} ({}% completed)\".format(current, total, int(current / total * 100))", "code_tokens": "def ratio_and_percentage ( current , total , time_remaining ) : return \"{} / {} ({}% completed)\" . format ( current , total , int ( current / total * 100 ) )", "docstring_tokens": "Returns the progress ratio and percentage .", "label": 0}, {"idx": "cosqa-train-1274", "doc": "python select folder dialog", "code": "def ask_dir(self):\n\t\t\"\"\"\n\t\tdialogue box for choosing directory\n\t\t\"\"\"\n\t\targs ['directory'] = askdirectory(**self.dir_opt) \n\t\tself.dir_text.set(args ['directory'])", "code_tokens": "def ask_dir ( self ) : args [ 'directory' ] = askdirectory ( * * self . dir_opt ) self . dir_text . set ( args [ 'directory' ] )", "docstring_tokens": "dialogue box for choosing directory", "label": 0}, {"idx": "cosqa-train-1275", "doc": "how to read dicom image in python", "code": "def numpy(self):\n        \"\"\" Grabs image data and converts it to a numpy array \"\"\"\n        # load GDCM's image reading functionality\n        image_reader = gdcm.ImageReader()\n        image_reader.SetFileName(self.fname)\n        if not image_reader.Read():\n            raise IOError(\"Could not read DICOM image\")\n        pixel_array = self._gdcm_to_numpy(image_reader.GetImage())\n        return pixel_array", "code_tokens": "def numpy ( self ) : # load GDCM's image reading functionality image_reader = gdcm . ImageReader ( ) image_reader . SetFileName ( self . fname ) if not image_reader . Read ( ) : raise IOError ( \"Could not read DICOM image\" ) pixel_array = self . _gdcm_to_numpy ( image_reader . GetImage ( ) ) return pixel_array", "docstring_tokens": "Grabs image data and converts it to a numpy array", "label": 0}, {"idx": "cosqa-train-1276", "doc": "python select greater of two values", "code": "def selectgt(table, field, value, complement=False):\n    \"\"\"Select rows where the given field is greater than the given value.\"\"\"\n\n    value = Comparable(value)\n    return selectop(table, field, value, operator.gt, complement=complement)", "code_tokens": "def selectgt ( table , field , value , complement = False ) : value = Comparable ( value ) return selectop ( table , field , value , operator . gt , complement = complement )", "docstring_tokens": "Select rows where the given field is greater than the given value .", "label": 0}, {"idx": "cosqa-train-1277", "doc": "how to read file with uft8 in python", "code": "def read_utf8(fh, byteorder, dtype, count, offsetsize):\n    \"\"\"Read tag data from file and return as unicode string.\"\"\"\n    return fh.read(count).decode('utf-8')", "code_tokens": "def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )", "docstring_tokens": "Read tag data from file and return as unicode string .", "label": 0}, {"idx": "cosqa-train-1278", "doc": "python select non null rows", "code": "def selectnotnone(table, field, complement=False):\n    \"\"\"Select rows where the given field is not `None`.\"\"\"\n\n    return select(table, field, lambda v: v is not None,\n                  complement=complement)", "code_tokens": "def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )", "docstring_tokens": "Select rows where the given field is not None .", "label": 0}, {"idx": "cosqa-train-1279", "doc": "how to read in a yml file python", "code": "def ReadManyFromPath(filepath):\n  \"\"\"Reads a Python object stored in a specified YAML file.\n\n  Args:\n    filepath: A filepath to the YAML file.\n\n  Returns:\n    A Python data structure corresponding to the YAML in the given file.\n  \"\"\"\n  with io.open(filepath, mode=\"r\", encoding=\"utf-8\") as filedesc:\n    return ReadManyFromFile(filedesc)", "code_tokens": "def ReadManyFromPath ( filepath ) : with io . open ( filepath , mode = \"r\" , encoding = \"utf-8\" ) as filedesc : return ReadManyFromFile ( filedesc )", "docstring_tokens": "Reads a Python object stored in a specified YAML file .", "label": 0}, {"idx": "cosqa-train-1280", "doc": "python select rows with no null", "code": "def selectnotnone(table, field, complement=False):\n    \"\"\"Select rows where the given field is not `None`.\"\"\"\n\n    return select(table, field, lambda v: v is not None,\n                  complement=complement)", "code_tokens": "def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )", "docstring_tokens": "Select rows where the given field is not None .", "label": 0}, {"idx": "cosqa-train-1281", "doc": "how to read the first number in a string in python", "code": "def find_first_number(ll):\n    \"\"\" Returns nr of first entry parseable to float in ll, None otherwise\"\"\"\n    for nr, entry in enumerate(ll):\n        try:\n            float(entry)\n        except (ValueError, TypeError) as e:\n            pass\n        else:\n            return nr\n    return None", "code_tokens": "def find_first_number ( ll ) : for nr , entry in enumerate ( ll ) : try : float ( entry ) except ( ValueError , TypeError ) as e : pass else : return nr return None", "docstring_tokens": "Returns nr of first entry parseable to float in ll None otherwise", "label": 0}, {"idx": "cosqa-train-1282", "doc": "python select the row of ids that match the ids in a list", "code": "def filter_by_ids(original_list, ids_to_filter):\n    \"\"\"Filter a list of dicts by IDs using an id key on each dict.\"\"\"\n    if not ids_to_filter:\n        return original_list\n\n    return [i for i in original_list if i['id'] in ids_to_filter]", "code_tokens": "def filter_by_ids ( original_list , ids_to_filter ) : if not ids_to_filter : return original_list return [ i for i in original_list if i [ 'id' ] in ids_to_filter ]", "docstring_tokens": "Filter a list of dicts by IDs using an id key on each dict .", "label": 0}, {"idx": "cosqa-train-1283", "doc": "python self id double underscore", "code": "def __init__(self):\n    \"\"\"Initializes an attribute container identifier.\"\"\"\n    super(AttributeContainerIdentifier, self).__init__()\n    self._identifier = id(self)", "code_tokens": "def __init__ ( self ) : super ( AttributeContainerIdentifier , self ) . __init__ ( ) self . _identifier = id ( self )", "docstring_tokens": "Initializes an attribute container identifier .", "label": 0}, {"idx": "cosqa-train-1284", "doc": "how to refresh the window in python maya", "code": "def main_func(args=None):\n    \"\"\"Main funcion when executing this module as script\n\n    :param args: commandline arguments\n    :type args: list\n    :returns: None\n    :rtype: None\n    :raises: None\n    \"\"\"\n    # we have to initialize a gui even if we dont need one right now.\n    # as soon as you call maya.standalone.initialize(), a QApplication\n    # with type Tty is created. This is the type for conosle apps.\n    # Because i have not found a way to replace that, we just init the gui.\n    guimain.init_gui()\n\n    main.init()\n    launcher = Launcher()\n    parsed, unknown = launcher.parse_args(args)\n    parsed.func(parsed, unknown)", "code_tokens": "def main_func ( args = None ) : # we have to initialize a gui even if we dont need one right now. # as soon as you call maya.standalone.initialize(), a QApplication # with type Tty is created. This is the type for conosle apps. # Because i have not found a way to replace that, we just init the gui. guimain . init_gui ( ) main . init ( ) launcher = Launcher ( ) parsed , unknown = launcher . parse_args ( args ) parsed . func ( parsed , unknown )", "docstring_tokens": "Main funcion when executing this module as script", "label": 0}, {"idx": "cosqa-train-1285", "doc": "python serial readline has a delay", "code": "async def readline(self):\n        \"\"\"\n        This is an asyncio adapted version of pyserial read.\n        It provides a non-blocking read and returns a line of data read.\n\n        :return: A line of data\n        \"\"\"\n        future = asyncio.Future()\n        data_available = False\n        while True:\n            if not data_available:\n                if not self.my_serial.inWaiting():\n                    await asyncio.sleep(self.sleep_tune)\n                else:\n                    data_available = True\n                    data = self.my_serial.readline()\n                    future.set_result(data)\n            else:\n                if not future.done():\n                    await asyncio.sleep(self.sleep_tune)\n                else:\n                    return future.result()", "code_tokens": "async def readline ( self ) : future = asyncio . Future ( ) data_available = False while True : if not data_available : if not self . my_serial . inWaiting ( ) : await asyncio . sleep ( self . sleep_tune ) else : data_available = True data = self . my_serial . readline ( ) future . set_result ( data ) else : if not future . done ( ) : await asyncio . sleep ( self . sleep_tune ) else : return future . result ( )", "docstring_tokens": "This is an asyncio adapted version of pyserial read . It provides a non - blocking read and returns a line of data read .", "label": 0}, {"idx": "cosqa-train-1286", "doc": "how to remove a black border from an image python", "code": "def _trim(image):\n    \"\"\"Trim a PIL image and remove white space.\"\"\"\n    background = PIL.Image.new(image.mode, image.size, image.getpixel((0, 0)))\n    diff = PIL.ImageChops.difference(image, background)\n    diff = PIL.ImageChops.add(diff, diff, 2.0, -100)\n    bbox = diff.getbbox()\n    if bbox:\n        image = image.crop(bbox)\n    return image", "code_tokens": "def _trim ( image ) : background = PIL . Image . new ( image . mode , image . size , image . getpixel ( ( 0 , 0 ) ) ) diff = PIL . ImageChops . difference ( image , background ) diff = PIL . ImageChops . add ( diff , diff , 2.0 , - 100 ) bbox = diff . getbbox ( ) if bbox : image = image . crop ( bbox ) return image", "docstring_tokens": "Trim a PIL image and remove white space .", "label": 0}, {"idx": "cosqa-train-1287", "doc": "python series remove last value", "code": "def remove_series(self, series):\n        \"\"\"Removes a :py:class:`.Series` from the chart.\n\n        :param Series series: The :py:class:`.Series` to remove.\n        :raises ValueError: if you try to remove the last\\\n        :py:class:`.Series`.\"\"\"\n\n        if len(self.all_series()) == 1:\n            raise ValueError(\"Cannot remove last series from %s\" % str(self))\n        self._all_series.remove(series)\n        series._chart = None", "code_tokens": "def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( \"Cannot remove last series from %s\" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None", "docstring_tokens": "Removes a : py : class : . Series from the chart .", "label": 0}, {"idx": "cosqa-train-1288", "doc": "how to remove columns by name in python", "code": "def del_Unnamed(df):\n    \"\"\"\n    Deletes all the unnamed columns\n\n    :param df: pandas dataframe\n    \"\"\"\n    cols_del=[c for c in df.columns if 'Unnamed' in c]\n    return df.drop(cols_del,axis=1)", "code_tokens": "def del_Unnamed ( df ) : cols_del = [ c for c in df . columns if 'Unnamed' in c ] return df . drop ( cols_del , axis = 1 )", "docstring_tokens": "Deletes all the unnamed columns", "label": 0}, {"idx": "cosqa-train-1289", "doc": "python server side detext request headers", "code": "def get_header(request, header_service):\n    \"\"\"Return request's 'X_POLYAXON_...:' header, as a bytestring.\n\n    Hide some test client ickyness where the header can be unicode.\n    \"\"\"\n    service = request.META.get('HTTP_{}'.format(header_service), b'')\n    if isinstance(service, str):\n        # Work around django test client oddness\n        service = service.encode(HTTP_HEADER_ENCODING)\n    return service", "code_tokens": "def get_header ( request , header_service ) : service = request . META . get ( 'HTTP_{}' . format ( header_service ) , b'' ) if isinstance ( service , str ) : # Work around django test client oddness service = service . encode ( HTTP_HEADER_ENCODING ) return service", "docstring_tokens": "Return request s X_POLYAXON_ ... : header as a bytestring .", "label": 0}, {"idx": "cosqa-train-1290", "doc": "how to remove object out of list in python", "code": "def _removeTags(tags, objects):\n    \"\"\" Removes tags from objects \"\"\"\n    for t in tags:\n        for o in objects:\n            o.tags.remove(t)\n\n    return True", "code_tokens": "def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True", "docstring_tokens": "Removes tags from objects", "label": 0}, {"idx": "cosqa-train-1291", "doc": "python session cookie save", "code": "def save_session_to_file(self, sessionfile):\n        \"\"\"Not meant to be used directly, use :meth:`Instaloader.save_session_to_file`.\"\"\"\n        pickle.dump(requests.utils.dict_from_cookiejar(self._session.cookies), sessionfile)", "code_tokens": "def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )", "docstring_tokens": "Not meant to be used directly use : meth : Instaloader . save_session_to_file .", "label": 0}, {"idx": "cosqa-train-1292", "doc": "how to remove signatures in emails, in python", "code": "def fix_datagrepper_message(message):\n    \"\"\"\n    See if a message is (probably) a datagrepper message and attempt to mutate\n    it to pass signature validation.\n\n    Datagrepper adds the 'source_name' and 'source_version' keys. If messages happen\n    to use those keys, they will fail message validation. Additionally, a 'headers'\n    dictionary is present on all responses, regardless of whether it was in the\n    original message or not. This is deleted if it's null, which won't be correct in\n    all cases. Finally, datagrepper turns the 'timestamp' field into a float, but it\n    might have been an integer when the message was signed.\n\n    A copy of the dictionary is made and returned if altering the message is necessary.\n\n    I'm so sorry.\n\n    Args:\n        message (dict): A message to clean up.\n\n    Returns:\n        dict: A copy of the provided message, with the datagrepper-related keys removed\n            if they were present.\n    \"\"\"\n    if not ('source_name' in message and 'source_version' in message):\n        return message\n\n    # Don't mutate the original message\n    message = message.copy()\n\n    del message['source_name']\n    del message['source_version']\n    # datanommer adds the headers field to the message in all cases.\n    # This is a huge problem because if the signature was generated with a 'headers'\n    # key set and we delete it here, messages will fail validation, but if we don't\n    # messages will fail validation if they didn't have a 'headers' key set.\n    #\n    # There's no way to know whether or not the headers field was part of the signed\n    # message or not. Generally, the problem is datanommer is mutating messages.\n    if 'headers' in message and not message['headers']:\n        del message['headers']\n    if 'timestamp' in message:\n        message['timestamp'] = int(message['timestamp'])\n\n    return message", "code_tokens": "def fix_datagrepper_message ( message ) : if not ( 'source_name' in message and 'source_version' in message ) : return message # Don't mutate the original message message = message . copy ( ) del message [ 'source_name' ] del message [ 'source_version' ] # datanommer adds the headers field to the message in all cases. # This is a huge problem because if the signature was generated with a 'headers' # key set and we delete it here, messages will fail validation, but if we don't # messages will fail validation if they didn't have a 'headers' key set. # # There's no way to know whether or not the headers field was part of the signed # message or not. Generally, the problem is datanommer is mutating messages. if 'headers' in message and not message [ 'headers' ] : del message [ 'headers' ] if 'timestamp' in message : message [ 'timestamp' ] = int ( message [ 'timestamp' ] ) return message", "docstring_tokens": "See if a message is ( probably ) a datagrepper message and attempt to mutate it to pass signature validation .", "label": 0}, {"idx": "cosqa-train-1293", "doc": "python set file mtime", "code": "def set_time(filename, mod_time):\n\t\"\"\"\n\tSet the modified time of a file\n\t\"\"\"\n\tlog.debug('Setting modified time to %s', mod_time)\n\tmtime = calendar.timegm(mod_time.utctimetuple())\n\t# utctimetuple discards microseconds, so restore it (for consistency)\n\tmtime += mod_time.microsecond / 1000000\n\tatime = os.stat(filename).st_atime\n\tos.utime(filename, (atime, mtime))", "code_tokens": "def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)\n mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )", "docstring_tokens": "Set the modified time of a file", "label": 0}, {"idx": "cosqa-train-1294", "doc": "how to remove stop words in python without ntlk", "code": "def wordify(text):\n    \"\"\"Generate a list of words given text, removing punctuation.\n\n    Parameters\n    ----------\n    text : unicode\n        A piece of english text.\n\n    Returns\n    -------\n    words : list\n        List of words.\n    \"\"\"\n    stopset = set(nltk.corpus.stopwords.words('english'))\n    tokens = nltk.WordPunctTokenizer().tokenize(text)\n    return [w for w in tokens if w not in stopset]", "code_tokens": "def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]", "docstring_tokens": "Generate a list of words given text removing punctuation .", "label": 0}, {"idx": "cosqa-train-1295", "doc": "python set global variable from variable name", "code": "def get_var(name, factory=None):\n    \"\"\"Gets a global variable given its name.\n\n    If factory is not None and the variable is not set, factory\n    is a callable that will set the variable.\n\n    If not set, returns None.\n    \"\"\"\n    if name not in _VARS and factory is not None:\n        _VARS[name] = factory()\n    return _VARS.get(name)", "code_tokens": "def get_var ( name , factory = None ) : if name not in _VARS and factory is not None : _VARS [ name ] = factory ( ) return _VARS . get ( name )", "docstring_tokens": "Gets a global variable given its name .", "label": 0}, {"idx": "cosqa-train-1296", "doc": "how to remove table fields in python", "code": "def remove_non_magic_cols(self):\n        \"\"\"\n        Remove all non-MagIC columns from all tables.\n        \"\"\"\n        for table_name in self.tables:\n            table = self.tables[table_name]\n            table.remove_non_magic_cols_from_table()", "code_tokens": "def remove_non_magic_cols ( self ) : for table_name in self . tables : table = self . tables [ table_name ] table . remove_non_magic_cols_from_table ( )", "docstring_tokens": "Remove all non - MagIC columns from all tables .", "label": 0}, {"idx": "cosqa-train-1297", "doc": "python set last element", "code": "def turn(self):\n        \"\"\"Turn the ring for a single position.\n        For example, [a, b, c, d] becomes [b, c, d, a].\"\"\"\n        first = self._data.pop(0)\n        self._data.append(first)", "code_tokens": "def turn ( self ) : first = self . _data . pop ( 0 ) self . _data . append ( first )", "docstring_tokens": "Turn the ring for a single position . For example [ a b c d ] becomes [ b c d a ] .", "label": 0}, {"idx": "cosqa-train-1298", "doc": "how to remove the axis from the graph by python", "code": "def clean_axis(axis):\n    \"\"\"Remove ticks, tick labels, and frame from axis\"\"\"\n    axis.get_xaxis().set_ticks([])\n    axis.get_yaxis().set_ticks([])\n    for spine in list(axis.spines.values()):\n        spine.set_visible(False)", "code_tokens": "def clean_axis ( axis ) : axis . get_xaxis ( ) . set_ticks ( [ ] ) axis . get_yaxis ( ) . set_ticks ( [ ] ) for spine in list ( axis . spines . values ( ) ) : spine . set_visible ( False )", "docstring_tokens": "Remove ticks tick labels and frame from axis", "label": 0}, {"idx": "cosqa-train-1299", "doc": "python set loglevel with a variable", "code": "def set_log_level(logger_name: str, log_level: str, propagate: bool = False):\n    \"\"\"Set the log level of the specified logger.\"\"\"\n    log = logging.getLogger(logger_name)\n    log.propagate = propagate\n    log.setLevel(log_level)", "code_tokens": "def set_log_level ( logger_name : str , log_level : str , propagate : bool = False ) : log = logging . getLogger ( logger_name ) log . propagate = propagate log . setLevel ( log_level )", "docstring_tokens": "Set the log level of the specified logger .", "label": 0}, {"idx": "cosqa-train-1300", "doc": "how to remove the comma in a string python", "code": "def split_comma_argument(comma_sep_str):\n    \"\"\"Split a comma separated option into a list.\"\"\"\n    terms = []\n    for term in comma_sep_str.split(','):\n        if term:\n            terms.append(term)\n    return terms", "code_tokens": "def split_comma_argument ( comma_sep_str ) : terms = [ ] for term in comma_sep_str . split ( ',' ) : if term : terms . append ( term ) return terms", "docstring_tokens": "Split a comma separated option into a list .", "label": 0}, {"idx": "cosqa-train-1301", "doc": "python set mime type as iage", "code": "def python_mime(fn):\n    \"\"\"\n    Decorator, which adds correct MIME type for python source to the decorated\n    bottle API function.\n    \"\"\"\n    @wraps(fn)\n    def python_mime_decorator(*args, **kwargs):\n        response.content_type = \"text/x-python\"\n\n        return fn(*args, **kwargs)\n\n    return python_mime_decorator", "code_tokens": "def python_mime ( fn ) : @ wraps ( fn ) def python_mime_decorator ( * args , * * kwargs ) : response . content_type = \"text/x-python\" return fn ( * args , * * kwargs ) return python_mime_decorator", "docstring_tokens": "Decorator which adds correct MIME type for python source to the decorated bottle API function .", "label": 0}, {"idx": "cosqa-train-1302", "doc": "how to rename in pivot in python", "code": "def set_pivot_keys(self, foreign_key, other_key):\n        \"\"\"\n        Set the key names for the pivot model instance\n        \"\"\"\n        self.__foreign_key = foreign_key\n        self.__other_key = other_key\n\n        return self", "code_tokens": "def set_pivot_keys ( self , foreign_key , other_key ) : self . __foreign_key = foreign_key self . __other_key = other_key return self", "docstring_tokens": "Set the key names for the pivot model instance", "label": 0}, {"idx": "cosqa-train-1303", "doc": "python set mock attribute", "code": "def mock_add_spec(self, spec, spec_set=False):\n        \"\"\"Add a spec to a mock. `spec` can either be an object or a\n        list of strings. Only attributes on the `spec` can be fetched as\n        attributes from the mock.\n\n        If `spec_set` is True then only attributes on the spec can be set.\"\"\"\n        self._mock_add_spec(spec, spec_set)\n        self._mock_set_magics()", "code_tokens": "def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )", "docstring_tokens": "Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock .", "label": 0}, {"idx": "cosqa-train-1304", "doc": "how to replace a string witb another string python", "code": "def fmt_subst(regex, subst):\n    \"\"\"Replace regex with string.\"\"\"\n    return lambda text: re.sub(regex, subst, text) if text else text", "code_tokens": "def fmt_subst ( regex , subst ) : return lambda text : re . sub ( regex , subst , text ) if text else text", "docstring_tokens": "Replace regex with string .", "label": 0}, {"idx": "cosqa-train-1305", "doc": "python set remove an element", "code": "def discard(self, element):\n        \"\"\"Remove element from the RangeSet if it is a member.\n\n        If the element is not a member, do nothing.\n        \"\"\"\n        try:\n            i = int(element)\n            set.discard(self, i)\n        except ValueError:\n            pass", "code_tokens": "def discard ( self , element ) : try : i = int ( element ) set . discard ( self , i ) except ValueError : pass", "docstring_tokens": "Remove element from the RangeSet if it is a member .", "label": 0}, {"idx": "cosqa-train-1306", "doc": "how to replace na with median python", "code": "def median(self):\n        \"\"\"Computes the median of a log-normal distribution built with the stats data.\"\"\"\n        mu = self.mean()\n        ret_val = math.exp(mu)\n        if math.isnan(ret_val):\n            ret_val = float(\"inf\")\n        return ret_val", "code_tokens": "def median ( self ) : mu = self . mean ( ) ret_val = math . exp ( mu ) if math . isnan ( ret_val ) : ret_val = float ( \"inf\" ) return ret_val", "docstring_tokens": "Computes the median of a log - normal distribution built with the stats data .", "label": 0}, {"idx": "cosqa-train-1307", "doc": "python set the current file", "code": "def load_file(self, filename):\n        \"\"\"Read in file contents and set the current string.\"\"\"\n        with open(filename, 'r') as sourcefile:\n            self.set_string(sourcefile.read())", "code_tokens": "def load_file ( self , filename ) : with open ( filename , 'r' ) as sourcefile : self . set_string ( sourcefile . read ( ) )", "docstring_tokens": "Read in file contents and set the current string .", "label": 1}, {"idx": "cosqa-train-1308", "doc": "how to replace spaces with underscores in python", "code": "def normalise_string(string):\n    \"\"\" Strips trailing whitespace from string, lowercases it and replaces\n        spaces with underscores\n    \"\"\"\n    string = (string.strip()).lower()\n    return re.sub(r'\\W+', '_', string)", "code_tokens": "def normalise_string ( string ) : string = ( string . strip ( ) ) . lower ( ) return re . sub ( r'\\W+' , '_' , string )", "docstring_tokens": "Strips trailing whitespace from string lowercases it and replaces spaces with underscores", "label": 0}, {"idx": "cosqa-train-1309", "doc": "python set timezone to utc", "code": "def to_utc(self, dt):\n        \"\"\"Convert any timestamp to UTC (with tzinfo).\"\"\"\n        if dt.tzinfo is None:\n            return dt.replace(tzinfo=self.utc)\n        return dt.astimezone(self.utc)", "code_tokens": "def to_utc ( self , dt ) : if dt . tzinfo is None : return dt . replace ( tzinfo = self . utc ) return dt . astimezone ( self . utc )", "docstring_tokens": "Convert any timestamp to UTC ( with tzinfo ) .", "label": 0}, {"idx": "cosqa-train-1310", "doc": "how to replace word with space in python", "code": "def dashrepl(value):\n    \"\"\"\n    Replace any non-word characters with a dash.\n    \"\"\"\n    patt = re.compile(r'\\W', re.UNICODE)\n    return re.sub(patt, '-', value)", "code_tokens": "def dashrepl ( value ) : patt = re . compile ( r'\\W' , re . UNICODE ) return re . sub ( patt , '-' , value )", "docstring_tokens": "Replace any non - word characters with a dash .", "label": 0}, {"idx": "cosqa-train-1311", "doc": "how to reshape images in python", "code": "def im2mat(I):\n    \"\"\"Converts and image to matrix (one pixel per line)\"\"\"\n    return I.reshape((I.shape[0] * I.shape[1], I.shape[2]))", "code_tokens": "def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )", "docstring_tokens": "Converts and image to matrix ( one pixel per line )", "label": 0}, {"idx": "cosqa-train-1312", "doc": "how to restart computer with python", "code": "async def restart(request):\n    \"\"\"\n    Returns OK, then waits approximately 1 second and restarts container\n    \"\"\"\n    def wait_and_restart():\n        log.info('Restarting server')\n        sleep(1)\n        os.system('kill 1')\n    Thread(target=wait_and_restart).start()\n    return web.json_response({\"message\": \"restarting\"})", "code_tokens": "async def restart ( request ) : def wait_and_restart ( ) : log . info ( 'Restarting server' ) sleep ( 1 ) os . system ( 'kill 1' ) Thread ( target = wait_and_restart ) . start ( ) return web . json_response ( { \"message\" : \"restarting\" } )", "docstring_tokens": "Returns OK then waits approximately 1 second and restarts container", "label": 0}, {"idx": "cosqa-train-1313", "doc": "python sets contains another set", "code": "def issuperset(self, other):\n        \"\"\"Report whether this RangeSet contains another set.\"\"\"\n        self._binary_sanity_check(other)\n        return set.issuperset(self, other)", "code_tokens": "def issuperset ( self , other ) : self . _binary_sanity_check ( other ) return set . issuperset ( self , other )", "docstring_tokens": "Report whether this RangeSet contains another set .", "label": 0}, {"idx": "cosqa-train-1314", "doc": "how to retreive json data from dynamic url using python", "code": "def get_jsonparsed_data(url):\n    \"\"\"Receive the content of ``url``, parse it as JSON and return the\n       object.\n    \"\"\"\n    response = urlopen(url)\n    data = response.read().decode('utf-8')\n    return json.loads(data)", "code_tokens": "def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )", "docstring_tokens": "Receive the content of url parse it as JSON and return the object .", "label": 1}, {"idx": "cosqa-train-1315", "doc": "python sftp eof during negotiation", "code": "def feed_eof(self):\n        \"\"\"Send a potentially \"ragged\" EOF.\n\n        This method will raise an SSL_ERROR_EOF exception if the EOF is\n        unexpected.\n        \"\"\"\n        self._incoming.write_eof()\n        ssldata, appdata = self.feed_ssldata(b'')\n        assert appdata == [] or appdata == [b'']", "code_tokens": "def feed_eof ( self ) : self . _incoming . write_eof ( ) ssldata , appdata = self . feed_ssldata ( b'' ) assert appdata == [ ] or appdata == [ b'' ]", "docstring_tokens": "Send a potentially ragged EOF .", "label": 0}, {"idx": "cosqa-train-1316", "doc": "how to return the highest value of a tree python", "code": "def maxDepth(self, currentDepth=0):\n        \"\"\"Compute the depth of the longest branch of the tree\"\"\"\n        if not any((self.left, self.right)):\n            return currentDepth\n        result = 0\n        for child in (self.left, self.right):\n            if child:\n                result = max(result, child.maxDepth(currentDepth + 1))\n        return result", "code_tokens": "def maxDepth ( self , currentDepth = 0 ) : if not any ( ( self . left , self . right ) ) : return currentDepth result = 0 for child in ( self . left , self . right ) : if child : result = max ( result , child . maxDepth ( currentDepth + 1 ) ) return result", "docstring_tokens": "Compute the depth of the longest branch of the tree", "label": 0}, {"idx": "cosqa-train-1317", "doc": "python shapely string polygon to polygon", "code": "def bounds_to_poly(bounds):\n    \"\"\"\n    Constructs a shapely Polygon from the provided bounds tuple.\n\n    Parameters\n    ----------\n    bounds: tuple\n        Tuple representing the (left, bottom, right, top) coordinates\n\n    Returns\n    -------\n    polygon: shapely.geometry.Polygon\n        Shapely Polygon geometry of the bounds\n    \"\"\"\n    x0, y0, x1, y1 = bounds\n    return Polygon([(x0, y0), (x1, y0), (x1, y1), (x0, y1)])", "code_tokens": "def bounds_to_poly ( bounds ) : x0 , y0 , x1 , y1 = bounds return Polygon ( [ ( x0 , y0 ) , ( x1 , y0 ) , ( x1 , y1 ) , ( x0 , y1 ) ] )", "docstring_tokens": "Constructs a shapely Polygon from the provided bounds tuple .", "label": 0}, {"idx": "cosqa-train-1318", "doc": "how to rewind the itretator in python", "code": "def reset(self):\n\t\t\"\"\"\n\t\tResets the iterator to the start.\n\n\t\tAny remaining values in the current iteration are discarded.\n\t\t\"\"\"\n\t\tself.__iterator, self.__saved = itertools.tee(self.__saved)", "code_tokens": "def reset ( self ) : self . __iterator , self . __saved = itertools . tee ( self . __saved )", "docstring_tokens": "Resets the iterator to the start .", "label": 0}, {"idx": "cosqa-train-1319", "doc": "how to round floats using f2 python %", "code": "def _saferound(value, decimal_places):\n    \"\"\"\n    Rounds a float value off to the desired precision\n    \"\"\"\n    try:\n        f = float(value)\n    except ValueError:\n        return ''\n    format = '%%.%df' % decimal_places\n    return format % f", "code_tokens": "def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f", "docstring_tokens": "Rounds a float value off to the desired precision", "label": 0}, {"idx": "cosqa-train-1320", "doc": "python shuffle array along with the first dim", "code": "def _shuffle(data, idx):\n    \"\"\"Shuffle the data.\"\"\"\n    shuffle_data = []\n\n    for idx_k, idx_v in data:\n        shuffle_data.append((idx_k, mx.ndarray.array(idx_v.asnumpy()[idx], idx_v.context)))\n\n    return shuffle_data", "code_tokens": "def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data", "docstring_tokens": "Shuffle the data .", "label": 0}, {"idx": "cosqa-train-1321", "doc": "how to round to a specific number of decimals in python", "code": "def round_to_n(x, n):\n    \"\"\"\n    Round to sig figs\n    \"\"\"\n    return round(x, -int(np.floor(np.log10(x))) + (n - 1))", "code_tokens": "def round_to_n ( x , n ) : return round ( x , - int ( np . floor ( np . log10 ( x ) ) ) + ( n - 1 ) )", "docstring_tokens": "Round to sig figs", "label": 0}, {"idx": "cosqa-train-1322", "doc": "python shuffle numpy array index", "code": "def _shuffle(data, idx):\n    \"\"\"Shuffle the data.\"\"\"\n    shuffle_data = []\n\n    for idx_k, idx_v in data:\n        shuffle_data.append((idx_k, mx.ndarray.array(idx_v.asnumpy()[idx], idx_v.context)))\n\n    return shuffle_data", "code_tokens": "def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data", "docstring_tokens": "Shuffle the data .", "label": 0}, {"idx": "cosqa-train-1323", "doc": "how to round to sig figs in python", "code": "def round_to_n(x, n):\n    \"\"\"\n    Round to sig figs\n    \"\"\"\n    return round(x, -int(np.floor(np.log10(x))) + (n - 1))", "code_tokens": "def round_to_n ( x , n ) : return round ( x , - int ( np . floor ( np . log10 ( x ) ) ) + ( n - 1 ) )", "docstring_tokens": "Round to sig figs", "label": 0}, {"idx": "cosqa-train-1324", "doc": "python signal low pass filter", "code": "def lowPass(self, *args):\n        \"\"\"\n        Creates a copy of the signal with the low pass applied, args specifed are passed through to _butter. \n        :return: \n        \"\"\"\n        return Signal(self._butter(self.samples, 'low', *args), fs=self.fs)", "code_tokens": "def lowPass ( self , * args ) : return Signal ( self . _butter ( self . samples , 'low' , * args ) , fs = self . fs )", "docstring_tokens": "Creates a copy of the signal with the low pass applied args specifed are passed through to _butter . : return :", "label": 0}, {"idx": "cosqa-train-1325", "doc": "how to run a loop again after sleeping in python inside the loop", "code": "def begin_stream_loop(stream, poll_interval):\n    \"\"\"Start and maintain the streaming connection...\"\"\"\n    while should_continue():\n        try:\n            stream.start_polling(poll_interval)\n        except Exception as e:\n            # Infinite restart\n            logger.error(\"Exception while polling. Restarting in 1 second.\", exc_info=True)\n            time.sleep(1)", "code_tokens": "def begin_stream_loop ( stream , poll_interval ) : while should_continue ( ) : try : stream . start_polling ( poll_interval ) except Exception as e : # Infinite restart logger . error ( \"Exception while polling. Restarting in 1 second.\" , exc_info = True ) time . sleep ( 1 )", "docstring_tokens": "Start and maintain the streaming connection ...", "label": 0}, {"idx": "cosqa-train-1326", "doc": "python sine wave with periods", "code": "def sine_wave(frequency):\n  \"\"\"Emit a sine wave at the given frequency.\"\"\"\n  xs = tf.reshape(tf.range(_samples(), dtype=tf.float32), [1, _samples(), 1])\n  ts = xs / FLAGS.sample_rate\n  return tf.sin(2 * math.pi * frequency * ts)", "code_tokens": "def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )", "docstring_tokens": "Emit a sine wave at the given frequency .", "label": 1}, {"idx": "cosqa-train-1327", "doc": "how to run flake8 python", "code": "def lint(args):\n    \"\"\"Run lint checks using flake8.\"\"\"\n    application = get_current_application()\n    if not args:\n        args = [application.name, 'tests']\n    args = ['flake8'] + list(args)\n    run.main(args, standalone_mode=False)", "code_tokens": "def lint ( args ) : application = get_current_application ( ) if not args : args = [ application . name , 'tests' ] args = [ 'flake8' ] + list ( args ) run . main ( args , standalone_mode = False )", "docstring_tokens": "Run lint checks using flake8 .", "label": 1}, {"idx": "cosqa-train-1328", "doc": "python single tuple read as list", "code": "def readTuple(self, line, n=3):\n        \"\"\" Reads a tuple of numbers. e.g. vertices, normals or teture coords.\n        \"\"\"\n        numbers = [num for num in line.split(' ') if num]\n        return [float(num) for num in numbers[1:n + 1]]", "code_tokens": "def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]", "docstring_tokens": "Reads a tuple of numbers . e . g . vertices normals or teture coords .", "label": 0}, {"idx": "cosqa-train-1329", "doc": "how to run python script in deburger mode", "code": "def stub_main():\n    \"\"\"setuptools blah: it still can't run a module as a script entry_point\"\"\"\n    from google.apputils import run_script_module\n    import butcher.main\n    run_script_module.RunScriptModule(butcher.main)", "code_tokens": "def stub_main ( ) : from google . apputils import run_script_module import butcher . main run_script_module . RunScriptModule ( butcher . main )", "docstring_tokens": "setuptools blah : it still can t run a module as a script entry_point", "label": 1}, {"idx": "cosqa-train-1330", "doc": "python size of input buffer", "code": "def _nbytes(buf):\n    \"\"\"Return byte-size of a memoryview or buffer.\"\"\"\n    if isinstance(buf, memoryview):\n        if PY3:\n            # py3 introduces nbytes attribute\n            return buf.nbytes\n        else:\n            # compute nbytes on py2\n            size = buf.itemsize\n            for dim in buf.shape:\n                size *= dim\n            return size\n    else:\n        # not a memoryview, raw bytes/ py2 buffer\n        return len(buf)", "code_tokens": "def _nbytes ( buf ) : if isinstance ( buf , memoryview ) : if PY3 : # py3 introduces nbytes attribute return buf . nbytes else : # compute nbytes on py2 size = buf . itemsize for dim in buf . shape : size *= dim return size else : # not a memoryview, raw bytes/ py2 buffer return len ( buf )", "docstring_tokens": "Return byte - size of a memoryview or buffer .", "label": 0}, {"idx": "cosqa-train-1331", "doc": "how to save a variable to a text file in python", "code": "def save(variable, filename):\n    \"\"\"Save variable on given path using Pickle\n    \n    Args:\n        variable: what to save\n        path (str): path of the output\n    \"\"\"\n    fileObj = open(filename, 'wb')\n    pickle.dump(variable, fileObj)\n    fileObj.close()", "code_tokens": "def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )", "docstring_tokens": "Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output", "label": 1}, {"idx": "cosqa-train-1332", "doc": "python skip lines for loop", "code": "def _skip_frame(self):\n        \"\"\"Skip the next time frame\"\"\"\n        for line in self._f:\n            if line == 'ITEM: ATOMS\\n':\n                break\n        for i in range(self.num_atoms):\n            next(self._f)", "code_tokens": "def _skip_frame ( self ) : for line in self . _f : if line == 'ITEM: ATOMS\\n' : break for i in range ( self . num_atoms ) : next ( self . _f )", "docstring_tokens": "Skip the next time frame", "label": 0}, {"idx": "cosqa-train-1333", "doc": "how to save an excel sheet as a new file python", "code": "def save_excel(self, fd):\n        \"\"\" Saves the case as an Excel spreadsheet.\n        \"\"\"\n        from pylon.io.excel import ExcelWriter\n        ExcelWriter(self).write(fd)", "code_tokens": "def save_excel ( self , fd ) : from pylon . io . excel import ExcelWriter ExcelWriter ( self ) . write ( fd )", "docstring_tokens": "Saves the case as an Excel spreadsheet .", "label": 1}, {"idx": "cosqa-train-1334", "doc": "python skip to next element in for loop", "code": "def skip(self, n):\n        \"\"\"Skip the specified number of elements in the list.\n\n        If the number skipped is greater than the number of elements in\n        the list, hasNext() becomes false and available() returns zero\n        as there are no more elements to retrieve.\n\n        arg:    n (cardinal): the number of elements to skip\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        try:\n            self._iter_object.skip(n)\n        except AttributeError:\n            for i in range(0, n):\n                self.next()", "code_tokens": "def skip ( self , n ) : try : self . _iter_object . skip ( n ) except AttributeError : for i in range ( 0 , n ) : self . next ( )", "docstring_tokens": "Skip the specified number of elements in the list .", "label": 0}, {"idx": "cosqa-train-1335", "doc": "how to save header of fits file to export python", "code": "def write_fits(self, fitsfile):\n        \"\"\"Write the ROI model to a FITS file.\"\"\"\n\n        tab = self.create_table()\n        hdu_data = fits.table_to_hdu(tab)\n        hdus = [fits.PrimaryHDU(), hdu_data]\n        fits_utils.write_hdus(hdus, fitsfile)", "code_tokens": "def write_fits ( self , fitsfile ) : tab = self . create_table ( ) hdu_data = fits . table_to_hdu ( tab ) hdus = [ fits . PrimaryHDU ( ) , hdu_data ] fits_utils . write_hdus ( hdus , fitsfile )", "docstring_tokens": "Write the ROI model to a FITS file .", "label": 1}, {"idx": "cosqa-train-1336", "doc": "python slice front of array", "code": "def getbyteslice(self, start, end):\n        \"\"\"Direct access to byte data.\"\"\"\n        c = self._rawarray[start:end]\n        return c", "code_tokens": "def getbyteslice ( self , start , end ) : c = self . _rawarray [ start : end ] return c", "docstring_tokens": "Direct access to byte data .", "label": 0}, {"idx": "cosqa-train-1337", "doc": "how to save something on python", "code": "def pickle_save(thing,fname):\n    \"\"\"save something to a pickle file\"\"\"\n    pickle.dump(thing, open(fname,\"wb\"),pickle.HIGHEST_PROTOCOL)\n    return thing", "code_tokens": "def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , \"wb\" ) , pickle . HIGHEST_PROTOCOL ) return thing", "docstring_tokens": "save something to a pickle file", "label": 1}, {"idx": "cosqa-train-1338", "doc": "python slice without an element", "code": "def is_full_slice(obj, l):\n    \"\"\"\n    We have a full length slice.\n    \"\"\"\n    return (isinstance(obj, slice) and obj.start == 0 and obj.stop == l and\n            obj.step is None)", "code_tokens": "def is_full_slice ( obj , l ) : return ( isinstance ( obj , slice ) and obj . start == 0 and obj . stop == l and obj . step is None )", "docstring_tokens": "We have a full length slice .", "label": 0}, {"idx": "cosqa-train-1339", "doc": "how to save the output imagw with full size without white spaces in python", "code": "def resize_image(self, data, size):\n        \"\"\" Resizes the given image to fit inside a box of the given size. \"\"\"\n        from machina.core.compat import PILImage as Image\n        image = Image.open(BytesIO(data))\n\n        # Resize!\n        image.thumbnail(size, Image.ANTIALIAS)\n\n        string = BytesIO()\n        image.save(string, format='PNG')\n        return string.getvalue()", "code_tokens": "def resize_image ( self , data , size ) : from machina . core . compat import PILImage as Image image = Image . open ( BytesIO ( data ) ) # Resize! image . thumbnail ( size , Image . ANTIALIAS ) string = BytesIO ( ) image . save ( string , format = 'PNG' ) return string . getvalue ( )", "docstring_tokens": "Resizes the given image to fit inside a box of the given size .", "label": 0}, {"idx": "cosqa-train-1340", "doc": "python socket close shutdown", "code": "def stop(self, dummy_signum=None, dummy_frame=None):\n        \"\"\" Shutdown process (this method is also a signal handler) \"\"\"\n        logging.info('Shutting down ...')\n        self.socket.close()\n        sys.exit(0)", "code_tokens": "def stop ( self , dummy_signum = None , dummy_frame = None ) : logging . info ( 'Shutting down ...' ) self . socket . close ( ) sys . exit ( 0 )", "docstring_tokens": "Shutdown process ( this method is also a signal handler )", "label": 0}, {"idx": "cosqa-train-1341", "doc": "how to securely stop threading python", "code": "def stop(self):\n        \"\"\"Stops the background synchronization thread\"\"\"\n        with self.synclock:\n            if self.syncthread is not None:\n                self.syncthread.cancel()\n                self.syncthread = None", "code_tokens": "def stop ( self ) : with self . synclock : if self . syncthread is not None : self . syncthread . cancel ( ) self . syncthread = None", "docstring_tokens": "Stops the background synchronization thread", "label": 0}, {"idx": "cosqa-train-1342", "doc": "python soft link removal", "code": "def symlink_remove(link):\n    \"\"\"Remove a symlink. Used for model shortcut links.\n\n    link (unicode / Path): The path to the symlink.\n    \"\"\"\n    # https://stackoverflow.com/q/26554135/6400719\n    if os.path.isdir(path2str(link)) and is_windows:\n        # this should only be on Py2.7 and windows\n        os.rmdir(path2str(link))\n    else:\n        os.unlink(path2str(link))", "code_tokens": "def symlink_remove ( link ) : # https://stackoverflow.com/q/26554135/6400719 if os . path . isdir ( path2str ( link ) ) and is_windows : # this should only be on Py2.7 and windows os . rmdir ( path2str ( link ) ) else : os . unlink ( path2str ( link ) )", "docstring_tokens": "Remove a symlink . Used for model shortcut links .", "label": 1}, {"idx": "cosqa-train-1343", "doc": "how to see type of column data python", "code": "def _get_column_types(self, data):\n        \"\"\"Get a list of the data types for each column in *data*.\"\"\"\n        columns = list(zip_longest(*data))\n        return [self._get_column_type(column) for column in columns]", "code_tokens": "def _get_column_types ( self , data ) : columns = list ( zip_longest ( * data ) ) return [ self . _get_column_type ( column ) for column in columns ]", "docstring_tokens": "Get a list of the data types for each column in * data * .", "label": 0}, {"idx": "cosqa-train-1344", "doc": "python sort list of filenames with numbers ascending", "code": "def sort_filenames(filenames):\n    \"\"\"\n    sort a list of files by filename only, ignoring the directory names\n    \"\"\"\n    basenames = [os.path.basename(x) for x in filenames]\n    indexes = [i[0] for i in sorted(enumerate(basenames), key=lambda x:x[1])]\n    return [filenames[x] for x in indexes]", "code_tokens": "def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "docstring_tokens": "sort a list of files by filename only ignoring the directory names", "label": 0}, {"idx": "cosqa-train-1345", "doc": "how to separate list elements by white space python", "code": "def split_strings_in_list_retain_spaces(orig_list):\n    \"\"\"\n    Function to split every line in a list, and retain spaces for a rejoin\n    :param orig_list: Original list\n    :return:\n        A List with split lines\n\n    \"\"\"\n    temp_list = list()\n    for line in orig_list:\n        line_split = __re.split(r'(\\s+)', line)\n        temp_list.append(line_split)\n\n    return temp_list", "code_tokens": "def split_strings_in_list_retain_spaces ( orig_list ) : temp_list = list ( ) for line in orig_list : line_split = __re . split ( r'(\\s+)' , line ) temp_list . append ( line_split ) return temp_list", "docstring_tokens": "Function to split every line in a list and retain spaces for a rejoin : param orig_list : Original list : return : A List with split lines", "label": 1}, {"idx": "cosqa-train-1346", "doc": "python sort names last to first with composite key", "code": "def transcript_sort_key(transcript):\n    \"\"\"\n    Key function used to sort transcripts. Taking the negative of\n    protein sequence length and nucleotide sequence length so that\n    the transcripts with longest sequences come first in the list. This couldn't\n    be accomplished with `reverse=True` since we're also sorting by\n    transcript name (which places TP53-001 before TP53-002).\n    \"\"\"\n    return (\n        -len(transcript.protein_sequence),\n        -len(transcript.sequence),\n        transcript.name\n    )", "code_tokens": "def transcript_sort_key ( transcript ) : return ( - len ( transcript . protein_sequence ) , - len ( transcript . sequence ) , transcript . name )", "docstring_tokens": "Key function used to sort transcripts . Taking the negative of protein sequence length and nucleotide sequence length so that the transcripts with longest sequences come first in the list . This couldn t be accomplished with reverse = True since we re also sorting by transcript name ( which places TP53 - 001 before TP53 - 002 ) .", "label": 0}, {"idx": "cosqa-train-1347", "doc": "how to set ansi encoding in python", "code": "def getdefaultencoding():\n    \"\"\"Return IPython's guess for the default encoding for bytes as text.\n\n    Asks for stdin.encoding first, to match the calling Terminal, but that\n    is often None for subprocesses.  Fall back on locale.getpreferredencoding()\n    which should be a sensible platform default (that respects LANG environment),\n    and finally to sys.getdefaultencoding() which is the most conservative option,\n    and usually ASCII.\n    \"\"\"\n    enc = get_stream_enc(sys.stdin)\n    if not enc or enc=='ascii':\n        try:\n            # There are reports of getpreferredencoding raising errors\n            # in some cases, which may well be fixed, but let's be conservative here.\n            enc = locale.getpreferredencoding()\n        except Exception:\n            pass\n    return enc or sys.getdefaultencoding()", "code_tokens": "def getdefaultencoding ( ) : enc = get_stream_enc ( sys . stdin ) if not enc or enc == 'ascii' : try : # There are reports of getpreferredencoding raising errors # in some cases, which may well be fixed, but let's be conservative here. enc = locale . getpreferredencoding ( ) except Exception : pass return enc or sys . getdefaultencoding ( )", "docstring_tokens": "Return IPython s guess for the default encoding for bytes as text .", "label": 0}, {"idx": "cosqa-train-1348", "doc": "python sorted comppond key", "code": "def transcript_sort_key(transcript):\n    \"\"\"\n    Key function used to sort transcripts. Taking the negative of\n    protein sequence length and nucleotide sequence length so that\n    the transcripts with longest sequences come first in the list. This couldn't\n    be accomplished with `reverse=True` since we're also sorting by\n    transcript name (which places TP53-001 before TP53-002).\n    \"\"\"\n    return (\n        -len(transcript.protein_sequence),\n        -len(transcript.sequence),\n        transcript.name\n    )", "code_tokens": "def transcript_sort_key ( transcript ) : return ( - len ( transcript . protein_sequence ) , - len ( transcript . sequence ) , transcript . name )", "docstring_tokens": "Key function used to sort transcripts . Taking the negative of protein sequence length and nucleotide sequence length so that the transcripts with longest sequences come first in the list . This couldn t be accomplished with reverse = True since we re also sorting by transcript name ( which places TP53 - 001 before TP53 - 002 ) .", "label": 0}, {"idx": "cosqa-train-1349", "doc": "python sorted iterator dictionary", "code": "def _dict_values_sorted_by_key(dictionary):\n    # This should be a yield from instead.\n    \"\"\"Internal helper to return the values of a dictionary, sorted by key.\n    \"\"\"\n    for _, value in sorted(dictionary.iteritems(), key=operator.itemgetter(0)):\n        yield value", "code_tokens": "def _dict_values_sorted_by_key ( dictionary ) : # This should be a yield from instead. for _ , value in sorted ( dictionary . iteritems ( ) , key = operator . itemgetter ( 0 ) ) : yield value", "docstring_tokens": "Internal helper to return the values of a dictionary sorted by key .", "label": 1}, {"idx": "cosqa-train-1350", "doc": "how to set infinity as a bound in python", "code": "def get_neg_infinity(dtype):\n    \"\"\"Return an appropriate positive infinity for this dtype.\n\n    Parameters\n    ----------\n    dtype : np.dtype\n\n    Returns\n    -------\n    fill_value : positive infinity value corresponding to this dtype.\n    \"\"\"\n    if issubclass(dtype.type, (np.floating, np.integer)):\n        return -np.inf\n\n    if issubclass(dtype.type, np.complexfloating):\n        return -np.inf - 1j * np.inf\n\n    return NINF", "code_tokens": "def get_neg_infinity ( dtype ) : if issubclass ( dtype . type , ( np . floating , np . integer ) ) : return - np . inf if issubclass ( dtype . type , np . complexfloating ) : return - np . inf - 1j * np . inf return NINF", "docstring_tokens": "Return an appropriate positive infinity for this dtype .", "label": 0}, {"idx": "cosqa-train-1351", "doc": "python source code for distance between two points", "code": "def direct2dDistance(self, point):\n        \"\"\"consider the distance between two mapPoints, ignoring all terrain, pathing issues\"\"\"\n        if not isinstance(point, MapPoint): return 0.0\n        return  ((self.x-point.x)**2 + (self.y-point.y)**2)**(0.5) # simple distance formula", "code_tokens": "def direct2dDistance ( self , point ) : if not isinstance ( point , MapPoint ) : return 0.0 return ( ( self . x - point . x ) ** 2 + ( self . y - point . y ) ** 2 ) ** ( 0.5 ) # simple distance formula", "docstring_tokens": "consider the distance between two mapPoints ignoring all terrain pathing issues", "label": 0}, {"idx": "cosqa-train-1352", "doc": "how to set permissions /dev in python", "code": "def chmod_add_excute(filename):\n        \"\"\"\n        Adds execute permission to file.\n        :param filename:\n        :return:\n        \"\"\"\n        st = os.stat(filename)\n        os.chmod(filename, st.st_mode | stat.S_IEXEC)", "code_tokens": "def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "docstring_tokens": "Adds execute permission to file . : param filename : : return :", "label": 0}, {"idx": "cosqa-train-1353", "doc": "python spacy how to remove stopwords and lower", "code": "def _removeStopwords(text_list):\n    \"\"\"\n    Removes stopwords contained in a list of words.\n\n    :param text_string: A list of strings.\n    :type text_string: list.\n\n    :returns: The input ``text_list`` with stopwords removed.\n    :rtype: list\n    \"\"\"\n\n    output_list = []\n\n    for word in text_list:\n        if word.lower() not in _stopwords:\n            output_list.append(word)\n\n    return output_list", "code_tokens": "def _removeStopwords ( text_list ) : output_list = [ ] for word in text_list : if word . lower ( ) not in _stopwords : output_list . append ( word ) return output_list", "docstring_tokens": "Removes stopwords contained in a list of words .", "label": 1}, {"idx": "cosqa-train-1354", "doc": "how to set python libpath", "code": "def GetPythonLibraryDirectoryPath():\n  \"\"\"Retrieves the Python library directory path.\"\"\"\n  path = sysconfig.get_python_lib(True)\n  _, _, path = path.rpartition(sysconfig.PREFIX)\n\n  if path.startswith(os.sep):\n    path = path[1:]\n\n  return path", "code_tokens": "def GetPythonLibraryDirectoryPath ( ) : path = sysconfig . get_python_lib ( True ) _ , _ , path = path . rpartition ( sysconfig . PREFIX ) if path . startswith ( os . sep ) : path = path [ 1 : ] return path", "docstring_tokens": "Retrieves the Python library directory path .", "label": 0}, {"idx": "cosqa-train-1355", "doc": "python spearman rank correlation", "code": "def lspearmanr(x,y):\n    \"\"\"\nCalculates a Spearman rank-order correlation coefficient.  Taken\nfrom Heiman's Basic Statistics for the Behav. Sci (1st), p.192.\n\nUsage:   lspearmanr(x,y)      where x and y are equal-length lists\nReturns: Spearman's r, two-tailed p-value\n\"\"\"\n    TINY = 1e-30\n    if len(x) != len(y):\n        raise ValueError('Input values not paired in spearmanr.  Aborting.')\n    n = len(x)\n    rankx = rankdata(x)\n    ranky = rankdata(y)\n    dsq = sumdiffsquared(rankx,ranky)\n    rs = 1 - 6*dsq / float(n*(n**2-1))\n    t = rs * math.sqrt((n-2) / ((rs+1.0)*(1.0-rs)))\n    df = n-2\n    probrs = betai(0.5*df,0.5,df/(df+t*t))  # t already a float\n# probability values for rs are from part 2 of the spearman function in\n# Numerical Recipies, p.510.  They are close to tables, but not exact. (?)\n    return rs, probrs", "code_tokens": "def lspearmanr ( x , y ) : TINY = 1e-30 if len ( x ) != len ( y ) : raise ValueError ( 'Input values not paired in spearmanr.  Aborting.' ) n = len ( x ) rankx = rankdata ( x ) ranky = rankdata ( y ) dsq = sumdiffsquared ( rankx , ranky ) rs = 1 - 6 * dsq / float ( n * ( n ** 2 - 1 ) ) t = rs * math . sqrt ( ( n - 2 ) / ( ( rs + 1.0 ) * ( 1.0 - rs ) ) ) df = n - 2 probrs = betai ( 0.5 * df , 0.5 , df / ( df + t * t ) ) # t already a float # probability values for rs are from part 2 of the spearman function in # Numerical Recipies, p.510.  They are close to tables, but not exact. (?) return rs , probrs", "docstring_tokens": "Calculates a Spearman rank - order correlation coefficient . Taken from Heiman s Basic Statistics for the Behav . Sci ( 1st ) p . 192 .", "label": 0}, {"idx": "cosqa-train-1356", "doc": "how to set python path in windows 7", "code": "def _python_rpath(self):\n        \"\"\"The relative path (from environment root) to python.\"\"\"\n        # Windows virtualenv installation installs pip to the [Ss]cripts\n        # folder. Here's a simple check to support:\n        if sys.platform == 'win32':\n            return os.path.join('Scripts', 'python.exe')\n        return os.path.join('bin', 'python')", "code_tokens": "def _python_rpath ( self ) : # Windows virtualenv installation installs pip to the [Ss]cripts # folder. Here's a simple check to support: if sys . platform == 'win32' : return os . path . join ( 'Scripts' , 'python.exe' ) return os . path . join ( 'bin' , 'python' )", "docstring_tokens": "The relative path ( from environment root ) to python .", "label": 1}, {"idx": "cosqa-train-1357", "doc": "python specify not condition", "code": "def _not(condition=None, **kwargs):\n    \"\"\"\n    Return the opposite of input condition.\n\n    :param condition: condition to process.\n\n    :result: not condition.\n    :rtype: bool\n    \"\"\"\n\n    result = True\n\n    if condition is not None:\n        result = not run(condition, **kwargs)\n\n    return result", "code_tokens": "def _not ( condition = None , * * kwargs ) : result = True if condition is not None : result = not run ( condition , * * kwargs ) return result", "docstring_tokens": "Return the opposite of input condition .", "label": 0}, {"idx": "cosqa-train-1358", "doc": "how to set the number of decimal places shown for a float in python", "code": "def setValue(self, p_float):\n        \"\"\"Override method to set a value to show it as 0 to 100.\n\n        :param p_float: The float number that want to be set.\n        :type p_float: float\n        \"\"\"\n        p_float = p_float * 100\n\n        super(PercentageSpinBox, self).setValue(p_float)", "code_tokens": "def setValue ( self , p_float ) : p_float = p_float * 100 super ( PercentageSpinBox , self ) . setValue ( p_float )", "docstring_tokens": "Override method to set a value to show it as 0 to 100 .", "label": 0}, {"idx": "cosqa-train-1359", "doc": "python split command args into list", "code": "def expand_args(cmd_args):\n    \"\"\"split command args to args list\n    returns a list of args\n\n    :param cmd_args: command args, can be tuple, list or str\n    \"\"\"\n    if isinstance(cmd_args, (tuple, list)):\n        args_list = list(cmd_args)\n    else:\n        args_list = shlex.split(cmd_args)\n    return args_list", "code_tokens": "def expand_args ( cmd_args ) : if isinstance ( cmd_args , ( tuple , list ) ) : args_list = list ( cmd_args ) else : args_list = shlex . split ( cmd_args ) return args_list", "docstring_tokens": "split command args to args list returns a list of args", "label": 0}, {"idx": "cosqa-train-1360", "doc": "how to set timezone datetime python", "code": "def datetime_from_timestamp(timestamp, content):\n    \"\"\"\n    Helper function to add timezone information to datetime,\n    so that datetime is comparable to other datetime objects in recent versions\n    that now also have timezone information.\n    \"\"\"\n    return set_date_tzinfo(\n        datetime.fromtimestamp(timestamp),\n        tz_name=content.settings.get('TIMEZONE', None))", "code_tokens": "def datetime_from_timestamp ( timestamp , content ) : return set_date_tzinfo ( datetime . fromtimestamp ( timestamp ) , tz_name = content . settings . get ( 'TIMEZONE' , None ) )", "docstring_tokens": "Helper function to add timezone information to datetime so that datetime is comparable to other datetime objects in recent versions that now also have timezone information .", "label": 0}, {"idx": "cosqa-train-1361", "doc": "python split multiple delimeters", "code": "def split_on(s, sep=\" \"):\n    \"\"\"Split s by sep, unless it's inside a quote.\"\"\"\n    pattern = '''((?:[^%s\"']|\"[^\"]*\"|'[^']*')+)''' % sep\n\n    return [_strip_speechmarks(t) for t in re.split(pattern, s)[1::2]]", "code_tokens": "def split_on ( s , sep = \" \" ) : pattern = '''((?:[^%s\"']|\"[^\"]*\"|'[^']*')+)''' % sep return [ _strip_speechmarks ( t ) for t in re . split ( pattern , s ) [ 1 : : 2 ] ]", "docstring_tokens": "Split s by sep unless it s inside a quote .", "label": 0}, {"idx": "cosqa-train-1362", "doc": "how to set value in python data frame", "code": "def SetValue(self, row, col, value):\n        \"\"\"\n        Set value in the pandas DataFrame\n        \"\"\"\n        self.dataframe.iloc[row, col] = value", "code_tokens": "def SetValue ( self , row , col , value ) : self . dataframe . iloc [ row , col ] = value", "docstring_tokens": "Set value in the pandas DataFrame", "label": 1}, {"idx": "cosqa-train-1363", "doc": "python split string in form of command argv", "code": "def extract_args(argv):\n    \"\"\"\n    take sys.argv that is used to call a command-line script and return a correctly split list of arguments\n    for example, this input: [\"eqarea.py\", \"-f\", \"infile\", \"-F\", \"outfile\", \"-A\"]\n    will return this output: [['f', 'infile'], ['F', 'outfile'], ['A']]\n    \"\"\"\n    string = \" \".join(argv)\n    string = string.split(' -')\n    program = string[0]\n    arguments = [s.split() for s in string[1:]]\n    return arguments", "code_tokens": "def extract_args ( argv ) : string = \" \" . join ( argv ) string = string . split ( ' -' ) program = string [ 0 ] arguments = [ s . split ( ) for s in string [ 1 : ] ] return arguments", "docstring_tokens": "take sys . argv that is used to call a command - line script and return a correctly split list of arguments for example this input : [ eqarea . py - f infile - F outfile - A ] will return this output : [[ f infile ] [ F outfile ] [ A ]]", "label": 0}, {"idx": "cosqa-train-1364", "doc": "how to set world cordinates for a turtle in python", "code": "def move_to(x, y):\n    \"\"\"Moves the brush to a particular position.\n\n    Arguments:\n        x - a number between -250 and 250.\n        y - a number between -180 and 180.\n    \"\"\"\n    _make_cnc_request(\"coord/{0}/{1}\".format(x, y))\n    state['turtle'].goto(x, y)", "code_tokens": "def move_to ( x , y ) : _make_cnc_request ( \"coord/{0}/{1}\" . format ( x , y ) ) state [ 'turtle' ] . goto ( x , y )", "docstring_tokens": "Moves the brush to a particular position .", "label": 0}, {"idx": "cosqa-train-1365", "doc": "python split string into n substrings", "code": "def _split_str(s, n):\n    \"\"\"\n    split string into list of strings by specified number.\n    \"\"\"\n    length = len(s)\n    return [s[i:i + n] for i in range(0, length, n)]", "code_tokens": "def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]", "docstring_tokens": "split string into list of strings by specified number .", "label": 0}, {"idx": "cosqa-train-1366", "doc": "how to simplify if elif python timechecks", "code": "def stopwatch_now():\n    \"\"\"Get a timevalue for interval comparisons\n\n    When possible it is a monotonic clock to prevent backwards time issues.\n    \"\"\"\n    if six.PY2:\n        now = time.time()\n    else:\n        now = time.monotonic()\n    return now", "code_tokens": "def stopwatch_now ( ) : if six . PY2 : now = time . time ( ) else : now = time . monotonic ( ) return now", "docstring_tokens": "Get a timevalue for interval comparisons", "label": 0}, {"idx": "cosqa-train-1367", "doc": "python split underscore reverse", "code": "def case_us2mc(x):\n    \"\"\" underscore to mixed case notation \"\"\"\n    return re.sub(r'_([a-z])', lambda m: (m.group(1).upper()), x)", "code_tokens": "def case_us2mc ( x ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , x )", "docstring_tokens": "underscore to mixed case notation", "label": 1}, {"idx": "cosqa-train-1368", "doc": "how to skip if a file doesnt exist in python", "code": "def file_found(filename,force):\n    \"\"\"Check if a file exists\"\"\"\n    if os.path.exists(filename) and not force:\n        logger.info(\"Found %s; skipping...\"%filename)\n        return True\n    else:\n        return False", "code_tokens": "def file_found ( filename , force ) : if os . path . exists ( filename ) and not force : logger . info ( \"Found %s; skipping...\" % filename ) return True else : return False", "docstring_tokens": "Check if a file exists", "label": 0}, {"idx": "cosqa-train-1369", "doc": "python spyder kernel died restarting", "code": "def restart(self, reset=False):\n        \"\"\"\n        Quit and Restart Spyder application.\n\n        If reset True it allows to reset spyder on restart.\n        \"\"\"\n        # Get start path to use in restart script\n        spyder_start_directory = get_module_path('spyder')\n        restart_script = osp.join(spyder_start_directory, 'app', 'restart.py')\n\n        # Get any initial argument passed when spyder was started\n        # Note: Variables defined in bootstrap.py and spyder/app/start.py\n        env = os.environ.copy()\n        bootstrap_args = env.pop('SPYDER_BOOTSTRAP_ARGS', None)\n        spyder_args = env.pop('SPYDER_ARGS')\n\n        # Get current process and python running spyder\n        pid = os.getpid()\n        python = sys.executable\n\n        # Check if started with bootstrap.py\n        if bootstrap_args is not None:\n            spyder_args = bootstrap_args\n            is_bootstrap = True\n        else:\n            is_bootstrap = False\n\n        # Pass variables as environment variables (str) to restarter subprocess\n        env['SPYDER_ARGS'] = spyder_args\n        env['SPYDER_PID'] = str(pid)\n        env['SPYDER_IS_BOOTSTRAP'] = str(is_bootstrap)\n        env['SPYDER_RESET'] = str(reset)\n\n        if DEV:\n            if os.name == 'nt':\n                env['PYTHONPATH'] = ';'.join(sys.path)\n            else:\n                env['PYTHONPATH'] = ':'.join(sys.path)\n\n        # Build the command and popen arguments depending on the OS\n        if os.name == 'nt':\n            # Hide flashing command prompt\n            startupinfo = subprocess.STARTUPINFO()\n            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n            shell = False\n        else:\n            startupinfo = None\n            shell = True\n\n        command = '\"{0}\" \"{1}\"'\n        command = command.format(python, restart_script)\n\n        try:\n            if self.closing(True):\n                subprocess.Popen(command, shell=shell, env=env,\n                                 startupinfo=startupinfo)\n                self.console.quit()\n        except Exception as error:\n            # If there is an error with subprocess, Spyder should not quit and\n            # the error can be inspected in the internal console\n            print(error)  # spyder: test-skip\n            print(command)", "code_tokens": "def restart ( self , reset = False ) : # Get start path to use in restart script\n spyder_start_directory = get_module_path ( 'spyder' ) restart_script = osp . join ( spyder_start_directory , 'app' , 'restart.py' ) # Get any initial argument passed when spyder was started\n # Note: Variables defined in bootstrap.py and spyder/app/start.py\n env = os . environ . copy ( ) bootstrap_args = env . pop ( 'SPYDER_BOOTSTRAP_ARGS' , None ) spyder_args = env . pop ( 'SPYDER_ARGS' ) # Get current process and python running spyder\n pid = os . getpid ( ) python = sys . executable # Check if started with bootstrap.py\n if bootstrap_args is not None : spyder_args = bootstrap_args is_bootstrap = True else : is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess\n env [ 'SPYDER_ARGS' ] = spyder_args env [ 'SPYDER_PID' ] = str ( pid ) env [ 'SPYDER_IS_BOOTSTRAP' ] = str ( is_bootstrap ) env [ 'SPYDER_RESET' ] = str ( reset ) if DEV : if os . name == 'nt' : env [ 'PYTHONPATH' ] = ';' . join ( sys . path ) else : env [ 'PYTHONPATH' ] = ':' . join ( sys . path ) # Build the command and popen arguments depending on the OS\n if os . name == 'nt' : # Hide flashing command prompt\n startupinfo = subprocess . STARTUPINFO ( ) startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW shell = False else : startupinfo = None shell = True command = '\"{0}\" \"{1}\"' command = command . format ( python , restart_script ) try : if self . closing ( True ) : subprocess . Popen ( command , shell = shell , env = env , startupinfo = startupinfo ) self . console . quit ( ) except Exception as error : # If there is an error with subprocess, Spyder should not quit and\n # the error can be inspected in the internal console\n print ( error ) # spyder: test-skip\n print ( command )", "docstring_tokens": "Quit and Restart Spyder application . If reset True it allows to reset spyder on restart .", "label": 1}, {"idx": "cosqa-train-1370", "doc": "how to solve a matrix in python", "code": "def MatrixSolve(a, rhs, adj):\n    \"\"\"\n    Matrix solve op.\n    \"\"\"\n    return np.linalg.solve(a if not adj else _adjoint(a), rhs),", "code_tokens": "def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,", "docstring_tokens": "Matrix solve op .", "label": 0}, {"idx": "cosqa-train-1371", "doc": "python sql result to dict", "code": "def _bindingsToDict(self, bindings):\n        \"\"\"\n        Given a binding from the sparql query result,\n        create a dict of plain text\n        \"\"\"\n        myDict = {}\n        for key, val in bindings.iteritems():\n            myDict[key.toPython().replace('?', '')] = val.toPython()\n        return myDict", "code_tokens": "def _bindingsToDict ( self , bindings ) : myDict = { } for key , val in bindings . iteritems ( ) : myDict [ key . toPython ( ) . replace ( '?' , '' ) ] = val . toPython ( ) return myDict", "docstring_tokens": "Given a binding from the sparql query result create a dict of plain text", "label": 0}, {"idx": "cosqa-train-1372", "doc": "how to solve equations with singular matrix python", "code": "def MatrixSolve(a, rhs, adj):\n    \"\"\"\n    Matrix solve op.\n    \"\"\"\n    return np.linalg.solve(a if not adj else _adjoint(a), rhs),", "code_tokens": "def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,", "docstring_tokens": "Matrix solve op .", "label": 0}, {"idx": "cosqa-train-1373", "doc": "python sqlalchemy altering table", "code": "def createdb():\n    \"\"\"Create database tables from sqlalchemy models\"\"\"\n    manager.db.engine.echo = True\n    manager.db.create_all()\n    set_alembic_revision()", "code_tokens": "def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )", "docstring_tokens": "Create database tables from sqlalchemy models", "label": 0}, {"idx": "cosqa-train-1374", "doc": "how to solve exponential function with python", "code": "def algo_exp(x, m, t, b):\n    \"\"\"mono-exponential curve.\"\"\"\n    return m*np.exp(-t*x)+b", "code_tokens": "def algo_exp ( x , m , t , b ) : return m * np . exp ( - t * x ) + b", "docstring_tokens": "mono - exponential curve .", "label": 0}, {"idx": "cosqa-train-1375", "doc": "python sqlalchemy create tables in different schemas", "code": "def createdb():\n    \"\"\"Create database tables from sqlalchemy models\"\"\"\n    manager.db.engine.echo = True\n    manager.db.create_all()\n    set_alembic_revision()", "code_tokens": "def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )", "docstring_tokens": "Create database tables from sqlalchemy models", "label": 0}, {"idx": "cosqa-train-1376", "doc": "how to sort a dictionary in descending orderpython", "code": "def sort_dict(d, key=None, reverse=False):\n    \"\"\"\n    Sorts a dict by value.\n\n    Args:\n        d: Input dictionary\n        key: Function which takes an tuple (key, object) and returns a value to\n            compare and sort by. By default, the function compares the values\n            of the dict i.e. key = lambda t : t[1]\n        reverse: Allows to reverse sort order.\n\n    Returns:\n        OrderedDict object whose keys are ordered according to their value.\n    \"\"\"\n    kv_items = [kv for kv in d.items()]\n\n    # Sort kv_items according to key.\n    if key is None:\n        kv_items.sort(key=lambda t: t[1], reverse=reverse)\n    else:\n        kv_items.sort(key=key, reverse=reverse)\n\n    # Build ordered dict.\n    return collections.OrderedDict(kv_items)", "code_tokens": "def sort_dict ( d , key = None , reverse = False ) : kv_items = [ kv for kv in d . items ( ) ] # Sort kv_items according to key. if key is None : kv_items . sort ( key = lambda t : t [ 1 ] , reverse = reverse ) else : kv_items . sort ( key = key , reverse = reverse ) # Build ordered dict. return collections . OrderedDict ( kv_items )", "docstring_tokens": "Sorts a dict by value .", "label": 1}, {"idx": "cosqa-train-1377", "doc": "python sqlalchemy this transaction is inactive", "code": "def commit(self, session=None):\n        \"\"\"Merge modified objects into parent transaction.\n\n        Once commited a transaction object is not usable anymore\n\n        :param:session: current sqlalchemy Session\n        \"\"\"\n        if self.__cleared:\n            return\n\n        if self._parent:\n            # nested transaction\n            self._commit_parent()\n        else:\n            self._commit_repository()\n        self._clear()", "code_tokens": "def commit ( self , session = None ) : if self . __cleared : return if self . _parent : # nested transaction self . _commit_parent ( ) else : self . _commit_repository ( ) self . _clear ( )", "docstring_tokens": "Merge modified objects into parent transaction .", "label": 1}, {"idx": "cosqa-train-1378", "doc": "how to sort an array in python descending", "code": "def arglexsort(arrays):\n    \"\"\"\n    Returns the indices of the lexicographical sorting\n    order of the supplied arrays.\n    \"\"\"\n    dtypes = ','.join(array.dtype.str for array in arrays)\n    recarray = np.empty(len(arrays[0]), dtype=dtypes)\n    for i, array in enumerate(arrays):\n        recarray['f%s' % i] = array\n    return recarray.argsort()", "code_tokens": "def arglexsort ( arrays ) : dtypes = ',' . join ( array . dtype . str for array in arrays ) recarray = np . empty ( len ( arrays [ 0 ] ) , dtype = dtypes ) for i , array in enumerate ( arrays ) : recarray [ 'f%s' % i ] = array return recarray . argsort ( )", "docstring_tokens": "Returns the indices of the lexicographical sorting order of the supplied arrays .", "label": 0}, {"idx": "cosqa-train-1379", "doc": "python sqlite get tables", "code": "def get_tablenames(cur):\n    \"\"\" Conveinience: \"\"\"\n    cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n    tablename_list_ = cur.fetchall()\n    tablename_list = [str(tablename[0]) for tablename in tablename_list_ ]\n    return tablename_list", "code_tokens": "def get_tablenames ( cur ) : cur . execute ( \"SELECT name FROM sqlite_master WHERE type='table'\" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list", "docstring_tokens": "Conveinience :", "label": 0}, {"idx": "cosqa-train-1380", "doc": "how to sort an ordered dictionary python", "code": "def sort_dict(d, key=None, reverse=False):\n    \"\"\"\n    Sorts a dict by value.\n\n    Args:\n        d: Input dictionary\n        key: Function which takes an tuple (key, object) and returns a value to\n            compare and sort by. By default, the function compares the values\n            of the dict i.e. key = lambda t : t[1]\n        reverse: Allows to reverse sort order.\n\n    Returns:\n        OrderedDict object whose keys are ordered according to their value.\n    \"\"\"\n    kv_items = [kv for kv in d.items()]\n\n    # Sort kv_items according to key.\n    if key is None:\n        kv_items.sort(key=lambda t: t[1], reverse=reverse)\n    else:\n        kv_items.sort(key=key, reverse=reverse)\n\n    # Build ordered dict.\n    return collections.OrderedDict(kv_items)", "code_tokens": "def sort_dict ( d , key = None , reverse = False ) : kv_items = [ kv for kv in d . items ( ) ] # Sort kv_items according to key. if key is None : kv_items . sort ( key = lambda t : t [ 1 ] , reverse = reverse ) else : kv_items . sort ( key = key , reverse = reverse ) # Build ordered dict. return collections . OrderedDict ( kv_items )", "docstring_tokens": "Sorts a dict by value .", "label": 0}, {"idx": "cosqa-train-1381", "doc": "python sqlite3 object has no attribute commit", "code": "def __init__(self):\n    \"\"\"Initializes the database file object.\"\"\"\n    super(Sqlite3DatabaseFile, self).__init__()\n    self._connection = None\n    self._cursor = None\n    self.filename = None\n    self.read_only = None", "code_tokens": "def __init__ ( self ) : super ( Sqlite3DatabaseFile , self ) . __init__ ( ) self . _connection = None self . _cursor = None self . filename = None self . read_only = None", "docstring_tokens": "Initializes the database file object .", "label": 0}, {"idx": "cosqa-train-1382", "doc": "how to sort array in descending order in python", "code": "def arglexsort(arrays):\n    \"\"\"\n    Returns the indices of the lexicographical sorting\n    order of the supplied arrays.\n    \"\"\"\n    dtypes = ','.join(array.dtype.str for array in arrays)\n    recarray = np.empty(len(arrays[0]), dtype=dtypes)\n    for i, array in enumerate(arrays):\n        recarray['f%s' % i] = array\n    return recarray.argsort()", "code_tokens": "def arglexsort ( arrays ) : dtypes = ',' . join ( array . dtype . str for array in arrays ) recarray = np . empty ( len ( arrays [ 0 ] ) , dtype = dtypes ) for i , array in enumerate ( arrays ) : recarray [ 'f%s' % i ] = array return recarray . argsort ( )", "docstring_tokens": "Returns the indices of the lexicographical sorting order of the supplied arrays .", "label": 0}, {"idx": "cosqa-train-1383", "doc": "python ssl handshake connection reset by peer", "code": "def _shutdown_transport(self):\n        \"\"\"Unwrap a Python 2.6 SSL socket, so we can call shutdown()\"\"\"\n        if self.sock is not None:\n            try:\n                unwrap = self.sock.unwrap\n            except AttributeError:\n                return\n            try:\n                self.sock = unwrap()\n            except ValueError:\n                # Failure within SSL might mean unwrap exists but socket is not\n                # deemed wrapped\n                pass", "code_tokens": "def _shutdown_transport ( self ) : if self . sock is not None : try : unwrap = self . sock . unwrap except AttributeError : return try : self . sock = unwrap ( ) except ValueError : # Failure within SSL might mean unwrap exists but socket is not # deemed wrapped pass", "docstring_tokens": "Unwrap a Python 2 . 6 SSL socket so we can call shutdown ()", "label": 0}, {"idx": "cosqa-train-1384", "doc": "how to sort list in python strings start with numbers", "code": "def sort_nicely(l):\n    \"\"\"Sort the given list in the way that humans expect.\"\"\"\n    convert = lambda text: int(text) if text.isdigit() else text\n    alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)]\n    l.sort(key=alphanum_key)", "code_tokens": "def sort_nicely ( l ) : convert = lambda text : int ( text ) if text . isdigit ( ) else text alphanum_key = lambda key : [ convert ( c ) for c in re . split ( '([0-9]+)' , key ) ] l . sort ( key = alphanum_key )", "docstring_tokens": "Sort the given list in the way that humans expect .", "label": 0}, {"idx": "cosqa-train-1385", "doc": "python standard deviation and average", "code": "def weighted_std(values, weights):\n    \"\"\" Calculate standard deviation weighted by errors \"\"\"\n    average = np.average(values, weights=weights)\n    variance = np.average((values-average)**2, weights=weights)\n    return np.sqrt(variance)", "code_tokens": "def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )", "docstring_tokens": "Calculate standard deviation weighted by errors", "label": 0}, {"idx": "cosqa-train-1386", "doc": "python standard deviation method", "code": "def _std(self,x):\n        \"\"\"\n        Compute standard deviation with ddof degrees of freedom\n        \"\"\"\n        return np.nanstd(x.values,ddof=self._ddof)", "code_tokens": "def _std ( self , x ) : return np . nanstd ( x . values , ddof = self . _ddof )", "docstring_tokens": "Compute standard deviation with ddof degrees of freedom", "label": 0}, {"idx": "cosqa-train-1387", "doc": "how to sort the columns in python in data frame", "code": "def sort_data(data, cols):\n    \"\"\"Sort `data` rows and order columns\"\"\"\n    return data.sort_values(cols)[cols + ['value']].reset_index(drop=True)", "code_tokens": "def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )", "docstring_tokens": "Sort data rows and order columns", "label": 1}, {"idx": "cosqa-train-1388", "doc": "python start fnction asynchronously", "code": "def asynchronous(function, event):\n    \"\"\"\n    Runs the function asynchronously taking care of exceptions.\n    \"\"\"\n    thread = Thread(target=synchronous, args=(function, event))\n    thread.daemon = True\n    thread.start()", "code_tokens": "def asynchronous ( function , event ) : thread = Thread ( target = synchronous , args = ( function , event ) ) thread . daemon = True thread . start ( )", "docstring_tokens": "Runs the function asynchronously taking care of exceptions .", "label": 1}, {"idx": "cosqa-train-1389", "doc": "how to specify a function return enumerated type, python", "code": "def get_function_class(function_name):\n    \"\"\"\n    Return the type for the requested function\n\n    :param function_name: the function to return\n    :return: the type for that function (i.e., this is a class, not an instance)\n    \"\"\"\n\n    if function_name in _known_functions:\n\n        return _known_functions[function_name]\n\n    else:\n\n        raise UnknownFunction(\"Function %s is not known. Known functions are: %s\" %\n                              (function_name, \",\".join(_known_functions.keys())))", "code_tokens": "def get_function_class ( function_name ) : if function_name in _known_functions : return _known_functions [ function_name ] else : raise UnknownFunction ( \"Function %s is not known. Known functions are: %s\" % ( function_name , \",\" . join ( _known_functions . keys ( ) ) ) )", "docstring_tokens": "Return the type for the requested function", "label": 1}, {"idx": "cosqa-train-1390", "doc": "python static method call static method", "code": "def safe_call(cls, method, *args):\n        \"\"\" Call a remote api method but don't raise if an error occurred.\"\"\"\n        return cls.call(method, *args, safe=True)", "code_tokens": "def safe_call ( cls , method , * args ) : return cls . call ( method , * args , safe = True )", "docstring_tokens": "Call a remote api method but don t raise if an error occurred .", "label": 0}, {"idx": "cosqa-train-1391", "doc": "how to specify widths in python", "code": "def text_width(string, font_name, font_size):\n    \"\"\"Determine with width in pixels of string.\"\"\"\n    return stringWidth(string, fontName=font_name, fontSize=font_size)", "code_tokens": "def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )", "docstring_tokens": "Determine with width in pixels of string .", "label": 0}, {"idx": "cosqa-train-1392", "doc": "python static variabl in function", "code": "def is_static(*p):\n    \"\"\" A static value (does not change at runtime)\n    which is known at compile time\n    \"\"\"\n    return all(is_CONST(x) or\n               is_number(x) or\n               is_const(x)\n               for x in p)", "code_tokens": "def is_static ( * p ) : return all ( is_CONST ( x ) or is_number ( x ) or is_const ( x ) for x in p )", "docstring_tokens": "A static value ( does not change at runtime ) which is known at compile time", "label": 0}, {"idx": "cosqa-train-1393", "doc": "how to splice a confusion matrix python", "code": "def incidence(boundary):\n    \"\"\"\n    given an Nxm matrix containing boundary info between simplices,\n    compute indidence info matrix\n    not very reusable; should probably not be in this lib\n    \"\"\"\n    return GroupBy(boundary).split(np.arange(boundary.size) // boundary.shape[1])", "code_tokens": "def incidence ( boundary ) : return GroupBy ( boundary ) . split ( np . arange ( boundary . size ) // boundary . shape [ 1 ] )", "docstring_tokens": "given an Nxm matrix containing boundary info between simplices compute indidence info matrix not very reusable ; should probably not be in this lib", "label": 0}, {"idx": "cosqa-train-1394", "doc": "python staticmethod call another staticmethod", "code": "def _update_staticmethod(self, oldsm, newsm):\n        \"\"\"Update a staticmethod update.\"\"\"\n        # While we can't modify the staticmethod object itself (it has no\n        # mutable attributes), we *can* extract the underlying function\n        # (by calling __get__(), which returns it) and update it in-place.\n        # We don't have the class available to pass to __get__() but any\n        # object except None will do.\n        self._update(None, None, oldsm.__get__(0), newsm.__get__(0))", "code_tokens": "def _update_staticmethod ( self , oldsm , newsm ) : # While we can't modify the staticmethod object itself (it has no # mutable attributes), we *can* extract the underlying function # (by calling __get__(), which returns it) and update it in-place. # We don't have the class available to pass to __get__() but any # object except None will do. self . _update ( None , None , oldsm . __get__ ( 0 ) , newsm . __get__ ( 0 ) )", "docstring_tokens": "Update a staticmethod update .", "label": 0}, {"idx": "cosqa-train-1395", "doc": "how to stack a list of array values in a grid in python", "code": "def column_stack_2d(data):\n    \"\"\"Perform column-stacking on a list of 2d data blocks.\"\"\"\n    return list(list(itt.chain.from_iterable(_)) for _ in zip(*data))", "code_tokens": "def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )", "docstring_tokens": "Perform column - stacking on a list of 2d data blocks .", "label": 0}, {"idx": "cosqa-train-1396", "doc": "python stmp connection unexpectedly closed", "code": "def disconnect(self):\n        \"\"\"Gracefully close connection to stomp server.\"\"\"\n        if self._connected:\n            self._connected = False\n            self._conn.disconnect()", "code_tokens": "def disconnect ( self ) : if self . _connected : self . _connected = False self . _conn . disconnect ( )", "docstring_tokens": "Gracefully close connection to stomp server .", "label": 0}, {"idx": "cosqa-train-1397", "doc": "how to stop a python program running in the background", "code": "def timeout_thread_handler(timeout, stop_event):\n    \"\"\"A background thread to kill the process if it takes too long.\n\n    Args:\n        timeout (float): The number of seconds to wait before killing\n            the process.\n        stop_event (Event): An optional event to cleanly stop the background\n            thread if required during testing.\n    \"\"\"\n\n    stop_happened = stop_event.wait(timeout)\n    if stop_happened is False:\n        print(\"Killing program due to %f second timeout\" % timeout)\n\n    os._exit(2)", "code_tokens": "def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( \"Killing program due to %f second timeout\" % timeout ) os . _exit ( 2 )", "docstring_tokens": "A background thread to kill the process if it takes too long .", "label": 1}, {"idx": "cosqa-train-1398", "doc": "python stop logging for unit tests", "code": "def _configure_logger():\n    \"\"\"Configure the logging module.\"\"\"\n    if not app.debug:\n        _configure_logger_for_production(logging.getLogger())\n    elif not app.testing:\n        _configure_logger_for_debugging(logging.getLogger())", "code_tokens": "def _configure_logger ( ) : if not app . debug : _configure_logger_for_production ( logging . getLogger ( ) ) elif not app . testing : _configure_logger_for_debugging ( logging . getLogger ( ) )", "docstring_tokens": "Configure the logging module .", "label": 1}, {"idx": "cosqa-train-1399", "doc": "how to stop a python thread object", "code": "def _StopStatusUpdateThread(self):\n    \"\"\"Stops the status update thread.\"\"\"\n    self._status_update_active = False\n    if self._status_update_thread.isAlive():\n      self._status_update_thread.join()\n    self._status_update_thread = None", "code_tokens": "def _StopStatusUpdateThread ( self ) : self . _status_update_active = False if self . _status_update_thread . isAlive ( ) : self . _status_update_thread . join ( ) self . _status_update_thread = None", "docstring_tokens": "Stops the status update thread .", "label": 0}, {"idx": "cosqa-train-1400", "doc": "python str decode types", "code": "def to_binary(s, encoding='utf8'):\n    \"\"\"Portable cast function.\n\n    In python 2 the ``str`` function which is used to coerce objects to bytes does not\n    accept an encoding argument, whereas python 3's ``bytes`` function requires one.\n\n    :param s: object to be converted to binary_type\n    :return: binary_type instance, representing s.\n    \"\"\"\n    if PY3:  # pragma: no cover\n        return s if isinstance(s, binary_type) else binary_type(s, encoding=encoding)\n    return binary_type(s)", "code_tokens": "def to_binary ( s , encoding = 'utf8' ) : if PY3 : # pragma: no cover return s if isinstance ( s , binary_type ) else binary_type ( s , encoding = encoding ) return binary_type ( s )", "docstring_tokens": "Portable cast function .", "label": 0}, {"idx": "cosqa-train-1401", "doc": "how to stop python auto gui", "code": "def stop_button_click_handler(self):\n        \"\"\"Method to handle what to do when the stop button is pressed\"\"\"\n        self.stop_button.setDisabled(True)\n        # Interrupt computations or stop debugging\n        if not self.shellwidget._reading:\n            self.interrupt_kernel()\n        else:\n            self.shellwidget.write_to_stdin('exit')", "code_tokens": "def stop_button_click_handler ( self ) : self . stop_button . setDisabled ( True ) # Interrupt computations or stop debugging\n if not self . shellwidget . _reading : self . interrupt_kernel ( ) else : self . shellwidget . write_to_stdin ( 'exit' )", "docstring_tokens": "Method to handle what to do when the stop button is pressed", "label": 0}, {"idx": "cosqa-train-1402", "doc": "python str format md5 hashlib", "code": "def md5_string(s):\n    \"\"\"\n    Shortcut to create md5 hash\n    :param s:\n    :return:\n    \"\"\"\n    m = hashlib.md5()\n    m.update(s)\n    return str(m.hexdigest())", "code_tokens": "def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )", "docstring_tokens": "Shortcut to create md5 hash : param s : : return :", "label": 0}, {"idx": "cosqa-train-1403", "doc": "how to supress subprocess output python", "code": "def disown(cmd):\n    \"\"\"Call a system command in the background,\n       disown it and hide it's output.\"\"\"\n    subprocess.Popen(cmd,\n                     stdout=subprocess.DEVNULL,\n                     stderr=subprocess.DEVNULL)", "code_tokens": "def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "docstring_tokens": "Call a system command in the background disown it and hide it s output .", "label": 0}, {"idx": "cosqa-train-1404", "doc": "python str is valid date", "code": "def _validate_date_str(str_):\n    \"\"\"Validate str as a date and return string version of date\"\"\"\n\n    if not str_:\n        return None\n\n    # Convert to datetime so we can validate it's a real date that exists then\n    # convert it back to the string.\n    try:\n        date = datetime.strptime(str_, DATE_FMT)\n    except ValueError:\n        msg = 'Invalid date format, should be YYYY-MM-DD'\n        raise argparse.ArgumentTypeError(msg)\n\n    return date.strftime(DATE_FMT)", "code_tokens": "def _validate_date_str ( str_ ) : if not str_ : return None # Convert to datetime so we can validate it's a real date that exists then # convert it back to the string. try : date = datetime . strptime ( str_ , DATE_FMT ) except ValueError : msg = 'Invalid date format, should be YYYY-MM-DD' raise argparse . ArgumentTypeError ( msg ) return date . strftime ( DATE_FMT )", "docstring_tokens": "Validate str as a date and return string version of date", "label": 1}, {"idx": "cosqa-train-1405", "doc": "how to take a matrix to a power in python", "code": "def magnitude(X):\n    \"\"\"Magnitude of a complex matrix.\"\"\"\n    r = np.real(X)\n    i = np.imag(X)\n    return np.sqrt(r * r + i * i);", "code_tokens": "def magnitude ( X ) : r = np . real ( X ) i = np . imag ( X ) return np . sqrt ( r * r + i * i )", "docstring_tokens": "Magnitude of a complex matrix .", "label": 0}, {"idx": "cosqa-train-1406", "doc": "python str to fileobject", "code": "def loads(s, model=None, parser=None):\n    \"\"\"Deserialize s (a str) to a Python object.\"\"\"\n    with StringIO(s) as f:\n        return load(f, model=model, parser=parser)", "code_tokens": "def loads ( s , model = None , parser = None ) : with StringIO ( s ) as f : return load ( f , model = model , parser = parser )", "docstring_tokens": "Deserialize s ( a str ) to a Python object .", "label": 0}, {"idx": "cosqa-train-1407", "doc": "how to take dot product of two vecotrs in python", "code": "def dot(self, w):\n        \"\"\"Return the dotproduct between self and another vector.\"\"\"\n\n        return sum([x * y for x, y in zip(self, w)])", "code_tokens": "def dot ( self , w ) : return sum ( [ x * y for x , y in zip ( self , w ) ] )", "docstring_tokens": "Return the dotproduct between self and another vector .", "label": 0}, {"idx": "cosqa-train-1408", "doc": "python stream from image bytes", "code": "def from_bytes(cls, b):\n\t\t\"\"\"Create :class:`PNG` from raw bytes.\n\t\t\n\t\t:arg bytes b: The raw bytes of the PNG file.\n\t\t:rtype: :class:`PNG`\n\t\t\"\"\"\n\t\tim = cls()\n\t\tim.chunks = list(parse_chunks(b))\n\t\tim.init()\n\t\treturn im", "code_tokens": "def from_bytes ( cls , b ) : im = cls ( ) im . chunks = list ( parse_chunks ( b ) ) im . init ( ) return im", "docstring_tokens": "Create : class : PNG from raw bytes . : arg bytes b : The raw bytes of the PNG file . : rtype : : class : PNG", "label": 0}, {"idx": "cosqa-train-1409", "doc": "how to take the average value each day on group of datetime strings in python", "code": "def mean_date(dt_list):\n    \"\"\"Calcuate mean datetime from datetime list\n    \"\"\"\n    dt_list_sort = sorted(dt_list)\n    dt_list_sort_rel = [dt - dt_list_sort[0] for dt in dt_list_sort]\n    avg_timedelta = sum(dt_list_sort_rel, timedelta())/len(dt_list_sort_rel)\n    return dt_list_sort[0] + avg_timedelta", "code_tokens": "def mean_date ( dt_list ) : dt_list_sort = sorted ( dt_list ) dt_list_sort_rel = [ dt - dt_list_sort [ 0 ] for dt in dt_list_sort ] avg_timedelta = sum ( dt_list_sort_rel , timedelta ( ) ) / len ( dt_list_sort_rel ) return dt_list_sort [ 0 ] + avg_timedelta", "docstring_tokens": "Calcuate mean datetime from datetime list", "label": 1}, {"idx": "cosqa-train-1410", "doc": "python stream json to file", "code": "def _serialize_json(obj, fp):\n    \"\"\" Serialize ``obj`` as a JSON formatted stream to ``fp`` \"\"\"\n    json.dump(obj, fp, indent=4, default=serialize)", "code_tokens": "def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )", "docstring_tokens": "Serialize obj as a JSON formatted stream to fp", "label": 0}, {"idx": "cosqa-train-1411", "doc": "how to tell if a url is valid in python", "code": "def is_valid_url(url):\n    \"\"\"Checks if a given string is an url\"\"\"\n    pieces = urlparse(url)\n    return all([pieces.scheme, pieces.netloc])", "code_tokens": "def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )", "docstring_tokens": "Checks if a given string is an url", "label": 0}, {"idx": "cosqa-train-1412", "doc": "python strftime millisecond digits", "code": "def fmt_duration(secs):\n    \"\"\"Format a duration in seconds.\"\"\"\n    return ' '.join(fmt.human_duration(secs, 0, precision=2, short=True).strip().split())", "code_tokens": "def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )", "docstring_tokens": "Format a duration in seconds .", "label": 0}, {"idx": "cosqa-train-1413", "doc": "how to tell size of array in python", "code": "def bytesize(arr):\n    \"\"\"\n    Returns the memory byte size of a Numpy array as an integer.\n    \"\"\"\n    byte_size = np.prod(arr.shape) * np.dtype(arr.dtype).itemsize\n    return byte_size", "code_tokens": "def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size", "docstring_tokens": "Returns the memory byte size of a Numpy array as an integer .", "label": 0}, {"idx": "cosqa-train-1414", "doc": "python string % substitution float", "code": "def format_float(value): # not used\n    \"\"\"Modified form of the 'g' format specifier.\n    \"\"\"\n    string = \"{:g}\".format(value).replace(\"e+\", \"e\")\n    string = re.sub(\"e(-?)0*(\\d+)\", r\"e\\1\\2\", string)\n    return string", "code_tokens": "def format_float ( value ) : # not used string = \"{:g}\" . format ( value ) . replace ( \"e+\" , \"e\" ) string = re . sub ( \"e(-?)0*(\\d+)\" , r\"e\\1\\2\" , string ) return string", "docstring_tokens": "Modified form of the g format specifier .", "label": 1}, {"idx": "cosqa-train-1415", "doc": "how to test for maximum of a random integer function python", "code": "def random_int(maximum_value):\n\t\"\"\" Random generator (PyCrypto getrandbits wrapper). The result is a non-negative value.\n\n\t:param maximum_value: maximum integer value\n\t:return: int\n\t\"\"\"\n\tif maximum_value == 0:\n\t\treturn 0\n\telif maximum_value == 1:\n\t\treturn random_bits(1)\n\n\tbits = math.floor(math.log2(maximum_value))\n\tresult = random_bits(bits) + random_int(maximum_value - ((2 ** bits) - 1))\n\treturn result", "code_tokens": "def random_int ( maximum_value ) : if maximum_value == 0 : return 0 elif maximum_value == 1 : return random_bits ( 1 ) bits = math . floor ( math . log2 ( maximum_value ) ) result = random_bits ( bits ) + random_int ( maximum_value - ( ( 2 ** bits ) - 1 ) ) return result", "docstring_tokens": "Random generator ( PyCrypto getrandbits wrapper ) . The result is a non - negative value .", "label": 1}, {"idx": "cosqa-train-1416", "doc": "python string a float", "code": "def covstr(s):\n  \"\"\" convert string to int or float. \"\"\"\n  try:\n    ret = int(s)\n  except ValueError:\n    ret = float(s)\n  return ret", "code_tokens": "def covstr ( s ) : try : ret = int ( s ) except ValueError : ret = float ( s ) return ret", "docstring_tokens": "convert string to int or float .", "label": 0}, {"idx": "cosqa-train-1417", "doc": "how to test if a kwarg was supplied in python", "code": "def _system_parameters(**kwargs):\n    \"\"\"\n    Returns system keyword arguments removing Nones.\n\n    Args:\n        kwargs: system keyword arguments.\n\n    Returns:\n        dict: system keyword arguments.\n    \"\"\"\n    return {key: value for key, value in kwargs.items()\n            if (value is not None or value == {})}", "code_tokens": "def _system_parameters ( * * kwargs ) : return { key : value for key , value in kwargs . items ( ) if ( value is not None or value == { } ) }", "docstring_tokens": "Returns system keyword arguments removing Nones .", "label": 0}, {"idx": "cosqa-train-1418", "doc": "python string binary to int", "code": "def _from_bytes(bytes, byteorder=\"big\", signed=False):\n    \"\"\"This is the same functionality as ``int.from_bytes`` in python 3\"\"\"\n    return int.from_bytes(bytes, byteorder=byteorder, signed=signed)", "code_tokens": "def _from_bytes ( bytes , byteorder = \"big\" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )", "docstring_tokens": "This is the same functionality as int . from_bytes in python 3", "label": 0}, {"idx": "cosqa-train-1419", "doc": "how to test if it is a string python", "code": "def is_string(val):\n    \"\"\"Determines whether the passed value is a string, safe for 2/3.\"\"\"\n    try:\n        basestring\n    except NameError:\n        return isinstance(val, str)\n    return isinstance(val, basestring)", "code_tokens": "def is_string ( val ) : try : basestring except NameError : return isinstance ( val , str ) return isinstance ( val , basestring )", "docstring_tokens": "Determines whether the passed value is a string safe for 2 / 3 .", "label": 0}, {"idx": "cosqa-train-1420", "doc": "python string comparison case", "code": "def _match_literal(self, a, b=None):\n        \"\"\"Match two names.\"\"\"\n\n        return a.lower() == b if not self.case_sensitive else a == b", "code_tokens": "def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b", "docstring_tokens": "Match two names .", "label": 0}, {"idx": "cosqa-train-1421", "doc": "how to total a list without reduce python", "code": "def lcumsum (inlist):\n    \"\"\"\nReturns a list consisting of the cumulative sum of the items in the\npassed list.\n\nUsage:   lcumsum(inlist)\n\"\"\"\n    newlist = copy.deepcopy(inlist)\n    for i in range(1,len(newlist)):\n        newlist[i] = newlist[i] + newlist[i-1]\n    return newlist", "code_tokens": "def lcumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist", "docstring_tokens": "Returns a list consisting of the cumulative sum of the items in the passed list .", "label": 0}, {"idx": "cosqa-train-1422", "doc": "python string contains non hex characters in a string", "code": "def is_hex_string(string):\n    \"\"\"Check if the string is only composed of hex characters.\"\"\"\n    pattern = re.compile(r'[A-Fa-f0-9]+')\n    if isinstance(string, six.binary_type):\n        string = str(string)\n    return pattern.match(string) is not None", "code_tokens": "def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None", "docstring_tokens": "Check if the string is only composed of hex characters .", "label": 0}, {"idx": "cosqa-train-1423", "doc": "how to train and fit model and test accuracy python", "code": "def local_accuracy(X_train, y_train, X_test, y_test, attr_test, model_generator, metric, trained_model):\n    \"\"\" The how well do the features plus a constant base rate sum up to the model output.\n    \"\"\"\n\n    X_train, X_test = to_array(X_train, X_test)\n\n    # how many features to mask\n    assert X_train.shape[1] == X_test.shape[1]\n\n    # keep nkeep top features and re-train the model for each test explanation\n    yp_test = trained_model.predict(X_test)\n\n    return metric(yp_test, strip_list(attr_test).sum(1))", "code_tokens": "def local_accuracy ( X_train , y_train , X_test , y_test , attr_test , model_generator , metric , trained_model ) : X_train , X_test = to_array ( X_train , X_test ) # how many features to mask assert X_train . shape [ 1 ] == X_test . shape [ 1 ] # keep nkeep top features and re-train the model for each test explanation yp_test = trained_model . predict ( X_test ) return metric ( yp_test , strip_list ( attr_test ) . sum ( 1 ) )", "docstring_tokens": "The how well do the features plus a constant base rate sum up to the model output .", "label": 0}, {"idx": "cosqa-train-1424", "doc": "python string contains non hex charcters in a string", "code": "def is_hex_string(string):\n    \"\"\"Check if the string is only composed of hex characters.\"\"\"\n    pattern = re.compile(r'[A-Fa-f0-9]+')\n    if isinstance(string, six.binary_type):\n        string = str(string)\n    return pattern.match(string) is not None", "code_tokens": "def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None", "docstring_tokens": "Check if the string is only composed of hex characters .", "label": 0}, {"idx": "cosqa-train-1425", "doc": "how to turn a document ino python", "code": "def doc_to_html(doc, doc_format=\"ROBOT\"):\n    \"\"\"Convert documentation to HTML\"\"\"\n    from robot.libdocpkg.htmlwriter import DocToHtml\n    return DocToHtml(doc_format)(doc)", "code_tokens": "def doc_to_html ( doc , doc_format = \"ROBOT\" ) : from robot . libdocpkg . htmlwriter import DocToHtml return DocToHtml ( doc_format ) ( doc )", "docstring_tokens": "Convert documentation to HTML", "label": 0}, {"idx": "cosqa-train-1426", "doc": "python string to cstr", "code": "def c_str(string):\n    \"\"\"\"Convert a python string to C string.\"\"\"\n    if not isinstance(string, str):\n        string = string.decode('ascii')\n    return ctypes.c_char_p(string.encode('utf-8'))", "code_tokens": "def c_str ( string ) : if not isinstance ( string , str ) : string = string . decode ( 'ascii' ) return ctypes . c_char_p ( string . encode ( 'utf-8' ) )", "docstring_tokens": "Convert a python string to C string .", "label": 0}, {"idx": "cosqa-train-1427", "doc": "how to turn an array of arrays into an list python", "code": "def pack_triples_numpy(triples):\n    \"\"\"Packs a list of triple indexes into a 2D numpy array.\"\"\"\n    if len(triples) == 0:\n        return np.array([], dtype=np.int64)\n    return np.stack(list(map(_transform_triple_numpy, triples)), axis=0)", "code_tokens": "def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )", "docstring_tokens": "Packs a list of triple indexes into a 2D numpy array .", "label": 0}, {"idx": "cosqa-train-1428", "doc": "python string to float based on format", "code": "def _convert_to_float_if_possible(s):\n    \"\"\"\n    A small helper function to convert a string to a numeric value\n    if appropriate\n\n    :param s: the string to be converted\n    :type s: str\n    \"\"\"\n    try:\n        ret = float(s)\n    except (ValueError, TypeError):\n        ret = s\n    return ret", "code_tokens": "def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret", "docstring_tokens": "A small helper function to convert a string to a numeric value if appropriate", "label": 0}, {"idx": "cosqa-train-1429", "doc": "how to turn str to bytes python", "code": "def str2bytes(x):\n  \"\"\"Convert input argument to bytes\"\"\"\n  if type(x) is bytes:\n    return x\n  elif type(x) is str:\n    return bytes([ ord(i) for i in x ])\n  else:\n    return str2bytes(str(x))", "code_tokens": "def str2bytes ( x ) : if type ( x ) is bytes : return x elif type ( x ) is str : return bytes ( [ ord ( i ) for i in x ] ) else : return str2bytes ( str ( x ) )", "docstring_tokens": "Convert input argument to bytes", "label": 0}, {"idx": "cosqa-train-1430", "doc": "python string to hash code", "code": "def _string_hash(s):\n    \"\"\"String hash (djb2) with consistency between py2/py3 and persistency between runs (unlike `hash`).\"\"\"\n    h = 5381\n    for c in s:\n        h = h * 33 + ord(c)\n    return h", "code_tokens": "def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h", "docstring_tokens": "String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) .", "label": 0}, {"idx": "cosqa-train-1431", "doc": "how to type a string in python", "code": "def visit_Str(self, node):\n        \"\"\" Set the pythonic string type. \"\"\"\n        self.result[node] = self.builder.NamedType(pytype_to_ctype(str))", "code_tokens": "def visit_Str ( self , node ) : self . result [ node ] = self . builder . NamedType ( pytype_to_ctype ( str ) )", "docstring_tokens": "Set the pythonic string type .", "label": 1}, {"idx": "cosqa-train-1432", "doc": "python string to java", "code": "def string_list_to_array(l):\n    \"\"\"\n    Turns a Python unicode string list into a Java String array.\n\n    :param l: the string list\n    :type: list\n    :rtype: java string array\n    :return: JB_Object\n    \"\"\"\n    result = javabridge.get_env().make_object_array(len(l), javabridge.get_env().find_class(\"java/lang/String\"))\n    for i in range(len(l)):\n        javabridge.get_env().set_object_array_element(result, i, javabridge.get_env().new_string_utf(l[i]))\n    return result", "code_tokens": "def string_list_to_array ( l ) : result = javabridge . get_env ( ) . make_object_array ( len ( l ) , javabridge . get_env ( ) . find_class ( \"java/lang/String\" ) ) for i in range ( len ( l ) ) : javabridge . get_env ( ) . set_object_array_element ( result , i , javabridge . get_env ( ) . new_string_utf ( l [ i ] ) ) return result", "docstring_tokens": "Turns a Python unicode string list into a Java String array .", "label": 1}, {"idx": "cosqa-train-1433", "doc": "how to typecast a list in python", "code": "def coerce(self, value):\n        \"\"\"Convert from whatever is given to a list of scalars for the lookup_field.\"\"\"\n        if isinstance(value, dict):\n            value = [value]\n        if not isiterable_notstring(value):\n            value = [value]\n        return [coerce_single_instance(self.lookup_field, v) for v in value]", "code_tokens": "def coerce ( self , value ) : if isinstance ( value , dict ) : value = [ value ] if not isiterable_notstring ( value ) : value = [ value ] return [ coerce_single_instance ( self . lookup_field , v ) for v in value ]", "docstring_tokens": "Convert from whatever is given to a list of scalars for the lookup_field .", "label": 0}, {"idx": "cosqa-train-1434", "doc": "python strip non word characters", "code": "def drop_bad_characters(text):\n    \"\"\"Takes a text and drops all non-printable and non-ascii characters and\n    also any whitespace characters that aren't space.\n\n    :arg str text: the text to fix\n\n    :returns: text with all bad characters dropped\n\n    \"\"\"\n    # Strip all non-ascii and non-printable characters\n    text = ''.join([c for c in text if c in ALLOWED_CHARS])\n    return text", "code_tokens": "def drop_bad_characters ( text ) : # Strip all non-ascii and non-printable characters text = '' . join ( [ c for c in text if c in ALLOWED_CHARS ] ) return text", "docstring_tokens": "Takes a text and drops all non - printable and non - ascii characters and also any whitespace characters that aren t space .", "label": 0}, {"idx": "cosqa-train-1435", "doc": "how to unregister for python", "code": "def removeFromRegistery(obj) :\n\t\"\"\"Removes an object/rabalist from registery. This is useful if you want to allow the garbage collector to free the memory\n\ttaken by the objects you've already loaded. Be careful might cause some discrepenties in your scripts. For objects,\n\tcascades to free the registeries of related rabalists also\"\"\"\n\t\n\tif isRabaObject(obj) :\n\t\t_unregisterRabaObjectInstance(obj)\n\telif isRabaList(obj) :\n\t\t_unregisterRabaListInstance(obj)", "code_tokens": "def removeFromRegistery ( obj ) : if isRabaObject ( obj ) : _unregisterRabaObjectInstance ( obj ) elif isRabaList ( obj ) : _unregisterRabaListInstance ( obj )", "docstring_tokens": "Removes an object / rabalist from registery . This is useful if you want to allow the garbage collector to free the memory taken by the objects you ve already loaded . Be careful might cause some discrepenties in your scripts . For objects cascades to free the registeries of related rabalists also", "label": 0}, {"idx": "cosqa-train-1436", "doc": "python strip none list", "code": "def filter_none(list_of_points):\n    \"\"\"\n    \n    :param list_of_points: \n    :return: list_of_points with None's removed\n    \"\"\"\n    remove_elementnone = filter(lambda p: p is not None, list_of_points)\n    remove_sublistnone = filter(lambda p: not contains_none(p), remove_elementnone)\n    return list(remove_sublistnone)", "code_tokens": "def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "docstring_tokens": ": param list_of_points : : return : list_of_points with None s removed", "label": 0}, {"idx": "cosqa-train-1437", "doc": "how to unzip gz file python", "code": "def _unzip_handle(handle):\n    \"\"\"Transparently unzip the file handle\"\"\"\n    if isinstance(handle, basestring):\n        handle = _gzip_open_filename(handle)\n    else:\n        handle = _gzip_open_handle(handle)\n    return handle", "code_tokens": "def _unzip_handle ( handle ) : if isinstance ( handle , basestring ) : handle = _gzip_open_filename ( handle ) else : handle = _gzip_open_handle ( handle ) return handle", "docstring_tokens": "Transparently unzip the file handle", "label": 0}, {"idx": "cosqa-train-1438", "doc": "python substring index variable", "code": "def fsliceafter(astr, sub):\n    \"\"\"Return the slice after at sub in string astr\"\"\"\n    findex = astr.find(sub)\n    return astr[findex + len(sub):]", "code_tokens": "def fsliceafter ( astr , sub ) : findex = astr . find ( sub ) return astr [ findex + len ( sub ) : ]", "docstring_tokens": "Return the slice after at sub in string astr", "label": 0}, {"idx": "cosqa-train-1439", "doc": "how to update a x, y tuple python", "code": "def _update_texttuple(self, x, y, s, cs, d):\n        \"\"\"Update the text tuple at `x` and `y` with the given `s` and `d`\"\"\"\n        pos = (x, y, cs)\n        for i, (old_x, old_y, old_s, old_cs, old_d) in enumerate(self.value):\n            if (old_x, old_y, old_cs) == pos:\n                self.value[i] = (old_x, old_y, s, old_cs, d)\n                return\n        raise ValueError(\"No text tuple found at {0}!\".format(pos))", "code_tokens": "def _update_texttuple ( self , x , y , s , cs , d ) : pos = ( x , y , cs ) for i , ( old_x , old_y , old_s , old_cs , old_d ) in enumerate ( self . value ) : if ( old_x , old_y , old_cs ) == pos : self . value [ i ] = ( old_x , old_y , s , old_cs , d ) return raise ValueError ( \"No text tuple found at {0}!\" . format ( pos ) )", "docstring_tokens": "Update the text tuple at x and y with the given s and d", "label": 0}, {"idx": "cosqa-train-1440", "doc": "python suds authenticate to soap web service", "code": "def authenticate(self, transport, account_name, password=None):\n        \"\"\"\n        Authenticates account using soap method.\n        \"\"\"\n        Authenticator.authenticate(self, transport, account_name, password)\n\n        if password == None:\n            return self.pre_auth(transport, account_name)\n        else:\n            return self.auth(transport, account_name, password)", "code_tokens": "def authenticate ( self , transport , account_name , password = None ) : Authenticator . authenticate ( self , transport , account_name , password ) if password == None : return self . pre_auth ( transport , account_name ) else : return self . auth ( transport , account_name , password )", "docstring_tokens": "Authenticates account using soap method .", "label": 0}, {"idx": "cosqa-train-1441", "doc": "how to uppercase or lowercase using lists in python", "code": "def upcaseTokens(s,l,t):\n    \"\"\"Helper parse action to convert tokens to upper case.\"\"\"\n    return [ tt.upper() for tt in map(_ustr,t) ]", "code_tokens": "def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]", "docstring_tokens": "Helper parse action to convert tokens to upper case .", "label": 0}, {"idx": "cosqa-train-1442", "doc": "python suspend until response", "code": "def _wait_for_response(self):\n\t\t\"\"\"\n\t\tWait until the user accepted or rejected the request\n\t\t\"\"\"\n\t\twhile not self.server.response_code:\n\t\t\ttime.sleep(2)\n\t\ttime.sleep(5)\n\t\tself.server.shutdown()", "code_tokens": "def _wait_for_response ( self ) : while not self . server . response_code : time . sleep ( 2 ) time . sleep ( 5 ) self . server . shutdown ( )", "docstring_tokens": "Wait until the user accepted or rejected the request", "label": 1}, {"idx": "cosqa-train-1443", "doc": "how to use a dictionary to replace in python", "code": "def copy_and_update(dictionary, update):\n    \"\"\"Returns an updated copy of the dictionary without modifying the original\"\"\"\n    newdict = dictionary.copy()\n    newdict.update(update)\n    return newdict", "code_tokens": "def copy_and_update ( dictionary , update ) : newdict = dictionary . copy ( ) newdict . update ( update ) return newdict", "docstring_tokens": "Returns an updated copy of the dictionary without modifying the original", "label": 0}, {"idx": "cosqa-train-1444", "doc": "python sync tables sqlalchem", "code": "def init_db():\n    \"\"\"\n    Drops and re-creates the SQL schema\n    \"\"\"\n    db.drop_all()\n    db.configure_mappers()\n    db.create_all()\n    db.session.commit()", "code_tokens": "def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )", "docstring_tokens": "Drops and re - creates the SQL schema", "label": 0}, {"idx": "cosqa-train-1445", "doc": "how to use a predict function on python", "code": "def _do_auto_predict(machine, X, *args):\n    \"\"\"Performs an automatic prediction for the specified machine and returns\n    the predicted values.\n    \"\"\"\n    if auto_predict and hasattr(machine, \"predict\"):\n        return machine.predict(X)", "code_tokens": "def _do_auto_predict ( machine , X , * args ) : if auto_predict and hasattr ( machine , \"predict\" ) : return machine . predict ( X )", "docstring_tokens": "Performs an automatic prediction for the specified machine and returns the predicted values .", "label": 0}, {"idx": "cosqa-train-1446", "doc": "python table like output", "code": "def get_table(ports):\n    \"\"\"\n    This function returns a pretty table used to display the port results.\n\n    :param ports: list of found ports\n    :return: the table to display\n    \"\"\"\n    table = PrettyTable([\"Name\", \"Port\", \"Protocol\", \"Description\"])\n    table.align[\"Name\"] = \"l\"\n    table.align[\"Description\"] = \"l\"\n    table.padding_width = 1\n\n    for port in ports:\n        table.add_row(port)\n\n    return table", "code_tokens": "def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "docstring_tokens": "This function returns a pretty table used to display the port results .", "label": 1}, {"idx": "cosqa-train-1447", "doc": "how to use capitalize to make every word in a string upper case python", "code": "def to_pascal_case(s):\n    \"\"\"Transform underscore separated string to pascal case\n\n    \"\"\"\n    return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())", "code_tokens": "def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )", "docstring_tokens": "Transform underscore separated string to pascal case", "label": 1}, {"idx": "cosqa-train-1448", "doc": "python table to dict", "code": "def row_to_dict(row):\n    \"\"\"Convert a table row to a dictionary.\"\"\"\n    o = {}\n    for colname in row.colnames:\n\n        if isinstance(row[colname], np.string_) and row[colname].dtype.kind in ['S', 'U']:\n            o[colname] = str(row[colname])\n        else:\n            o[colname] = row[colname]\n\n    return o", "code_tokens": "def row_to_dict ( row ) : o = { } for colname in row . colnames : if isinstance ( row [ colname ] , np . string_ ) and row [ colname ] . dtype . kind in [ 'S' , 'U' ] : o [ colname ] = str ( row [ colname ] ) else : o [ colname ] = row [ colname ] return o", "docstring_tokens": "Convert a table row to a dictionary .", "label": 0}, {"idx": "cosqa-train-1449", "doc": "how to use colons in a string in python", "code": "def color_string(color, string):\n    \"\"\"\n    Colorizes a given string, if coloring is available.\n    \"\"\"\n    if not color_available:\n        return string\n\n    return color + string + colorama.Fore.RESET", "code_tokens": "def color_string ( color , string ) : if not color_available : return string return color + string + colorama . Fore . RESET", "docstring_tokens": "Colorizes a given string if coloring is available .", "label": 0}, {"idx": "cosqa-train-1450", "doc": "python task auto start", "code": "def execute(self, env, args):\n        \"\"\" Starts a new task.\n\n            `env`\n                Runtime ``Environment`` instance.\n            `args`\n                Arguments object from arg parser.\n            \"\"\"\n\n        # start the task\n        if env.task.start(args.task_name):\n            env.io.success(u'Task Loaded.')", "code_tokens": "def execute ( self , env , args ) : # start the task if env . task . start ( args . task_name ) : env . io . success ( u'Task Loaded.' )", "docstring_tokens": "Starts a new task .", "label": 0}, {"idx": "cosqa-train-1451", "doc": "how to use local stopwords file in python", "code": "def get_stoplist(language):\n    \"\"\"Returns an built-in stop-list for the language as a set of words.\"\"\"\n    file_path = os.path.join(\"stoplists\", \"%s.txt\" % language)\n    try:\n        stopwords = pkgutil.get_data(\"justext\", file_path)\n    except IOError:\n        raise ValueError(\n            \"Stoplist for language '%s' is missing. \"\n            \"Please use function 'get_stoplists' for complete list of stoplists \"\n            \"and feel free to contribute by your own stoplist.\" % language\n        )\n\n    return frozenset(w.decode(\"utf8\").lower() for w in stopwords.splitlines())", "code_tokens": "def get_stoplist ( language ) : file_path = os . path . join ( \"stoplists\" , \"%s.txt\" % language ) try : stopwords = pkgutil . get_data ( \"justext\" , file_path ) except IOError : raise ValueError ( \"Stoplist for language '%s' is missing. \" \"Please use function 'get_stoplists' for complete list of stoplists \" \"and feel free to contribute by your own stoplist.\" % language ) return frozenset ( w . decode ( \"utf8\" ) . lower ( ) for w in stopwords . splitlines ( ) )", "docstring_tokens": "Returns an built - in stop - list for the language as a set of words .", "label": 0}, {"idx": "cosqa-train-1452", "doc": "python temp file creation for testing", "code": "def create_tmpfile(self, content):\n        \"\"\" Utility method to create temp files. These are cleaned at the end of the test \"\"\"\n        # Not using a context manager to avoid unneccessary identation in test code\n        tmpfile, tmpfilepath = tempfile.mkstemp()\n        self.tmpfiles.append(tmpfilepath)\n        with os.fdopen(tmpfile, \"w\") as f:\n            f.write(content)\n        return tmpfilepath", "code_tokens": "def create_tmpfile ( self , content ) : # Not using a context manager to avoid unneccessary identation in test code tmpfile , tmpfilepath = tempfile . mkstemp ( ) self . tmpfiles . append ( tmpfilepath ) with os . fdopen ( tmpfile , \"w\" ) as f : f . write ( content ) return tmpfilepath", "docstring_tokens": "Utility method to create temp files . These are cleaned at the end of the test", "label": 0}, {"idx": "cosqa-train-1453", "doc": "how to use multiple logical opetators in python", "code": "def aandb(a, b):\n    \"\"\"Return a matrix of logic comparison of A or B\"\"\"\n    return matrix(np.logical_and(a, b).astype('float'), a.size)", "code_tokens": "def aandb ( a , b ) : return matrix ( np . logical_and ( a , b ) . astype ( 'float' ) , a . size )", "docstring_tokens": "Return a matrix of logic comparison of A or B", "label": 0}, {"idx": "cosqa-train-1454", "doc": "python template render json object", "code": "def json_template(data, template_name, template_context):\n    \"\"\"Old style, use JSONTemplateResponse instead of this.\n    \"\"\"\n    html = render_to_string(template_name, template_context)\n    data = data or {}\n    data['html'] = html\n    return HttpResponse(json_encode(data), content_type='application/json')", "code_tokens": "def json_template ( data , template_name , template_context ) : html = render_to_string ( template_name , template_context ) data = data or { } data [ 'html' ] = html return HttpResponse ( json_encode ( data ) , content_type = 'application/json' )", "docstring_tokens": "Old style use JSONTemplateResponse instead of this .", "label": 0}, {"idx": "cosqa-train-1455", "doc": "how to use pymongo query in mongoengine in python", "code": "def find(self, *args, **kwargs):\n        \"\"\"Same as :meth:`pymongo.collection.Collection.find`, except\n        it returns the right document class.\n        \"\"\"\n        return Cursor(self, *args, wrap=self.document_class, **kwargs)", "code_tokens": "def find ( self , * args , * * kwargs ) : return Cursor ( self , * args , wrap = self . document_class , * * kwargs )", "docstring_tokens": "Same as : meth : pymongo . collection . Collection . find except it returns the right document class .", "label": 0}, {"idx": "cosqa-train-1456", "doc": "python tensor of dimension (h, w)", "code": "def unfolding(tens, i):\n    \"\"\"Compute the i-th unfolding of a tensor.\"\"\"\n    return reshape(tens.full(), (np.prod(tens.n[0:(i+1)]), -1))", "code_tokens": "def unfolding ( tens , i ) : return reshape ( tens . full ( ) , ( np . prod ( tens . n [ 0 : ( i + 1 ) ] ) , - 1 ) )", "docstring_tokens": "Compute the i - th unfolding of a tensor .", "label": 0}, {"idx": "cosqa-train-1457", "doc": "how to use python ldap to query some users", "code": "def members(self, uid=\"*\", objects=False):\n        \"\"\" members() issues an ldap query for all users, and returns a dict\n            for each matching entry. This can be quite slow, and takes roughly\n            3s to complete. You may optionally restrict the scope by specifying\n            a uid, which is roughly equivalent to a search(uid='foo')\n        \"\"\"\n        entries = self.search(uid='*')\n        if objects:\n            return self.memberObjects(entries)\n        result = []\n        for entry in entries:\n            result.append(entry[1])\n        return result", "code_tokens": "def members ( self , uid = \"*\" , objects = False ) : entries = self . search ( uid = '*' ) if objects : return self . memberObjects ( entries ) result = [ ] for entry in entries : result . append ( entry [ 1 ] ) return result", "docstring_tokens": "members () issues an ldap query for all users and returns a dict for each matching entry . This can be quite slow and takes roughly 3s to complete . You may optionally restrict the scope by specifying a uid which is roughly equivalent to a search ( uid = foo )", "label": 0}, {"idx": "cosqa-train-1458", "doc": "python tensorflow auc incompatible shapes", "code": "def flatten_all_but_last(a):\n  \"\"\"Flatten all dimensions of a except the last.\"\"\"\n  ret = tf.reshape(a, [-1, tf.shape(a)[-1]])\n  if not tf.executing_eagerly():\n    ret.set_shape([None] + a.get_shape().as_list()[-1:])\n  return ret", "code_tokens": "def flatten_all_but_last ( a ) : ret = tf . reshape ( a , [ - 1 , tf . shape ( a ) [ - 1 ] ] ) if not tf . executing_eagerly ( ) : ret . set_shape ( [ None ] + a . get_shape ( ) . as_list ( ) [ - 1 : ] ) return ret", "docstring_tokens": "Flatten all dimensions of a except the last .", "label": 0}, {"idx": "cosqa-train-1459", "doc": "how to use remove last thing inserted in a list in python", "code": "def list_move_to_front(l,value='other'):\n    \"\"\"if the value is in the list, move it to the front and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n        l.insert(0,value)\n    return l", "code_tokens": "def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l", "docstring_tokens": "if the value is in the list move it to the front and return it .", "label": 0}, {"idx": "cosqa-train-1460", "doc": "python tensorflow slim demo", "code": "def afx_small():\n  \"\"\"Small transformer model with small batch size for fast step times.\"\"\"\n  hparams = transformer.transformer_tpu()\n  hparams.filter_size = 1024\n  hparams.num_heads = 4\n  hparams.num_hidden_layers = 3\n  hparams.batch_size = 512\n  return hparams", "code_tokens": "def afx_small ( ) : hparams = transformer . transformer_tpu ( ) hparams . filter_size = 1024 hparams . num_heads = 4 hparams . num_hidden_layers = 3 hparams . batch_size = 512 return hparams", "docstring_tokens": "Small transformer model with small batch size for fast step times .", "label": 1}, {"idx": "cosqa-train-1461", "doc": "how to use rowspan for varing length using python", "code": "def get_span_char_width(span, column_widths):\n    \"\"\"\n    Sum the widths of the columns that make up the span, plus the extra.\n\n    Parameters\n    ----------\n    span : list of lists of int\n        list of [row, column] pairs that make up the span\n    column_widths : list of int\n        The widths of the columns that make up the table\n\n    Returns\n    -------\n    total_width : int\n        The total width of the span\n    \"\"\"\n\n    start_column = span[0][1]\n    column_count = get_span_column_count(span)\n    total_width = 0\n\n    for i in range(start_column, start_column + column_count):\n        total_width += column_widths[i]\n\n    total_width += column_count - 1\n\n    return total_width", "code_tokens": "def get_span_char_width ( span , column_widths ) : start_column = span [ 0 ] [ 1 ] column_count = get_span_column_count ( span ) total_width = 0 for i in range ( start_column , start_column + column_count ) : total_width += column_widths [ i ] total_width += column_count - 1 return total_width", "docstring_tokens": "Sum the widths of the columns that make up the span plus the extra .", "label": 1}, {"idx": "cosqa-train-1462", "doc": "python test if attribute exists", "code": "def has_attribute(module_name, attribute_name):\n    \"\"\"Is this attribute present?\"\"\"\n    init_file = '%s/__init__.py' % module_name\n    return any(\n        [attribute_name in init_line for init_line in open(init_file).readlines()]\n    )", "code_tokens": "def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )", "docstring_tokens": "Is this attribute present?", "label": 0}, {"idx": "cosqa-train-1463", "doc": "how to use the range function in descending order python", "code": "def sort_genomic_ranges(rngs):\n  \"\"\"sort multiple ranges\"\"\"\n  return sorted(rngs, key=lambda x: (x.chr, x.start, x.end))", "code_tokens": "def sort_genomic_ranges ( rngs ) : return sorted ( rngs , key = lambda x : ( x . chr , x . start , x . end ) )", "docstring_tokens": "sort multiple ranges", "label": 0}, {"idx": "cosqa-train-1464", "doc": "python test if matrix is singlor", "code": "def is_square_matrix(mat):\n    \"\"\"Test if an array is a square matrix.\"\"\"\n    mat = np.array(mat)\n    if mat.ndim != 2:\n        return False\n    shape = mat.shape\n    return shape[0] == shape[1]", "code_tokens": "def is_square_matrix ( mat ) : mat = np . array ( mat ) if mat . ndim != 2 : return False shape = mat . shape return shape [ 0 ] == shape [ 1 ]", "docstring_tokens": "Test if an array is a square matrix .", "label": 0}, {"idx": "cosqa-train-1465", "doc": "how to use the session attributes from one intent to another using python", "code": "def save_session(self, sid, session, namespace=None):\n        \"\"\"Store the user session for a client.\n\n        The only difference with the :func:`socketio.Server.save_session`\n        method is that when the ``namespace`` argument is not given the\n        namespace associated with the class is used.\n        \"\"\"\n        return self.server.save_session(\n            sid, session, namespace=namespace or self.namespace)", "code_tokens": "def save_session ( self , sid , session , namespace = None ) : return self . server . save_session ( sid , session , namespace = namespace or self . namespace )", "docstring_tokens": "Store the user session for a client .", "label": 0}, {"idx": "cosqa-train-1466", "doc": "python test if socket is connected", "code": "def is_connected(self):\n        \"\"\"\n        Return true if the socket managed by this connection is connected\n\n        :rtype: bool\n        \"\"\"\n        try:\n            return self.socket is not None and self.socket.getsockname()[1] != 0 and BaseTransport.is_connected(self)\n        except socket.error:\n            return False", "code_tokens": "def is_connected ( self ) : try : return self . socket is not None and self . socket . getsockname ( ) [ 1 ] != 0 and BaseTransport . is_connected ( self ) except socket . error : return False", "docstring_tokens": "Return true if the socket managed by this connection is connected", "label": 0}, {"idx": "cosqa-train-1467", "doc": "how to use to parse a yaml script in python", "code": "def show(config):\n    \"\"\"Show revision list\"\"\"\n    with open(config, 'r'):\n        main.show(yaml.load(open(config)))", "code_tokens": "def show ( config ) : with open ( config , 'r' ) : main . show ( yaml . load ( open ( config ) ) )", "docstring_tokens": "Show revision list", "label": 1}, {"idx": "cosqa-train-1468", "doc": "python text file iterator", "code": "def txt_line_iterator(path):\n  \"\"\"Iterate through lines of file.\"\"\"\n  with tf.gfile.Open(path) as f:\n    for line in f:\n      yield line.strip()", "code_tokens": "def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )", "docstring_tokens": "Iterate through lines of file .", "label": 0}, {"idx": "cosqa-train-1469", "doc": "how to use type check validation in python", "code": "def _validate_type_scalar(self, value):\n        \"\"\" Is not a list or a dict \"\"\"\n        if isinstance(\n            value, _int_types + (_str_type, float, date, datetime, bool)\n        ):\n            return True", "code_tokens": "def _validate_type_scalar ( self , value ) : if isinstance ( value , _int_types + ( _str_type , float , date , datetime , bool ) ) : return True", "docstring_tokens": "Is not a list or a dict", "label": 0}, {"idx": "cosqa-train-1470", "doc": "python tfidf add token to vocabulary", "code": "def encode_dataset(dataset, vocabulary):\n  \"\"\"Encode from strings to token ids.\n\n  Args:\n    dataset: a tf.data.Dataset with string values.\n    vocabulary: a mesh_tensorflow.transformer.Vocabulary\n  Returns:\n    a tf.data.Dataset with integer-vector values ending in EOS=1\n  \"\"\"\n  def encode(features):\n    return {k: vocabulary.encode_tf(v) for k, v in features.items()}\n  return dataset.map(encode, num_parallel_calls=tf.data.experimental.AUTOTUNE)", "code_tokens": "def encode_dataset ( dataset , vocabulary ) : def encode ( features ) : return { k : vocabulary . encode_tf ( v ) for k , v in features . items ( ) } return dataset . map ( encode , num_parallel_calls = tf . data . experimental . AUTOTUNE )", "docstring_tokens": "Encode from strings to token ids .", "label": 1}, {"idx": "cosqa-train-1471", "doc": "how to use yaml to make a configure file example python", "code": "def generate_write_yaml_to_file(file_name):\n    \"\"\" generate a method to write the configuration in yaml to the method desired \"\"\"\n    def write_yaml(config):\n        with open(file_name, 'w+') as fh:\n            fh.write(yaml.dump(config))\n    return write_yaml", "code_tokens": "def generate_write_yaml_to_file ( file_name ) : def write_yaml ( config ) : with open ( file_name , 'w+' ) as fh : fh . write ( yaml . dump ( config ) ) return write_yaml", "docstring_tokens": "generate a method to write the configuration in yaml to the method desired", "label": 0}, {"idx": "cosqa-train-1472", "doc": "python thread kill alive", "code": "def Stop(self):\n    \"\"\"Stops the process status RPC server.\"\"\"\n    self._Close()\n\n    if self._rpc_thread.isAlive():\n      self._rpc_thread.join()\n    self._rpc_thread = None", "code_tokens": "def Stop ( self ) : self . _Close ( ) if self . _rpc_thread . isAlive ( ) : self . _rpc_thread . join ( ) self . _rpc_thread = None", "docstring_tokens": "Stops the process status RPC server .", "label": 0}, {"idx": "cosqa-train-1473", "doc": "how to validate mac address in python", "code": "def is_valid_ipv6(ip_str):\n    \"\"\"\n    Check the validity of an IPv6 address\n    \"\"\"\n    try:\n        socket.inet_pton(socket.AF_INET6, ip_str)\n    except socket.error:\n        return False\n    return True", "code_tokens": "def is_valid_ipv6 ( ip_str ) : try : socket . inet_pton ( socket . AF_INET6 , ip_str ) except socket . error : return False return True", "docstring_tokens": "Check the validity of an IPv6 address", "label": 0}, {"idx": "cosqa-train-1474", "doc": "python thread safe flush buffer", "code": "def flush():\n    \"\"\"Try to flush all stdio buffers, both from python and from C.\"\"\"\n    try:\n        sys.stdout.flush()\n        sys.stderr.flush()\n    except (AttributeError, ValueError, IOError):\n        pass  # unsupported\n    try:\n        libc.fflush(None)\n    except (AttributeError, ValueError, IOError):\n        pass", "code_tokens": "def flush ( ) : try : sys . stdout . flush ( ) sys . stderr . flush ( ) except ( AttributeError , ValueError , IOError ) : pass # unsupported try : libc . fflush ( None ) except ( AttributeError , ValueError , IOError ) : pass", "docstring_tokens": "Try to flush all stdio buffers both from python and from C .", "label": 0}, {"idx": "cosqa-train-1475", "doc": "how to view a list as an array in python", "code": "def get_list_representation(self):\n        \"\"\"Returns this subset's representation as a list of indices.\"\"\"\n        if self.is_list:\n            return self.list_or_slice\n        else:\n            return self[list(range(self.num_examples))]", "code_tokens": "def get_list_representation ( self ) : if self . is_list : return self . list_or_slice else : return self [ list ( range ( self . num_examples ) ) ]", "docstring_tokens": "Returns this subset s representation as a list of indices .", "label": 0}, {"idx": "cosqa-train-1476", "doc": "python threading kill all", "code": "def terminate(self):\n        \"\"\"Terminate all workers and threads.\"\"\"\n        for t in self._threads:\n            t.quit()\n        self._thread = []\n        self._workers = []", "code_tokens": "def terminate ( self ) : for t in self . _threads : t . quit ( ) self . _thread = [ ] self . _workers = [ ]", "docstring_tokens": "Terminate all workers and threads .", "label": 0}, {"idx": "cosqa-train-1477", "doc": "how to warp image python", "code": "def post_process(self):\n        \"\"\" Apply last 2D transforms\"\"\"\n        self.image.putdata(self.pixels)\n        self.image = self.image.transpose(Image.ROTATE_90)", "code_tokens": "def post_process ( self ) : self . image . putdata ( self . pixels ) self . image = self . image . transpose ( Image . ROTATE_90 )", "docstring_tokens": "Apply last 2D transforms", "label": 0}, {"idx": "cosqa-train-1478", "doc": "python threadpool executor terminate thread early", "code": "def join(self):\n\t\t\"\"\"Note that the Executor must be close()'d elsewhere,\n\t\tor join() will never return.\n\t\t\"\"\"\n\t\tself.inputfeeder_thread.join()\n\t\tself.pool.join()\n\t\tself.resulttracker_thread.join()\n\t\tself.failuretracker_thread.join()", "code_tokens": "def join ( self ) : self . inputfeeder_thread . join ( ) self . pool . join ( ) self . resulttracker_thread . join ( ) self . failuretracker_thread . join ( )", "docstring_tokens": "Note that the Executor must be close () d elsewhere or join () will never return .", "label": 0}, {"idx": "cosqa-train-1479", "doc": "how to write a list into a tab delimit text file, python", "code": "def write_tsv_line_from_list(linelist, outfp):\n    \"\"\"Utility method to convert list to tsv line with carriage return\"\"\"\n    line = '\\t'.join(linelist)\n    outfp.write(line)\n    outfp.write('\\n')", "code_tokens": "def write_tsv_line_from_list ( linelist , outfp ) : line = '\\t' . join ( linelist ) outfp . write ( line ) outfp . write ( '\\n' )", "docstring_tokens": "Utility method to convert list to tsv line with carriage return", "label": 0}, {"idx": "cosqa-train-1480", "doc": "how to write a string in python with first word starting with a capital and ending with a period", "code": "def _make_sentence(txt):\n    \"\"\"Make a sentence from a piece of text.\"\"\"\n    #Make sure first letter is capitalized\n    txt = txt.strip(' ')\n    txt = txt[0].upper() + txt[1:] + '.'\n    return txt", "code_tokens": "def _make_sentence ( txt ) : #Make sure first letter is capitalized txt = txt . strip ( ' ' ) txt = txt [ 0 ] . upper ( ) + txt [ 1 : ] + '.' return txt", "docstring_tokens": "Make a sentence from a piece of text .", "label": 0}, {"idx": "cosqa-train-1481", "doc": "python threadpool map async", "code": "def asyncStarCmap(asyncCallable, iterable):\n    \"\"\"itertools.starmap for deferred callables using cooperative multitasking\n    \"\"\"\n    results = []\n    yield coopStar(asyncCallable, results.append, iterable)\n    returnValue(results)", "code_tokens": "def asyncStarCmap ( asyncCallable , iterable ) : results = [ ] yield coopStar ( asyncCallable , results . append , iterable ) returnValue ( results )", "docstring_tokens": "itertools . starmap for deferred callables using cooperative multitasking", "label": 0}, {"idx": "cosqa-train-1482", "doc": "how to write an wav file in python using scipy", "code": "def write_wav(path, samples, sr=16000):\n    \"\"\"\n    Write to given samples to a wav file.\n    The samples are expected to be floating point numbers\n    in the range of -1.0 to 1.0.\n\n    Args:\n        path (str): The path to write the wav to.\n        samples (np.array): A float array .\n        sr (int): The sampling rate.\n    \"\"\"\n    max_value = np.abs(np.iinfo(np.int16).min)\n    data = (samples * max_value).astype(np.int16)\n    scipy.io.wavfile.write(path, sr, data)", "code_tokens": "def write_wav ( path , samples , sr = 16000 ) : max_value = np . abs ( np . iinfo ( np . int16 ) . min ) data = ( samples * max_value ) . astype ( np . int16 ) scipy . io . wavfile . write ( path , sr , data )", "docstring_tokens": "Write to given samples to a wav file . The samples are expected to be floating point numbers in the range of - 1 . 0 to 1 . 0 .", "label": 0}, {"idx": "cosqa-train-1483", "doc": "python threadsafe create directory", "code": "def make_directory(path):\n    \"\"\"\n    Make a directory and any intermediate directories that don't already\n    exist. This function handles the case where two threads try to create\n    a directory at once.\n    \"\"\"\n    if not os.path.exists(path):\n        # concurrent writes that try to create the same dir can fail\n        try:\n            os.makedirs(path)\n\n        except OSError as e:\n            if e.errno == errno.EEXIST:\n                pass\n            else:\n                raise e", "code_tokens": "def make_directory ( path ) : if not os . path . exists ( path ) : # concurrent writes that try to create the same dir can fail try : os . makedirs ( path ) except OSError as e : if e . errno == errno . EEXIST : pass else : raise e", "docstring_tokens": "Make a directory and any intermediate directories that don t already exist . This function handles the case where two threads try to create a directory at once .", "label": 0}, {"idx": "cosqa-train-1484", "doc": "how to write matrix values in csv using python", "code": "def csv_matrix_print(classes, table):\n    \"\"\"\n    Return matrix as csv data.\n\n    :param classes: classes list\n    :type classes:list\n    :param table: table\n    :type table:dict\n    :return:\n    \"\"\"\n    result = \"\"\n    classes.sort()\n    for i in classes:\n        for j in classes:\n            result += str(table[i][j]) + \",\"\n        result = result[:-1] + \"\\n\"\n    return result[:-1]", "code_tokens": "def csv_matrix_print ( classes , table ) : result = \"\" classes . sort ( ) for i in classes : for j in classes : result += str ( table [ i ] [ j ] ) + \",\" result = result [ : - 1 ] + \"\\n\" return result [ : - 1 ]", "docstring_tokens": "Return matrix as csv data .", "label": 1}, {"idx": "cosqa-train-1485", "doc": "python three dimensional rotation matrix", "code": "def quaternion_to_rotation_matrix(quaternion):\n    \"\"\"Compute the rotation matrix representated by the quaternion\"\"\"\n    c, x, y, z = quaternion\n    return np.array([\n        [c*c + x*x - y*y - z*z, 2*x*y - 2*c*z,         2*x*z + 2*c*y        ],\n        [2*x*y + 2*c*z,         c*c - x*x + y*y - z*z, 2*y*z - 2*c*x        ],\n        [2*x*z - 2*c*y,         2*y*z + 2*c*x,         c*c - x*x - y*y + z*z]\n    ], float)", "code_tokens": "def quaternion_to_rotation_matrix ( quaternion ) : c , x , y , z = quaternion return np . array ( [ [ c * c + x * x - y * y - z * z , 2 * x * y - 2 * c * z , 2 * x * z + 2 * c * y ] , [ 2 * x * y + 2 * c * z , c * c - x * x + y * y - z * z , 2 * y * z - 2 * c * x ] , [ 2 * x * z - 2 * c * y , 2 * y * z + 2 * c * x , c * c - x * x - y * y + z * z ] ] , float )", "docstring_tokens": "Compute the rotation matrix representated by the quaternion", "label": 0}, {"idx": "cosqa-train-1486", "doc": "how to write to create a file in source code then write to it in python", "code": "def write_file(filename, content):\n    \"\"\"Create the file with the given content\"\"\"\n    print 'Generating {0}'.format(filename)\n    with open(filename, 'wb') as out_f:\n        out_f.write(content)", "code_tokens": "def write_file ( filename , content ) : print 'Generating {0}' . format ( filename ) with open ( filename , 'wb' ) as out_f : out_f . write ( content )", "docstring_tokens": "Create the file with the given content", "label": 0}, {"idx": "cosqa-train-1487", "doc": "python time change to miliseconds", "code": "def ms_to_datetime(ms):\n    \"\"\"\n    Converts a millisecond accuracy timestamp to a datetime\n    \"\"\"\n    dt = datetime.datetime.utcfromtimestamp(ms / 1000)\n    return dt.replace(microsecond=(ms % 1000) * 1000).replace(tzinfo=pytz.utc)", "code_tokens": "def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )", "docstring_tokens": "Converts a millisecond accuracy timestamp to a datetime", "label": 0}, {"idx": "cosqa-train-1488", "doc": "how to write unit test functions for a try loop in python", "code": "def retry_test(func):\n    \"\"\"Retries the passed function 3 times before failing\"\"\"\n    success = False\n    ex = Exception(\"Unknown\")\n    for i in six.moves.range(3):\n        try:\n            result = func()\n        except Exception as e:\n            time.sleep(1)\n            ex = e\n        else:\n            success = True\n            break\n    if not success:\n        raise ex\n    assert success\n    return result", "code_tokens": "def retry_test ( func ) : success = False ex = Exception ( \"Unknown\" ) for i in six . moves . range ( 3 ) : try : result = func ( ) except Exception as e : time . sleep ( 1 ) ex = e else : success = True break if not success : raise ex assert success return result", "docstring_tokens": "Retries the passed function 3 times before failing", "label": 0}, {"idx": "cosqa-train-1489", "doc": "python time covert to epoch time", "code": "def session_to_epoch(timestamp):\n    \"\"\" converts Synergy Timestamp for session to UTC zone seconds since epoch \"\"\"\n    utc_timetuple = datetime.strptime(timestamp, SYNERGY_SESSION_PATTERN).replace(tzinfo=None).utctimetuple()\n    return calendar.timegm(utc_timetuple)", "code_tokens": "def session_to_epoch ( timestamp ) : utc_timetuple = datetime . strptime ( timestamp , SYNERGY_SESSION_PATTERN ) . replace ( tzinfo = None ) . utctimetuple ( ) return calendar . timegm ( utc_timetuple )", "docstring_tokens": "converts Synergy Timestamp for session to UTC zone seconds since epoch", "label": 0}, {"idx": "cosqa-train-1490", "doc": "how yo print hostname of ip in python", "code": "def get_own_ip():\n    \"\"\"Get the host's ip number.\n    \"\"\"\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    try:\n        sock.connect((\"8.8.8.8\", 80))\n    except socket.gaierror:\n        ip_ = \"127.0.0.1\"\n    else:\n        ip_ = sock.getsockname()[0]\n    finally:\n        sock.close()\n    return ip_", "code_tokens": "def get_own_ip ( ) : sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) try : sock . connect ( ( \"8.8.8.8\" , 80 ) ) except socket . gaierror : ip_ = \"127.0.0.1\" else : ip_ = sock . getsockname ( ) [ 0 ] finally : sock . close ( ) return ip_", "docstring_tokens": "Get the host s ip number .", "label": 0}, {"idx": "cosqa-train-1491", "doc": "python time timezone tzoffset", "code": "def make_aware(dt):\n    \"\"\"Appends tzinfo and assumes UTC, if datetime object has no tzinfo already.\"\"\"\n    return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)", "code_tokens": "def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "docstring_tokens": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already .", "label": 0}, {"idx": "cosqa-train-1492", "doc": "howt to update attobute to object python", "code": "def populate_obj(obj, attrs):\n    \"\"\"Populates an object's attributes using the provided dict\n    \"\"\"\n    for k, v in attrs.iteritems():\n        setattr(obj, k, v)", "code_tokens": "def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "docstring_tokens": "Populates an object s attributes using the provided dict", "label": 0}, {"idx": "cosqa-train-1493", "doc": "python timestamp with microsecond to datetime", "code": "def timestamp_to_datetime(timestamp):\n    \"\"\"Convert an ARF timestamp to a datetime.datetime object (naive local time)\"\"\"\n    from datetime import datetime, timedelta\n    obj = datetime.fromtimestamp(timestamp[0])\n    return obj + timedelta(microseconds=int(timestamp[1]))", "code_tokens": "def timestamp_to_datetime ( timestamp ) : from datetime import datetime , timedelta obj = datetime . fromtimestamp ( timestamp [ 0 ] ) return obj + timedelta ( microseconds = int ( timestamp [ 1 ] ) )", "docstring_tokens": "Convert an ARF timestamp to a datetime . datetime object ( naive local time )", "label": 0}, {"idx": "cosqa-train-1494", "doc": "howto comvert string to byte type in python", "code": "def str2bytes(x):\n  \"\"\"Convert input argument to bytes\"\"\"\n  if type(x) is bytes:\n    return x\n  elif type(x) is str:\n    return bytes([ ord(i) for i in x ])\n  else:\n    return str2bytes(str(x))", "code_tokens": "def str2bytes ( x ) : if type ( x ) is bytes : return x elif type ( x ) is str : return bytes ( [ ord ( i ) for i in x ] ) else : return str2bytes ( str ( x ) )", "docstring_tokens": "Convert input argument to bytes", "label": 0}, {"idx": "cosqa-train-1495", "doc": "python timezone offset to timezone", "code": "def make_aware(dt):\n    \"\"\"Appends tzinfo and assumes UTC, if datetime object has no tzinfo already.\"\"\"\n    return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)", "code_tokens": "def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "docstring_tokens": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already .", "label": 0}, {"idx": "cosqa-train-1496", "doc": "html table format with python variables", "code": "def html(header_rows):\n    \"\"\"\n    Convert a list of tuples describing a table into a HTML string\n    \"\"\"\n    name = 'table%d' % next(tablecounter)\n    return HtmlTable([map(str, row) for row in header_rows], name).render()", "code_tokens": "def html ( header_rows ) : name = 'table%d' % next ( tablecounter ) return HtmlTable ( [ map ( str , row ) for row in header_rows ] , name ) . render ( )", "docstring_tokens": "Convert a list of tuples describing a table into a HTML string", "label": 0}, {"idx": "cosqa-train-1497", "doc": "python tk scrollbar in a frame", "code": "def yview(self, *args):\n        \"\"\"Update inplace widgets position when doing vertical scroll\"\"\"\n        self.after_idle(self.__updateWnds)\n        ttk.Treeview.yview(self, *args)", "code_tokens": "def yview ( self , * args ) : self . after_idle ( self . __updateWnds ) ttk . Treeview . yview ( self , * args )", "docstring_tokens": "Update inplace widgets position when doing vertical scroll", "label": 0}, {"idx": "cosqa-train-1498", "doc": "identify if its a zipped file in python", "code": "def is_gzipped_fastq(file_name):\n    \"\"\"\n    Determine whether indicated file appears to be a gzipped FASTQ.\n\n    :param str file_name: Name/path of file to check as gzipped FASTQ.\n    :return bool: Whether indicated file appears to be in gzipped FASTQ format.\n    \"\"\"\n    _, ext = os.path.splitext(file_name)\n    return file_name.endswith(\".fastq.gz\") or file_name.endswith(\".fq.gz\")", "code_tokens": "def is_gzipped_fastq ( file_name ) : _ , ext = os . path . splitext ( file_name ) return file_name . endswith ( \".fastq.gz\" ) or file_name . endswith ( \".fq.gz\" )", "docstring_tokens": "Determine whether indicated file appears to be a gzipped FASTQ .", "label": 0}, {"idx": "cosqa-train-1499", "doc": "python tkinter modal dialog with scroll", "code": "def restore_scrollbar_position(self):\n        \"\"\"Restoring scrollbar position after main window is visible\"\"\"\n        scrollbar_pos = self.get_option('scrollbar_position', None)\n        if scrollbar_pos is not None:\n            self.explorer.treewidget.set_scrollbar_position(scrollbar_pos)", "code_tokens": "def restore_scrollbar_position ( self ) : scrollbar_pos = self . get_option ( 'scrollbar_position' , None ) if scrollbar_pos is not None : self . explorer . treewidget . set_scrollbar_position ( scrollbar_pos )", "docstring_tokens": "Restoring scrollbar position after main window is visible", "label": 0}, {"idx": "cosqa-train-1500", "doc": "if a is list python", "code": "def is_listish(obj):\n    \"\"\"Check if something quacks like a list.\"\"\"\n    if isinstance(obj, (list, tuple, set)):\n        return True\n    return is_sequence(obj)", "code_tokens": "def is_listish ( obj ) : if isinstance ( obj , ( list , tuple , set ) ) : return True return is_sequence ( obj )", "docstring_tokens": "Check if something quacks like a list .", "label": 0}, {"idx": "cosqa-train-1501", "doc": "python to compute fourier transform", "code": "def translate_fourier(image, dx):\n    \"\"\" Translate an image in fourier-space with plane waves \"\"\"\n    N = image.shape[0]\n\n    f = 2*np.pi*np.fft.fftfreq(N)\n    kx,ky,kz = np.meshgrid(*(f,)*3, indexing='ij')\n    kv = np.array([kx,ky,kz]).T\n\n    q = np.fft.fftn(image)*np.exp(-1.j*(kv*dx).sum(axis=-1)).T\n    return np.real(np.fft.ifftn(q))", "code_tokens": "def translate_fourier ( image , dx ) : N = image . shape [ 0 ] f = 2 * np . pi * np . fft . fftfreq ( N ) kx , ky , kz = np . meshgrid ( * ( f , ) * 3 , indexing = 'ij' ) kv = np . array ( [ kx , ky , kz ] ) . T q = np . fft . fftn ( image ) * np . exp ( - 1.j * ( kv * dx ) . sum ( axis = - 1 ) ) . T return np . real ( np . fft . ifftn ( q ) )", "docstring_tokens": "Translate an image in fourier - space with plane waves", "label": 0}, {"idx": "cosqa-train-1502", "doc": "if queue not empty python", "code": "def full(self):\n        \"\"\"Return True if the queue is full\"\"\"\n        if not self.size: return False\n        return len(self.pq) == (self.size + self.removed_count)", "code_tokens": "def full ( self ) : if not self . size : return False return len ( self . pq ) == ( self . size + self . removed_count )", "docstring_tokens": "Return True if the queue is full", "label": 0}, {"idx": "cosqa-train-1503", "doc": "python to connect postgresql remote database", "code": "def get_pg_connection(host, user, port, password, database, ssl={}):\n    \"\"\" PostgreSQL connection \"\"\"\n\n    return psycopg2.connect(host=host,\n                            user=user,\n                            port=port,\n                            password=password,\n                            dbname=database,\n                            sslmode=ssl.get('sslmode', None),\n                            sslcert=ssl.get('sslcert', None),\n                            sslkey=ssl.get('sslkey', None),\n                            sslrootcert=ssl.get('sslrootcert', None),\n                            )", "code_tokens": "def get_pg_connection ( host , user , port , password , database , ssl = { } ) : return psycopg2 . connect ( host = host , user = user , port = port , password = password , dbname = database , sslmode = ssl . get ( 'sslmode' , None ) , sslcert = ssl . get ( 'sslcert' , None ) , sslkey = ssl . get ( 'sslkey' , None ) , sslrootcert = ssl . get ( 'sslrootcert' , None ) , )", "docstring_tokens": "PostgreSQL connection", "label": 0}, {"idx": "cosqa-train-1504", "doc": "if value not present in json, take default values python", "code": "def defvalkey(js, key, default=None, take_none=True):\n    \"\"\"\n    Returns js[key] if set, otherwise default. Note js[key] can be None.\n    :param js:\n    :param key:\n    :param default:\n    :param take_none:\n    :return:\n    \"\"\"\n    if js is None:\n        return default\n    if key not in js:\n        return default\n    if js[key] is None and not take_none:\n        return default\n    return js[key]", "code_tokens": "def defvalkey ( js , key , default = None , take_none = True ) : if js is None : return default if key not in js : return default if js [ key ] is None and not take_none : return default return js [ key ]", "docstring_tokens": "Returns js [ key ] if set otherwise default . Note js [ key ] can be None . : param js : : param key : : param default : : param take_none : : return :", "label": 0}, {"idx": "cosqa-train-1505", "doc": "python to dict with key lambda", "code": "def get_python_dict(scala_map):\n    \"\"\"Return a dict from entries in a scala.collection.immutable.Map\"\"\"\n    python_dict = {}\n    keys = get_python_list(scala_map.keys().toList())\n    for key in keys:\n        python_dict[key] = scala_map.apply(key)\n    return python_dict", "code_tokens": "def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict", "docstring_tokens": "Return a dict from entries in a scala . collection . immutable . Map", "label": 0}, {"idx": "cosqa-train-1506", "doc": "image resize while protecting aspect ration python", "code": "def resize_image_to_fit_width(image, dest_w):\n    \"\"\"\n    Resize and image to fit the passed in width, keeping the aspect ratio the same\n\n    :param image: PIL.Image\n    :param dest_w: The desired width\n    \"\"\"\n    scale_factor = dest_w / image.size[0]\n    dest_h = image.size[1] * scale_factor\n    \n    scaled_image = image.resize((int(dest_w), int(dest_h)), PIL.Image.ANTIALIAS)\n\n    return scaled_image", "code_tokens": "def resize_image_to_fit_width ( image , dest_w ) : scale_factor = dest_w / image . size [ 0 ] dest_h = image . size [ 1 ] * scale_factor scaled_image = image . resize ( ( int ( dest_w ) , int ( dest_h ) ) , PIL . Image . ANTIALIAS ) return scaled_image", "docstring_tokens": "Resize and image to fit the passed in width keeping the aspect ratio the same", "label": 0}, {"idx": "cosqa-train-1507", "doc": "python to get 3d object", "code": "def list(self):\n        \"\"\"position in 3d space\"\"\"\n        return [self._pos3d.x, self._pos3d.y, self._pos3d.z]", "code_tokens": "def list ( self ) : return [ self . _pos3d . x , self . _pos3d . y , self . _pos3d . z ]", "docstring_tokens": "position in 3d space", "label": 0}, {"idx": "cosqa-train-1508", "doc": "in python how do i ask a user a yes or no question", "code": "def yn_prompt(msg, default=True):\n    \"\"\"\n    Prompts the user for yes or no.\n    \"\"\"\n    ret = custom_prompt(msg, [\"y\", \"n\"], \"y\" if default else \"n\")\n    if ret == \"y\":\n        return True\n    return False", "code_tokens": "def yn_prompt ( msg , default = True ) : ret = custom_prompt ( msg , [ \"y\" , \"n\" ] , \"y\" if default else \"n\" ) if ret == \"y\" : return True return False", "docstring_tokens": "Prompts the user for yes or no .", "label": 0}, {"idx": "cosqa-train-1509", "doc": "python to retrieve attribute from xml string with namespace", "code": "def GetAttributeNs(self, localName, namespaceURI):\n        \"\"\"Provides the value of the specified attribute \"\"\"\n        ret = libxml2mod.xmlTextReaderGetAttributeNs(self._o, localName, namespaceURI)\n        return ret", "code_tokens": "def GetAttributeNs ( self , localName , namespaceURI ) : ret = libxml2mod . xmlTextReaderGetAttributeNs ( self . _o , localName , namespaceURI ) return ret", "docstring_tokens": "Provides the value of the specified attribute", "label": 0}, {"idx": "cosqa-train-1510", "doc": "index of a known elemnt python list", "code": "def find_geom(geom, geoms):\n    \"\"\"\n    Returns the index of a geometry in a list of geometries avoiding\n    expensive equality checks of `in` operator.\n    \"\"\"\n    for i, g in enumerate(geoms):\n        if g is geom:\n            return i", "code_tokens": "def find_geom ( geom , geoms ) : for i , g in enumerate ( geoms ) : if g is geom : return i", "docstring_tokens": "Returns the index of a geometry in a list of geometries avoiding expensive equality checks of in operator .", "label": 1}, {"idx": "cosqa-train-1511", "doc": "python to see if file handler is stdout", "code": "def _using_stdout(self):\n        \"\"\"\n        Return whether the handler is using sys.stdout.\n        \"\"\"\n        if WINDOWS and colorama:\n            # Then self.stream is an AnsiToWin32 object.\n            return self.stream.wrapped is sys.stdout\n\n        return self.stream is sys.stdout", "code_tokens": "def _using_stdout ( self ) : if WINDOWS and colorama : # Then self.stream is an AnsiToWin32 object. return self . stream . wrapped is sys . stdout return self . stream is sys . stdout", "docstring_tokens": "Return whether the handler is using sys . stdout .", "label": 0}, {"idx": "cosqa-train-1512", "doc": "inner join function in python", "code": "def merge(left, right, how='inner', key=None, left_key=None, right_key=None,\n          left_as='left', right_as='right'):\n    \"\"\" Performs a join using the union join function. \"\"\"\n    return join(left, right, how, key, left_key, right_key,\n                join_fn=make_union_join(left_as, right_as))", "code_tokens": "def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "docstring_tokens": "Performs a join using the union join function .", "label": 0}, {"idx": "cosqa-train-1513", "doc": "python to skip if file do not exist", "code": "def file_found(filename,force):\n    \"\"\"Check if a file exists\"\"\"\n    if os.path.exists(filename) and not force:\n        logger.info(\"Found %s; skipping...\"%filename)\n        return True\n    else:\n        return False", "code_tokens": "def file_found ( filename , force ) : if os . path . exists ( filename ) and not force : logger . info ( \"Found %s; skipping...\" % filename ) return True else : return False", "docstring_tokens": "Check if a file exists", "label": 1}, {"idx": "cosqa-train-1514", "doc": "interpolate a 2d matrix to the size of another 2d matrix python", "code": "def _linearInterpolationTransformMatrix(matrix1, matrix2, value):\n    \"\"\" Linear, 'oldstyle' interpolation of the transform matrix.\"\"\"\n    return tuple(_interpolateValue(matrix1[i], matrix2[i], value) for i in range(len(matrix1)))", "code_tokens": "def _linearInterpolationTransformMatrix ( matrix1 , matrix2 , value ) : return tuple ( _interpolateValue ( matrix1 [ i ] , matrix2 [ i ] , value ) for i in range ( len ( matrix1 ) ) )", "docstring_tokens": "Linear oldstyle interpolation of the transform matrix .", "label": 0}, {"idx": "cosqa-train-1515", "doc": "python to tell windows or linux", "code": "def is_unix_style(flags):\n    \"\"\"Check if we should use Unix style.\"\"\"\n\n    return (util.platform() != \"windows\" or (not bool(flags & REALPATH) and get_case(flags))) and not flags & _FORCEWIN", "code_tokens": "def is_unix_style ( flags ) : return ( util . platform ( ) != \"windows\" or ( not bool ( flags & REALPATH ) and get_case ( flags ) ) ) and not flags & _FORCEWIN", "docstring_tokens": "Check if we should use Unix style .", "label": 0}, {"idx": "cosqa-train-1516", "doc": "invert a dictionary containing lists python", "code": "def invertDictMapping(d):\n    \"\"\" Invert mapping of dictionary (i.e. map values to list of keys) \"\"\"\n    inv_map = {}\n    for k, v in d.items():\n        inv_map[v] = inv_map.get(v, [])\n        inv_map[v].append(k)\n    return inv_map", "code_tokens": "def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map", "docstring_tokens": "Invert mapping of dictionary ( i . e . map values to list of keys )", "label": 0}, {"idx": "cosqa-train-1517", "doc": "python tornado multiple port", "code": "def start(args):\n    \"\"\"Run server with provided command line arguments.\n    \"\"\"\n    application = tornado.web.Application([(r\"/run\", run.get_handler(args)),\n                                           (r\"/status\", run.StatusHandler)])\n    application.runmonitor = RunMonitor()\n    application.listen(args.port)\n    tornado.ioloop.IOLoop.instance().start()", "code_tokens": "def start ( args ) : application = tornado . web . Application ( [ ( r\"/run\" , run . get_handler ( args ) ) , ( r\"/status\" , run . StatusHandler ) ] ) application . runmonitor = RunMonitor ( ) application . listen ( args . port ) tornado . ioloop . IOLoop . instance ( ) . start ( )", "docstring_tokens": "Run server with provided command line arguments .", "label": 0}, {"idx": "cosqa-train-1518", "doc": "is divisible function in python", "code": "def generic_div(a, b):\n    \"\"\"Simple function to divide two numbers\"\"\"\n    logger.debug('Called generic_div({}, {})'.format(a, b))\n    return a / b", "code_tokens": "def generic_div ( a , b ) : logger . debug ( 'Called generic_div({}, {})' . format ( a , b ) ) return a / b", "docstring_tokens": "Simple function to divide two numbers", "label": 1}, {"idx": "cosqa-train-1519", "doc": "is there a average function for lists in python", "code": "def mean(inlist):\n    \"\"\"\nReturns the arithematic mean of the values in the passed list.\nAssumes a '1D' list, but will function on the 1st dim of an array(!).\n\nUsage:   lmean(inlist)\n\"\"\"\n    sum = 0\n    for item in inlist:\n        sum = sum + item\n    return sum / float(len(inlist))", "code_tokens": "def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )", "docstring_tokens": "Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) .", "label": 0}, {"idx": "cosqa-train-1520", "doc": "python transform numpy to data fram", "code": "def _frombuffer(ptr, frames, channels, dtype):\n    \"\"\"Create NumPy array from a pointer to some memory.\"\"\"\n    framesize = channels * dtype.itemsize\n    data = np.frombuffer(ffi.buffer(ptr, frames * framesize), dtype=dtype)\n    data.shape = -1, channels\n    return data", "code_tokens": "def _frombuffer ( ptr , frames , channels , dtype ) : framesize = channels * dtype . itemsize data = np . frombuffer ( ffi . buffer ( ptr , frames * framesize ) , dtype = dtype ) data . shape = - 1 , channels return data", "docstring_tokens": "Create NumPy array from a pointer to some memory .", "label": 0}, {"idx": "cosqa-train-1521", "doc": "is there some way to create a pdf with python", "code": "def _single_page_pdf(page):\n    \"\"\"Construct a single page PDF from the provided page in memory\"\"\"\n    pdf = Pdf.new()\n    pdf.pages.append(page)\n    bio = BytesIO()\n    pdf.save(bio)\n    bio.seek(0)\n    return bio.read()", "code_tokens": "def _single_page_pdf ( page ) : pdf = Pdf . new ( ) pdf . pages . append ( page ) bio = BytesIO ( ) pdf . save ( bio ) bio . seek ( 0 ) return bio . read ( )", "docstring_tokens": "Construct a single page PDF from the provided page in memory", "label": 0}, {"idx": "cosqa-train-1522", "doc": "python translate json to list of objects", "code": "def from_json_list(cls, api_client, data):\n        \"\"\"Convert a list of JSON values to a list of models\n        \"\"\"\n        return [cls.from_json(api_client, item) for item in data]", "code_tokens": "def from_json_list ( cls , api_client , data ) : return [ cls . from_json ( api_client , item ) for item in data ]", "docstring_tokens": "Convert a list of JSON values to a list of models", "label": 0}, {"idx": "cosqa-train-1523", "doc": "iserie python how to get the cursor return value", "code": "def query_fetch_one(self, query, values):\n        \"\"\"\n        Executes a db query, gets the first value, and closes the connection.\n        \"\"\"\n        self.cursor.execute(query, values)\n        retval = self.cursor.fetchone()\n        self.__close_db()\n        return retval", "code_tokens": "def query_fetch_one ( self , query , values ) : self . cursor . execute ( query , values ) retval = self . cursor . fetchone ( ) self . __close_db ( ) return retval", "docstring_tokens": "Executes a db query gets the first value and closes the connection .", "label": 0}, {"idx": "cosqa-train-1524", "doc": "python traverse tree leaf", "code": "def walk_tree(root):\n    \"\"\"Pre-order depth-first\"\"\"\n    yield root\n\n    for child in root.children:\n        for el in walk_tree(child):\n            yield el", "code_tokens": "def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el", "docstring_tokens": "Pre - order depth - first", "label": 0}, {"idx": "cosqa-train-1525", "doc": "isinstance python 3 user defined data type", "code": "def listlike(obj):\n    \"\"\"Is an object iterable like a list (and not a string)?\"\"\"\n    \n    return hasattr(obj, \"__iter__\") \\\n    and not issubclass(type(obj), str)\\\n    and not issubclass(type(obj), unicode)", "code_tokens": "def listlike ( obj ) : return hasattr ( obj , \"__iter__\" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )", "docstring_tokens": "Is an object iterable like a list ( and not a string ) ?", "label": 1}, {"idx": "cosqa-train-1526", "doc": "python truncate spaces in string", "code": "def strip_spaces(x):\n    \"\"\"\n    Strips spaces\n    :param x:\n    :return:\n    \"\"\"\n    x = x.replace(b' ', b'')\n    x = x.replace(b'\\t', b'')\n    return x", "code_tokens": "def strip_spaces ( x ) : x = x . replace ( b' ' , b'' ) x = x . replace ( b'\\t' , b'' ) return x", "docstring_tokens": "Strips spaces : param x : : return :", "label": 1}, {"idx": "cosqa-train-1527", "doc": "iso format timezone offset python", "code": "def __consistent_isoformat_utc(datetime_val):\n        \"\"\"\n        Function that does what isoformat does but it actually does the same\n        every time instead of randomly doing different things on some systems\n        and also it represents that time as the equivalent UTC time.\n        \"\"\"\n        isotime = datetime_val.astimezone(pytz.utc).strftime(\"%Y-%m-%dT%H:%M:%S%z\")\n        if isotime[-2] != \":\":\n            isotime = isotime[:-2] + \":\" + isotime[-2:]\n        return isotime", "code_tokens": "def __consistent_isoformat_utc ( datetime_val ) : isotime = datetime_val . astimezone ( pytz . utc ) . strftime ( \"%Y-%m-%dT%H:%M:%S%z\" ) if isotime [ - 2 ] != \":\" : isotime = isotime [ : - 2 ] + \":\" + isotime [ - 2 : ] return isotime", "docstring_tokens": "Function that does what isoformat does but it actually does the same every time instead of randomly doing different things on some systems and also it represents that time as the equivalent UTC time .", "label": 0}, {"idx": "cosqa-train-1528", "doc": "python try block inside the function and how to use return", "code": "def retry_on_signal(function):\n    \"\"\"Retries function until it doesn't raise an EINTR error\"\"\"\n    while True:\n        try:\n            return function()\n        except EnvironmentError, e:\n            if e.errno != errno.EINTR:\n                raise", "code_tokens": "def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise", "docstring_tokens": "Retries function until it doesn t raise an EINTR error", "label": 0}, {"idx": "cosqa-train-1529", "doc": "iterate over all but first element python", "code": "def __iter__(self):\n\t\t\"\"\"Iterate through all elements.\n\n\t\tMultiple copies will be returned if they exist.\n\t\t\"\"\"\n\t\tfor value, count in self.counts():\n\t\t\tfor _ in range(count):\n\t\t\t\tyield value", "code_tokens": "def __iter__ ( self ) : for value , count in self . counts ( ) : for _ in range ( count ) : yield value", "docstring_tokens": "Iterate through all elements .", "label": 0}, {"idx": "cosqa-train-1530", "doc": "python try excpet in loop", "code": "def eintr_retry(exc_type, f, *args, **kwargs):\n    \"\"\"Calls a function.  If an error of the given exception type with\n    interrupted system call (EINTR) occurs calls the function again.\n    \"\"\"\n    while True:\n        try:\n            return f(*args, **kwargs)\n        except exc_type as exc:\n            if exc.errno != EINTR:\n                raise\n        else:\n            break", "code_tokens": "def eintr_retry ( exc_type , f , * args , * * kwargs ) : while True : try : return f ( * args , * * kwargs ) except exc_type as exc : if exc . errno != EINTR : raise else : break", "docstring_tokens": "Calls a function . If an error of the given exception type with interrupted system call ( EINTR ) occurs calls the function again .", "label": 0}, {"idx": "cosqa-train-1531", "doc": "iterator for reading from file python", "code": "def txt_line_iterator(path):\n  \"\"\"Iterate through lines of file.\"\"\"\n  with tf.gfile.Open(path) as f:\n    for line in f:\n      yield line.strip()", "code_tokens": "def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )", "docstring_tokens": "Iterate through lines of file .", "label": 0}, {"idx": "cosqa-train-1532", "doc": "python turn datetime into timestamp", "code": "def dt_to_ts(value):\n    \"\"\" If value is a datetime, convert to timestamp \"\"\"\n    if not isinstance(value, datetime):\n        return value\n    return calendar.timegm(value.utctimetuple()) + value.microsecond / 1000000.0", "code_tokens": "def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0", "docstring_tokens": "If value is a datetime convert to timestamp", "label": 0}, {"idx": "cosqa-train-1533", "doc": "itertools for dictionary values in python", "code": "def itervalues(d, **kw):\n    \"\"\"Return an iterator over the values of a dictionary.\"\"\"\n    if not PY2:\n        return iter(d.values(**kw))\n    return d.itervalues(**kw)", "code_tokens": "def itervalues ( d , * * kw ) : if not PY2 : return iter ( d . values ( * * kw ) ) return d . itervalues ( * * kw )", "docstring_tokens": "Return an iterator over the values of a dictionary .", "label": 0}, {"idx": "cosqa-train-1534", "doc": "python turn forward slashes to back slashes", "code": "def norm_slash(name):\n    \"\"\"Normalize path slashes.\"\"\"\n\n    if isinstance(name, str):\n        return name.replace('/', \"\\\\\") if not is_case_sensitive() else name\n    else:\n        return name.replace(b'/', b\"\\\\\") if not is_case_sensitive() else name", "code_tokens": "def norm_slash ( name ) : if isinstance ( name , str ) : return name . replace ( '/' , \"\\\\\" ) if not is_case_sensitive ( ) else name else : return name . replace ( b'/' , b\"\\\\\" ) if not is_case_sensitive ( ) else name", "docstring_tokens": "Normalize path slashes .", "label": 0}, {"idx": "cosqa-train-1535", "doc": "itertools python groupby group keys", "code": "def group_by(iterable, key_func):\n    \"\"\"Wrap itertools.groupby to make life easier.\"\"\"\n    groups = (\n        list(sub) for key, sub in groupby(iterable, key_func)\n    )\n    return zip(groups, groups)", "code_tokens": "def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "docstring_tokens": "Wrap itertools . groupby to make life easier .", "label": 0}, {"idx": "cosqa-train-1536", "doc": "python turn instance method to function", "code": "def Proxy(f):\n  \"\"\"A helper to create a proxy method in a class.\"\"\"\n\n  def Wrapped(self, *args):\n    return getattr(self, f)(*args)\n\n  return Wrapped", "code_tokens": "def Proxy ( f ) : def Wrapped ( self , * args ) : return getattr ( self , f ) ( * args ) return Wrapped", "docstring_tokens": "A helper to create a proxy method in a class .", "label": 0}, {"idx": "cosqa-train-1537", "doc": "java 2 dimensional array return to python", "code": "def string_list_to_array(l):\n    \"\"\"\n    Turns a Python unicode string list into a Java String array.\n\n    :param l: the string list\n    :type: list\n    :rtype: java string array\n    :return: JB_Object\n    \"\"\"\n    result = javabridge.get_env().make_object_array(len(l), javabridge.get_env().find_class(\"java/lang/String\"))\n    for i in range(len(l)):\n        javabridge.get_env().set_object_array_element(result, i, javabridge.get_env().new_string_utf(l[i]))\n    return result", "code_tokens": "def string_list_to_array ( l ) : result = javabridge . get_env ( ) . make_object_array ( len ( l ) , javabridge . get_env ( ) . find_class ( \"java/lang/String\" ) ) for i in range ( len ( l ) ) : javabridge . get_env ( ) . set_object_array_element ( result , i , javabridge . get_env ( ) . new_string_utf ( l [ i ] ) ) return result", "docstring_tokens": "Turns a Python unicode string list into a Java String array .", "label": 1}, {"idx": "cosqa-train-1538", "doc": "python turn int to 16 but bin", "code": "def intToBin(i):\n    \"\"\" Integer to two bytes \"\"\"\n    # divide in two parts (bytes)\n    i1 = i % 256\n    i2 = int(i / 256)\n    # make string (little endian)\n    return i.to_bytes(2, byteorder='little')", "code_tokens": "def intToBin ( i ) : # divide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return i . to_bytes ( 2 , byteorder = 'little' )", "docstring_tokens": "Integer to two bytes", "label": 0}, {"idx": "cosqa-train-1539", "doc": "java path python like", "code": "def get_java_path():\n  \"\"\"Get the path of java executable\"\"\"\n  java_home = os.environ.get(\"JAVA_HOME\")\n  return os.path.join(java_home, BIN_DIR, \"java\")", "code_tokens": "def get_java_path ( ) : java_home = os . environ . get ( \"JAVA_HOME\" ) return os . path . join ( java_home , BIN_DIR , \"java\" )", "docstring_tokens": "Get the path of java executable", "label": 0}, {"idx": "cosqa-train-1540", "doc": "python turning lambda expression into a key", "code": "def excel_key(index):\n    \"\"\"create a key for index by converting index into a base-26 number, using A-Z as the characters.\"\"\"\n    X = lambda n: ~n and X((n // 26)-1) + chr(65 + (n % 26)) or ''\n    return X(int(index))", "code_tokens": "def excel_key ( index ) : X = lambda n : ~ n and X ( ( n // 26 ) - 1 ) + chr ( 65 + ( n % 26 ) ) or '' return X ( int ( index ) )", "docstring_tokens": "create a key for index by converting index into a base - 26 number using A - Z as the characters .", "label": 0}, {"idx": "cosqa-train-1541", "doc": "java python integration jython vs", "code": "def test_python_java_rt():\n    \"\"\" Run Python test cases against Java runtime classes. \"\"\"\n    sub_env = {'PYTHONPATH': _build_dir()}\n\n    log.info('Executing Python unit tests (against Java runtime classes)...')\n    return jpyutil._execute_python_scripts(python_java_rt_tests,\n                                           env=sub_env)", "code_tokens": "def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )", "docstring_tokens": "Run Python test cases against Java runtime classes .", "label": 0}, {"idx": "cosqa-train-1542", "doc": "python turning space delimited text into list", "code": "def split_into_sentences(s):\n  \"\"\"Split text into list of sentences.\"\"\"\n  s = re.sub(r\"\\s+\", \" \", s)\n  s = re.sub(r\"[\\\\.\\\\?\\\\!]\", \"\\n\", s)\n  return s.split(\"\\n\")", "code_tokens": "def split_into_sentences ( s ) : s = re . sub ( r\"\\s+\" , \" \" , s ) s = re . sub ( r\"[\\\\.\\\\?\\\\!]\" , \"\\n\" , s ) return s . split ( \"\\n\" )", "docstring_tokens": "Split text into list of sentences .", "label": 0}, {"idx": "cosqa-train-1543", "doc": "jinja2 template list of strings python", "code": "def get_attributes(var):\n    \"\"\"\n    Given a varaible, return the list of attributes that are available inside\n    of a template\n    \"\"\"\n    is_valid = partial(is_valid_in_template, var)\n    return list(filter(is_valid, dir(var)))", "code_tokens": "def get_attributes ( var ) : is_valid = partial ( is_valid_in_template , var ) return list ( filter ( is_valid , dir ( var ) ) )", "docstring_tokens": "Given a varaible return the list of attributes that are available inside of a template", "label": 0}, {"idx": "cosqa-train-1544", "doc": "python two image similarity", "code": "def _sim_fill(r1, r2, imsize):\n    \"\"\"\n        calculate the fill similarity over the image\n    \"\"\"\n    bbsize = (\n        (max(r1[\"max_x\"], r2[\"max_x\"]) - min(r1[\"min_x\"], r2[\"min_x\"]))\n        * (max(r1[\"max_y\"], r2[\"max_y\"]) - min(r1[\"min_y\"], r2[\"min_y\"]))\n    )\n    return 1.0 - (bbsize - r1[\"size\"] - r2[\"size\"]) / imsize", "code_tokens": "def _sim_fill ( r1 , r2 , imsize ) : bbsize = ( ( max ( r1 [ \"max_x\" ] , r2 [ \"max_x\" ] ) - min ( r1 [ \"min_x\" ] , r2 [ \"min_x\" ] ) ) * ( max ( r1 [ \"max_y\" ] , r2 [ \"max_y\" ] ) - min ( r1 [ \"min_y\" ] , r2 [ \"min_y\" ] ) ) ) return 1.0 - ( bbsize - r1 [ \"size\" ] - r2 [ \"size\" ] ) / imsize", "docstring_tokens": "calculate the fill similarity over the image", "label": 0}, {"idx": "cosqa-train-1545", "doc": "join characters in list python", "code": "def delimited(items, character='|'):\n    \"\"\"Returns a character delimited version of the provided list as a Python string\"\"\"\n    return '|'.join(items) if type(items) in (list, tuple, set) else items", "code_tokens": "def delimited ( items , character = '|' ) : return '|' . join ( items ) if type ( items ) in ( list , tuple , set ) else items", "docstring_tokens": "Returns a character delimited version of the provided list as a Python string", "label": 0}, {"idx": "cosqa-train-1546", "doc": "python type hinting 'method'", "code": "def is_builtin_type(tp):\n    \"\"\"Checks if the given type is a builtin one.\n    \"\"\"\n    return hasattr(__builtins__, tp.__name__) and tp is getattr(__builtins__, tp.__name__)", "code_tokens": "def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )", "docstring_tokens": "Checks if the given type is a builtin one .", "label": 0}, {"idx": "cosqa-train-1547", "doc": "json date format milliseconds python", "code": "def _timestamp_to_json_row(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\n\n    This version returns floating-point seconds value used in row data.\n    \"\"\"\n    if isinstance(value, datetime.datetime):\n        value = _microseconds_from_datetime(value) * 1e-6\n    return value", "code_tokens": "def _timestamp_to_json_row ( value ) : if isinstance ( value , datetime . datetime ) : value = _microseconds_from_datetime ( value ) * 1e-6 return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 0}, {"idx": "cosqa-train-1548", "doc": "python type hinting allow 2 types", "code": "def istype(obj, check):\n    \"\"\"Like isinstance(obj, check), but strict.\n\n    This won't catch subclasses.\n    \"\"\"\n    if isinstance(check, tuple):\n        for cls in check:\n            if type(obj) is cls:\n                return True\n        return False\n    else:\n        return type(obj) is check", "code_tokens": "def istype ( obj , check ) : if isinstance ( check , tuple ) : for cls in check : if type ( obj ) is cls : return True return False else : return type ( obj ) is check", "docstring_tokens": "Like isinstance ( obj check ) but strict .", "label": 0}, {"idx": "cosqa-train-1549", "doc": "json load python isoformat datetime", "code": "def parse_json_date(value):\n    \"\"\"\n    Parses an ISO8601 formatted datetime from a string value\n    \"\"\"\n    if not value:\n        return None\n\n    return datetime.datetime.strptime(value, JSON_DATETIME_FORMAT).replace(tzinfo=pytz.UTC)", "code_tokens": "def parse_json_date ( value ) : if not value : return None return datetime . datetime . strptime ( value , JSON_DATETIME_FORMAT ) . replace ( tzinfo = pytz . UTC )", "docstring_tokens": "Parses an ISO8601 formatted datetime from a string value", "label": 0}, {"idx": "cosqa-train-1550", "doc": "python typecast as int", "code": "def _to_numeric(val):\n    \"\"\"\n    Helper function for conversion of various data types into numeric representation.\n    \"\"\"\n    if isinstance(val, (int, float, datetime.datetime, datetime.timedelta)):\n        return val\n    return float(val)", "code_tokens": "def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )", "docstring_tokens": "Helper function for conversion of various data types into numeric representation .", "label": 0}, {"idx": "cosqa-train-1551", "doc": "json load utf dict python", "code": "def read_json(location):\n    \"\"\"Open and load JSON from file.\n\n    location (Path): Path to JSON file.\n    RETURNS (dict): Loaded JSON content.\n    \"\"\"\n    location = ensure_path(location)\n    with location.open('r', encoding='utf8') as f:\n        return ujson.load(f)", "code_tokens": "def read_json ( location ) : location = ensure_path ( location ) with location . open ( 'r' , encoding = 'utf8' ) as f : return ujson . load ( f )", "docstring_tokens": "Open and load JSON from file .", "label": 0}, {"idx": "cosqa-train-1552", "doc": "python typecast object to string", "code": "def check_str(obj):\n        \"\"\" Returns a string for various input types \"\"\"\n        if isinstance(obj, str):\n            return obj\n        if isinstance(obj, float):\n            return str(int(obj))\n        else:\n            return str(obj)", "code_tokens": "def check_str ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , float ) : return str ( int ( obj ) ) else : return str ( obj )", "docstring_tokens": "Returns a string for various input types", "label": 1}, {"idx": "cosqa-train-1553", "doc": "json serializable types python", "code": "def json_serialize(obj):\n    \"\"\"\n    Simple generic JSON serializer for common objects.\n    \"\"\"\n    if isinstance(obj, datetime):\n        return obj.isoformat()\n\n    if hasattr(obj, 'id'):\n        return jsonify(obj.id)\n\n    if hasattr(obj, 'name'):\n        return jsonify(obj.name)\n\n    raise TypeError('{0} is not JSON serializable'.format(obj))", "code_tokens": "def json_serialize ( obj ) : if isinstance ( obj , datetime ) : return obj . isoformat ( ) if hasattr ( obj , 'id' ) : return jsonify ( obj . id ) if hasattr ( obj , 'name' ) : return jsonify ( obj . name ) raise TypeError ( '{0} is not JSON serializable' . format ( obj ) )", "docstring_tokens": "Simple generic JSON serializer for common objects .", "label": 0}, {"idx": "cosqa-train-1554", "doc": "python underscore to camel", "code": "def to_pascal_case(s):\n    \"\"\"Transform underscore separated string to pascal case\n\n    \"\"\"\n    return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())", "code_tokens": "def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )", "docstring_tokens": "Transform underscore separated string to pascal case", "label": 0}, {"idx": "cosqa-train-1555", "doc": "jsonschema python multiple schema files", "code": "def load_schema(schema_path):\n    \"\"\"Prepare the api specification for request and response validation.\n\n    :returns: a mapping from :class:`RequestMatcher` to :class:`ValidatorMap`\n        for every operation in the api specification.\n    :rtype: dict\n    \"\"\"\n    with open(schema_path, 'r') as schema_file:\n        schema = simplejson.load(schema_file)\n    resolver = RefResolver('', '', schema.get('models', {}))\n    return build_request_to_validator_map(schema, resolver)", "code_tokens": "def load_schema ( schema_path ) : with open ( schema_path , 'r' ) as schema_file : schema = simplejson . load ( schema_file ) resolver = RefResolver ( '' , '' , schema . get ( 'models' , { } ) ) return build_request_to_validator_map ( schema , resolver )", "docstring_tokens": "Prepare the api specification for request and response validation .", "label": 1}, {"idx": "cosqa-train-1556", "doc": "python unitest how to assing variable to object in setup", "code": "def __init__(self, testnet=False, dryrun=False):\n        \"\"\"TODO doc string\"\"\"\n        self.testnet = testnet\n        self.dryrun = dryrun", "code_tokens": "def __init__ ( self , testnet = False , dryrun = False ) : self . testnet = testnet self . dryrun = dryrun", "docstring_tokens": "TODO doc string", "label": 0}, {"idx": "cosqa-train-1557", "doc": "keep only elements in list python", "code": "def unique(iterable):\n    \"\"\" Returns a list copy in which each item occurs only once (in-order).\n    \"\"\"\n    seen = set()\n    return [x for x in iterable if x not in seen and not seen.add(x)]", "code_tokens": "def unique ( iterable ) : seen = set ( ) return [ x for x in iterable if x not in seen and not seen . add ( x ) ]", "docstring_tokens": "Returns a list copy in which each item occurs only once ( in - order ) .", "label": 0}, {"idx": "cosqa-train-1558", "doc": "python unittest show passed tests and failed tests", "code": "def test():\n    \"\"\" Run all Tests [nose] \"\"\"\n\n    command = 'nosetests --with-coverage --cover-package=pwnurl'\n    status = subprocess.call(shlex.split(command))\n    sys.exit(status)", "code_tokens": "def test ( ) : command = 'nosetests --with-coverage --cover-package=pwnurl' status = subprocess . call ( shlex . split ( command ) ) sys . exit ( status )", "docstring_tokens": "Run all Tests [ nose ]", "label": 0}, {"idx": "cosqa-train-1559", "doc": "kill a root process from python", "code": "def kill_process_children(pid):\n    \"\"\"Find and kill child processes of a process.\n\n    :param pid: PID of parent process (process ID)\n    :return: Nothing\n    \"\"\"\n    if sys.platform == \"darwin\":\n        kill_process_children_osx(pid)\n    elif sys.platform == \"linux\":\n        kill_process_children_unix(pid)\n    else:\n        pass", "code_tokens": "def kill_process_children ( pid ) : if sys . platform == \"darwin\" : kill_process_children_osx ( pid ) elif sys . platform == \"linux\" : kill_process_children_unix ( pid ) else : pass", "docstring_tokens": "Find and kill child processes of a process .", "label": 1}, {"idx": "cosqa-train-1560", "doc": "python unittesting assert raise failing with callable function", "code": "def assert_is_not(expected, actual, message=None, extra=None):\n    \"\"\"Raises an AssertionError if expected is actual.\"\"\"\n    assert expected is not actual, _assert_fail_message(\n        message, expected, actual, \"is\", extra\n    )", "code_tokens": "def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , \"is\" , extra )", "docstring_tokens": "Raises an AssertionError if expected is actual .", "label": 0}, {"idx": "cosqa-train-1561", "doc": "kill thread python daemon", "code": "def sigterm(self, signum, frame):\n        \"\"\"\n        These actions will be done after SIGTERM.\n        \"\"\"\n        self.logger.warning(\"Caught signal %s. Stopping daemon.\" % signum)\n        sys.exit(0)", "code_tokens": "def sigterm ( self , signum , frame ) : self . logger . warning ( \"Caught signal %s. Stopping daemon.\" % signum ) sys . exit ( 0 )", "docstring_tokens": "These actions will be done after SIGTERM .", "label": 0}, {"idx": "cosqa-train-1562", "doc": "python unknown url type https", "code": "def guess_url(url):\n    \"\"\"Guess if URL is a http or ftp URL.\n    @param url: the URL to check\n    @ptype url: unicode\n    @return: url with http:// or ftp:// prepended if it's detected as\n      a http respective ftp URL.\n    @rtype: unicode\n    \"\"\"\n    if url.lower().startswith(\"www.\"):\n        # syntactic sugar\n        return \"http://%s\" % url\n    elif url.lower().startswith(\"ftp.\"):\n        # syntactic sugar\n        return \"ftp://%s\" % url\n    return url", "code_tokens": "def guess_url ( url ) : if url . lower ( ) . startswith ( \"www.\" ) : # syntactic sugar return \"http://%s\" % url elif url . lower ( ) . startswith ( \"ftp.\" ) : # syntactic sugar return \"ftp://%s\" % url return url", "docstring_tokens": "Guess if URL is a http or ftp URL .", "label": 0}, {"idx": "cosqa-train-1563", "doc": "l2 normalization python numpy", "code": "def normalize(v, axis=None, eps=1e-10):\n  \"\"\"L2 Normalize along specified axes.\"\"\"\n  return v / max(anorm(v, axis=axis, keepdims=True), eps)", "code_tokens": "def normalize ( v , axis = None , eps = 1e-10 ) : return v / max ( anorm ( v , axis = axis , keepdims = True ) , eps )", "docstring_tokens": "L2 Normalize along specified axes .", "label": 0}, {"idx": "cosqa-train-1564", "doc": "python unzip gzip file", "code": "def _unzip_handle(handle):\n    \"\"\"Transparently unzip the file handle\"\"\"\n    if isinstance(handle, basestring):\n        handle = _gzip_open_filename(handle)\n    else:\n        handle = _gzip_open_handle(handle)\n    return handle", "code_tokens": "def _unzip_handle ( handle ) : if isinstance ( handle , basestring ) : handle = _gzip_open_filename ( handle ) else : handle = _gzip_open_handle ( handle ) return handle", "docstring_tokens": "Transparently unzip the file handle", "label": 0}, {"idx": "cosqa-train-1565", "doc": "labels and legends for ploting python", "code": "def finish_plot():\n    \"\"\"Helper for plotting.\"\"\"\n    plt.legend()\n    plt.grid(color='0.7')\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.show()", "code_tokens": "def finish_plot ( ) : plt . legend ( ) plt . grid ( color = '0.7' ) plt . xlabel ( 'x' ) plt . ylabel ( 'y' ) plt . show ( )", "docstring_tokens": "Helper for plotting .", "label": 0}, {"idx": "cosqa-train-1566", "doc": "python uppercase lower case variables", "code": "def upcaseTokens(s,l,t):\n    \"\"\"Helper parse action to convert tokens to upper case.\"\"\"\n    return [ tt.upper() for tt in map(_ustr,t) ]", "code_tokens": "def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]", "docstring_tokens": "Helper parse action to convert tokens to upper case .", "label": 0}, {"idx": "cosqa-train-1567", "doc": "lamba function that returns boolean python", "code": "def visit_BoolOp(self, node):\n        \"\"\" Return type may come from any boolop operand. \"\"\"\n        return sum((self.visit(value) for value in node.values), [])", "code_tokens": "def visit_BoolOp ( self , node ) : return sum ( ( self . visit ( value ) for value in node . values ) , [ ] )", "docstring_tokens": "Return type may come from any boolop operand .", "label": 0}, {"idx": "cosqa-train-1568", "doc": "python url encoding and requests", "code": "def download(url, encoding='utf-8'):\n    \"\"\"Returns the text fetched via http GET from URL, read as `encoding`\"\"\"\n    import requests\n    response = requests.get(url)\n    response.encoding = encoding\n    return response.text", "code_tokens": "def download ( url , encoding = 'utf-8' ) : import requests response = requests . get ( url ) response . encoding = encoding return response . text", "docstring_tokens": "Returns the text fetched via http GET from URL read as encoding", "label": 0}, {"idx": "cosqa-train-1569", "doc": "lambda python create file s3", "code": "def s3(ctx, bucket_name, data_file, region):\n    \"\"\"Use the S3 SWAG backend.\"\"\"\n    if not ctx.data_file:\n        ctx.data_file = data_file\n\n    if not ctx.bucket_name:\n        ctx.bucket_name = bucket_name\n\n    if not ctx.region:\n        ctx.region = region\n\n    ctx.type = 's3'", "code_tokens": "def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'", "docstring_tokens": "Use the S3 SWAG backend .", "label": 0}, {"idx": "cosqa-train-1570", "doc": "python url read text", "code": "def url_read_text(url, verbose=True):\n    r\"\"\"\n    Directly reads text data from url\n    \"\"\"\n    data = url_read(url, verbose)\n    text = data.decode('utf8')\n    return text", "code_tokens": "def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text", "docstring_tokens": "r Directly reads text data from url", "label": 1}, {"idx": "cosqa-train-1571", "doc": "large dataset for model training in python", "code": "def afx_small():\n  \"\"\"Small transformer model with small batch size for fast step times.\"\"\"\n  hparams = transformer.transformer_tpu()\n  hparams.filter_size = 1024\n  hparams.num_heads = 4\n  hparams.num_hidden_layers = 3\n  hparams.batch_size = 512\n  return hparams", "code_tokens": "def afx_small ( ) : hparams = transformer . transformer_tpu ( ) hparams . filter_size = 1024 hparams . num_heads = 4 hparams . num_hidden_layers = 3 hparams . batch_size = 512 return hparams", "docstring_tokens": "Small transformer model with small batch size for fast step times .", "label": 0}, {"idx": "cosqa-train-1572", "doc": "python url safety checker", "code": "def is_safe_url(url, host=None):\n    \"\"\"Return ``True`` if the url is a safe redirection.\n\n    The safe redirection means that it doesn't point to a different host.\n    Always returns ``False`` on an empty url.\n    \"\"\"\n    if not url:\n        return False\n    netloc = urlparse.urlparse(url)[1]\n    return not netloc or netloc == host", "code_tokens": "def is_safe_url ( url , host = None ) : if not url : return False netloc = urlparse . urlparse ( url ) [ 1 ] return not netloc or netloc == host", "docstring_tokens": "Return True if the url is a safe redirection .", "label": 0}, {"idx": "cosqa-train-1573", "doc": "last five entries from data in python", "code": "def get_last_row(dbconn, tablename, n=1, uuid=None):\n    \"\"\"\n    Returns the last `n` rows in the table\n    \"\"\"\n    return fetch(dbconn, tablename, n, uuid, end=True)", "code_tokens": "def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )", "docstring_tokens": "Returns the last n rows in the table", "label": 0}, {"idx": "cosqa-train-1574", "doc": "python url without opening browser window", "code": "def url(self):\n        \"\"\" The url of this window \"\"\"\n        with switch_window(self._browser, self.name):\n            return self._browser.url", "code_tokens": "def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "docstring_tokens": "The url of this window", "label": 0}, {"idx": "cosqa-train-1575", "doc": "last n elements of python list", "code": "def tail(self, n=10):\n        \"\"\"\n        Get an SArray that contains the last n elements in the SArray.\n\n        Parameters\n        ----------\n        n : int\n            The number of elements to fetch\n\n        Returns\n        -------\n        out : SArray\n            A new SArray which contains the last n rows of the current SArray.\n        \"\"\"\n        with cython_context():\n            return SArray(_proxy=self.__proxy__.tail(n))", "code_tokens": "def tail ( self , n = 10 ) : with cython_context ( ) : return SArray ( _proxy = self . __proxy__ . tail ( n ) )", "docstring_tokens": "Get an SArray that contains the last n elements in the SArray .", "label": 1}, {"idx": "cosqa-train-1576", "doc": "python urlquery to dict", "code": "def get_url_args(url):\n    \"\"\" Returns a dictionary from a URL params \"\"\"\n    url_data = urllib.parse.urlparse(url)\n    arg_dict = urllib.parse.parse_qs(url_data.query)\n    return arg_dict", "code_tokens": "def get_url_args ( url ) : url_data = urllib . parse . urlparse ( url ) arg_dict = urllib . parse . parse_qs ( url_data . query ) return arg_dict", "docstring_tokens": "Returns a dictionary from a URL params", "label": 0}, {"idx": "cosqa-train-1577", "doc": "latex python code snippet", "code": "def print_latex(o):\n    \"\"\"A function to generate the latex representation of sympy\n    expressions.\"\"\"\n    if can_print_latex(o):\n        s = latex(o, mode='plain')\n        s = s.replace('\\\\dag','\\\\dagger')\n        s = s.strip('$')\n        return '$$%s$$' % s\n    # Fallback to the string printer\n    return None", "code_tokens": "def print_latex ( o ) : if can_print_latex ( o ) : s = latex ( o , mode = 'plain' ) s = s . replace ( '\\\\dag' , '\\\\dagger' ) s = s . strip ( '$' ) return '$$%s$$' % s # Fallback to the string printer return None", "docstring_tokens": "A function to generate the latex representation of sympy expressions .", "label": 0}, {"idx": "cosqa-train-1578", "doc": "python use a colorbar range", "code": "def colorbar(height, length, colormap):\n    \"\"\"Return the channels of a colorbar.\n    \"\"\"\n    cbar = np.tile(np.arange(length) * 1.0 / (length - 1), (height, 1))\n    cbar = (cbar * (colormap.values.max() - colormap.values.min())\n            + colormap.values.min())\n\n    return colormap.colorize(cbar)", "code_tokens": "def colorbar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . colorize ( cbar )", "docstring_tokens": "Return the channels of a colorbar .", "label": 0}, {"idx": "cosqa-train-1579", "doc": "leave subplots empty in python", "code": "def set_empty(self, row, column):\n        \"\"\"Keep one of the subplots completely empty.\n\n        :param row,column: specify the subplot.\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_empty()", "code_tokens": "def set_empty ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . set_empty ( )", "docstring_tokens": "Keep one of the subplots completely empty .", "label": 1}, {"idx": "cosqa-train-1580", "doc": "python use one dict to new a", "code": "def fromDict(cls, _dict):\n        \"\"\" Builds instance from dictionary of properties. \"\"\"\n        obj = cls()\n        obj.__dict__.update(_dict)\n        return obj", "code_tokens": "def fromDict ( cls , _dict ) : obj = cls ( ) obj . __dict__ . update ( _dict ) return obj", "docstring_tokens": "Builds instance from dictionary of properties .", "label": 0}, {"idx": "cosqa-train-1581", "doc": "lenght of a number array in python", "code": "def _requiredSize(shape, dtype):\n\t\"\"\"\n\tDetermines the number of bytes required to store a NumPy array with\n\tthe specified shape and datatype.\n\t\"\"\"\n\treturn math.floor(np.prod(np.asarray(shape, dtype=np.uint64)) * np.dtype(dtype).itemsize)", "code_tokens": "def _requiredSize ( shape , dtype ) : return math . floor ( np . prod ( np . asarray ( shape , dtype = np . uint64 ) ) * np . dtype ( dtype ) . itemsize )", "docstring_tokens": "Determines the number of bytes required to store a NumPy array with the specified shape and datatype .", "label": 0}, {"idx": "cosqa-train-1582", "doc": "python use quote in string", "code": "def quote(self, s):\n        \"\"\"Return a shell-escaped version of the string s.\"\"\"\n\n        if six.PY2:\n            from pipes import quote\n        else:\n            from shlex import quote\n\n        return quote(s)", "code_tokens": "def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )", "docstring_tokens": "Return a shell - escaped version of the string s .", "label": 0}, {"idx": "cosqa-train-1583", "doc": "length normalization of vector python", "code": "def normalized(vector):\n    \"\"\"\n    Get unit vector for a given one.\n\n    :param vector:\n        Numpy vector as coordinates in Cartesian space, or an array of such.\n    :returns:\n        Numpy array of the same shape and structure where all vectors are\n        normalized. That is, each coordinate component is divided by its\n        vector's length.\n    \"\"\"\n    length = numpy.sum(vector * vector, axis=-1)\n    length = numpy.sqrt(length.reshape(length.shape + (1, )))\n    return vector / length", "code_tokens": "def normalized ( vector ) : length = numpy . sum ( vector * vector , axis = - 1 ) length = numpy . sqrt ( length . reshape ( length . shape + ( 1 , ) ) ) return vector / length", "docstring_tokens": "Get unit vector for a given one .", "label": 0}, {"idx": "cosqa-train-1584", "doc": "python use staticmethod function in another staticmethod function", "code": "def static_method(cls, f):\n        \"\"\"Decorator which dynamically binds static methods to the model for later use.\"\"\"\n        setattr(cls, f.__name__, staticmethod(f))\n        return f", "code_tokens": "def static_method ( cls , f ) : setattr ( cls , f . __name__ , staticmethod ( f ) ) return f", "docstring_tokens": "Decorator which dynamically binds static methods to the model for later use .", "label": 0}, {"idx": "cosqa-train-1585", "doc": "linux python mmap only maps 240 bytes", "code": "def align_to_mmap(num, round_up):\n    \"\"\"\n    Align the given integer number to the closest page offset, which usually is 4096 bytes.\n\n    :param round_up: if True, the next higher multiple of page size is used, otherwise\n        the lower page_size will be used (i.e. if True, 1 becomes 4096, otherwise it becomes 0)\n    :return: num rounded to closest page\"\"\"\n    res = (num // ALLOCATIONGRANULARITY) * ALLOCATIONGRANULARITY\n    if round_up and (res != num):\n        res += ALLOCATIONGRANULARITY\n    # END handle size\n    return res", "code_tokens": "def align_to_mmap ( num , round_up ) : res = ( num // ALLOCATIONGRANULARITY ) * ALLOCATIONGRANULARITY if round_up and ( res != num ) : res += ALLOCATIONGRANULARITY # END handle size return res", "docstring_tokens": "Align the given integer number to the closest page offset which usually is 4096 bytes .", "label": 0}, {"idx": "cosqa-train-1586", "doc": "python use timer to call function every 10 sec", "code": "def set(self, f):\n        \"\"\"Call a function after a delay, unless another function is set\n        in the meantime.\"\"\"\n        self.stop()\n        self._create_timer(f)\n        self.start()", "code_tokens": "def set ( self , f ) : self . stop ( ) self . _create_timer ( f ) self . start ( )", "docstring_tokens": "Call a function after a delay unless another function is set in the meantime .", "label": 0}, {"idx": "cosqa-train-1587", "doc": "linux python really close serial", "code": "def close(self):\n\t\t\"\"\"\n\t\tSend a terminate request and then disconnect from the serial device.\n\t\t\"\"\"\n\t\tif self._initialized:\n\t\t\tself.stop()\n\t\tself.logged_in = False\n\t\treturn self.serial_h.close()", "code_tokens": "def close ( self ) : if self . _initialized : self . stop ( ) self . logged_in = False return self . serial_h . close ( )", "docstring_tokens": "Send a terminate request and then disconnect from the serial device .", "label": 1}, {"idx": "cosqa-train-1588", "doc": "python user enters 10 intergers", "code": "def test():\n    \"\"\"Interactive test run.\"\"\"\n    try:\n        while 1:\n            x, digs = input('Enter (x, digs): ')\n            print x, fix(x, digs), sci(x, digs)\n    except (EOFError, KeyboardInterrupt):\n        pass", "code_tokens": "def test ( ) : try : while 1 : x , digs = input ( 'Enter (x, digs): ' ) print x , fix ( x , digs ) , sci ( x , digs ) except ( EOFError , KeyboardInterrupt ) : pass", "docstring_tokens": "Interactive test run .", "label": 0}, {"idx": "cosqa-train-1589", "doc": "list all attributes of an object python", "code": "def dict_from_object(obj: object):\n    \"\"\"Convert a object into dictionary with all of its readable attributes.\"\"\"\n\n    # If object is a dict instance, no need to convert.\n    return (obj if isinstance(obj, dict)\n            else {attr: getattr(obj, attr)\n                  for attr in dir(obj) if not attr.startswith('_')})", "code_tokens": "def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )", "docstring_tokens": "Convert a object into dictionary with all of its readable attributes .", "label": 0}, {"idx": "cosqa-train-1590", "doc": "python user prompt hide input", "code": "def _normal_prompt(self):\n        \"\"\"\n        Flushes the prompt before requesting the input\n\n        :return: The command line\n        \"\"\"\n        sys.stdout.write(self.__get_ps1())\n        sys.stdout.flush()\n        return safe_input()", "code_tokens": "def _normal_prompt ( self ) : sys . stdout . write ( self . __get_ps1 ( ) ) sys . stdout . flush ( ) return safe_input ( )", "docstring_tokens": "Flushes the prompt before requesting the input", "label": 0}, {"idx": "cosqa-train-1591", "doc": "list all variables in python size", "code": "def get_flat_size(self):\n        \"\"\"Returns the total length of all of the flattened variables.\n\n        Returns:\n            The length of all flattened variables concatenated.\n        \"\"\"\n        return sum(\n            np.prod(v.get_shape().as_list()) for v in self.variables.values())", "code_tokens": "def get_flat_size ( self ) : return sum ( np . prod ( v . get_shape ( ) . as_list ( ) ) for v in self . variables . values ( ) )", "docstring_tokens": "Returns the total length of all of the flattened variables .", "label": 0}, {"idx": "cosqa-train-1592", "doc": "python username and password from files", "code": "def read_credentials(fname):\n    \"\"\"\n    read a simple text file from a private location to get\n    username and password\n    \"\"\"\n    with open(fname, 'r') as f:\n        username = f.readline().strip('\\n')\n        password = f.readline().strip('\\n')\n    return username, password", "code_tokens": "def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\\n' ) password = f . readline ( ) . strip ( '\\n' ) return username , password", "docstring_tokens": "read a simple text file from a private location to get username and password", "label": 0}, {"idx": "cosqa-train-1593", "doc": "list of methods on an object in python", "code": "def get_methods(*objs):\n    \"\"\" Return the names of all callable attributes of an object\"\"\"\n    return set(\n        attr\n        for obj in objs\n        for attr in dir(obj)\n        if not attr.startswith('_') and callable(getattr(obj, attr))\n    )", "code_tokens": "def get_methods ( * objs ) : return set ( attr for obj in objs for attr in dir ( obj ) if not attr . startswith ( '_' ) and callable ( getattr ( obj , attr ) ) )", "docstring_tokens": "Return the names of all callable attributes of an object", "label": 0}, {"idx": "cosqa-train-1594", "doc": "python uuencode stringto bytes", "code": "def b2u(string):\n    \"\"\" bytes to unicode \"\"\"\n    if (isinstance(string, bytes) or\n        (PY2 and isinstance(string, str))):\n        return string.decode('utf-8')\n    return string", "code_tokens": "def b2u ( string ) : if ( isinstance ( string , bytes ) or ( PY2 and isinstance ( string , str ) ) ) : return string . decode ( 'utf-8' ) return string", "docstring_tokens": "bytes to unicode", "label": 0}, {"idx": "cosqa-train-1595", "doc": "list of numpy arrays in python", "code": "def recarray(self):\n        \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"\n        return numpy.rec.fromrecords(self.records, names=self.names)", "code_tokens": "def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "docstring_tokens": "Returns data as : class : numpy . recarray .", "label": 0}, {"idx": "cosqa-train-1596", "doc": "python validate is integer", "code": "def validate_int(value):\n    \"\"\" Integer validator \"\"\"\n\n    if value and not isinstance(value, int):\n        try:\n            int(str(value))\n        except (TypeError, ValueError):\n            raise ValidationError('not a valid number')\n    return value", "code_tokens": "def validate_int ( value ) : if value and not isinstance ( value , int ) : try : int ( str ( value ) ) except ( TypeError , ValueError ) : raise ValidationError ( 'not a valid number' ) return value", "docstring_tokens": "Integer validator", "label": 0}, {"idx": "cosqa-train-1597", "doc": "list of tuples to list of dictionary python 3", "code": "def list2dict(list_of_options):\n    \"\"\"Transforms a list of 2 element tuples to a dictionary\"\"\"\n    d = {}\n    for key, value in list_of_options:\n        d[key] = value\n    return d", "code_tokens": "def list2dict ( list_of_options ) : d = { } for key , value in list_of_options : d [ key ] = value return d", "docstring_tokens": "Transforms a list of 2 element tuples to a dictionary", "label": 0}, {"idx": "cosqa-train-1598", "doc": "python validate mac address check", "code": "def is_valid_ipv6(ip_str):\n    \"\"\"\n    Check the validity of an IPv6 address\n    \"\"\"\n    try:\n        socket.inet_pton(socket.AF_INET6, ip_str)\n    except socket.error:\n        return False\n    return True", "code_tokens": "def is_valid_ipv6 ( ip_str ) : try : socket . inet_pton ( socket . AF_INET6 , ip_str ) except socket . error : return False return True", "docstring_tokens": "Check the validity of an IPv6 address", "label": 0}, {"idx": "cosqa-train-1599", "doc": "list with all values except for one python", "code": "def _values(self):\n        \"\"\"Getter for series values (flattened)\"\"\"\n        return [\n            val for serie in self.series for val in serie.values\n            if val is not None\n        ]", "code_tokens": "def _values ( self ) : return [ val for serie in self . series for val in serie . values if val is not None ]", "docstring_tokens": "Getter for series values ( flattened )", "label": 0}, {"idx": "cosqa-train-1600", "doc": "python validate two dataset", "code": "def check_X_y(X, y):\n    \"\"\"\n    tool to ensure input and output data have the same number of samples\n\n    Parameters\n    ----------\n    X : array-like\n    y : array-like\n\n    Returns\n    -------\n    None\n    \"\"\"\n    if len(X) != len(y):\n        raise ValueError('Inconsistent input and output data shapes. '\\\n                         'found X: {} and y: {}'.format(X.shape, y.shape))", "code_tokens": "def check_X_y ( X , y ) : if len ( X ) != len ( y ) : raise ValueError ( 'Inconsistent input and output data shapes. ' 'found X: {} and y: {}' . format ( X . shape , y . shape ) )", "docstring_tokens": "tool to ensure input and output data have the same number of samples", "label": 0}, {"idx": "cosqa-train-1601", "doc": "load data to file from json in python", "code": "def open_json(file_name):\n    \"\"\"\n    returns json contents as string\n    \"\"\"\n    with open(file_name, \"r\") as json_data:\n        data = json.load(json_data)\n        return data", "code_tokens": "def open_json ( file_name ) : with open ( file_name , \"r\" ) as json_data : data = json . load ( json_data ) return data", "docstring_tokens": "returns json contents as string", "label": 0}, {"idx": "cosqa-train-1602", "doc": "python value none how to encode in protocol buffer", "code": "def AsPrimitiveProto(self):\n    \"\"\"Return an old style protocol buffer object.\"\"\"\n    if self.protobuf:\n      result = self.protobuf()\n      result.ParseFromString(self.SerializeToString())\n      return result", "code_tokens": "def AsPrimitiveProto ( self ) : if self . protobuf : result = self . protobuf ( ) result . ParseFromString ( self . SerializeToString ( ) ) return result", "docstring_tokens": "Return an old style protocol buffer object .", "label": 0}, {"idx": "cosqa-train-1603", "doc": "load rds into python", "code": "def sav_to_pandas_rpy2(input_file):\n    \"\"\"\n    SPSS .sav files to Pandas DataFrame through Rpy2\n\n    :param input_file: string\n\n    :return:\n    \"\"\"\n    import pandas.rpy.common as com\n\n    w = com.robj.r('foreign::read.spss(\"%s\", to.data.frame=TRUE)' % input_file)\n    return com.convert_robj(w)", "code_tokens": "def sav_to_pandas_rpy2 ( input_file ) : import pandas . rpy . common as com w = com . robj . r ( 'foreign::read.spss(\"%s\", to.data.frame=TRUE)' % input_file ) return com . convert_robj ( w )", "docstring_tokens": "SPSS . sav files to Pandas DataFrame through Rpy2", "label": 0}, {"idx": "cosqa-train-1604", "doc": "python verify datetime format of string", "code": "def is_timestamp(instance):\n    \"\"\"Validates data is a timestamp\"\"\"\n    if not isinstance(instance, (int, str)):\n        return True\n    return datetime.fromtimestamp(int(instance))", "code_tokens": "def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )", "docstring_tokens": "Validates data is a timestamp", "label": 0}, {"idx": "cosqa-train-1605", "doc": "log normal distribution function in python", "code": "def ln_norm(x, mu, sigma=1.0):\n    \"\"\" Natural log of scipy norm function truncated at zero \"\"\"\n    return np.log(stats.norm(loc=mu, scale=sigma).pdf(x))", "code_tokens": "def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )", "docstring_tokens": "Natural log of scipy norm function truncated at zero", "label": 1}, {"idx": "cosqa-train-1606", "doc": "python view all rows in a pivot table cell", "code": "def iter_except_top_row_tcs(self):\n        \"\"\"Generate each `a:tc` element in non-first rows of range.\"\"\"\n        for tr in self._tbl.tr_lst[self._top + 1:self._bottom]:\n            for tc in tr.tc_lst[self._left:self._right]:\n                yield tc", "code_tokens": "def iter_except_top_row_tcs ( self ) : for tr in self . _tbl . tr_lst [ self . _top + 1 : self . _bottom ] : for tc in tr . tc_lst [ self . _left : self . _right ] : yield tc", "docstring_tokens": "Generate each a : tc element in non - first rows of range .", "label": 0}, {"idx": "cosqa-train-1607", "doc": "log normalization with zero values python", "code": "def ln_norm(x, mu, sigma=1.0):\n    \"\"\" Natural log of scipy norm function truncated at zero \"\"\"\n    return np.log(stats.norm(loc=mu, scale=sigma).pdf(x))", "code_tokens": "def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )", "docstring_tokens": "Natural log of scipy norm function truncated at zero", "label": 0}, {"idx": "cosqa-train-1608", "doc": "python webservers that have no external dependencies", "code": "def web(host, port):\n    \"\"\"Start web application\"\"\"\n    from .webserver.web import get_app\n    get_app().run(host=host, port=port)", "code_tokens": "def web ( host , port ) : from . webserver . web import get_app get_app ( ) . run ( host = host , port = port )", "docstring_tokens": "Start web application", "label": 0}, {"idx": "cosqa-train-1609", "doc": "loop through tokens in a string python", "code": "def tokenize(string):\n    \"\"\"Match and yield all the tokens of the input string.\"\"\"\n    for match in TOKENS_REGEX.finditer(string):\n        yield Token(match.lastgroup, match.group().strip(), match.span())", "code_tokens": "def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "docstring_tokens": "Match and yield all the tokens of the input string .", "label": 0}, {"idx": "cosqa-train-1610", "doc": "python what type of object is xml", "code": "def get_type(self):\n        \"\"\"Get the type of the item.\n\n        :return: the type of the item.\n        :returntype: `unicode`\"\"\"\n        item_type = self.xmlnode.prop(\"type\")\n        if not item_type:\n            item_type = \"?\"\n        return item_type.decode(\"utf-8\")", "code_tokens": "def get_type ( self ) : item_type = self . xmlnode . prop ( \"type\" ) if not item_type : item_type = \"?\" return item_type . decode ( \"utf-8\" )", "docstring_tokens": "Get the type of the item .", "label": 0}, {"idx": "cosqa-train-1611", "doc": "mac osx not verrifying python", "code": "def _is_osx_107():\n    \"\"\"\n    :return:\n        A bool if the current machine is running OS X 10.7\n    \"\"\"\n\n    if sys.platform != 'darwin':\n        return False\n    version = platform.mac_ver()[0]\n    return tuple(map(int, version.split('.')))[0:2] == (10, 7)", "code_tokens": "def _is_osx_107 ( ) : if sys . platform != 'darwin' : return False version = platform . mac_ver ( ) [ 0 ] return tuple ( map ( int , version . split ( '.' ) ) ) [ 0 : 2 ] == ( 10 , 7 )", "docstring_tokens": ": return : A bool if the current machine is running OS X 10 . 7", "label": 0}, {"idx": "cosqa-train-1612", "doc": "python windows close other windows except active window", "code": "def close_other_windows(self):\n        \"\"\"\n        Closes all not current windows. Useful for tests - after each test you\n        can automatically close all windows.\n        \"\"\"\n        main_window_handle = self.current_window_handle\n        for window_handle in self.window_handles:\n            if window_handle == main_window_handle:\n                continue\n            self.switch_to_window(window_handle)\n            self.close()\n        self.switch_to_window(main_window_handle)", "code_tokens": "def close_other_windows ( self ) : main_window_handle = self . current_window_handle for window_handle in self . window_handles : if window_handle == main_window_handle : continue self . switch_to_window ( window_handle ) self . close ( ) self . switch_to_window ( main_window_handle )", "docstring_tokens": "Closes all not current windows . Useful for tests - after each test you can automatically close all windows .", "label": 0}, {"idx": "cosqa-train-1613", "doc": "magnitude of a matrix python", "code": "def magnitude(X):\n    \"\"\"Magnitude of a complex matrix.\"\"\"\n    r = np.real(X)\n    i = np.imag(X)\n    return np.sqrt(r * r + i * i);", "code_tokens": "def magnitude ( X ) : r = np . real ( X ) i = np . imag ( X ) return np . sqrt ( r * r + i * i )", "docstring_tokens": "Magnitude of a complex matrix .", "label": 0}, {"idx": "cosqa-train-1614", "doc": "python windows shared memory api", "code": "def swap_memory():\n    \"\"\"Swap system memory as a (total, used, free, sin, sout) tuple.\"\"\"\n    mem = _psutil_mswindows.get_virtual_mem()\n    total = mem[2]\n    free = mem[3]\n    used = total - free\n    percent = usage_percent(used, total, _round=1)\n    return nt_swapmeminfo(total, used, free, percent, 0, 0)", "code_tokens": "def swap_memory ( ) : mem = _psutil_mswindows . get_virtual_mem ( ) total = mem [ 2 ] free = mem [ 3 ] used = total - free percent = usage_percent ( used , total , _round = 1 ) return nt_swapmeminfo ( total , used , free , percent , 0 , 0 )", "docstring_tokens": "Swap system memory as a ( total used free sin sout ) tuple .", "label": 0}, {"idx": "cosqa-train-1615", "doc": "make a matrix as vector python", "code": "def cross_product_matrix(vec):\n    \"\"\"Returns a 3x3 cross-product matrix from a 3-element vector.\"\"\"\n    return np.array([[0, -vec[2], vec[1]],\n                     [vec[2], 0, -vec[0]],\n                     [-vec[1], vec[0], 0]])", "code_tokens": "def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )", "docstring_tokens": "Returns a 3x3 cross - product matrix from a 3 - element vector .", "label": 1}, {"idx": "cosqa-train-1616", "doc": "python working with protobuf", "code": "def from_pb(cls, pb):\n        \"\"\"Instantiate the object from a protocol buffer.\n\n        Args:\n            pb (protobuf)\n\n        Save a reference to the protocol buffer on the object.\n        \"\"\"\n        obj = cls._from_pb(pb)\n        obj._pb = pb\n        return obj", "code_tokens": "def from_pb ( cls , pb ) : obj = cls . _from_pb ( pb ) obj . _pb = pb return obj", "docstring_tokens": "Instantiate the object from a protocol buffer .", "label": 1}, {"idx": "cosqa-train-1617", "doc": "make a python script executable ~chmod", "code": "def make_executable(script_path):\n    \"\"\"Make `script_path` executable.\n\n    :param script_path: The file to change\n    \"\"\"\n    status = os.stat(script_path)\n    os.chmod(script_path, status.st_mode | stat.S_IEXEC)", "code_tokens": "def make_executable ( script_path ) : status = os . stat ( script_path ) os . chmod ( script_path , status . st_mode | stat . S_IEXEC )", "docstring_tokens": "Make script_path executable .", "label": 0}, {"idx": "cosqa-train-1618", "doc": "python write json structure to file", "code": "def _write_json(file, contents):\n    \"\"\"Write a dict to a JSON file.\"\"\"\n    with open(file, 'w') as f:\n        return json.dump(contents, f, indent=2, sort_keys=True)", "code_tokens": "def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )", "docstring_tokens": "Write a dict to a JSON file .", "label": 0}, {"idx": "cosqa-train-1619", "doc": "make all items unique in list python", "code": "def dedupe(items):\n    \"\"\"Remove duplicates from a sequence (of hashable items) while maintaining\n    order. NOTE: This only works if items in the list are hashable types.\n\n    Taken from the Python Cookbook, 3rd ed. Such a great book!\n\n    \"\"\"\n    seen = set()\n    for item in items:\n        if item not in seen:\n            yield item\n            seen.add(item)", "code_tokens": "def dedupe ( items ) : seen = set ( ) for item in items : if item not in seen : yield item seen . add ( item )", "docstring_tokens": "Remove duplicates from a sequence ( of hashable items ) while maintaining order . NOTE : This only works if items in the list are hashable types .", "label": 0}, {"idx": "cosqa-train-1620", "doc": "python write once property", "code": "def set_property(self, key, value):\n        \"\"\"\n        Update only one property in the dict\n        \"\"\"\n        self.properties[key] = value\n        self.sync_properties()", "code_tokens": "def set_property ( self , key , value ) : self . properties [ key ] = value self . sync_properties ( )", "docstring_tokens": "Update only one property in the dict", "label": 0}, {"idx": "cosqa-train-1621", "doc": "make an array float python", "code": "def as_float_array(a):\n    \"\"\"View the quaternion array as an array of floats\n\n    This function is fast (of order 1 microsecond) because no data is\n    copied; the returned quantity is just a \"view\" of the original.\n\n    The output view has one more dimension (of size 4) than the input\n    array, but is otherwise the same shape.\n\n    \"\"\"\n    return np.asarray(a, dtype=np.quaternion).view((np.double, 4))", "code_tokens": "def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )", "docstring_tokens": "View the quaternion array as an array of floats", "label": 0}, {"idx": "cosqa-train-1622", "doc": "python write text to file with different color", "code": "def _write_color_colorama (fp, text, color):\n    \"\"\"Colorize text with given color.\"\"\"\n    foreground, background, style = get_win_color(color)\n    colorama.set_console(foreground=foreground, background=background,\n      style=style)\n    fp.write(text)\n    colorama.reset_console()", "code_tokens": "def _write_color_colorama ( fp , text , color ) : foreground , background , style = get_win_color ( color ) colorama . set_console ( foreground = foreground , background = background , style = style ) fp . write ( text ) colorama . reset_console ( )", "docstring_tokens": "Colorize text with given color .", "label": 1}, {"idx": "cosqa-train-1623", "doc": "python writing a dictionary to file", "code": "def save_dict_to_file(filename, dictionary):\n  \"\"\"Saves dictionary as CSV file.\"\"\"\n  with open(filename, 'w') as f:\n    writer = csv.writer(f)\n    for k, v in iteritems(dictionary):\n      writer.writerow([str(k), str(v)])", "code_tokens": "def save_dict_to_file ( filename , dictionary ) : with open ( filename , 'w' ) as f : writer = csv . writer ( f ) for k , v in iteritems ( dictionary ) : writer . writerow ( [ str ( k ) , str ( v ) ] )", "docstring_tokens": "Saves dictionary as CSV file .", "label": 0}, {"idx": "cosqa-train-1624", "doc": "make noise using python", "code": "def add_noise(Y, sigma):\n    \"\"\"Adds noise to Y\"\"\"\n    return Y + np.random.normal(0, sigma, Y.shape)", "code_tokens": "def add_noise ( Y , sigma ) : return Y + np . random . normal ( 0 , sigma , Y . shape )", "docstring_tokens": "Adds noise to Y", "label": 0}, {"idx": "cosqa-train-1625", "doc": "python x and y gradients of an image", "code": "def average_gradient(data, *kwargs):\n    \"\"\" Compute average gradient norm of an image\n    \"\"\"\n    return np.average(np.array(np.gradient(data))**2)", "code_tokens": "def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )", "docstring_tokens": "Compute average gradient norm of an image", "label": 0}, {"idx": "cosqa-train-1626", "doc": "make time aware python", "code": "def stopwatch_now():\n    \"\"\"Get a timevalue for interval comparisons\n\n    When possible it is a monotonic clock to prevent backwards time issues.\n    \"\"\"\n    if six.PY2:\n        now = time.time()\n    else:\n        now = time.monotonic()\n    return now", "code_tokens": "def stopwatch_now ( ) : if six . PY2 : now = time . time ( ) else : now = time . monotonic ( ) return now", "docstring_tokens": "Get a timevalue for interval comparisons", "label": 0}, {"idx": "cosqa-train-1627", "doc": "python yaml dump dict with blank ident", "code": "def safe_dump(data, stream=None, **kwds):\n    \"\"\"implementation of safe dumper using Ordered Dict Yaml Dumper\"\"\"\n    return yaml.dump(data, stream=stream, Dumper=ODYD, **kwds)", "code_tokens": "def safe_dump ( data , stream = None , * * kwds ) : return yaml . dump ( data , stream = stream , Dumper = ODYD , * * kwds )", "docstring_tokens": "implementation of safe dumper using Ordered Dict Yaml Dumper", "label": 0}, {"idx": "cosqa-train-1628", "doc": "making a legend on a line graph subplot python", "code": "def add_plot(x, y, xl, yl, fig, ax, LATEX=False, linestyle=None, **kwargs):\n    \"\"\"Add plots to an existing plot\"\"\"\n    if LATEX:\n        xl_data = xl[1]  # NOQA\n        yl_data = yl[1]\n    else:\n        xl_data = xl[0]  # NOQA\n        yl_data = yl[0]\n\n    for idx in range(len(y)):\n        ax.plot(x, y[idx], label=yl_data[idx], linestyle=linestyle)\n\n    ax.legend(loc='upper right')\n    ax.set_ylim(auto=True)", "code_tokens": "def add_plot ( x , y , xl , yl , fig , ax , LATEX = False , linestyle = None , * * kwargs ) : if LATEX : xl_data = xl [ 1 ] # NOQA yl_data = yl [ 1 ] else : xl_data = xl [ 0 ] # NOQA yl_data = yl [ 0 ] for idx in range ( len ( y ) ) : ax . plot ( x , y [ idx ] , label = yl_data [ idx ] , linestyle = linestyle ) ax . legend ( loc = 'upper right' ) ax . set_ylim ( auto = True )", "docstring_tokens": "Add plots to an existing plot", "label": 1}, {"idx": "cosqa-train-1629", "doc": "python yaml safe load json", "code": "def load_yaml_file(file_path: str):\n    \"\"\"Load a YAML file from path\"\"\"\n    with codecs.open(file_path, 'r') as f:\n        return yaml.safe_load(f)", "code_tokens": "def load_yaml_file ( file_path : str ) : with codecs . open ( file_path , 'r' ) as f : return yaml . safe_load ( f )", "docstring_tokens": "Load a YAML file from path", "label": 0}, {"idx": "cosqa-train-1630", "doc": "making a string utf8 python", "code": "def safe_unicode(string):\n    \"\"\"If Python 2, replace non-ascii characters and return encoded string.\"\"\"\n    if not PY3:\n        uni = string.replace(u'\\u2019', \"'\")\n        return uni.encode('utf-8')\n        \n    return string", "code_tokens": "def safe_unicode ( string ) : if not PY3 : uni = string . replace ( u'\\u2019' , \"'\" ) return uni . encode ( 'utf-8' ) return string", "docstring_tokens": "If Python 2 replace non - ascii characters and return encoded string .", "label": 0}, {"idx": "cosqa-train-1631", "doc": "python yaml to dict", "code": "def yaml_to_param(obj, name):\n\t\"\"\"\n\tReturn the top-level element of a document sub-tree containing the\n\tYAML serialization of a Python object.\n\t\"\"\"\n\treturn from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))", "code_tokens": "def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "docstring_tokens": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object .", "label": 0}, {"idx": "cosqa-train-1632", "doc": "making changes to a url in python", "code": "def url_fix_common_typos (url):\n    \"\"\"Fix common typos in given URL like forgotten colon.\"\"\"\n    if url.startswith(\"http//\"):\n        url = \"http://\" + url[6:]\n    elif url.startswith(\"https//\"):\n        url = \"https://\" + url[7:]\n    return url", "code_tokens": "def url_fix_common_typos ( url ) : if url . startswith ( \"http//\" ) : url = \"http://\" + url [ 6 : ] elif url . startswith ( \"https//\" ) : url = \"https://\" + url [ 7 : ] return url", "docstring_tokens": "Fix common typos in given URL like forgotten colon .", "label": 0}, {"idx": "cosqa-train-1633", "doc": "python yaml write ordered dict", "code": "def yaml(self):\n        \"\"\"\n        returns the yaml output of the dict.\n        \"\"\"\n        return ordered_dump(OrderedDict(self),\n                            Dumper=yaml.SafeDumper,\n                            default_flow_style=False)", "code_tokens": "def yaml ( self ) : return ordered_dump ( OrderedDict ( self ) , Dumper = yaml . SafeDumper , default_flow_style = False )", "docstring_tokens": "returns the yaml output of the dict .", "label": 1}, {"idx": "cosqa-train-1634", "doc": "making one axis of imshow wider python", "code": "def matshow(*args, **kwargs):\n    \"\"\"\n    imshow without interpolation like as matshow\n    :param args:\n    :param kwargs:\n    :return:\n    \"\"\"\n    kwargs['interpolation'] = kwargs.pop('interpolation', 'none')\n    return plt.imshow(*args, **kwargs)", "code_tokens": "def matshow ( * args , * * kwargs ) : kwargs [ 'interpolation' ] = kwargs . pop ( 'interpolation' , 'none' ) return plt . imshow ( * args , * * kwargs )", "docstring_tokens": "imshow without interpolation like as matshow : param args : : param kwargs : : return :", "label": 1}, {"idx": "cosqa-train-1635", "doc": "python zipfile extractall file not found", "code": "def extract_all(zipfile, dest_folder):\n    \"\"\"\n    reads the zip file, determines compression\n    and unzips recursively until source files \n    are extracted \n    \"\"\"\n    z = ZipFile(zipfile)\n    print(z)\n    z.extract(dest_folder)", "code_tokens": "def extract_all ( zipfile , dest_folder ) : z = ZipFile ( zipfile ) print ( z ) z . extract ( dest_folder )", "docstring_tokens": "reads the zip file determines compression and unzips recursively until source files are extracted", "label": 0}, {"idx": "cosqa-train-1636", "doc": "many to many relations python", "code": "def handle_m2m(self, sender, instance, **kwargs):\n    \"\"\" Handle many to many relationships \"\"\"\n    self.handle_save(instance.__class__, instance)", "code_tokens": "def handle_m2m ( self , sender , instance , * * kwargs ) : self . handle_save ( instance . __class__ , instance )", "docstring_tokens": "Handle many to many relationships", "label": 0}, {"idx": "cosqa-train-1637", "doc": "python zipfile source and destination the same", "code": "def extract(self, destination):\n        \"\"\"Extract the archive.\"\"\"\n        with zipfile.ZipFile(self.archive, 'r') as zip_ref:\n            zip_ref.extractall(destination)", "code_tokens": "def extract ( self , destination ) : with zipfile . ZipFile ( self . archive , 'r' ) as zip_ref : zip_ref . extractall ( destination )", "docstring_tokens": "Extract the archive .", "label": 0}, {"idx": "cosqa-train-1638", "doc": "map to dict python c++ swig", "code": "def get_python_dict(scala_map):\n    \"\"\"Return a dict from entries in a scala.collection.immutable.Map\"\"\"\n    python_dict = {}\n    keys = get_python_list(scala_map.keys().toList())\n    for key in keys:\n        python_dict[key] = scala_map.apply(key)\n    return python_dict", "code_tokens": "def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict", "docstring_tokens": "Return a dict from entries in a scala . collection . immutable . Map", "label": 0}, {"idx": "cosqa-train-1639", "doc": "python zlib compress file", "code": "def compress(data, **kwargs):\n    \"\"\"zlib.compress(data, **kwargs)\n    \n    \"\"\" + zopfli.__COMPRESSOR_DOCSTRING__  + \"\"\"\n    Returns:\n      String containing a zlib container\n    \"\"\"\n    kwargs['gzip_mode'] = 0\n    return zopfli.zopfli.compress(data, **kwargs)", "code_tokens": "def compress ( data , * * kwargs ) : \"\"\"zlib.compress(data, **kwargs)\n    \n    \"\"\" + zopfli . __COMPRESSOR_DOCSTRING__ + \"\"\"\n    Returns:\n      String containing a zlib container\n    \"\"\" kwargs [ 'gzip_mode' ] = 0 return zopfli . zopfli . compress ( data , * * kwargs )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-1640", "doc": "math average of a list python", "code": "def mean(inlist):\n    \"\"\"\nReturns the arithematic mean of the values in the passed list.\nAssumes a '1D' list, but will function on the 1st dim of an array(!).\n\nUsage:   lmean(inlist)\n\"\"\"\n    sum = 0\n    for item in inlist:\n        sum = sum + item\n    return sum / float(len(inlist))", "code_tokens": "def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )", "docstring_tokens": "Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) .", "label": 0}, {"idx": "cosqa-train-1641", "doc": "python zmq pub build connection", "code": "def init_mq(self):\n        \"\"\"Init connection and consumer with openstack mq.\"\"\"\n        mq = self.init_connection()\n        self.init_consumer(mq)\n        return mq.connection", "code_tokens": "def init_mq ( self ) : mq = self . init_connection ( ) self . init_consumer ( mq ) return mq . connection", "docstring_tokens": "Init connection and consumer with openstack mq .", "label": 0}, {"idx": "cosqa-train-1642", "doc": "matrix dot product python", "code": "def dot_product(self, other):\n        \"\"\" Return the dot product of the given vectors. \"\"\"\n        return self.x * other.x + self.y * other.y", "code_tokens": "def dot_product ( self , other ) : return self . x * other . x + self . y * other . y", "docstring_tokens": "Return the dot product of the given vectors .", "label": 0}, {"idx": "cosqa-train-1643", "doc": "python, how to check the dtype of a variable", "code": "def is_real_floating_dtype(dtype):\n    \"\"\"Return ``True`` if ``dtype`` is a real floating point type.\"\"\"\n    dtype = np.dtype(dtype)\n    return np.issubsctype(getattr(dtype, 'base', None), np.floating)", "code_tokens": "def is_real_floating_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . floating )", "docstring_tokens": "Return True if dtype is a real floating point type .", "label": 1}, {"idx": "cosqa-train-1644", "doc": "max value of al ist python", "code": "def max(self):\n        \"\"\"\n        Returns the maximum value of the domain.\n\n        :rtype: `float` or `np.inf`\n        \"\"\"\n        return int(self._max) if not np.isinf(self._max) else self._max", "code_tokens": "def max ( self ) : return int ( self . _max ) if not np . isinf ( self . _max ) else self . _max", "docstring_tokens": "Returns the maximum value of the domain .", "label": 0}, {"idx": "cosqa-train-1645", "doc": "python, how to run a bash command", "code": "def bash(filename):\n    \"\"\"Runs a bash script in the local directory\"\"\"\n    sys.stdout.flush()\n    subprocess.call(\"bash {}\".format(filename), shell=True)", "code_tokens": "def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( \"bash {}\" . format ( filename ) , shell = True )", "docstring_tokens": "Runs a bash script in the local directory", "label": 0}, {"idx": "cosqa-train-1646", "doc": "maximize log likelihood python", "code": "def log_loss(preds, labels):\n    \"\"\"Logarithmic loss with non-necessarily-binary labels.\"\"\"\n    log_likelihood = np.sum(labels * np.log(preds)) / len(preds)\n    return -log_likelihood", "code_tokens": "def log_loss ( preds , labels ) : log_likelihood = np . sum ( labels * np . log ( preds ) ) / len ( preds ) return - log_likelihood", "docstring_tokens": "Logarithmic loss with non - necessarily - binary labels .", "label": 1}, {"idx": "cosqa-train-1647", "doc": "python, lists to dict", "code": "def list_of_lists_to_dict(l):\n    \"\"\" Convert list of key,value lists to dict\n\n    [['id', 1], ['id', 2], ['id', 3], ['foo': 4]]\n    {'id': [1, 2, 3], 'foo': [4]}\n    \"\"\"\n    d = {}\n    for key, val in l:\n        d.setdefault(key, []).append(val)\n    return d", "code_tokens": "def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d", "docstring_tokens": "Convert list of key value lists to dict", "label": 0}, {"idx": "cosqa-train-1648", "doc": "maximum length of column in 2d array python", "code": "def longest_run_1d(arr):\n    \"\"\"Return the length of the longest consecutive run of identical values.\n\n    Parameters\n    ----------\n    arr : bool array\n      Input array\n\n    Returns\n    -------\n    int\n      Length of longest run.\n    \"\"\"\n    v, rl = rle_1d(arr)[:2]\n    return np.where(v, rl, 0).max()", "code_tokens": "def longest_run_1d ( arr ) : v , rl = rle_1d ( arr ) [ : 2 ] return np . where ( v , rl , 0 ) . max ( )", "docstring_tokens": "Return the length of the longest consecutive run of identical values .", "label": 0}, {"idx": "cosqa-train-1649", "doc": "python3 2 list to dict", "code": "def list2dict(list_of_options):\n    \"\"\"Transforms a list of 2 element tuples to a dictionary\"\"\"\n    d = {}\n    for key, value in list_of_options:\n        d[key] = value\n    return d", "code_tokens": "def list2dict ( list_of_options ) : d = { } for key , value in list_of_options : d [ key ] = value return d", "docstring_tokens": "Transforms a list of 2 element tuples to a dictionary", "label": 0}, {"idx": "cosqa-train-1650", "doc": "maximum numbers accepted by randrange in python", "code": "def simulate(self):\n        \"\"\"Generates a random integer in the available range.\"\"\"\n        min_ = (-sys.maxsize - 1) if self._min is None else self._min\n        max_ = sys.maxsize if self._max is None else self._max\n        return random.randint(min_, max_)", "code_tokens": "def simulate ( self ) : min_ = ( - sys . maxsize - 1 ) if self . _min is None else self . _min max_ = sys . maxsize if self . _max is None else self . _max return random . randint ( min_ , max_ )", "docstring_tokens": "Generates a random integer in the available range .", "label": 0}, {"idx": "cosqa-train-1651", "doc": "python3 change directory contextmanager", "code": "def in_directory(path):\n    \"\"\"Context manager (with statement) that changes the current directory\n    during the context.\n    \"\"\"\n    curdir = os.path.abspath(os.curdir)\n    os.chdir(path)\n    yield\n    os.chdir(curdir)", "code_tokens": "def in_directory ( path ) : curdir = os . path . abspath ( os . curdir ) os . chdir ( path ) yield os . chdir ( curdir )", "docstring_tokens": "Context manager ( with statement ) that changes the current directory during the context .", "label": 0}, {"idx": "cosqa-train-1652", "doc": "median filter data function python", "code": "def median(data):\n    \"\"\"Calculate the median of a list.\"\"\"\n    data.sort()\n    num_values = len(data)\n    half = num_values // 2\n    if num_values % 2:\n        return data[half]\n    return 0.5 * (data[half-1] + data[half])", "code_tokens": "def median ( data ) : data . sort ( ) num_values = len ( data ) half = num_values // 2 if num_values % 2 : return data [ half ] return 0.5 * ( data [ half - 1 ] + data [ half ] )", "docstring_tokens": "Calculate the median of a list .", "label": 0}, {"idx": "cosqa-train-1653", "doc": "python3 filter object is not", "code": "def filter_(stream_spec, filter_name, *args, **kwargs):\n    \"\"\"Alternate name for ``filter``, so as to not collide with the\n    built-in python ``filter`` operator.\n    \"\"\"\n    return filter(stream_spec, filter_name, *args, **kwargs)", "code_tokens": "def filter_ ( stream_spec , filter_name , * args , * * kwargs ) : return filter ( stream_spec , filter_name , * args , * * kwargs )", "docstring_tokens": "Alternate name for filter so as to not collide with the built - in python filter operator .", "label": 0}, {"idx": "cosqa-train-1654", "doc": "merge pdf into one python", "code": "def append_pdf(input_pdf: bytes, output_writer: PdfFileWriter):\n    \"\"\"\n    Appends a PDF to a pyPDF writer. Legacy interface.\n    \"\"\"\n    append_memory_pdf_to_writer(input_pdf=input_pdf,\n                                writer=output_writer)", "code_tokens": "def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )", "docstring_tokens": "Appends a PDF to a pyPDF writer . Legacy interface .", "label": 0}, {"idx": "cosqa-train-1655", "doc": "python3 get datetime instance by milliseconds", "code": "def date_to_timestamp(date):\n    \"\"\"\n        date to unix timestamp in milliseconds\n    \"\"\"\n    date_tuple = date.timetuple()\n    timestamp = calendar.timegm(date_tuple) * 1000\n    return timestamp", "code_tokens": "def date_to_timestamp ( date ) : date_tuple = date . timetuple ( ) timestamp = calendar . timegm ( date_tuple ) * 1000 return timestamp", "docstring_tokens": "date to unix timestamp in milliseconds", "label": 0}, {"idx": "cosqa-train-1656", "doc": "mime type flask python", "code": "def python_mime(fn):\n    \"\"\"\n    Decorator, which adds correct MIME type for python source to the decorated\n    bottle API function.\n    \"\"\"\n    @wraps(fn)\n    def python_mime_decorator(*args, **kwargs):\n        response.content_type = \"text/x-python\"\n\n        return fn(*args, **kwargs)\n\n    return python_mime_decorator", "code_tokens": "def python_mime ( fn ) : @ wraps ( fn ) def python_mime_decorator ( * args , * * kwargs ) : response . content_type = \"text/x-python\" return fn ( * args , * * kwargs ) return python_mime_decorator", "docstring_tokens": "Decorator which adds correct MIME type for python source to the decorated bottle API function .", "label": 0}, {"idx": "cosqa-train-1657", "doc": "python3 get method by name", "code": "def FindMethodByName(self, name):\n    \"\"\"Searches for the specified method, and returns its descriptor.\"\"\"\n    for method in self.methods:\n      if name == method.name:\n        return method\n    return None", "code_tokens": "def FindMethodByName ( self , name ) : for method in self . methods : if name == method . name : return method return None", "docstring_tokens": "Searches for the specified method and returns its descriptor .", "label": 0}, {"idx": "cosqa-train-1658", "doc": "mock a function in python", "code": "def mock_decorator(*args, **kwargs):\n    \"\"\"Mocked decorator, needed in the case we need to mock a decorator\"\"\"\n    def _called_decorator(dec_func):\n        @wraps(dec_func)\n        def _decorator(*args, **kwargs):\n            return dec_func()\n        return _decorator\n    return _called_decorator", "code_tokens": "def mock_decorator ( * args , * * kwargs ) : def _called_decorator ( dec_func ) : @ wraps ( dec_func ) def _decorator ( * args , * * kwargs ) : return dec_func ( ) return _decorator return _called_decorator", "docstring_tokens": "Mocked decorator needed in the case we need to mock a decorator", "label": 1}, {"idx": "cosqa-train-1659", "doc": "python3 itertools flatten list", "code": "def flatten_list(l):\n    \"\"\" Nested lists to single-level list, does not split strings\"\"\"\n    return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "code_tokens": "def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )", "docstring_tokens": "Nested lists to single - level list does not split strings", "label": 0}, {"idx": "cosqa-train-1660", "doc": "modify existing cmap python matplotlib", "code": "def add_matplotlib_cmap(cm, name=None):\n    \"\"\"Add a matplotlib colormap.\"\"\"\n    global cmaps\n    cmap = matplotlib_to_ginga_cmap(cm, name=name)\n    cmaps[cmap.name] = cmap", "code_tokens": "def add_matplotlib_cmap ( cm , name = None ) : global cmaps cmap = matplotlib_to_ginga_cmap ( cm , name = name ) cmaps [ cmap . name ] = cmap", "docstring_tokens": "Add a matplotlib colormap .", "label": 0}, {"idx": "cosqa-train-1661", "doc": "python3 json object must be str not bytes", "code": "def to_bytes(value):\n    \"\"\" str to bytes (py3k) \"\"\"\n    vtype = type(value)\n\n    if vtype == bytes or vtype == type(None):\n        return value\n\n    try:\n        return vtype.encode(value)\n    except UnicodeEncodeError:\n        pass\n    return value", "code_tokens": "def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value", "docstring_tokens": "str to bytes ( py3k )", "label": 0}, {"idx": "cosqa-train-1662", "doc": "mongo query to python converter", "code": "def find_one(self, query):\n        \"\"\"Find one wrapper with conversion to dictionary\n\n        :param dict query: A Mongo query\n        \"\"\"\n        mongo_response = yield self.collection.find_one(query)\n        raise Return(self._obj_cursor_to_dictionary(mongo_response))", "code_tokens": "def find_one ( self , query ) : mongo_response = yield self . collection . find_one ( query ) raise Return ( self . _obj_cursor_to_dictionary ( mongo_response ) )", "docstring_tokens": "Find one wrapper with conversion to dictionary", "label": 0}, {"idx": "cosqa-train-1663", "doc": "python3 json the json object must be str, not 'bytes'", "code": "def loadb(b):\n    \"\"\"Deserialize ``b`` (instance of ``bytes``) to a Python object.\"\"\"\n    assert isinstance(b, (bytes, bytearray))\n    return std_json.loads(b.decode('utf-8'))", "code_tokens": "def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )", "docstring_tokens": "Deserialize b ( instance of bytes ) to a Python object .", "label": 0}, {"idx": "cosqa-train-1664", "doc": "multiple colons for string python", "code": "def test_replace_colon():\n    \"\"\"py.test for replace_colon\"\"\"\n    data = ((\"zone:aap\", '@', \"zone@aap\"),# s, r, replaced\n    )    \n    for s, r, replaced in data:\n        result = replace_colon(s, r)\n        assert result == replaced", "code_tokens": "def test_replace_colon ( ) : data = ( ( \"zone:aap\" , '@' , \"zone@aap\" ) , # s, r, replaced ) for s , r , replaced in data : result = replace_colon ( s , r ) assert result == replaced", "docstring_tokens": "py . test for replace_colon", "label": 1}, {"idx": "cosqa-train-1665", "doc": "python3 logger timedrotatingfilehandler rotate doesn't work", "code": "def init_rotating_logger(level, logfile, max_files, max_bytes):\n  \"\"\"Initializes a rotating logger\n\n  It also makes sure that any StreamHandler is removed, so as to avoid stdout/stderr\n  constipation issues\n  \"\"\"\n  logging.basicConfig()\n\n  root_logger = logging.getLogger()\n  log_format = \"[%(asctime)s] [%(levelname)s] %(filename)s: %(message)s\"\n\n  root_logger.setLevel(level)\n  handler = RotatingFileHandler(logfile, maxBytes=max_bytes, backupCount=max_files)\n  handler.setFormatter(logging.Formatter(fmt=log_format, datefmt=date_format))\n  root_logger.addHandler(handler)\n\n  for handler in root_logger.handlers:\n    root_logger.debug(\"Associated handlers - \" + str(handler))\n    if isinstance(handler, logging.StreamHandler):\n      root_logger.debug(\"Removing StreamHandler: \" + str(handler))\n      root_logger.handlers.remove(handler)", "code_tokens": "def init_rotating_logger ( level , logfile , max_files , max_bytes ) : logging . basicConfig ( ) root_logger = logging . getLogger ( ) log_format = \"[%(asctime)s] [%(levelname)s] %(filename)s: %(message)s\" root_logger . setLevel ( level ) handler = RotatingFileHandler ( logfile , maxBytes = max_bytes , backupCount = max_files ) handler . setFormatter ( logging . Formatter ( fmt = log_format , datefmt = date_format ) ) root_logger . addHandler ( handler ) for handler in root_logger . handlers : root_logger . debug ( \"Associated handlers - \" + str ( handler ) ) if isinstance ( handler , logging . StreamHandler ) : root_logger . debug ( \"Removing StreamHandler: \" + str ( handler ) ) root_logger . handlers . remove ( handler )", "docstring_tokens": "Initializes a rotating logger", "label": 0}, {"idx": "cosqa-train-1666", "doc": "multiple python devs using same server", "code": "def main(ctx, connection):\n    \"\"\"Command line interface for PyBEL.\"\"\"\n    ctx.obj = Manager(connection=connection)\n    ctx.obj.bind()", "code_tokens": "def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )", "docstring_tokens": "Command line interface for PyBEL .", "label": 0}, {"idx": "cosqa-train-1667", "doc": "python3 read first line of file", "code": "def getfirstline(file, default):\n    \"\"\"\n    Returns the first line of a file.\n    \"\"\"\n    with open(file, 'rb') as fh:\n        content = fh.readlines()\n        if len(content) == 1:\n            return content[0].decode('utf-8').strip('\\n')\n\n    return default", "code_tokens": "def getfirstline ( file , default ) : with open ( file , 'rb' ) as fh : content = fh . readlines ( ) if len ( content ) == 1 : return content [ 0 ] . decode ( 'utf-8' ) . strip ( '\\n' ) return default", "docstring_tokens": "Returns the first line of a file .", "label": 0}, {"idx": "cosqa-train-1668", "doc": "multiple sets of parentheses function python", "code": "def maybeparens(lparen, item, rparen):\n    \"\"\"Wrap an item in optional parentheses, only applying them if necessary.\"\"\"\n    return item | lparen.suppress() + item + rparen.suppress()", "code_tokens": "def maybeparens ( lparen , item , rparen ) : return item | lparen . suppress ( ) + item + rparen . suppress ( )", "docstring_tokens": "Wrap an item in optional parentheses only applying them if necessary .", "label": 0}, {"idx": "cosqa-train-1669", "doc": "python3 set default timezone", "code": "def now(timezone=None):\n    \"\"\"\n    Return a naive datetime object for the given ``timezone``. A ``timezone``\n    is any pytz- like or datetime.tzinfo-like timezone object. If no timezone\n    is given, then UTC is assumed.\n\n    This method is best used with pytz installed::\n\n        pip install pytz\n    \"\"\"\n    d = datetime.datetime.utcnow()\n    if not timezone:\n        return d\n\n    return to_timezone(d, timezone).replace(tzinfo=None)", "code_tokens": "def now ( timezone = None ) : d = datetime . datetime . utcnow ( ) if not timezone : return d return to_timezone ( d , timezone ) . replace ( tzinfo = None )", "docstring_tokens": "Return a naive datetime object for the given timezone . A timezone is any pytz - like or datetime . tzinfo - like timezone object . If no timezone is given then UTC is assumed .", "label": 0}, {"idx": "cosqa-train-1670", "doc": "multiply vector element wise by matrix python", "code": "def matrixTimesVector(MM, aa):\n    \"\"\"\n\n    :param MM: A matrix of size 3x3\n    :param aa: A vector of size 3\n    :return: A vector of size 3 which is the product of the matrix by the vector\n    \"\"\"\n    bb = np.zeros(3, np.float)\n    for ii in range(3):\n        bb[ii] = np.sum(MM[ii, :] * aa)\n    return bb", "code_tokens": "def matrixTimesVector ( MM , aa ) : bb = np . zeros ( 3 , np . float ) for ii in range ( 3 ) : bb [ ii ] = np . sum ( MM [ ii , : ] * aa ) return bb", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-1671", "doc": "python3 stdout context manger", "code": "def redirect_stdout(new_stdout):\n    \"\"\"Redirect the stdout\n\n    Args:\n        new_stdout (io.StringIO): New stdout to use instead\n    \"\"\"\n    old_stdout, sys.stdout = sys.stdout, new_stdout\n    try:\n        yield None\n    finally:\n        sys.stdout = old_stdout", "code_tokens": "def redirect_stdout ( new_stdout ) : old_stdout , sys . stdout = sys . stdout , new_stdout try : yield None finally : sys . stdout = old_stdout", "docstring_tokens": "Redirect the stdout", "label": 0}, {"idx": "cosqa-train-1672", "doc": "mutate boolean column python", "code": "def _check_and_convert_bools(self):\n        \"\"\"Replace boolean variables by the characters 'F'/'T'\n        \"\"\"\n        replacements = {\n            True: 'T',\n            False: 'F',\n        }\n\n        for key in self.bools:\n            if isinstance(self[key], bool):\n                self[key] = replacements[self[key]]", "code_tokens": "def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]", "docstring_tokens": "Replace boolean variables by the characters F / T", "label": 0}, {"idx": "cosqa-train-1673", "doc": "python3 stop the current excutation", "code": "def __exit__(self, *exc):\n        \"\"\"Exit the runtime context. This will end the transaction.\"\"\"\n        if exc[0] is None and exc[1] is None and exc[2] is None:\n            self.commit()\n        else:\n            self.rollback()", "code_tokens": "def __exit__ ( self , * exc ) : if exc [ 0 ] is None and exc [ 1 ] is None and exc [ 2 ] is None : self . commit ( ) else : self . rollback ( )", "docstring_tokens": "Exit the runtime context . This will end the transaction .", "label": 0}, {"idx": "cosqa-train-1674", "doc": "nested dictionaries python string", "code": "def stringify_dict_contents(dct):\n    \"\"\"Turn dict keys and values into native strings.\"\"\"\n    return {\n        str_if_nested_or_str(k): str_if_nested_or_str(v)\n        for k, v in dct.items()\n    }", "code_tokens": "def stringify_dict_contents ( dct ) : return { str_if_nested_or_str ( k ) : str_if_nested_or_str ( v ) for k , v in dct . items ( ) }", "docstring_tokens": "Turn dict keys and values into native strings .", "label": 0}, {"idx": "cosqa-train-1675", "doc": "qgis python move layer up", "code": "def up(self):\n        \n        \"\"\"Moves the layer up in the stacking order.\n        \n        \"\"\"\n        \n        i = self.index()\n        if i != None:\n            del self.canvas.layers[i]\n            i = min(len(self.canvas.layers), i+1)\n            self.canvas.layers.insert(i, self)", "code_tokens": "def up ( self ) : i = self . index ( ) if i != None : del self . canvas . layers [ i ] i = min ( len ( self . canvas . layers ) , i + 1 ) self . canvas . layers . insert ( i , self )", "docstring_tokens": "Moves the layer up in the stacking order .", "label": 0}, {"idx": "cosqa-train-1676", "doc": "nested dictionary python format string", "code": "def pretty_dict_string(d, indent=0):\n    \"\"\"Pretty output of nested dictionaries.\n    \"\"\"\n    s = ''\n    for key, value in sorted(d.items()):\n        s += '    ' * indent + str(key)\n        if isinstance(value, dict):\n             s += '\\n' + pretty_dict_string(value, indent+1)\n        else:\n             s += '=' + str(value) + '\\n'\n    return s", "code_tokens": "def pretty_dict_string ( d , indent = 0 ) : s = '' for key , value in sorted ( d . items ( ) ) : s += '    ' * indent + str ( key ) if isinstance ( value , dict ) : s += '\\n' + pretty_dict_string ( value , indent + 1 ) else : s += '=' + str ( value ) + '\\n' return s", "docstring_tokens": "Pretty output of nested dictionaries .", "label": 0}, {"idx": "cosqa-train-1677", "doc": "qpython3 getlocale locale query failed", "code": "def set_locale(request):\n    \"\"\"Return locale from GET lang param or automatically.\"\"\"\n    return request.query.get('lang', app.ps.babel.select_locale_by_request(request))", "code_tokens": "def set_locale ( request ) : return request . query . get ( 'lang' , app . ps . babel . select_locale_by_request ( request ) )", "docstring_tokens": "Return locale from GET lang param or automatically .", "label": 0}, {"idx": "cosqa-train-1678", "doc": "no is power of 2 in python", "code": "def is_power_of_2(num):\n    \"\"\"Return whether `num` is a power of two\"\"\"\n    log = math.log2(num)\n    return int(log) == float(log)", "code_tokens": "def is_power_of_2 ( num ) : log = math . log2 ( num ) return int ( log ) == float ( log )", "docstring_tokens": "Return whether num is a power of two", "label": 0}, {"idx": "cosqa-train-1679", "doc": "qrcode python how to save image to file", "code": "def _qrcode_to_file(qrcode, out_filepath):\n    \"\"\" Save a `qrcode` object into `out_filepath`.\n    Parameters\n    ----------\n    qrcode: qrcode object\n\n    out_filepath: str\n        Path to the output file.\n    \"\"\"\n    try:\n        qrcode.save(out_filepath)\n    except Exception as exc:\n        raise IOError('Error trying to save QR code file {}.'.format(out_filepath)) from exc\n    else:\n        return qrcode", "code_tokens": "def _qrcode_to_file ( qrcode , out_filepath ) : try : qrcode . save ( out_filepath ) except Exception as exc : raise IOError ( 'Error trying to save QR code file {}.' . format ( out_filepath ) ) from exc else : return qrcode", "docstring_tokens": "Save a qrcode object into out_filepath . Parameters ---------- qrcode : qrcode object", "label": 0}, {"idx": "cosqa-train-1680", "doc": "no style with name docx python", "code": "def prepare(doc):\n    \"\"\"Sets the caption_found and plot_found variables to False.\"\"\"\n    doc.caption_found = False\n    doc.plot_found = False\n    doc.listings_counter = 0", "code_tokens": "def prepare ( doc ) : doc . caption_found = False doc . plot_found = False doc . listings_counter = 0", "docstring_tokens": "Sets the caption_found and plot_found variables to False .", "label": 0}, {"idx": "cosqa-train-1681", "doc": "question make python copy", "code": "def copy(obj):\n    def copy(self):\n        \"\"\"\n        Copy self to a new object.\n        \"\"\"\n        from copy import deepcopy\n\n        return deepcopy(self)\n    obj.copy = copy\n    return obj", "code_tokens": "def copy ( obj ) : def copy ( self ) : \"\"\"\n        Copy self to a new object.\n        \"\"\" from copy import deepcopy return deepcopy ( self ) obj . copy = copy return obj", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-1682", "doc": "noise in an image python", "code": "def shot_noise(x, severity=1):\n  \"\"\"Shot noise corruption to images.\n\n  Args:\n    x: numpy array, uncorrupted image, assumed to have uint8 pixel in [0,255].\n    severity: integer, severity of corruption.\n\n  Returns:\n    numpy array, image with uint8 pixels in [0,255]. Added shot noise.\n  \"\"\"\n  c = [60, 25, 12, 5, 3][severity - 1]\n  x = np.array(x) / 255.\n  x_clip = np.clip(np.random.poisson(x * c) / float(c), 0, 1) * 255\n  return around_and_astype(x_clip)", "code_tokens": "def shot_noise ( x , severity = 1 ) : c = [ 60 , 25 , 12 , 5 , 3 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( np . random . poisson ( x * c ) / float ( c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )", "docstring_tokens": "Shot noise corruption to images .", "label": 0}, {"idx": "cosqa-train-1683", "doc": "random int with if else python", "code": "def positive_integer(anon, obj, field, val):\n    \"\"\"\n    Returns a random positive integer (for a Django PositiveIntegerField)\n    \"\"\"\n    return anon.faker.positive_integer(field=field)", "code_tokens": "def positive_integer ( anon , obj , field , val ) : return anon . faker . positive_integer ( field = field )", "docstring_tokens": "Returns a random positive integer ( for a Django PositiveIntegerField )", "label": 0}, {"idx": "cosqa-train-1684", "doc": "normalize cifar10 input python with tensorflow", "code": "def _normalize(image):\n  \"\"\"Normalize the image to zero mean and unit variance.\"\"\"\n  offset = tf.constant(MEAN_RGB, shape=[1, 1, 3])\n  image -= offset\n\n  scale = tf.constant(STDDEV_RGB, shape=[1, 1, 3])\n  image /= scale\n  return image", "code_tokens": "def _normalize ( image ) : offset = tf . constant ( MEAN_RGB , shape = [ 1 , 1 , 3 ] ) image -= offset scale = tf . constant ( STDDEV_RGB , shape = [ 1 , 1 , 3 ] ) image /= scale return image", "docstring_tokens": "Normalize the image to zero mean and unit variance .", "label": 0}, {"idx": "cosqa-train-1685", "doc": "random integer in a function set to variable python", "code": "def sometimesish(fn):\n    \"\"\"\n    Has a 50/50 chance of calling a function\n    \"\"\"\n    def wrapped(*args, **kwargs):\n        if random.randint(1, 2) == 1:\n            return fn(*args, **kwargs)\n\n    return wrapped", "code_tokens": "def sometimesish ( fn ) : def wrapped ( * args , * * kwargs ) : if random . randint ( 1 , 2 ) == 1 : return fn ( * args , * * kwargs ) return wrapped", "docstring_tokens": "Has a 50 / 50 chance of calling a function", "label": 0}, {"idx": "cosqa-train-1686", "doc": "normalize histogram python log", "code": "def log_normalize(data):\n    \"\"\"Perform log transform log(x + 1).\n    \n    Parameters\n    ----------\n    data : array_like\n    \n    \"\"\"\n    if sp.issparse(data):\n        data = data.copy()\n        data.data = np.log2(data.data + 1)\n        return data\n\n    return np.log2(data.astype(np.float64) + 1)", "code_tokens": "def log_normalize ( data ) : if sp . issparse ( data ) : data = data . copy ( ) data . data = np . log2 ( data . data + 1 ) return data return np . log2 ( data . astype ( np . float64 ) + 1 )", "docstring_tokens": "Perform log transform log ( x + 1 ) . Parameters ---------- data : array_like", "label": 1}, {"idx": "cosqa-train-1687", "doc": "random uniform high and low data python", "code": "def runiform(lower, upper, size=None):\n    \"\"\"\n    Random uniform variates.\n    \"\"\"\n    return np.random.uniform(lower, upper, size)", "code_tokens": "def runiform ( lower , upper , size = None ) : return np . random . uniform ( lower , upper , size )", "docstring_tokens": "Random uniform variates .", "label": 0}, {"idx": "cosqa-train-1688", "doc": "np array float python to string base64", "code": "def decode_arr(data):\n    \"\"\"Extract a numpy array from a base64 buffer\"\"\"\n    data = data.encode('utf-8')\n    return frombuffer(base64.b64decode(data), float64)", "code_tokens": "def decode_arr ( data ) : data = data . encode ( 'utf-8' ) return frombuffer ( base64 . b64decode ( data ) , float64 )", "docstring_tokens": "Extract a numpy array from a base64 buffer", "label": 0}, {"idx": "cosqa-train-1689", "doc": "range of indices of list python", "code": "def get_idx_rect(index_list):\n    \"\"\"Extract the boundaries from a list of indexes\"\"\"\n    rows, cols = list(zip(*[(i.row(), i.column()) for i in index_list]))\n    return ( min(rows), max(rows), min(cols), max(cols) )", "code_tokens": "def get_idx_rect ( index_list ) : rows , cols = list ( zip ( * [ ( i . row ( ) , i . column ( ) ) for i in index_list ] ) ) return ( min ( rows ) , max ( rows ) , min ( cols ) , max ( cols ) )", "docstring_tokens": "Extract the boundaries from a list of indexes", "label": 0}, {"idx": "cosqa-train-1690", "doc": "number of prime factors in python", "code": "def _factor_generator(n):\n    \"\"\"\n    From a given natural integer, returns the prime factors and their multiplicity\n    :param n: Natural integer\n    :return:\n    \"\"\"\n    p = prime_factors(n)\n    factors = {}\n    for p1 in p:\n        try:\n            factors[p1] += 1\n        except KeyError:\n            factors[p1] = 1\n    return factors", "code_tokens": "def _factor_generator ( n ) : p = prime_factors ( n ) factors = { } for p1 in p : try : factors [ p1 ] += 1 except KeyError : factors [ p1 ] = 1 return factors", "docstring_tokens": "From a given natural integer returns the prime factors and their multiplicity : param n : Natural integer : return :", "label": 0}, {"idx": "cosqa-train-1691", "doc": "raspberry python get status of gpio pins", "code": "def input(self,pin):\n        \"\"\"Read the specified pin and return HIGH/true if the pin is pulled high,\n        or LOW/false if pulled low.\n        \"\"\"\n        return self.mraa_gpio.Gpio.read(self.mraa_gpio.Gpio(pin))", "code_tokens": "def input ( self , pin ) : return self . mraa_gpio . Gpio . read ( self . mraa_gpio . Gpio ( pin ) )", "docstring_tokens": "Read the specified pin and return HIGH / true if the pin is pulled high or LOW / false if pulled low .", "label": 0}, {"idx": "cosqa-train-1692", "doc": "number of rows in a df python", "code": "def count_(self):\n        \"\"\"\n        Returns the number of rows of the main dataframe\n        \"\"\"\n        try:\n            num = len(self.df.index)\n        except Exception as e:\n            self.err(e, \"Can not count data\")\n            return\n        return num", "code_tokens": "def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , \"Can not count data\" ) return return num", "docstring_tokens": "Returns the number of rows of the main dataframe", "label": 0}, {"idx": "cosqa-train-1693", "doc": "read all subkeys from a key regedit python", "code": "def _iter_keys(key):\n    \"\"\"! Iterate over subkeys of a key\n    \"\"\"\n    for i in range(winreg.QueryInfoKey(key)[0]):\n        yield winreg.OpenKey(key, winreg.EnumKey(key, i))", "code_tokens": "def _iter_keys ( key ) : for i in range ( winreg . QueryInfoKey ( key ) [ 0 ] ) : yield winreg . OpenKey ( key , winreg . EnumKey ( key , i ) )", "docstring_tokens": "! Iterate over subkeys of a key", "label": 0}, {"idx": "cosqa-train-1694", "doc": "number of rows in dataset in python", "code": "def shape(self):\n        \"\"\"Compute the shape of the dataset as (rows, cols).\"\"\"\n        if not self.data:\n            return (0, 0)\n        return (len(self.data), len(self.dimensions))", "code_tokens": "def shape ( self ) : if not self . data : return ( 0 , 0 ) return ( len ( self . data ) , len ( self . dimensions ) )", "docstring_tokens": "Compute the shape of the dataset as ( rows cols ) .", "label": 0}, {"idx": "cosqa-train-1695", "doc": "read config yaml file from python", "code": "def _parse_config(config_file_path):\n    \"\"\" Parse Config File from yaml file. \"\"\"\n    config_file = open(config_file_path, 'r')\n    config = yaml.load(config_file)\n    config_file.close()\n    return config", "code_tokens": "def _parse_config ( config_file_path ) : config_file = open ( config_file_path , 'r' ) config = yaml . load ( config_file ) config_file . close ( ) return config", "docstring_tokens": "Parse Config File from yaml file .", "label": 0}, {"idx": "cosqa-train-1696", "doc": "obtain model accuracy in python", "code": "def local_accuracy(X_train, y_train, X_test, y_test, attr_test, model_generator, metric, trained_model):\n    \"\"\" The how well do the features plus a constant base rate sum up to the model output.\n    \"\"\"\n\n    X_train, X_test = to_array(X_train, X_test)\n\n    # how many features to mask\n    assert X_train.shape[1] == X_test.shape[1]\n\n    # keep nkeep top features and re-train the model for each test explanation\n    yp_test = trained_model.predict(X_test)\n\n    return metric(yp_test, strip_list(attr_test).sum(1))", "code_tokens": "def local_accuracy ( X_train , y_train , X_test , y_test , attr_test , model_generator , metric , trained_model ) : X_train , X_test = to_array ( X_train , X_test ) # how many features to mask assert X_train . shape [ 1 ] == X_test . shape [ 1 ] # keep nkeep top features and re-train the model for each test explanation yp_test = trained_model . predict ( X_test ) return metric ( yp_test , strip_list ( attr_test ) . sum ( 1 ) )", "docstring_tokens": "The how well do the features plus a constant base rate sum up to the model output .", "label": 1}, {"idx": "cosqa-train-1697", "doc": "read data from file to matrix in python", "code": "def load_data(filename):\n    \"\"\"\n    :rtype : numpy matrix\n    \"\"\"\n    data = pandas.read_csv(filename, header=None, delimiter='\\t', skiprows=9)\n    return data.as_matrix()", "code_tokens": "def load_data ( filename ) : data = pandas . read_csv ( filename , header = None , delimiter = '\\t' , skiprows = 9 ) return data . as_matrix ( )", "docstring_tokens": ": rtype : numpy matrix", "label": 0}, {"idx": "cosqa-train-1698", "doc": "one hot encode list of words in python", "code": "def one_hot2string(arr, vocab):\n    \"\"\"Convert a one-hot encoded array back to string\n    \"\"\"\n    tokens = one_hot2token(arr)\n    indexToLetter = _get_index_dict(vocab)\n\n    return [''.join([indexToLetter[x] for x in row]) for row in tokens]", "code_tokens": "def one_hot2string ( arr , vocab ) : tokens = one_hot2token ( arr ) indexToLetter = _get_index_dict ( vocab ) return [ '' . join ( [ indexToLetter [ x ] for x in row ] ) for row in tokens ]", "docstring_tokens": "Convert a one - hot encoded array back to string", "label": 0}, {"idx": "cosqa-train-1699", "doc": "read file with lambda python", "code": "def lambda_from_file(python_file):\n    \"\"\"\n    Reads a python file and returns a awslambda.Code object\n    :param python_file:\n    :return:\n    \"\"\"\n    lambda_function = []\n    with open(python_file, 'r') as f:\n        lambda_function.extend(f.read().splitlines())\n\n    return awslambda.Code(ZipFile=(Join('\\n', lambda_function)))", "code_tokens": "def lambda_from_file ( python_file ) : lambda_function = [ ] with open ( python_file , 'r' ) as f : lambda_function . extend ( f . read ( ) . splitlines ( ) ) return awslambda . Code ( ZipFile = ( Join ( '\\n' , lambda_function ) ) )", "docstring_tokens": "Reads a python file and returns a awslambda . Code object : param python_file : : return :", "label": 0}, {"idx": "cosqa-train-1700", "doc": "one to multiple mapping in python", "code": "def reverse_code_map(self):\n        \"\"\"Return a map from a code ( usually a string ) to the  shorter numeric value\"\"\"\n\n        return {c.value: (c.ikey if c.ikey else c.key) for c in self.codes}", "code_tokens": "def reverse_code_map ( self ) : return { c . value : ( c . ikey if c . ikey else c . key ) for c in self . codes }", "docstring_tokens": "Return a map from a code ( usually a string ) to the shorter numeric value", "label": 0}, {"idx": "cosqa-train-1701", "doc": "read html as plain text file python", "code": "def html_to_text(content):\n    \"\"\" Converts html content to plain text \"\"\"\n    text = None\n    h2t = html2text.HTML2Text()\n    h2t.ignore_links = False\n    text = h2t.handle(content)\n    return text", "code_tokens": "def html_to_text ( content ) : text = None h2t = html2text . HTML2Text ( ) h2t . ignore_links = False text = h2t . handle ( content ) return text", "docstring_tokens": "Converts html content to plain text", "label": 0}, {"idx": "cosqa-train-1702", "doc": "open geojson file with python", "code": "def _loadfilepath(self, filepath, **kwargs):\n        \"\"\"This loads a geojson file into a geojson python\n        dictionary using the json module.\n        \n        Note: to load with a different text encoding use the encoding argument.\n        \"\"\"\n        with open(filepath, \"r\") as f:\n            data = json.load(f, **kwargs)\n        return data", "code_tokens": "def _loadfilepath ( self , filepath , * * kwargs ) : with open ( filepath , \"r\" ) as f : data = json . load ( f , * * kwargs ) return data", "docstring_tokens": "This loads a geojson file into a geojson python dictionary using the json module . Note : to load with a different text encoding use the encoding argument .", "label": 0}, {"idx": "cosqa-train-1703", "doc": "read json from web with python", "code": "def get(url):\n    \"\"\"Recieving the JSON file from uulm\"\"\"\n    response = urllib.request.urlopen(url)\n    data = response.read()\n    data = data.decode(\"utf-8\")\n    data = json.loads(data)\n    return data", "code_tokens": "def get ( url ) : response = urllib . request . urlopen ( url ) data = response . read ( ) data = data . decode ( \"utf-8\" ) data = json . loads ( data ) return data", "docstring_tokens": "Recieving the JSON file from uulm", "label": 0}, {"idx": "cosqa-train-1704", "doc": "open modelica generate python", "code": "def cli(yamlfile, root, format):\n    \"\"\" Generate CSV/TSV file from biolink model \"\"\"\n    print(CsvGenerator(yamlfile, format).serialize(classes=root))", "code_tokens": "def cli ( yamlfile , root , format ) : print ( CsvGenerator ( yamlfile , format ) . serialize ( classes = root ) )", "docstring_tokens": "Generate CSV / TSV file from biolink model", "label": 0}, {"idx": "cosqa-train-1705", "doc": "read username and password from a file python3", "code": "def read_credentials(fname):\n    \"\"\"\n    read a simple text file from a private location to get\n    username and password\n    \"\"\"\n    with open(fname, 'r') as f:\n        username = f.readline().strip('\\n')\n        password = f.readline().strip('\\n')\n    return username, password", "code_tokens": "def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\\n' ) password = f . readline ( ) . strip ( '\\n' ) return username , password", "docstring_tokens": "read a simple text file from a private location to get username and password", "label": 0}, {"idx": "cosqa-train-1706", "doc": "open pdf specific size python", "code": "def dimensions(path):\n    \"\"\"Get width and height of a PDF\"\"\"\n    pdf = PdfFileReader(path)\n    size = pdf.getPage(0).mediaBox\n    return {'w': float(size[2]), 'h': float(size[3])}", "code_tokens": "def dimensions ( path ) : pdf = PdfFileReader ( path ) size = pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "docstring_tokens": "Get width and height of a PDF", "label": 1}, {"idx": "cosqa-train-1707", "doc": "reading an api into python", "code": "def list_apis(awsclient):\n    \"\"\"List APIs in account.\"\"\"\n    client_api = awsclient.get_client('apigateway')\n\n    apis = client_api.get_rest_apis()['items']\n\n    for api in apis:\n        print(json2table(api))", "code_tokens": "def list_apis ( awsclient ) : client_api = awsclient . get_client ( 'apigateway' ) apis = client_api . get_rest_apis ( ) [ 'items' ] for api in apis : print ( json2table ( api ) )", "docstring_tokens": "List APIs in account .", "label": 1}, {"idx": "cosqa-train-1708", "doc": "open syntax python with variables as filename", "code": "def execfile(fname, variables):\n    \"\"\" This is builtin in python2, but we have to roll our own on py3. \"\"\"\n    with open(fname) as f:\n        code = compile(f.read(), fname, 'exec')\n        exec(code, variables)", "code_tokens": "def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )", "docstring_tokens": "This is builtin in python2 but we have to roll our own on py3 .", "label": 0}, {"idx": "cosqa-train-1709", "doc": "reading compiled code in python", "code": "def get_code(module):\n    \"\"\"\n    Compile and return a Module's code object.\n    \"\"\"\n    fp = open(module.path)\n    try:\n        return compile(fp.read(), str(module.name), 'exec')\n    finally:\n        fp.close()", "code_tokens": "def get_code ( module ) : fp = open ( module . path ) try : return compile ( fp . read ( ) , str ( module . name ) , 'exec' ) finally : fp . close ( )", "docstring_tokens": "Compile and return a Module s code object .", "label": 1}, {"idx": "cosqa-train-1710", "doc": "opening a file with certain owner/permissions python", "code": "def fopenat(base_fd, path):\n    \"\"\"\n    Does openat read-only, then does fdopen to get a file object\n    \"\"\"\n\n    return os.fdopen(openat(base_fd, path, os.O_RDONLY), 'rb')", "code_tokens": "def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )", "docstring_tokens": "Does openat read - only then does fdopen to get a file object", "label": 0}, {"idx": "cosqa-train-1711", "doc": "recursive inser binary tree nodes python", "code": "def aux_insertTree(childTree, parentTree):\n\t\"\"\"This a private (You shouldn't have to call it) recursive function that inserts a child tree into a parent tree.\"\"\"\n\tif childTree.x1 != None and childTree.x2 != None :\n\t\tparentTree.insert(childTree.x1, childTree.x2, childTree.name, childTree.referedObject)\n\n\tfor c in childTree.children:\n\t\taux_insertTree(c, parentTree)", "code_tokens": "def aux_insertTree ( childTree , parentTree ) : if childTree . x1 != None and childTree . x2 != None : parentTree . insert ( childTree . x1 , childTree . x2 , childTree . name , childTree . referedObject ) for c in childTree . children : aux_insertTree ( c , parentTree )", "docstring_tokens": "This a private ( You shouldn t have to call it ) recursive function that inserts a child tree into a parent tree .", "label": 0}, {"idx": "cosqa-train-1712", "doc": "opening serial port in python", "code": "def do_serial(self, p):\n\t\t\"\"\"Set the serial port, e.g.: /dev/tty.usbserial-A4001ib8\"\"\"\n\t\ttry:\n\t\t\tself.serial.port = p\n\t\t\tself.serial.open()\n\t\t\tprint 'Opening serial port: %s' % p\n\t\texcept Exception, e:\n\t\t\tprint 'Unable to open serial port: %s' % p", "code_tokens": "def do_serial ( self , p ) : try : self . serial . port = p self . serial . open ( ) print 'Opening serial port: %s' % p except Exception , e : print 'Unable to open serial port: %s' % p", "docstring_tokens": "Set the serial port e . g . : / dev / tty . usbserial - A4001ib8", "label": 0}, {"idx": "cosqa-train-1713", "doc": "recursively flatten list python3", "code": "def flat_list(lst):\n    \"\"\"This function flatten given nested list.\n    Argument:\n        nested list\n    Returns:\n        flat list\n    \"\"\"\n    if isinstance(lst, list):\n        for item in lst:\n            for i in flat_list(item):\n                yield i\n    else:\n        yield lst", "code_tokens": "def flat_list ( lst ) : if isinstance ( lst , list ) : for item in lst : for i in flat_list ( item ) : yield i else : yield lst", "docstring_tokens": "This function flatten given nested list . Argument : nested list Returns : flat list", "label": 0}, {"idx": "cosqa-train-1714", "doc": "order of elements in each subset python", "code": "def get_feature_order(dataset, features):\n    \"\"\" Returns a list with the order that features requested appear in\n    dataset \"\"\"\n    all_features = dataset.get_feature_names()\n\n    i = [all_features.index(f) for f in features]\n\n    return i", "code_tokens": "def get_feature_order ( dataset , features ) : all_features = dataset . get_feature_names ( ) i = [ all_features . index ( f ) for f in features ] return i", "docstring_tokens": "Returns a list with the order that features requested appear in dataset", "label": 0}, {"idx": "cosqa-train-1715", "doc": "recussion solution show all permutations python", "code": "def circ_permutation(items):\n    \"\"\"Calculate the circular permutation for a given list of items.\"\"\"\n    permutations = []\n    for i in range(len(items)):\n        permutations.append(items[i:] + items[:i])\n    return permutations", "code_tokens": "def circ_permutation ( items ) : permutations = [ ] for i in range ( len ( items ) ) : permutations . append ( items [ i : ] + items [ : i ] ) return permutations", "docstring_tokens": "Calculate the circular permutation for a given list of items .", "label": 0}, {"idx": "cosqa-train-1716", "doc": "outputting lists into tables python", "code": "def _format_list(result):\n    \"\"\"Format list responses into a table.\"\"\"\n\n    if not result:\n        return result\n\n    if isinstance(result[0], dict):\n        return _format_list_objects(result)\n\n    table = Table(['value'])\n    for item in result:\n        table.add_row([iter_to_table(item)])\n    return table", "code_tokens": "def _format_list ( result ) : if not result : return result if isinstance ( result [ 0 ] , dict ) : return _format_list_objects ( result ) table = Table ( [ 'value' ] ) for item in result : table . add_row ( [ iter_to_table ( item ) ] ) return table", "docstring_tokens": "Format list responses into a table .", "label": 0}, {"idx": "cosqa-train-1717", "doc": "redirect without refresh python flask", "code": "def redirect(view=None, url=None, **kwargs):\n    \"\"\"Redirects to the specified view or url\n    \"\"\"\n    if view:\n        if url:\n            kwargs[\"url\"] = url\n        url = flask.url_for(view, **kwargs)\n    current_context.exit(flask.redirect(url))", "code_tokens": "def redirect ( view = None , url = None , * * kwargs ) : if view : if url : kwargs [ \"url\" ] = url url = flask . url_for ( view , * * kwargs ) current_context . exit ( flask . redirect ( url ) )", "docstring_tokens": "Redirects to the specified view or url", "label": 0}, {"idx": "cosqa-train-1718", "doc": "pad ones using python", "code": "def zero_pad(m, n=1):\n    \"\"\"Pad a matrix with zeros, on all sides.\"\"\"\n    return np.pad(m, (n, n), mode='constant', constant_values=[0])", "code_tokens": "def zero_pad ( m , n = 1 ) : return np . pad ( m , ( n , n ) , mode = 'constant' , constant_values = [ 0 ] )", "docstring_tokens": "Pad a matrix with zeros on all sides .", "label": 0}, {"idx": "cosqa-train-1719", "doc": "redis get multiple keys with python", "code": "def get(self, key):  \n        \"\"\" get a set of keys from redis \"\"\"\n        res = self.connection.get(key)\n        print(res)\n        return res", "code_tokens": "def get ( self , key ) : res = self . connection . get ( key ) print ( res ) return res", "docstring_tokens": "get a set of keys from redis", "label": 0}, {"idx": "cosqa-train-1720", "doc": "reduce multiple space to one python", "code": "def format_screen(strng):\n    \"\"\"Format a string for screen printing.\n\n    This removes some latex-type format codes.\"\"\"\n    # Paragraph continue\n    par_re = re.compile(r'\\\\$',re.MULTILINE)\n    strng = par_re.sub('',strng)\n    return strng", "code_tokens": "def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng", "docstring_tokens": "Format a string for screen printing .", "label": 0}, {"idx": "cosqa-train-1721", "doc": "padding code for python", "code": "def old_pad(s):\n    \"\"\"\n    Pads an input string to a given block size.\n    :param s: string\n    :returns: The padded string.\n    \"\"\"\n    if len(s) % OLD_BLOCK_SIZE == 0:\n        return s\n\n    return Padding.appendPadding(s, blocksize=OLD_BLOCK_SIZE)", "code_tokens": "def old_pad ( s ) : if len ( s ) % OLD_BLOCK_SIZE == 0 : return s return Padding . appendPadding ( s , blocksize = OLD_BLOCK_SIZE )", "docstring_tokens": "Pads an input string to a given block size . : param s : string : returns : The padded string .", "label": 1}, {"idx": "cosqa-train-1722", "doc": "refer to project directory in python", "code": "def path(self):\n        \"\"\"Return the project path (aka project root)\n\n        If ``package.__file__`` is ``/foo/foo/__init__.py``, then project.path\n        should be ``/foo``.\n        \"\"\"\n        return pathlib.Path(self.package.__file__).resolve().parent.parent", "code_tokens": "def path ( self ) : return pathlib . Path ( self . package . __file__ ) . resolve ( ) . parent . parent", "docstring_tokens": "Return the project path ( aka project root )", "label": 0}, {"idx": "cosqa-train-1723", "doc": "panda python how to get maximum value of a column", "code": "def get_max(qs, field):\n    \"\"\"\n    get max for queryset.\n\n    qs: queryset\n    field: The field name to max.\n    \"\"\"\n    max_field = '%s__max' % field\n    num = qs.aggregate(Max(field))[max_field]\n    return num if num else 0", "code_tokens": "def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0", "docstring_tokens": "get max for queryset .", "label": 0}, {"idx": "cosqa-train-1724", "doc": "regex contains only letters and numbers with underscore python", "code": "def case_us2mc(x):\n    \"\"\" underscore to mixed case notation \"\"\"\n    return re.sub(r'_([a-z])', lambda m: (m.group(1).upper()), x)", "code_tokens": "def case_us2mc ( x ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , x )", "docstring_tokens": "underscore to mixed case notation", "label": 0}, {"idx": "cosqa-train-1725", "doc": "paramiko python + remove remote file", "code": "def remove(self, path):\n        \"\"\"Remove remote file\n        Return:\n            bool: true or false\"\"\"\n        p = self.cmd('shell', 'rm', path)\n        stdout, stderr = p.communicate()\n        if stdout or stderr:\n            return False\n        else:\n            return True", "code_tokens": "def remove ( self , path ) : p = self . cmd ( 'shell' , 'rm' , path ) stdout , stderr = p . communicate ( ) if stdout or stderr : return False else : return True", "docstring_tokens": "Remove remote file Return : bool : true or false", "label": 0}, {"idx": "cosqa-train-1726", "doc": "regex python check symbol at end of line", "code": "def endline_semicolon_check(self, original, loc, tokens):\n        \"\"\"Check for semicolons at the end of lines.\"\"\"\n        return self.check_strict(\"semicolon at end of line\", original, loc, tokens)", "code_tokens": "def endline_semicolon_check ( self , original , loc , tokens ) : return self . check_strict ( \"semicolon at end of line\" , original , loc , tokens )", "docstring_tokens": "Check for semicolons at the end of lines .", "label": 0}, {"idx": "cosqa-train-1727", "doc": "parsing custom log files with python", "code": "def parse(self):\n        \"\"\"\n        Parse file specified by constructor.\n        \"\"\"\n        f = open(self.parse_log_path, \"r\")\n        self.parse2(f)\n        f.close()", "code_tokens": "def parse ( self ) : f = open ( self . parse_log_path , \"r\" ) self . parse2 ( f ) f . close ( )", "docstring_tokens": "Parse file specified by constructor .", "label": 0}, {"idx": "cosqa-train-1728", "doc": "relative path names python", "code": "def get_absolute_path(*args):\n    \"\"\"Transform relative pathnames into absolute pathnames.\"\"\"\n    directory = os.path.dirname(os.path.abspath(__file__))\n    return os.path.join(directory, *args)", "code_tokens": "def get_absolute_path ( * args ) : directory = os . path . dirname ( os . path . abspath ( __file__ ) ) return os . path . join ( directory , * args )", "docstring_tokens": "Transform relative pathnames into absolute pathnames .", "label": 0}, {"idx": "cosqa-train-1729", "doc": "parsing oder dict in python", "code": "def parse_obj(o):\n    \"\"\"\n    Parses a given dictionary with the key being the OBD PID and the value its\n    returned value by the OBD interface\n    :param dict o:\n    :return:\n    \"\"\"\n    r = {}\n    for k, v in o.items():\n        if is_unable_to_connect(v):\n            r[k] = None\n\n        try:\n            r[k] = parse_value(k, v)\n        except (ObdPidParserUnknownError, AttributeError, TypeError):\n            r[k] = None\n    return r", "code_tokens": "def parse_obj ( o ) : r = { } for k , v in o . items ( ) : if is_unable_to_connect ( v ) : r [ k ] = None try : r [ k ] = parse_value ( k , v ) except ( ObdPidParserUnknownError , AttributeError , TypeError ) : r [ k ] = None return r", "docstring_tokens": "Parses a given dictionary with the key being the OBD PID and the value its returned value by the OBD interface : param dict o : : return :", "label": 0}, {"idx": "cosqa-train-1730", "doc": "remove all duplicates elements from a list python and keep only unique elements", "code": "def remove_list_duplicates(lista, unique=False):\n    \"\"\"\n    Remove duplicated elements in a list.\n    Args:\n        lista: List with elements to clean duplicates.\n    \"\"\"\n    result = []\n    allready = []\n\n    for elem in lista:\n        if elem not in result:\n            result.append(elem)\n        else:\n            allready.append(elem)\n\n    if unique:\n        for elem in allready:\n            result = list(filter((elem).__ne__, result))\n\n    return result", "code_tokens": "def remove_list_duplicates ( lista , unique = False ) : result = [ ] allready = [ ] for elem in lista : if elem not in result : result . append ( elem ) else : allready . append ( elem ) if unique : for elem in allready : result = list ( filter ( ( elem ) . __ne__ , result ) ) return result", "docstring_tokens": "Remove duplicated elements in a list . Args : lista : List with elements to clean duplicates .", "label": 0}, {"idx": "cosqa-train-1731", "doc": "pass none as default value in python or use defualt value", "code": "def arg_default(*args, **kwargs):\n    \"\"\"Return default argument value as given by argparse's add_argument().\n\n    The argument is passed through a mocked-up argument parser. This way, we\n    get default parameters even if the feature is called directly and not\n    through the CLI.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(*args, **kwargs)\n    args = vars(parser.parse_args([]))\n    _, default = args.popitem()\n    return default", "code_tokens": "def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default", "docstring_tokens": "Return default argument value as given by argparse s add_argument () .", "label": 0}, {"idx": "cosqa-train-1732", "doc": "remove all spaces in strings python", "code": "def unaccentuate(s):\n    \"\"\" Replace accentuated chars in string by their non accentuated equivalent. \"\"\"\n    return \"\".join(c for c in unicodedata.normalize(\"NFKD\", s) if not unicodedata.combining(c))", "code_tokens": "def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "docstring_tokens": "Replace accentuated chars in string by their non accentuated equivalent .", "label": 0}, {"idx": "cosqa-train-1733", "doc": "passing function as parametr python", "code": "def def_linear(fun):\n    \"\"\"Flags that a function is linear wrt all args\"\"\"\n    defjvp_argnum(fun, lambda argnum, g, ans, args, kwargs:\n                  fun(*subval(args, argnum, g), **kwargs))", "code_tokens": "def def_linear ( fun ) : defjvp_argnum ( fun , lambda argnum , g , ans , args , kwargs : fun ( * subval ( args , argnum , g ) , * * kwargs ) )", "docstring_tokens": "Flags that a function is linear wrt all args", "label": 0}, {"idx": "cosqa-train-1734", "doc": "remove arguement from arg parser python", "code": "def add_to_parser(self, parser):\n        \"\"\"\n        Adds the argument to an argparse.ArgumentParser instance\n\n        @param parser An argparse.ArgumentParser instance\n        \"\"\"\n        kwargs = self._get_kwargs()\n        args = self._get_args()\n        parser.add_argument(*args, **kwargs)", "code_tokens": "def add_to_parser ( self , parser ) : kwargs = self . _get_kwargs ( ) args = self . _get_args ( ) parser . add_argument ( * args , * * kwargs )", "docstring_tokens": "Adds the argument to an argparse . ArgumentParser instance", "label": 0}, {"idx": "cosqa-train-1735", "doc": "pick random from set python", "code": "def random_choice(sequence):\n    \"\"\" Same as :meth:`random.choice`, but also supports :class:`set` type to be passed as sequence. \"\"\"\n    return random.choice(tuple(sequence) if isinstance(sequence, set) else sequence)", "code_tokens": "def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )", "docstring_tokens": "Same as : meth : random . choice but also supports : class : set type to be passed as sequence .", "label": 0}, {"idx": "cosqa-train-1736", "doc": "remove backslash last char from string python", "code": "def unescape(str):\n    \"\"\"Undoes the effects of the escape() function.\"\"\"\n    out = ''\n    prev_backslash = False\n    for char in str:\n        if not prev_backslash and char == '\\\\':\n            prev_backslash = True\n            continue\n        out += char\n        prev_backslash = False\n    return out", "code_tokens": "def unescape ( str ) : out = '' prev_backslash = False for char in str : if not prev_backslash and char == '\\\\' : prev_backslash = True continue out += char prev_backslash = False return out", "docstring_tokens": "Undoes the effects of the escape () function .", "label": 0}, {"idx": "cosqa-train-1737", "doc": "pil python image flip vertically", "code": "def hflip(img):\n    \"\"\"Horizontally flip the given PIL Image.\n\n    Args:\n        img (PIL Image): Image to be flipped.\n\n    Returns:\n        PIL Image:  Horizontall flipped image.\n    \"\"\"\n    if not _is_pil_image(img):\n        raise TypeError('img should be PIL Image. Got {}'.format(type(img)))\n\n    return img.transpose(Image.FLIP_LEFT_RIGHT)", "code_tokens": "def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )", "docstring_tokens": "Horizontally flip the given PIL Image .", "label": 0}, {"idx": "cosqa-train-1738", "doc": "remove character type columns from dataset using python", "code": "def strip_columns(tab):\n    \"\"\"Strip whitespace from string columns.\"\"\"\n    for colname in tab.colnames:\n        if tab[colname].dtype.kind in ['S', 'U']:\n            tab[colname] = np.core.defchararray.strip(tab[colname])", "code_tokens": "def strip_columns ( tab ) : for colname in tab . colnames : if tab [ colname ] . dtype . kind in [ 'S' , 'U' ] : tab [ colname ] = np . core . defchararray . strip ( tab [ colname ] )", "docstring_tokens": "Strip whitespace from string columns .", "label": 0}, {"idx": "cosqa-train-1739", "doc": "place sql query into dictionary python", "code": "def export_all(self):\n\t\tquery = \"\"\"\n\t\t\tSELECT quote, library, logid\n\t\t\tfrom quotes\n\t\t\tleft outer join quote_log on quotes.quoteid = quote_log.quoteid\n\t\t\t\"\"\"\n\t\tfields = 'text', 'library', 'log_id'\n\t\treturn (dict(zip(fields, res)) for res in self.db.execute(query))", "code_tokens": "def export_all ( self ) : query = \"\"\"\n\t\t\tSELECT quote, library, logid\n\t\t\tfrom quotes\n\t\t\tleft outer join quote_log on quotes.quoteid = quote_log.quoteid\n\t\t\t\"\"\" fields = 'text' , 'library' , 'log_id' return ( dict ( zip ( fields , res ) ) for res in self . db . execute ( query ) )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-1740", "doc": "remove comma from string in python 3", "code": "def seq_to_str(obj, sep=\",\"):\n    \"\"\"\n    Given a sequence convert it to a comma separated string.\n    If, however, the argument is a single object, return its string\n    representation.\n    \"\"\"\n    if isinstance(obj, string_classes):\n        return obj\n    elif isinstance(obj, (list, tuple)):\n        return sep.join([str(x) for x in obj])\n    else:\n        return str(obj)", "code_tokens": "def seq_to_str ( obj , sep = \",\" ) : if isinstance ( obj , string_classes ) : return obj elif isinstance ( obj , ( list , tuple ) ) : return sep . join ( [ str ( x ) for x in obj ] ) else : return str ( obj )", "docstring_tokens": "Given a sequence convert it to a comma separated string . If however the argument is a single object return its string representation .", "label": 0}, {"idx": "cosqa-train-1741", "doc": "plot precision recall curve in python matplotlib", "code": "def _precision_recall(y_true, y_score, ax=None):\n    \"\"\"\n    Plot precision-recall curve.\n\n    Parameters\n    ----------\n    y_true : array-like, shape = [n_samples]\n        Correct target values (ground truth).\n    y_score : array-like, shape = [n_samples]\n        Target scores (estimator predictions).\n    ax : matplotlib Axes\n        Axes object to draw the plot onto, otherwise uses current Axes\n\n    Returns\n    -------\n    ax: matplotlib Axes\n        Axes containing the plot\n\n    \"\"\"\n    precision, recall, _ = precision_recall_curve(y_true, y_score)\n    average_precision = average_precision_score(y_true, y_score)\n\n    if ax is None:\n        ax = plt.gca()\n\n    ax.plot(recall, precision, label=('Precision-Recall curve: AUC={0:0.2f}'\n                                      .format(average_precision)))\n    _set_ax_settings(ax)\n    return ax", "code_tokens": "def _precision_recall ( y_true , y_score , ax = None ) : precision , recall , _ = precision_recall_curve ( y_true , y_score ) average_precision = average_precision_score ( y_true , y_score ) if ax is None : ax = plt . gca ( ) ax . plot ( recall , precision , label = ( 'Precision-Recall curve: AUC={0:0.2f}' . format ( average_precision ) ) ) _set_ax_settings ( ax ) return ax", "docstring_tokens": "Plot precision - recall curve .", "label": 0}, {"idx": "cosqa-train-1742", "doc": "remove duplicate elements in list preserve order python", "code": "def dedup_list(l):\n    \"\"\"Given a list (l) will removing duplicates from the list,\n       preserving the original order of the list. Assumes that\n       the list entrie are hashable.\"\"\"\n    dedup = set()\n    return [ x for x in l if not (x in dedup or dedup.add(x))]", "code_tokens": "def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]", "docstring_tokens": "Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable .", "label": 0}, {"idx": "cosqa-train-1743", "doc": "points from a set of coordinates in python", "code": "def get_lons_from_cartesian(x__, y__):\n    \"\"\"Get longitudes from cartesian coordinates.\n    \"\"\"\n    return rad2deg(arccos(x__ / sqrt(x__ ** 2 + y__ ** 2))) * sign(y__)", "code_tokens": "def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )", "docstring_tokens": "Get longitudes from cartesian coordinates .", "label": 0}, {"idx": "cosqa-train-1744", "doc": "remove duplicates from a sequence python", "code": "def remove_dups(seq):\n    \"\"\"remove duplicates from a sequence, preserving order\"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "remove duplicates from a sequence preserving order", "label": 0}, {"idx": "cosqa-train-1745", "doc": "prettytable rename column python", "code": "def format_prettytable(table):\n    \"\"\"Converts SoftLayer.CLI.formatting.Table instance to a prettytable.\"\"\"\n    for i, row in enumerate(table.rows):\n        for j, item in enumerate(row):\n            table.rows[i][j] = format_output(item)\n\n    ptable = table.prettytable()\n    ptable.hrules = prettytable.FRAME\n    ptable.horizontal_char = '.'\n    ptable.vertical_char = ':'\n    ptable.junction_char = ':'\n    return ptable", "code_tokens": "def format_prettytable ( table ) : for i , row in enumerate ( table . rows ) : for j , item in enumerate ( row ) : table . rows [ i ] [ j ] = format_output ( item ) ptable = table . prettytable ( ) ptable . hrules = prettytable . FRAME ptable . horizontal_char = '.' ptable . vertical_char = ':' ptable . junction_char = ':' return ptable", "docstring_tokens": "Converts SoftLayer . CLI . formatting . Table instance to a prettytable .", "label": 1}, {"idx": "cosqa-train-1746", "doc": "remove invalid xml characters python", "code": "def _RemoveIllegalXMLCharacters(self, xml_string):\n    \"\"\"Removes illegal characters for XML.\n\n    If the input is not a string it will be returned unchanged.\n\n    Args:\n      xml_string (str): XML with possible illegal characters.\n\n    Returns:\n      str: XML where all illegal characters have been removed.\n    \"\"\"\n    if not isinstance(xml_string, py2to3.STRING_TYPES):\n      return xml_string\n\n    return self._ILLEGAL_XML_RE.sub('\\ufffd', xml_string)", "code_tokens": "def _RemoveIllegalXMLCharacters ( self , xml_string ) : if not isinstance ( xml_string , py2to3 . STRING_TYPES ) : return xml_string return self . _ILLEGAL_XML_RE . sub ( '\\ufffd' , xml_string )", "docstring_tokens": "Removes illegal characters for XML .", "label": 0}, {"idx": "cosqa-train-1747", "doc": "print duration per hour between start time and end time in python", "code": "def timespan(start_time):\n    \"\"\"Return time in milliseconds from start_time\"\"\"\n\n    timespan = datetime.datetime.now() - start_time\n    timespan_ms = timespan.total_seconds() * 1000\n    return timespan_ms", "code_tokens": "def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms", "docstring_tokens": "Return time in milliseconds from start_time", "label": 0}, {"idx": "cosqa-train-1748", "doc": "remove items in a python dictionary", "code": "def _remove_dict_keys_with_value(dict_, val):\n  \"\"\"Removes `dict` keys which have have `self` as value.\"\"\"\n  return {k: v for k, v in dict_.items() if v is not val}", "code_tokens": "def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }", "docstring_tokens": "Removes dict keys which have have self as value .", "label": 0}, {"idx": "cosqa-train-1749", "doc": "print function in python logging", "code": "def pylog(self, *args, **kwargs):\n        \"\"\"Display all available logging information.\"\"\"\n        printerr(self.name, args, kwargs, traceback.format_exc())", "code_tokens": "def pylog ( self , * args , * * kwargs ) : printerr ( self . name , args , kwargs , traceback . format_exc ( ) )", "docstring_tokens": "Display all available logging information .", "label": 0}, {"idx": "cosqa-train-1750", "doc": "remove letter other than english letters python", "code": "def strip_accents(s):\n    \"\"\"\n    Strip accents to prepare for slugification.\n    \"\"\"\n    nfkd = unicodedata.normalize('NFKD', unicode(s))\n    return u''.join(ch for ch in nfkd if not unicodedata.combining(ch))", "code_tokens": "def strip_accents ( s ) : nfkd = unicodedata . normalize ( 'NFKD' , unicode ( s ) ) return u'' . join ( ch for ch in nfkd if not unicodedata . combining ( ch ) )", "docstring_tokens": "Strip accents to prepare for slugification .", "label": 0}, {"idx": "cosqa-train-1751", "doc": "print many spaces in format python", "code": "def indented_show(text, howmany=1):\n        \"\"\"Print a formatted indented text.\n        \"\"\"\n        print(StrTemplate.pad_indent(text=text, howmany=howmany))", "code_tokens": "def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )", "docstring_tokens": "Print a formatted indented text .", "label": 0}, {"idx": "cosqa-train-1752", "doc": "remove punctuation from python key", "code": "def key_to_metric(self, key):\n        \"\"\"Replace all non-letter characters with underscores\"\"\"\n        return ''.join(l if l in string.letters else '_' for l in key)", "code_tokens": "def key_to_metric ( self , key ) : return '' . join ( l if l in string . letters else '_' for l in key )", "docstring_tokens": "Replace all non - letter characters with underscores", "label": 0}, {"idx": "cosqa-train-1753", "doc": "print ram memory in python", "code": "def get_ram(self, format_ = \"nl\"):\n\t\t\"\"\"\n\t\t\treturn a string representations of the ram\n\t\t\"\"\"\n\t\tram = [self.ram.read(i) for i in range(self.ram.size)]\n\t\treturn self._format_mem(ram, format_)", "code_tokens": "def get_ram ( self , format_ = \"nl\" ) : ram = [ self . ram . read ( i ) for i in range ( self . ram . size ) ] return self . _format_mem ( ram , format_ )", "docstring_tokens": "return a string representations of the ram", "label": 0}, {"idx": "cosqa-train-1754", "doc": "remove query from url python", "code": "def strip_querystring(url):\n    \"\"\"Remove the querystring from the end of a URL.\"\"\"\n    p = six.moves.urllib.parse.urlparse(url)\n    return p.scheme + \"://\" + p.netloc + p.path", "code_tokens": "def strip_querystring ( url ) : p = six . moves . urllib . parse . urlparse ( url ) return p . scheme + \"://\" + p . netloc + p . path", "docstring_tokens": "Remove the querystring from the end of a URL .", "label": 0}, {"idx": "cosqa-train-1755", "doc": "print the type of a varible python", "code": "def getTypeStr(_type):\n  r\"\"\"Gets the string representation of the given type.\n  \"\"\"\n  if isinstance(_type, CustomType):\n    return str(_type)\n\n  if hasattr(_type, '__name__'):\n    return _type.__name__\n\n  return ''", "code_tokens": "def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''", "docstring_tokens": "r Gets the string representation of the given type .", "label": 0}, {"idx": "cosqa-train-1756", "doc": "remove repeated entries in list python", "code": "def dedupe_list(seq):\n    \"\"\"\n    Utility function to remove duplicates from a list\n    :param seq: The sequence (list) to deduplicate\n    :return: A list with original duplicates removed\n    \"\"\"\n    seen = set()\n    return [x for x in seq if not (x in seen or seen.add(x))]", "code_tokens": "def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed", "label": 0}, {"idx": "cosqa-train-1757", "doc": "print used cuda device in python", "code": "async def sysinfo(dev: Device):\n    \"\"\"Print out system information (version, MAC addrs).\"\"\"\n    click.echo(await dev.get_system_info())\n    click.echo(await dev.get_interface_information())", "code_tokens": "async def sysinfo ( dev : Device ) : click . echo ( await dev . get_system_info ( ) ) click . echo ( await dev . get_interface_information ( ) )", "docstring_tokens": "Print out system information ( version MAC addrs ) .", "label": 0}, {"idx": "cosqa-train-1758", "doc": "remove series object from list python", "code": "def remove_series(self, series):\n        \"\"\"Removes a :py:class:`.Series` from the chart.\n\n        :param Series series: The :py:class:`.Series` to remove.\n        :raises ValueError: if you try to remove the last\\\n        :py:class:`.Series`.\"\"\"\n\n        if len(self.all_series()) == 1:\n            raise ValueError(\"Cannot remove last series from %s\" % str(self))\n        self._all_series.remove(series)\n        series._chart = None", "code_tokens": "def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( \"Cannot remove last series from %s\" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None", "docstring_tokens": "Removes a : py : class : . Series from the chart .", "label": 0}, {"idx": "cosqa-train-1759", "doc": "print without a new line in python", "code": "def _screen(self, s, newline=False):\n        \"\"\"Print something on screen when self.verbose == True\"\"\"\n        if self.verbose:\n            if newline:\n                print(s)\n            else:\n                print(s, end=' ')", "code_tokens": "def _screen ( self , s , newline = False ) : if self . verbose : if newline : print ( s ) else : print ( s , end = ' ' )", "docstring_tokens": "Print something on screen when self . verbose == True", "label": 0}, {"idx": "cosqa-train-1760", "doc": "remove spaces and punctuation python", "code": "def lowstrip(term):\n    \"\"\"Convert to lowercase and strip spaces\"\"\"\n    term = re.sub('\\s+', ' ', term)\n    term = term.lower()\n    return term", "code_tokens": "def lowstrip ( term ) : term = re . sub ( '\\s+' , ' ' , term ) term = term . lower ( ) return term", "docstring_tokens": "Convert to lowercase and strip spaces", "label": 0}, {"idx": "cosqa-train-1761", "doc": "print without new line in python", "code": "def _screen(self, s, newline=False):\n        \"\"\"Print something on screen when self.verbose == True\"\"\"\n        if self.verbose:\n            if newline:\n                print(s)\n            else:\n                print(s, end=' ')", "code_tokens": "def _screen ( self , s , newline = False ) : if self . verbose : if newline : print ( s ) else : print ( s , end = ' ' )", "docstring_tokens": "Print something on screen when self . verbose == True", "label": 0}, {"idx": "cosqa-train-1762", "doc": "remove spaces python string", "code": "def to_str(s):\n    \"\"\"\n    Convert bytes and non-string into Python 3 str\n    \"\"\"\n    if isinstance(s, bytes):\n        s = s.decode('utf-8')\n    elif not isinstance(s, str):\n        s = str(s)\n    return s", "code_tokens": "def to_str ( s ) : if isinstance ( s , bytes ) : s = s . decode ( 'utf-8' ) elif not isinstance ( s , str ) : s = str ( s ) return s", "docstring_tokens": "Convert bytes and non - string into Python 3 str", "label": 0}, {"idx": "cosqa-train-1763", "doc": "printing new line in python using string", "code": "def printOut(value, end='\\n'):\n    \"\"\"\n    This function prints the given String immediately and flushes the output.\n    \"\"\"\n    sys.stdout.write(value)\n    sys.stdout.write(end)\n    sys.stdout.flush()", "code_tokens": "def printOut ( value , end = '\\n' ) : sys . stdout . write ( value ) sys . stdout . write ( end ) sys . stdout . flush ( )", "docstring_tokens": "This function prints the given String immediately and flushes the output .", "label": 0}, {"idx": "cosqa-train-1764", "doc": "remove spacing charactes python", "code": "def normalize_value(text):\n    \"\"\"\n    This removes newlines and multiple spaces from a string.\n    \"\"\"\n    result = text.replace('\\n', ' ')\n    result = re.subn('[ ]{2,}', ' ', result)[0]\n    return result", "code_tokens": "def normalize_value ( text ) : result = text . replace ( '\\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result", "docstring_tokens": "This removes newlines and multiple spaces from a string .", "label": 0}, {"idx": "cosqa-train-1765", "doc": "printing nth occurence of character in string using python", "code": "def IndexOfNth(s, value, n):\n    \"\"\"Gets the index of Nth occurance of a given character in a string\n\n    :param str s:\n        Input string\n    :param char value:\n        Input char to be searched.\n    :param int n:\n        Nth occurrence of char to be searched.\n\n    :return:\n        Index of the Nth occurrence in the string.\n    :rtype: int\n\n    \"\"\"\n    remaining = n\n    for i in xrange(0, len(s)):\n        if s[i] == value:\n            remaining -= 1\n            if remaining == 0:\n                return i\n    return -1", "code_tokens": "def IndexOfNth ( s , value , n ) : remaining = n for i in xrange ( 0 , len ( s ) ) : if s [ i ] == value : remaining -= 1 if remaining == 0 : return i return - 1", "docstring_tokens": "Gets the index of Nth occurance of a given character in a string", "label": 0}, {"idx": "cosqa-train-1766", "doc": "removing a file from a bucket aws s3 python", "code": "def remove_file_from_s3(awsclient, bucket, key):\n    \"\"\"Remove a file from an AWS S3 bucket.\n\n    :param awsclient:\n    :param bucket:\n    :param key:\n    :return:\n    \"\"\"\n    client_s3 = awsclient.get_client('s3')\n    response = client_s3.delete_object(Bucket=bucket, Key=key)", "code_tokens": "def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )", "docstring_tokens": "Remove a file from an AWS S3 bucket .", "label": 0}, {"idx": "cosqa-train-1767", "doc": "printing request headers in python flask", "code": "def get_trace_id_from_flask():\n    \"\"\"Get trace_id from flask request headers.\n\n    :rtype: str\n    :returns: TraceID in HTTP request headers.\n    \"\"\"\n    if flask is None or not flask.request:\n        return None\n\n    header = flask.request.headers.get(_FLASK_TRACE_HEADER)\n\n    if header is None:\n        return None\n\n    trace_id = header.split(\"/\", 1)[0]\n\n    return trace_id", "code_tokens": "def get_trace_id_from_flask ( ) : if flask is None or not flask . request : return None header = flask . request . headers . get ( _FLASK_TRACE_HEADER ) if header is None : return None trace_id = header . split ( \"/\" , 1 ) [ 0 ] return trace_id", "docstring_tokens": "Get trace_id from flask request headers .", "label": 0}, {"idx": "cosqa-train-1768", "doc": "removing duplicate objects from list in python", "code": "def dedup_list(l):\n    \"\"\"Given a list (l) will removing duplicates from the list,\n       preserving the original order of the list. Assumes that\n       the list entrie are hashable.\"\"\"\n    dedup = set()\n    return [ x for x in l if not (x in dedup or dedup.add(x))]", "code_tokens": "def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]", "docstring_tokens": "Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable .", "label": 0}, {"idx": "cosqa-train-1769", "doc": "psutil python get total ram", "code": "def current_memory_usage():\n    \"\"\"\n    Returns this programs current memory usage in bytes\n    \"\"\"\n    import psutil\n    proc = psutil.Process(os.getpid())\n    #meminfo = proc.get_memory_info()\n    meminfo = proc.memory_info()\n    rss = meminfo[0]  # Resident Set Size / Mem Usage\n    vms = meminfo[1]  # Virtual Memory Size / VM Size  # NOQA\n    return rss", "code_tokens": "def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss", "docstring_tokens": "Returns this programs current memory usage in bytes", "label": 0}, {"idx": "cosqa-train-1770", "doc": "reorder multiple rows as a column index in python", "code": "def _idx_col2rowm(d):\n    \"\"\"Generate indexes to change from col-major to row-major ordering\"\"\"\n    if 0 == len(d):\n        return 1\n    if 1 == len(d):\n        return np.arange(d[0])\n    # order='F' indicates column-major ordering\n    idx = np.array(np.arange(np.prod(d))).reshape(d, order='F').T\n    return idx.flatten(order='F')", "code_tokens": "def _idx_col2rowm ( d ) : if 0 == len ( d ) : return 1 if 1 == len ( d ) : return np . arange ( d [ 0 ] ) # order='F' indicates column-major ordering idx = np . array ( np . arange ( np . prod ( d ) ) ) . reshape ( d , order = 'F' ) . T return idx . flatten ( order = 'F' )", "docstring_tokens": "Generate indexes to change from col - major to row - major ordering", "label": 0}, {"idx": "cosqa-train-1771", "doc": "psutil python memory variable", "code": "def get_memory_usage():\n    \"\"\"Gets RAM memory usage\n\n    :return: MB of memory used by this process\n    \"\"\"\n    process = psutil.Process(os.getpid())\n    mem = process.memory_info().rss\n    return mem / (1024 * 1024)", "code_tokens": "def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )", "docstring_tokens": "Gets RAM memory usage", "label": 0}, {"idx": "cosqa-train-1772", "doc": "replace a word in a string using start and end index python", "code": "def _replace_token_range(tokens, start, end, replacement):\n    \"\"\"For a range indicated from start to end, replace with replacement.\"\"\"\n    tokens = tokens[:start] + replacement + tokens[end:]\n    return tokens", "code_tokens": "def _replace_token_range ( tokens , start , end , replacement ) : tokens = tokens [ : start ] + replacement + tokens [ end : ] return tokens", "docstring_tokens": "For a range indicated from start to end replace with replacement .", "label": 1}, {"idx": "cosqa-train-1773", "doc": "put stdout of another method into a variable in python", "code": "def print_out(self, *lst):\n      \"\"\" Print list of strings to the predefined stdout. \"\"\"\n      self.print2file(self.stdout, True, True, *lst)", "code_tokens": "def print_out ( self , * lst ) : self . print2file ( self . stdout , True , True , * lst )", "docstring_tokens": "Print list of strings to the predefined stdout .", "label": 0}, {"idx": "cosqa-train-1774", "doc": "replace nan with none python", "code": "def _replace_nan(a, val):\n    \"\"\"\n    replace nan in a by val, and returns the replaced array and the nan\n    position\n    \"\"\"\n    mask = isnull(a)\n    return where_method(val, mask, a), mask", "code_tokens": "def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask", "docstring_tokens": "replace nan in a by val and returns the replaced array and the nan position", "label": 0}, {"idx": "cosqa-train-1775", "doc": "putting a scraped table into a list python", "code": "def parse(self):\n        \"\"\"Parses data in table\n\n        :return: List of list of values in table\n        \"\"\"\n        data = []  # add name of section\n\n        for row in self.soup.find_all(\"tr\"):  # cycle through all rows\n            parsed = self._parse_row(row)\n            if parsed:\n                data.append(parsed)\n\n        return data", "code_tokens": "def parse ( self ) : data = [ ] # add name of section for row in self . soup . find_all ( \"tr\" ) : # cycle through all rows parsed = self . _parse_row ( row ) if parsed : data . append ( parsed ) return data", "docstring_tokens": "Parses data in table", "label": 0}, {"idx": "cosqa-train-1776", "doc": "replacing string values for specified columns in python data frame", "code": "def stringify_col(df, col_name):\n    \"\"\"\n    Take a dataframe and string-i-fy a column of values.\n    Turn nan/None into \"\" and all other values into strings.\n\n    Parameters\n    ----------\n    df : dataframe\n    col_name : string\n    \"\"\"\n    df = df.copy()\n    df[col_name] = df[col_name].fillna(\"\")\n    df[col_name] = df[col_name].astype(str)\n    return df", "code_tokens": "def stringify_col ( df , col_name ) : df = df . copy ( ) df [ col_name ] = df [ col_name ] . fillna ( \"\" ) df [ col_name ] = df [ col_name ] . astype ( str ) return df", "docstring_tokens": "Take a dataframe and string - i - fy a column of values . Turn nan / None into and all other values into strings .", "label": 0}, {"idx": "cosqa-train-1777", "doc": "python '\\x' plus an int", "code": "def add_0x(string):\n    \"\"\"Add 0x to string at start.\n    \"\"\"\n    if isinstance(string, bytes):\n        string = string.decode('utf-8')\n    return '0x' + str(string)", "code_tokens": "def add_0x ( string ) : if isinstance ( string , bytes ) : string = string . decode ( 'utf-8' ) return '0x' + str ( string )", "docstring_tokens": "Add 0x to string at start .", "label": 0}, {"idx": "cosqa-train-1778", "doc": "python 'deprecationdict' object has no attribute 'mean'", "code": "def warn_deprecated(message, stacklevel=2):  # pragma: no cover\n    \"\"\"Warn deprecated.\"\"\"\n\n    warnings.warn(\n        message,\n        category=DeprecationWarning,\n        stacklevel=stacklevel\n    )", "code_tokens": "def warn_deprecated ( message , stacklevel = 2 ) : # pragma: no cover warnings . warn ( message , category = DeprecationWarning , stacklevel = stacklevel )", "docstring_tokens": "Warn deprecated .", "label": 0}, {"idx": "cosqa-train-1779", "doc": "rescaling a 10bit images to 8bit in python", "code": "def resize_by_area(img, size):\n  \"\"\"image resize function used by quite a few image problems.\"\"\"\n  return tf.to_int64(\n      tf.image.resize_images(img, [size, size], tf.image.ResizeMethod.AREA))", "code_tokens": "def resize_by_area ( img , size ) : return tf . to_int64 ( tf . image . resize_images ( img , [ size , size ] , tf . image . ResizeMethod . AREA ) )", "docstring_tokens": "image resize function used by quite a few image problems .", "label": 0}, {"idx": "cosqa-train-1780", "doc": "python 'point' object is not iterable", "code": "def _get_points(self):\n        \"\"\"\n        Subclasses may override this method.\n        \"\"\"\n        return tuple([self._getitem__points(i)\n                     for i in range(self._len__points())])", "code_tokens": "def _get_points ( self ) : return tuple ( [ self . _getitem__points ( i ) for i in range ( self . _len__points ( ) ) ] )", "docstring_tokens": "Subclasses may override this method .", "label": 0}, {"idx": "cosqa-train-1781", "doc": "reset index multi index python", "code": "def validate_multiindex(self, obj):\n        \"\"\"validate that we can store the multi-index; reset and return the\n        new object\n        \"\"\"\n        levels = [l if l is not None else \"level_{0}\".format(i)\n                  for i, l in enumerate(obj.index.names)]\n        try:\n            return obj.reset_index(), levels\n        except ValueError:\n            raise ValueError(\"duplicate names/columns in the multi-index when \"\n                             \"storing as a table\")", "code_tokens": "def validate_multiindex ( self , obj ) : levels = [ l if l is not None else \"level_{0}\" . format ( i ) for i , l in enumerate ( obj . index . names ) ] try : return obj . reset_index ( ) , levels except ValueError : raise ValueError ( \"duplicate names/columns in the multi-index when \" \"storing as a table\" )", "docstring_tokens": "validate that we can store the multi - index ; reset and return the new object", "label": 0}, {"idx": "cosqa-train-1782", "doc": "python 'print' is not defined", "code": "def raw_print(*args, **kw):\n    \"\"\"Raw print to sys.__stdout__, otherwise identical interface to print().\"\"\"\n\n    print(*args, sep=kw.get('sep', ' '), end=kw.get('end', '\\n'),\n          file=sys.__stdout__)\n    sys.__stdout__.flush()", "code_tokens": "def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )", "docstring_tokens": "Raw print to sys . __stdout__ otherwise identical interface to print () .", "label": 0}, {"idx": "cosqa-train-1783", "doc": "reset index with multi index python", "code": "def validate_multiindex(self, obj):\n        \"\"\"validate that we can store the multi-index; reset and return the\n        new object\n        \"\"\"\n        levels = [l if l is not None else \"level_{0}\".format(i)\n                  for i, l in enumerate(obj.index.names)]\n        try:\n            return obj.reset_index(), levels\n        except ValueError:\n            raise ValueError(\"duplicate names/columns in the multi-index when \"\n                             \"storing as a table\")", "code_tokens": "def validate_multiindex ( self , obj ) : levels = [ l if l is not None else \"level_{0}\" . format ( i ) for i , l in enumerate ( obj . index . names ) ] try : return obj . reset_index ( ) , levels except ValueError : raise ValueError ( \"duplicate names/columns in the multi-index when \" \"storing as a table\" )", "docstring_tokens": "validate that we can store the multi - index ; reset and return the new object", "label": 0}, {"idx": "cosqa-train-1784", "doc": "python 2 tkinter folder chooser", "code": "def popup(self, title, callfn, initialdir=None):\n        \"\"\"Let user select a directory.\"\"\"\n        super(DirectorySelection, self).popup(title, callfn, initialdir)", "code_tokens": "def popup ( self , title , callfn , initialdir = None ) : super ( DirectorySelection , self ) . popup ( title , callfn , initialdir )", "docstring_tokens": "Let user select a directory .", "label": 0}, {"idx": "cosqa-train-1785", "doc": "reshape the images into 2d image python", "code": "def im2mat(I):\n    \"\"\"Converts and image to matrix (one pixel per line)\"\"\"\n    return I.reshape((I.shape[0] * I.shape[1], I.shape[2]))", "code_tokens": "def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )", "docstring_tokens": "Converts and image to matrix ( one pixel per line )", "label": 0}, {"idx": "cosqa-train-1786", "doc": "python 2to3 not found", "code": "def command_py2to3(args):\n    \"\"\"\n    Apply '2to3' tool (Python2 to Python3 conversion tool) to Python sources.\n    \"\"\"\n    from lib2to3.main import main\n    sys.exit(main(\"lib2to3.fixes\", args=args.sources))", "code_tokens": "def command_py2to3 ( args ) : from lib2to3 . main import main sys . exit ( main ( \"lib2to3.fixes\" , args = args . sources ) )", "docstring_tokens": "Apply 2to3 tool ( Python2 to Python3 conversion tool ) to Python sources .", "label": 0}, {"idx": "cosqa-train-1787", "doc": "respone base64 encoding in python3", "code": "def toBase64(s):\n    \"\"\"Represent string / bytes s as base64, omitting newlines\"\"\"\n    if isinstance(s, str):\n        s = s.encode(\"utf-8\")\n    return binascii.b2a_base64(s)[:-1]", "code_tokens": "def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( \"utf-8\" ) return binascii . b2a_base64 ( s ) [ : - 1 ]", "docstring_tokens": "Represent string / bytes s as base64 omitting newlines", "label": 0}, {"idx": "cosqa-train-1788", "doc": "python 3 beautifulsoup4 get page back", "code": "def get_soup(page=''):\n    \"\"\"\n    Returns a bs4 object of the page requested\n    \"\"\"\n    content = requests.get('%s/%s' % (BASE_URL, page)).text\n    return BeautifulSoup(content)", "code_tokens": "def get_soup ( page = '' ) : content = requests . get ( '%s/%s' % ( BASE_URL , page ) ) . text return BeautifulSoup ( content )", "docstring_tokens": "Returns a bs4 object of the page requested", "label": 0}, {"idx": "cosqa-train-1789", "doc": "restrict file modification python", "code": "def make_file_read_only(file_path):\n    \"\"\"\n    Removes the write permissions for the given file for owner, groups and others.\n\n    :param file_path: The file whose privileges are revoked.\n    :raise FileNotFoundError: If the given file does not exist.\n    \"\"\"\n    old_permissions = os.stat(file_path).st_mode\n    os.chmod(file_path, old_permissions & ~WRITE_PERMISSIONS)", "code_tokens": "def make_file_read_only ( file_path ) : old_permissions = os . stat ( file_path ) . st_mode os . chmod ( file_path , old_permissions & ~ WRITE_PERMISSIONS )", "docstring_tokens": "Removes the write permissions for the given file for owner groups and others .", "label": 0}, {"idx": "cosqa-train-1790", "doc": "python 3 bound unbound method", "code": "def __is_bound_method(method):\n    \"\"\"Return ``True`` if the `method` is a bound method (attached to an class\n    instance.\n\n    Args:\n        method: A method or function type object.\n    \"\"\"\n    if not(hasattr(method, \"__func__\") and hasattr(method, \"__self__\")):\n        return False\n\n    # Bound methods have a __self__ attribute pointing to the owner instance\n    return six.get_method_self(method) is not None", "code_tokens": "def __is_bound_method ( method ) : if not ( hasattr ( method , \"__func__\" ) and hasattr ( method , \"__self__\" ) ) : return False # Bound methods have a __self__ attribute pointing to the owner instance return six . get_method_self ( method ) is not None", "docstring_tokens": "Return True if the method is a bound method ( attached to an class instance .", "label": 0}, {"idx": "cosqa-train-1791", "doc": "retrieving column names from sql in python", "code": "def get_column_keys_and_names(table):\n    \"\"\"\n    Return a generator of tuples k, c such that k is the name of the python attribute for\n    the column and c is the name of the column in the sql table.\n    \"\"\"\n    ins = inspect(table)\n    return ((k, c.name) for k, c in ins.mapper.c.items())", "code_tokens": "def get_column_keys_and_names ( table ) : ins = inspect ( table ) return ( ( k , c . name ) for k , c in ins . mapper . c . items ( ) )", "docstring_tokens": "Return a generator of tuples k c such that k is the name of the python attribute for the column and c is the name of the column in the sql table .", "label": 0}, {"idx": "cosqa-train-1792", "doc": "python 3 django url validator", "code": "def clean_url(url):\n        \"\"\"URL Validation function\"\"\"\n        if not url.startswith(('http://', 'https://')):\n            url = f'http://{url}'\n\n        if not URL_RE.match(url):\n            raise BadURLException(f'{url} is not valid')\n\n        return url", "code_tokens": "def clean_url ( url ) : if not url . startswith ( ( 'http://' , 'https://' ) ) : url = f'http://{url}' if not URL_RE . match ( url ) : raise BadURLException ( f'{url} is not valid' ) return url", "docstring_tokens": "URL Validation function", "label": 0}, {"idx": "cosqa-train-1793", "doc": "return a field in python on max condition", "code": "def get_max(qs, field):\n    \"\"\"\n    get max for queryset.\n\n    qs: queryset\n    field: The field name to max.\n    \"\"\"\n    max_field = '%s__max' % field\n    num = qs.aggregate(Max(field))[max_field]\n    return num if num else 0", "code_tokens": "def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0", "docstring_tokens": "get max for queryset .", "label": 0}, {"idx": "cosqa-train-1794", "doc": "python 3 fft and fftshift with fftw", "code": "def stft_magnitude(signal, fft_length,\n                   hop_length=None,\n                   window_length=None):\n  \"\"\"Calculate the short-time Fourier transform magnitude.\n\n  Args:\n    signal: 1D np.array of the input time-domain signal.\n    fft_length: Size of the FFT to apply.\n    hop_length: Advance (in samples) between each frame passed to FFT.\n    window_length: Length of each block of samples to pass to FFT.\n\n  Returns:\n    2D np.array where each row contains the magnitudes of the fft_length/2+1\n    unique values of the FFT for the corresponding frame of input samples.\n  \"\"\"\n  frames = frame(signal, window_length, hop_length)\n  # Apply frame window to each frame. We use a periodic Hann (cosine of period\n  # window_length) instead of the symmetric Hann of np.hanning (period\n  # window_length-1).\n  window = periodic_hann(window_length)\n  windowed_frames = frames * window\n  return np.abs(np.fft.rfft(windowed_frames, int(fft_length)))", "code_tokens": "def stft_magnitude ( signal , fft_length , hop_length = None , window_length = None ) : frames = frame ( signal , window_length , hop_length ) # Apply frame window to each frame. We use a periodic Hann (cosine of period # window_length) instead of the symmetric Hann of np.hanning (period # window_length-1). window = periodic_hann ( window_length ) windowed_frames = frames * window return np . abs ( np . fft . rfft ( windowed_frames , int ( fft_length ) ) )", "docstring_tokens": "Calculate the short - time Fourier transform magnitude .", "label": 0}, {"idx": "cosqa-train-1795", "doc": "return a list of all unique letters in a string python", "code": "def make_unique_ngrams(s, n):\n    \"\"\"Make a set of unique n-grams from a string.\"\"\"\n    return set(s[i:i + n] for i in range(len(s) - n + 1))", "code_tokens": "def make_unique_ngrams ( s , n ) : return set ( s [ i : i + n ] for i in range ( len ( s ) - n + 1 ) )", "docstring_tokens": "Make a set of unique n - grams from a string .", "label": 0}, {"idx": "cosqa-train-1796", "doc": "python 3 formatting seconds", "code": "def fmt_duration(secs):\n    \"\"\"Format a duration in seconds.\"\"\"\n    return ' '.join(fmt.human_duration(secs, 0, precision=2, short=True).strip().split())", "code_tokens": "def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )", "docstring_tokens": "Format a duration in seconds .", "label": 0}, {"idx": "cosqa-train-1797", "doc": "return a list of the vowels that are not in s python", "code": "def vowels(self):\n        \"\"\"\n        Return a new IPAString, containing only the vowels in the current string.\n\n        :rtype: IPAString\n        \"\"\"\n        return IPAString(ipa_chars=[c for c in self.ipa_chars if c.is_vowel])", "code_tokens": "def vowels ( self ) : return IPAString ( ipa_chars = [ c for c in self . ipa_chars if c . is_vowel ] )", "docstring_tokens": "Return a new IPAString containing only the vowels in the current string .", "label": 0}, {"idx": "cosqa-train-1798", "doc": "python 3 get name of calling routing", "code": "def module_name(self):\n        \"\"\"\n        The module where this route's view function was defined.\n        \"\"\"\n        if not self.view_func:\n            return None\n        elif self._controller_cls:\n            rv = inspect.getmodule(self._controller_cls).__name__\n            return rv\n        return inspect.getmodule(self.view_func).__name__", "code_tokens": "def module_name ( self ) : if not self . view_func : return None elif self . _controller_cls : rv = inspect . getmodule ( self . _controller_cls ) . __name__ return rv return inspect . getmodule ( self . view_func ) . __name__", "docstring_tokens": "The module where this route s view function was defined .", "label": 0}, {"idx": "cosqa-train-1799", "doc": "return if year of date typed in is leap year python", "code": "def _is_leap_year(year):\n    \"\"\"Determine if a year is leap year.\n\n    Parameters\n    ----------\n    year : numeric\n\n    Returns\n    -------\n    isleap : array of bools\n    \"\"\"\n    isleap = ((np.mod(year, 4) == 0) &\n              ((np.mod(year, 100) != 0) | (np.mod(year, 400) == 0)))\n    return isleap", "code_tokens": "def _is_leap_year ( year ) : isleap = ( ( np . mod ( year , 4 ) == 0 ) & ( ( np . mod ( year , 100 ) != 0 ) | ( np . mod ( year , 400 ) == 0 ) ) ) return isleap", "docstring_tokens": "Determine if a year is leap year .", "label": 0}, {"idx": "cosqa-train-1800", "doc": "return index of row in series python", "code": "def series_index(self, series):\n        \"\"\"\n        Return the integer index of *series* in this sequence.\n        \"\"\"\n        for idx, s in enumerate(self):\n            if series is s:\n                return idx\n        raise ValueError('series not in chart data object')", "code_tokens": "def series_index ( self , series ) : for idx , s in enumerate ( self ) : if series is s : return idx raise ValueError ( 'series not in chart data object' )", "docstring_tokens": "Return the integer index of * series * in this sequence .", "label": 0}, {"idx": "cosqa-train-1801", "doc": "python 3 how to filter out words from a dictionary", "code": "def _remove_keywords(d):\n    \"\"\"\n    copy the dict, filter_keywords\n\n    Parameters\n    ----------\n    d : dict\n    \"\"\"\n    return { k:v for k, v in iteritems(d) if k not in RESERVED }", "code_tokens": "def _remove_keywords ( d ) : return { k : v for k , v in iteritems ( d ) if k not in RESERVED }", "docstring_tokens": "copy the dict filter_keywords", "label": 0}, {"idx": "cosqa-train-1802", "doc": "return outer join python", "code": "def right_outer(self):\n        \"\"\"\n            Performs Right Outer Join\n            :return right_outer: dict\n        \"\"\"\n        self.get_collections_data()\n        right_outer_join = self.merge_join_docs(\n            set(self.collections_data['right'].keys()))\n        return right_outer_join", "code_tokens": "def right_outer ( self ) : self . get_collections_data ( ) right_outer_join = self . merge_join_docs ( set ( self . collections_data [ 'right' ] . keys ( ) ) ) return right_outer_join", "docstring_tokens": "Performs Right Outer Join : return right_outer : dict", "label": 0}, {"idx": "cosqa-train-1803", "doc": "python 3 input with default value", "code": "def input_int_default(question=\"\", default=0):\n    \"\"\"A function that works for both, Python 2.x and Python 3.x.\n       It asks the user for input and returns it as a string.\n    \"\"\"\n    answer = input_string(question)\n    if answer == \"\" or answer == \"yes\":\n        return default\n    else:\n        return int(answer)", "code_tokens": "def input_int_default ( question = \"\" , default = 0 ) : answer = input_string ( question ) if answer == \"\" or answer == \"yes\" : return default else : return int ( answer )", "docstring_tokens": "A function that works for both Python 2 . x and Python 3 . x . It asks the user for input and returns it as a string .", "label": 0}, {"idx": "cosqa-train-1804", "doc": "return response from an asynchronous call in python", "code": "async def result_processor(tasks):\n    \"\"\"An async result aggregator that combines all the results\n       This gets executed in unsync.loop and unsync.thread\"\"\"\n    output = {}\n    for task in tasks:\n        num, res = await task\n        output[num] = res\n    return output", "code_tokens": "async def result_processor ( tasks ) : output = { } for task in tasks : num , res = await task output [ num ] = res return output", "docstring_tokens": "An async result aggregator that combines all the results This gets executed in unsync . loop and unsync . thread", "label": 0}, {"idx": "cosqa-train-1805", "doc": "python 3 interate over a dict", "code": "def to_dict(dictish):\n    \"\"\"\n    Given something that closely resembles a dictionary, we attempt\n    to coerce it into a propery dictionary.\n    \"\"\"\n    if hasattr(dictish, 'iterkeys'):\n        m = dictish.iterkeys\n    elif hasattr(dictish, 'keys'):\n        m = dictish.keys\n    else:\n        raise ValueError(dictish)\n\n    return dict((k, dictish[k]) for k in m())", "code_tokens": "def to_dict ( dictish ) : if hasattr ( dictish , 'iterkeys' ) : m = dictish . iterkeys elif hasattr ( dictish , 'keys' ) : m = dictish . keys else : raise ValueError ( dictish ) return dict ( ( k , dictish [ k ] ) for k in m ( ) )", "docstring_tokens": "Given something that closely resembles a dictionary we attempt to coerce it into a propery dictionary .", "label": 0}, {"idx": "cosqa-train-1806", "doc": "return type information in python", "code": "def getTypeStr(_type):\n  r\"\"\"Gets the string representation of the given type.\n  \"\"\"\n  if isinstance(_type, CustomType):\n    return str(_type)\n\n  if hasattr(_type, '__name__'):\n    return _type.__name__\n\n  return ''", "code_tokens": "def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''", "docstring_tokens": "r Gets the string representation of the given type .", "label": 0}, {"idx": "cosqa-train-1807", "doc": "python 3 join strings on multiple", "code": "def _py2_and_3_joiner(sep, joinable):\n    \"\"\"\n    Allow '\\n'.join(...) statements to work in Py2 and Py3.\n    :param sep:\n    :param joinable:\n    :return:\n    \"\"\"\n    if ISPY3:\n        sep = bytes(sep, DEFAULT_ENCODING)\n    joined = sep.join(joinable)\n    return joined.decode(DEFAULT_ENCODING) if ISPY3 else joined", "code_tokens": "def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "docstring_tokens": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return :", "label": 0}, {"idx": "cosqa-train-1808", "doc": "reverse edges of a graph python", "code": "def shallow_reverse(g):\n    \"\"\"\n    Make a shallow copy of a directional graph and reverse the edges. This is a workaround to solve the issue that one\n    cannot easily make a shallow reversed copy of a graph in NetworkX 2, since networkx.reverse(copy=False) now returns\n    a GraphView, and GraphViews are always read-only.\n\n    :param networkx.DiGraph g:  The graph to reverse.\n    :return:                    A new networkx.DiGraph that has all nodes and all edges of the original graph, with\n                                edges reversed.\n    \"\"\"\n\n    new_g = networkx.DiGraph()\n\n    new_g.add_nodes_from(g.nodes())\n    for src, dst, data in g.edges(data=True):\n        new_g.add_edge(dst, src, **data)\n\n    return new_g", "code_tokens": "def shallow_reverse ( g ) : new_g = networkx . DiGraph ( ) new_g . add_nodes_from ( g . nodes ( ) ) for src , dst , data in g . edges ( data = True ) : new_g . add_edge ( dst , src , * * data ) return new_g", "docstring_tokens": "Make a shallow copy of a directional graph and reverse the edges . This is a workaround to solve the issue that one cannot easily make a shallow reversed copy of a graph in NetworkX 2 since networkx . reverse ( copy = False ) now returns a GraphView and GraphViews are always read - only .", "label": 0}, {"idx": "cosqa-train-1809", "doc": "python 3 match a string sequence exactly in another string", "code": "def __matches(s1, s2, ngrams_fn, n=3):\n    \"\"\"\n        Returns the n-grams that match between two sequences\n\n        See also: SequenceMatcher.get_matching_blocks\n\n        Args:\n            s1: a string\n            s2: another string\n            n: an int for the n in n-gram\n\n        Returns:\n            set:\n    \"\"\"\n    ngrams1, ngrams2 = set(ngrams_fn(s1, n=n)), set(ngrams_fn(s2, n=n))\n    return ngrams1.intersection(ngrams2)", "code_tokens": "def __matches ( s1 , s2 , ngrams_fn , n = 3 ) : ngrams1 , ngrams2 = set ( ngrams_fn ( s1 , n = n ) ) , set ( ngrams_fn ( s2 , n = n ) ) return ngrams1 . intersection ( ngrams2 )", "docstring_tokens": "Returns the n - grams that match between two sequences", "label": 0}, {"idx": "cosqa-train-1810", "doc": "rnn reshape data based on 2d data frame python", "code": "def sf01(arr):\n    \"\"\"\n    swap and then flatten axes 0 and 1\n    \"\"\"\n    s = arr.shape\n    return arr.swapaxes(0, 1).reshape(s[0] * s[1], *s[2:])", "code_tokens": "def sf01 ( arr ) : s = arr . shape return arr . swapaxes ( 0 , 1 ) . reshape ( s [ 0 ] * s [ 1 ] , * s [ 2 : ] )", "docstring_tokens": "swap and then flatten axes 0 and 1", "label": 0}, {"idx": "cosqa-train-1811", "doc": "python 3 parse datetime timezone", "code": "def parse_timestamp(timestamp):\n    \"\"\"Parse ISO8601 timestamps given by github API.\"\"\"\n    dt = dateutil.parser.parse(timestamp)\n    return dt.astimezone(dateutil.tz.tzutc())", "code_tokens": "def parse_timestamp ( timestamp ) : dt = dateutil . parser . parse ( timestamp ) return dt . astimezone ( dateutil . tz . tzutc ( ) )", "docstring_tokens": "Parse ISO8601 timestamps given by github API .", "label": 0}, {"idx": "cosqa-train-1812", "doc": "rot13 algorithim in python 3", "code": "def _rotate(n, x, y, rx, ry):\n    \"\"\"Rotate and flip a quadrant appropriately\n\n    Based on the implementation here:\n        https://en.wikipedia.org/w/index.php?title=Hilbert_curve&oldid=797332503\n\n    \"\"\"\n    if ry == 0:\n        if rx == 1:\n            x = n - 1 - x\n            y = n - 1 - y\n        return y, x\n    return x, y", "code_tokens": "def _rotate ( n , x , y , rx , ry ) : if ry == 0 : if rx == 1 : x = n - 1 - x y = n - 1 - y return y , x return x , y", "docstring_tokens": "Rotate and flip a quadrant appropriately", "label": 0}, {"idx": "cosqa-train-1813", "doc": "python 3 redirect stdout to file", "code": "def redirect_output(fileobj):\n    \"\"\"Redirect standard out to file.\"\"\"\n    old = sys.stdout\n    sys.stdout = fileobj\n    try:\n        yield fileobj\n    finally:\n        sys.stdout = old", "code_tokens": "def redirect_output ( fileobj ) : old = sys . stdout sys . stdout = fileobj try : yield fileobj finally : sys . stdout = old", "docstring_tokens": "Redirect standard out to file .", "label": 0}, {"idx": "cosqa-train-1814", "doc": "round off a float to int in python", "code": "def round_to_int(number, precision):\n    \"\"\"Round a number to a precision\"\"\"\n    precision = int(precision)\n    rounded = (int(number) + precision / 2) // precision * precision\n    return rounded", "code_tokens": "def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded", "docstring_tokens": "Round a number to a precision", "label": 1}, {"idx": "cosqa-train-1815", "doc": "python 3 slice function", "code": "def Slice(a, begin, size):\n    \"\"\"\n    Slicing op.\n    \"\"\"\n    return np.copy(a)[[slice(*tpl) for tpl in zip(begin, begin+size)]],", "code_tokens": "def Slice ( a , begin , size ) : return np . copy ( a ) [ [ slice ( * tpl ) for tpl in zip ( begin , begin + size ) ] ] ,", "docstring_tokens": "Slicing op .", "label": 1}, {"idx": "cosqa-train-1816", "doc": "round off float to intin python", "code": "def intround(value):\n    \"\"\"Given a float returns a rounded int. Should give the same result on\n    both Py2/3\n    \"\"\"\n\n    return int(decimal.Decimal.from_float(\n        value).to_integral_value(decimal.ROUND_HALF_EVEN))", "code_tokens": "def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )", "docstring_tokens": "Given a float returns a rounded int . Should give the same result on both Py2 / 3", "label": 0}, {"idx": "cosqa-train-1817", "doc": "python 3 store clipboard to variable", "code": "def paste(xsel=False):\n    \"\"\"Returns system clipboard contents.\"\"\"\n    selection = \"primary\" if xsel else \"clipboard\"\n    try:\n        return subprocess.Popen([\"xclip\", \"-selection\", selection, \"-o\"], stdout=subprocess.PIPE).communicate()[0].decode(\"utf-8\")\n    except OSError as why:\n        raise XclipNotFound", "code_tokens": "def paste ( xsel = False ) : selection = \"primary\" if xsel else \"clipboard\" try : return subprocess . Popen ( [ \"xclip\" , \"-selection\" , selection , \"-o\" ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] . decode ( \"utf-8\" ) except OSError as why : raise XclipNotFound", "docstring_tokens": "Returns system clipboard contents .", "label": 0}, {"idx": "cosqa-train-1818", "doc": "round the value of array numpy, python", "code": "def round_array(array_in):\n    \"\"\"\n    arr_out = round_array(array_in)\n\n    Rounds an array and recasts it to int. Also works on scalars.\n    \"\"\"\n    if isinstance(array_in, ndarray):\n        return np.round(array_in).astype(int)\n    else:\n        return int(np.round(array_in))", "code_tokens": "def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )", "docstring_tokens": "arr_out = round_array ( array_in )", "label": 0}, {"idx": "cosqa-train-1819", "doc": "python 3 string normalize", "code": "def normalize(self, string):\n        \"\"\"Normalize the string according to normalization list\"\"\"\n        return ''.join([self._normalize.get(x, x) for x in nfd(string)])", "code_tokens": "def normalize ( self , string ) : return '' . join ( [ self . _normalize . get ( x , x ) for x in nfd ( string ) ] )", "docstring_tokens": "Normalize the string according to normalization list", "label": 0}, {"idx": "cosqa-train-1820", "doc": "rove file extension name python", "code": "def lower_ext(abspath):\n    \"\"\"Convert file extension to lowercase.\n    \"\"\"\n    fname, ext = os.path.splitext(abspath)\n    return fname + ext.lower()", "code_tokens": "def lower_ext ( abspath ) : fname , ext = os . path . splitext ( abspath ) return fname + ext . lower ( )", "docstring_tokens": "Convert file extension to lowercase .", "label": 0}, {"idx": "cosqa-train-1821", "doc": "python 3d linear interpolation", "code": "def _linear_interpolation(x, X, Y):\n    \"\"\"Given two data points [X,Y], linearly interpolate those at x.\n    \"\"\"\n    return (Y[1] * (x - X[0]) + Y[0] * (X[1] - x)) / (X[1] - X[0])", "code_tokens": "def _linear_interpolation ( x , X , Y ) : return ( Y [ 1 ] * ( x - X [ 0 ] ) + Y [ 0 ] * ( X [ 1 ] - x ) ) / ( X [ 1 ] - X [ 0 ] )", "docstring_tokens": "Given two data points [ X Y ] linearly interpolate those at x .", "label": 0}, {"idx": "cosqa-train-1822", "doc": "run function with self variable python", "code": "def __call__(self, func, *args, **kwargs):\n        \"\"\"Shorcut for self.run.\"\"\"\n        return self.run(func, *args, **kwargs)", "code_tokens": "def __call__ ( self , func , * args , * * kwargs ) : return self . run ( func , * args , * * kwargs )", "docstring_tokens": "Shorcut for self . run .", "label": 0}, {"idx": "cosqa-train-1823", "doc": "python abort(404) global name 'abort' is not defined", "code": "def abort(err):\n    \"\"\"Abort everything, everywhere.\"\"\"\n    if _debug: abort._debug(\"abort %r\", err)\n    global local_controllers\n\n    # tell all the local controllers to abort\n    for controller in local_controllers.values():\n        controller.abort(err)", "code_tokens": "def abort ( err ) : if _debug : abort . _debug ( \"abort %r\" , err ) global local_controllers # tell all the local controllers to abort for controller in local_controllers . values ( ) : controller . abort ( err )", "docstring_tokens": "Abort everything everywhere .", "label": 1}, {"idx": "cosqa-train-1824", "doc": "python abstract method raise notimplemented", "code": "def storeByteArray(self, context, page, len, data, returnError):\n        \"\"\"please override\"\"\"\n        returnError.contents.value = self.IllegalStateError\n        raise NotImplementedError(\"You must override this method.\")", "code_tokens": "def storeByteArray ( self , context , page , len , data , returnError ) : returnError . contents . value = self . IllegalStateError raise NotImplementedError ( \"You must override this method.\" )", "docstring_tokens": "please override", "label": 0}, {"idx": "cosqa-train-1825", "doc": "run python test using tox", "code": "def test(ctx, all=False, verbose=False):\n    \"\"\"Run the tests.\"\"\"\n    cmd = 'tox' if all else 'py.test'\n    if verbose:\n        cmd += ' -v'\n    return ctx.run(cmd, pty=True).return_code", "code_tokens": "def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code", "docstring_tokens": "Run the tests .", "label": 0}, {"idx": "cosqa-train-1826", "doc": "python access numpy array range", "code": "def array(self):\n        \"\"\"\n        return the underlying numpy array\n        \"\"\"\n        return np.arange(self.start, self.stop, self.step)", "code_tokens": "def array ( self ) : return np . arange ( self . start , self . stop , self . step )", "docstring_tokens": "return the underlying numpy array", "label": 0}, {"idx": "cosqa-train-1827", "doc": "running nose tests python", "code": "def test(nose_argsuments):\n    \"\"\" Run application tests \"\"\"\n    from nose import run\n\n    params = ['__main__', '-c', 'nose.ini']\n    params.extend(nose_argsuments)\n    run(argv=params)", "code_tokens": "def test ( nose_argsuments ) : from nose import run params = [ '__main__' , '-c' , 'nose.ini' ] params . extend ( nose_argsuments ) run ( argv = params )", "docstring_tokens": "Run application tests", "label": 0}, {"idx": "cosqa-train-1828", "doc": "python access property dynamically", "code": "def value(self):\n        \"\"\"Value of property.\"\"\"\n        if self._prop.fget is None:\n            raise AttributeError('Unable to read attribute')\n        return self._prop.fget(self._obj)", "code_tokens": "def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )", "docstring_tokens": "Value of property .", "label": 0}, {"idx": "cosqa-train-1829", "doc": "saving a html file python", "code": "def _save_file(self, filename, contents):\n        \"\"\"write the html file contents to disk\"\"\"\n        with open(filename, 'w') as f:\n            f.write(contents)", "code_tokens": "def _save_file ( self , filename , contents ) : with open ( filename , 'w' ) as f : f . write ( contents )", "docstring_tokens": "write the html file contents to disk", "label": 0}, {"idx": "cosqa-train-1830", "doc": "scale image on pil python", "code": "def resetScale(self):\n        \"\"\"Resets the scale on this image. Correctly aligns time scale, undoes manual scaling\"\"\"\n        self.img.scale(1./self.imgScale[0], 1./self.imgScale[1])\n        self.imgScale = (1.,1.)", "code_tokens": "def resetScale ( self ) : self . img . scale ( 1. / self . imgScale [ 0 ] , 1. / self . imgScale [ 1 ] ) self . imgScale = ( 1. , 1. )", "docstring_tokens": "Resets the scale on this image . Correctly aligns time scale undoes manual scaling", "label": 0}, {"idx": "cosqa-train-1831", "doc": "python add a line to the end of a text file", "code": "def prepend_line(filepath, line):\n    \"\"\"Rewrite a file adding a line to its beginning.\n    \"\"\"\n    with open(filepath) as f:\n        lines = f.readlines()\n\n    lines.insert(0, line)\n\n    with open(filepath, 'w') as f:\n        f.writelines(lines)", "code_tokens": "def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )", "docstring_tokens": "Rewrite a file adding a line to its beginning .", "label": 0}, {"idx": "cosqa-train-1832", "doc": "scapy python apply filter to pcap and export new file", "code": "def compile_filter(bpf_filter, iface=None):\n    \"\"\"Asks Tcpdump to parse the filter, then build the matching\n    BPF bytecode using get_bpf_pointer.\n    \"\"\"\n    if not TCPDUMP:\n        raise Scapy_Exception(\"tcpdump is not available. Cannot use filter !\")\n    try:\n        process = subprocess.Popen([\n            conf.prog.tcpdump,\n            \"-p\",\n            \"-i\", (conf.iface if iface is None else iface),\n            \"-ddd\",\n            \"-s\", str(MTU),\n            bpf_filter],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE\n        )\n    except OSError as ex:\n        raise Scapy_Exception(\"Failed to attach filter: %s\" % ex)\n    lines, err = process.communicate()\n    ret = process.returncode\n    if ret:\n        raise Scapy_Exception(\n            \"Failed to attach filter: tcpdump returned: %s\" % err\n        )\n    lines = lines.strip().split(b\"\\n\")\n    return get_bpf_pointer(lines)", "code_tokens": "def compile_filter ( bpf_filter , iface = None ) : if not TCPDUMP : raise Scapy_Exception ( \"tcpdump is not available. Cannot use filter !\" ) try : process = subprocess . Popen ( [ conf . prog . tcpdump , \"-p\" , \"-i\" , ( conf . iface if iface is None else iface ) , \"-ddd\" , \"-s\" , str ( MTU ) , bpf_filter ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) except OSError as ex : raise Scapy_Exception ( \"Failed to attach filter: %s\" % ex ) lines , err = process . communicate ( ) ret = process . returncode if ret : raise Scapy_Exception ( \"Failed to attach filter: tcpdump returned: %s\" % err ) lines = lines . strip ( ) . split ( b\"\\n\" ) return get_bpf_pointer ( lines )", "docstring_tokens": "Asks Tcpdump to parse the filter then build the matching BPF bytecode using get_bpf_pointer .", "label": 0}, {"idx": "cosqa-train-1833", "doc": "python add default value", "code": "def setdefault(obj, field, default):\n    \"\"\"Set an object's field to default if it doesn't have a value\"\"\"\n    setattr(obj, field, getattr(obj, field, default))", "code_tokens": "def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )", "docstring_tokens": "Set an object s field to default if it doesn t have a value", "label": 1}, {"idx": "cosqa-train-1834", "doc": "scatter plot python deside each other", "code": "def plot_target(target, ax):\n    \"\"\"Ajoute la target au plot\"\"\"\n    ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)", "code_tokens": "def plot_target ( target , ax ) : ax . scatter ( target [ 0 ] , target [ 1 ] , target [ 2 ] , c = \"red\" , s = 80 )", "docstring_tokens": "Ajoute la target au plot", "label": 0}, {"idx": "cosqa-train-1835", "doc": "python add item in printing a list", "code": "def append(self, item):\n        \"\"\" append item and print it to stdout \"\"\"\n        print(item)\n        super(MyList, self).append(item)", "code_tokens": "def append ( self , item ) : print ( item ) super ( MyList , self ) . append ( item )", "docstring_tokens": "append item and print it to stdout", "label": 0}, {"idx": "cosqa-train-1836", "doc": "scrap a fixed amount of links from a webpage python", "code": "def get_duckduckgo_links(limit, params, headers):\n\t\"\"\"\n\tfunction to fetch links equal to limit\n\n\tduckduckgo pagination is not static, so there is a limit on\n\tmaximum number of links that can be scraped\n\t\"\"\"\n\tresp = s.get('https://duckduckgo.com/html', params = params, headers = headers)\n\tlinks = scrape_links(resp.content, engine = 'd')\n\treturn links[:limit]", "code_tokens": "def get_duckduckgo_links ( limit , params , headers ) : resp = s . get ( 'https://duckduckgo.com/html' , params = params , headers = headers ) links = scrape_links ( resp . content , engine = 'd' ) return links [ : limit ]", "docstring_tokens": "function to fetch links equal to limit", "label": 0}, {"idx": "cosqa-train-1837", "doc": "python add noise to model", "code": "def add_noise(Y, sigma):\n    \"\"\"Adds noise to Y\"\"\"\n    return Y + np.random.normal(0, sigma, Y.shape)", "code_tokens": "def add_noise ( Y , sigma ) : return Y + np . random . normal ( 0 , sigma , Y . shape )", "docstring_tokens": "Adds noise to Y", "label": 0}, {"idx": "cosqa-train-1838", "doc": "script for ui window in maya 2018 using python", "code": "def main_func(args=None):\n    \"\"\"Main funcion when executing this module as script\n\n    :param args: commandline arguments\n    :type args: list\n    :returns: None\n    :rtype: None\n    :raises: None\n    \"\"\"\n    # we have to initialize a gui even if we dont need one right now.\n    # as soon as you call maya.standalone.initialize(), a QApplication\n    # with type Tty is created. This is the type for conosle apps.\n    # Because i have not found a way to replace that, we just init the gui.\n    guimain.init_gui()\n\n    main.init()\n    launcher = Launcher()\n    parsed, unknown = launcher.parse_args(args)\n    parsed.func(parsed, unknown)", "code_tokens": "def main_func ( args = None ) : # we have to initialize a gui even if we dont need one right now. # as soon as you call maya.standalone.initialize(), a QApplication # with type Tty is created. This is the type for conosle apps. # Because i have not found a way to replace that, we just init the gui. guimain . init_gui ( ) main . init ( ) launcher = Launcher ( ) parsed , unknown = launcher . parse_args ( args ) parsed . func ( parsed , unknown )", "docstring_tokens": "Main funcion when executing this module as script", "label": 1}, {"idx": "cosqa-train-1839", "doc": "python add property method dynamic to object", "code": "def set_property(self, key, value):\n        \"\"\"\n        Update only one property in the dict\n        \"\"\"\n        self.properties[key] = value\n        self.sync_properties()", "code_tokens": "def set_property ( self , key , value ) : self . properties [ key ] = value self . sync_properties ( )", "docstring_tokens": "Update only one property in the dict", "label": 0}, {"idx": "cosqa-train-1840", "doc": "see if two strings are the same python", "code": "def eqstr(a, b):\n    \"\"\"\n    Determine whether two strings are equivalent.\n\n    http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/eqstr_c.html\n\n    :param a: Arbitrary character string.\n    :type a: str\n    :param b: Arbitrary character string.\n    :type b: str\n    :return: True if A and B are equivalent.\n    :rtype: bool\n    \"\"\"\n    return bool(libspice.eqstr_c(stypes.stringToCharP(a), stypes.stringToCharP(b)))", "code_tokens": "def eqstr ( a , b ) : return bool ( libspice . eqstr_c ( stypes . stringToCharP ( a ) , stypes . stringToCharP ( b ) ) )", "docstring_tokens": "Determine whether two strings are equivalent .", "label": 0}, {"idx": "cosqa-train-1841", "doc": "python all methods object show", "code": "def __dir__(self):\n        u\"\"\"Returns a list of children and available helper methods.\"\"\"\n        return sorted(self.keys() | {m for m in dir(self.__class__) if m.startswith('to_')})", "code_tokens": "def __dir__ ( self ) : return sorted ( self . keys ( ) | { m for m in dir ( self . __class__ ) if m . startswith ( 'to_' ) } )", "docstring_tokens": "u Returns a list of children and available helper methods .", "label": 0}, {"idx": "cosqa-train-1842", "doc": "select folder dialog in python", "code": "def ask_dir(self):\n\t\t\"\"\"\n\t\tdialogue box for choosing directory\n\t\t\"\"\"\n\t\targs ['directory'] = askdirectory(**self.dir_opt) \n\t\tself.dir_text.set(args ['directory'])", "code_tokens": "def ask_dir ( self ) : args [ 'directory' ] = askdirectory ( * * self . dir_opt ) self . dir_text . set ( args [ 'directory' ] )", "docstring_tokens": "dialogue box for choosing directory", "label": 1}, {"idx": "cosqa-train-1843", "doc": "python argarse custom action", "code": "def add_argument(self, dest, nargs=1, obj=None):\n        \"\"\"Adds a positional argument named `dest` to the parser.\n\n        The `obj` can be used to identify the option in the order list\n        that is returned from the parser.\n        \"\"\"\n        if obj is None:\n            obj = dest\n        self._args.append(Argument(dest=dest, nargs=nargs, obj=obj))", "code_tokens": "def add_argument ( self , dest , nargs = 1 , obj = None ) : if obj is None : obj = dest self . _args . append ( Argument ( dest = dest , nargs = nargs , obj = obj ) )", "docstring_tokens": "Adds a positional argument named dest to the parser .", "label": 1}, {"idx": "cosqa-train-1844", "doc": "select last row python", "code": "def get_last(self, table=None):\n        \"\"\"Just the last entry.\"\"\"\n        if table is None: table = self.main_table\n        query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table\n        return self.own_cursor.execute(query).fetchone()", "code_tokens": "def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )", "docstring_tokens": "Just the last entry .", "label": 0}, {"idx": "cosqa-train-1845", "doc": "python argmin ndarray too large", "code": "def Min(a, axis, keep_dims):\n    \"\"\"\n    Min reduction op.\n    \"\"\"\n    return np.amin(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis),\n                   keepdims=keep_dims),", "code_tokens": "def Min ( a , axis , keep_dims ) : return np . amin ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "docstring_tokens": "Min reduction op .", "label": 0}, {"idx": "cosqa-train-1846", "doc": "selecting a column in python matrix", "code": "def get_column(self, X, column):\n        \"\"\"Return a column of the given matrix.\n\n        Args:\n            X: `numpy.ndarray` or `pandas.DataFrame`.\n            column: `int` or `str`.\n\n        Returns:\n            np.ndarray: Selected column.\n        \"\"\"\n        if isinstance(X, pd.DataFrame):\n            return X[column].values\n\n        return X[:, column]", "code_tokens": "def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]", "docstring_tokens": "Return a column of the given matrix .", "label": 0}, {"idx": "cosqa-train-1847", "doc": "python argparse parser no optional", "code": "def build_parser():\n    \"\"\"Build argument parsers.\"\"\"\n\n    parser = argparse.ArgumentParser(\"Release packages to pypi\")\n    parser.add_argument('--check', '-c', action=\"store_true\", help=\"Do a dry run without uploading\")\n    parser.add_argument('component', help=\"The component to release as component-version\")\n    return parser", "code_tokens": "def build_parser ( ) : parser = argparse . ArgumentParser ( \"Release packages to pypi\" ) parser . add_argument ( '--check' , '-c' , action = \"store_true\" , help = \"Do a dry run without uploading\" ) parser . add_argument ( 'component' , help = \"The component to release as component-version\" ) return parser", "docstring_tokens": "Build argument parsers .", "label": 0}, {"idx": "cosqa-train-1848", "doc": "send an email in python with flask", "code": "def send_email_message(self, recipient, subject, html_message, text_message, sender_email, sender_name):\n        \"\"\" Send email message via Flask-Sendmail.\n\n        Args:\n            recipient: Email address or tuple of (Name, Email-address).\n            subject: Subject line.\n            html_message: The message body in HTML.\n            text_message: The message body in plain text.\n        \"\"\"\n\n        if not current_app.testing:  # pragma: no cover\n\n            # Prepare email message\n            from flask_sendmail import Message\n            message = Message(\n                subject,\n                recipients=[recipient],\n                html=html_message,\n                body=text_message)\n\n            # Send email message\n            self.mail.send(message)", "code_tokens": "def send_email_message ( self , recipient , subject , html_message , text_message , sender_email , sender_name ) : if not current_app . testing : # pragma: no cover # Prepare email message from flask_sendmail import Message message = Message ( subject , recipients = [ recipient ] , html = html_message , body = text_message ) # Send email message self . mail . send ( message )", "docstring_tokens": "Send email message via Flask - Sendmail .", "label": 0}, {"idx": "cosqa-train-1849", "doc": "python array not nan", "code": "def ma(self):\n        \"\"\"Represent data as a masked array.\n\n        The array is returned with column-first indexing, i.e. for a data file with\n        columns X Y1 Y2 Y3 ... the array a will be a[0] = X, a[1] = Y1, ... .\n\n        inf and nan are filtered via :func:`numpy.isfinite`.\n        \"\"\"\n        a = self.array\n        return numpy.ma.MaskedArray(a, mask=numpy.logical_not(numpy.isfinite(a)))", "code_tokens": "def ma ( self ) : a = self . array return numpy . ma . MaskedArray ( a , mask = numpy . logical_not ( numpy . isfinite ( a ) ) )", "docstring_tokens": "Represent data as a masked array .", "label": 0}, {"idx": "cosqa-train-1850", "doc": "send text message using python", "code": "async def _send_plain_text(self, request: Request, stack: Stack):\n        \"\"\"\n        Sends plain text using `_send_text()`.\n        \"\"\"\n\n        await self._send_text(request, stack, None)", "code_tokens": "async def _send_plain_text ( self , request : Request , stack : Stack ) : await self . _send_text ( request , stack , None )", "docstring_tokens": "Sends plain text using _send_text () .", "label": 0}, {"idx": "cosqa-train-1851", "doc": "python array slice start stop skip", "code": "def getbyteslice(self, start, end):\n        \"\"\"Direct access to byte data.\"\"\"\n        c = self._rawarray[start:end]\n        return c", "code_tokens": "def getbyteslice ( self , start , end ) : c = self . _rawarray [ start : end ] return c", "docstring_tokens": "Direct access to byte data .", "label": 0}, {"idx": "cosqa-train-1852", "doc": "server side url parsing in python", "code": "def strip_querystring(url):\n    \"\"\"Remove the querystring from the end of a URL.\"\"\"\n    p = six.moves.urllib.parse.urlparse(url)\n    return p.scheme + \"://\" + p.netloc + p.path", "code_tokens": "def strip_querystring ( url ) : p = six . moves . urllib . parse . urlparse ( url ) return p . scheme + \"://\" + p . netloc + p . path", "docstring_tokens": "Remove the querystring from the end of a URL .", "label": 0}, {"idx": "cosqa-train-1853", "doc": "python array split to chunk", "code": "def chunks(arr, size):\n    \"\"\"Splits a list into chunks\n\n    :param arr: list to split\n    :type arr: :class:`list`\n    :param size: number of elements in each chunk\n    :type size: :class:`int`\n    :return: generator object\n    :rtype: :class:`generator`\n    \"\"\"\n    for i in _range(0, len(arr), size):\n        yield arr[i:i+size]", "code_tokens": "def chunks ( arr , size ) : for i in _range ( 0 , len ( arr ) , size ) : yield arr [ i : i + size ]", "docstring_tokens": "Splits a list into chunks", "label": 0}, {"idx": "cosqa-train-1854", "doc": "serversocket in python inbackround, forever", "code": "def yield_connections(sock):\n    \"\"\"Run a server on the specified socket.\"\"\"\n    while True:\n        log.debug('waiting for connection on %s', sock.getsockname())\n        try:\n            conn, _ = sock.accept()\n        except KeyboardInterrupt:\n            return\n        conn.settimeout(None)\n        log.debug('accepted connection on %s', sock.getsockname())\n        yield conn", "code_tokens": "def yield_connections ( sock ) : while True : log . debug ( 'waiting for connection on %s' , sock . getsockname ( ) ) try : conn , _ = sock . accept ( ) except KeyboardInterrupt : return conn . settimeout ( None ) log . debug ( 'accepted connection on %s' , sock . getsockname ( ) ) yield conn", "docstring_tokens": "Run a server on the specified socket .", "label": 0}, {"idx": "cosqa-train-1855", "doc": "python array to dict using attribute", "code": "def to_dicts(recarray):\n    \"\"\"convert record array to a dictionaries\"\"\"\n    for rec in recarray:\n        yield dict(zip(recarray.dtype.names, rec.tolist()))", "code_tokens": "def to_dicts ( recarray ) : for rec in recarray : yield dict ( zip ( recarray . dtype . names , rec . tolist ( ) ) )", "docstring_tokens": "convert record array to a dictionaries", "label": 1}, {"idx": "cosqa-train-1856", "doc": "set a default value if null python", "code": "def set_if_empty(self, param, default):\n        \"\"\" Set the parameter to the default if it doesn't exist \"\"\"\n        if not self.has(param):\n            self.set(param, default)", "code_tokens": "def set_if_empty ( self , param , default ) : if not self . has ( param ) : self . set ( param , default )", "docstring_tokens": "Set the parameter to the default if it doesn t exist", "label": 0}, {"idx": "cosqa-train-1857", "doc": "set axes limits in a plot python", "code": "def set_xlimits_widgets(self, set_min=True, set_max=True):\n        \"\"\"Populate axis limits GUI with current plot values.\"\"\"\n        xmin, xmax = self.tab_plot.ax.get_xlim()\n        if set_min:\n            self.w.x_lo.set_text('{0}'.format(xmin))\n        if set_max:\n            self.w.x_hi.set_text('{0}'.format(xmax))", "code_tokens": "def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )", "docstring_tokens": "Populate axis limits GUI with current plot values .", "label": 0}, {"idx": "cosqa-train-1858", "doc": "python ascii array build in", "code": "def barray(iterlines):\n    \"\"\"\n    Array of bytes\n    \"\"\"\n    lst = [line.encode('utf-8') for line in iterlines]\n    arr = numpy.array(lst)\n    return arr", "code_tokens": "def barray ( iterlines ) : lst = [ line . encode ( 'utf-8' ) for line in iterlines ] arr = numpy . array ( lst ) return arr", "docstring_tokens": "Array of bytes", "label": 0}, {"idx": "cosqa-train-1859", "doc": "set color palette for gmap python", "code": "def add_matplotlib_cmap(cm, name=None):\n    \"\"\"Add a matplotlib colormap.\"\"\"\n    global cmaps\n    cmap = matplotlib_to_ginga_cmap(cm, name=name)\n    cmaps[cmap.name] = cmap", "code_tokens": "def add_matplotlib_cmap ( cm , name = None ) : global cmaps cmap = matplotlib_to_ginga_cmap ( cm , name = name ) cmaps [ cmap . name ] = cmap", "docstring_tokens": "Add a matplotlib colormap .", "label": 0}, {"idx": "cosqa-train-1860", "doc": "python assert all value in list are equal", "code": "def _check_elements_equal(lst):\n    \"\"\"\n    Returns true if all of the elements in the list are equal.\n    \"\"\"\n    assert isinstance(lst, list), \"Input value must be a list.\"\n    return not lst or lst.count(lst[0]) == len(lst)", "code_tokens": "def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , \"Input value must be a list.\" return not lst or lst . count ( lst [ 0 ] ) == len ( lst )", "docstring_tokens": "Returns true if all of the elements in the list are equal .", "label": 0}, {"idx": "cosqa-train-1861", "doc": "set color value of a pixel python", "code": "def setPixel(self, x, y, color):\n        \"\"\"Set the pixel at (x,y) to the integers in sequence 'color'.\"\"\"\n        return _fitz.Pixmap_setPixel(self, x, y, color)", "code_tokens": "def setPixel ( self , x , y , color ) : return _fitz . Pixmap_setPixel ( self , x , y , color )", "docstring_tokens": "Set the pixel at ( x y ) to the integers in sequence color .", "label": 0}, {"idx": "cosqa-train-1862", "doc": "python assert check type", "code": "def _assert_is_type(name, value, value_type):\n    \"\"\"Assert that a value must be a given type.\"\"\"\n    if not isinstance(value, value_type):\n        if type(value_type) is tuple:\n            types = ', '.join(t.__name__ for t in value_type)\n            raise ValueError('{0} must be one of ({1})'.format(name, types))\n        else:\n            raise ValueError('{0} must be {1}'\n                             .format(name, value_type.__name__))", "code_tokens": "def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )", "docstring_tokens": "Assert that a value must be a given type .", "label": 0}, {"idx": "cosqa-train-1863", "doc": "set default in dictionary python", "code": "def setdefaults(dct, defaults):\n    \"\"\"Given a target dct and a dict of {key:default value} pairs,\n    calls setdefault for all of those pairs.\"\"\"\n    for key in defaults:\n        dct.setdefault(key, defaults[key])\n\n    return dct", "code_tokens": "def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct", "docstring_tokens": "Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs .", "label": 0}, {"idx": "cosqa-train-1864", "doc": "python asyncio add task in task", "code": "async def _thread_coro(self, *args):\n        \"\"\" Coroutine called by MapAsync. It's wrapping the call of\n        run_in_executor to run the synchronous function as thread \"\"\"\n        return await self._loop.run_in_executor(\n            self._executor, self._function, *args)", "code_tokens": "async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "docstring_tokens": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread", "label": 0}, {"idx": "cosqa-train-1865", "doc": "set horizontal line python", "code": "def get_hline():\n    \"\"\" gets a horiztonal line \"\"\"\n    return Window(\n        width=LayoutDimension.exact(1),\n        height=LayoutDimension.exact(1),\n        content=FillControl('-', token=Token.Line))", "code_tokens": "def get_hline ( ) : return Window ( width = LayoutDimension . exact ( 1 ) , height = LayoutDimension . exact ( 1 ) , content = FillControl ( '-' , token = Token . Line ) )", "docstring_tokens": "gets a horiztonal line", "label": 0}, {"idx": "cosqa-train-1866", "doc": "python asyncio wrap function async", "code": "def StringIO(*args, **kwargs):\n    \"\"\"StringIO constructor shim for the async wrapper.\"\"\"\n    raw = sync_io.StringIO(*args, **kwargs)\n    return AsyncStringIOWrapper(raw)", "code_tokens": "def StringIO ( * args , * * kwargs ) : raw = sync_io . StringIO ( * args , * * kwargs ) return AsyncStringIOWrapper ( raw )", "docstring_tokens": "StringIO constructor shim for the async wrapper .", "label": 0}, {"idx": "cosqa-train-1867", "doc": "set particular elements of a matric to zero python", "code": "def _zerosamestates(self, A):\n        \"\"\"\n        zeros out states that should be identical\n\n        REQUIRED ARGUMENTS\n\n        A: the matrix whose entries are to be zeroed.\n\n        \"\"\"\n\n        for pair in self.samestates:\n            A[pair[0], pair[1]] = 0\n            A[pair[1], pair[0]] = 0", "code_tokens": "def _zerosamestates ( self , A ) : for pair in self . samestates : A [ pair [ 0 ] , pair [ 1 ] ] = 0 A [ pair [ 1 ] , pair [ 0 ] ] = 0", "docstring_tokens": "zeros out states that should be identical", "label": 1}, {"idx": "cosqa-train-1868", "doc": "python attr getter key", "code": "def get_attribute_name_id(attr):\n    \"\"\"\n    Return the attribute name identifier\n    \"\"\"\n    return attr.value.id if isinstance(attr.value, ast.Name) else None", "code_tokens": "def get_attribute_name_id ( attr ) : return attr . value . id if isinstance ( attr . value , ast . Name ) else None", "docstring_tokens": "Return the attribute name identifier", "label": 0}, {"idx": "cosqa-train-1869", "doc": "set python opposite of intersection", "code": "def __iand__(self, other):\n        \"\"\"Intersect this flag with ``other`` in-place.\n        \"\"\"\n        self.known &= other.known\n        self.active &= other.active\n        return self", "code_tokens": "def __iand__ ( self , other ) : self . known &= other . known self . active &= other . active return self", "docstring_tokens": "Intersect this flag with other in - place .", "label": 0}, {"idx": "cosqa-train-1870", "doc": "python autcomplete method name", "code": "def get_method_name(method):\n    \"\"\"\n    Returns given method name.\n\n    :param method: Method to retrieve the name.\n    :type method: object\n    :return: Method name.\n    :rtype: unicode\n    \"\"\"\n\n    name = get_object_name(method)\n    if name.startswith(\"__\") and not name.endswith(\"__\"):\n        name = \"_{0}{1}\".format(get_object_name(method.im_class), name)\n    return name", "code_tokens": "def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( \"__\" ) and not name . endswith ( \"__\" ) : name = \"_{0}{1}\" . format ( get_object_name ( method . im_class ) , name ) return name", "docstring_tokens": "Returns given method name .", "label": 0}, {"idx": "cosqa-train-1871", "doc": "setting a variable for user prompt python", "code": "def get_raw_input(description, default=False):\n    \"\"\"Get user input from the command line via raw_input / input.\n\n    description (unicode): Text to display before prompt.\n    default (unicode or False/None): Default value to display with prompt.\n    RETURNS (unicode): User input.\n    \"\"\"\n    additional = ' (default: %s)' % default if default else ''\n    prompt = '    %s%s: ' % (description, additional)\n    user_input = input_(prompt)\n    return user_input", "code_tokens": "def get_raw_input ( description , default = False ) : additional = ' (default: %s)' % default if default else '' prompt = '    %s%s: ' % ( description , additional ) user_input = input_ ( prompt ) return user_input", "docstring_tokens": "Get user input from the command line via raw_input / input .", "label": 1}, {"idx": "cosqa-train-1872", "doc": "python auto doc args", "code": "def setup(app):\n  \"\"\"\n  Just connects the docstring pre_processor and should_skip functions to be\n  applied on all docstrings.\n\n  \"\"\"\n  app.connect('autodoc-process-docstring',\n              lambda *args: pre_processor(*args, namer=audiolazy_namer))\n  app.connect('autodoc-skip-member', should_skip)", "code_tokens": "def setup ( app ) : app . connect ( 'autodoc-process-docstring' , lambda * args : pre_processor ( * args , namer = audiolazy_namer ) ) app . connect ( 'autodoc-skip-member' , should_skip )", "docstring_tokens": "Just connects the docstring pre_processor and should_skip functions to be applied on all docstrings .", "label": 0}, {"idx": "cosqa-train-1873", "doc": "setting yaxis as log in python", "code": "def log_y_cb(self, w, val):\n        \"\"\"Toggle linear/log scale for Y-axis.\"\"\"\n        self.tab_plot.logy = val\n        self.plot_two_columns()", "code_tokens": "def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )", "docstring_tokens": "Toggle linear / log scale for Y - axis .", "label": 1}, {"idx": "cosqa-train-1874", "doc": "python automaticlally change camelcase to snakecase", "code": "def convert_camel_case_to_snake_case(name):\n    \"\"\"Convert CamelCase to snake_case.\"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def convert_camel_case_to_snake_case ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert CamelCase to snake_case .", "label": 0}, {"idx": "cosqa-train-1875", "doc": "shape along x dimension in python", "code": "def array_size(x, axis):\n  \"\"\"Calculate the size of `x` along `axis` dimensions only.\"\"\"\n  axis_shape = x.shape if axis is None else tuple(x.shape[a] for a in axis)\n  return max(numpy.prod(axis_shape), 1)", "code_tokens": "def array_size ( x , axis ) : axis_shape = x . shape if axis is None else tuple ( x . shape [ a ] for a in axis ) return max ( numpy . prod ( axis_shape ) , 1 )", "docstring_tokens": "Calculate the size of x along axis dimensions only .", "label": 0}, {"idx": "cosqa-train-1876", "doc": "python average of values in dictionary", "code": "def _mean_dict(dict_list):\n    \"\"\"Compute the mean value across a list of dictionaries\n    \"\"\"\n    return {k: np.array([d[k] for d in dict_list]).mean()\n            for k in dict_list[0].keys()}", "code_tokens": "def _mean_dict ( dict_list ) : return { k : np . array ( [ d [ k ] for d in dict_list ] ) . mean ( ) for k in dict_list [ 0 ] . keys ( ) }", "docstring_tokens": "Compute the mean value across a list of dictionaries", "label": 0}, {"idx": "cosqa-train-1877", "doc": "shortcut for substring in python", "code": "def fsliceafter(astr, sub):\n    \"\"\"Return the slice after at sub in string astr\"\"\"\n    findex = astr.find(sub)\n    return astr[findex + len(sub):]", "code_tokens": "def fsliceafter ( astr , sub ) : findex = astr . find ( sub ) return astr [ findex + len ( sub ) : ]", "docstring_tokens": "Return the slice after at sub in string astr", "label": 0}, {"idx": "cosqa-train-1878", "doc": "python average value or array", "code": "def average(arr):\n  \"\"\"average of the values, must have more than 0 entries.\n\n  :param arr: list of numbers\n  :type arr: number[] a number array\n  :return: average\n  :rtype: float\n\n  \"\"\"\n  if len(arr) == 0:\n    sys.stderr.write(\"ERROR: no content in array to take average\\n\")\n    sys.exit()\n  if len(arr) == 1:  return arr[0]\n  return float(sum(arr))/float(len(arr))", "code_tokens": "def average ( arr ) : if len ( arr ) == 0 : sys . stderr . write ( \"ERROR: no content in array to take average\\n\" ) sys . exit ( ) if len ( arr ) == 1 : return arr [ 0 ] return float ( sum ( arr ) ) / float ( len ( arr ) )", "docstring_tokens": "average of the values must have more than 0 entries .", "label": 0}, {"idx": "cosqa-train-1879", "doc": "should there be equal no of columns to concanate two df python", "code": "def cross_join(df1, df2):\n    \"\"\"\n    Return a dataframe that is a cross between dataframes\n    df1 and df2\n\n    ref: https://github.com/pydata/pandas/issues/5401\n    \"\"\"\n    if len(df1) == 0:\n        return df2\n\n    if len(df2) == 0:\n        return df1\n\n    # Add as lists so that the new index keeps the items in\n    # the order that they are added together\n    all_columns = pd.Index(list(df1.columns) + list(df2.columns))\n    df1['key'] = 1\n    df2['key'] = 1\n    return pd.merge(df1, df2, on='key').loc[:, all_columns]", "code_tokens": "def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]", "docstring_tokens": "Return a dataframe that is a cross between dataframes df1 and df2", "label": 1}, {"idx": "cosqa-train-1880", "doc": "python average with if condition", "code": "def _aggr_mean(inList):\n  \"\"\" Returns mean of non-None elements of the list\n  \"\"\"\n  aggrSum = 0\n  nonNone = 0\n  for elem in inList:\n    if elem != SENTINEL_VALUE_FOR_MISSING_DATA:\n      aggrSum += elem\n      nonNone += 1\n  if nonNone != 0:\n    return aggrSum / nonNone\n  else:\n    return None", "code_tokens": "def _aggr_mean ( inList ) : aggrSum = 0 nonNone = 0 for elem in inList : if elem != SENTINEL_VALUE_FOR_MISSING_DATA : aggrSum += elem nonNone += 1 if nonNone != 0 : return aggrSum / nonNone else : return None", "docstring_tokens": "Returns mean of non - None elements of the list", "label": 0}, {"idx": "cosqa-train-1881", "doc": "show associated methods in python", "code": "def help(self):\n        \"\"\"Prints discovered resources and their associated methods. Nice when\n        noodling in the terminal to wrap your head around Magento's insanity.\n        \"\"\"\n\n        print('Resources:')\n        print('')\n        for name in sorted(self._resources.keys()):\n            methods = sorted(self._resources[name]._methods.keys())\n            print('{}: {}'.format(bold(name), ', '.join(methods)))", "code_tokens": "def help ( self ) : print ( 'Resources:' ) print ( '' ) for name in sorted ( self . _resources . keys ( ) ) : methods = sorted ( self . _resources [ name ] . _methods . keys ( ) ) print ( '{}: {}' . format ( bold ( name ) , ', ' . join ( methods ) ) )", "docstring_tokens": "Prints discovered resources and their associated methods . Nice when noodling in the terminal to wrap your head around Magento s insanity .", "label": 0}, {"idx": "cosqa-train-1882", "doc": "python azure analysis service connect adomd", "code": "def loganalytics_data_plane_client(cli_ctx, _):\n    \"\"\"Initialize Log Analytics data client for use with CLI.\"\"\"\n    from .vendored_sdks.loganalytics import LogAnalyticsDataClient\n    from azure.cli.core._profile import Profile\n    profile = Profile(cli_ctx=cli_ctx)\n    cred, _, _ = profile.get_login_credentials(\n        resource=\"https://api.loganalytics.io\")\n    return LogAnalyticsDataClient(cred)", "code_tokens": "def loganalytics_data_plane_client ( cli_ctx , _ ) : from . vendored_sdks . loganalytics import LogAnalyticsDataClient from azure . cli . core . _profile import Profile profile = Profile ( cli_ctx = cli_ctx ) cred , _ , _ = profile . get_login_credentials ( resource = \"https://api.loganalytics.io\" ) return LogAnalyticsDataClient ( cred )", "docstring_tokens": "Initialize Log Analytics data client for use with CLI .", "label": 0}, {"idx": "cosqa-train-1883", "doc": "show attributes of object python", "code": "def _repr(obj):\n    \"\"\"Show the received object as precise as possible.\"\"\"\n    vals = \", \".join(\"{}={!r}\".format(\n        name, getattr(obj, name)) for name in obj._attribs)\n    if vals:\n        t = \"{}(name={}, {})\".format(obj.__class__.__name__, obj.name, vals)\n    else:\n        t = \"{}(name={})\".format(obj.__class__.__name__, obj.name)\n    return t", "code_tokens": "def _repr ( obj ) : vals = \", \" . join ( \"{}={!r}\" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = \"{}(name={}, {})\" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = \"{}(name={})\" . format ( obj . __class__ . __name__ , obj . name ) return t", "docstring_tokens": "Show the received object as precise as possible .", "label": 0}, {"idx": "cosqa-train-1884", "doc": "python background queue httpserver", "code": "def start(self):\n        \"\"\"Create a background thread for httpd and serve 'forever'\"\"\"\n        self._process = threading.Thread(target=self._background_runner)\n        self._process.start()", "code_tokens": "def start ( self ) : self . _process = threading . Thread ( target = self . _background_runner ) self . _process . start ( )", "docstring_tokens": "Create a background thread for httpd and serve forever", "label": 0}, {"idx": "cosqa-train-1885", "doc": "show the \\n in python screen", "code": "def out(self, output, newline=True):\n        \"\"\"Outputs a string to the console (stdout).\"\"\"\n        click.echo(output, nl=newline)", "code_tokens": "def out ( self , output , newline = True ) : click . echo ( output , nl = newline )", "docstring_tokens": "Outputs a string to the console ( stdout ) .", "label": 0}, {"idx": "cosqa-train-1886", "doc": "python base64 decode to float array", "code": "def decode_arr(data):\n    \"\"\"Extract a numpy array from a base64 buffer\"\"\"\n    data = data.encode('utf-8')\n    return frombuffer(base64.b64decode(data), float64)", "code_tokens": "def decode_arr ( data ) : data = data . encode ( 'utf-8' ) return frombuffer ( base64 . b64decode ( data ) , float64 )", "docstring_tokens": "Extract a numpy array from a base64 buffer", "label": 0}, {"idx": "cosqa-train-1887", "doc": "show tsv file in python", "code": "def csvpretty(csvfile: csvfile=sys.stdin):\n    \"\"\" Pretty print a CSV file. \"\"\"\n    shellish.tabulate(csv.reader(csvfile))", "code_tokens": "def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )", "docstring_tokens": "Pretty print a CSV file .", "label": 0}, {"idx": "cosqa-train-1888", "doc": "python batch input matrix", "code": "def encode_batch(self, inputBatch):\n        \"\"\"Encodes a whole batch of input arrays, without learning.\"\"\"\n        X      = inputBatch\n        encode = self.encode\n        Y      = np.array([ encode(x) for x in X])\n        return Y", "code_tokens": "def encode_batch ( self , inputBatch ) : X = inputBatch encode = self . encode Y = np . array ( [ encode ( x ) for x in X ] ) return Y", "docstring_tokens": "Encodes a whole batch of input arrays without learning .", "label": 0}, {"idx": "cosqa-train-1889", "doc": "python beautifulsoup 'nonetype' object is not callable", "code": "def parse(el, typ):\n    \"\"\"\n    Parse a ``BeautifulSoup`` element as the given type.\n    \"\"\"\n    if not el:\n        return typ()\n    txt = text(el)\n    if not txt:\n        return typ()\n    return typ(txt)", "code_tokens": "def parse ( el , typ ) : if not el : return typ ( ) txt = text ( el ) if not txt : return typ ( ) return typ ( txt )", "docstring_tokens": "Parse a BeautifulSoup element as the given type .", "label": 0}, {"idx": "cosqa-train-1890", "doc": "sine wave python code", "code": "def sine_wave(frequency):\n  \"\"\"Emit a sine wave at the given frequency.\"\"\"\n  xs = tf.reshape(tf.range(_samples(), dtype=tf.float32), [1, _samples(), 1])\n  ts = xs / FLAGS.sample_rate\n  return tf.sin(2 * math.pi * frequency * ts)", "code_tokens": "def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )", "docstring_tokens": "Emit a sine wave at the given frequency .", "label": 1}, {"idx": "cosqa-train-1891", "doc": "python behavor tree json", "code": "def as_tree(context):\n    \"\"\"Return info about an object's members as JSON\"\"\"\n\n    tree = _build_tree(context, 2, 1)\n    if type(tree) == dict:\n        tree = [tree] \n    \n    return Response(content_type='application/json', body=json.dumps(tree))", "code_tokens": "def as_tree ( context ) : tree = _build_tree ( context , 2 , 1 ) if type ( tree ) == dict : tree = [ tree ] return Response ( content_type = 'application/json' , body = json . dumps ( tree ) )", "docstring_tokens": "Return info about an object s members as JSON", "label": 0}, {"idx": "cosqa-train-1892", "doc": "singleton implementation python 3", "code": "def singleton(class_):\n    \"\"\"Singleton definition.\n\n    Method 1 from\n    https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python\n    \"\"\"\n    instances = {}\n\n    def get_instance(*args, **kwargs):\n        if class_ not in instances:\n            instances[class_] = class_(*args, **kwargs)\n        return instances[class_]\n    return get_instance", "code_tokens": "def singleton ( class_ ) : instances = { } def get_instance ( * args , * * kwargs ) : if class_ not in instances : instances [ class_ ] = class_ ( * args , * * kwargs ) return instances [ class_ ] return get_instance", "docstring_tokens": "Singleton definition .", "label": 0}, {"idx": "cosqa-train-1893", "doc": "python best way to stringify a date", "code": "def QA_util_datetime_to_strdate(dt):\n    \"\"\"\n    :param dt:  pythone datetime.datetime\n    :return:  1999-02-01 string type\n    \"\"\"\n    strdate = \"%04d-%02d-%02d\" % (dt.year, dt.month, dt.day)\n    return strdate", "code_tokens": "def QA_util_datetime_to_strdate ( dt ) : strdate = \"%04d-%02d-%02d\" % ( dt . year , dt . month , dt . day ) return strdate", "docstring_tokens": ": param dt : pythone datetime . datetime : return : 1999 - 02 - 01 string type", "label": 1}, {"idx": "cosqa-train-1894", "doc": "skip lines that start with # in python", "code": "def filter_useless_pass(source):\n    \"\"\"Yield code with useless \"pass\" lines removed.\"\"\"\n    try:\n        marked_lines = frozenset(useless_pass_line_numbers(source))\n    except (SyntaxError, tokenize.TokenError):\n        marked_lines = frozenset()\n\n    sio = io.StringIO(source)\n    for line_number, line in enumerate(sio.readlines(), start=1):\n        if line_number not in marked_lines:\n            yield line", "code_tokens": "def filter_useless_pass ( source ) : try : marked_lines = frozenset ( useless_pass_line_numbers ( source ) ) except ( SyntaxError , tokenize . TokenError ) : marked_lines = frozenset ( ) sio = io . StringIO ( source ) for line_number , line in enumerate ( sio . readlines ( ) , start = 1 ) : if line_number not in marked_lines : yield line", "docstring_tokens": "Yield code with useless pass lines removed .", "label": 0}, {"idx": "cosqa-train-1895", "doc": "python best way to use swagger", "code": "def refresh_swagger(self):\n        \"\"\"\n        Manually refresh the swagger document. This can help resolve errors communicate with the API.\n        \"\"\"\n        try:\n            os.remove(self._get_swagger_filename(self.swagger_url))\n        except EnvironmentError as e:\n            logger.warn(os.strerror(e.errno))\n        else:\n            self.__init__()", "code_tokens": "def refresh_swagger ( self ) : try : os . remove ( self . _get_swagger_filename ( self . swagger_url ) ) except EnvironmentError as e : logger . warn ( os . strerror ( e . errno ) ) else : self . __init__ ( )", "docstring_tokens": "Manually refresh the swagger document . This can help resolve errors communicate with the API .", "label": 0}, {"idx": "cosqa-train-1896", "doc": "slice a column from 2d list python", "code": "def iget_list_column_slice(list_, start=None, stop=None, stride=None):\n    \"\"\" iterator version of get_list_column \"\"\"\n    if isinstance(start, slice):\n        slice_ = start\n    else:\n        slice_ = slice(start, stop, stride)\n    return (row[slice_] for row in list_)", "code_tokens": "def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )", "docstring_tokens": "iterator version of get_list_column", "label": 0}, {"idx": "cosqa-train-1897", "doc": "python bin interval to index", "code": "def get_bin_indices(self, values):\n        \"\"\"Returns index tuple in histogram of bin which contains value\"\"\"\n        return tuple([self.get_axis_bin_index(values[ax_i], ax_i)\n                      for ax_i in range(self.dimensions)])", "code_tokens": "def get_bin_indices ( self , values ) : return tuple ( [ self . get_axis_bin_index ( values [ ax_i ] , ax_i ) for ax_i in range ( self . dimensions ) ] )", "docstring_tokens": "Returns index tuple in histogram of bin which contains value", "label": 1}, {"idx": "cosqa-train-1898", "doc": "sorting an array in descending order in python", "code": "def arglexsort(arrays):\n    \"\"\"\n    Returns the indices of the lexicographical sorting\n    order of the supplied arrays.\n    \"\"\"\n    dtypes = ','.join(array.dtype.str for array in arrays)\n    recarray = np.empty(len(arrays[0]), dtype=dtypes)\n    for i, array in enumerate(arrays):\n        recarray['f%s' % i] = array\n    return recarray.argsort()", "code_tokens": "def arglexsort ( arrays ) : dtypes = ',' . join ( array . dtype . str for array in arrays ) recarray = np . empty ( len ( arrays [ 0 ] ) , dtype = dtypes ) for i , array in enumerate ( arrays ) : recarray [ 'f%s' % i ] = array return recarray . argsort ( )", "docstring_tokens": "Returns the indices of the lexicographical sorting order of the supplied arrays .", "label": 0}, {"idx": "cosqa-train-1899", "doc": "python bind event to a entry in treeview", "code": "def register_view(self, view):\n        \"\"\"Register callbacks for button press events and selection changed\"\"\"\n        super(ListViewController, self).register_view(view)\n        self.tree_view.connect('button_press_event', self.mouse_click)", "code_tokens": "def register_view ( self , view ) : super ( ListViewController , self ) . register_view ( view ) self . tree_view . connect ( 'button_press_event' , self . mouse_click )", "docstring_tokens": "Register callbacks for button press events and selection changed", "label": 0}, {"idx": "cosqa-train-1900", "doc": "spacing a print function in python", "code": "def indented_show(text, howmany=1):\n        \"\"\"Print a formatted indented text.\n        \"\"\"\n        print(StrTemplate.pad_indent(text=text, howmany=howmany))", "code_tokens": "def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )", "docstring_tokens": "Print a formatted indented text .", "label": 0}, {"idx": "cosqa-train-1901", "doc": "python binomial coefficient doc", "code": "def Bernstein(n, k):\n    \"\"\"Bernstein polynomial.\n\n    \"\"\"\n    coeff = binom(n, k)\n\n    def _bpoly(x):\n        return coeff * x ** k * (1 - x) ** (n - k)\n\n    return _bpoly", "code_tokens": "def Bernstein ( n , k ) : coeff = binom ( n , k ) def _bpoly ( x ) : return coeff * x ** k * ( 1 - x ) ** ( n - k ) return _bpoly", "docstring_tokens": "Bernstein polynomial .", "label": 1}, {"idx": "cosqa-train-1902", "doc": "split dash words in python", "code": "def abbreviate_dashed(s):\n    \"\"\"Abbreviates each part of string that is delimited by a '-'.\"\"\"\n    r = []\n    for part in s.split('-'):\n        r.append(abbreviate(part))\n    return '-'.join(r)", "code_tokens": "def abbreviate_dashed ( s ) : r = [ ] for part in s . split ( '-' ) : r . append ( abbreviate ( part ) ) return '-' . join ( r )", "docstring_tokens": "Abbreviates each part of string that is delimited by a - .", "label": 0}, {"idx": "cosqa-train-1903", "doc": "python boolen mask index", "code": "def maskIndex(self):\n        \"\"\" Returns a boolean index with True if the value is masked.\n\n            Always has the same shape as the maksedArray.data, event if the mask is a single boolan.\n        \"\"\"\n        if isinstance(self.mask, bool):\n            return np.full(self.data.shape, self.mask, dtype=np.bool)\n        else:\n            return self.mask", "code_tokens": "def maskIndex ( self ) : if isinstance ( self . mask , bool ) : return np . full ( self . data . shape , self . mask , dtype = np . bool ) else : return self . mask", "docstring_tokens": "Returns a boolean index with True if the value is masked .", "label": 0}, {"idx": "cosqa-train-1904", "doc": "splitting a string by multiple charachters python", "code": "def _split(string, splitters):\n    \"\"\"Splits a string into parts at multiple characters\"\"\"\n    part = ''\n    for character in string:\n        if character in splitters:\n            yield part\n            part = ''\n        else:\n            part += character\n    yield part", "code_tokens": "def _split ( string , splitters ) : part = '' for character in string : if character in splitters : yield part part = '' else : part += character yield part", "docstring_tokens": "Splits a string into parts at multiple characters", "label": 0}, {"idx": "cosqa-train-1905", "doc": "python boto retrieve s3 file", "code": "def read_key(self, key, bucket_name=None):\n        \"\"\"\n        Reads a key from S3\n\n        :param key: S3 key that will point to the file\n        :type key: str\n        :param bucket_name: Name of the bucket in which the file is stored\n        :type bucket_name: str\n        \"\"\"\n\n        obj = self.get_key(key, bucket_name)\n        return obj.get()['Body'].read().decode('utf-8')", "code_tokens": "def read_key ( self , key , bucket_name = None ) : obj = self . get_key ( key , bucket_name ) return obj . get ( ) [ 'Body' ] . read ( ) . decode ( 'utf-8' )", "docstring_tokens": "Reads a key from S3", "label": 0}, {"idx": "cosqa-train-1906", "doc": "splitting string into list of words python", "code": "def split_into_words(s):\n  \"\"\"Split a sentence into list of words.\"\"\"\n  s = re.sub(r\"\\W+\", \" \", s)\n  s = re.sub(r\"[_0-9]+\", \" \", s)\n  return s.split()", "code_tokens": "def split_into_words ( s ) : s = re . sub ( r\"\\W+\" , \" \" , s ) s = re . sub ( r\"[_0-9]+\" , \" \" , s ) return s . split ( )", "docstring_tokens": "Split a sentence into list of words .", "label": 0}, {"idx": "cosqa-train-1907", "doc": "python boto3 stream bytes object s3", "code": "def get_as_bytes(self, s3_path):\n        \"\"\"\n        Get the contents of an object stored in S3 as bytes\n\n        :param s3_path: URL for target S3 location\n        :return: File contents as pure bytes\n        \"\"\"\n        (bucket, key) = self._path_to_bucket_and_key(s3_path)\n        obj = self.s3.Object(bucket, key)\n        contents = obj.get()['Body'].read()\n        return contents", "code_tokens": "def get_as_bytes ( self , s3_path ) : ( bucket , key ) = self . _path_to_bucket_and_key ( s3_path ) obj = self . s3 . Object ( bucket , key ) contents = obj . get ( ) [ 'Body' ] . read ( ) return contents", "docstring_tokens": "Get the contents of an object stored in S3 as bytes", "label": 0}, {"idx": "cosqa-train-1908", "doc": "spyder 3 to do check mark python", "code": "def matrix_at_check(self, original, loc, tokens):\n        \"\"\"Check for Python 3.5 matrix multiplication.\"\"\"\n        return self.check_py(\"35\", \"matrix multiplication\", original, loc, tokens)", "code_tokens": "def matrix_at_check ( self , original , loc , tokens ) : return self . check_py ( \"35\" , \"matrix multiplication\" , original , loc , tokens )", "docstring_tokens": "Check for Python 3 . 5 matrix multiplication .", "label": 0}, {"idx": "cosqa-train-1909", "doc": "python bottle how to use session variables in jinja2 template", "code": "def render_template(self, source, **kwargs_context):\n        r\"\"\"Render a template string using sandboxed environment.\n\n        :param source: A string containing the page source.\n        :param \\*\\*kwargs_context: The context associated with the page.\n        :returns: The rendered template.\n        \"\"\"\n        return self.jinja_env.from_string(source).render(kwargs_context)", "code_tokens": "def render_template ( self , source , * * kwargs_context ) : return self . jinja_env . from_string ( source ) . render ( kwargs_context )", "docstring_tokens": "r Render a template string using sandboxed environment .", "label": 0}, {"idx": "cosqa-train-1910", "doc": "sqlalchemy python column id update next availb seq id", "code": "def emit_db_sequence_updates(engine):\n    \"\"\"Set database sequence objects to match the source db\n\n       Relevant only when generated from SQLAlchemy connection.\n       Needed to avoid subsequent unique key violations after DB build.\"\"\"\n\n    if engine and engine.name == 'postgresql':\n        # not implemented for other RDBMS; necessity unknown\n        conn = engine.connect()\n        qry = \"\"\"SELECT 'SELECT last_value FROM ' || n.nspname ||\n                         '.' || c.relname || ';' AS qry,\n                        n.nspname || '.' || c.relname AS qual_name\n                 FROM   pg_namespace n\n                 JOIN   pg_class c ON (n.oid = c.relnamespace)\n                 WHERE  c.relkind = 'S'\"\"\"\n        for (qry, qual_name) in list(conn.execute(qry)):\n            (lastval, ) = conn.execute(qry).first()\n            nextval = int(lastval) + 1\n            yield \"ALTER SEQUENCE %s RESTART WITH %s;\" % (qual_name, nextval)", "code_tokens": "def emit_db_sequence_updates ( engine ) : if engine and engine . name == 'postgresql' : # not implemented for other RDBMS; necessity unknown conn = engine . connect ( ) qry = \"\"\"SELECT 'SELECT last_value FROM ' || n.nspname ||\n                         '.' || c.relname || ';' AS qry,\n                        n.nspname || '.' || c.relname AS qual_name\n                 FROM   pg_namespace n\n                 JOIN   pg_class c ON (n.oid = c.relnamespace)\n                 WHERE  c.relkind = 'S'\"\"\" for ( qry , qual_name ) in list ( conn . execute ( qry ) ) : ( lastval , ) = conn . execute ( qry ) . first ( ) nextval = int ( lastval ) + 1 yield \"ALTER SEQUENCE %s RESTART WITH %s;\" % ( qual_name , nextval )", "docstring_tokens": "Set database sequence objects to match the source db", "label": 0}, {"idx": "cosqa-train-1911", "doc": "python bound method get set", "code": "def method_double_for(self, method_name):\n        \"\"\"Returns the method double for the provided method name, creating one if necessary.\n\n        :param str method_name: The name of the method to retrieve a method double for.\n        :return: The mapped ``MethodDouble``.\n        :rtype: MethodDouble\n        \"\"\"\n\n        if method_name not in self._method_doubles:\n            self._method_doubles[method_name] = MethodDouble(method_name, self._target)\n\n        return self._method_doubles[method_name]", "code_tokens": "def method_double_for ( self , method_name ) : if method_name not in self . _method_doubles : self . _method_doubles [ method_name ] = MethodDouble ( method_name , self . _target ) return self . _method_doubles [ method_name ]", "docstring_tokens": "Returns the method double for the provided method name creating one if necessary .", "label": 0}, {"idx": "cosqa-train-1912", "doc": "srgbcolor get tuple python", "code": "def rgba_bytes_tuple(self, x):\n        \"\"\"Provides the color corresponding to value `x` in the\n        form of a tuple (R,G,B,A) with int values between 0 and 255.\n        \"\"\"\n        return tuple(int(u*255.9999) for u in self.rgba_floats_tuple(x))", "code_tokens": "def rgba_bytes_tuple ( self , x ) : return tuple ( int ( u * 255.9999 ) for u in self . rgba_floats_tuple ( x ) )", "docstring_tokens": "Provides the color corresponding to value x in the form of a tuple ( R G B A ) with int values between 0 and 255 .", "label": 0}, {"idx": "cosqa-train-1913", "doc": "python bulk insert cursor to sql server", "code": "def bulk_query(self, query, *multiparams):\n        \"\"\"Bulk insert or update.\"\"\"\n\n        with self.get_connection() as conn:\n            conn.bulk_query(query, *multiparams)", "code_tokens": "def bulk_query ( self , query , * multiparams ) : with self . get_connection ( ) as conn : conn . bulk_query ( query , * multiparams )", "docstring_tokens": "Bulk insert or update .", "label": 0}, {"idx": "cosqa-train-1914", "doc": "stack overflow python database", "code": "def init_db():\n    \"\"\"\n    Drops and re-creates the SQL schema\n    \"\"\"\n    db.drop_all()\n    db.configure_mappers()\n    db.create_all()\n    db.session.commit()", "code_tokens": "def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )", "docstring_tokens": "Drops and re - creates the SQL schema", "label": 0}, {"idx": "cosqa-train-1915", "doc": "python butterworth high filter in frequency", "code": "def fft_bandpassfilter(data, fs, lowcut, highcut):\n    \"\"\"\n    http://www.swharden.com/blog/2009-01-21-signal-filtering-with-python/#comment-16801\n    \"\"\"\n    fft = np.fft.fft(data)\n    # n = len(data)\n    # timestep = 1.0 / fs\n    # freq = np.fft.fftfreq(n, d=timestep)\n    bp = fft.copy()\n\n    # Zero out fft coefficients\n    # bp[10:-10] = 0\n\n    # Normalise\n    # bp *= real(fft.dot(fft))/real(bp.dot(bp))\n\n    bp *= fft.dot(fft) / bp.dot(bp)\n\n    # must multipy by 2 to get the correct amplitude\n    ibp = 12 * np.fft.ifft(bp)\n    return ibp", "code_tokens": "def fft_bandpassfilter ( data , fs , lowcut , highcut ) : fft = np . fft . fft ( data ) # n = len(data) # timestep = 1.0 / fs # freq = np.fft.fftfreq(n, d=timestep) bp = fft . copy ( ) # Zero out fft coefficients # bp[10:-10] = 0 # Normalise # bp *= real(fft.dot(fft))/real(bp.dot(bp)) bp *= fft . dot ( fft ) / bp . dot ( bp ) # must multipy by 2 to get the correct amplitude ibp = 12 * np . fft . ifft ( bp ) return ibp", "docstring_tokens": "http : // www . swharden . com / blog / 2009 - 01 - 21 - signal - filtering - with - python / #comment - 16801", "label": 1}, {"idx": "cosqa-train-1916", "doc": "standard deviation python numpy not correct", "code": "def _std(self,x):\n        \"\"\"\n        Compute standard deviation with ddof degrees of freedom\n        \"\"\"\n        return np.nanstd(x.values,ddof=self._ddof)", "code_tokens": "def _std ( self , x ) : return np . nanstd ( x . values , ddof = self . _ddof )", "docstring_tokens": "Compute standard deviation with ddof degrees of freedom", "label": 0}, {"idx": "cosqa-train-1917", "doc": "python byte string to numpy", "code": "def convert_array(array):\n    \"\"\"\n    Converts an ARRAY string stored in the database back into a Numpy array.\n\n    Parameters\n    ----------\n    array: ARRAY\n        The array object to be converted back into a Numpy array.\n\n    Returns\n    -------\n    array\n            The converted Numpy array.\n\n    \"\"\"\n    out = io.BytesIO(array)\n    out.seek(0)\n    return np.load(out)", "code_tokens": "def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )", "docstring_tokens": "Converts an ARRAY string stored in the database back into a Numpy array .", "label": 0}, {"idx": "cosqa-train-1918", "doc": "stestr to invoke a python env variable", "code": "def print_env_info(key, out=sys.stderr):\n    \"\"\"If given environment key is defined, print it out.\"\"\"\n    value = os.getenv(key)\n    if value is not None:\n        print(key, \"=\", repr(value), file=out)", "code_tokens": "def print_env_info ( key , out = sys . stderr ) : value = os . getenv ( key ) if value is not None : print ( key , \"=\" , repr ( value ) , file = out )", "docstring_tokens": "If given environment key is defined print it out .", "label": 0}, {"idx": "cosqa-train-1919", "doc": "python cache file in memory", "code": "def is_cached(file_name):\n\t\"\"\"\n\tCheck if a given file is available in the cache or not\n\t\"\"\"\n\n\tgml_file_path = join(join(expanduser('~'), OCTOGRID_DIRECTORY), file_name)\n\n\treturn isfile(gml_file_path)", "code_tokens": "def is_cached ( file_name ) : gml_file_path = join ( join ( expanduser ( '~' ) , OCTOGRID_DIRECTORY ) , file_name ) return isfile ( gml_file_path )", "docstring_tokens": "Check if a given file is available in the cache or not", "label": 1}, {"idx": "cosqa-train-1920", "doc": "stop child thread python", "code": "def Stop(self):\n    \"\"\"Stops the process status RPC server.\"\"\"\n    self._Close()\n\n    if self._rpc_thread.isAlive():\n      self._rpc_thread.join()\n    self._rpc_thread = None", "code_tokens": "def Stop ( self ) : self . _Close ( ) if self . _rpc_thread . isAlive ( ) : self . _rpc_thread . join ( ) self . _rpc_thread = None", "docstring_tokens": "Stops the process status RPC server .", "label": 1}, {"idx": "cosqa-train-1921", "doc": "python cache limit size", "code": "def set_cache_max(self, cache_name, maxsize, **kwargs):\n        \"\"\"\n        Sets the maxsize attribute of the named cache\n        \"\"\"\n        cache = self._get_cache(cache_name)\n        cache.set_maxsize(maxsize, **kwargs)", "code_tokens": "def set_cache_max ( self , cache_name , maxsize , * * kwargs ) : cache = self . _get_cache ( cache_name ) cache . set_maxsize ( maxsize , * * kwargs )", "docstring_tokens": "Sets the maxsize attribute of the named cache", "label": 0}, {"idx": "cosqa-train-1922", "doc": "stop moving objects canvas python", "code": "def _on_release(self, event):\n        \"\"\"Stop dragging.\"\"\"\n        if self._drag_cols or self._drag_rows:\n            self._visual_drag.place_forget()\n            self._dragged_col = None\n            self._dragged_row = None", "code_tokens": "def _on_release ( self , event ) : if self . _drag_cols or self . _drag_rows : self . _visual_drag . place_forget ( ) self . _dragged_col = None self . _dragged_row = None", "docstring_tokens": "Stop dragging .", "label": 0}, {"idx": "cosqa-train-1923", "doc": "python caching db update", "code": "def update_cache(self, data):\n        \"\"\"Update a cached value.\"\"\"\n        UTILS.update(self._cache, data)\n        self._save_cache()", "code_tokens": "def update_cache ( self , data ) : UTILS . update ( self . _cache , data ) self . _save_cache ( )", "docstring_tokens": "Update a cached value .", "label": 0}, {"idx": "cosqa-train-1924", "doc": "stop the python shell from executing", "code": "def stop_button_click_handler(self):\n        \"\"\"Method to handle what to do when the stop button is pressed\"\"\"\n        self.stop_button.setDisabled(True)\n        # Interrupt computations or stop debugging\n        if not self.shellwidget._reading:\n            self.interrupt_kernel()\n        else:\n            self.shellwidget.write_to_stdin('exit')", "code_tokens": "def stop_button_click_handler ( self ) : self . stop_button . setDisabled ( True ) # Interrupt computations or stop debugging\n if not self . shellwidget . _reading : self . interrupt_kernel ( ) else : self . shellwidget . write_to_stdin ( 'exit' )", "docstring_tokens": "Method to handle what to do when the stop button is pressed", "label": 0}, {"idx": "cosqa-train-1925", "doc": "python calculate angle from 3 points", "code": "def angle(x, y):\n    \"\"\"Return the angle between vectors a and b in degrees.\"\"\"\n    return arccos(dot(x, y)/(norm(x)*norm(y)))*180./pi", "code_tokens": "def angle ( x , y ) : return arccos ( dot ( x , y ) / ( norm ( x ) * norm ( y ) ) ) * 180. / pi", "docstring_tokens": "Return the angle between vectors a and b in degrees .", "label": 0}, {"idx": "cosqa-train-1926", "doc": "store a file locally cache python", "code": "def is_cached(file_name):\n\t\"\"\"\n\tCheck if a given file is available in the cache or not\n\t\"\"\"\n\n\tgml_file_path = join(join(expanduser('~'), OCTOGRID_DIRECTORY), file_name)\n\n\treturn isfile(gml_file_path)", "code_tokens": "def is_cached ( file_name ) : gml_file_path = join ( join ( expanduser ( '~' ) , OCTOGRID_DIRECTORY ) , file_name ) return isfile ( gml_file_path )", "docstring_tokens": "Check if a given file is available in the cache or not", "label": 0}, {"idx": "cosqa-train-1927", "doc": "python calculate average from iterator", "code": "def average(iterator):\n    \"\"\"Iterative mean.\"\"\"\n    count = 0\n    total = 0\n    for num in iterator:\n        count += 1\n        total += num\n    return float(total)/count", "code_tokens": "def average ( iterator ) : count = 0 total = 0 for num in iterator : count += 1 total += num return float ( total ) / count", "docstring_tokens": "Iterative mean .", "label": 0}, {"idx": "cosqa-train-1928", "doc": "store python object in mongodb", "code": "def add_object(self, object):\n        \"\"\"Add object to db session. Only for session-centric object-database mappers.\"\"\"\n        if object.id is None:\n            object.get_id()\n        self.db.engine.save(object)", "code_tokens": "def add_object ( self , object ) : if object . id is None : object . get_id ( ) self . db . engine . save ( object )", "docstring_tokens": "Add object to db session . Only for session - centric object - database mappers .", "label": 0}, {"idx": "cosqa-train-1929", "doc": "python calculate distance cluster centroid", "code": "def _cal_dist2center(X, center):\n    \"\"\" Calculate the SSE to the cluster center\n    \"\"\"\n    dmemb2cen = scipy.spatial.distance.cdist(X, center.reshape(1,X.shape[1]), metric='seuclidean')\n    return(np.sum(dmemb2cen))", "code_tokens": "def _cal_dist2center ( X , center ) : dmemb2cen = scipy . spatial . distance . cdist ( X , center . reshape ( 1 , X . shape [ 1 ] ) , metric = 'seuclidean' ) return ( np . sum ( dmemb2cen ) )", "docstring_tokens": "Calculate the SSE to the cluster center", "label": 0}, {"idx": "cosqa-train-1930", "doc": "store sparse matrix in h5py python", "code": "def save_hdf5(X, y, path):\n    \"\"\"Save data as a HDF5 file.\n\n    Args:\n        X (numpy or scipy sparse matrix): Data matrix\n        y (numpy array): Target vector.\n        path (str): Path to the HDF5 file to save data.\n    \"\"\"\n\n    with h5py.File(path, 'w') as f:\n        is_sparse = 1 if sparse.issparse(X) else 0\n        f['issparse'] = is_sparse\n        f['target'] = y\n\n        if is_sparse:\n            if not sparse.isspmatrix_csr(X):\n                X = X.tocsr()\n\n            f['shape'] = np.array(X.shape)\n            f['data'] = X.data\n            f['indices'] = X.indices\n            f['indptr'] = X.indptr\n        else:\n            f['data'] = X", "code_tokens": "def save_hdf5 ( X , y , path ) : with h5py . File ( path , 'w' ) as f : is_sparse = 1 if sparse . issparse ( X ) else 0 f [ 'issparse' ] = is_sparse f [ 'target' ] = y if is_sparse : if not sparse . isspmatrix_csr ( X ) : X = X . tocsr ( ) f [ 'shape' ] = np . array ( X . shape ) f [ 'data' ] = X . data f [ 'indices' ] = X . indices f [ 'indptr' ] = X . indptr else : f [ 'data' ] = X", "docstring_tokens": "Save data as a HDF5 file .", "label": 0}, {"idx": "cosqa-train-1931", "doc": "python calculate eigenvector and eigenvalue of a matrix", "code": "def center_eigenvalue_diff(mat):\n    \"\"\"Compute the eigvals of mat and then find the center eigval difference.\"\"\"\n    N = len(mat)\n    evals = np.sort(la.eigvals(mat))\n    diff = np.abs(evals[N/2] - evals[N/2-1])\n    return diff", "code_tokens": "def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff", "docstring_tokens": "Compute the eigvals of mat and then find the center eigval difference .", "label": 0}, {"idx": "cosqa-train-1932", "doc": "storing gzip file contents in a variable in python", "code": "def get_gzipped_contents(input_file):\n    \"\"\"\n    Returns a gzipped version of a previously opened file's buffer.\n    \"\"\"\n    zbuf = StringIO()\n    zfile = GzipFile(mode=\"wb\", compresslevel=6, fileobj=zbuf)\n    zfile.write(input_file.read())\n    zfile.close()\n    return ContentFile(zbuf.getvalue())", "code_tokens": "def get_gzipped_contents ( input_file ) : zbuf = StringIO ( ) zfile = GzipFile ( mode = \"wb\" , compresslevel = 6 , fileobj = zbuf ) zfile . write ( input_file . read ( ) ) zfile . close ( ) return ContentFile ( zbuf . getvalue ( ) )", "docstring_tokens": "Returns a gzipped version of a previously opened file s buffer .", "label": 0}, {"idx": "cosqa-train-1933", "doc": "python calculate the angle between two points", "code": "def vec_angle(a, b):\n    \"\"\"\n    Calculate angle between two vectors\n    \"\"\"\n    cosang = np.dot(a, b)\n    sinang = fast_norm(np.cross(a, b))\n    return np.arctan2(sinang, cosang)", "code_tokens": "def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )", "docstring_tokens": "Calculate angle between two vectors", "label": 0}, {"idx": "cosqa-train-1934", "doc": "string, capitalize each alpha letter and do nothing on others python", "code": "def decamelise(text):\n    \"\"\"Convert CamelCase to lower_and_underscore.\"\"\"\n    s = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s).lower()", "code_tokens": "def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s ) . lower ( )", "docstring_tokens": "Convert CamelCase to lower_and_underscore .", "label": 0}, {"idx": "cosqa-train-1935", "doc": "python calculate time delta", "code": "def elapsed_time_from(start_time):\n    \"\"\"calculate time delta from latched time and current time\"\"\"\n    time_then = make_time(start_time)\n    time_now = datetime.utcnow().replace(microsecond=0)\n    if time_then is None:\n        return\n    delta_t = time_now - time_then\n    return delta_t", "code_tokens": "def elapsed_time_from ( start_time ) : time_then = make_time ( start_time ) time_now = datetime . utcnow ( ) . replace ( microsecond = 0 ) if time_then is None : return delta_t = time_now - time_then return delta_t", "docstring_tokens": "calculate time delta from latched time and current time", "label": 1}, {"idx": "cosqa-train-1936", "doc": "strip all letters except a word python", "code": "def _to_lower_alpha_only(s):\n    \"\"\"Return a lowercased string with non alphabetic chars removed.\n\n    White spaces are not to be removed.\"\"\"\n    s = re.sub(r'\\n', ' ',  s.lower())\n    return re.sub(r'[^a-z\\s]', '', s)", "code_tokens": "def _to_lower_alpha_only ( s ) : s = re . sub ( r'\\n' , ' ' , s . lower ( ) ) return re . sub ( r'[^a-z\\s]' , '' , s )", "docstring_tokens": "Return a lowercased string with non alphabetic chars removed .", "label": 1}, {"idx": "cosqa-train-1937", "doc": "python call a function using a variable in termiinal", "code": "def color_func(func_name):\n    \"\"\"\n    Call color function base on name\n    \"\"\"\n    if str(func_name).isdigit():\n        return term_color(int(func_name))\n    return globals()[func_name]", "code_tokens": "def color_func ( func_name ) : if str ( func_name ) . isdigit ( ) : return term_color ( int ( func_name ) ) return globals ( ) [ func_name ]", "docstring_tokens": "Call color function base on name", "label": 0}, {"idx": "cosqa-train-1938", "doc": "strips all leading and trailing space of each token in python list", "code": "def token_list_to_text(tokenlist):\n    \"\"\"\n    Concatenate all the text parts again.\n    \"\"\"\n    ZeroWidthEscape = Token.ZeroWidthEscape\n    return ''.join(item[1] for item in tokenlist if item[0] != ZeroWidthEscape)", "code_tokens": "def token_list_to_text ( tokenlist ) : ZeroWidthEscape = Token . ZeroWidthEscape return '' . join ( item [ 1 ] for item in tokenlist if item [ 0 ] != ZeroWidthEscape )", "docstring_tokens": "Concatenate all the text parts again .", "label": 0}, {"idx": "cosqa-train-1939", "doc": "python calling on random function wanting to to stay same", "code": "def sometimesish(fn):\n    \"\"\"\n    Has a 50/50 chance of calling a function\n    \"\"\"\n    def wrapped(*args, **kwargs):\n        if random.randint(1, 2) == 1:\n            return fn(*args, **kwargs)\n\n    return wrapped", "code_tokens": "def sometimesish ( fn ) : def wrapped ( * args , * * kwargs ) : if random . randint ( 1 , 2 ) == 1 : return fn ( * args , * * kwargs ) return wrapped", "docstring_tokens": "Has a 50 / 50 chance of calling a function", "label": 0}, {"idx": "cosqa-train-1940", "doc": "suppress help text python django", "code": "def help(self, level=0):\n        \"\"\"return the usage string for available options \"\"\"\n        self.cmdline_parser.formatter.output_level = level\n        with _patch_optparse():\n            return self.cmdline_parser.format_help()", "code_tokens": "def help ( self , level = 0 ) : self . cmdline_parser . formatter . output_level = level with _patch_optparse ( ) : return self . cmdline_parser . format_help ( )", "docstring_tokens": "return the usage string for available options", "label": 0}, {"idx": "cosqa-train-1941", "doc": "python can buffered reader", "code": "def next (self):    # File-like object.\n\n        \"\"\"This is to support iterators over a file-like object.\n        \"\"\"\n\n        result = self.readline()\n        if result == self._empty_buffer:\n            raise StopIteration\n        return result", "code_tokens": "def next ( self ) : # File-like object. result = self . readline ( ) if result == self . _empty_buffer : raise StopIteration return result", "docstring_tokens": "This is to support iterators over a file - like object .", "label": 1}, {"idx": "cosqa-train-1942", "doc": "swagger python adding an authorization header", "code": "def get_request(self, request):\n        \"\"\"Sets token-based auth headers.\"\"\"\n        request.transport_user = self.username\n        request.transport_password = self.api_key\n        return request", "code_tokens": "def get_request ( self , request ) : request . transport_user = self . username request . transport_password = self . api_key return request", "docstring_tokens": "Sets token - based auth headers .", "label": 0}, {"idx": "cosqa-train-1943", "doc": "python can none value be used outside of functions", "code": "def min_or_none(val1, val2):\n    \"\"\"Returns min(val1, val2) returning None only if both values are None\"\"\"\n    return min(val1, val2, key=lambda x: sys.maxint if x is None else x)", "code_tokens": "def min_or_none ( val1 , val2 ) : return min ( val1 , val2 , key = lambda x : sys . maxint if x is None else x )", "docstring_tokens": "Returns min ( val1 val2 ) returning None only if both values are None", "label": 0}, {"idx": "cosqa-train-1944", "doc": "switch the order of names in python", "code": "def get_order(self, codes):\n        \"\"\"Return evidence codes in order shown in code2name.\"\"\"\n        return sorted(codes, key=lambda e: [self.ev2idx.get(e)])", "code_tokens": "def get_order ( self , codes ) : return sorted ( codes , key = lambda e : [ self . ev2idx . get ( e ) ] )", "docstring_tokens": "Return evidence codes in order shown in code2name .", "label": 0}, {"idx": "cosqa-train-1945", "doc": "python can not exit in cmd", "code": "def call_and_exit(self, cmd, shell=True):\n        \"\"\"Run the *cmd* and exit with the proper exit code.\"\"\"\n        sys.exit(subprocess.call(cmd, shell=shell))", "code_tokens": "def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )", "docstring_tokens": "Run the * cmd * and exit with the proper exit code .", "label": 0}, {"idx": "cosqa-train-1946", "doc": "take the average array value not zero numpy python", "code": "def average(arr):\n  \"\"\"average of the values, must have more than 0 entries.\n\n  :param arr: list of numbers\n  :type arr: number[] a number array\n  :return: average\n  :rtype: float\n\n  \"\"\"\n  if len(arr) == 0:\n    sys.stderr.write(\"ERROR: no content in array to take average\\n\")\n    sys.exit()\n  if len(arr) == 1:  return arr[0]\n  return float(sum(arr))/float(len(arr))", "code_tokens": "def average ( arr ) : if len ( arr ) == 0 : sys . stderr . write ( \"ERROR: no content in array to take average\\n\" ) sys . exit ( ) if len ( arr ) == 1 : return arr [ 0 ] return float ( sum ( arr ) ) / float ( len ( arr ) )", "docstring_tokens": "average of the values must have more than 0 entries .", "label": 0}, {"idx": "cosqa-train-1947", "doc": "python canvas news scrolling", "code": "def _set_scroll_v(self, *args):\n        \"\"\"Scroll both categories Canvas and scrolling container\"\"\"\n        self._canvas_categories.yview(*args)\n        self._canvas_scroll.yview(*args)", "code_tokens": "def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "docstring_tokens": "Scroll both categories Canvas and scrolling container", "label": 0}, {"idx": "cosqa-train-1948", "doc": "tensorflow on python37 not running", "code": "def tf2():\n  \"\"\"Provide the root module of a TF-2.0 API for use within TensorBoard.\n\n  Returns:\n    The root module of a TF-2.0 API, if available.\n\n  Raises:\n    ImportError: if a TF-2.0 API is not available.\n  \"\"\"\n  # Import the `tf` compat API from this file and check if it's already TF 2.0.\n  if tf.__version__.startswith('2.'):\n    return tf\n  elif hasattr(tf, 'compat') and hasattr(tf.compat, 'v2'):\n    # As a fallback, try `tensorflow.compat.v2` if it's defined.\n    return tf.compat.v2\n  raise ImportError('cannot import tensorflow 2.0 API')", "code_tokens": "def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )", "docstring_tokens": "Provide the root module of a TF - 2 . 0 API for use within TensorBoard .", "label": 0}, {"idx": "cosqa-train-1949", "doc": "python capture results of a command", "code": "def _run_cmd_get_output(cmd):\n    \"\"\"Runs a shell command, returns console output.\n\n    Mimics python3's subprocess.getoutput\n    \"\"\"\n    process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)\n    out, err = process.communicate()\n    return out or err", "code_tokens": "def _run_cmd_get_output ( cmd ) : process = subprocess . Popen ( cmd . split ( ) , stdout = subprocess . PIPE ) out , err = process . communicate ( ) return out or err", "docstring_tokens": "Runs a shell command returns console output .", "label": 0}, {"idx": "cosqa-train-1950", "doc": "tensorflow with python2 and not python3", "code": "def tf2():\n  \"\"\"Provide the root module of a TF-2.0 API for use within TensorBoard.\n\n  Returns:\n    The root module of a TF-2.0 API, if available.\n\n  Raises:\n    ImportError: if a TF-2.0 API is not available.\n  \"\"\"\n  # Import the `tf` compat API from this file and check if it's already TF 2.0.\n  if tf.__version__.startswith('2.'):\n    return tf\n  elif hasattr(tf, 'compat') and hasattr(tf.compat, 'v2'):\n    # As a fallback, try `tensorflow.compat.v2` if it's defined.\n    return tf.compat.v2\n  raise ImportError('cannot import tensorflow 2.0 API')", "code_tokens": "def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )", "docstring_tokens": "Provide the root module of a TF - 2 . 0 API for use within TensorBoard .", "label": 1}, {"idx": "cosqa-train-1951", "doc": "python cartesian product list comprehension", "code": "def cartesian_product(arrays, flat=True, copy=False):\n    \"\"\"\n    Efficient cartesian product of a list of 1D arrays returning the\n    expanded array views for each dimensions. By default arrays are\n    flattened, which may be controlled with the flat flag. The array\n    views can be turned into regular arrays with the copy flag.\n    \"\"\"\n    arrays = np.broadcast_arrays(*np.ix_(*arrays))\n    if flat:\n        return tuple(arr.flatten() if copy else arr.flat for arr in arrays)\n    return tuple(arr.copy() if copy else arr for arr in arrays)", "code_tokens": "def cartesian_product ( arrays , flat = True , copy = False ) : arrays = np . broadcast_arrays ( * np . ix_ ( * arrays ) ) if flat : return tuple ( arr . flatten ( ) if copy else arr . flat for arr in arrays ) return tuple ( arr . copy ( ) if copy else arr for arr in arrays )", "docstring_tokens": "Efficient cartesian product of a list of 1D arrays returning the expanded array views for each dimensions . By default arrays are flattened which may be controlled with the flat flag . The array views can be turned into regular arrays with the copy flag .", "label": 0}, {"idx": "cosqa-train-1952", "doc": "test if attribute exists python", "code": "def has_attribute(module_name, attribute_name):\n    \"\"\"Is this attribute present?\"\"\"\n    init_file = '%s/__init__.py' % module_name\n    return any(\n        [attribute_name in init_line for init_line in open(init_file).readlines()]\n    )", "code_tokens": "def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )", "docstring_tokens": "Is this attribute present?", "label": 0}, {"idx": "cosqa-train-1953", "doc": "python cast numpy array to bool", "code": "def is_bool_matrix(l):\n    r\"\"\"Checks if l is a 2D numpy array of bools\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 2 and (l.dtype == bool):\n            return True\n    return False", "code_tokens": "def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False", "docstring_tokens": "r Checks if l is a 2D numpy array of bools", "label": 1}, {"idx": "cosqa-train-1954", "doc": "test if strings match python", "code": "def match(string, patterns):\n    \"\"\"Given a string return true if it matches the supplied list of\n    patterns.\n\n    Parameters\n    ----------\n    string : str\n        The string to be matched.\n    patterns : None or [pattern, ...]\n        The series of regular expressions to attempt to match.\n    \"\"\"\n    if patterns is None:\n        return True\n    else:\n        return any(re.match(pattern, string)\n                   for pattern in patterns)", "code_tokens": "def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )", "docstring_tokens": "Given a string return true if it matches the supplied list of patterns .", "label": 0}, {"idx": "cosqa-train-1955", "doc": "python cast raw bytes as object", "code": "def loadb(b):\n    \"\"\"Deserialize ``b`` (instance of ``bytes``) to a Python object.\"\"\"\n    assert isinstance(b, (bytes, bytearray))\n    return std_json.loads(b.decode('utf-8'))", "code_tokens": "def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )", "docstring_tokens": "Deserialize b ( instance of bytes ) to a Python object .", "label": 1}, {"idx": "cosqa-train-1956", "doc": "text into tokenized python", "code": "def tokenize_list(self, text):\n        \"\"\"\n        Split a text into separate words.\n        \"\"\"\n        return [self.get_record_token(record) for record in self.analyze(text)]", "code_tokens": "def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]", "docstring_tokens": "Split a text into separate words .", "label": 0}, {"idx": "cosqa-train-1957", "doc": "python cast string into date", "code": "def deserialize_date(string):\n    \"\"\"\n    Deserializes string to date.\n\n    :param string: str.\n    :type string: str\n    :return: date.\n    :rtype: date\n    \"\"\"\n    try:\n        from dateutil.parser import parse\n        return parse(string).date()\n    except ImportError:\n        return string", "code_tokens": "def deserialize_date ( string ) : try : from dateutil . parser import parse return parse ( string ) . date ( ) except ImportError : return string", "docstring_tokens": "Deserializes string to date .", "label": 0}, {"idx": "cosqa-train-1958", "doc": "text removing illegal charcater in python", "code": "def strip_accents(text):\n    \"\"\"\n    Strip agents from a string.\n    \"\"\"\n\n    normalized_str = unicodedata.normalize('NFD', text)\n\n    return ''.join([\n        c for c in normalized_str if unicodedata.category(c) != 'Mn'])", "code_tokens": "def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "docstring_tokens": "Strip agents from a string .", "label": 1}, {"idx": "cosqa-train-1959", "doc": "python chain multiple function", "code": "def compose(*funcs):\n    \"\"\"compose a list of functions\"\"\"\n    return lambda x: reduce(lambda v, f: f(v), reversed(funcs), x)", "code_tokens": "def compose ( * funcs ) : return lambda x : reduce ( lambda v , f : f ( v ) , reversed ( funcs ) , x )", "docstring_tokens": "compose a list of functions", "label": 0}, {"idx": "cosqa-train-1960", "doc": "tf stack and unstack python", "code": "def flatten_all_but_last(a):\n  \"\"\"Flatten all dimensions of a except the last.\"\"\"\n  ret = tf.reshape(a, [-1, tf.shape(a)[-1]])\n  if not tf.executing_eagerly():\n    ret.set_shape([None] + a.get_shape().as_list()[-1:])\n  return ret", "code_tokens": "def flatten_all_but_last ( a ) : ret = tf . reshape ( a , [ - 1 , tf . shape ( a ) [ - 1 ] ] ) if not tf . executing_eagerly ( ) : ret . set_shape ( [ None ] + a . get_shape ( ) . as_list ( ) [ - 1 : ] ) return ret", "docstring_tokens": "Flatten all dimensions of a except the last .", "label": 0}, {"idx": "cosqa-train-1961", "doc": "python chain next iterable", "code": "def concat(cls, iterables):\n    \"\"\"\n    Similar to #itertools.chain.from_iterable().\n    \"\"\"\n\n    def generator():\n      for it in iterables:\n        for element in it:\n          yield element\n    return cls(generator())", "code_tokens": "def concat ( cls , iterables ) : def generator ( ) : for it in iterables : for element in it : yield element return cls ( generator ( ) )", "docstring_tokens": "Similar to #itertools . chain . from_iterable () .", "label": 0}, {"idx": "cosqa-train-1962", "doc": "the inde of the max in python", "code": "def max(self):\n        \"\"\"\n        Returns the maximum value of the domain.\n\n        :rtype: `float` or `np.inf`\n        \"\"\"\n        return int(self._max) if not np.isinf(self._max) else self._max", "code_tokens": "def max ( self ) : return int ( self . _max ) if not np . isinf ( self . _max ) else self . _max", "docstring_tokens": "Returns the maximum value of the domain .", "label": 0}, {"idx": "cosqa-train-1963", "doc": "python change background color in grid", "code": "def OnCellBackgroundColor(self, event):\n        \"\"\"Cell background color event handler\"\"\"\n\n        with undo.group(_(\"Background color\")):\n            self.grid.actions.set_attr(\"bgcolor\", event.color)\n\n        self.grid.ForceRefresh()\n\n        self.grid.update_attribute_toolbar()\n\n        event.Skip()", "code_tokens": "def OnCellBackgroundColor ( self , event ) : with undo . group ( _ ( \"Background color\" ) ) : self . grid . actions . set_attr ( \"bgcolor\" , event . color ) self . grid . ForceRefresh ( ) self . grid . update_attribute_toolbar ( ) event . Skip ( )", "docstring_tokens": "Cell background color event handler", "label": 0}, {"idx": "cosqa-train-1964", "doc": "the length of the longest run of consecutive heads python", "code": "def longest_run(da, dim='time'):\n    \"\"\"Return the length of the longest consecutive run of True values.\n\n        Parameters\n        ----------\n        arr : N-dimensional array (boolean)\n          Input array\n        dim : Xarray dimension (default = 'time')\n          Dimension along which to calculate consecutive run\n\n        Returns\n        -------\n        N-dimensional array (int)\n          Length of longest run of True values along dimension\n        \"\"\"\n\n    d = rle(da, dim=dim)\n    rl_long = d.max(dim=dim)\n\n    return rl_long", "code_tokens": "def longest_run ( da , dim = 'time' ) : d = rle ( da , dim = dim ) rl_long = d . max ( dim = dim ) return rl_long", "docstring_tokens": "Return the length of the longest consecutive run of True values .", "label": 0}, {"idx": "cosqa-train-1965", "doc": "python change directory to my documents", "code": "def build_docs(directory):\n    \"\"\"Builds sphinx docs from a given directory.\"\"\"\n    os.chdir(directory)\n    process = subprocess.Popen([\"make\", \"html\"], cwd=directory)\n    process.communicate()", "code_tokens": "def build_docs ( directory ) : os . chdir ( directory ) process = subprocess . Popen ( [ \"make\" , \"html\" ] , cwd = directory ) process . communicate ( )", "docstring_tokens": "Builds sphinx docs from a given directory .", "label": 0}, {"idx": "cosqa-train-1966", "doc": "the scope of variables inside a function is local to the python function", "code": "def ex(self, cmd):\n        \"\"\"Execute a normal python statement in user namespace.\"\"\"\n        with self.builtin_trap:\n            exec cmd in self.user_global_ns, self.user_ns", "code_tokens": "def ex ( self , cmd ) : with self . builtin_trap : exec cmd in self . user_global_ns , self . user_ns", "docstring_tokens": "Execute a normal python statement in user namespace .", "label": 0}, {"idx": "cosqa-train-1967", "doc": "python change maximun line length", "code": "def _multiline_width(multiline_s, line_width_fn=len):\n    \"\"\"Visible width of a potentially multiline content.\"\"\"\n    return max(map(line_width_fn, re.split(\"[\\r\\n]\", multiline_s)))", "code_tokens": "def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( \"[\\r\\n]\" , multiline_s ) ) )", "docstring_tokens": "Visible width of a potentially multiline content .", "label": 1}, {"idx": "cosqa-train-1968", "doc": "thread safety in python pdf", "code": "def append_pdf(input_pdf: bytes, output_writer: PdfFileWriter):\n    \"\"\"\n    Appends a PDF to a pyPDF writer. Legacy interface.\n    \"\"\"\n    append_memory_pdf_to_writer(input_pdf=input_pdf,\n                                writer=output_writer)", "code_tokens": "def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )", "docstring_tokens": "Appends a PDF to a pyPDF writer . Legacy interface .", "label": 0}, {"idx": "cosqa-train-1969", "doc": "python change mtime of file", "code": "def set_time(filename, mod_time):\n\t\"\"\"\n\tSet the modified time of a file\n\t\"\"\"\n\tlog.debug('Setting modified time to %s', mod_time)\n\tmtime = calendar.timegm(mod_time.utctimetuple())\n\t# utctimetuple discards microseconds, so restore it (for consistency)\n\tmtime += mod_time.microsecond / 1000000\n\tatime = os.stat(filename).st_atime\n\tos.utime(filename, (atime, mtime))", "code_tokens": "def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)\n mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )", "docstring_tokens": "Set the modified time of a file", "label": 0}, {"idx": "cosqa-train-1970", "doc": "timestramp datetime localtime python", "code": "def convert_tstamp(response):\n\t\"\"\"\n\tConvert a Stripe API timestamp response (unix epoch) to a native datetime.\n\n\t:rtype: datetime\n\t\"\"\"\n\tif response is None:\n\t\t# Allow passing None to convert_tstamp()\n\t\treturn response\n\n\t# Overrides the set timezone to UTC - I think...\n\ttz = timezone.utc if settings.USE_TZ else None\n\n\treturn datetime.datetime.fromtimestamp(response, tz)", "code_tokens": "def convert_tstamp ( response ) : if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = timezone . utc if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz )", "docstring_tokens": "Convert a Stripe API timestamp response ( unix epoch ) to a native datetime .", "label": 1}, {"idx": "cosqa-train-1971", "doc": "python change name of a column", "code": "def col_rename(df,col_name,new_col_name):\n    \"\"\" Changes a column name in a DataFrame\n    Parameters:\n    df - DataFrame\n        DataFrame to operate on\n    col_name - string\n        Name of column to change\n    new_col_name - string\n        New name of column\n    \"\"\"\n    col_list = list(df.columns)\n    for index,value in enumerate(col_list):\n        if value == col_name:\n            col_list[index] = new_col_name\n            break\n    df.columns = col_list", "code_tokens": "def col_rename ( df , col_name , new_col_name ) : col_list = list ( df . columns ) for index , value in enumerate ( col_list ) : if value == col_name : col_list [ index ] = new_col_name break df . columns = col_list", "docstring_tokens": "Changes a column name in a DataFrame Parameters : df - DataFrame DataFrame to operate on col_name - string Name of column to change new_col_name - string New name of column", "label": 0}, {"idx": "cosqa-train-1972", "doc": "tkinter python deselect check button", "code": "def checkbox_uncheck(self, force_check=False):\n        \"\"\"\n        Wrapper to uncheck a checkbox\n        \"\"\"\n        if self.get_attribute('checked'):\n            self.click(force_click=force_check)", "code_tokens": "def checkbox_uncheck ( self , force_check = False ) : if self . get_attribute ( 'checked' ) : self . click ( force_click = force_check )", "docstring_tokens": "Wrapper to uncheck a checkbox", "label": 0}, {"idx": "cosqa-train-1973", "doc": "python change numpy dtype to python type", "code": "def dict_to_numpy_array(d):\n    \"\"\"\n    Convert a dict of 1d array to a numpy recarray\n    \"\"\"\n    return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))", "code_tokens": "def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )", "docstring_tokens": "Convert a dict of 1d array to a numpy recarray", "label": 1}, {"idx": "cosqa-train-1974", "doc": "to array function python", "code": "def adapt_array(arr):\n    \"\"\"\n    http://stackoverflow.com/a/31312102/190597 (SoulNibbler)\n    \"\"\"\n    out = io.BytesIO()\n    np.save(out, arr)\n    out.seek(0)\n    return sqlite3.Binary(out.read())", "code_tokens": "def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) out . seek ( 0 ) return sqlite3 . Binary ( out . read ( ) )", "docstring_tokens": "http : // stackoverflow . com / a / 31312102 / 190597 ( SoulNibbler )", "label": 0}, {"idx": "cosqa-train-1975", "doc": "python change oauth2 flask expire time", "code": "def __set_token_expired(self, value):\n        \"\"\"Internal helper for oauth code\"\"\"\n        self._token_expired = datetime.datetime.now() + datetime.timedelta(seconds=value)\n        return", "code_tokens": "def __set_token_expired ( self , value ) : self . _token_expired = datetime . datetime . now ( ) + datetime . timedelta ( seconds = value ) return", "docstring_tokens": "Internal helper for oauth code", "label": 0}, {"idx": "cosqa-train-1976", "doc": "to check if object doesnt have attribute key python", "code": "def check_attribute_exists(instance):\n    \"\"\" Additional check for the dimension model, to ensure that attributes\n    given as the key and label attribute on the dimension exist. \"\"\"\n    attributes = instance.get('attributes', {}).keys()\n    if instance.get('key_attribute') not in attributes:\n        return False\n    label_attr = instance.get('label_attribute')\n    if label_attr and label_attr not in attributes:\n        return False\n    return True", "code_tokens": "def check_attribute_exists ( instance ) : attributes = instance . get ( 'attributes' , { } ) . keys ( ) if instance . get ( 'key_attribute' ) not in attributes : return False label_attr = instance . get ( 'label_attribute' ) if label_attr and label_attr not in attributes : return False return True", "docstring_tokens": "Additional check for the dimension model to ensure that attributes given as the key and label attribute on the dimension exist .", "label": 0}, {"idx": "cosqa-train-1977", "doc": "python change the global stdout", "code": "def redirect_output(fileobj):\n    \"\"\"Redirect standard out to file.\"\"\"\n    old = sys.stdout\n    sys.stdout = fileobj\n    try:\n        yield fileobj\n    finally:\n        sys.stdout = old", "code_tokens": "def redirect_output ( fileobj ) : old = sys . stdout sys . stdout = fileobj try : yield fileobj finally : sys . stdout = old", "docstring_tokens": "Redirect standard out to file .", "label": 0}, {"idx": "cosqa-train-1978", "doc": "to check if object doesnt have attribute variable python", "code": "def hasattrs(object, *names):\n    \"\"\"\n    Takes in an object and a variable length amount of named attributes,\n    and checks to see if the object has each property. If any of the\n    attributes are missing, this returns false.\n\n    :param object: an object that may or may not contain the listed attributes\n    :param names: a variable amount of attribute names to check for\n    :return: True if the object contains each named attribute, false otherwise\n    \"\"\"\n    for name in names:\n        if not hasattr(object, name):\n            return False\n    return True", "code_tokens": "def hasattrs ( object , * names ) : for name in names : if not hasattr ( object , name ) : return False return True", "docstring_tokens": "Takes in an object and a variable length amount of named attributes and checks to see if the object has each property . If any of the attributes are missing this returns false .", "label": 1}, {"idx": "cosqa-train-1979", "doc": "python change to a dir", "code": "def dir_path(dir):\n    \"\"\"with dir_path(path) to change into a directory.\"\"\"\n    old_dir = os.getcwd()\n    os.chdir(dir)\n    yield\n    os.chdir(old_dir)", "code_tokens": "def dir_path ( dir ) : old_dir = os . getcwd ( ) os . chdir ( dir ) yield os . chdir ( old_dir )", "docstring_tokens": "with dir_path ( path ) to change into a directory .", "label": 0}, {"idx": "cosqa-train-1980", "doc": "to get index based on values in python list", "code": "def bisect_index(a, x):\n    \"\"\" Find the leftmost index of an element in a list using binary search.\n\n    Parameters\n    ----------\n    a: list\n        A sorted list.\n    x: arbitrary\n        The element.\n\n    Returns\n    -------\n    int\n        The index.\n\n    \"\"\"\n    i = bisect.bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    raise ValueError", "code_tokens": "def bisect_index ( a , x ) : i = bisect . bisect_left ( a , x ) if i != len ( a ) and a [ i ] == x : return i raise ValueError", "docstring_tokens": "Find the leftmost index of an element in a list using binary search .", "label": 0}, {"idx": "cosqa-train-1981", "doc": "python change to su from admin", "code": "def save_form(self, request, form, change):\n        \"\"\"\n        Super class ordering is important here - user must get saved first.\n        \"\"\"\n        OwnableAdmin.save_form(self, request, form, change)\n        return DisplayableAdmin.save_form(self, request, form, change)", "code_tokens": "def save_form ( self , request , form , change ) : OwnableAdmin . save_form ( self , request , form , change ) return DisplayableAdmin . save_form ( self , request , form , change )", "docstring_tokens": "Super class ordering is important here - user must get saved first .", "label": 0}, {"idx": "cosqa-train-1982", "doc": "to get the next line in python", "code": "def __next__(self):\n        \"\"\"\n\n        :return: a pair (1-based line number in the input, row)\n        \"\"\"\n        # Retrieve the row, thereby incrementing the line number:\n        row = super(UnicodeReaderWithLineNumber, self).__next__()\n        return self.lineno + 1, row", "code_tokens": "def __next__ ( self ) : # Retrieve the row, thereby incrementing the line number: row = super ( UnicodeReaderWithLineNumber , self ) . __next__ ( ) return self . lineno + 1 , row", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-1983", "doc": "python change type to string", "code": "def check_str(obj):\n        \"\"\" Returns a string for various input types \"\"\"\n        if isinstance(obj, str):\n            return obj\n        if isinstance(obj, float):\n            return str(int(obj))\n        else:\n            return str(obj)", "code_tokens": "def check_str ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , float ) : return str ( int ( obj ) ) else : return str ( obj )", "docstring_tokens": "Returns a string for various input types", "label": 0}, {"idx": "cosqa-train-1984", "doc": "to plot gaussian distribution in python", "code": "def gaussian_variogram_model(m, d):\n    \"\"\"Gaussian model, m is [psill, range, nugget]\"\"\"\n    psill = float(m[0])\n    range_ = float(m[1])\n    nugget = float(m[2])\n    return psill * (1. - np.exp(-d**2./(range_*4./7.)**2.)) + nugget", "code_tokens": "def gaussian_variogram_model ( m , d ) : psill = float ( m [ 0 ] ) range_ = float ( m [ 1 ] ) nugget = float ( m [ 2 ] ) return psill * ( 1. - np . exp ( - d ** 2. / ( range_ * 4. / 7. ) ** 2. ) ) + nugget", "docstring_tokens": "Gaussian model m is [ psill range nugget ]", "label": 0}, {"idx": "cosqa-train-1985", "doc": "python change window title", "code": "def title(msg):\n    \"\"\"Sets the title of the console window.\"\"\"\n    if sys.platform.startswith(\"win\"):\n        ctypes.windll.kernel32.SetConsoleTitleW(tounicode(msg))", "code_tokens": "def title ( msg ) : if sys . platform . startswith ( \"win\" ) : ctypes . windll . kernel32 . SetConsoleTitleW ( tounicode ( msg ) )", "docstring_tokens": "Sets the title of the console window .", "label": 1}, {"idx": "cosqa-train-1986", "doc": "to write function of gradient of an image in python", "code": "def average_gradient(data, *kwargs):\n    \"\"\" Compute average gradient norm of an image\n    \"\"\"\n    return np.average(np.array(np.gradient(data))**2)", "code_tokens": "def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )", "docstring_tokens": "Compute average gradient norm of an image", "label": 0}, {"idx": "cosqa-train-1987", "doc": "python changing any amount of seconds into hours minutes and seconds", "code": "def pprint(self, seconds):\n        \"\"\"\n        Pretty Prints seconds as Hours:Minutes:Seconds.MilliSeconds\n\n        :param seconds:  The time in seconds.\n        \"\"\"\n        return (\"%d:%02d:%02d.%03d\", reduce(lambda ll, b: divmod(ll[0], b) + ll[1:], [(seconds * 1000,), 1000, 60, 60]))", "code_tokens": "def pprint ( self , seconds ) : return ( \"%d:%02d:%02d.%03d\" , reduce ( lambda ll , b : divmod ( ll [ 0 ] , b ) + ll [ 1 : ] , [ ( seconds * 1000 , ) , 1000 , 60 , 60 ] ) )", "docstring_tokens": "Pretty Prints seconds as Hours : Minutes : Seconds . MilliSeconds", "label": 0}, {"idx": "cosqa-train-1988", "doc": "tokenize without creating a list python", "code": "def tokenize(string):\n    \"\"\"Match and yield all the tokens of the input string.\"\"\"\n    for match in TOKENS_REGEX.finditer(string):\n        yield Token(match.lastgroup, match.group().strip(), match.span())", "code_tokens": "def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "docstring_tokens": "Match and yield all the tokens of the input string .", "label": 0}, {"idx": "cosqa-train-1989", "doc": "python characters truncated in mssql query", "code": "def _escape(s):\n    \"\"\" Helper method that escapes parameters to a SQL query. \"\"\"\n    e = s\n    e = e.replace('\\\\', '\\\\\\\\')\n    e = e.replace('\\n', '\\\\n')\n    e = e.replace('\\r', '\\\\r')\n    e = e.replace(\"'\", \"\\\\'\")\n    e = e.replace('\"', '\\\\\"')\n    return e", "code_tokens": "def _escape ( s ) : e = s e = e . replace ( '\\\\' , '\\\\\\\\' ) e = e . replace ( '\\n' , '\\\\n' ) e = e . replace ( '\\r' , '\\\\r' ) e = e . replace ( \"'\" , \"\\\\'\" ) e = e . replace ( '\"' , '\\\\\"' ) return e", "docstring_tokens": "Helper method that escapes parameters to a SQL query .", "label": 0}, {"idx": "cosqa-train-1990", "doc": "transform data to normal distribution python", "code": "def normalize(data):\n    \"\"\"\n    Function to normalize data to have mean 0 and unity standard deviation\n    (also called z-transform)\n    \n    \n    Parameters\n    ----------\n    data : numpy.ndarray\n    \n    \n    Returns\n    -------\n    numpy.ndarray\n        z-transform of input array\n    \n    \"\"\"\n    data = data.astype(float)\n    data -= data.mean()\n    \n    return data / data.std()", "code_tokens": "def normalize ( data ) : data = data . astype ( float ) data -= data . mean ( ) return data / data . std ( )", "docstring_tokens": "Function to normalize data to have mean 0 and unity standard deviation ( also called z - transform ) Parameters ---------- data : numpy . ndarray Returns ------- numpy . ndarray z - transform of input array", "label": 0}, {"idx": "cosqa-train-1991", "doc": "python check against a list of regular expressions", "code": "def match(string, patterns):\n    \"\"\"Given a string return true if it matches the supplied list of\n    patterns.\n\n    Parameters\n    ----------\n    string : str\n        The string to be matched.\n    patterns : None or [pattern, ...]\n        The series of regular expressions to attempt to match.\n    \"\"\"\n    if patterns is None:\n        return True\n    else:\n        return any(re.match(pattern, string)\n                   for pattern in patterns)", "code_tokens": "def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )", "docstring_tokens": "Given a string return true if it matches the supplied list of patterns .", "label": 0}, {"idx": "cosqa-train-1992", "doc": "transform tuple to dict in python", "code": "def dictify(a_named_tuple):\n    \"\"\"Transform a named tuple into a dictionary\"\"\"\n    return dict((s, getattr(a_named_tuple, s)) for s in a_named_tuple._fields)", "code_tokens": "def dictify ( a_named_tuple ) : return dict ( ( s , getattr ( a_named_tuple , s ) ) for s in a_named_tuple . _fields )", "docstring_tokens": "Transform a named tuple into a dictionary", "label": 0}, {"idx": "cosqa-train-1993", "doc": "python check all inputs for type", "code": "def isnumber(*args):\n    \"\"\"Checks if value is an integer, long integer or float.\n\n    NOTE: Treats booleans as numbers, where True=1 and False=0.\n    \"\"\"\n    return all(map(lambda c: isinstance(c, int) or isinstance(c, float), args))", "code_tokens": "def isnumber ( * args ) : return all ( map ( lambda c : isinstance ( c , int ) or isinstance ( c , float ) , args ) )", "docstring_tokens": "Checks if value is an integer long integer or float .", "label": 1}, {"idx": "cosqa-train-1994", "doc": "tree recursion python print", "code": "def print_tree(self, indent=2):\n        \"\"\" print_tree: prints out structure of tree\n            Args: indent (int): What level of indentation at which to start printing\n            Returns: None\n        \"\"\"\n        config.LOGGER.info(\"{indent}{data}\".format(indent=\"   \" * indent, data=str(self)))\n        for child in self.children:\n            child.print_tree(indent + 1)", "code_tokens": "def print_tree ( self , indent = 2 ) : config . LOGGER . info ( \"{indent}{data}\" . format ( indent = \"   \" * indent , data = str ( self ) ) ) for child in self . children : child . print_tree ( indent + 1 )", "docstring_tokens": "print_tree : prints out structure of tree Args : indent ( int ) : What level of indentation at which to start printing Returns : None", "label": 0}, {"idx": "cosqa-train-1995", "doc": "python check file size greater than 0", "code": "def is_readable(fp, size=1):\n    \"\"\"\n    Check if the file-like object is readable.\n\n    :param fp: file-like object\n    :param size: byte size\n    :return: bool\n    \"\"\"\n    read_size = len(fp.read(size))\n    fp.seek(-read_size, 1)\n    return read_size == size", "code_tokens": "def is_readable ( fp , size = 1 ) : read_size = len ( fp . read ( size ) ) fp . seek ( - read_size , 1 ) return read_size == size", "docstring_tokens": "Check if the file - like object is readable .", "label": 0}, {"idx": "cosqa-train-1996", "doc": "trim head from list python", "code": "def strip_head(sequence, values):\n    \"\"\"Strips elements of `values` from the beginning of `sequence`.\"\"\"\n    values = set(values)\n    return list(itertools.dropwhile(lambda x: x in values, sequence))", "code_tokens": "def strip_head ( sequence , values ) : values = set ( values ) return list ( itertools . dropwhile ( lambda x : x in values , sequence ) )", "docstring_tokens": "Strips elements of values from the beginning of sequence .", "label": 0}, {"idx": "cosqa-train-1997", "doc": "python check folder exists and create", "code": "def check_create_folder(filename):\n    \"\"\"Check if the folder exisits. If not, create the folder\"\"\"\n    os.makedirs(os.path.dirname(filename), exist_ok=True)", "code_tokens": "def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )", "docstring_tokens": "Check if the folder exisits . If not create the folder", "label": 0}, {"idx": "cosqa-train-1998", "doc": "trun object into dictionary python", "code": "def to_dict(self):\n        \"\"\"Converts the table to a dict.\"\"\"\n        return {\"name\": self.table_name, \"kind\": self.table_kind, \"data\": [r.to_dict() for r in self]}", "code_tokens": "def to_dict ( self ) : return { \"name\" : self . table_name , \"kind\" : self . table_kind , \"data\" : [ r . to_dict ( ) for r in self ] }", "docstring_tokens": "Converts the table to a dict .", "label": 0}, {"idx": "cosqa-train-1999", "doc": "python check for existence of attribute", "code": "def has_attribute(module_name, attribute_name):\n    \"\"\"Is this attribute present?\"\"\"\n    init_file = '%s/__init__.py' % module_name\n    return any(\n        [attribute_name in init_line for init_line in open(init_file).readlines()]\n    )", "code_tokens": "def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )", "docstring_tokens": "Is this attribute present?", "label": 0}, {"idx": "cosqa-train-2000", "doc": "truncate a python list by one", "code": "def _crop_list_to_size(l, size):\n    \"\"\"Make a list a certain size\"\"\"\n    for x in range(size - len(l)):\n        l.append(False)\n    for x in range(len(l) - size):\n        l.pop()\n    return l", "code_tokens": "def _crop_list_to_size ( l , size ) : for x in range ( size - len ( l ) ) : l . append ( False ) for x in range ( len ( l ) - size ) : l . pop ( ) return l", "docstring_tokens": "Make a list a certain size", "label": 0}, {"idx": "cosqa-train-2001", "doc": "python check for presence of srting in forst word of a line", "code": "def isin_alone(elems, line):\n    \"\"\"Check if an element from a list is the only element of a string.\n\n    :type elems: list\n    :type line: str\n\n    \"\"\"\n    found = False\n    for e in elems:\n        if line.strip().lower() == e.lower():\n            found = True\n            break\n    return found", "code_tokens": "def isin_alone ( elems , line ) : found = False for e in elems : if line . strip ( ) . lower ( ) == e . lower ( ) : found = True break return found", "docstring_tokens": "Check if an element from a list is the only element of a string .", "label": 0}, {"idx": "cosqa-train-2002", "doc": "turn a key into a string varible name python", "code": "def unit_key_from_name(name):\n  \"\"\"Return a legal python name for the given name for use as a unit key.\"\"\"\n  result = name\n\n  for old, new in six.iteritems(UNIT_KEY_REPLACEMENTS):\n    result = result.replace(old, new)\n\n  # Collapse redundant underscores and convert to uppercase.\n  result = re.sub(r'_+', '_', result.upper())\n\n  return result", "code_tokens": "def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result", "docstring_tokens": "Return a legal python name for the given name for use as a unit key .", "label": 0}, {"idx": "cosqa-train-2003", "doc": "python check for string or list", "code": "def is_iter_non_string(obj):\n    \"\"\"test if object is a list or tuple\"\"\"\n    if isinstance(obj, list) or isinstance(obj, tuple):\n        return True\n    return False", "code_tokens": "def is_iter_non_string ( obj ) : if isinstance ( obj , list ) or isinstance ( obj , tuple ) : return True return False", "docstring_tokens": "test if object is a list or tuple", "label": 0}, {"idx": "cosqa-train-2004", "doc": "turn bytes to int python", "code": "def string_to_int( s ):\n  \"\"\"Convert a string of bytes into an integer, as per X9.62.\"\"\"\n  result = 0\n  for c in s:\n    if not isinstance(c, int): c = ord( c )\n    result = 256 * result + c\n  return result", "code_tokens": "def string_to_int ( s ) : result = 0 for c in s : if not isinstance ( c , int ) : c = ord ( c ) result = 256 * result + c return result", "docstring_tokens": "Convert a string of bytes into an integer as per X9 . 62 .", "label": 0}, {"idx": "cosqa-train-2005", "doc": "python check for valid uuid4", "code": "def valid_uuid(value):\n    \"\"\" Check if value is a valid UUID. \"\"\"\n\n    try:\n        uuid.UUID(value, version=4)\n        return True\n    except (TypeError, ValueError, AttributeError):\n        return False", "code_tokens": "def valid_uuid ( value ) : try : uuid . UUID ( value , version = 4 ) return True except ( TypeError , ValueError , AttributeError ) : return False", "docstring_tokens": "Check if value is a valid UUID .", "label": 1}, {"idx": "cosqa-train-2006", "doc": "turn def to data frame python", "code": "def to_dataframe(products):\n        \"\"\"Return the products from a query response as a Pandas DataFrame\n        with the values in their appropriate Python types.\n        \"\"\"\n        try:\n            import pandas as pd\n        except ImportError:\n            raise ImportError(\"to_dataframe requires the optional dependency Pandas.\")\n\n        return pd.DataFrame.from_dict(products, orient='index')", "code_tokens": "def to_dataframe ( products ) : try : import pandas as pd except ImportError : raise ImportError ( \"to_dataframe requires the optional dependency Pandas.\" ) return pd . DataFrame . from_dict ( products , orient = 'index' )", "docstring_tokens": "Return the products from a query response as a Pandas DataFrame with the values in their appropriate Python types .", "label": 0}, {"idx": "cosqa-train-2007", "doc": "python check if a directory is writable", "code": "def _writable_dir(path):\n    \"\"\"Whether `path` is a directory, to which the user has write access.\"\"\"\n    return os.path.isdir(path) and os.access(path, os.W_OK)", "code_tokens": "def _writable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . W_OK )", "docstring_tokens": "Whether path is a directory to which the user has write access .", "label": 1}, {"idx": "cosqa-train-2008", "doc": "turn mac address into ip python", "code": "def _get_ipv4_from_binary(self, bin_addr):\n        \"\"\"Converts binary address to Ipv4 format.\"\"\"\n\n        return socket.inet_ntop(socket.AF_INET, struct.pack(\"!L\", bin_addr))", "code_tokens": "def _get_ipv4_from_binary ( self , bin_addr ) : return socket . inet_ntop ( socket . AF_INET , struct . pack ( \"!L\" , bin_addr ) )", "docstring_tokens": "Converts binary address to Ipv4 format .", "label": 0}, {"idx": "cosqa-train-2009", "doc": "python check if a path is symlink", "code": "def is_symlink(self):\n        \"\"\"\n        Whether this path is a symbolic link.\n        \"\"\"\n        try:\n            return S_ISLNK(self.lstat().st_mode)\n        except OSError as e:\n            if e.errno != ENOENT:\n                raise\n            # Path doesn't exist\n            return False", "code_tokens": "def is_symlink ( self ) : try : return S_ISLNK ( self . lstat ( ) . st_mode ) except OSError as e : if e . errno != ENOENT : raise # Path doesn't exist return False", "docstring_tokens": "Whether this path is a symbolic link .", "label": 0}, {"idx": "cosqa-train-2010", "doc": "turning datetime t ostring python", "code": "def dt_to_ts(value):\n    \"\"\" If value is a datetime, convert to timestamp \"\"\"\n    if not isinstance(value, datetime):\n        return value\n    return calendar.timegm(value.utctimetuple()) + value.microsecond / 1000000.0", "code_tokens": "def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0", "docstring_tokens": "If value is a datetime convert to timestamp", "label": 0}, {"idx": "cosqa-train-2011", "doc": "python check if a path is valid", "code": "def is_valid_folder(parser, arg):\n    \"\"\"Check if arg is a valid file that already exists on the file system.\"\"\"\n    arg = os.path.abspath(arg)\n    if not os.path.isdir(arg):\n        parser.error(\"The folder %s does not exist!\" % arg)\n    else:\n        return arg", "code_tokens": "def is_valid_folder ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . isdir ( arg ) : parser . error ( \"The folder %s does not exist!\" % arg ) else : return arg", "docstring_tokens": "Check if arg is a valid file that already exists on the file system .", "label": 0}, {"idx": "cosqa-train-2012", "doc": "turtle program still running after mannually closing it in python", "code": "def abort(self):\n        \"\"\" ensure the master exit from Barrier \"\"\"\n        self.mutex.release()\n        self.turnstile.release()\n        self.mutex.release()\n        self.turnstile2.release()", "code_tokens": "def abort ( self ) : self . mutex . release ( ) self . turnstile . release ( ) self . mutex . release ( ) self . turnstile2 . release ( )", "docstring_tokens": "ensure the master exit from Barrier", "label": 0}, {"idx": "cosqa-train-2013", "doc": "python check if a process with pid is running", "code": "def pid_exists(pid):\n    \"\"\" Determines if a system process identifer exists in process table.\n        \"\"\"\n    try:\n        os.kill(pid, 0)\n    except OSError as exc:\n        return exc.errno == errno.EPERM\n    else:\n        return True", "code_tokens": "def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True", "docstring_tokens": "Determines if a system process identifer exists in process table .", "label": 0}, {"idx": "cosqa-train-2014", "doc": "two dimensional gaussian distribution python", "code": "def Gaussian(x, mu, sig):\n    \"\"\"\n    Gaussian pdf.\n    :param x: free variable.\n    :param mu: mean of the distribution.\n    :param sig: standard deviation of the distribution.\n    :return: sympy.Expr for a Gaussian pdf.\n    \"\"\"\n    return sympy.exp(-(x - mu)**2/(2*sig**2))/sympy.sqrt(2*sympy.pi*sig**2)", "code_tokens": "def Gaussian ( x , mu , sig ) : return sympy . exp ( - ( x - mu ) ** 2 / ( 2 * sig ** 2 ) ) / sympy . sqrt ( 2 * sympy . pi * sig ** 2 )", "docstring_tokens": "Gaussian pdf . : param x : free variable . : param mu : mean of the distribution . : param sig : standard deviation of the distribution . : return : sympy . Expr for a Gaussian pdf .", "label": 1}, {"idx": "cosqa-train-2015", "doc": "python check if all condition is true", "code": "def All(sequence):\n  \"\"\"\n  :param sequence: Any sequence whose elements can be evaluated as booleans.\n  :returns: true if all elements of the sequence satisfy True and x.\n  \"\"\"\n  return bool(reduce(lambda x, y: x and y, sequence, True))", "code_tokens": "def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )", "docstring_tokens": ": param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x .", "label": 0}, {"idx": "cosqa-train-2016", "doc": "two vector angle python", "code": "def angle_v2_rad(vec_a, vec_b):\n    \"\"\"Returns angle between vec_a and vec_b in range [0, PI].  This does not\n    distinguish if a is left of or right of b.\n    \"\"\"\n    # cos(x) = A * B / |A| * |B|\n    return math.acos(vec_a.dot(vec_b) / (vec_a.length() * vec_b.length()))", "code_tokens": "def angle_v2_rad ( vec_a , vec_b ) : # cos(x) = A * B / |A| * |B| return math . acos ( vec_a . dot ( vec_b ) / ( vec_a . length ( ) * vec_b . length ( ) ) )", "docstring_tokens": "Returns angle between vec_a and vec_b in range [ 0 PI ] . This does not distinguish if a is left of or right of b .", "label": 0}, {"idx": "cosqa-train-2017", "doc": "python check if all elements in a list are digits", "code": "def _rectangular(n):\n    \"\"\"Checks to see if a 2D list is a valid 2D matrix\"\"\"\n    for i in n:\n        if len(i) != len(n[0]):\n            return False\n    return True", "code_tokens": "def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True", "docstring_tokens": "Checks to see if a 2D list is a valid 2D matrix", "label": 0}, {"idx": "cosqa-train-2018", "doc": "txt read iterator python", "code": "def txt_line_iterator(path):\n  \"\"\"Iterate through lines of file.\"\"\"\n  with tf.gfile.Open(path) as f:\n    for line in f:\n      yield line.strip()", "code_tokens": "def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )", "docstring_tokens": "Iterate through lines of file .", "label": 0}, {"idx": "cosqa-train-2019", "doc": "python check if dictionaries are equal", "code": "def is_same_dict(d1, d2):\n    \"\"\"Test two dictionary is equal on values. (ignore order)\n    \"\"\"\n    for k, v in d1.items():\n        if isinstance(v, dict):\n            is_same_dict(v, d2[k])\n        else:\n            assert d1[k] == d2[k]\n\n    for k, v in d2.items():\n        if isinstance(v, dict):\n            is_same_dict(v, d1[k])\n        else:\n            assert d1[k] == d2[k]", "code_tokens": "def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]", "docstring_tokens": "Test two dictionary is equal on values . ( ignore order )", "label": 0}, {"idx": "cosqa-train-2020", "doc": "type cast python string", "code": "def to_binary(s, encoding='utf8'):\n    \"\"\"Portable cast function.\n\n    In python 2 the ``str`` function which is used to coerce objects to bytes does not\n    accept an encoding argument, whereas python 3's ``bytes`` function requires one.\n\n    :param s: object to be converted to binary_type\n    :return: binary_type instance, representing s.\n    \"\"\"\n    if PY3:  # pragma: no cover\n        return s if isinstance(s, binary_type) else binary_type(s, encoding=encoding)\n    return binary_type(s)", "code_tokens": "def to_binary ( s , encoding = 'utf8' ) : if PY3 : # pragma: no cover return s if isinstance ( s , binary_type ) else binary_type ( s , encoding = encoding ) return binary_type ( s )", "docstring_tokens": "Portable cast function .", "label": 1}, {"idx": "cosqa-train-2021", "doc": "python check if element is list or int", "code": "def is_iterable_of_int(l):\n    r\"\"\" Checks if l is iterable and contains only integral types \"\"\"\n    if not is_iterable(l):\n        return False\n\n    return all(is_int(value) for value in l)", "code_tokens": "def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )", "docstring_tokens": "r Checks if l is iterable and contains only integral types", "label": 0}, {"idx": "cosqa-train-2022", "doc": "type cast to int python", "code": "def _to_numeric(val):\n    \"\"\"\n    Helper function for conversion of various data types into numeric representation.\n    \"\"\"\n    if isinstance(val, (int, float, datetime.datetime, datetime.timedelta)):\n        return val\n    return float(val)", "code_tokens": "def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )", "docstring_tokens": "Helper function for conversion of various data types into numeric representation .", "label": 0}, {"idx": "cosqa-train-2023", "doc": "python check if filename has extension", "code": "def is_valid_image_extension(file_path):\n    \"\"\"is_valid_image_extension.\"\"\"\n    valid_extensions = ['.jpeg', '.jpg', '.gif', '.png']\n    _, extension = os.path.splitext(file_path)\n    return extension.lower() in valid_extensions", "code_tokens": "def is_valid_image_extension ( file_path ) : valid_extensions = [ '.jpeg' , '.jpg' , '.gif' , '.png' ] _ , extension = os . path . splitext ( file_path ) return extension . lower ( ) in valid_extensions", "docstring_tokens": "is_valid_image_extension .", "label": 0}, {"idx": "cosqa-train-2024", "doc": "unable to rollback python", "code": "def rollback(self):\n\t\t\"\"\"\n\t\tRollback MySQL Transaction to database.\n\t\tMySQLDB: If the database and tables support transactions, this rolls \n\t\tback (cancels) the current transaction; otherwise a \n\t\tNotSupportedError is raised.\n\t\t\n\t\t@author: Nick Verbeck\n\t\t@since: 5/12/2008\n\t\t\"\"\"\n\t\ttry:\n\t\t\tif self.connection is not None:\n\t\t\t\tself.connection.rollback()\n\t\t\t\tself._updateCheckTime()\n\t\t\t\tself.release()\n\t\texcept Exception, e:\n\t\t\tpass", "code_tokens": "def rollback ( self ) : try : if self . connection is not None : self . connection . rollback ( ) self . _updateCheckTime ( ) self . release ( ) except Exception , e : pass", "docstring_tokens": "Rollback MySQL Transaction to database . MySQLDB : If the database and tables support transactions this rolls back ( cancels ) the current transaction ; otherwise a NotSupportedError is raised .", "label": 0}, {"idx": "cosqa-train-2025", "doc": "python check if gevent monkey patch", "code": "def gevent_monkey_patch_report(self):\n        \"\"\"\n        Report effective gevent monkey patching on the logs.\n        \"\"\"\n        try:\n            import gevent.socket\n            import socket\n\n            if gevent.socket.socket is socket.socket:\n                self.log(\"gevent monkey patching is active\")\n                return True\n            else:\n                self.notify_user(\"gevent monkey patching failed.\")\n        except ImportError:\n            self.notify_user(\"gevent is not installed, monkey patching failed.\")\n        return False", "code_tokens": "def gevent_monkey_patch_report ( self ) : try : import gevent . socket import socket if gevent . socket . socket is socket . socket : self . log ( \"gevent monkey patching is active\" ) return True else : self . notify_user ( \"gevent monkey patching failed.\" ) except ImportError : self . notify_user ( \"gevent is not installed, monkey patching failed.\" ) return False", "docstring_tokens": "Report effective gevent monkey patching on the logs .", "label": 1}, {"idx": "cosqa-train-2026", "doc": "underscore space replace python", "code": "def underscore(text):\n    \"\"\"Converts text that may be camelcased into an underscored format\"\"\"\n    return UNDERSCORE[1].sub(r'\\1_\\2', UNDERSCORE[0].sub(r'\\1_\\2', text)).lower()", "code_tokens": "def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\\1_\\2' , UNDERSCORE [ 0 ] . sub ( r'\\1_\\2' , text ) ) . lower ( )", "docstring_tokens": "Converts text that may be camelcased into an underscored format", "label": 0}, {"idx": "cosqa-train-2027", "doc": "python check if it win32com object", "code": "def inside_softimage():\n    \"\"\"Returns a boolean indicating if the code is executed inside softimage.\"\"\"\n    try:\n        import maya\n        return False\n    except ImportError:\n        pass\n    try:\n        from win32com.client import Dispatch as disp\n        disp('XSI.Application')\n        return True\n    except:\n        return False", "code_tokens": "def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False", "docstring_tokens": "Returns a boolean indicating if the code is executed inside softimage .", "label": 0}, {"idx": "cosqa-train-2028", "doc": "underscores surrounding word in python", "code": "def camel_case_from_underscores(string):\n    \"\"\"generate a CamelCase string from an underscore_string.\"\"\"\n    components = string.split('_')\n    string = ''\n    for component in components:\n        string += component[0].upper() + component[1:]\n    return string", "code_tokens": "def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "docstring_tokens": "generate a CamelCase string from an underscore_string .", "label": 0}, {"idx": "cosqa-train-2029", "doc": "python check if its a vector", "code": "def is_int_vector(l):\n    r\"\"\"Checks if l is a numpy array of integers\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 1 and (l.dtype.kind == 'i' or l.dtype.kind == 'u'):\n            return True\n    return False", "code_tokens": "def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False", "docstring_tokens": "r Checks if l is a numpy array of integers", "label": 0}, {"idx": "cosqa-train-2030", "doc": "unit test with mock and patch in python", "code": "def test_kwargs_are_optional(self):\n        \"\"\"kwarg values always have defaults\"\"\"\n        with patch(\"sys.exit\") as mock_exit:\n            cli = MicroCLITestCase.T(\"script_name f3\".split()).run()\n            # kwargs are optional\n            mock_exit.assert_called_with(4)", "code_tokens": "def test_kwargs_are_optional ( self ) : with patch ( \"sys.exit\" ) as mock_exit : cli = MicroCLITestCase . T ( \"script_name f3\" . split ( ) ) . run ( ) # kwargs are optional mock_exit . assert_called_with ( 4 )", "docstring_tokens": "kwarg values always have defaults", "label": 0}, {"idx": "cosqa-train-2031", "doc": "python check if row value is null", "code": "def is_valid_row(cls, row):\n        \"\"\"Indicates whether or not the given row contains valid data.\"\"\"\n        for k in row.keys():\n            if row[k] is None:\n                return False\n        return True", "code_tokens": "def is_valid_row ( cls , row ) : for k in row . keys ( ) : if row [ k ] is None : return False return True", "docstring_tokens": "Indicates whether or not the given row contains valid data .", "label": 0}, {"idx": "cosqa-train-2032", "doc": "unix utc to datetime in python", "code": "def unixtime_to_datetime(ut):\n    \"\"\"Convert a unixtime timestamp to a datetime object.\n    The function converts a timestamp in Unix format to a\n    datetime object. UTC timezone will also be set.\n    :param ut: Unix timestamp to convert\n    :returns: a datetime object\n    :raises InvalidDateError: when the given timestamp cannot be\n        converted into a valid date\n    \"\"\"\n\n    dt = datetime.datetime.utcfromtimestamp(ut)\n    dt = dt.replace(tzinfo=tz.tzutc())\n    return dt", "code_tokens": "def unixtime_to_datetime ( ut ) : dt = datetime . datetime . utcfromtimestamp ( ut ) dt = dt . replace ( tzinfo = tz . tzutc ( ) ) return dt", "docstring_tokens": "Convert a unixtime timestamp to a datetime object . The function converts a timestamp in Unix format to a datetime object . UTC timezone will also be set . : param ut : Unix timestamp to convert : returns : a datetime object : raises InvalidDateError : when the given timestamp cannot be converted into a valid date", "label": 0}, {"idx": "cosqa-train-2033", "doc": "python check if run admin cmd", "code": "def is_managed():\n    \"\"\"\n    Check if a Django project is being managed with ``manage.py`` or\n    ``django-admin`` scripts\n\n    :return: Check result\n    :rtype: bool\n    \"\"\"\n    for item in sys.argv:\n        if re.search(r'manage.py|django-admin|django', item) is not None:\n            return True\n    return False", "code_tokens": "def is_managed ( ) : for item in sys . argv : if re . search ( r'manage.py|django-admin|django' , item ) is not None : return True return False", "docstring_tokens": "Check if a Django project is being managed with manage . py or django - admin scripts", "label": 0}, {"idx": "cosqa-train-2034", "doc": "unsupported operand type(s) for python", "code": "def __init__(self,operand,operator,**args):\n        \"\"\"\n        Accepts a NumberGenerator operand, an operator, and\n        optional arguments to be provided to the operator when calling\n        it on the operand.\n        \"\"\"\n        # Note that it's currently not possible to set\n        # parameters in the superclass when creating an instance,\n        # because **args is used by this class itself.\n        super(UnaryOperator,self).__init__()\n\n        self.operand=operand\n        self.operator=operator\n        self.args=args", "code_tokens": "def __init__ ( self , operand , operator , * * args ) : # Note that it's currently not possible to set # parameters in the superclass when creating an instance, # because **args is used by this class itself. super ( UnaryOperator , self ) . __init__ ( ) self . operand = operand self . operator = operator self . args = args", "docstring_tokens": "Accepts a NumberGenerator operand an operator and optional arguments to be provided to the operator when calling it on the operand .", "label": 1}, {"idx": "cosqa-train-2035", "doc": "python check if stream is open", "code": "def _has_fileno(stream):\n    \"\"\"Returns whether the stream object seems to have a working fileno()\n\n    Tells whether _redirect_stderr is likely to work.\n\n    Parameters\n    ----------\n    stream : IO stream object\n\n    Returns\n    -------\n    has_fileno : bool\n        True if stream.fileno() exists and doesn't raise OSError or\n        UnsupportedOperation\n    \"\"\"\n    try:\n        stream.fileno()\n    except (AttributeError, OSError, IOError, io.UnsupportedOperation):\n        return False\n    return True", "code_tokens": "def _has_fileno ( stream ) : try : stream . fileno ( ) except ( AttributeError , OSError , IOError , io . UnsupportedOperation ) : return False return True", "docstring_tokens": "Returns whether the stream object seems to have a working fileno ()", "label": 1}, {"idx": "cosqa-train-2036", "doc": "uppercase lowercase title case in python", "code": "def to_capitalized_camel_case(snake_case_string):\n    \"\"\"\n    Convert a string from snake case to camel case with the first letter capitalized. For example, \"some_var\"\n    would become \"SomeVar\".\n\n    :param snake_case_string: Snake-cased string to convert to camel case.\n    :returns: Camel-cased version of snake_case_string.\n    \"\"\"\n    parts = snake_case_string.split('_')\n    return ''.join([i.title() for i in parts])", "code_tokens": "def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )", "docstring_tokens": "Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar .", "label": 0}, {"idx": "cosqa-train-2037", "doc": "python check if string contains multiple lines", "code": "def has_multiline_items(maybe_list: Optional[Sequence[str]]):\n    \"\"\"Check whether one of the items in the list has multiple lines.\"\"\"\n    return maybe_list and any(is_multiline(item) for item in maybe_list)", "code_tokens": "def has_multiline_items ( maybe_list : Optional [ Sequence [ str ] ] ) : return maybe_list and any ( is_multiline ( item ) for item in maybe_list )", "docstring_tokens": "Check whether one of the items in the list has multiple lines .", "label": 0}, {"idx": "cosqa-train-2038", "doc": "urlib open file in python", "code": "def read(*args):\n    \"\"\"Reads complete file contents.\"\"\"\n    return io.open(os.path.join(HERE, *args), encoding=\"utf-8\").read()", "code_tokens": "def read ( * args ) : return io . open ( os . path . join ( HERE , * args ) , encoding = \"utf-8\" ) . read ( )", "docstring_tokens": "Reads complete file contents .", "label": 1}, {"idx": "cosqa-train-2039", "doc": "python check if table exists", "code": "def table_exists(self, table):\n        \"\"\"Returns whether the given table exists.\n\n           :param table:\n           :type table: BQTable\n        \"\"\"\n        if not self.dataset_exists(table.dataset):\n            return False\n\n        try:\n            self.client.tables().get(projectId=table.project_id,\n                                     datasetId=table.dataset_id,\n                                     tableId=table.table_id).execute()\n        except http.HttpError as ex:\n            if ex.resp.status == 404:\n                return False\n            raise\n\n        return True", "code_tokens": "def table_exists ( self , table ) : if not self . dataset_exists ( table . dataset ) : return False try : self . client . tables ( ) . get ( projectId = table . project_id , datasetId = table . dataset_id , tableId = table . table_id ) . execute ( ) except http . HttpError as ex : if ex . resp . status == 404 : return False raise return True", "docstring_tokens": "Returns whether the given table exists .", "label": 0}, {"idx": "cosqa-train-2040", "doc": "use a function to store the code that displays the menu in python", "code": "def run_func(entry):\n    \"\"\"Runs the function associated with the given MenuEntry.\"\"\"\n    if entry.func:\n        if entry.args and entry.krgs:\n            return entry.func(*entry.args, **entry.krgs)\n        if entry.args:\n            return entry.func(*entry.args)\n        if entry.krgs:\n            return entry.func(**entry.krgs)\n        return entry.func()", "code_tokens": "def run_func ( entry ) : if entry . func : if entry . args and entry . krgs : return entry . func ( * entry . args , * * entry . krgs ) if entry . args : return entry . func ( * entry . args ) if entry . krgs : return entry . func ( * * entry . krgs ) return entry . func ( )", "docstring_tokens": "Runs the function associated with the given MenuEntry .", "label": 1}, {"idx": "cosqa-train-2041", "doc": "python check if two arrays are equal", "code": "def numpy_aware_eq(a, b):\n    \"\"\"Return whether two objects are equal via recursion, using\n    :func:`numpy.array_equal` for comparing numpy arays.\n    \"\"\"\n    if isinstance(a, np.ndarray) or isinstance(b, np.ndarray):\n        return np.array_equal(a, b)\n    if ((isinstance(a, Iterable) and isinstance(b, Iterable)) and\n            not isinstance(a, str) and not isinstance(b, str)):\n        if len(a) != len(b):\n            return False\n        return all(numpy_aware_eq(x, y) for x, y in zip(a, b))\n    return a == b", "code_tokens": "def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b", "docstring_tokens": "Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays .", "label": 0}, {"idx": "cosqa-train-2042", "doc": "use of iterators without for loops in python 2", "code": "def peekiter(iterable):\n    \"\"\"Return first row and also iterable with same items as original\"\"\"\n    it = iter(iterable)\n    one = next(it)\n\n    def gen():\n        \"\"\"Generator that returns first and proxy other items from source\"\"\"\n        yield one\n        while True:\n            yield next(it)\n    return (one, gen())", "code_tokens": "def peekiter ( iterable ) : it = iter ( iterable ) one = next ( it ) def gen ( ) : \"\"\"Generator that returns first and proxy other items from source\"\"\" yield one while True : yield next ( it ) return ( one , gen ( ) )", "docstring_tokens": "Return first row and also iterable with same items as original", "label": 0}, {"idx": "cosqa-train-2043", "doc": "python check if two dictionaries are identical", "code": "def is_same_dict(d1, d2):\n    \"\"\"Test two dictionary is equal on values. (ignore order)\n    \"\"\"\n    for k, v in d1.items():\n        if isinstance(v, dict):\n            is_same_dict(v, d2[k])\n        else:\n            assert d1[k] == d2[k]\n\n    for k, v in d2.items():\n        if isinstance(v, dict):\n            is_same_dict(v, d1[k])\n        else:\n            assert d1[k] == d2[k]", "code_tokens": "def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]", "docstring_tokens": "Test two dictionary is equal on values . ( ignore order )", "label": 0}, {"idx": "cosqa-train-2044", "doc": "use replace in python to cut characters", "code": "def str_ripper(self, text):\n        \"\"\"Got this code from here:\n        http://stackoverflow.com/questions/6116978/python-replace-multiple-strings\n\n        This method takes a set of strings, A, and removes all whole\n        elements of set A from string B.\n\n        Input: text string to strip based on instance attribute self.censor\n        Output: a stripped (censored) text string\n        \"\"\"\n        return self.pattern.sub(lambda m: self.rep[re.escape(m.group(0))], text)", "code_tokens": "def str_ripper ( self , text ) : return self . pattern . sub ( lambda m : self . rep [ re . escape ( m . group ( 0 ) ) ] , text )", "docstring_tokens": "Got this code from here : http : // stackoverflow . com / questions / 6116978 / python - replace - multiple - strings", "label": 0}, {"idx": "cosqa-train-2045", "doc": "python check if url is localhost", "code": "def is_local_url(target):\n    \"\"\"Determine if URL is safe to redirect to.\"\"\"\n    ref_url = urlparse(request.host_url)\n    test_url = urlparse(urljoin(request.host_url, target))\n    return test_url.scheme in ('http', 'https') and \\\n        ref_url.netloc == test_url.netloc", "code_tokens": "def is_local_url ( target ) : ref_url = urlparse ( request . host_url ) test_url = urlparse ( urljoin ( request . host_url , target ) ) return test_url . scheme in ( 'http' , 'https' ) and ref_url . netloc == test_url . netloc", "docstring_tokens": "Determine if URL is safe to redirect to .", "label": 1}, {"idx": "cosqa-train-2046", "doc": "use single quote in string python", "code": "def quote(self, s):\n        \"\"\"Return a shell-escaped version of the string s.\"\"\"\n\n        if six.PY2:\n            from pipes import quote\n        else:\n            from shlex import quote\n\n        return quote(s)", "code_tokens": "def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )", "docstring_tokens": "Return a shell - escaped version of the string s .", "label": 1}, {"idx": "cosqa-train-2047", "doc": "python check if valid uuid", "code": "def valid_uuid(value):\n    \"\"\" Check if value is a valid UUID. \"\"\"\n\n    try:\n        uuid.UUID(value, version=4)\n        return True\n    except (TypeError, ValueError, AttributeError):\n        return False", "code_tokens": "def valid_uuid ( value ) : try : uuid . UUID ( value , version = 4 ) return True except ( TypeError , ValueError , AttributeError ) : return False", "docstring_tokens": "Check if value is a valid UUID .", "label": 0}, {"idx": "cosqa-train-2048", "doc": "use variable to retrieve attribute in python", "code": "def getSystemVariable(self, remote, name):\n        \"\"\"Get single system variable from CCU / Homegear\"\"\"\n        if self._server is not None:\n            return self._server.getSystemVariable(remote, name)", "code_tokens": "def getSystemVariable ( self , remote , name ) : if self . _server is not None : return self . _server . getSystemVariable ( remote , name )", "docstring_tokens": "Get single system variable from CCU / Homegear", "label": 0}, {"idx": "cosqa-train-2049", "doc": "python check if value is sequence", "code": "def _is_proper_sequence(seq):\n    \"\"\"Returns is seq is sequence and not string.\"\"\"\n    return (isinstance(seq, collections.abc.Sequence) and\n            not isinstance(seq, str))", "code_tokens": "def _is_proper_sequence ( seq ) : return ( isinstance ( seq , collections . abc . Sequence ) and not isinstance ( seq , str ) )", "docstring_tokens": "Returns is seq is sequence and not string .", "label": 0}, {"idx": "cosqa-train-2050", "doc": "python check is a string a path", "code": "def _is_path(s):\n    \"\"\"Return whether an object is a path.\"\"\"\n    if isinstance(s, string_types):\n        try:\n            return op.exists(s)\n        except (OSError, ValueError):\n            return False\n    else:\n        return False", "code_tokens": "def _is_path ( s ) : if isinstance ( s , string_types ) : try : return op . exists ( s ) except ( OSError , ValueError ) : return False else : return False", "docstring_tokens": "Return whether an object is a path .", "label": 1}, {"idx": "cosqa-train-2051", "doc": "using clipboard with python", "code": "def paste(xsel=False):\n    \"\"\"Returns system clipboard contents.\"\"\"\n    selection = \"primary\" if xsel else \"clipboard\"\n    try:\n        return subprocess.Popen([\"xclip\", \"-selection\", selection, \"-o\"], stdout=subprocess.PIPE).communicate()[0].decode(\"utf-8\")\n    except OSError as why:\n        raise XclipNotFound", "code_tokens": "def paste ( xsel = False ) : selection = \"primary\" if xsel else \"clipboard\" try : return subprocess . Popen ( [ \"xclip\" , \"-selection\" , selection , \"-o\" ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] . decode ( \"utf-8\" ) except OSError as why : raise XclipNotFound", "docstring_tokens": "Returns system clipboard contents .", "label": 0}, {"idx": "cosqa-train-2052", "doc": "python check is file is image", "code": "def is_image(filename):\n    \"\"\"Determine if given filename is an image.\"\"\"\n    # note: isfile() also accepts symlinks\n    return os.path.isfile(filename) and filename.lower().endswith(ImageExts)", "code_tokens": "def is_image ( filename ) : # note: isfile() also accepts symlinks return os . path . isfile ( filename ) and filename . lower ( ) . endswith ( ImageExts )", "docstring_tokens": "Determine if given filename is an image .", "label": 0}, {"idx": "cosqa-train-2053", "doc": "python check is list all int", "code": "def is_iterable_of_int(l):\n    r\"\"\" Checks if l is iterable and contains only integral types \"\"\"\n    if not is_iterable(l):\n        return False\n\n    return all(is_int(value) for value in l)", "code_tokens": "def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )", "docstring_tokens": "r Checks if l is iterable and contains only integral types", "label": 0}, {"idx": "cosqa-train-2054", "doc": "using format with a list python", "code": "def list_formatter(handler, item, value):\n    \"\"\"Format list.\"\"\"\n    return u', '.join(str(v) for v in value)", "code_tokens": "def list_formatter ( handler , item , value ) : return u', ' . join ( str ( v ) for v in value )", "docstring_tokens": "Format list .", "label": 0}, {"idx": "cosqa-train-2055", "doc": "python check is namedtuple matches", "code": "def isnamedtuple(obj):\n    \"\"\"Heuristic check if an object is a namedtuple.\"\"\"\n    return isinstance(obj, tuple) \\\n           and hasattr(obj, \"_fields\") \\\n           and hasattr(obj, \"_asdict\") \\\n           and callable(obj._asdict)", "code_tokens": "def isnamedtuple ( obj ) : return isinstance ( obj , tuple ) and hasattr ( obj , \"_fields\" ) and hasattr ( obj , \"_asdict\" ) and callable ( obj . _asdict )", "docstring_tokens": "Heuristic check if an object is a namedtuple .", "label": 0}, {"idx": "cosqa-train-2056", "doc": "using graphviz with python", "code": "def _text_to_graphiz(self, text):\n        \"\"\"create a graphviz graph from text\"\"\"\n        dot = Source(text, format='svg')\n        return dot.pipe().decode('utf-8')", "code_tokens": "def _text_to_graphiz ( self , text ) : dot = Source ( text , format = 'svg' ) return dot . pipe ( ) . decode ( 'utf-8' )", "docstring_tokens": "create a graphviz graph from text", "label": 1}, {"idx": "cosqa-train-2057", "doc": "python check is string is valid url", "code": "def is_valid_url(url):\n    \"\"\"Checks if a given string is an url\"\"\"\n    pieces = urlparse(url)\n    return all([pieces.scheme, pieces.netloc])", "code_tokens": "def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )", "docstring_tokens": "Checks if a given string is an url", "label": 1}, {"idx": "cosqa-train-2058", "doc": "using runtime to execute python in java", "code": "def test_python_java_rt():\n    \"\"\" Run Python test cases against Java runtime classes. \"\"\"\n    sub_env = {'PYTHONPATH': _build_dir()}\n\n    log.info('Executing Python unit tests (against Java runtime classes)...')\n    return jpyutil._execute_python_scripts(python_java_rt_tests,\n                                           env=sub_env)", "code_tokens": "def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )", "docstring_tokens": "Run Python test cases against Java runtime classes .", "label": 0}, {"idx": "cosqa-train-2059", "doc": "python check last modified time", "code": "def last_modified_date(filename):\n    \"\"\"Last modified timestamp as a UTC datetime\"\"\"\n    mtime = os.path.getmtime(filename)\n    dt = datetime.datetime.utcfromtimestamp(mtime)\n    return dt.replace(tzinfo=pytz.utc)", "code_tokens": "def last_modified_date ( filename ) : mtime = os . path . getmtime ( filename ) dt = datetime . datetime . utcfromtimestamp ( mtime ) return dt . replace ( tzinfo = pytz . utc )", "docstring_tokens": "Last modified timestamp as a UTC datetime", "label": 0}, {"idx": "cosqa-train-2060", "doc": "using this form for the binomial coefficient python", "code": "def Bernstein(n, k):\n    \"\"\"Bernstein polynomial.\n\n    \"\"\"\n    coeff = binom(n, k)\n\n    def _bpoly(x):\n        return coeff * x ** k * (1 - x) ** (n - k)\n\n    return _bpoly", "code_tokens": "def Bernstein ( n , k ) : coeff = binom ( n , k ) def _bpoly ( x ) : return coeff * x ** k * ( 1 - x ) ** ( n - k ) return _bpoly", "docstring_tokens": "Bernstein polynomial .", "label": 1}, {"idx": "cosqa-train-2061", "doc": "python check method defined", "code": "def _check_methods(self, methods):\n        \"\"\" @type methods: tuple \"\"\"\n        for method in methods:\n            if method not in self.ALLOWED_METHODS:\n                raise Exception('Invalid \\'%s\\' method' % method)", "code_tokens": "def _check_methods ( self , methods ) : for method in methods : if method not in self . ALLOWED_METHODS : raise Exception ( 'Invalid \\'%s\\' method' % method )", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-2062", "doc": "utc timestamp to specified timezone in python", "code": "def timestamp_to_datetime(cls, time_stamp, localized=True):\n        \"\"\" Converts a UTC timestamp to a datetime.datetime.\"\"\"\n        ret = datetime.datetime.utcfromtimestamp(time_stamp)\n        if localized:\n            ret = localize(ret, pytz.utc)\n        return ret", "code_tokens": "def timestamp_to_datetime ( cls , time_stamp , localized = True ) : ret = datetime . datetime . utcfromtimestamp ( time_stamp ) if localized : ret = localize ( ret , pytz . utc ) return ret", "docstring_tokens": "Converts a UTC timestamp to a datetime . datetime .", "label": 0}, {"idx": "cosqa-train-2063", "doc": "python check object iterable", "code": "def is_iterable_but_not_string(obj):\n    \"\"\"\n    Determine whether or not obj is iterable but not a string (eg, a list, set, tuple etc).\n    \"\"\"\n    return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)", "code_tokens": "def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )", "docstring_tokens": "Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) .", "label": 0}, {"idx": "cosqa-train-2064", "doc": "validate avro schema with data in python", "code": "def validate(datum, schema, field=None, raise_errors=True):\n    \"\"\"\n    Determine if a python datum is an instance of a schema.\n\n    Parameters\n    ----------\n    datum: Any\n        Data being validated\n    schema: dict\n        Schema\n    field: str, optional\n        Record field being validated\n    raise_errors: bool, optional\n        If true, errors are raised for invalid data. If false, a simple\n        True (valid) or False (invalid) result is returned\n\n\n    Example::\n\n        from fastavro.validation import validate\n        schema = {...}\n        record = {...}\n        validate(record, schema)\n    \"\"\"\n    record_type = extract_record_type(schema)\n    result = None\n\n    validator = VALIDATORS.get(record_type)\n    if validator:\n        result = validator(datum, schema=schema,\n                           parent_ns=field,\n                           raise_errors=raise_errors)\n    elif record_type in SCHEMA_DEFS:\n        result = validate(datum,\n                          schema=SCHEMA_DEFS[record_type],\n                          field=field,\n                          raise_errors=raise_errors)\n    else:\n        raise UnknownType(record_type)\n\n    if raise_errors and result is False:\n        raise ValidationError(ValidationErrorData(datum, schema, field))\n\n    return result", "code_tokens": "def validate ( datum , schema , field = None , raise_errors = True ) : record_type = extract_record_type ( schema ) result = None validator = VALIDATORS . get ( record_type ) if validator : result = validator ( datum , schema = schema , parent_ns = field , raise_errors = raise_errors ) elif record_type in SCHEMA_DEFS : result = validate ( datum , schema = SCHEMA_DEFS [ record_type ] , field = field , raise_errors = raise_errors ) else : raise UnknownType ( record_type ) if raise_errors and result is False : raise ValidationError ( ValidationErrorData ( datum , schema , field ) ) return result", "docstring_tokens": "Determine if a python datum is an instance of a schema .", "label": 0}, {"idx": "cosqa-train-2065", "doc": "python check own memory usage", "code": "def memory_used(self):\n        \"\"\"To know the allocated memory at function termination.\n\n        ..versionadded:: 4.1\n\n        This property might return None if the function is still running.\n\n        This function should help to show memory leaks or ram greedy code.\n        \"\"\"\n        if self._end_memory:\n            memory_used = self._end_memory - self._start_memory\n            return memory_used\n        else:\n            return None", "code_tokens": "def memory_used ( self ) : if self . _end_memory : memory_used = self . _end_memory - self . _start_memory return memory_used else : return None", "docstring_tokens": "To know the allocated memory at function termination .", "label": 0}, {"idx": "cosqa-train-2066", "doc": "validate email address with regex python", "code": "def __validate_email(self, email):\n        \"\"\"Checks if a string looks like an email address\"\"\"\n\n        e = re.match(self.EMAIL_ADDRESS_REGEX, email, re.UNICODE)\n        if e:\n            return email\n        else:\n            error = \"Invalid email address: \" + str(email)\n            msg = self.GRIMOIRELAB_INVALID_FORMAT % {'error': error}\n            raise InvalidFormatError(cause=msg)", "code_tokens": "def __validate_email ( self , email ) : e = re . match ( self . EMAIL_ADDRESS_REGEX , email , re . UNICODE ) if e : return email else : error = \"Invalid email address: \" + str ( email ) msg = self . GRIMOIRELAB_INVALID_FORMAT % { 'error' : error } raise InvalidFormatError ( cause = msg )", "docstring_tokens": "Checks if a string looks like an email address", "label": 0}, {"idx": "cosqa-train-2067", "doc": "python check permissions of a folder", "code": "def is_readable_dir(path):\n  \"\"\"Returns whether a path names an existing directory we can list and read files from.\"\"\"\n  return os.path.isdir(path) and os.access(path, os.R_OK) and os.access(path, os.X_OK)", "code_tokens": "def is_readable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . R_OK ) and os . access ( path , os . X_OK )", "docstring_tokens": "Returns whether a path names an existing directory we can list and read files from .", "label": 0}, {"idx": "cosqa-train-2068", "doc": "validate for arg python", "code": "def email_type(arg):\n\t\"\"\"An argparse type representing an email address.\"\"\"\n\tif not is_valid_email_address(arg):\n\t\traise argparse.ArgumentTypeError(\"{0} is not a valid email address\".format(repr(arg)))\n\treturn arg", "code_tokens": "def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( \"{0} is not a valid email address\" . format ( repr ( arg ) ) ) return arg", "docstring_tokens": "An argparse type representing an email address .", "label": 0}, {"idx": "cosqa-train-2069", "doc": "python check process exist pid", "code": "def pid_exists(pid):\n    \"\"\" Determines if a system process identifer exists in process table.\n        \"\"\"\n    try:\n        os.kill(pid, 0)\n    except OSError as exc:\n        return exc.errno == errno.EPERM\n    else:\n        return True", "code_tokens": "def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True", "docstring_tokens": "Determines if a system process identifer exists in process table .", "label": 0}, {"idx": "cosqa-train-2070", "doc": "validate xml with xsd file using python", "code": "def SchemaValidate(self, xsd):\n        \"\"\"Use W3C XSD schema to validate the document as it is\n          processed. Activation is only possible before the first\n          Read(). If @xsd is None, then XML Schema validation is\n           deactivated. \"\"\"\n        ret = libxml2mod.xmlTextReaderSchemaValidate(self._o, xsd)\n        return ret", "code_tokens": "def SchemaValidate ( self , xsd ) : ret = libxml2mod . xmlTextReaderSchemaValidate ( self . _o , xsd ) return ret", "docstring_tokens": "Use W3C XSD schema to validate the document as it is processed . Activation is only possible before the first Read () . If", "label": 0}, {"idx": "cosqa-train-2071", "doc": "python check request querystring none", "code": "def arg_bool(name, default=False):\n    \"\"\" Fetch a query argument, as a boolean. \"\"\"\n    v = request.args.get(name, '')\n    if not len(v):\n        return default\n    return v in BOOL_TRUISH", "code_tokens": "def arg_bool ( name , default = False ) : v = request . args . get ( name , '' ) if not len ( v ) : return default return v in BOOL_TRUISH", "docstring_tokens": "Fetch a query argument as a boolean .", "label": 0}, {"idx": "cosqa-train-2072", "doc": "validation of username and password in python and or", "code": "def check_auth(username, pwd):\n    \"\"\"This function is called to check if a username /\n    password combination is valid.\n    \"\"\"\n    cfg = get_current_config()\n    return username == cfg[\"dashboard_httpauth\"].split(\n        \":\")[0] and pwd == cfg[\"dashboard_httpauth\"].split(\":\")[1]", "code_tokens": "def check_auth ( username , pwd ) : cfg = get_current_config ( ) return username == cfg [ \"dashboard_httpauth\" ] . split ( \":\" ) [ 0 ] and pwd == cfg [ \"dashboard_httpauth\" ] . split ( \":\" ) [ 1 ]", "docstring_tokens": "This function is called to check if a username / password combination is valid .", "label": 0}, {"idx": "cosqa-train-2073", "doc": "python check rpm exists", "code": "def is_rpm_package_installed(pkg):\n    \"\"\" checks if a particular rpm package is installed \"\"\"\n\n    with settings(hide('warnings', 'running', 'stdout', 'stderr'),\n                  warn_only=True, capture=True):\n\n        result = sudo(\"rpm -q %s\" % pkg)\n        if result.return_code == 0:\n            return True\n        elif result.return_code == 1:\n            return False\n        else:   # print error to user\n            print(result)\n            raise SystemExit()", "code_tokens": "def is_rpm_package_installed ( pkg ) : with settings ( hide ( 'warnings' , 'running' , 'stdout' , 'stderr' ) , warn_only = True , capture = True ) : result = sudo ( \"rpm -q %s\" % pkg ) if result . return_code == 0 : return True elif result . return_code == 1 : return False else : # print error to user print ( result ) raise SystemExit ( )", "docstring_tokens": "checks if a particular rpm package is installed", "label": 0}, {"idx": "cosqa-train-2074", "doc": "variable wrapped in [' django python json", "code": "def json_template(data, template_name, template_context):\n    \"\"\"Old style, use JSONTemplateResponse instead of this.\n    \"\"\"\n    html = render_to_string(template_name, template_context)\n    data = data or {}\n    data['html'] = html\n    return HttpResponse(json_encode(data), content_type='application/json')", "code_tokens": "def json_template ( data , template_name , template_context ) : html = render_to_string ( template_name , template_context ) data = data or { } data [ 'html' ] = html return HttpResponse ( json_encode ( data ) , content_type = 'application/json' )", "docstring_tokens": "Old style use JSONTemplateResponse instead of this .", "label": 1}, {"idx": "cosqa-train-2075", "doc": "python check set intersection", "code": "def issuperset(self, other):\n        \"\"\"Report whether this RangeSet contains another set.\"\"\"\n        self._binary_sanity_check(other)\n        return set.issuperset(self, other)", "code_tokens": "def issuperset ( self , other ) : self . _binary_sanity_check ( other ) return set . issuperset ( self , other )", "docstring_tokens": "Report whether this RangeSet contains another set .", "label": 0}, {"idx": "cosqa-train-2076", "doc": "vs code python indentation reformat", "code": "def dumped(text, level, indent=2):\n    \"\"\"Put curly brackets round an indented text\"\"\"\n    return indented(\"{\\n%s\\n}\" % indented(text, level + 1, indent) or \"None\", level, indent) + \"\\n\"", "code_tokens": "def dumped ( text , level , indent = 2 ) : return indented ( \"{\\n%s\\n}\" % indented ( text , level + 1 , indent ) or \"None\" , level , indent ) + \"\\n\"", "docstring_tokens": "Put curly brackets round an indented text", "label": 0}, {"idx": "cosqa-train-2077", "doc": "python check string if float", "code": "def _convert_to_float_if_possible(s):\n    \"\"\"\n    A small helper function to convert a string to a numeric value\n    if appropriate\n\n    :param s: the string to be converted\n    :type s: str\n    \"\"\"\n    try:\n        ret = float(s)\n    except (ValueError, TypeError):\n        ret = s\n    return ret", "code_tokens": "def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret", "docstring_tokens": "A small helper function to convert a string to a numeric value if appropriate", "label": 1}, {"idx": "cosqa-train-2078", "doc": "vs code python type hinting", "code": "def is_builtin_type(tp):\n    \"\"\"Checks if the given type is a builtin one.\n    \"\"\"\n    return hasattr(__builtins__, tp.__name__) and tp is getattr(__builtins__, tp.__name__)", "code_tokens": "def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )", "docstring_tokens": "Checks if the given type is a builtin one .", "label": 1}, {"idx": "cosqa-train-2079", "doc": "vs code set python indent to two spaces", "code": "def dumped(text, level, indent=2):\n    \"\"\"Put curly brackets round an indented text\"\"\"\n    return indented(\"{\\n%s\\n}\" % indented(text, level + 1, indent) or \"None\", level, indent) + \"\\n\"", "code_tokens": "def dumped ( text , level , indent = 2 ) : return indented ( \"{\\n%s\\n}\" % indented ( text , level + 1 , indent ) or \"None\" , level , indent ) + \"\\n\"", "docstring_tokens": "Put curly brackets round an indented text", "label": 0}, {"idx": "cosqa-train-2080", "doc": "python check string not null", "code": "def is_valid_variable_name(string_to_check):\n    \"\"\"\n    Returns whether the provided name is a valid variable name in Python\n\n    :param string_to_check: the string to be checked\n    :return: True or False\n    \"\"\"\n\n    try:\n\n        parse('{} = None'.format(string_to_check))\n        return True\n\n    except (SyntaxError, ValueError, TypeError):\n\n        return False", "code_tokens": "def is_valid_variable_name ( string_to_check ) : try : parse ( '{} = None' . format ( string_to_check ) ) return True except ( SyntaxError , ValueError , TypeError ) : return False", "docstring_tokens": "Returns whether the provided name is a valid variable name in Python", "label": 0}, {"idx": "cosqa-train-2081", "doc": "way to strip punctuation python", "code": "def _clean_str(self, s):\n        \"\"\" Returns a lowercase string with punctuation and bad chars removed\n        :param s: string to clean\n        \"\"\"\n        return s.translate(str.maketrans('', '', punctuation)).replace('\\u200b', \" \").strip().lower()", "code_tokens": "def _clean_str ( self , s ) : return s . translate ( str . maketrans ( '' , '' , punctuation ) ) . replace ( '\\u200b' , \" \" ) . strip ( ) . lower ( )", "docstring_tokens": "Returns a lowercase string with punctuation and bad chars removed : param s : string to clean", "label": 0}, {"idx": "cosqa-train-2082", "doc": "python check the truth value of a list of boolean elements", "code": "def assert_exactly_one_true(bool_list):\n    \"\"\"This method asserts that only one value of the provided list is True.\n\n    :param bool_list: List of booleans to check\n    :return: True if only one value is True, False otherwise\n    \"\"\"\n    assert isinstance(bool_list, list)\n    counter = 0\n    for item in bool_list:\n        if item:\n            counter += 1\n    return counter == 1", "code_tokens": "def assert_exactly_one_true ( bool_list ) : assert isinstance ( bool_list , list ) counter = 0 for item in bool_list : if item : counter += 1 return counter == 1", "docstring_tokens": "This method asserts that only one value of the provided list is True .", "label": 0}, {"idx": "cosqa-train-2083", "doc": "what clear markings do a python have", "code": "def is_empty_object(n, last):\n    \"\"\"n may be the inside of block or object\"\"\"\n    if n.strip():\n        return False\n    # seems to be but can be empty code\n    last = last.strip()\n    markers = {\n        ')',\n        ';',\n    }\n    if not last or last[-1] in markers:\n        return False\n    return True", "code_tokens": "def is_empty_object ( n , last ) : if n . strip ( ) : return False # seems to be but can be empty code last = last . strip ( ) markers = { ')' , ';' , } if not last or last [ - 1 ] in markers : return False return True", "docstring_tokens": "n may be the inside of block or object", "label": 0}, {"idx": "cosqa-train-2084", "doc": "python check user is admin", "code": "def is_admin(self):\n        \"\"\"Is the user a system administrator\"\"\"\n        return self.role == self.roles.administrator.value and self.state == State.approved", "code_tokens": "def is_admin ( self ) : return self . role == self . roles . administrator . value and self . state == State . approved", "docstring_tokens": "Is the user a system administrator", "label": 1}, {"idx": "cosqa-train-2085", "doc": "what does 'id' gives in python", "code": "def get_obj(ref):\n    \"\"\"Get object from string reference.\"\"\"\n    oid = int(ref)\n    return server.id2ref.get(oid) or server.id2obj[oid]", "code_tokens": "def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]", "docstring_tokens": "Get object from string reference .", "label": 0}, {"idx": "cosqa-train-2086", "doc": "python check valid attribute names", "code": "def _validate_key(self, key):\n        \"\"\"Returns a boolean indicating if the attribute name is valid or not\"\"\"\n        return not any([key.startswith(i) for i in self.EXCEPTIONS])", "code_tokens": "def _validate_key ( self , key ) : return not any ( [ key . startswith ( i ) for i in self . EXCEPTIONS ] )", "docstring_tokens": "Returns a boolean indicating if the attribute name is valid or not", "label": 1}, {"idx": "cosqa-train-2087", "doc": "what function is used to get user input in python3", "code": "def _stdin_(p):\n    \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"\n    _v = sys.version[0]\n    return input(p) if _v is '3' else raw_input(p)", "code_tokens": "def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "docstring_tokens": "Takes input from user . Works for Python 2 and 3 .", "label": 0}, {"idx": "cosqa-train-2088", "doc": "will python 3 accept polar coordinates", "code": "def cart2pol(x, y):\n    \"\"\"Cartesian to Polar coordinates conversion.\"\"\"\n    theta = np.arctan2(y, x)\n    rho = np.hypot(x, y)\n    return theta, rho", "code_tokens": "def cart2pol ( x , y ) : theta = np . arctan2 ( y , x ) rho = np . hypot ( x , y ) return theta , rho", "docstring_tokens": "Cartesian to Polar coordinates conversion .", "label": 0}, {"idx": "cosqa-train-2089", "doc": "python check value of qcheckbox", "code": "def set_value(self, value):\n        \"\"\"Set value of the checkbox.\n\n        Parameters\n        ----------\n        value : bool\n            value for the checkbox\n\n        \"\"\"\n        if value:\n            self.setChecked(Qt.Checked)\n        else:\n            self.setChecked(Qt.Unchecked)", "code_tokens": "def set_value ( self , value ) : if value : self . setChecked ( Qt . Checked ) else : self . setChecked ( Qt . Unchecked )", "docstring_tokens": "Set value of the checkbox .", "label": 1}, {"idx": "cosqa-train-2090", "doc": "win32 hook file python", "code": "def install_handle_input(self):\n        \"\"\"Install the hook.\"\"\"\n        self.pointer = self.get_fptr()\n\n        self.hooked = ctypes.windll.user32.SetWindowsHookExA(\n            13,\n            self.pointer,\n            ctypes.windll.kernel32.GetModuleHandleW(None),\n            0\n        )\n        if not self.hooked:\n            return False\n        return True", "code_tokens": "def install_handle_input ( self ) : self . pointer = self . get_fptr ( ) self . hooked = ctypes . windll . user32 . SetWindowsHookExA ( 13 , self . pointer , ctypes . windll . kernel32 . GetModuleHandleW ( None ) , 0 ) if not self . hooked : return False return True", "docstring_tokens": "Install the hook .", "label": 0}, {"idx": "cosqa-train-2091", "doc": "python checking equality between objects", "code": "def __eq__(self, other):\n        \"\"\"Determine if two objects are equal.\"\"\"\n        return isinstance(other, self.__class__) \\\n            and self._freeze() == other._freeze()", "code_tokens": "def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) and self . _freeze ( ) == other . _freeze ( )", "docstring_tokens": "Determine if two objects are equal .", "label": 0}, {"idx": "cosqa-train-2092", "doc": "python checking if string is multiple lines", "code": "def has_multiline_items(maybe_list: Optional[Sequence[str]]):\n    \"\"\"Check whether one of the items in the list has multiple lines.\"\"\"\n    return maybe_list and any(is_multiline(item) for item in maybe_list)", "code_tokens": "def has_multiline_items ( maybe_list : Optional [ Sequence [ str ] ] ) : return maybe_list and any ( is_multiline ( item ) for item in maybe_list )", "docstring_tokens": "Check whether one of the items in the list has multiple lines .", "label": 0}, {"idx": "cosqa-train-2093", "doc": "wrap a method in python", "code": "def method(func):\n    \"\"\"Wrap a function as a method.\"\"\"\n    attr = abc.abstractmethod(func)\n    attr.__imethod__ = True\n    return attr", "code_tokens": "def method ( func ) : attr = abc . abstractmethod ( func ) attr . __imethod__ = True return attr", "docstring_tokens": "Wrap a function as a method .", "label": 0}, {"idx": "cosqa-train-2094", "doc": "python chmod sticky bit", "code": "def chmod(f):\n    \"\"\" change mod to writeable \"\"\"\n    try:\n        os.chmod(f, S_IWRITE)  # windows (cover all)\n    except Exception as e:\n        pass\n    try:\n        os.chmod(f, 0o777)  # *nix\n    except Exception as e:\n        pass", "code_tokens": "def chmod ( f ) : try : os . chmod ( f , S_IWRITE ) # windows (cover all) except Exception as e : pass try : os . chmod ( f , 0o777 ) # *nix except Exception as e : pass", "docstring_tokens": "change mod to writeable", "label": 0}, {"idx": "cosqa-train-2095", "doc": "wrap c python ctypes vs", "code": "def get_ctype(rtype, cfunc, *args):\n    \"\"\" Call a C function that takes a pointer as its last argument and\n        return the C object that it contains after the function has finished.\n\n    :param rtype:   C data type is filled by the function\n    :param cfunc:   C function to call\n    :param args:    Arguments to call function with\n    :return:        A pointer to the specified data type\n    \"\"\"\n    val_p = backend.ffi.new(rtype)\n    args = args + (val_p,)\n    cfunc(*args)\n    return val_p[0]", "code_tokens": "def get_ctype ( rtype , cfunc , * args ) : val_p = backend . ffi . new ( rtype ) args = args + ( val_p , ) cfunc ( * args ) return val_p [ 0 ]", "docstring_tokens": "Call a C function that takes a pointer as its last argument and return the C object that it contains after the function has finished .", "label": 0}, {"idx": "cosqa-train-2096", "doc": "python clean url function", "code": "def clean_url(url):\n    \"\"\"\n    Remove params, query and fragment parts from URL so that `os.path.basename`\n    and `os.path.splitext` can work correctly.\n\n    @param url: URL to clean.\n    @type url: str\n\n    @return: Cleaned URL.\n    @rtype: str\n    \"\"\"\n    parsed = urlparse(url.strip())\n    reconstructed = ParseResult(\n        parsed.scheme, parsed.netloc, parsed.path,\n        params='', query='', fragment='')\n    return reconstructed.geturl()", "code_tokens": "def clean_url ( url ) : parsed = urlparse ( url . strip ( ) ) reconstructed = ParseResult ( parsed . scheme , parsed . netloc , parsed . path , params = '' , query = '' , fragment = '' ) return reconstructed . geturl ( )", "docstring_tokens": "Remove params query and fragment parts from URL so that os . path . basename and os . path . splitext can work correctly .", "label": 0}, {"idx": "cosqa-train-2097", "doc": "wrap single line strings python as", "code": "def wrap(string, length, indent):\n    \"\"\" Wrap a string at a line length \"\"\"\n    newline = \"\\n\" + \" \" * indent\n    return newline.join((string[i : i + length] for i in range(0, len(string), length)))", "code_tokens": "def wrap ( string , length , indent ) : newline = \"\\n\" + \" \" * indent return newline . join ( ( string [ i : i + length ] for i in range ( 0 , len ( string ) , length ) ) )", "docstring_tokens": "Wrap a string at a line length", "label": 0}, {"idx": "cosqa-train-2098", "doc": "python clear all figures", "code": "def close_all():\n    \"\"\"Close all open/active plotters\"\"\"\n    for key, p in _ALL_PLOTTERS.items():\n        p.close()\n    _ALL_PLOTTERS.clear()\n    return True", "code_tokens": "def close_all ( ) : for key , p in _ALL_PLOTTERS . items ( ) : p . close ( ) _ALL_PLOTTERS . clear ( ) return True", "docstring_tokens": "Close all open / active plotters", "label": 0}, {"idx": "cosqa-train-2099", "doc": "write a float to a binary file python", "code": "def write_float(self, number):\n        \"\"\" Writes a float to the underlying output file as a 4-byte value. \"\"\"\n        buf = pack(self.byte_order + \"f\", number)\n        self.write(buf)", "code_tokens": "def write_float ( self , number ) : buf = pack ( self . byte_order + \"f\" , number ) self . write ( buf )", "docstring_tokens": "Writes a float to the underlying output file as a 4 - byte value .", "label": 1}, {"idx": "cosqa-train-2100", "doc": "python clear leading whitespace", "code": "def _delete_whitespace(self):\n        \"\"\"Delete all whitespace from the end of the line.\"\"\"\n        while isinstance(self._lines[-1], (self._Space, self._LineBreak,\n                                           self._Indent)):\n            del self._lines[-1]", "code_tokens": "def _delete_whitespace ( self ) : while isinstance ( self . _lines [ - 1 ] , ( self . _Space , self . _LineBreak , self . _Indent ) ) : del self . _lines [ - 1 ]", "docstring_tokens": "Delete all whitespace from the end of the line .", "label": 1}, {"idx": "cosqa-train-2101", "doc": "write a program that calculates the angle between two observed points python", "code": "def angle_between_vectors(x, y):\n    \"\"\" Compute the angle between vector x and y \"\"\"\n    dp = dot_product(x, y)\n    if dp == 0:\n        return 0\n    xm = magnitude(x)\n    ym = magnitude(y)\n    return math.acos(dp / (xm*ym)) * (180. / math.pi)", "code_tokens": "def angle_between_vectors ( x , y ) : dp = dot_product ( x , y ) if dp == 0 : return 0 xm = magnitude ( x ) ym = magnitude ( y ) return math . acos ( dp / ( xm * ym ) ) * ( 180. / math . pi )", "docstring_tokens": "Compute the angle between vector x and y", "label": 0}, {"idx": "cosqa-train-2102", "doc": "python close socket port", "code": "def socket_close(self):\n        \"\"\"Close our socket.\"\"\"\n        if self.sock != NC.INVALID_SOCKET:\n            self.sock.close()\n        self.sock = NC.INVALID_SOCKET", "code_tokens": "def socket_close ( self ) : if self . sock != NC . INVALID_SOCKET : self . sock . close ( ) self . sock = NC . INVALID_SOCKET", "docstring_tokens": "Close our socket .", "label": 0}, {"idx": "cosqa-train-2103", "doc": "write a python program to read first n lines of a file", "code": "def head(filename, n=10):\n    \"\"\" prints the top `n` lines of a file \"\"\"\n    with freader(filename) as fr:\n        for _ in range(n):\n            print(fr.readline().strip())", "code_tokens": "def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )", "docstring_tokens": "prints the top n lines of a file", "label": 0}, {"idx": "cosqa-train-2104", "doc": "python close websockets connection", "code": "def _close_websocket(self):\n        \"\"\"Closes the websocket connection.\"\"\"\n        close_method = getattr(self._websocket, \"close\", None)\n        if callable(close_method):\n            asyncio.ensure_future(close_method(), loop=self._event_loop)\n        self._websocket = None\n        self._dispatch_event(event=\"close\")", "code_tokens": "def _close_websocket ( self ) : close_method = getattr ( self . _websocket , \"close\" , None ) if callable ( close_method ) : asyncio . ensure_future ( close_method ( ) , loop = self . _event_loop ) self . _websocket = None self . _dispatch_event ( event = \"close\" )", "docstring_tokens": "Closes the websocket connection .", "label": 0}, {"idx": "cosqa-train-2105", "doc": "write python data into pickles", "code": "def pickle_data(data, picklefile):\n    \"\"\"Helper function to pickle `data` in `picklefile`.\"\"\"\n    with open(picklefile, 'wb') as f:\n        pickle.dump(data, f, protocol=2)", "code_tokens": "def pickle_data ( data , picklefile ) : with open ( picklefile , 'wb' ) as f : pickle . dump ( data , f , protocol = 2 )", "docstring_tokens": "Helper function to pickle data in picklefile .", "label": 1}, {"idx": "cosqa-train-2106", "doc": "python code example least squares best fit", "code": "def fit_select_best(X, y):\n    \"\"\"\n    Selects the best fit of the estimators already implemented by choosing the\n    model with the smallest mean square error metric for the trained values.\n    \"\"\"\n    models = [fit(X,y) for fit in [fit_linear, fit_quadratic]]\n    errors = map(lambda model: mse(y, model.predict(X)), models)\n\n    return min(zip(models, errors), key=itemgetter(1))[0]", "code_tokens": "def fit_select_best ( X , y ) : models = [ fit ( X , y ) for fit in [ fit_linear , fit_quadratic ] ] errors = map ( lambda model : mse ( y , model . predict ( X ) ) , models ) return min ( zip ( models , errors ) , key = itemgetter ( 1 ) ) [ 0 ]", "docstring_tokens": "Selects the best fit of the estimators already implemented by choosing the model with the smallest mean square error metric for the trained values .", "label": 0}, {"idx": "cosqa-train-2107", "doc": "writing softmax function python", "code": "def softmax(attrs, inputs, proto_obj):\n    \"\"\"Softmax function.\"\"\"\n    if 'axis' not in attrs:\n        attrs = translation_utils._add_extra_attributes(attrs, {'axis': 1})\n    return 'softmax', attrs, inputs", "code_tokens": "def softmax ( attrs , inputs , proto_obj ) : if 'axis' not in attrs : attrs = translation_utils . _add_extra_attributes ( attrs , { 'axis' : 1 } ) return 'softmax' , attrs , inputs", "docstring_tokens": "Softmax function .", "label": 0}, {"idx": "cosqa-train-2108", "doc": "python code for butter wirth filter", "code": "def filtered_image(self, im):\n        \"\"\"Returns a filtered image after applying the Fourier-space filters\"\"\"\n        q = np.fft.fftn(im)\n        for k,v in self.filters:\n            q[k] -= v\n        return np.real(np.fft.ifftn(q))", "code_tokens": "def filtered_image ( self , im ) : q = np . fft . fftn ( im ) for k , v in self . filters : q [ k ] -= v return np . real ( np . fft . ifftn ( q ) )", "docstring_tokens": "Returns a filtered image after applying the Fourier - space filters", "label": 1}, {"idx": "cosqa-train-2109", "doc": "wxpython disable window close", "code": "def disable_wx(self):\n        \"\"\"Disable event loop integration with wxPython.\n\n        This merely sets PyOS_InputHook to NULL.\n        \"\"\"\n        if self._apps.has_key(GUI_WX):\n            self._apps[GUI_WX]._in_event_loop = False\n        self.clear_inputhook()", "code_tokens": "def disable_wx ( self ) : if self . _apps . has_key ( GUI_WX ) : self . _apps [ GUI_WX ] . _in_event_loop = False self . clear_inputhook ( )", "docstring_tokens": "Disable event loop integration with wxPython .", "label": 0}, {"idx": "cosqa-train-2110", "doc": "python code for changing color of output text", "code": "def underline(self, msg):\n        \"\"\"Underline the input\"\"\"\n        return click.style(msg, underline=True) if self.colorize else msg", "code_tokens": "def underline ( self , msg ) : return click . style ( msg , underline = True ) if self . colorize else msg", "docstring_tokens": "Underline the input", "label": 0}, {"idx": "cosqa-train-2111", "doc": "wxpython popup auto close", "code": "def on_close(self, evt):\n    \"\"\"\n    Pop-up menu and wx.EVT_CLOSE closing event\n    \"\"\"\n    self.stop() # DoseWatcher\n    if evt.EventObject is not self: # Avoid deadlocks\n      self.Close() # wx.Frame\n    evt.Skip()", "code_tokens": "def on_close ( self , evt ) : self . stop ( ) # DoseWatcher if evt . EventObject is not self : # Avoid deadlocks self . Close ( ) # wx.Frame evt . Skip ( )", "docstring_tokens": "Pop - up menu and wx . EVT_CLOSE closing event", "label": 0}, {"idx": "cosqa-train-2112", "doc": "python code for cifar 10 data set without batches", "code": "def afx_small():\n  \"\"\"Small transformer model with small batch size for fast step times.\"\"\"\n  hparams = transformer.transformer_tpu()\n  hparams.filter_size = 1024\n  hparams.num_heads = 4\n  hparams.num_hidden_layers = 3\n  hparams.batch_size = 512\n  return hparams", "code_tokens": "def afx_small ( ) : hparams = transformer . transformer_tpu ( ) hparams . filter_size = 1024 hparams . num_heads = 4 hparams . num_hidden_layers = 3 hparams . batch_size = 512 return hparams", "docstring_tokens": "Small transformer model with small batch size for fast step times .", "label": 0}, {"idx": "cosqa-train-2113", "doc": "wxpython scrollbar doesn't update position with key press", "code": "def restore_scrollbar_position(self):\n        \"\"\"Restoring scrollbar position after main window is visible\"\"\"\n        scrollbar_pos = self.get_option('scrollbar_position', None)\n        if scrollbar_pos is not None:\n            self.explorer.treewidget.set_scrollbar_position(scrollbar_pos)", "code_tokens": "def restore_scrollbar_position ( self ) : scrollbar_pos = self . get_option ( 'scrollbar_position' , None ) if scrollbar_pos is not None : self . explorer . treewidget . set_scrollbar_position ( scrollbar_pos )", "docstring_tokens": "Restoring scrollbar position after main window is visible", "label": 0}, {"idx": "cosqa-train-2114", "doc": "python code runner is not recognized as an internal or external command", "code": "def IPYTHON_MAIN():\n    \"\"\"Decide if the Ipython command line is running code.\"\"\"\n    import pkg_resources\n\n    runner_frame = inspect.getouterframes(inspect.currentframe())[-2]\n    return (\n        getattr(runner_frame, \"function\", None)\n        == pkg_resources.load_entry_point(\"ipython\", \"console_scripts\", \"ipython\").__name__\n    )", "code_tokens": "def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , \"function\" , None ) == pkg_resources . load_entry_point ( \"ipython\" , \"console_scripts\" , \"ipython\" ) . __name__ )", "docstring_tokens": "Decide if the Ipython command line is running code .", "label": 0}, {"idx": "cosqa-train-2115", "doc": "xlswriter python row width", "code": "def series_table_row_offset(self, series):\n        \"\"\"\n        Return the number of rows preceding the data table for *series* in\n        the Excel worksheet.\n        \"\"\"\n        title_and_spacer_rows = series.index * 2\n        data_point_rows = series.data_point_offset\n        return title_and_spacer_rows + data_point_rows", "code_tokens": "def series_table_row_offset ( self , series ) : title_and_spacer_rows = series . index * 2 data_point_rows = series . data_point_offset return title_and_spacer_rows + data_point_rows", "docstring_tokens": "Return the number of rows preceding the data table for * series * in the Excel worksheet .", "label": 0}, {"idx": "cosqa-train-2116", "doc": "python code to check for file extension", "code": "def is_valid_image_extension(file_path):\n    \"\"\"is_valid_image_extension.\"\"\"\n    valid_extensions = ['.jpeg', '.jpg', '.gif', '.png']\n    _, extension = os.path.splitext(file_path)\n    return extension.lower() in valid_extensions", "code_tokens": "def is_valid_image_extension ( file_path ) : valid_extensions = [ '.jpeg' , '.jpg' , '.gif' , '.png' ] _ , extension = os . path . splitext ( file_path ) return extension . lower ( ) in valid_extensions", "docstring_tokens": "is_valid_image_extension .", "label": 0}, {"idx": "cosqa-train-2117", "doc": "xml getelementsbytagname without tag python", "code": "def getChildElementsByTagName(self, tagName):\n    \"\"\" Return child elements of type tagName if found, else [] \"\"\"\n    result = []\n    for child in self.childNodes:\n        if isinstance(child, Element):\n            if child.tagName == tagName:\n                result.append(child)\n    return result", "code_tokens": "def getChildElementsByTagName ( self , tagName ) : result = [ ] for child in self . childNodes : if isinstance ( child , Element ) : if child . tagName == tagName : result . append ( child ) return result", "docstring_tokens": "Return child elements of type tagName if found else []", "label": 0}, {"idx": "cosqa-train-2118", "doc": "python code to check spearman correlation coefficient", "code": "def mcc(y_true, y_pred, round=True):\n    \"\"\"Matthews correlation coefficient\n    \"\"\"\n    y_true, y_pred = _mask_value_nan(y_true, y_pred)\n    if round:\n        y_true = np.round(y_true)\n        y_pred = np.round(y_pred)\n    return skm.matthews_corrcoef(y_true, y_pred)", "code_tokens": "def mcc ( y_true , y_pred , round = True ) : y_true , y_pred = _mask_value_nan ( y_true , y_pred ) if round : y_true = np . round ( y_true ) y_pred = np . round ( y_pred ) return skm . matthews_corrcoef ( y_true , y_pred )", "docstring_tokens": "Matthews correlation coefficient", "label": 0}, {"idx": "cosqa-train-2119", "doc": "xsd file to python object", "code": "def from_file(cls, file_path, validate=True):\n        \"\"\" Creates a Python object from a XML file\n\n        :param file_path: Path to the XML file\n        :param validate: XML should be validated against the embedded XSD definition\n        :type validate: Boolean\n        :returns: the Python object\n        \"\"\"\n        return xmlmap.load_xmlobject_from_file(file_path, xmlclass=cls, validate=validate)", "code_tokens": "def from_file ( cls , file_path , validate = True ) : return xmlmap . load_xmlobject_from_file ( file_path , xmlclass = cls , validate = validate )", "docstring_tokens": "Creates a Python object from a XML file", "label": 1}, {"idx": "cosqa-train-2120", "doc": "python code to check usb device connedted", "code": "def kernelDriverActive(self, interface):\n        \"\"\"\n        Tell whether a kernel driver is active on given interface number.\n        \"\"\"\n        result = libusb1.libusb_kernel_driver_active(self.__handle, interface)\n        if result == 0:\n            return False\n        elif result == 1:\n            return True\n        raiseUSBError(result)", "code_tokens": "def kernelDriverActive ( self , interface ) : result = libusb1 . libusb_kernel_driver_active ( self . __handle , interface ) if result == 0 : return False elif result == 1 : return True raiseUSBError ( result )", "docstring_tokens": "Tell whether a kernel driver is active on given interface number .", "label": 0}, {"idx": "cosqa-train-2121", "doc": "xsd validation libraries for python", "code": "def schemaValidateFile(self, filename, options):\n        \"\"\"Do a schemas validation of the given resource, it will use\n           the SAX streamable validation internally. \"\"\"\n        ret = libxml2mod.xmlSchemaValidateFile(self._o, filename, options)\n        return ret", "code_tokens": "def schemaValidateFile ( self , filename , options ) : ret = libxml2mod . xmlSchemaValidateFile ( self . _o , filename , options ) return ret", "docstring_tokens": "Do a schemas validation of the given resource it will use the SAX streamable validation internally .", "label": 0}, {"idx": "cosqa-train-2122", "doc": "python code to clear all variables at the start of code execution", "code": "def clear_globals_reload_modules(self):\n        \"\"\"Clears globals and reloads modules\"\"\"\n\n        self.code_array.clear_globals()\n        self.code_array.reload_modules()\n\n        # Clear result cache\n        self.code_array.result_cache.clear()", "code_tokens": "def clear_globals_reload_modules ( self ) : self . code_array . clear_globals ( ) self . code_array . reload_modules ( ) # Clear result cache self . code_array . result_cache . clear ( )", "docstring_tokens": "Clears globals and reloads modules", "label": 1}, {"idx": "cosqa-train-2123", "doc": "zero matrix without numpy python", "code": "def prox_zero(X, step):\n    \"\"\"Proximal operator to project onto zero\n    \"\"\"\n    return np.zeros(X.shape, dtype=X.dtype)", "code_tokens": "def prox_zero ( X , step ) : return np . zeros ( X . shape , dtype = X . dtype )", "docstring_tokens": "Proximal operator to project onto zero", "label": 0}, {"idx": "cosqa-train-2124", "doc": "python code to count no of rows in table in python", "code": "def count_rows(self, table_name):\n        \"\"\"Return the number of entries in a table by counting them.\"\"\"\n        self.table_must_exist(table_name)\n        query = \"SELECT COUNT (*) FROM `%s`\" % table_name.lower()\n        self.own_cursor.execute(query)\n        return int(self.own_cursor.fetchone()[0])", "code_tokens": "def count_rows ( self , table_name ) : self . table_must_exist ( table_name ) query = \"SELECT COUNT (*) FROM `%s`\" % table_name . lower ( ) self . own_cursor . execute ( query ) return int ( self . own_cursor . fetchone ( ) [ 0 ] )", "docstring_tokens": "Return the number of entries in a table by counting them .", "label": 0}, {"idx": "cosqa-train-2125", "doc": "python code to make a dir", "code": "def mkdir(dir, enter):\n    \"\"\"Create directory with template for topic of the current environment\n\n    \"\"\"\n\n    if not os.path.exists(dir):\n        os.makedirs(dir)", "code_tokens": "def mkdir ( dir , enter ) : if not os . path . exists ( dir ) : os . makedirs ( dir )", "docstring_tokens": "Create directory with template for topic of the current environment", "label": 1}, {"idx": "cosqa-train-2126", "doc": "python code to replace string", "code": "def myreplace(astr, thefind, thereplace):\n    \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"\n    alist = astr.split(thefind)\n    new_s = alist.split(thereplace)\n    return new_s", "code_tokens": "def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "docstring_tokens": "in string astr replace all occurences of thefind with thereplace", "label": 0}, {"idx": "cosqa-train-2127", "doc": "python ctypes define argtypes on a pointer to a pointer", "code": "def POINTER(obj):\n    \"\"\"\n    Create ctypes pointer to object.\n\n    Notes\n    -----\n    This function converts None to a real NULL pointer because of bug\n    in how ctypes handles None on 64-bit platforms.\n\n    \"\"\"\n\n    p = ctypes.POINTER(obj)\n    if not isinstance(p.from_param, classmethod):\n        def from_param(cls, x):\n            if x is None:\n                return cls()\n            else:\n                return x\n        p.from_param = classmethod(from_param)\n\n    return p", "code_tokens": "def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p", "docstring_tokens": "Create ctypes pointer to object .", "label": 1}, {"idx": "cosqa-train-2128", "doc": "\"object of type 'datetime' is not json serializable\", postgres python", "code": "def _time_to_json(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\"\"\"\n    if isinstance(value, datetime.time):\n        value = value.isoformat()\n    return value", "code_tokens": "def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 0}, {"idx": "cosqa-train-2129", "doc": "python ctypes dll deallocate", "code": "def cleanup_lib(self):\n        \"\"\" unload the previously loaded shared library \"\"\"\n        if not self.using_openmp:\n            #this if statement is necessary because shared libraries that use\n            #OpenMP will core dump when unloaded, this is a well-known issue with OpenMP\n            logging.debug('unloading shared library')\n            _ctypes.dlclose(self.lib._handle)", "code_tokens": "def cleanup_lib ( self ) : if not self . using_openmp : #this if statement is necessary because shared libraries that use #OpenMP will core dump when unloaded, this is a well-known issue with OpenMP logging . debug ( 'unloading shared library' ) _ctypes . dlclose ( self . lib . _handle )", "docstring_tokens": "unload the previously loaded shared library", "label": 0}, {"idx": "cosqa-train-2130", "doc": "ascending and descending order dynamic python \"range\"", "code": "def negate(self):\n        \"\"\"Reverse the range\"\"\"\n        self.from_value, self.to_value = self.to_value, self.from_value\n        self.include_lower, self.include_upper = self.include_upper, self.include_lower", "code_tokens": "def negate ( self ) : self . from_value , self . to_value = self . to_value , self . from_value self . include_lower , self . include_upper = self . include_upper , self . include_lower", "docstring_tokens": "Reverse the range", "label": 0}, {"idx": "cosqa-train-2131", "doc": "python ctypes float to int", "code": "def cfloat32_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes float pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_float)):\n        return np.fromiter(cptr, dtype=np.float32, count=length)\n    else:\n        raise RuntimeError('Expected float pointer')", "code_tokens": "def cfloat32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_float ) ) : return np . fromiter ( cptr , dtype = np . float32 , count = length ) else : raise RuntimeError ( 'Expected float pointer' )", "docstring_tokens": "Convert a ctypes float pointer array to a numpy array .", "label": 0}, {"idx": "cosqa-train-2132", "doc": "how to check if \" is in python string", "code": "def is_identifier(string):\n    \"\"\"Check if string could be a valid python identifier\n\n    :param string: string to be tested\n    :returns: True if string can be a python identifier, False otherwise\n    :rtype: bool\n    \"\"\"\n    matched = PYTHON_IDENTIFIER_RE.match(string)\n    return bool(matched) and not keyword.iskeyword(string)", "code_tokens": "def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )", "docstring_tokens": "Check if string could be a valid python identifier", "label": 0}, {"idx": "cosqa-train-2133", "doc": "python ctypes indefinite length array", "code": "def cint8_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes int pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)):\n        return np.fromiter(cptr, dtype=np.int8, count=length)\n    else:\n        raise RuntimeError('Expected int pointer')", "code_tokens": "def cint8_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int8 ) ) : return np . fromiter ( cptr , dtype = np . int8 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "docstring_tokens": "Convert a ctypes int pointer array to a numpy array .", "label": 0}, {"idx": "cosqa-train-2134", "doc": "python \"resource has no attribute\"", "code": "def get_resource_attribute(self, attr):\n        \"\"\"Gets the resource attribute if available\n\n        :param attr: Name of the attribute\n        :return: Value of the attribute, if set in the resource. None otherwise\n        \"\"\"\n        if attr not in self.resource_attributes:\n            raise KeyError(\"%s is not in resource attributes\" % attr)\n\n        return self.resource_attributes[attr]", "code_tokens": "def get_resource_attribute ( self , attr ) : if attr not in self . resource_attributes : raise KeyError ( \"%s is not in resource attributes\" % attr ) return self . resource_attributes [ attr ]", "docstring_tokens": "Gets the resource attribute if available", "label": 0}, {"idx": "cosqa-train-2135", "doc": "python ctypes pass var to cpp constructor", "code": "def POINTER(obj):\n    \"\"\"\n    Create ctypes pointer to object.\n\n    Notes\n    -----\n    This function converts None to a real NULL pointer because of bug\n    in how ctypes handles None on 64-bit platforms.\n\n    \"\"\"\n\n    p = ctypes.POINTER(obj)\n    if not isinstance(p.from_param, classmethod):\n        def from_param(cls, x):\n            if x is None:\n                return cls()\n            else:\n                return x\n        p.from_param = classmethod(from_param)\n\n    return p", "code_tokens": "def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p", "docstring_tokens": "Create ctypes pointer to object .", "label": 0}, {"idx": "cosqa-train-2136", "doc": "python \"the event loop is already running\"", "code": "def run(self):\n        \"\"\"Run the event loop.\"\"\"\n        self.signal_init()\n        self.listen_init()\n        self.logger.info('starting')\n        self.loop.start()", "code_tokens": "def run ( self ) : self . signal_init ( ) self . listen_init ( ) self . logger . info ( 'starting' ) self . loop . start ( )", "docstring_tokens": "Run the event loop .", "label": 1}, {"idx": "cosqa-train-2137", "doc": "python ctypes setting buffer to 0", "code": "def _ram_buffer(self):\n        \"\"\"Setup the RAM buffer from the C++ code.\"\"\"\n        # get the address of the RAM\n        address = _LIB.Memory(self._env)\n        # create a buffer from the contents of the address location\n        buffer_ = ctypes.cast(address, ctypes.POINTER(RAM_VECTOR)).contents\n        # create a NumPy array from the buffer\n        return np.frombuffer(buffer_, dtype='uint8')", "code_tokens": "def _ram_buffer ( self ) : # get the address of the RAM address = _LIB . Memory ( self . _env ) # create a buffer from the contents of the address location buffer_ = ctypes . cast ( address , ctypes . POINTER ( RAM_VECTOR ) ) . contents # create a NumPy array from the buffer return np . frombuffer ( buffer_ , dtype = 'uint8' )", "docstring_tokens": "Setup the RAM buffer from the C ++ code .", "label": 1}, {"idx": "cosqa-train-2138", "doc": "python 3 \"object of type 'bytes' is not json serializable\"", "code": "def loadb(b):\n    \"\"\"Deserialize ``b`` (instance of ``bytes``) to a Python object.\"\"\"\n    assert isinstance(b, (bytes, bytearray))\n    return std_json.loads(b.decode('utf-8'))", "code_tokens": "def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )", "docstring_tokens": "Deserialize b ( instance of bytes ) to a Python object .", "label": 0}, {"idx": "cosqa-train-2139", "doc": "python cumulative sum list", "code": "def cumsum(inlist):\n    \"\"\"\nReturns a list consisting of the cumulative sum of the items in the\npassed list.\n\nUsage:   lcumsum(inlist)\n\"\"\"\n    newlist = copy.deepcopy(inlist)\n    for i in range(1, len(newlist)):\n        newlist[i] = newlist[i] + newlist[i - 1]\n    return newlist", "code_tokens": "def cumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist", "docstring_tokens": "Returns a list consisting of the cumulative sum of the items in the passed list .", "label": 1}, {"idx": "cosqa-train-2140", "doc": "python iso utc strftime \"utc offset\"", "code": "def __consistent_isoformat_utc(datetime_val):\n        \"\"\"\n        Function that does what isoformat does but it actually does the same\n        every time instead of randomly doing different things on some systems\n        and also it represents that time as the equivalent UTC time.\n        \"\"\"\n        isotime = datetime_val.astimezone(pytz.utc).strftime(\"%Y-%m-%dT%H:%M:%S%z\")\n        if isotime[-2] != \":\":\n            isotime = isotime[:-2] + \":\" + isotime[-2:]\n        return isotime", "code_tokens": "def __consistent_isoformat_utc ( datetime_val ) : isotime = datetime_val . astimezone ( pytz . utc ) . strftime ( \"%Y-%m-%dT%H:%M:%S%z\" ) if isotime [ - 2 ] != \":\" : isotime = isotime [ : - 2 ] + \":\" + isotime [ - 2 : ] return isotime", "docstring_tokens": "Function that does what isoformat does but it actually does the same every time instead of randomly doing different things on some systems and also it represents that time as the equivalent UTC time .", "label": 0}, {"idx": "cosqa-train-2141", "doc": "python curly brakcet string fixed width", "code": "def _swap_curly(string):\n    \"\"\"Swap single and double curly brackets\"\"\"\n    return (\n        string.replace('{{ ', '{{').replace('{{', '\\x00').replace('{', '{{')\n        .replace('\\x00', '{').replace(' }}', '}}').replace('}}', '\\x00')\n        .replace('}', '}}').replace('\\x00', '}')\n    )", "code_tokens": "def _swap_curly ( string ) : return ( string . replace ( '{{ ' , '{{' ) . replace ( '{{' , '\\x00' ) . replace ( '{' , '{{' ) . replace ( '\\x00' , '{' ) . replace ( ' }}' , '}}' ) . replace ( '}}' , '\\x00' ) . replace ( '}' , '}}' ) . replace ( '\\x00' , '}' ) )", "docstring_tokens": "Swap single and double curly brackets", "label": 0}, {"idx": "cosqa-train-2142", "doc": "python tensorflow can only concatenate list (not \"int\") to list", "code": "def _int64_feature(value):\n  \"\"\"Wrapper for inserting int64 features into Example proto.\"\"\"\n  if not isinstance(value, list):\n    value = [value]\n  return tf.train.Feature(int64_list=tf.train.Int64List(value=value))", "code_tokens": "def _int64_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( int64_list = tf . train . Int64List ( value = value ) )", "docstring_tokens": "Wrapper for inserting int64 features into Example proto .", "label": 1}, {"idx": "cosqa-train-2143", "doc": "python current time string no colon", "code": "def now_time(str=False):\n    \"\"\"Get the current time.\"\"\"\n    if str:\n        return datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    return datetime.datetime.now()", "code_tokens": "def now_time ( str = False ) : if str : return datetime . datetime . now ( ) . strftime ( \"%Y-%m-%d %H:%M:%S\" ) return datetime . datetime . now ( )", "docstring_tokens": "Get the current time .", "label": 0}, {"idx": "cosqa-train-2144", "doc": "'function' object has no attribute 'predict' python", "code": "def _do_auto_predict(machine, X, *args):\n    \"\"\"Performs an automatic prediction for the specified machine and returns\n    the predicted values.\n    \"\"\"\n    if auto_predict and hasattr(machine, \"predict\"):\n        return machine.predict(X)", "code_tokens": "def _do_auto_predict ( machine , X , * args ) : if auto_predict and hasattr ( machine , \"predict\" ) : return machine . predict ( X )", "docstring_tokens": "Performs an automatic prediction for the specified machine and returns the predicted values .", "label": 0}, {"idx": "cosqa-train-2145", "doc": "python cursor go to start", "code": "def home(self):\n        \"\"\"Set cursor to initial position and reset any shifting.\"\"\"\n        self.command(c.LCD_RETURNHOME)\n        self._cursor_pos = (0, 0)\n        c.msleep(2)", "code_tokens": "def home ( self ) : self . command ( c . LCD_RETURNHOME ) self . _cursor_pos = ( 0 , 0 ) c . msleep ( 2 )", "docstring_tokens": "Set cursor to initial position and reset any shifting .", "label": 0}, {"idx": "cosqa-train-2146", "doc": "'nonetype' object is not subscriptable sql python", "code": "def _getTypename(self, defn):\n        \"\"\" Returns the SQL typename required to store the given FieldDefinition \"\"\"\n        return 'REAL' if defn.type.float or 'TIME' in defn.type.name or defn.dntoeu else 'INTEGER'", "code_tokens": "def _getTypename ( self , defn ) : return 'REAL' if defn . type . float or 'TIME' in defn . type . name or defn . dntoeu else 'INTEGER'", "docstring_tokens": "Returns the SQL typename required to store the given FieldDefinition", "label": 0}, {"idx": "cosqa-train-2147", "doc": "python cursor result to list", "code": "def INIT_LIST_EXPR(self, cursor):\n        \"\"\"Returns a list of literal values.\"\"\"\n        values = [self.parse_cursor(child)\n                  for child in list(cursor.get_children())]\n        return values", "code_tokens": "def INIT_LIST_EXPR ( self , cursor ) : values = [ self . parse_cursor ( child ) for child in list ( cursor . get_children ( ) ) ] return values", "docstring_tokens": "Returns a list of literal values .", "label": 0}, {"idx": "cosqa-train-2148", "doc": "2d list in python into numpy array", "code": "def torecarray(*args, **kwargs):\n    \"\"\"\n    Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.\n\n    \"\"\"\n\n    import numpy as np\n    return toarray(*args, **kwargs).view(np.recarray)", "code_tokens": "def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )", "docstring_tokens": "Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) .", "label": 0}, {"idx": "cosqa-train-2149", "doc": "python custom data type json", "code": "def json_serial(obj):\n    \"\"\"JSON serializer for objects not serializable by default json code\"\"\"\n    if isinstance(obj, LegipyModel):\n        return obj.to_json()\n    elif isinstance(obj, (datetime.date, datetime.datetime)):\n        return obj.isoformat()\n    raise TypeError(\"Type {0} not serializable\".format(repr(type(obj))))", "code_tokens": "def json_serial ( obj ) : if isinstance ( obj , LegipyModel ) : return obj . to_json ( ) elif isinstance ( obj , ( datetime . date , datetime . datetime ) ) : return obj . isoformat ( ) raise TypeError ( \"Type {0} not serializable\" . format ( repr ( type ( obj ) ) ) )", "docstring_tokens": "JSON serializer for objects not serializable by default json code", "label": 0}, {"idx": "cosqa-train-2150", "doc": "3x2x4 array of floats python", "code": "def as_float_array(a):\n    \"\"\"View the quaternion array as an array of floats\n\n    This function is fast (of order 1 microsecond) because no data is\n    copied; the returned quantity is just a \"view\" of the original.\n\n    The output view has one more dimension (of size 4) than the input\n    array, but is otherwise the same shape.\n\n    \"\"\"\n    return np.asarray(a, dtype=np.quaternion).view((np.double, 4))", "code_tokens": "def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )", "docstring_tokens": "View the quaternion array as an array of floats", "label": 0}, {"idx": "cosqa-train-2151", "doc": "python cv2 image closes immediately", "code": "def cio_close(cio):\n    \"\"\"Wraps openjpeg library function cio_close.\n    \"\"\"\n    OPENJPEG.opj_cio_close.argtypes = [ctypes.POINTER(CioType)]\n    OPENJPEG.opj_cio_close(cio)", "code_tokens": "def cio_close ( cio ) : OPENJPEG . opj_cio_close . argtypes = [ ctypes . POINTER ( CioType ) ] OPENJPEG . opj_cio_close ( cio )", "docstring_tokens": "Wraps openjpeg library function cio_close .", "label": 0}, {"idx": "cosqa-train-2152", "doc": "?python how to remove a trailing substring from a string", "code": "def remove_trailing_string(content, trailing):\n    \"\"\"\n    Strip trailing component `trailing` from `content` if it exists.\n    Used when generating names from view classes.\n    \"\"\"\n    if content.endswith(trailing) and content != trailing:\n        return content[:-len(trailing)]\n    return content", "code_tokens": "def remove_trailing_string ( content , trailing ) : if content . endswith ( trailing ) and content != trailing : return content [ : - len ( trailing ) ] return content", "docstring_tokens": "Strip trailing component trailing from content if it exists . Used when generating names from view classes .", "label": 0}, {"idx": "cosqa-train-2153", "doc": "python cv2 rotate image by degrees", "code": "def rotate_img(im, deg, mode=cv2.BORDER_CONSTANT, interpolation=cv2.INTER_AREA):\n    \"\"\" Rotates an image by deg degrees\n\n    Arguments:\n        deg (float): degree to rotate.\n    \"\"\"\n    r,c,*_ = im.shape\n    M = cv2.getRotationMatrix2D((c//2,r//2),deg,1)\n    return cv2.warpAffine(im,M,(c,r), borderMode=mode, flags=cv2.WARP_FILL_OUTLIERS+interpolation)", "code_tokens": "def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )", "docstring_tokens": "Rotates an image by deg degrees", "label": 0}, {"idx": "cosqa-train-2154", "doc": "a list of variables python", "code": "def format_vars(args):\n    \"\"\"Format the given vars in the form: 'flag=value'\"\"\"\n    variables = []\n    for key, value in args.items():\n        if value:\n            variables += ['{0}={1}'.format(key, value)]\n    return variables", "code_tokens": "def format_vars ( args ) : variables = [ ] for key , value in args . items ( ) : if value : variables += [ '{0}={1}' . format ( key , value ) ] return variables", "docstring_tokens": "Format the given vars in the form : flag = value", "label": 0}, {"idx": "cosqa-train-2155", "doc": "python dash server not closing", "code": "def kill_dashboard(self, check_alive=True):\n        \"\"\"Kill the dashboard.\n\n        Args:\n            check_alive (bool): Raise an exception if the process was already\n                dead.\n        \"\"\"\n        self._kill_process_type(\n            ray_constants.PROCESS_TYPE_DASHBOARD, check_alive=check_alive)", "code_tokens": "def kill_dashboard ( self , check_alive = True ) : self . _kill_process_type ( ray_constants . PROCESS_TYPE_DASHBOARD , check_alive = check_alive )", "docstring_tokens": "Kill the dashboard .", "label": 0}, {"idx": "cosqa-train-2156", "doc": "accuracy of a model python", "code": "def cat_acc(y_true, y_pred):\n    \"\"\"Categorical accuracy\n    \"\"\"\n    return np.mean(y_true.argmax(axis=1) == y_pred.argmax(axis=1))", "code_tokens": "def cat_acc ( y_true , y_pred ) : return np . mean ( y_true . argmax ( axis = 1 ) == y_pred . argmax ( axis = 1 ) )", "docstring_tokens": "Categorical accuracy", "label": 0}, {"idx": "cosqa-train-2157", "doc": "python date from datetime string", "code": "def string_to_date(value):\n    \"\"\"\n    Return a Python date that corresponds to the specified string\n    representation.\n\n    @param value: string representation of a date.\n\n    @return: an instance ``datetime.datetime`` represented by the string.\n    \"\"\"\n    if isinstance(value, datetime.date):\n        return value\n\n    return dateutil.parser.parse(value).date()", "code_tokens": "def string_to_date ( value ) : if isinstance ( value , datetime . date ) : return value return dateutil . parser . parse ( value ) . date ( )", "docstring_tokens": "Return a Python date that corresponds to the specified string representation .", "label": 0}, {"idx": "cosqa-train-2158", "doc": "activation function for the output layer keras python", "code": "def softplus(attrs, inputs, proto_obj):\n    \"\"\"Applies the sofplus activation function element-wise to the input.\"\"\"\n    new_attrs = translation_utils._add_extra_attributes(attrs, {'act_type' : 'softrelu'})\n    return 'Activation', new_attrs, inputs", "code_tokens": "def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs", "docstring_tokens": "Applies the sofplus activation function element - wise to the input .", "label": 0}, {"idx": "cosqa-train-2159", "doc": "add header and footer to python print", "code": "def print_with_header(header, message, color, indent=0):\n    \"\"\"\n    Use one of the functions below for printing, not this one.\n    \"\"\"\n    print()\n    padding = ' ' * indent\n    print(padding + color + BOLD + header + ENDC + color + message + ENDC)", "code_tokens": "def print_with_header ( header , message , color , indent = 0 ) : print ( ) padding = ' ' * indent print ( padding + color + BOLD + header + ENDC + color + message + ENDC )", "docstring_tokens": "Use one of the functions below for printing not this one .", "label": 0}, {"idx": "cosqa-train-2160", "doc": "python datetime set microsecond", "code": "def from_timestamp(microsecond_timestamp):\n    \"\"\"Convert a microsecond timestamp to a UTC datetime instance.\"\"\"\n    # Create datetime without losing precision from floating point (yes, this\n    # is actually needed):\n    return datetime.datetime.fromtimestamp(\n        microsecond_timestamp // 1000000, datetime.timezone.utc\n    ).replace(microsecond=(microsecond_timestamp % 1000000))", "code_tokens": "def from_timestamp ( microsecond_timestamp ) : # Create datetime without losing precision from floating point (yes, this # is actually needed): return datetime . datetime . fromtimestamp ( microsecond_timestamp // 1000000 , datetime . timezone . utc ) . replace ( microsecond = ( microsecond_timestamp % 1000000 ) )", "docstring_tokens": "Convert a microsecond timestamp to a UTC datetime instance .", "label": 1}, {"idx": "cosqa-train-2161", "doc": "add margin to a figure python", "code": "def calculate_top_margin(self):\n\t\t\"\"\"\n\t\tCalculate the margin in pixels above the plot area, setting\n\t\tborder_top.\n\t\t\"\"\"\n\t\tself.border_top = 5\n\t\tif self.show_graph_title:\n\t\t\tself.border_top += self.title_font_size\n\t\tself.border_top += 5\n\t\tif self.show_graph_subtitle:\n\t\t\tself.border_top += self.subtitle_font_size", "code_tokens": "def calculate_top_margin ( self ) : self . border_top = 5 if self . show_graph_title : self . border_top += self . title_font_size self . border_top += 5 if self . show_graph_subtitle : self . border_top += self . subtitle_font_size", "docstring_tokens": "Calculate the margin in pixels above the plot area setting border_top .", "label": 0}, {"idx": "cosqa-train-2162", "doc": "python datetime string to utc timestamp", "code": "def timestamp_from_datetime(dt):\n    \"\"\"\n    Compute timestamp from a datetime object that could be timezone aware\n    or unaware.\n    \"\"\"\n    try:\n        utc_dt = dt.astimezone(pytz.utc)\n    except ValueError:\n        utc_dt = dt.replace(tzinfo=pytz.utc)\n    return timegm(utc_dt.timetuple())", "code_tokens": "def timestamp_from_datetime ( dt ) : try : utc_dt = dt . astimezone ( pytz . utc ) except ValueError : utc_dt = dt . replace ( tzinfo = pytz . utc ) return timegm ( utc_dt . timetuple ( ) )", "docstring_tokens": "Compute timestamp from a datetime object that could be timezone aware or unaware .", "label": 1}, {"idx": "cosqa-train-2163", "doc": "add margins to subplots python", "code": "def calculate_top_margin(self):\n\t\t\"\"\"\n\t\tCalculate the margin in pixels above the plot area, setting\n\t\tborder_top.\n\t\t\"\"\"\n\t\tself.border_top = 5\n\t\tif self.show_graph_title:\n\t\t\tself.border_top += self.title_font_size\n\t\tself.border_top += 5\n\t\tif self.show_graph_subtitle:\n\t\t\tself.border_top += self.subtitle_font_size", "code_tokens": "def calculate_top_margin ( self ) : self . border_top = 5 if self . show_graph_title : self . border_top += self . title_font_size self . border_top += 5 if self . show_graph_subtitle : self . border_top += self . subtitle_font_size", "docstring_tokens": "Calculate the margin in pixels above the plot area setting border_top .", "label": 0}, {"idx": "cosqa-train-2164", "doc": "python datetime to epoch milliseconds", "code": "def _DateToEpoch(date):\n  \"\"\"Converts python datetime to epoch microseconds.\"\"\"\n  tz_zero = datetime.datetime.utcfromtimestamp(0)\n  diff_sec = int((date - tz_zero).total_seconds())\n  return diff_sec * 1000000", "code_tokens": "def _DateToEpoch ( date ) : tz_zero = datetime . datetime . utcfromtimestamp ( 0 ) diff_sec = int ( ( date - tz_zero ) . total_seconds ( ) ) return diff_sec * 1000000", "docstring_tokens": "Converts python datetime to epoch microseconds .", "label": 0}, {"idx": "cosqa-train-2165", "doc": "add message at exit python", "code": "def _quit(self, *args):\n        \"\"\" quit crash \"\"\"\n        self.logger.warn('Bye!')\n        sys.exit(self.exit())", "code_tokens": "def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )", "docstring_tokens": "quit crash", "label": 0}, {"idx": "cosqa-train-2166", "doc": "add milliseconds to datetime python", "code": "def datetime_to_ms(dt):\n    \"\"\"\n    Converts a datetime to a millisecond accuracy timestamp\n    \"\"\"\n    seconds = calendar.timegm(dt.utctimetuple())\n    return seconds * 1000 + int(dt.microsecond / 1000)", "code_tokens": "def datetime_to_ms ( dt ) : seconds = calendar . timegm ( dt . utctimetuple ( ) ) return seconds * 1000 + int ( dt . microsecond / 1000 )", "docstring_tokens": "Converts a datetime to a millisecond accuracy timestamp", "label": 1}, {"idx": "cosqa-train-2167", "doc": "python dateutil first day of month", "code": "def monthly(date=datetime.date.today()):\n    \"\"\"\n    Take a date object and return the first day of the month.\n    \"\"\"\n    return datetime.date(date.year, date.month, 1)", "code_tokens": "def monthly ( date = datetime . date . today ( ) ) : return datetime . date ( date . year , date . month , 1 )", "docstring_tokens": "Take a date object and return the first day of the month .", "label": 1}, {"idx": "cosqa-train-2168", "doc": "add new fields to an object python", "code": "def update_dict(obj, dict, attributes):\n    \"\"\"Update dict with fields from obj.attributes.\n\n    :param obj: the object updated into dict\n    :param dict: the result dictionary\n    :param attributes: a list of attributes belonging to obj\n    \"\"\"\n    for attribute in attributes:\n        if hasattr(obj, attribute) and getattr(obj, attribute) is not None:\n            dict[attribute] = getattr(obj, attribute)", "code_tokens": "def update_dict ( obj , dict , attributes ) : for attribute in attributes : if hasattr ( obj , attribute ) and getattr ( obj , attribute ) is not None : dict [ attribute ] = getattr ( obj , attribute )", "docstring_tokens": "Update dict with fields from obj . attributes .", "label": 0}, {"idx": "cosqa-train-2169", "doc": "python decode jsonify object", "code": "def _default(self, obj):\n        \"\"\" return a serialized version of obj or raise a TypeError\n\n        :param obj:\n        :return: Serialized version of obj\n        \"\"\"\n        return obj.__dict__ if isinstance(obj, JsonObj) else json.JSONDecoder().decode(obj)", "code_tokens": "def _default ( self , obj ) : return obj . __dict__ if isinstance ( obj , JsonObj ) else json . JSONDecoder ( ) . decode ( obj )", "docstring_tokens": "return a serialized version of obj or raise a TypeError", "label": 0}, {"idx": "cosqa-train-2170", "doc": "add root path in python", "code": "def getpackagepath():\n    \"\"\"\n     *Get the root path for this python package - used in unit testing code*\n    \"\"\"\n    moduleDirectory = os.path.dirname(__file__)\n    packagePath = os.path.dirname(__file__) + \"/../\"\n\n    return packagePath", "code_tokens": "def getpackagepath ( ) : moduleDirectory = os . path . dirname ( __file__ ) packagePath = os . path . dirname ( __file__ ) + \"/../\" return packagePath", "docstring_tokens": "* Get the root path for this python package - used in unit testing code *", "label": 0}, {"idx": "cosqa-train-2171", "doc": "python decorate print funcion", "code": "def print_args(output=sys.stdout):\n    \"\"\"Decorate a function so that print arguments before calling it.\n\n    Args:\n      output: writable to print args. (Default: sys.stdout)\n    \"\"\"\n    def decorator(func):\n        \"\"\"The decorator function.\n        \"\"\"\n        @wraps(func)\n        def _(*args, **kwargs):\n            \"\"\"The decorated function.\n            \"\"\"\n            output.write(\n                \"Args: {0}, KwArgs: {1}\\n\".format(str(args), str(kwargs)))\n            return func(*args, **kwargs)\n        return _\n    return decorator", "code_tokens": "def print_args ( output = sys . stdout ) : def decorator ( func ) : \"\"\"The decorator function.\n        \"\"\" @ wraps ( func ) def _ ( * args , * * kwargs ) : \"\"\"The decorated function.\n            \"\"\" output . write ( \"Args: {0}, KwArgs: {1}\\n\" . format ( str ( args ) , str ( kwargs ) ) ) return func ( * args , * * kwargs ) return _ return decorator", "docstring_tokens": "Decorate a function so that print arguments before calling it .", "label": 0}, {"idx": "cosqa-train-2172", "doc": "adding a matrix to another matrix python", "code": "def __add__(self,other):\n        \"\"\"\n            If the number of columns matches, we can concatenate two LabeldMatrices\n            with the + operator.\n        \"\"\"\n        assert self.matrix.shape[1] == other.matrix.shape[1]\n        return LabeledMatrix(np.concatenate([self.matrix,other.matrix],axis=0),self.labels)", "code_tokens": "def __add__ ( self , other ) : assert self . matrix . shape [ 1 ] == other . matrix . shape [ 1 ] return LabeledMatrix ( np . concatenate ( [ self . matrix , other . matrix ] , axis = 0 ) , self . labels )", "docstring_tokens": "If the number of columns matches we can concatenate two LabeldMatrices with the + operator .", "label": 0}, {"idx": "cosqa-train-2173", "doc": "python deep format of dictionary", "code": "def pretty_dict_string(d, indent=0):\n    \"\"\"Pretty output of nested dictionaries.\n    \"\"\"\n    s = ''\n    for key, value in sorted(d.items()):\n        s += '    ' * indent + str(key)\n        if isinstance(value, dict):\n             s += '\\n' + pretty_dict_string(value, indent+1)\n        else:\n             s += '=' + str(value) + '\\n'\n    return s", "code_tokens": "def pretty_dict_string ( d , indent = 0 ) : s = '' for key , value in sorted ( d . items ( ) ) : s += '    ' * indent + str ( key ) if isinstance ( value , dict ) : s += '\\n' + pretty_dict_string ( value , indent + 1 ) else : s += '=' + str ( value ) + '\\n' return s", "docstring_tokens": "Pretty output of nested dictionaries .", "label": 0}, {"idx": "cosqa-train-2174", "doc": "an integer, a string, and a boolean of an integer for python", "code": "def is_int(value):\n    \"\"\"Return `True` if ``value`` is an integer.\"\"\"\n    if isinstance(value, bool):\n        return False\n    try:\n        int(value)\n        return True\n    except (ValueError, TypeError):\n        return False", "code_tokens": "def is_int ( value ) : if isinstance ( value , bool ) : return False try : int ( value ) return True except ( ValueError , TypeError ) : return False", "docstring_tokens": "Return True if value is an integer .", "label": 0}, {"idx": "cosqa-train-2175", "doc": "python def funciton that return list", "code": "def generator_to_list(fn):\n    \"\"\"This decorator is for flat_list function.\n    It converts returned generator to list.\n    \"\"\"\n    def wrapper(*args, **kw):\n        return list(fn(*args, **kw))\n    return wrapper", "code_tokens": "def generator_to_list ( fn ) : def wrapper ( * args , * * kw ) : return list ( fn ( * args , * * kw ) ) return wrapper", "docstring_tokens": "This decorator is for flat_list function . It converts returned generator to list .", "label": 0}, {"idx": "cosqa-train-2176", "doc": "and multiple figures to save file in python", "code": "def strip_figures(figure):\n\t\"\"\"\n\tStrips a figure into multiple figures with a trace on each of them\n\n\tParameters:\n\t-----------\n\t\tfigure : Figure\n\t\t\tPlotly Figure\n\t\"\"\"\n\tfig=[]\n\tfor trace in figure['data']:\n\t\tfig.append(dict(data=[trace],layout=figure['layout']))\n\treturn fig", "code_tokens": "def strip_figures ( figure ) : fig = [ ] for trace in figure [ 'data' ] : fig . append ( dict ( data = [ trace ] , layout = figure [ 'layout' ] ) ) return fig", "docstring_tokens": "Strips a figure into multiple figures with a trace on each of them", "label": 0}, {"idx": "cosqa-train-2177", "doc": "python define the exponents in a polynomial", "code": "def Square(x, a, b, c):\n    \"\"\"Second order polynomial\n\n    Inputs:\n    -------\n        ``x``: independent variable\n        ``a``: coefficient of the second-order term\n        ``b``: coefficient of the first-order term\n        ``c``: additive constant\n\n    Formula:\n    --------\n        ``a*x^2 + b*x + c``\n    \"\"\"\n    return a * x ** 2 + b * x + c", "code_tokens": "def Square ( x , a , b , c ) : return a * x ** 2 + b * x + c", "docstring_tokens": "Second order polynomial", "label": 0}, {"idx": "cosqa-train-2178", "doc": "angle between two vectors algorithm python", "code": "def vec_angle(a, b):\n    \"\"\"\n    Calculate angle between two vectors\n    \"\"\"\n    cosang = np.dot(a, b)\n    sinang = fast_norm(np.cross(a, b))\n    return np.arctan2(sinang, cosang)", "code_tokens": "def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )", "docstring_tokens": "Calculate angle between two vectors", "label": 0}, {"idx": "cosqa-train-2179", "doc": "python define variable as an array", "code": "def parameter_vector(self):\n        \"\"\"An array of all parameters (including frozen parameters)\"\"\"\n        return np.array([getattr(self, k) for k in self.parameter_names])", "code_tokens": "def parameter_vector ( self ) : return np . array ( [ getattr ( self , k ) for k in self . parameter_names ] )", "docstring_tokens": "An array of all parameters ( including frozen parameters )", "label": 0}, {"idx": "cosqa-train-2180", "doc": "ansi escape sequence python", "code": "def position(self, x, y, text):\n        \"\"\"\n            ANSI Escape sequences\n            http://ascii-table.com/ansi-escape-sequences.php\n        \"\"\"\n        sys.stdout.write(\"\\x1b7\\x1b[%d;%df%s\\x1b8\" % (x, y, text))\n        sys.stdout.flush()", "code_tokens": "def position ( self , x , y , text ) : sys . stdout . write ( \"\\x1b7\\x1b[%d;%df%s\\x1b8\" % ( x , y , text ) ) sys . stdout . flush ( )", "docstring_tokens": "ANSI Escape sequences http : // ascii - table . com / ansi - escape - sequences . php", "label": 1}, {"idx": "cosqa-train-2181", "doc": "python delete a tag", "code": "def del_label(self, name):\n        \"\"\"Delete a label by name.\"\"\"\n        labels_tag = self.root[0]\n        labels_tag.remove(self._find_label(name))", "code_tokens": "def del_label ( self , name ) : labels_tag = self . root [ 0 ] labels_tag . remove ( self . _find_label ( name ) )", "docstring_tokens": "Delete a label by name .", "label": 1}, {"idx": "cosqa-train-2182", "doc": "append string to end of line in file python", "code": "def prepend_line(filepath, line):\n    \"\"\"Rewrite a file adding a line to its beginning.\n    \"\"\"\n    with open(filepath) as f:\n        lines = f.readlines()\n\n    lines.insert(0, line)\n\n    with open(filepath, 'w') as f:\n        f.writelines(lines)", "code_tokens": "def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )", "docstring_tokens": "Rewrite a file adding a line to its beginning .", "label": 0}, {"idx": "cosqa-train-2183", "doc": "python delete none value dict", "code": "def nonull_dict(self):\n        \"\"\"Like dict, but does not hold any null values.\n\n        :return:\n\n        \"\"\"\n        return {k: v for k, v in six.iteritems(self.dict) if v and k != '_codes'}", "code_tokens": "def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }", "docstring_tokens": "Like dict but does not hold any null values .", "label": 0}, {"idx": "cosqa-train-2184", "doc": "apply a function to an entire data frame in python", "code": "def transform(self, df):\n        \"\"\"\n        Transforms a DataFrame in place. Computes all outputs of the DataFrame.\n\n        Args:\n            df (pandas.DataFrame): DataFrame to transform.\n        \"\"\"\n        for name, function in self.outputs:\n            df[name] = function(df)", "code_tokens": "def transform ( self , df ) : for name , function in self . outputs : df [ name ] = function ( df )", "docstring_tokens": "Transforms a DataFrame in place . Computes all outputs of the DataFrame .", "label": 0}, {"idx": "cosqa-train-2185", "doc": "python delete object command on button", "code": "def delete(self, name):\n        \"\"\"Delete object on remote\"\"\"\n        obj = self._get_object(name)\n        if obj:\n            return self.driver.delete_object(obj)", "code_tokens": "def delete ( self , name ) : obj = self . _get_object ( name ) if obj : return self . driver . delete_object ( obj )", "docstring_tokens": "Delete object on remote", "label": 0}, {"idx": "cosqa-train-2186", "doc": "apply upper case function over list of python strings", "code": "def upcaseTokens(s,l,t):\n    \"\"\"Helper parse action to convert tokens to upper case.\"\"\"\n    return [ tt.upper() for tt in map(_ustr,t) ]", "code_tokens": "def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]", "docstring_tokens": "Helper parse action to convert tokens to upper case .", "label": 0}, {"idx": "cosqa-train-2187", "doc": "python describe varible panda", "code": "def desc(self):\n        \"\"\"Get a short description of the device.\"\"\"\n        return '{0} (ID: {1}) - {2} - {3}'.format(\n            self.name, self.device_id, self.type, self.status)", "code_tokens": "def desc ( self ) : return '{0} (ID: {1}) - {2} - {3}' . format ( self . name , self . device_id , self . type , self . status )", "docstring_tokens": "Get a short description of the device .", "label": 0}, {"idx": "cosqa-train-2188", "doc": "applying a filter python", "code": "def filter(self, obj, *args, **kwargs):\n        \"\"\"\n        Filter the given object through the filter chain.\n\n        :param obj: The object to filter\n        :param args: Additional arguments to pass to each filter function.\n        :param kwargs: Additional keyword arguments to pass to each filter\n                       function.\n        :return: The filtered object or :data:`None`\n\n        See the documentation of :class:`Filter` on how filtering operates.\n\n        Returns the object returned by the last function in the filter chain or\n        :data:`None` if any function returned :data:`None`.\n        \"\"\"\n        for _, _, func in self._filter_order:\n            obj = func(obj, *args, **kwargs)\n            if obj is None:\n                return None\n        return obj", "code_tokens": "def filter ( self , obj , * args , * * kwargs ) : for _ , _ , func in self . _filter_order : obj = func ( obj , * args , * * kwargs ) if obj is None : return None return obj", "docstring_tokens": "Filter the given object through the filter chain .", "label": 0}, {"idx": "cosqa-train-2189", "doc": "python designing a time series filter after fourier analysis", "code": "def fft(t, y, pow2=False, window=None, rescale=False):\n    \"\"\"\n    FFT of y, assuming complex or real-valued inputs. This goes through the \n    numpy fourier transform process, assembling and returning (frequencies, \n    complex fft) given time and signal data y.\n\n    Parameters\n    ----------\n    t,y\n        Time (t) and signal (y) arrays with which to perform the fft. Note the t\n        array is assumed to be evenly spaced.\n        \n    pow2 = False\n        Set this to true if you only want to keep the first 2^n data\n        points (speeds up the FFT substantially)\n\n    window = None\n        Can be set to any of the windowing functions in numpy that require only\n        the number of points as the argument, e.g. window='hanning'. \n        \n    rescale = False\n        If True, the FFT will be rescaled by the square root of the ratio of \n        variances before and after windowing, such that the sum of component \n        amplitudes squared is equal to the actual variance.\n    \"\"\"\n    # make sure they're numpy arrays, and make copies to avoid the referencing error\n    y = _n.array(y)\n    t = _n.array(t)\n\n    # if we're doing the power of 2, do it\n    if pow2:\n        keep  = 2**int(_n.log2(len(y)))\n\n        # now resize the data\n        y.resize(keep)\n        t.resize(keep)\n\n    # Window the data\n    if not window in [None, False, 0]:\n        try:\n            # Get the windowing array\n            w = eval(\"_n.\"+window, dict(_n=_n))(len(y))\n            \n            # Store the original variance\n            v0 = _n.average(abs(y)**2)\n            \n            # window the time domain data \n            y = y * w\n            \n            # Rescale by the variance ratio\n            if rescale: y = y * _n.sqrt(v0 / _n.average(abs(y)**2))\n            \n        except:\n            print(\"ERROR: Bad window!\")\n            return\n\n    # do the actual fft, and normalize\n    Y = _n.fft.fftshift( _n.fft.fft(y) / len(t) )\n    f = _n.fft.fftshift( _n.fft.fftfreq(len(t), t[1]-t[0]) )\n    \n    return f, Y", "code_tokens": "def fft ( t , y , pow2 = False , window = None , rescale = False ) : # make sure they're numpy arrays, and make copies to avoid the referencing error y = _n . array ( y ) t = _n . array ( t ) # if we're doing the power of 2, do it if pow2 : keep = 2 ** int ( _n . log2 ( len ( y ) ) ) # now resize the data y . resize ( keep ) t . resize ( keep ) # Window the data if not window in [ None , False , 0 ] : try : # Get the windowing array w = eval ( \"_n.\" + window , dict ( _n = _n ) ) ( len ( y ) ) # Store the original variance v0 = _n . average ( abs ( y ) ** 2 ) # window the time domain data  y = y * w # Rescale by the variance ratio if rescale : y = y * _n . sqrt ( v0 / _n . average ( abs ( y ) ** 2 ) ) except : print ( \"ERROR: Bad window!\" ) return # do the actual fft, and normalize Y = _n . fft . fftshift ( _n . fft . fft ( y ) / len ( t ) ) f = _n . fft . fftshift ( _n . fft . fftfreq ( len ( t ) , t [ 1 ] - t [ 0 ] ) ) return f , Y", "docstring_tokens": "FFT of y assuming complex or real - valued inputs . This goes through the numpy fourier transform process assembling and returning ( frequencies complex fft ) given time and signal data y .", "label": 0}, {"idx": "cosqa-train-2190", "doc": "applying a method to a dictionary python", "code": "def dictapply(d, fn):\n    \"\"\"\n    apply a function to all non-dict values in a dictionary\n    \"\"\"\n    for k, v in d.items():\n        if isinstance(v, dict):\n            v = dictapply(v, fn)\n        else:\n            d[k] = fn(v)\n    return d", "code_tokens": "def dictapply ( d , fn ) : for k , v in d . items ( ) : if isinstance ( v , dict ) : v = dictapply ( v , fn ) else : d [ k ] = fn ( v ) return d", "docstring_tokens": "apply a function to all non - dict values in a dictionary", "label": 1}, {"idx": "cosqa-train-2191", "doc": "python detect change of slope", "code": "def click_estimate_slope():\n    \"\"\"\n    Takes two clicks and returns the slope.\n\n    Right-click aborts.\n    \"\"\"\n\n    c1 = _pylab.ginput()\n    if len(c1)==0:\n        return None\n\n    c2 = _pylab.ginput()\n    if len(c2)==0:\n        return None\n\n    return (c1[0][1]-c2[0][1])/(c1[0][0]-c2[0][0])", "code_tokens": "def click_estimate_slope ( ) : c1 = _pylab . ginput ( ) if len ( c1 ) == 0 : return None c2 = _pylab . ginput ( ) if len ( c2 ) == 0 : return None return ( c1 [ 0 ] [ 1 ] - c2 [ 0 ] [ 1 ] ) / ( c1 [ 0 ] [ 0 ] - c2 [ 0 ] [ 0 ] )", "docstring_tokens": "Takes two clicks and returns the slope .", "label": 1}, {"idx": "cosqa-train-2192", "doc": "applying existing columns as index python", "code": "def _update_index_on_df(df, index_names):\n    \"\"\"Helper function to restore index information after collection. Doesn't\n    use self so we can serialize this.\"\"\"\n    if index_names:\n        df = df.set_index(index_names)\n        # Remove names from unnamed indexes\n        index_names = _denormalize_index_names(index_names)\n        df.index.names = index_names\n    return df", "code_tokens": "def _update_index_on_df ( df , index_names ) : if index_names : df = df . set_index ( index_names ) # Remove names from unnamed indexes index_names = _denormalize_index_names ( index_names ) df . index . names = index_names return df", "docstring_tokens": "Helper function to restore index information after collection . Doesn t use self so we can serialize this .", "label": 0}, {"idx": "cosqa-train-2193", "doc": "python detect if object has a method", "code": "def is_function(self):\n        \"\"\"return True if callback is a vanilla plain jane function\"\"\"\n        if self.is_instance() or self.is_class(): return False\n        return isinstance(self.callback, (Callable, classmethod))", "code_tokens": "def is_function ( self ) : if self . is_instance ( ) or self . is_class ( ) : return False return isinstance ( self . callback , ( Callable , classmethod ) )", "docstring_tokens": "return True if callback is a vanilla plain jane function", "label": 0}, {"idx": "cosqa-train-2194", "doc": "archer encoding text in python", "code": "def guess_encoding(text, default=DEFAULT_ENCODING):\n    \"\"\"Guess string encoding.\n\n    Given a piece of text, apply character encoding detection to\n    guess the appropriate encoding of the text.\n    \"\"\"\n    result = chardet.detect(text)\n    return normalize_result(result, default=default)", "code_tokens": "def guess_encoding ( text , default = DEFAULT_ENCODING ) : result = chardet . detect ( text ) return normalize_result ( result , default = default )", "docstring_tokens": "Guess string encoding .", "label": 0}, {"idx": "cosqa-train-2195", "doc": "python detect text encoding", "code": "def guess_encoding(text, default=DEFAULT_ENCODING):\n    \"\"\"Guess string encoding.\n\n    Given a piece of text, apply character encoding detection to\n    guess the appropriate encoding of the text.\n    \"\"\"\n    result = chardet.detect(text)\n    return normalize_result(result, default=default)", "code_tokens": "def guess_encoding ( text , default = DEFAULT_ENCODING ) : result = chardet . detect ( text ) return normalize_result ( result , default = default )", "docstring_tokens": "Guess string encoding .", "label": 1}, {"idx": "cosqa-train-2196", "doc": "asterisk notation in python 3 passing async functions", "code": "def build_and_start(query, directory):\n    \"\"\"This function will create and then start a new Async task with the\n    default callbacks argument defined in the decorator.\"\"\"\n\n    Async(target=grep, args=[query, directory]).start()", "code_tokens": "def build_and_start ( query , directory ) : Async ( target = grep , args = [ query , directory ] ) . start ( )", "docstring_tokens": "This function will create and then start a new Async task with the default callbacks argument defined in the decorator .", "label": 0}, {"idx": "cosqa-train-2197", "doc": "python determin the width of a character", "code": "def _string_width(self, s):\n        \"\"\"Get width of a string in the current font\"\"\"\n        s = str(s)\n        w = 0\n        for char in s:\n            char = ord(char)\n            w += self.character_widths[char]\n        return w * self.font_size / 1000.0", "code_tokens": "def _string_width ( self , s ) : s = str ( s ) w = 0 for char in s : char = ord ( char ) w += self . character_widths [ char ] return w * self . font_size / 1000.0", "docstring_tokens": "Get width of a string in the current font", "label": 0}, {"idx": "cosqa-train-2198", "doc": "average values for key in dictionary python", "code": "def _mean_dict(dict_list):\n    \"\"\"Compute the mean value across a list of dictionaries\n    \"\"\"\n    return {k: np.array([d[k] for d in dict_list]).mean()\n            for k in dict_list[0].keys()}", "code_tokens": "def _mean_dict ( dict_list ) : return { k : np . array ( [ d [ k ] for d in dict_list ] ) . mean ( ) for k in dict_list [ 0 ] . keys ( ) }", "docstring_tokens": "Compute the mean value across a list of dictionaries", "label": 1}, {"idx": "cosqa-train-2199", "doc": "python determine column types", "code": "def _get_column_types(self, data):\n        \"\"\"Get a list of the data types for each column in *data*.\"\"\"\n        columns = list(zip_longest(*data))\n        return [self._get_column_type(column) for column in columns]", "code_tokens": "def _get_column_types ( self , data ) : columns = list ( zip_longest ( * data ) ) return [ self . _get_column_type ( column ) for column in columns ]", "docstring_tokens": "Get a list of the data types for each column in * data * .", "label": 0}, {"idx": "cosqa-train-2200", "doc": "aws lambda python working with files", "code": "def lambda_from_file(python_file):\n    \"\"\"\n    Reads a python file and returns a awslambda.Code object\n    :param python_file:\n    :return:\n    \"\"\"\n    lambda_function = []\n    with open(python_file, 'r') as f:\n        lambda_function.extend(f.read().splitlines())\n\n    return awslambda.Code(ZipFile=(Join('\\n', lambda_function)))", "code_tokens": "def lambda_from_file ( python_file ) : lambda_function = [ ] with open ( python_file , 'r' ) as f : lambda_function . extend ( f . read ( ) . splitlines ( ) ) return awslambda . Code ( ZipFile = ( Join ( '\\n' , lambda_function ) ) )", "docstring_tokens": "Reads a python file and returns a awslambda . Code object : param python_file : : return :", "label": 0}, {"idx": "cosqa-train-2201", "doc": "python determine if key is in dict", "code": "def __contains__(self, key):\n        \"\"\"\n        Invoked when determining whether a specific key is in the dictionary\n        using `key in d`.\n\n        The key is looked up case-insensitively.\n        \"\"\"\n        k = self._real_key(key)\n        return k in self._data", "code_tokens": "def __contains__ ( self , key ) : k = self . _real_key ( key ) return k in self . _data", "docstring_tokens": "Invoked when determining whether a specific key is in the dictionary using key in d .", "label": 0}, {"idx": "cosqa-train-2202", "doc": "axis labels of subplot python", "code": "def show_xticklabels(self, row, column):\n        \"\"\"Show the x-axis tick labels for a subplot.\n\n        :param row,column: specify the subplot.\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.show_xticklabels()", "code_tokens": "def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "docstring_tokens": "Show the x - axis tick labels for a subplot .", "label": 0}, {"idx": "cosqa-train-2203", "doc": "bar plot with percentages python seaborn", "code": "def seaborn_bar_(self, label=None, style=None, opts=None):\n        \"\"\"\n        Get a Seaborn bar chart\n        \"\"\"\n        try:\n            fig = sns.barplot(self.x, self.y, palette=\"BuGn_d\")\n            return fig\n        except Exception as e:\n            self.err(e, self.seaborn_bar_,\n                     \"Can not get Seaborn bar chart object\")", "code_tokens": "def seaborn_bar_ ( self , label = None , style = None , opts = None ) : try : fig = sns . barplot ( self . x , self . y , palette = \"BuGn_d\" ) return fig except Exception as e : self . err ( e , self . seaborn_bar_ , \"Can not get Seaborn bar chart object\" )", "docstring_tokens": "Get a Seaborn bar chart", "label": 0}, {"idx": "cosqa-train-2204", "doc": "python dialog title aply font", "code": "def getFileDialogTitle(msg, title):\n    \"\"\"\n    Create nicely-formatted string based on arguments msg and title\n    :param msg: the msg to be displayed\n    :param title: the window title\n    :return: None\n    \"\"\"\n    if msg and title:\n        return \"%s - %s\" % (title, msg)\n    if msg and not title:\n        return str(msg)\n    if title and not msg:\n        return str(title)\n    return None", "code_tokens": "def getFileDialogTitle ( msg , title ) : if msg and title : return \"%s - %s\" % ( title , msg ) if msg and not title : return str ( msg ) if title and not msg : return str ( title ) return None", "docstring_tokens": "Create nicely - formatted string based on arguments msg and title : param msg : the msg to be displayed : param title : the window title : return : None", "label": 0}, {"idx": "cosqa-train-2205", "doc": "base64 encoding image python numpy", "code": "def img_encode(arr, **kwargs):\n    \"\"\"Encode ndarray to base64 string image data\n    \n    Parameters\n    ----------\n    arr: ndarray (rows, cols, depth)\n    kwargs: passed directly to matplotlib.image.imsave\n    \"\"\"\n    sio = BytesIO()\n    imsave(sio, arr, **kwargs)\n    sio.seek(0)\n    img_format = kwargs['format'] if kwargs.get('format') else 'png'\n    img_str = base64.b64encode(sio.getvalue()).decode()\n\n    return 'data:image/{};base64,{}'.format(img_format, img_str)", "code_tokens": "def img_encode ( arr , * * kwargs ) : sio = BytesIO ( ) imsave ( sio , arr , * * kwargs ) sio . seek ( 0 ) img_format = kwargs [ 'format' ] if kwargs . get ( 'format' ) else 'png' img_str = base64 . b64encode ( sio . getvalue ( ) ) . decode ( ) return 'data:image/{};base64,{}' . format ( img_format , img_str )", "docstring_tokens": "Encode ndarray to base64 string image data Parameters ---------- arr : ndarray ( rows cols depth ) kwargs : passed directly to matplotlib . image . imsave", "label": 1}, {"idx": "cosqa-train-2206", "doc": "python dict key must be string", "code": "def _check_conversion(key, valid_dict):\n    \"\"\"Check for existence of key in dict, return value or raise error\"\"\"\n    if key not in valid_dict and key not in valid_dict.values():\n        # Only show users the nice string values\n        keys = [v for v in valid_dict.keys() if isinstance(v, string_types)]\n        raise ValueError('value must be one of %s, not %s' % (keys, key))\n    return valid_dict[key] if key in valid_dict else key", "code_tokens": "def _check_conversion ( key , valid_dict ) : if key not in valid_dict and key not in valid_dict . values ( ) : # Only show users the nice string values keys = [ v for v in valid_dict . keys ( ) if isinstance ( v , string_types ) ] raise ValueError ( 'value must be one of %s, not %s' % ( keys , key ) ) return valid_dict [ key ] if key in valid_dict else key", "docstring_tokens": "Check for existence of key in dict return value or raise error", "label": 0}, {"idx": "cosqa-train-2207", "doc": "bold the line to print in python", "code": "def good(txt):\n    \"\"\"Print, emphasized 'good', the given 'txt' message\"\"\"\n\n    print(\"%s# %s%s%s\" % (PR_GOOD_CC, get_time_stamp(), txt, PR_NC))\n    sys.stdout.flush()", "code_tokens": "def good ( txt ) : print ( \"%s# %s%s%s\" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "docstring_tokens": "Print emphasized good the given txt message", "label": 1}, {"idx": "cosqa-train-2208", "doc": "python dict key, val only one item", "code": "def get_single_item(d):\n    \"\"\"Get an item from a dict which contains just one item.\"\"\"\n    assert len(d) == 1, 'Single-item dict must have just one item, not %d.' % len(d)\n    return next(six.iteritems(d))", "code_tokens": "def get_single_item ( d ) : assert len ( d ) == 1 , 'Single-item dict must have just one item, not %d.' % len ( d ) return next ( six . iteritems ( d ) )", "docstring_tokens": "Get an item from a dict which contains just one item .", "label": 0}, {"idx": "cosqa-train-2209", "doc": "boolean values of ints python", "code": "def is_int(value):\n    \"\"\"Return `True` if ``value`` is an integer.\"\"\"\n    if isinstance(value, bool):\n        return False\n    try:\n        int(value)\n        return True\n    except (ValueError, TypeError):\n        return False", "code_tokens": "def is_int ( value ) : if isinstance ( value , bool ) : return False try : int ( value ) return True except ( ValueError , TypeError ) : return False", "docstring_tokens": "Return True if value is an integer .", "label": 1}, {"idx": "cosqa-train-2210", "doc": "python dict merge with same key", "code": "def dictmerge(x, y):\n    \"\"\"\n    merge two dictionaries\n    \"\"\"\n    z = x.copy()\n    z.update(y)\n    return z", "code_tokens": "def dictmerge ( x , y ) : z = x . copy ( ) z . update ( y ) return z", "docstring_tokens": "merge two dictionaries", "label": 0}, {"idx": "cosqa-train-2211", "doc": "bounding box given points 3d python", "code": "def bounding_box_from(points, i, i1, thr):\n    \"\"\"Creates bounding box for a line segment\n\n    Args:\n        points (:obj:`list` of :obj:`Point`)\n        i (int): Line segment start, index in points array\n        i1 (int): Line segment end, index in points array\n    Returns:\n        (float, float, float, float): with bounding box min x, min y, max x and max y\n    \"\"\"\n    pi = points[i]\n    pi1 = points[i1]\n\n    min_lat = min(pi.lat, pi1.lat)\n    min_lon = min(pi.lon, pi1.lon)\n    max_lat = max(pi.lat, pi1.lat)\n    max_lon = max(pi.lon, pi1.lon)\n\n    return min_lat-thr, min_lon-thr, max_lat+thr, max_lon+thr", "code_tokens": "def bounding_box_from ( points , i , i1 , thr ) : pi = points [ i ] pi1 = points [ i1 ] min_lat = min ( pi . lat , pi1 . lat ) min_lon = min ( pi . lon , pi1 . lon ) max_lat = max ( pi . lat , pi1 . lat ) max_lon = max ( pi . lon , pi1 . lon ) return min_lat - thr , min_lon - thr , max_lat + thr , max_lon + thr", "docstring_tokens": "Creates bounding box for a line segment", "label": 0}, {"idx": "cosqa-train-2212", "doc": "python dict update one dict without changing other", "code": "def update(self, other_dict):\n        \"\"\"update() extends rather than replaces existing key lists.\"\"\"\n        for key, value in iter_multi_items(other_dict):\n            MultiDict.add(self, key, value)", "code_tokens": "def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )", "docstring_tokens": "update () extends rather than replaces existing key lists .", "label": 0}, {"idx": "cosqa-train-2213", "doc": "bounding box to capture an object inpython", "code": "def swap(self):\n        \"\"\"Return the box (for horizontal graphs)\"\"\"\n        self.xmin, self.ymin = self.ymin, self.xmin\n        self.xmax, self.ymax = self.ymax, self.xmax", "code_tokens": "def swap ( self ) : self . xmin , self . ymin = self . ymin , self . xmin self . xmax , self . ymax = self . ymax , self . xmax", "docstring_tokens": "Return the box ( for horizontal graphs )", "label": 0}, {"idx": "cosqa-train-2214", "doc": "python dictionary value iterator", "code": "def itervalues(d, **kw):\n    \"\"\"Return an iterator over the values of a dictionary.\"\"\"\n    if not PY2:\n        return iter(d.values(**kw))\n    return d.itervalues(**kw)", "code_tokens": "def itervalues ( d , * * kw ) : if not PY2 : return iter ( d . values ( * * kw ) ) return d . itervalues ( * * kw )", "docstring_tokens": "Return an iterator over the values of a dictionary .", "label": 0}, {"idx": "cosqa-train-2215", "doc": "bytearray default encoding python", "code": "def tob(data, enc='utf8'):\n    \"\"\" Convert anything to bytes \"\"\"\n    return data.encode(enc) if isinstance(data, six.text_type) else bytes(data)", "code_tokens": "def tob ( data , enc = 'utf8' ) : return data . encode ( enc ) if isinstance ( data , six . text_type ) else bytes ( data )", "docstring_tokens": "Convert anything to bytes", "label": 0}, {"idx": "cosqa-train-2216", "doc": "python dictonary remove null value", "code": "def purge_dict(idict):\n    \"\"\"Remove null items from a dictionary \"\"\"\n    odict = {}\n    for key, val in idict.items():\n        if is_null(val):\n            continue\n        odict[key] = val\n    return odict", "code_tokens": "def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict", "docstring_tokens": "Remove null items from a dictionary", "label": 0}, {"idx": "cosqa-train-2217", "doc": "c c++ remove comments python", "code": "def CleanseComments(line):\n  \"\"\"Removes //-comments and single-line C-style /* */ comments.\n\n  Args:\n    line: A line of C++ source.\n\n  Returns:\n    The line with single-line comments removed.\n  \"\"\"\n  commentpos = line.find('//')\n  if commentpos != -1 and not IsCppString(line[:commentpos]):\n    line = line[:commentpos].rstrip()\n  # get rid of /* ... */\n  return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS.sub('', line)", "code_tokens": "def CleanseComments ( line ) : commentpos = line . find ( '//' ) if commentpos != - 1 and not IsCppString ( line [ : commentpos ] ) : line = line [ : commentpos ] . rstrip ( ) # get rid of /* ... */ return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS . sub ( '' , line )", "docstring_tokens": "Removes // - comments and single - line C - style / * * / comments .", "label": 0}, {"idx": "cosqa-train-2218", "doc": "python disable history file", "code": "def set_history_file(self, path):\n        \"\"\"Set path to history file. \"\" produces no file.\"\"\"\n        if path:\n            self.history = prompt_toolkit.history.FileHistory(fixpath(path))\n        else:\n            self.history = prompt_toolkit.history.InMemoryHistory()", "code_tokens": "def set_history_file ( self , path ) : if path : self . history = prompt_toolkit . history . FileHistory ( fixpath ( path ) ) else : self . history = prompt_toolkit . history . InMemoryHistory ( )", "docstring_tokens": "Set path to history file . produces no file .", "label": 0}, {"idx": "cosqa-train-2219", "doc": "c++ map to python dictionary", "code": "def get_python_dict(scala_map):\n    \"\"\"Return a dict from entries in a scala.collection.immutable.Map\"\"\"\n    python_dict = {}\n    keys = get_python_list(scala_map.keys().toList())\n    for key in keys:\n        python_dict[key] = scala_map.apply(key)\n    return python_dict", "code_tokens": "def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict", "docstring_tokens": "Return a dict from entries in a scala . collection . immutable . Map", "label": 0}, {"idx": "cosqa-train-2220", "doc": "python distinct query django", "code": "def fast_distinct(self):\n        \"\"\"\n        Because standard distinct used on the all fields are very slow and works only with PostgreSQL database\n        this method provides alternative to the standard distinct method.\n        :return: qs with unique objects\n        \"\"\"\n        return self.model.objects.filter(pk__in=self.values_list('pk', flat=True))", "code_tokens": "def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )", "docstring_tokens": "Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects", "label": 0}, {"idx": "cosqa-train-2221", "doc": "caching to a file in python", "code": "def is_cached(file_name):\n\t\"\"\"\n\tCheck if a given file is available in the cache or not\n\t\"\"\"\n\n\tgml_file_path = join(join(expanduser('~'), OCTOGRID_DIRECTORY), file_name)\n\n\treturn isfile(gml_file_path)", "code_tokens": "def is_cached ( file_name ) : gml_file_path = join ( join ( expanduser ( '~' ) , OCTOGRID_DIRECTORY ) , file_name ) return isfile ( gml_file_path )", "docstring_tokens": "Check if a given file is available in the cache or not", "label": 1}, {"idx": "cosqa-train-2222", "doc": "python distinguish between float and int", "code": "def type_converter(text):\n    \"\"\" I convert strings into integers, floats, and strings! \"\"\"\n    if text.isdigit():\n        return int(text), int\n\n    try:\n        return float(text), float\n    except ValueError:\n        return text, STRING_TYPE", "code_tokens": "def type_converter ( text ) : if text . isdigit ( ) : return int ( text ) , int try : return float ( text ) , float except ValueError : return text , STRING_TYPE", "docstring_tokens": "I convert strings into integers floats and strings!", "label": 1}, {"idx": "cosqa-train-2223", "doc": "calculate byte size of array python", "code": "def array_bytes(array):\n    \"\"\" Estimates the memory of the supplied array in bytes \"\"\"\n    return np.product(array.shape)*np.dtype(array.dtype).itemsize", "code_tokens": "def array_bytes ( array ) : return np . product ( array . shape ) * np . dtype ( array . dtype ) . itemsize", "docstring_tokens": "Estimates the memory of the supplied array in bytes", "label": 0}, {"idx": "cosqa-train-2224", "doc": "calculate distance between two longitudes and altitudes python", "code": "def Distance(lat1, lon1, lat2, lon2):\n    \"\"\"Get distance between pairs of lat-lon points\"\"\"\n\n    az12, az21, dist = wgs84_geod.inv(lon1, lat1, lon2, lat2)\n    return az21, dist", "code_tokens": "def Distance ( lat1 , lon1 , lat2 , lon2 ) : az12 , az21 , dist = wgs84_geod . inv ( lon1 , lat1 , lon2 , lat2 ) return az21 , dist", "docstring_tokens": "Get distance between pairs of lat - lon points", "label": 1}, {"idx": "cosqa-train-2225", "doc": "python django checkbox true", "code": "def set_value(self, value):\n        \"\"\"Set value of the checkbox.\n\n        Parameters\n        ----------\n        value : bool\n            value for the checkbox\n\n        \"\"\"\n        if value:\n            self.setCheckState(Qt.Checked)\n        else:\n            self.setCheckState(Qt.Unchecked)", "code_tokens": "def set_value ( self , value ) : if value : self . setCheckState ( Qt . Checked ) else : self . setCheckState ( Qt . Unchecked )", "docstring_tokens": "Set value of the checkbox .", "label": 0}, {"idx": "cosqa-train-2226", "doc": "calculate the calum average of array python", "code": "def average(arr):\n  \"\"\"average of the values, must have more than 0 entries.\n\n  :param arr: list of numbers\n  :type arr: number[] a number array\n  :return: average\n  :rtype: float\n\n  \"\"\"\n  if len(arr) == 0:\n    sys.stderr.write(\"ERROR: no content in array to take average\\n\")\n    sys.exit()\n  if len(arr) == 1:  return arr[0]\n  return float(sum(arr))/float(len(arr))", "code_tokens": "def average ( arr ) : if len ( arr ) == 0 : sys . stderr . write ( \"ERROR: no content in array to take average\\n\" ) sys . exit ( ) if len ( arr ) == 1 : return arr [ 0 ] return float ( sum ( arr ) ) / float ( len ( arr ) )", "docstring_tokens": "average of the values must have more than 0 entries .", "label": 1}, {"idx": "cosqa-train-2227", "doc": "python django get request locale", "code": "def set_locale(request):\n    \"\"\"Return locale from GET lang param or automatically.\"\"\"\n    return request.query.get('lang', app.ps.babel.select_locale_by_request(request))", "code_tokens": "def set_locale ( request ) : return request . query . get ( 'lang' , app . ps . babel . select_locale_by_request ( request ) )", "docstring_tokens": "Return locale from GET lang param or automatically .", "label": 0}, {"idx": "cosqa-train-2228", "doc": "calculate time delta in python", "code": "def elapsed_time_from(start_time):\n    \"\"\"calculate time delta from latched time and current time\"\"\"\n    time_then = make_time(start_time)\n    time_now = datetime.utcnow().replace(microsecond=0)\n    if time_then is None:\n        return\n    delta_t = time_now - time_then\n    return delta_t", "code_tokens": "def elapsed_time_from ( start_time ) : time_then = make_time ( start_time ) time_now = datetime . utcnow ( ) . replace ( microsecond = 0 ) if time_then is None : return delta_t = time_now - time_then return delta_t", "docstring_tokens": "calculate time delta from latched time and current time", "label": 1}, {"idx": "cosqa-train-2229", "doc": "python django how to get largest id", "code": "def getMaxAffiliationInstanceID():\n    \"\"\"\n\n    Returns\n    -------\n    maximum value of the Primary key from the table \"django-tethne_affiliation_instance\"\n    This is used to calculate the next id for primary key.\n\n    if the table is empty, 0 is returned\n\n    \"\"\"\n    dbconnectionhanlder = DBConnection()\n    dbconnectionhanlder.cursor.execute(\"SELECT max(id) from `django-tethne_affiliation_instance`\")\n    rows = dbconnectionhanlder.cursor.fetchall()\n    dbconnectionhanlder.conn.close()\n    if rows[0][0] is None:\n        return 0\n    else:\n        return rows[0][0]", "code_tokens": "def getMaxAffiliationInstanceID ( ) : dbconnectionhanlder = DBConnection ( ) dbconnectionhanlder . cursor . execute ( \"SELECT max(id) from `django-tethne_affiliation_instance`\" ) rows = dbconnectionhanlder . cursor . fetchall ( ) dbconnectionhanlder . conn . close ( ) if rows [ 0 ] [ 0 ] is None : return 0 else : return rows [ 0 ] [ 0 ]", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-2230", "doc": "calculate variance of a column of a data frame in python", "code": "def var(series):\n    \"\"\"\n    Returns the variance of values in a series.\n\n    Args:\n        series (pandas.Series): column to summarize.\n    \"\"\"\n    if np.issubdtype(series.dtype, np.number):\n        return series.var()\n    else:\n        return np.nan", "code_tokens": "def var ( series ) : if np . issubdtype ( series . dtype , np . number ) : return series . var ( ) else : return np . nan", "docstring_tokens": "Returns the variance of values in a series .", "label": 0}, {"idx": "cosqa-train-2231", "doc": "python django many to many field", "code": "def handle_m2m_user(self, sender, instance, **kwargs):\n    \"\"\" Handle many to many relationships for user field \"\"\"\n    self.handle_save(instance.user.__class__, instance.user)", "code_tokens": "def handle_m2m_user ( self , sender , instance , * * kwargs ) : self . handle_save ( instance . user . __class__ , instance . user )", "docstring_tokens": "Handle many to many relationships for user field", "label": 0}, {"idx": "cosqa-train-2232", "doc": "calculating eigenvector centrality with eigenvector in python", "code": "def center_eigenvalue_diff(mat):\n    \"\"\"Compute the eigvals of mat and then find the center eigval difference.\"\"\"\n    N = len(mat)\n    evals = np.sort(la.eigvals(mat))\n    diff = np.abs(evals[N/2] - evals[N/2-1])\n    return diff", "code_tokens": "def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff", "docstring_tokens": "Compute the eigvals of mat and then find the center eigval difference .", "label": 1}, {"idx": "cosqa-train-2233", "doc": "python django model get largest primary key", "code": "def maxId(self):\n        \"\"\"int: current max id of objects\"\"\"\n        if len(self.model.db) == 0:\n            return 0\n\n        return max(map(lambda obj: obj[\"id\"], self.model.db))", "code_tokens": "def maxId ( self ) : if len ( self . model . db ) == 0 : return 0 return max ( map ( lambda obj : obj [ \"id\" ] , self . model . db ) )", "docstring_tokens": "int : current max id of objects", "label": 0}, {"idx": "cosqa-train-2234", "doc": "calculating standard deviation from a list using python", "code": "def lsem (inlist):\n    \"\"\"\nReturns the estimated standard error of the mean (sx-bar) of the\nvalues in the passed list.  sem = stdev / sqrt(n)\n\nUsage:   lsem(inlist)\n\"\"\"\n    sd = stdev(inlist)\n    n = len(inlist)\n    return sd/math.sqrt(n)", "code_tokens": "def lsem ( inlist ) : sd = stdev ( inlist ) n = len ( inlist ) return sd / math . sqrt ( n )", "docstring_tokens": "Returns the estimated standard error of the mean ( sx - bar ) of the values in the passed list . sem = stdev / sqrt ( n )", "label": 1}, {"idx": "cosqa-train-2235", "doc": "python django or flask for json", "code": "def json_response(data, status=200):\n    \"\"\"Return a JsonResponse. Make sure you have django installed first.\"\"\"\n    from django.http import JsonResponse\n    return JsonResponse(data=data, status=status, safe=isinstance(data, dict))", "code_tokens": "def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )", "docstring_tokens": "Return a JsonResponse . Make sure you have django installed first .", "label": 0}, {"idx": "cosqa-train-2236", "doc": "call a javascript function from python file", "code": "def import_js(path, lib_name, globals):\n    \"\"\"Imports from javascript source file.\n      globals is your globals()\"\"\"\n    with codecs.open(path_as_local(path), \"r\", \"utf-8\") as f:\n        js = f.read()\n    e = EvalJs()\n    e.execute(js)\n    var = e.context['var']\n    globals[lib_name] = var.to_python()", "code_tokens": "def import_js ( path , lib_name , globals ) : with codecs . open ( path_as_local ( path ) , \"r\" , \"utf-8\" ) as f : js = f . read ( ) e = EvalJs ( ) e . execute ( js ) var = e . context [ 'var' ] globals [ lib_name ] = var . to_python ( )", "docstring_tokens": "Imports from javascript source file . globals is your globals ()", "label": 0}, {"idx": "cosqa-train-2237", "doc": "python django response json stack", "code": "def json_response(data, status=200):\n    \"\"\"Return a JsonResponse. Make sure you have django installed first.\"\"\"\n    from django.http import JsonResponse\n    return JsonResponse(data=data, status=status, safe=isinstance(data, dict))", "code_tokens": "def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )", "docstring_tokens": "Return a JsonResponse . Make sure you have django installed first .", "label": 1}, {"idx": "cosqa-train-2238", "doc": "call python code from url", "code": "def parse_code(url):\n    \"\"\"\n    Parse the code parameter from the a URL\n\n    :param str url: URL to parse\n    :return: code query parameter\n    :rtype: str\n    \"\"\"\n    result = urlparse(url)\n    query = parse_qs(result.query)\n    return query['code']", "code_tokens": "def parse_code ( url ) : result = urlparse ( url ) query = parse_qs ( result . query ) return query [ 'code' ]", "docstring_tokens": "Parse the code parameter from the a URL", "label": 0}, {"idx": "cosqa-train-2239", "doc": "python django timezone map to new timezone", "code": "def make_aware(dt):\n    \"\"\"Appends tzinfo and assumes UTC, if datetime object has no tzinfo already.\"\"\"\n    return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)", "code_tokens": "def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "docstring_tokens": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already .", "label": 0}, {"idx": "cosqa-train-2240", "doc": "calling a definded function in python", "code": "def __call__(self, args):\n        \"\"\"Execute the user function.\"\"\"\n        window, ij = args\n        return self.user_func(srcs, window, ij, global_args), window", "code_tokens": "def __call__ ( self , args ) : window , ij = args return self . user_func ( srcs , window , ij , global_args ) , window", "docstring_tokens": "Execute the user function .", "label": 0}, {"idx": "cosqa-train-2241", "doc": "python do you have to close a pool", "code": "def release(self):\n        \"\"\"\n        Releases this resource back to the pool it came from.\n        \"\"\"\n        if self.errored:\n            self.pool.delete_resource(self)\n        else:\n            self.pool.release(self)", "code_tokens": "def release ( self ) : if self . errored : self . pool . delete_resource ( self ) else : self . pool . release ( self )", "docstring_tokens": "Releases this resource back to the pool it came from .", "label": 0}, {"idx": "cosqa-train-2242", "doc": "can i check to see if two strings match python", "code": "def _rm_name_match(s1, s2):\n  \"\"\"\n  determine whether two sequence names from a repeatmasker alignment match.\n\n  :return: True if they are the same string, or if one forms a substring of the\n           other, else False\n  \"\"\"\n  m_len = min(len(s1), len(s2))\n  return s1[:m_len] == s2[:m_len]", "code_tokens": "def _rm_name_match ( s1 , s2 ) : m_len = min ( len ( s1 ) , len ( s2 ) ) return s1 [ : m_len ] == s2 [ : m_len ]", "docstring_tokens": "determine whether two sequence names from a repeatmasker alignment match .", "label": 0}, {"idx": "cosqa-train-2243", "doc": "python docker api build output stream", "code": "def pull_stream(image):\n    \"\"\"\n    Return generator of pull status objects\n    \"\"\"\n    return (json.loads(s) for s in _get_docker().pull(image, stream=True))", "code_tokens": "def pull_stream ( image ) : return ( json . loads ( s ) for s in _get_docker ( ) . pull ( image , stream = True ) )", "docstring_tokens": "Return generator of pull status objects", "label": 0}, {"idx": "cosqa-train-2244", "doc": "can i delete unused objects in python", "code": "def _removeTags(tags, objects):\n    \"\"\" Removes tags from objects \"\"\"\n    for t in tags:\n        for o in objects:\n            o.tags.remove(t)\n\n    return True", "code_tokens": "def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True", "docstring_tokens": "Removes tags from objects", "label": 0}, {"idx": "cosqa-train-2245", "doc": "python docstring how to make", "code": "def _composed_doc(fs):\n    \"\"\"\n    Generate a docstring for the composition of fs.\n    \"\"\"\n    if not fs:\n        # Argument name for the docstring.\n        return 'n'\n\n    return '{f}({g})'.format(f=fs[0].__name__, g=_composed_doc(fs[1:]))", "code_tokens": "def _composed_doc ( fs ) : if not fs : # Argument name for the docstring. return 'n' return '{f}({g})' . format ( f = fs [ 0 ] . __name__ , g = _composed_doc ( fs [ 1 : ] ) )", "docstring_tokens": "Generate a docstring for the composition of fs .", "label": 1}, {"idx": "cosqa-train-2246", "doc": "can i initialize a python datetime to none", "code": "def date_to_datetime(x):\n    \"\"\"Convert a date into a datetime\"\"\"\n    if not isinstance(x, datetime) and isinstance(x, date):\n        return datetime.combine(x, time())\n    return x", "code_tokens": "def date_to_datetime ( x ) : if not isinstance ( x , datetime ) and isinstance ( x , date ) : return datetime . combine ( x , time ( ) ) return x", "docstring_tokens": "Convert a date into a datetime", "label": 0}, {"idx": "cosqa-train-2247", "doc": "python does slicing return a new list", "code": "def Slice(a, begin, size):\n    \"\"\"\n    Slicing op.\n    \"\"\"\n    return np.copy(a)[[slice(*tpl) for tpl in zip(begin, begin+size)]],", "code_tokens": "def Slice ( a , begin , size ) : return np . copy ( a ) [ [ slice ( * tpl ) for tpl in zip ( begin , begin + size ) ] ] ,", "docstring_tokens": "Slicing op .", "label": 0}, {"idx": "cosqa-train-2248", "doc": "can i pickle and unpickle an object in the same python file", "code": "def unpickle_file(picklefile, **kwargs):\n    \"\"\"Helper function to unpickle data from `picklefile`.\"\"\"\n    with open(picklefile, 'rb') as f:\n        return pickle.load(f, **kwargs)", "code_tokens": "def unpickle_file ( picklefile , * * kwargs ) : with open ( picklefile , 'rb' ) as f : return pickle . load ( f , * * kwargs )", "docstring_tokens": "Helper function to unpickle data from picklefile .", "label": 0}, {"idx": "cosqa-train-2249", "doc": "python dot product of a vector", "code": "def dot(self, w):\n        \"\"\"Return the dotproduct between self and another vector.\"\"\"\n\n        return sum([x * y for x, y in zip(self, w)])", "code_tokens": "def dot ( self , w ) : return sum ( [ x * y for x , y in zip ( self , w ) ] )", "docstring_tokens": "Return the dotproduct between self and another vector .", "label": 0}, {"idx": "cosqa-train-2250", "doc": "can you patch within a method python", "code": "def unpatch(obj, name):\n    \"\"\"\n    Undo the effects of patch(func, obj, name)\n    \"\"\"\n    setattr(obj, name, getattr(obj, name).original)", "code_tokens": "def unpatch ( obj , name ) : setattr ( obj , name , getattr ( obj , name ) . original )", "docstring_tokens": "Undo the effects of patch ( func obj name )", "label": 0}, {"idx": "cosqa-train-2251", "doc": "python draw a graph and save", "code": "def draw(graph, fname):\n    \"\"\"Draw a graph and save it into a file\"\"\"\n    ag = networkx.nx_agraph.to_agraph(graph)\n    ag.draw(fname, prog='dot')", "code_tokens": "def draw ( graph , fname ) : ag = networkx . nx_agraph . to_agraph ( graph ) ag . draw ( fname , prog = 'dot' )", "docstring_tokens": "Draw a graph and save it into a file", "label": 0}, {"idx": "cosqa-train-2252", "doc": "can you use enumerate to iterate python", "code": "def items(iterable):\n    \"\"\"\n    Iterates over the items of a sequence. If the sequence supports the\n      dictionary protocol (iteritems/items) then we use that. Otherwise\n      we use the enumerate built-in function.\n    \"\"\"\n    if hasattr(iterable, 'iteritems'):\n        return (p for p in iterable.iteritems())\n    elif hasattr(iterable, 'items'):\n        return (p for p in iterable.items())\n    else:\n        return (p for p in enumerate(iterable))", "code_tokens": "def items ( iterable ) : if hasattr ( iterable , 'iteritems' ) : return ( p for p in iterable . iteritems ( ) ) elif hasattr ( iterable , 'items' ) : return ( p for p in iterable . items ( ) ) else : return ( p for p in enumerate ( iterable ) )", "docstring_tokens": "Iterates over the items of a sequence . If the sequence supports the dictionary protocol ( iteritems / items ) then we use that . Otherwise we use the enumerate built - in function .", "label": 0}, {"idx": "cosqa-train-2253", "doc": "python dropdown cant select after change", "code": "def onchange(self, value):\n        \"\"\"Called when a new DropDownItem gets selected.\n        \"\"\"\n        log.debug('combo box. selected %s' % value)\n        self.select_by_value(value)\n        return (value, )", "code_tokens": "def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )", "docstring_tokens": "Called when a new DropDownItem gets selected .", "label": 1}, {"idx": "cosqa-train-2254", "doc": "capitalize entire string function python", "code": "def to_identifier(s):\n  \"\"\"\n  Convert snake_case to camel_case.\n  \"\"\"\n  if s.startswith('GPS'):\n      s = 'Gps' + s[3:]\n  return ''.join([i.capitalize() for i in s.split('_')]) if '_' in s else s", "code_tokens": "def to_identifier ( s ) : if s . startswith ( 'GPS' ) : s = 'Gps' + s [ 3 : ] return '' . join ( [ i . capitalize ( ) for i in s . split ( '_' ) ] ) if '_' in s else s", "docstring_tokens": "Convert snake_case to camel_case .", "label": 0}, {"idx": "cosqa-train-2255", "doc": "python dump json object", "code": "def to_json(obj):\n    \"\"\"Return a json string representing the python object obj.\"\"\"\n    i = StringIO.StringIO()\n    w = Writer(i, encoding='UTF-8')\n    w.write_value(obj)\n    return i.getvalue()", "code_tokens": "def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )", "docstring_tokens": "Return a json string representing the python object obj .", "label": 0}, {"idx": "cosqa-train-2256", "doc": "capitalize every two letter python", "code": "def decamelise(text):\n    \"\"\"Convert CamelCase to lower_and_underscore.\"\"\"\n    s = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s).lower()", "code_tokens": "def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s ) . lower ( )", "docstring_tokens": "Convert CamelCase to lower_and_underscore .", "label": 0}, {"idx": "cosqa-train-2257", "doc": "python dump pretty json indent", "code": "def pretty_dict_str(d, indent=2):\n    \"\"\"shows JSON indented representation of d\"\"\"\n    b = StringIO()\n    write_pretty_dict_str(b, d, indent=indent)\n    return b.getvalue()", "code_tokens": "def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )", "docstring_tokens": "shows JSON indented representation of d", "label": 0}, {"idx": "cosqa-train-2258", "doc": "capitalize letters in a string python", "code": "def camel_case_from_underscores(string):\n    \"\"\"generate a CamelCase string from an underscore_string.\"\"\"\n    components = string.split('_')\n    string = ''\n    for component in components:\n        string += component[0].upper() + component[1:]\n    return string", "code_tokens": "def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "docstring_tokens": "generate a CamelCase string from an underscore_string .", "label": 0}, {"idx": "cosqa-train-2259", "doc": "python dynamic create object from dict", "code": "def _from_dict(cls, _dict):\n        \"\"\"Initialize a KeyValuePair object from a json dictionary.\"\"\"\n        args = {}\n        if 'key' in _dict:\n            args['key'] = Key._from_dict(_dict.get('key'))\n        if 'value' in _dict:\n            args['value'] = Value._from_dict(_dict.get('value'))\n        return cls(**args)", "code_tokens": "def _from_dict ( cls , _dict ) : args = { } if 'key' in _dict : args [ 'key' ] = Key . _from_dict ( _dict . get ( 'key' ) ) if 'value' in _dict : args [ 'value' ] = Value . _from_dict ( _dict . get ( 'value' ) ) return cls ( * * args )", "docstring_tokens": "Initialize a KeyValuePair object from a json dictionary .", "label": 0}, {"idx": "cosqa-train-2260", "doc": "cdf function generation python", "code": "def _cdf(self, xloc, dist, base, cache):\n        \"\"\"Cumulative distribution function.\"\"\"\n        return evaluation.evaluate_forward(dist, base**xloc, cache=cache)", "code_tokens": "def _cdf ( self , xloc , dist , base , cache ) : return evaluation . evaluate_forward ( dist , base ** xloc , cache = cache )", "docstring_tokens": "Cumulative distribution function .", "label": 1}, {"idx": "cosqa-train-2261", "doc": "python dynamic multiple processes", "code": "def parallel(processes, threads):\n    \"\"\"\n    execute jobs in processes using N threads\n    \"\"\"\n    pool = multithread(threads)\n    pool.map(run_process, processes)\n    pool.close()\n    pool.join()", "code_tokens": "def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )", "docstring_tokens": "execute jobs in processes using N threads", "label": 0}, {"idx": "cosqa-train-2262", "doc": "change a date from month end to month begin in python", "code": "def start_of_month(val):\n    \"\"\"\n    Return a new datetime.datetime object with values that represent\n    a start of a month.\n    :param val: Date to ...\n    :type val: datetime.datetime | datetime.date\n    :rtype: datetime.datetime\n    \"\"\"\n    if type(val) == date:\n        val = datetime.fromordinal(val.toordinal())\n    return start_of_day(val).replace(day=1)", "code_tokens": "def start_of_month ( val ) : if type ( val ) == date : val = datetime . fromordinal ( val . toordinal ( ) ) return start_of_day ( val ) . replace ( day = 1 )", "docstring_tokens": "Return a new datetime . datetime object with values that represent a start of a month . : param val : Date to ... : type val : datetime . datetime | datetime . date : rtype : datetime . datetime", "label": 1}, {"idx": "cosqa-train-2263", "doc": "python dynamicly allocate dict kye", "code": "def _kw(keywords):\n    \"\"\"Turn list of keywords into dictionary.\"\"\"\n    r = {}\n    for k, v in keywords:\n        r[k] = v\n    return r", "code_tokens": "def _kw ( keywords ) : r = { } for k , v in keywords : r [ k ] = v return r", "docstring_tokens": "Turn list of keywords into dictionary .", "label": 0}, {"idx": "cosqa-train-2264", "doc": "change all text to lower case in python", "code": "def to_snake_case(text):\n    \"\"\"Convert to snake case.\n\n    :param str text:\n    :rtype: str\n    :return:\n    \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def to_snake_case ( text ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert to snake case .", "label": 0}, {"idx": "cosqa-train-2265", "doc": "python elasticsearch bulk performance", "code": "def update_index(index):\n    \"\"\"Re-index every document in a named index.\"\"\"\n    logger.info(\"Updating search index: '%s'\", index)\n    client = get_client()\n    responses = []\n    for model in get_index_models(index):\n        logger.info(\"Updating search index model: '%s'\", model.search_doc_type)\n        objects = model.objects.get_search_queryset(index).iterator()\n        actions = bulk_actions(objects, index=index, action=\"index\")\n        response = helpers.bulk(client, actions, chunk_size=get_setting(\"chunk_size\"))\n        responses.append(response)\n    return responses", "code_tokens": "def update_index ( index ) : logger . info ( \"Updating search index: '%s'\" , index ) client = get_client ( ) responses = [ ] for model in get_index_models ( index ) : logger . info ( \"Updating search index model: '%s'\" , model . search_doc_type ) objects = model . objects . get_search_queryset ( index ) . iterator ( ) actions = bulk_actions ( objects , index = index , action = \"index\" ) response = helpers . bulk ( client , actions , chunk_size = get_setting ( \"chunk_size\" ) ) responses . append ( response ) return responses", "docstring_tokens": "Re - index every document in a named index .", "label": 0}, {"idx": "cosqa-train-2266", "doc": "change array to string python", "code": "def bitsToString(arr):\n  \"\"\"Returns a string representing a numpy array of 0's and 1's\"\"\"\n  s = array('c','.'*len(arr))\n  for i in xrange(len(arr)):\n    if arr[i] == 1:\n      s[i]='*'\n  return s", "code_tokens": "def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s", "docstring_tokens": "Returns a string representing a numpy array of 0 s and 1 s", "label": 0}, {"idx": "cosqa-train-2267", "doc": "python elasticsearch index mapping", "code": "def add_index_alias(es, index_name, alias_name):\n    \"\"\"Add index alias to index_name\"\"\"\n\n    es.indices.put_alias(index=index_name, name=terms_alias)", "code_tokens": "def add_index_alias ( es , index_name , alias_name ) : es . indices . put_alias ( index = index_name , name = terms_alias )", "docstring_tokens": "Add index alias to index_name", "label": 0}, {"idx": "cosqa-train-2268", "doc": "change data type python to boolean", "code": "def _check_and_convert_bools(self):\n        \"\"\"Replace boolean variables by the characters 'F'/'T'\n        \"\"\"\n        replacements = {\n            True: 'T',\n            False: 'F',\n        }\n\n        for key in self.bools:\n            if isinstance(self[key], bool):\n                self[key] = replacements[self[key]]", "code_tokens": "def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]", "docstring_tokens": "Replace boolean variables by the characters F / T", "label": 0}, {"idx": "cosqa-train-2269", "doc": "python elasticsearch new field", "code": "def index(obj, index=INDEX_NAME, doc_type=DOC_TYPE):\n    \"\"\"\n    Index the given document.\n\n    https://elasticsearch-py.readthedocs.io/en/master/api.html#elasticsearch.Elasticsearch.index\n    https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html\n    \"\"\"\n    doc = to_dict(obj)\n\n    if doc is None:\n        return\n\n    id = doc.pop('id')\n\n    return es_conn.index(index, doc_type, doc, id=id)", "code_tokens": "def index ( obj , index = INDEX_NAME , doc_type = DOC_TYPE ) : doc = to_dict ( obj ) if doc is None : return id = doc . pop ( 'id' ) return es_conn . index ( index , doc_type , doc , id = id )", "docstring_tokens": "Index the given document .", "label": 0}, {"idx": "cosqa-train-2270", "doc": "change list to tuple in python", "code": "def as_tuple(self, value):\n        \"\"\"Utility function which converts lists to tuples.\"\"\"\n        if isinstance(value, list):\n            value = tuple(value)\n        return value", "code_tokens": "def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value", "docstring_tokens": "Utility function which converts lists to tuples .", "label": 0}, {"idx": "cosqa-train-2271", "doc": "python elegant solution to removing spaces in column names", "code": "def format_header_cell(val):\n    \"\"\"\n    Formats given header column. This involves changing '_Px_' to '(', '_xP_' to ')' and\n    all other '_' to spaces.\n    \"\"\"\n    return re.sub('_', ' ', re.sub(r'(_Px_)', '(', re.sub(r'(_xP_)', ')', str(val) )))", "code_tokens": "def format_header_cell ( val ) : return re . sub ( '_' , ' ' , re . sub ( r'(_Px_)' , '(' , re . sub ( r'(_xP_)' , ')' , str ( val ) ) ) )", "docstring_tokens": "Formats given header column . This involves changing _Px_ to ( _xP_ to ) and all other _ to spaces .", "label": 0}, {"idx": "cosqa-train-2272", "doc": "change long date into month in python", "code": "def QA_util_datetime_to_strdate(dt):\n    \"\"\"\n    :param dt:  pythone datetime.datetime\n    :return:  1999-02-01 string type\n    \"\"\"\n    strdate = \"%04d-%02d-%02d\" % (dt.year, dt.month, dt.day)\n    return strdate", "code_tokens": "def QA_util_datetime_to_strdate ( dt ) : strdate = \"%04d-%02d-%02d\" % ( dt . year , dt . month , dt . day ) return strdate", "docstring_tokens": ": param dt : pythone datetime . datetime : return : 1999 - 02 - 01 string type", "label": 1}, {"idx": "cosqa-train-2273", "doc": "python elementtree iterparse clear", "code": "def iterparse(source, tag, clear=False, events=None):\n    \"\"\"\n    iterparse variant that supports 'tag' parameter (like lxml),\n    yields elements and clears nodes after parsing.\n    \"\"\"\n    for event, elem in ElementTree.iterparse(source, events=events):\n        if elem.tag == tag:\n            yield elem\n        if clear:\n            elem.clear()", "code_tokens": "def iterparse ( source , tag , clear = False , events = None ) : for event , elem in ElementTree . iterparse ( source , events = events ) : if elem . tag == tag : yield elem if clear : elem . clear ( )", "docstring_tokens": "iterparse variant that supports tag parameter ( like lxml ) yields elements and clears nodes after parsing .", "label": 0}, {"idx": "cosqa-train-2274", "doc": "change python 2 to3", "code": "def command_py2to3(args):\n    \"\"\"\n    Apply '2to3' tool (Python2 to Python3 conversion tool) to Python sources.\n    \"\"\"\n    from lib2to3.main import main\n    sys.exit(main(\"lib2to3.fixes\", args=args.sources))", "code_tokens": "def command_py2to3 ( args ) : from lib2to3 . main import main sys . exit ( main ( \"lib2to3.fixes\" , args = args . sources ) )", "docstring_tokens": "Apply 2to3 tool ( Python2 to Python3 conversion tool ) to Python sources .", "label": 0}, {"idx": "cosqa-train-2275", "doc": "python email format check", "code": "def is_rfc2822(instance: str):\n    \"\"\"Validates RFC2822 format\"\"\"\n    if not isinstance(instance, str):\n        return True\n    return email.utils.parsedate(instance) is not None", "code_tokens": "def is_rfc2822 ( instance : str ) : if not isinstance ( instance , str ) : return True return email . utils . parsedate ( instance ) is not None", "docstring_tokens": "Validates RFC2822 format", "label": 0}, {"idx": "cosqa-train-2276", "doc": "change string from ascii enode to deafult in python", "code": "def b(s):\n\t\"\"\" Encodes Unicode strings to byte strings, if necessary. \"\"\"\n\n\treturn s if isinstance(s, bytes) else s.encode(locale.getpreferredencoding())", "code_tokens": "def b ( s ) : return s if isinstance ( s , bytes ) else s . encode ( locale . getpreferredencoding ( ) )", "docstring_tokens": "Encodes Unicode strings to byte strings if necessary .", "label": 0}, {"idx": "cosqa-train-2277", "doc": "python ensure shape is ,1 and not ,", "code": "def _check_color_dim(val):\n    \"\"\"Ensure val is Nx(n_col), usually Nx3\"\"\"\n    val = np.atleast_2d(val)\n    if val.shape[1] not in (3, 4):\n        raise RuntimeError('Value must have second dimension of size 3 or 4')\n    return val, val.shape[1]", "code_tokens": "def _check_color_dim ( val ) : val = np . atleast_2d ( val ) if val . shape [ 1 ] not in ( 3 , 4 ) : raise RuntimeError ( 'Value must have second dimension of size 3 or 4' ) return val , val . shape [ 1 ]", "docstring_tokens": "Ensure val is Nx ( n_col ) usually Nx3", "label": 0}, {"idx": "cosqa-train-2278", "doc": "change sys args to string in python", "code": "def aug_sysargv(cmdstr):\n    \"\"\" DEBUG FUNC modify argv to look like you ran a command \"\"\"\n    import shlex\n    argv = shlex.split(cmdstr)\n    sys.argv.extend(argv)", "code_tokens": "def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )", "docstring_tokens": "DEBUG FUNC modify argv to look like you ran a command", "label": 0}, {"idx": "cosqa-train-2279", "doc": "python enum list all names", "code": "def items(self):\n    \"\"\"Return a list of the (name, value) pairs of the enum.\n\n    These are returned in the order they were defined in the .proto file.\n    \"\"\"\n    return [(value_descriptor.name, value_descriptor.number)\n            for value_descriptor in self._enum_type.values]", "code_tokens": "def items ( self ) : return [ ( value_descriptor . name , value_descriptor . number ) for value_descriptor in self . _enum_type . values ]", "docstring_tokens": "Return a list of the ( name value ) pairs of the enum .", "label": 1}, {"idx": "cosqa-train-2280", "doc": "change variable prompt in python", "code": "def getpass(self, prompt, default=None):\n        \"\"\"Provide a password prompt.\"\"\"\n        return click.prompt(prompt, hide_input=True, default=default)", "code_tokens": "def getpass ( self , prompt , default = None ) : return click . prompt ( prompt , hide_input = True , default = default )", "docstring_tokens": "Provide a password prompt .", "label": 0}, {"idx": "cosqa-train-2281", "doc": "python enum or global variables", "code": "def unpack_out(self, name):\n        return self.parse(\"\"\"\n            $enum = $enum_class($value.value)\n            \"\"\", enum_class=self._import_type(), value=name)[\"enum\"]", "code_tokens": "def unpack_out ( self , name ) : return self . parse ( \"\"\"\n            $enum = $enum_class($value.value)\n            \"\"\" , enum_class = self . _import_type ( ) , value = name ) [ \"enum\" ]", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-2282", "doc": "changing background widget color python", "code": "def _set_widget_background_color(widget, color):\n        \"\"\"\n        Changes the base color of a widget (background).\n        :param widget: widget to modify\n        :param color: the color to apply\n        \"\"\"\n        pal = widget.palette()\n        pal.setColor(pal.Base, color)\n        widget.setPalette(pal)", "code_tokens": "def _set_widget_background_color ( widget , color ) : pal = widget . palette ( ) pal . setColor ( pal . Base , color ) widget . setPalette ( pal )", "docstring_tokens": "Changes the base color of a widget ( background ) . : param widget : widget to modify : param color : the color to apply", "label": 1}, {"idx": "cosqa-train-2283", "doc": "python equvalent of matlab index", "code": "def get_mi_vec(slab):\n    \"\"\"\n    Convenience function which returns the unit vector aligned\n    with the miller index.\n    \"\"\"\n    mvec = np.cross(slab.lattice.matrix[0], slab.lattice.matrix[1])\n    return mvec / np.linalg.norm(mvec)", "code_tokens": "def get_mi_vec ( slab ) : mvec = np . cross ( slab . lattice . matrix [ 0 ] , slab . lattice . matrix [ 1 ] ) return mvec / np . linalg . norm ( mvec )", "docstring_tokens": "Convenience function which returns the unit vector aligned with the miller index .", "label": 0}, {"idx": "cosqa-train-2284", "doc": "changing values to complex python", "code": "def c2f(r, i, ctype_name):\n    \"\"\"\n    Convert strings to complex number instance with specified numpy type.\n    \"\"\"\n\n    ftype = c2f_dict[ctype_name]\n    return np.typeDict[ctype_name](ftype(r) + 1j * ftype(i))", "code_tokens": "def c2f ( r , i , ctype_name ) : ftype = c2f_dict [ ctype_name ] return np . typeDict [ ctype_name ] ( ftype ( r ) + 1j * ftype ( i ) )", "docstring_tokens": "Convert strings to complex number instance with specified numpy type .", "label": 0}, {"idx": "cosqa-train-2285", "doc": "python erase previous line", "code": "def erase_lines(n=1):\n    \"\"\" Erases n lines from the screen and moves the cursor up to follow\n    \"\"\"\n    for _ in range(n):\n        print(codes.cursor[\"up\"], end=\"\")\n        print(codes.cursor[\"eol\"], end=\"\")", "code_tokens": "def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ \"up\" ] , end = \"\" ) print ( codes . cursor [ \"eol\" ] , end = \"\" )", "docstring_tokens": "Erases n lines from the screen and moves the cursor up to follow", "label": 1}, {"idx": "cosqa-train-2286", "doc": "check a file in a folder location in python code", "code": "def contained_in(filename, directory):\n    \"\"\"Test if a file is located within the given directory.\"\"\"\n    filename = os.path.normcase(os.path.abspath(filename))\n    directory = os.path.normcase(os.path.abspath(directory))\n    return os.path.commonprefix([filename, directory]) == directory", "code_tokens": "def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory", "docstring_tokens": "Test if a file is located within the given directory .", "label": 0}, {"idx": "cosqa-train-2287", "doc": "python eval globals locals", "code": "def exec_function(ast, globals_map):\n    \"\"\"Execute a python code object in the given environment.\n\n    Args:\n      globals_map: Dictionary to use as the globals context.\n    Returns:\n      locals_map: Dictionary of locals from the environment after execution.\n    \"\"\"\n    locals_map = globals_map\n    exec ast in globals_map, locals_map\n    return locals_map", "code_tokens": "def exec_function ( ast , globals_map ) : locals_map = globals_map exec ast in globals_map , locals_map return locals_map", "docstring_tokens": "Execute a python code object in the given environment .", "label": 0}, {"idx": "cosqa-train-2288", "doc": "check for attribute python object", "code": "def is_collection(obj):\n    \"\"\"Tests if an object is a collection.\"\"\"\n\n    col = getattr(obj, '__getitem__', False)\n    val = False if (not col) else True\n\n    if isinstance(obj, basestring):\n        val = False\n\n    return val", "code_tokens": "def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val", "docstring_tokens": "Tests if an object is a collection .", "label": 0}, {"idx": "cosqa-train-2289", "doc": "python exc log trace", "code": "def log_exception(exc_info=None, stream=None):\n    \"\"\"Log the 'exc_info' tuple in the server log.\"\"\"\n    exc_info = exc_info or sys.exc_info()\n    stream = stream or sys.stderr\n    try:\n        from traceback import print_exception\n        print_exception(exc_info[0], exc_info[1], exc_info[2], None, stream)\n        stream.flush()\n    finally:\n        exc_info = None", "code_tokens": "def log_exception ( exc_info = None , stream = None ) : exc_info = exc_info or sys . exc_info ( ) stream = stream or sys . stderr try : from traceback import print_exception print_exception ( exc_info [ 0 ] , exc_info [ 1 ] , exc_info [ 2 ] , None , stream ) stream . flush ( ) finally : exc_info = None", "docstring_tokens": "Log the exc_info tuple in the server log .", "label": 1}, {"idx": "cosqa-train-2290", "doc": "check given regex is valid python regex", "code": "def is_valid_regex(string):\n    \"\"\"\n    Checks whether the re module can compile the given regular expression.\n\n    Parameters\n    ----------\n    string: str\n\n    Returns\n    -------\n    boolean\n    \"\"\"\n    try:\n        re.compile(string)\n        is_valid = True\n    except re.error:\n        is_valid = False\n    return is_valid", "code_tokens": "def is_valid_regex ( string ) : try : re . compile ( string ) is_valid = True except re . error : is_valid = False return is_valid", "docstring_tokens": "Checks whether the re module can compile the given regular expression .", "label": 0}, {"idx": "cosqa-train-2291", "doc": "python excel workbook open giving none type", "code": "def __init__(self, filename, formatting_info=False, handle_ambiguous_date=None):\n    \"\"\"Initialize the ExcelWorkbook instance.\"\"\"\n    super().__init__(filename)\n    self.workbook = xlrd.open_workbook(self.filename, formatting_info=formatting_info)\n    self.handle_ambiguous_date = handle_ambiguous_date", "code_tokens": "def __init__ ( self , filename , formatting_info = False , handle_ambiguous_date = None ) : super ( ) . __init__ ( filename ) self . workbook = xlrd . open_workbook ( self . filename , formatting_info = formatting_info ) self . handle_ambiguous_date = handle_ambiguous_date", "docstring_tokens": "Initialize the ExcelWorkbook instance .", "label": 0}, {"idx": "cosqa-train-2292", "doc": "check if 2 arrays are equal python", "code": "def numpy_aware_eq(a, b):\n    \"\"\"Return whether two objects are equal via recursion, using\n    :func:`numpy.array_equal` for comparing numpy arays.\n    \"\"\"\n    if isinstance(a, np.ndarray) or isinstance(b, np.ndarray):\n        return np.array_equal(a, b)\n    if ((isinstance(a, Iterable) and isinstance(b, Iterable)) and\n            not isinstance(a, str) and not isinstance(b, str)):\n        if len(a) != len(b):\n            return False\n        return all(numpy_aware_eq(x, y) for x, y in zip(a, b))\n    return a == b", "code_tokens": "def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b", "docstring_tokens": "Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays .", "label": 0}, {"idx": "cosqa-train-2293", "doc": "python except flask http 400", "code": "def handle_exception(error):\n        \"\"\"Simple method for handling exceptions raised by `PyBankID`.\n\n        :param flask_pybankid.FlaskPyBankIDError error: The exception to handle.\n        :return: The exception represented as a dictionary.\n        :rtype: dict\n\n        \"\"\"\n        response = jsonify(error.to_dict())\n        response.status_code = error.status_code\n        return response", "code_tokens": "def handle_exception ( error ) : response = jsonify ( error . to_dict ( ) ) response . status_code = error . status_code return response", "docstring_tokens": "Simple method for handling exceptions raised by PyBankID .", "label": 0}, {"idx": "cosqa-train-2294", "doc": "check if a file is present in a folder using python", "code": "def contained_in(filename, directory):\n    \"\"\"Test if a file is located within the given directory.\"\"\"\n    filename = os.path.normcase(os.path.abspath(filename))\n    directory = os.path.normcase(os.path.abspath(directory))\n    return os.path.commonprefix([filename, directory]) == directory", "code_tokens": "def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory", "docstring_tokens": "Test if a file is located within the given directory .", "label": 0}, {"idx": "cosqa-train-2295", "doc": "python exec function timing", "code": "def timedcall(executable_function, *args):\n    \"\"\"!\n    @brief Executes specified method or function with measuring of execution time.\n    \n    @param[in] executable_function (pointer): Pointer to function or method.\n    @param[in] args (*): Arguments of called function or method.\n    \n    @return (tuple) Execution time and result of execution of function or method (execution_time, result_execution).\n    \n    \"\"\"\n    \n    time_start = time.clock();\n    result = executable_function(*args);\n    time_end = time.clock();\n    \n    return (time_end - time_start, result);", "code_tokens": "def timedcall ( executable_function , * args ) : time_start = time . clock ( ) result = executable_function ( * args ) time_end = time . clock ( ) return ( time_end - time_start , result )", "docstring_tokens": "!", "label": 1}, {"idx": "cosqa-train-2296", "doc": "check if a list contains multiple strings python 2", "code": "def has_multiline_items(maybe_list: Optional[Sequence[str]]):\n    \"\"\"Check whether one of the items in the list has multiple lines.\"\"\"\n    return maybe_list and any(is_multiline(item) for item in maybe_list)", "code_tokens": "def has_multiline_items ( maybe_list : Optional [ Sequence [ str ] ] ) : return maybe_list and any ( is_multiline ( item ) for item in maybe_list )", "docstring_tokens": "Check whether one of the items in the list has multiple lines .", "label": 0}, {"idx": "cosqa-train-2297", "doc": "python exec global scope", "code": "def exec_function(ast, globals_map):\n    \"\"\"Execute a python code object in the given environment.\n\n    Args:\n      globals_map: Dictionary to use as the globals context.\n    Returns:\n      locals_map: Dictionary of locals from the environment after execution.\n    \"\"\"\n    locals_map = globals_map\n    exec ast in globals_map, locals_map\n    return locals_map", "code_tokens": "def exec_function ( ast , globals_map ) : locals_map = globals_map exec ast in globals_map , locals_map return locals_map", "docstring_tokens": "Execute a python code object in the given environment .", "label": 0}, {"idx": "cosqa-train-2298", "doc": "check if a socket is connected python", "code": "def is_connected(self):\n        \"\"\"\n        Return true if the socket managed by this connection is connected\n\n        :rtype: bool\n        \"\"\"\n        try:\n            return self.socket is not None and self.socket.getsockname()[1] != 0 and BaseTransport.is_connected(self)\n        except socket.error:\n            return False", "code_tokens": "def is_connected ( self ) : try : return self . socket is not None and self . socket . getsockname ( ) [ 1 ] != 0 and BaseTransport . is_connected ( self ) except socket . error : return False", "docstring_tokens": "Return true if the socket managed by this connection is connected", "label": 0}, {"idx": "cosqa-train-2299", "doc": "python execute code before exit", "code": "def call_and_exit(self, cmd, shell=True):\n        \"\"\"Run the *cmd* and exit with the proper exit code.\"\"\"\n        sys.exit(subprocess.call(cmd, shell=shell))", "code_tokens": "def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )", "docstring_tokens": "Run the * cmd * and exit with the proper exit code .", "label": 0}, {"idx": "cosqa-train-2300", "doc": "check if an element exists python", "code": "def is_element_present(driver, selector, by=By.CSS_SELECTOR):\n    \"\"\"\n    Returns whether the specified element selector is present on the page.\n    @Params\n    driver - the webdriver object (required)\n    selector - the locator that is used (required)\n    by - the method to search for the locator (Default: By.CSS_SELECTOR)\n    @Returns\n    Boolean (is element present)\n    \"\"\"\n    try:\n        driver.find_element(by=by, value=selector)\n        return True\n    except Exception:\n        return False", "code_tokens": "def is_element_present ( driver , selector , by = By . CSS_SELECTOR ) : try : driver . find_element ( by = by , value = selector ) return True except Exception : return False", "docstring_tokens": "Returns whether the specified element selector is present on the page .", "label": 0}, {"idx": "cosqa-train-2301", "doc": "python execute query is not returning letthers as the columns names", "code": "def get_tablenames(cur):\n    \"\"\" Conveinience: \"\"\"\n    cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n    tablename_list_ = cur.fetchall()\n    tablename_list = [str(tablename[0]) for tablename in tablename_list_ ]\n    return tablename_list", "code_tokens": "def get_tablenames ( cur ) : cur . execute ( \"SELECT name FROM sqlite_master WHERE type='table'\" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list", "docstring_tokens": "Conveinience :", "label": 0}, {"idx": "cosqa-train-2302", "doc": "check if an item is in a tuple python", "code": "def is_list_of_list(item):\n    \"\"\"\n    check whether the item is list (tuple)\n    and consist of list (tuple) elements\n    \"\"\"\n    if (\n        type(item) in (list, tuple)\n        and len(item)\n        and isinstance(item[0], (list, tuple))\n    ):\n        return True\n    return False", "code_tokens": "def is_list_of_list ( item ) : if ( type ( item ) in ( list , tuple ) and len ( item ) and isinstance ( item [ 0 ] , ( list , tuple ) ) ) : return True return False", "docstring_tokens": "check whether the item is list ( tuple ) and consist of list ( tuple ) elements", "label": 0}, {"idx": "cosqa-train-2303", "doc": "python exit still running", "code": "def exit(exit_code=0):\n  r\"\"\"A function to support exiting from exit hooks.\n\n  Could also be used to exit from the calling scripts in a thread safe manner.\n  \"\"\"\n  core.processExitHooks()\n\n  if state.isExitHooked and not hasattr(sys, 'exitfunc'): # The function is called from the exit hook\n    sys.stderr.flush()\n    sys.stdout.flush()\n    os._exit(exit_code) #pylint: disable=W0212\n\n  sys.exit(exit_code)", "code_tokens": "def exit ( exit_code = 0 ) : core . processExitHooks ( ) if state . isExitHooked and not hasattr ( sys , 'exitfunc' ) : # The function is called from the exit hook sys . stderr . flush ( ) sys . stdout . flush ( ) os . _exit ( exit_code ) #pylint: disable=W0212 sys . exit ( exit_code )", "docstring_tokens": "r A function to support exiting from exit hooks .", "label": 0}, {"idx": "cosqa-train-2304", "doc": "check if any item in a list is null python", "code": "def is_nullable_list(val, vtype):\n    \"\"\"Return True if list contains either values of type `vtype` or None.\"\"\"\n    return (isinstance(val, list) and\n            any(isinstance(v, vtype) for v in val) and\n            all((isinstance(v, vtype) or v is None) for v in val))", "code_tokens": "def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )", "docstring_tokens": "Return True if list contains either values of type vtype or None .", "label": 0}, {"idx": "cosqa-train-2305", "doc": "python expanding variables inside strings", "code": "def _expand(self, str, local_vars={}):\n        \"\"\"Expand $vars in a string.\"\"\"\n        return ninja_syntax.expand(str, self.vars, local_vars)", "code_tokens": "def _expand ( self , str , local_vars = { } ) : return ninja_syntax . expand ( str , self . vars , local_vars )", "docstring_tokens": "Expand $vars in a string .", "label": 0}, {"idx": "cosqa-train-2306", "doc": "check if attribute key exists json python", "code": "def task_property_present_predicate(service, task, prop):\n    \"\"\" True if the json_element passed is present for the task specified.\n    \"\"\"\n    try:\n        response = get_service_task(service, task)\n    except Exception as e:\n        pass\n\n    return (response is not None) and (prop in response)", "code_tokens": "def task_property_present_predicate ( service , task , prop ) : try : response = get_service_task ( service , task ) except Exception as e : pass return ( response is not None ) and ( prop in response )", "docstring_tokens": "True if the json_element passed is present for the task specified .", "label": 0}, {"idx": "cosqa-train-2307", "doc": "python extend a dict with kwargs", "code": "def _merge_args_with_kwargs(args_dict, kwargs_dict):\n    \"\"\"Merge args with kwargs.\"\"\"\n    ret = args_dict.copy()\n    ret.update(kwargs_dict)\n    return ret", "code_tokens": "def _merge_args_with_kwargs ( args_dict , kwargs_dict ) : ret = args_dict . copy ( ) ret . update ( kwargs_dict ) return ret", "docstring_tokens": "Merge args with kwargs .", "label": 0}, {"idx": "cosqa-train-2308", "doc": "check if cpython isntalled mac os", "code": "def inside_softimage():\n    \"\"\"Returns a boolean indicating if the code is executed inside softimage.\"\"\"\n    try:\n        import maya\n        return False\n    except ImportError:\n        pass\n    try:\n        from win32com.client import Dispatch as disp\n        disp('XSI.Application')\n        return True\n    except:\n        return False", "code_tokens": "def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False", "docstring_tokens": "Returns a boolean indicating if the code is executed inside softimage .", "label": 0}, {"idx": "cosqa-train-2309", "doc": "python extract from list to set", "code": "def unique_everseen(seq):\n    \"\"\"Solution found here : http://stackoverflow.com/questions/480214/how-do-you-remove-duplicates-from-a-list-in-python-whilst-preserving-order\"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def unique_everseen ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "Solution found here : http : // stackoverflow . com / questions / 480214 / how - do - you - remove - duplicates - from - a - list - in - python - whilst - preserving - order", "label": 0}, {"idx": "cosqa-train-2310", "doc": "check if file is json file in python", "code": "def is_json_file(filename, show_warnings = False):\n    \"\"\"Check configuration file type is JSON\n    Return a boolean indicating wheather the file is JSON format or not\n    \"\"\"\n    try:\n        config_dict = load_config(filename, file_type = \"json\")\n        is_json = True\n    except:\n        is_json = False\n    return(is_json)", "code_tokens": "def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = \"json\" ) is_json = True except : is_json = False return ( is_json )", "docstring_tokens": "Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not", "label": 1}, {"idx": "cosqa-train-2311", "doc": "python extract only letters from string", "code": "def return_letters_from_string(text):\n    \"\"\"Get letters from string only.\"\"\"\n    out = \"\"\n    for letter in text:\n        if letter.isalpha():\n            out += letter\n    return out", "code_tokens": "def return_letters_from_string ( text ) : out = \"\" for letter in text : if letter . isalpha ( ) : out += letter return out", "docstring_tokens": "Get letters from string only .", "label": 0}, {"idx": "cosqa-train-2312", "doc": "check if folder is writable python", "code": "def _writable_dir(path):\n    \"\"\"Whether `path` is a directory, to which the user has write access.\"\"\"\n    return os.path.isdir(path) and os.access(path, os.W_OK)", "code_tokens": "def _writable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . W_OK )", "docstring_tokens": "Whether path is a directory to which the user has write access .", "label": 0}, {"idx": "cosqa-train-2313", "doc": "python extract url parametes", "code": "def get_url_args(url):\n    \"\"\" Returns a dictionary from a URL params \"\"\"\n    url_data = urllib.parse.urlparse(url)\n    arg_dict = urllib.parse.parse_qs(url_data.query)\n    return arg_dict", "code_tokens": "def get_url_args ( url ) : url_data = urllib . parse . urlparse ( url ) arg_dict = urllib . parse . parse_qs ( url_data . query ) return arg_dict", "docstring_tokens": "Returns a dictionary from a URL params", "label": 0}, {"idx": "cosqa-train-2314", "doc": "check if item is in series python", "code": "def test_for_image(self, cat, img):\n        \"\"\"Tests if image img in category cat exists\"\"\"\n        return self.test_for_category(cat) and img in self.items[cat]", "code_tokens": "def test_for_image ( self , cat , img ) : return self . test_for_category ( cat ) and img in self . items [ cat ]", "docstring_tokens": "Tests if image img in category cat exists", "label": 0}, {"idx": "cosqa-train-2315", "doc": "python extract zip to folder", "code": "def extract_all(zipfile, dest_folder):\n    \"\"\"\n    reads the zip file, determines compression\n    and unzips recursively until source files \n    are extracted \n    \"\"\"\n    z = ZipFile(zipfile)\n    print(z)\n    z.extract(dest_folder)", "code_tokens": "def extract_all ( zipfile , dest_folder ) : z = ZipFile ( zipfile ) print ( z ) z . extract ( dest_folder )", "docstring_tokens": "reads the zip file determines compression and unzips recursively until source files are extracted", "label": 0}, {"idx": "cosqa-train-2316", "doc": "check if something is a string python without using type", "code": "def is_string(obj):\n    \"\"\"Is this a string.\n\n    :param object obj:\n    :rtype: bool\n    \"\"\"\n    if PYTHON3:\n        str_type = (bytes, str)\n    else:\n        str_type = (bytes, str, unicode)\n    return isinstance(obj, str_type)", "code_tokens": "def is_string ( obj ) : if PYTHON3 : str_type = ( bytes , str ) else : str_type = ( bytes , str , unicode ) return isinstance ( obj , str_type )", "docstring_tokens": "Is this a string .", "label": 0}, {"idx": "cosqa-train-2317", "doc": "python f string literal float", "code": "def parse_float_literal(ast, _variables=None):\n    \"\"\"Parse a float value node in the AST.\"\"\"\n    if isinstance(ast, (FloatValueNode, IntValueNode)):\n        return float(ast.value)\n    return INVALID", "code_tokens": "def parse_float_literal ( ast , _variables = None ) : if isinstance ( ast , ( FloatValueNode , IntValueNode ) ) : return float ( ast . value ) return INVALID", "docstring_tokens": "Parse a float value node in the AST .", "label": 0}, {"idx": "cosqa-train-2318", "doc": "check if string ontains a value python", "code": "def is_int(string):\n    \"\"\"\n    Checks if a string is an integer. If the string value is an integer\n    return True, otherwise return False. \n    \n    Args:\n        string: a string to test.\n\n    Returns: \n        boolean\n    \"\"\"\n    try:\n        a = float(string)\n        b = int(a)\n    except ValueError:\n        return False\n    else:\n        return a == b", "code_tokens": "def is_int ( string ) : try : a = float ( string ) b = int ( a ) except ValueError : return False else : return a == b", "docstring_tokens": "Checks if a string is an integer . If the string value is an integer return True otherwise return False . Args : string : a string to test .", "label": 0}, {"idx": "cosqa-train-2319", "doc": "python fft faster than c fft", "code": "def stft(func=None, **kwparams):\n  \"\"\"\n  Short Time Fourier Transform for real data keeping the full FFT block.\n\n  Same to the default STFT strategy, but with new defaults. This is the same\n  to:\n\n  .. code-block:: python\n\n    stft.base(transform=numpy.fft.fft,\n              inverse_transform=lambda *args: numpy.fft.ifft(*args).real)\n\n  See ``stft.base`` docs for more.\n  \"\"\"\n  from numpy.fft import fft, ifft\n  ifft_r = lambda *args: ifft(*args).real\n  return stft.base(transform=fft, inverse_transform=ifft_r)(func, **kwparams)", "code_tokens": "def stft ( func = None , * * kwparams ) : from numpy . fft import fft , ifft ifft_r = lambda * args : ifft ( * args ) . real return stft . base ( transform = fft , inverse_transform = ifft_r ) ( func , * * kwparams )", "docstring_tokens": "Short Time Fourier Transform for real data keeping the full FFT block .", "label": 0}, {"idx": "cosqa-train-2320", "doc": "check if two arrays are equal or not python", "code": "def numpy_aware_eq(a, b):\n    \"\"\"Return whether two objects are equal via recursion, using\n    :func:`numpy.array_equal` for comparing numpy arays.\n    \"\"\"\n    if isinstance(a, np.ndarray) or isinstance(b, np.ndarray):\n        return np.array_equal(a, b)\n    if ((isinstance(a, Iterable) and isinstance(b, Iterable)) and\n            not isinstance(a, str) and not isinstance(b, str)):\n        if len(a) != len(b):\n            return False\n        return all(numpy_aware_eq(x, y) for x, y in zip(a, b))\n    return a == b", "code_tokens": "def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b", "docstring_tokens": "Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays .", "label": 0}, {"idx": "cosqa-train-2321", "doc": "python fft to give phase", "code": "def stft(func=None, **kwparams):\n  \"\"\"\n  Short Time Fourier Transform for real data keeping the full FFT block.\n\n  Same to the default STFT strategy, but with new defaults. This is the same\n  to:\n\n  .. code-block:: python\n\n    stft.base(transform=numpy.fft.fft,\n              inverse_transform=lambda *args: numpy.fft.ifft(*args).real)\n\n  See ``stft.base`` docs for more.\n  \"\"\"\n  from numpy.fft import fft, ifft\n  ifft_r = lambda *args: ifft(*args).real\n  return stft.base(transform=fft, inverse_transform=ifft_r)(func, **kwparams)", "code_tokens": "def stft ( func = None , * * kwparams ) : from numpy . fft import fft , ifft ifft_r = lambda * args : ifft ( * args ) . real return stft . base ( transform = fft , inverse_transform = ifft_r ) ( func , * * kwparams )", "docstring_tokens": "Short Time Fourier Transform for real data keeping the full FFT block .", "label": 0}, {"idx": "cosqa-train-2322", "doc": "check if uuid python", "code": "def valid_uuid(value):\n    \"\"\" Check if value is a valid UUID. \"\"\"\n\n    try:\n        uuid.UUID(value, version=4)\n        return True\n    except (TypeError, ValueError, AttributeError):\n        return False", "code_tokens": "def valid_uuid ( value ) : try : uuid . UUID ( value , version = 4 ) return True except ( TypeError , ValueError , AttributeError ) : return False", "docstring_tokens": "Check if value is a valid UUID .", "label": 0}, {"idx": "cosqa-train-2323", "doc": "python fftn pyfft plan", "code": "def stft_magnitude(signal, fft_length,\n                   hop_length=None,\n                   window_length=None):\n  \"\"\"Calculate the short-time Fourier transform magnitude.\n\n  Args:\n    signal: 1D np.array of the input time-domain signal.\n    fft_length: Size of the FFT to apply.\n    hop_length: Advance (in samples) between each frame passed to FFT.\n    window_length: Length of each block of samples to pass to FFT.\n\n  Returns:\n    2D np.array where each row contains the magnitudes of the fft_length/2+1\n    unique values of the FFT for the corresponding frame of input samples.\n  \"\"\"\n  frames = frame(signal, window_length, hop_length)\n  # Apply frame window to each frame. We use a periodic Hann (cosine of period\n  # window_length) instead of the symmetric Hann of np.hanning (period\n  # window_length-1).\n  window = periodic_hann(window_length)\n  windowed_frames = frames * window\n  return np.abs(np.fft.rfft(windowed_frames, int(fft_length)))", "code_tokens": "def stft_magnitude ( signal , fft_length , hop_length = None , window_length = None ) : frames = frame ( signal , window_length , hop_length ) # Apply frame window to each frame. We use a periodic Hann (cosine of period # window_length) instead of the symmetric Hann of np.hanning (period # window_length-1). window = periodic_hann ( window_length ) windowed_frames = frames * window return np . abs ( np . fft . rfft ( windowed_frames , int ( fft_length ) ) )", "docstring_tokens": "Calculate the short - time Fourier transform magnitude .", "label": 0}, {"idx": "cosqa-train-2324", "doc": "check if variable is in locals python", "code": "def getvariable(name):\n    \"\"\"Get the value of a local variable somewhere in the call stack.\"\"\"\n    import inspect\n    fr = inspect.currentframe()\n    try:\n        while fr:\n            fr = fr.f_back\n            vars = fr.f_locals\n            if name in vars:\n                return vars[name]\n    except:\n        pass\n    return None", "code_tokens": "def getvariable ( name ) : import inspect fr = inspect . currentframe ( ) try : while fr : fr = fr . f_back vars = fr . f_locals if name in vars : return vars [ name ] except : pass return None", "docstring_tokens": "Get the value of a local variable somewhere in the call stack .", "label": 0}, {"idx": "cosqa-train-2325", "doc": "python file modified date in milliseconds", "code": "def get_time(filename):\n\t\"\"\"\n\tGet the modified time for a file as a datetime instance\n\t\"\"\"\n\tts = os.stat(filename).st_mtime\n\treturn datetime.datetime.utcfromtimestamp(ts)", "code_tokens": "def get_time ( filename ) : ts = os . stat ( filename ) . st_mtime return datetime . datetime . utcfromtimestamp ( ts )", "docstring_tokens": "Get the modified time for a file as a datetime instance", "label": 0}, {"idx": "cosqa-train-2326", "doc": "check if variable is not passed into html python flask", "code": "def check_empty_dict(GET_dict):\n    \"\"\"\n    Returns True if the GET querstring contains on values, but it can contain\n    empty keys.\n    This is better than doing not bool(request.GET) as an empty key will return\n    True\n    \"\"\"\n    empty = True\n    for k, v in GET_dict.items():\n        # Don't disable on p(age) or 'all' GET param\n        if v and k != 'p' and k != 'all':\n            empty = False\n    return empty", "code_tokens": "def check_empty_dict ( GET_dict ) : empty = True for k , v in GET_dict . items ( ) : # Don't disable on p(age) or 'all' GET param if v and k != 'p' and k != 'all' : empty = False return empty", "docstring_tokens": "Returns True if the GET querstring contains on values but it can contain empty keys . This is better than doing not bool ( request . GET ) as an empty key will return True", "label": 0}, {"idx": "cosqa-train-2327", "doc": "python file open access modes", "code": "def open_file(file, mode):\n\t\"\"\"Open a file.\n\n\t:arg file: file-like or path-like object.\n\t:arg str mode: ``mode`` argument for :func:`open`.\n\t\"\"\"\n\tif hasattr(file, \"read\"):\n\t\treturn file\n\tif hasattr(file, \"open\"):\n\t\treturn file.open(mode)\n\treturn open(file, mode)", "code_tokens": "def open_file ( file , mode ) : if hasattr ( file , \"read\" ) : return file if hasattr ( file , \"open\" ) : return file . open ( mode ) return open ( file , mode )", "docstring_tokens": "Open a file .", "label": 0}, {"idx": "cosqa-train-2328", "doc": "check list dimension python", "code": "def _rectangular(n):\n    \"\"\"Checks to see if a 2D list is a valid 2D matrix\"\"\"\n    for i in n:\n        if len(i) != len(n[0]):\n            return False\n    return True", "code_tokens": "def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True", "docstring_tokens": "Checks to see if a 2D list is a valid 2D matrix", "label": 0}, {"idx": "cosqa-train-2329", "doc": "python file pointer reset to beginning", "code": "def rewindbody(self):\n        \"\"\"Rewind the file to the start of the body (if seekable).\"\"\"\n        if not self.seekable:\n            raise IOError, \"unseekable file\"\n        self.fp.seek(self.startofbody)", "code_tokens": "def rewindbody ( self ) : if not self . seekable : raise IOError , \"unseekable file\" self . fp . seek ( self . startofbody )", "docstring_tokens": "Rewind the file to the start of the body ( if seekable ) .", "label": 0}, {"idx": "cosqa-train-2330", "doc": "check matrix dimension in python", "code": "def _check_2d_shape(X):\n    \"\"\"Check shape of array or sparse matrix.\n\n    Assure that X is always 2D: Unlike numpy we always deal with 2D arrays.\n    \"\"\"\n    if X.dtype.names is None and len(X.shape) != 2:\n        raise ValueError('X needs to be 2-dimensional, not '\n                         '{}-dimensional.'.format(len(X.shape)))", "code_tokens": "def _check_2d_shape ( X ) : if X . dtype . names is None and len ( X . shape ) != 2 : raise ValueError ( 'X needs to be 2-dimensional, not ' '{}-dimensional.' . format ( len ( X . shape ) ) )", "docstring_tokens": "Check shape of array or sparse matrix .", "label": 0}, {"idx": "cosqa-train-2331", "doc": "python file stream length", "code": "def file_length(file_obj):\n    \"\"\"\n    Returns the length in bytes of a given file object.\n    Necessary because os.fstat only works on real files and not file-like\n    objects. This works on more types of streams, primarily StringIO.\n    \"\"\"\n    file_obj.seek(0, 2)\n    length = file_obj.tell()\n    file_obj.seek(0)\n    return length", "code_tokens": "def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length", "docstring_tokens": "Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO .", "label": 0}, {"idx": "cosqa-train-2332", "doc": "check my python env location", "code": "def _pip_exists(self):\n        \"\"\"Returns True if pip exists inside the virtual environment. Can be\n        used as a naive way to verify that the environment is installed.\"\"\"\n        return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))", "code_tokens": "def _pip_exists ( self ) : return os . path . isfile ( os . path . join ( self . path , 'bin' , 'pip' ) )", "docstring_tokens": "Returns True if pip exists inside the virtual environment . Can be used as a naive way to verify that the environment is installed .", "label": 0}, {"idx": "cosqa-train-2333", "doc": "python filepath from project folder", "code": "def read(filename):\n    \"\"\"Read and return `filename` in root dir of project and return string\"\"\"\n    return codecs.open(os.path.join(__DIR__, filename), 'r').read()", "code_tokens": "def read ( filename ) : return codecs . open ( os . path . join ( __DIR__ , filename ) , 'r' ) . read ( )", "docstring_tokens": "Read and return filename in root dir of project and return string", "label": 1}, {"idx": "cosqa-train-2334", "doc": "check set membership for attribute python", "code": "def instance_contains(container, item):\n    \"\"\"Search into instance attributes, properties and return values of no-args methods.\"\"\"\n    return item in (member for _, member in inspect.getmembers(container))", "code_tokens": "def instance_contains ( container , item ) : return item in ( member for _ , member in inspect . getmembers ( container ) )", "docstring_tokens": "Search into instance attributes properties and return values of no - args methods .", "label": 1}, {"idx": "cosqa-train-2335", "doc": "python fill column with null", "code": "def fill_nulls(self, col: str):\n        \"\"\"\n        Fill all null values with NaN values in a column.\n        Null values are ``None`` or en empty string\n\n        :param col: column name\n        :type col: str\n\n        :example: ``ds.fill_nulls(\"mycol\")``\n        \"\"\"\n        n = [None, \"\"]\n        try:\n            self.df[col] = self.df[col].replace(n, nan)\n        except Exception as e:\n            self.err(e)", "code_tokens": "def fill_nulls ( self , col : str ) : n = [ None , \"\" ] try : self . df [ col ] = self . df [ col ] . replace ( n , nan ) except Exception as e : self . err ( e )", "docstring_tokens": "Fill all null values with NaN values in a column . Null values are None or en empty string", "label": 1}, {"idx": "cosqa-train-2336", "doc": "check skewness of dataset using python", "code": "def skewness(data):\n    \"\"\"\n    Returns the skewness of ``data``.\n    \"\"\"\n\n    if len(data) == 0:\n        return None\n\n    num = moment(data, 3)\n    denom = moment(data, 2) ** 1.5\n\n    return num / denom if denom != 0 else 0.", "code_tokens": "def skewness ( data ) : if len ( data ) == 0 : return None num = moment ( data , 3 ) denom = moment ( data , 2 ) ** 1.5 return num / denom if denom != 0 else 0.", "docstring_tokens": "Returns the skewness of data .", "label": 0}, {"idx": "cosqa-train-2337", "doc": "python fill masked array", "code": "def inpaint(self):\n        \"\"\" Replace masked-out elements in an array using an iterative image inpainting algorithm. \"\"\"\n\n        import inpaint\n        filled = inpaint.replace_nans(np.ma.filled(self.raster_data, np.NAN).astype(np.float32), 3, 0.01, 2)\n        self.raster_data = np.ma.masked_invalid(filled)", "code_tokens": "def inpaint ( self ) : import inpaint filled = inpaint . replace_nans ( np . ma . filled ( self . raster_data , np . NAN ) . astype ( np . float32 ) , 3 , 0.01 , 2 ) self . raster_data = np . ma . masked_invalid ( filled )", "docstring_tokens": "Replace masked - out elements in an array using an iterative image inpainting algorithm .", "label": 0}, {"idx": "cosqa-train-2338", "doc": "check the dimension of the array python numpy", "code": "def _check_color_dim(val):\n    \"\"\"Ensure val is Nx(n_col), usually Nx3\"\"\"\n    val = np.atleast_2d(val)\n    if val.shape[1] not in (3, 4):\n        raise RuntimeError('Value must have second dimension of size 3 or 4')\n    return val, val.shape[1]", "code_tokens": "def _check_color_dim ( val ) : val = np . atleast_2d ( val ) if val . shape [ 1 ] not in ( 3 , 4 ) : raise RuntimeError ( 'Value must have second dimension of size 3 or 4' ) return val , val . shape [ 1 ]", "docstring_tokens": "Ensure val is Nx ( n_col ) usually Nx3", "label": 0}, {"idx": "cosqa-train-2339", "doc": "python filter none list", "code": "def filter_none(list_of_points):\n    \"\"\"\n    \n    :param list_of_points: \n    :return: list_of_points with None's removed\n    \"\"\"\n    remove_elementnone = filter(lambda p: p is not None, list_of_points)\n    remove_sublistnone = filter(lambda p: not contains_none(p), remove_elementnone)\n    return list(remove_sublistnone)", "code_tokens": "def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "docstring_tokens": ": param list_of_points : : return : list_of_points with None s removed", "label": 0}, {"idx": "cosqa-train-2340", "doc": "checking device list python tensorflow", "code": "def available_gpus():\n  \"\"\"List of GPU device names detected by TensorFlow.\"\"\"\n  local_device_protos = device_lib.list_local_devices()\n  return [x.name for x in local_device_protos if x.device_type == 'GPU']", "code_tokens": "def available_gpus ( ) : local_device_protos = device_lib . list_local_devices ( ) return [ x . name for x in local_device_protos if x . device_type == 'GPU' ]", "docstring_tokens": "List of GPU device names detected by TensorFlow .", "label": 1}, {"idx": "cosqa-train-2341", "doc": "python filter to remove certain lines", "code": "def cleanLines(source, lineSep=os.linesep):\n    \"\"\"\n    :param source: some iterable source (list, file, etc)\n    :param lineSep: string of separators (chars) that must be removed\n    :return: list of non empty lines with removed separators\n    \"\"\"\n    stripped = (line.strip(lineSep) for line in source)\n    return (line for line in stripped if len(line) != 0)", "code_tokens": "def cleanLines ( source , lineSep = os . linesep ) : stripped = ( line . strip ( lineSep ) for line in source ) return ( line for line in stripped if len ( line ) != 0 )", "docstring_tokens": ": param source : some iterable source ( list file etc ) : param lineSep : string of separators ( chars ) that must be removed : return : list of non empty lines with removed separators", "label": 0}, {"idx": "cosqa-train-2342", "doc": "checking if two values are close to eachother python", "code": "def allclose(a, b):\n    \"\"\"\n    Test that a and b are close and match in shape.\n\n    Parameters\n    ----------\n    a : ndarray\n        First array to check\n\n    b : ndarray\n        First array to check\n    \"\"\"\n    from numpy import allclose\n    return (a.shape == b.shape) and allclose(a, b)", "code_tokens": "def allclose ( a , b ) : from numpy import allclose return ( a . shape == b . shape ) and allclose ( a , b )", "docstring_tokens": "Test that a and b are close and match in shape .", "label": 0}, {"idx": "cosqa-train-2343", "doc": "python findall lower upper case", "code": "def camel_to_snake_case(name):\n    \"\"\"Takes a camelCased string and converts to snake_case.\"\"\"\n    pattern = r'[A-Z][a-z]+|[A-Z]+(?![a-z])'\n    return '_'.join(map(str.lower, re.findall(pattern, name)))", "code_tokens": "def camel_to_snake_case ( name ) : pattern = r'[A-Z][a-z]+|[A-Z]+(?![a-z])' return '_' . join ( map ( str . lower , re . findall ( pattern , name ) ) )", "docstring_tokens": "Takes a camelCased string and converts to snake_case .", "label": 0}, {"idx": "cosqa-train-2344", "doc": "clear memory in python to avoid memory error", "code": "def invalidate_cache(cpu, address, size):\n        \"\"\" remove decoded instruction from instruction cache \"\"\"\n        cache = cpu.instruction_cache\n        for offset in range(size):\n            if address + offset in cache:\n                del cache[address + offset]", "code_tokens": "def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]", "docstring_tokens": "remove decoded instruction from instruction cache", "label": 1}, {"idx": "cosqa-train-2345", "doc": "python finding index of item in list", "code": "def sorted_index(values, x):\n    \"\"\"\n    For list, values, returns the index location of element x. If x does not exist will raise an error.\n\n    :param values: list\n    :param x: item\n    :return: integer index\n    \"\"\"\n    i = bisect_left(values, x)\n    j = bisect_right(values, x)\n    return values[i:j].index(x) + i", "code_tokens": "def sorted_index ( values , x ) : i = bisect_left ( values , x ) j = bisect_right ( values , x ) return values [ i : j ] . index ( x ) + i", "docstring_tokens": "For list values returns the index location of element x . If x does not exist will raise an error .", "label": 0}, {"idx": "cosqa-train-2346", "doc": "clear screen of python shell", "code": "def clear():\n    \"\"\"Clears the console.\"\"\"\n    if sys.platform.startswith(\"win\"):\n        call(\"cls\", shell=True)\n    else:\n        call(\"clear\", shell=True)", "code_tokens": "def clear ( ) : if sys . platform . startswith ( \"win\" ) : call ( \"cls\" , shell = True ) else : call ( \"clear\" , shell = True )", "docstring_tokens": "Clears the console .", "label": 0}, {"idx": "cosqa-train-2347", "doc": "python finding the second largest number in a list without sorting", "code": "def find_lt(a, x):\n    \"\"\"Find rightmost value less than x.\"\"\"\n    i = bs.bisect_left(a, x)\n    if i: return i - 1\n    raise ValueError", "code_tokens": "def find_lt ( a , x ) : i = bs . bisect_left ( a , x ) if i : return i - 1 raise ValueError", "docstring_tokens": "Find rightmost value less than x .", "label": 0}, {"idx": "cosqa-train-2348", "doc": "clearing browser cache after logging out python", "code": "def logout(cache):\n    \"\"\"\n    Logs out the current session by removing it from the cache. This is\n    expected to only occur when a session has\n    \"\"\"\n    cache.set(flask.session['auth0_key'], None)\n    flask.session.clear()\n    return True", "code_tokens": "def logout ( cache ) : cache . set ( flask . session [ 'auth0_key' ] , None ) flask . session . clear ( ) return True", "docstring_tokens": "Logs out the current session by removing it from the cache . This is expected to only occur when a session has", "label": 1}, {"idx": "cosqa-train-2349", "doc": "python flask imagwees show up as file not found", "code": "def retrieve_asset(filename):\n    \"\"\" Retrieves a non-image asset associated with an entry \"\"\"\n\n    record = model.Image.get(asset_name=filename)\n    if not record:\n        raise http_error.NotFound(\"File not found\")\n    if not record.is_asset:\n        raise http_error.Forbidden()\n\n    return flask.send_file(record.file_path, conditional=True)", "code_tokens": "def retrieve_asset ( filename ) : record = model . Image . get ( asset_name = filename ) if not record : raise http_error . NotFound ( \"File not found\" ) if not record . is_asset : raise http_error . Forbidden ( ) return flask . send_file ( record . file_path , conditional = True )", "docstring_tokens": "Retrieves a non - image asset associated with an entry", "label": 0}, {"idx": "cosqa-train-2350", "doc": "clearing everything from memory python", "code": "def Flush(self):\n    \"\"\"Flush all items from cache.\"\"\"\n    while self._age:\n      node = self._age.PopLeft()\n      self.KillObject(node.data)\n\n    self._hash = dict()", "code_tokens": "def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )", "docstring_tokens": "Flush all items from cache .", "label": 0}, {"idx": "cosqa-train-2351", "doc": "python flask jsonify html/text", "code": "def json_template(data, template_name, template_context):\n    \"\"\"Old style, use JSONTemplateResponse instead of this.\n    \"\"\"\n    html = render_to_string(template_name, template_context)\n    data = data or {}\n    data['html'] = html\n    return HttpResponse(json_encode(data), content_type='application/json')", "code_tokens": "def json_template ( data , template_name , template_context ) : html = render_to_string ( template_name , template_context ) data = data or { } data [ 'html' ] = html return HttpResponse ( json_encode ( data ) , content_type = 'application/json' )", "docstring_tokens": "Old style use JSONTemplateResponse instead of this .", "label": 0}, {"idx": "cosqa-train-2352", "doc": "close an h5 file python", "code": "def _closeResources(self):\n        \"\"\" Closes the root Dataset.\n        \"\"\"\n        logger.info(\"Closing: {}\".format(self._fileName))\n        self._h5Group.close()\n        self._h5Group = None", "code_tokens": "def _closeResources ( self ) : logger . info ( \"Closing: {}\" . format ( self . _fileName ) ) self . _h5Group . close ( ) self . _h5Group = None", "docstring_tokens": "Closes the root Dataset .", "label": 0}, {"idx": "cosqa-train-2353", "doc": "python flask pass boolean as post", "code": "def arg_bool(name, default=False):\n    \"\"\" Fetch a query argument, as a boolean. \"\"\"\n    v = request.args.get(name, '')\n    if not len(v):\n        return default\n    return v in BOOL_TRUISH", "code_tokens": "def arg_bool ( name , default = False ) : v = request . args . get ( name , '' ) if not len ( v ) : return default return v in BOOL_TRUISH", "docstring_tokens": "Fetch a query argument as a boolean .", "label": 0}, {"idx": "cosqa-train-2354", "doc": "close python interactive window", "code": "def closing_plugin(self, cancelable=False):\n        \"\"\"Perform actions before parent main window is closed\"\"\"\n        self.dialog_manager.close_all()\n        self.shell.exit_interpreter()\n        return True", "code_tokens": "def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True", "docstring_tokens": "Perform actions before parent main window is closed", "label": 0}, {"idx": "cosqa-train-2355", "doc": "python flask return http status 500", "code": "def view_500(request, url=None):\n    \"\"\"\n    it returns a 500 http response\n    \"\"\"\n    res = render_to_response(\"500.html\", context_instance=RequestContext(request))\n    res.status_code = 500\n    return res", "code_tokens": "def view_500 ( request , url = None ) : res = render_to_response ( \"500.html\" , context_instance = RequestContext ( request ) ) res . status_code = 500 return res", "docstring_tokens": "it returns a 500 http response", "label": 0}, {"idx": "cosqa-train-2356", "doc": "close socket python shutdown", "code": "def stop(self, dummy_signum=None, dummy_frame=None):\n        \"\"\" Shutdown process (this method is also a signal handler) \"\"\"\n        logging.info('Shutting down ...')\n        self.socket.close()\n        sys.exit(0)", "code_tokens": "def stop ( self , dummy_signum = None , dummy_frame = None ) : logging . info ( 'Shutting down ...' ) self . socket . close ( ) sys . exit ( 0 )", "docstring_tokens": "Shutdown process ( this method is also a signal handler )", "label": 0}, {"idx": "cosqa-train-2357", "doc": "python flask session save", "code": "def save_session_to_file(self, sessionfile):\n        \"\"\"Not meant to be used directly, use :meth:`Instaloader.save_session_to_file`.\"\"\"\n        pickle.dump(requests.utils.dict_from_cookiejar(self._session.cookies), sessionfile)", "code_tokens": "def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )", "docstring_tokens": "Not meant to be used directly use : meth : Instaloader . save_session_to_file .", "label": 1}, {"idx": "cosqa-train-2358", "doc": "close window python gui", "code": "def closing_plugin(self, cancelable=False):\n        \"\"\"Perform actions before parent main window is closed\"\"\"\n        self.dialog_manager.close_all()\n        self.shell.exit_interpreter()\n        return True", "code_tokens": "def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True", "docstring_tokens": "Perform actions before parent main window is closed", "label": 1}, {"idx": "cosqa-train-2359", "doc": "python flask set persistent cookies", "code": "def logout(cache):\n    \"\"\"\n    Logs out the current session by removing it from the cache. This is\n    expected to only occur when a session has\n    \"\"\"\n    cache.set(flask.session['auth0_key'], None)\n    flask.session.clear()\n    return True", "code_tokens": "def logout ( cache ) : cache . set ( flask . session [ 'auth0_key' ] , None ) flask . session . clear ( ) return True", "docstring_tokens": "Logs out the current session by removing it from the cache . This is expected to only occur when a session has", "label": 0}, {"idx": "cosqa-train-2360", "doc": "code for go to new line in python", "code": "def erase_lines(n=1):\n    \"\"\" Erases n lines from the screen and moves the cursor up to follow\n    \"\"\"\n    for _ in range(n):\n        print(codes.cursor[\"up\"], end=\"\")\n        print(codes.cursor[\"eol\"], end=\"\")", "code_tokens": "def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ \"up\" ] , end = \"\" ) print ( codes . cursor [ \"eol\" ] , end = \"\" )", "docstring_tokens": "Erases n lines from the screen and moves the cursor up to follow", "label": 0}, {"idx": "cosqa-train-2361", "doc": "python flask static folder", "code": "def staticdir():\n    \"\"\"Return the location of the static data directory.\"\"\"\n    root = os.path.abspath(os.path.dirname(__file__))\n    return os.path.join(root, \"static\")", "code_tokens": "def staticdir ( ) : root = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( root , \"static\" )", "docstring_tokens": "Return the location of the static data directory .", "label": 0}, {"idx": "cosqa-train-2362", "doc": "python flaskalchemy filter use obejct's attribute", "code": "def filter(self, f, operator=\"and\"):\n        \"\"\"\n        Add a filter to the query\n\n        Takes a Filter object, or a filterable DSL object.\n        \"\"\"\n        if self._filtered:\n            self._filter_dsl.filter(f)\n        else:\n            self._build_filtered_query(f, operator)\n        return self", "code_tokens": "def filter ( self , f , operator = \"and\" ) : if self . _filtered : self . _filter_dsl . filter ( f ) else : self . _build_filtered_query ( f , operator ) return self", "docstring_tokens": "Add a filter to the query", "label": 0}, {"idx": "cosqa-train-2363", "doc": "code to create folders in python", "code": "def mkdir(dir, enter):\n    \"\"\"Create directory with template for topic of the current environment\n\n    \"\"\"\n\n    if not os.path.exists(dir):\n        os.makedirs(dir)", "code_tokens": "def mkdir ( dir , enter ) : if not os . path . exists ( dir ) : os . makedirs ( dir )", "docstring_tokens": "Create directory with template for topic of the current environment", "label": 1}, {"idx": "cosqa-train-2364", "doc": "python flatten arbitrarily multi nested sequence", "code": "def flatten(nested):\n    \"\"\" Return a flatten version of the nested argument \"\"\"\n    flat_return = list()\n\n    def __inner_flat(nested,flat):\n        for i in nested:\n            __inner_flat(i, flat) if isinstance(i, list) else flat.append(i)\n        return flat\n\n    __inner_flat(nested,flat_return)\n\n    return flat_return", "code_tokens": "def flatten ( nested ) : flat_return = list ( ) def __inner_flat ( nested , flat ) : for i in nested : __inner_flat ( i , flat ) if isinstance ( i , list ) else flat . append ( i ) return flat __inner_flat ( nested , flat_return ) return flat_return", "docstring_tokens": "Return a flatten version of the nested argument", "label": 0}, {"idx": "cosqa-train-2365", "doc": "combine merge pdf files python", "code": "def merge_pdfs(pdf_filepaths, out_filepath):\n    \"\"\" Merge all the PDF files in `pdf_filepaths` in a new PDF file `out_filepath`.\n\n    Parameters\n    ----------\n    pdf_filepaths: list of str\n        Paths to PDF files.\n\n    out_filepath: str\n        Path to the result PDF file.\n\n    Returns\n    -------\n    path: str\n        The output file path.\n    \"\"\"\n    merger = PdfFileMerger()\n    for pdf in pdf_filepaths:\n        merger.append(PdfFileReader(open(pdf, 'rb')))\n\n    merger.write(out_filepath)\n\n    return out_filepath", "code_tokens": "def merge_pdfs ( pdf_filepaths , out_filepath ) : merger = PdfFileMerger ( ) for pdf in pdf_filepaths : merger . append ( PdfFileReader ( open ( pdf , 'rb' ) ) ) merger . write ( out_filepath ) return out_filepath", "docstring_tokens": "Merge all the PDF files in pdf_filepaths in a new PDF file out_filepath .", "label": 0}, {"idx": "cosqa-train-2366", "doc": "python flatten list if lists", "code": "def flatten(l, types=(list, float)):\n    \"\"\"\n    Flat nested list of lists into a single list.\n    \"\"\"\n    l = [item if isinstance(item, types) else [item] for item in l]\n    return [item for sublist in l for item in sublist]", "code_tokens": "def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Flat nested list of lists into a single list .", "label": 0}, {"idx": "cosqa-train-2367", "doc": "combine to dictionaries python", "code": "def merge_dict(data, *args):\n    \"\"\"Merge any number of dictionaries\n    \"\"\"\n    results = {}\n    for current in (data,) + args:\n        results.update(current)\n    return results", "code_tokens": "def merge_dict ( data , * args ) : results = { } for current in ( data , ) + args : results . update ( current ) return results", "docstring_tokens": "Merge any number of dictionaries", "label": 0}, {"idx": "cosqa-train-2368", "doc": "python flatten list or tuples", "code": "def flatten(nested, containers=(list, tuple)):\n    \"\"\" Flatten a nested list by yielding its scalar items.\n    \"\"\"\n    for item in nested:\n        if hasattr(item, \"next\") or isinstance(item, containers):\n            for subitem in flatten(item):\n                yield subitem\n        else:\n            yield item", "code_tokens": "def flatten ( nested , containers = ( list , tuple ) ) : for item in nested : if hasattr ( item , \"next\" ) or isinstance ( item , containers ) : for subitem in flatten ( item ) : yield subitem else : yield item", "docstring_tokens": "Flatten a nested list by yielding its scalar items .", "label": 0}, {"idx": "cosqa-train-2369", "doc": "combining hours and minutes to minutes in python", "code": "def pprint(self, seconds):\n        \"\"\"\n        Pretty Prints seconds as Hours:Minutes:Seconds.MilliSeconds\n\n        :param seconds:  The time in seconds.\n        \"\"\"\n        return (\"%d:%02d:%02d.%03d\", reduce(lambda ll, b: divmod(ll[0], b) + ll[1:], [(seconds * 1000,), 1000, 60, 60]))", "code_tokens": "def pprint ( self , seconds ) : return ( \"%d:%02d:%02d.%03d\" , reduce ( lambda ll , b : divmod ( ll [ 0 ] , b ) + ll [ 1 : ] , [ ( seconds * 1000 , ) , 1000 , 60 , 60 ] ) )", "docstring_tokens": "Pretty Prints seconds as Hours : Minutes : Seconds . MilliSeconds", "label": 0}, {"idx": "cosqa-train-2370", "doc": "python flatten numpy array", "code": "def flatten_array(grid):\n    \"\"\"\n    Takes a multi-dimensional array and returns a 1 dimensional array with the\n    same contents.\n    \"\"\"\n    grid = [grid[i][j] for i in range(len(grid)) for j in range(len(grid[i]))]\n    while type(grid[0]) is list:\n        grid = flatten_array(grid)\n    return grid", "code_tokens": "def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid", "docstring_tokens": "Takes a multi - dimensional array and returns a 1 dimensional array with the same contents .", "label": 0}, {"idx": "cosqa-train-2371", "doc": "command for running jar file in python", "code": "def version_jar(self):\n\t\t\"\"\"\n\t\tSpecial case of version() when the executable is a JAR file.\n\t\t\"\"\"\n\t\tcmd = config.get_command('java')\n\t\tcmd.append('-jar')\n\t\tcmd += self.cmd\n\t\tself.version(cmd=cmd, path=self.cmd[0])", "code_tokens": "def version_jar ( self ) : cmd = config . get_command ( 'java' ) cmd . append ( '-jar' ) cmd += self . cmd self . version ( cmd = cmd , path = self . cmd [ 0 ] )", "docstring_tokens": "Special case of version () when the executable is a JAR file .", "label": 0}, {"idx": "cosqa-train-2372", "doc": "python flatten of nested list", "code": "def flatten(lis):\n    \"\"\"Given a list, possibly nested to any level, return it flattened.\"\"\"\n    new_lis = []\n    for item in lis:\n        if isinstance(item, collections.Sequence) and not isinstance(item, basestring):\n            new_lis.extend(flatten(item))\n        else:\n            new_lis.append(item)\n    return new_lis", "code_tokens": "def flatten ( lis ) : new_lis = [ ] for item in lis : if isinstance ( item , collections . Sequence ) and not isinstance ( item , basestring ) : new_lis . extend ( flatten ( item ) ) else : new_lis . append ( item ) return new_lis", "docstring_tokens": "Given a list possibly nested to any level return it flattened .", "label": 0}, {"idx": "cosqa-train-2373", "doc": "command to clear a screen in python shell", "code": "def clear():\n    \"\"\"Clears the console.\"\"\"\n    if sys.platform.startswith(\"win\"):\n        call(\"cls\", shell=True)\n    else:\n        call(\"clear\", shell=True)", "code_tokens": "def clear ( ) : if sys . platform . startswith ( \"win\" ) : call ( \"cls\" , shell = True ) else : call ( \"clear\" , shell = True )", "docstring_tokens": "Clears the console .", "label": 0}, {"idx": "cosqa-train-2374", "doc": "python flatten string list", "code": "def flatten_list(l):\n    \"\"\" Nested lists to single-level list, does not split strings\"\"\"\n    return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "code_tokens": "def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )", "docstring_tokens": "Nested lists to single - level list does not split strings", "label": 0}, {"idx": "cosqa-train-2375", "doc": "comments at the beginning of a python file", "code": "def parse_comments_for_file(filename):\n    \"\"\"\n    Return a list of all parsed comments in a file.  Mostly for testing &\n    interactive use.\n    \"\"\"\n    return [parse_comment(strip_stars(comment), next_line)\n            for comment, next_line in get_doc_comments(read_file(filename))]", "code_tokens": "def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]", "docstring_tokens": "Return a list of all parsed comments in a file . Mostly for testing & interactive use .", "label": 0}, {"idx": "cosqa-train-2376", "doc": "python float to int type round", "code": "def intround(value):\n    \"\"\"Given a float returns a rounded int. Should give the same result on\n    both Py2/3\n    \"\"\"\n\n    return int(decimal.Decimal.from_float(\n        value).to_integral_value(decimal.ROUND_HALF_EVEN))", "code_tokens": "def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )", "docstring_tokens": "Given a float returns a rounded int . Should give the same result on both Py2 / 3", "label": 0}, {"idx": "cosqa-train-2377", "doc": "compare character counts from two strings python", "code": "def count_string_diff(a,b):\n    \"\"\"Return the number of characters in two strings that don't exactly match\"\"\"\n    shortest = min(len(a), len(b))\n    return sum(a[i] != b[i] for i in range(shortest))", "code_tokens": "def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )", "docstring_tokens": "Return the number of characters in two strings that don t exactly match", "label": 1}, {"idx": "cosqa-train-2378", "doc": "python flush all buffer", "code": "def flush():\n    \"\"\"Try to flush all stdio buffers, both from python and from C.\"\"\"\n    try:\n        sys.stdout.flush()\n        sys.stderr.flush()\n    except (AttributeError, ValueError, IOError):\n        pass  # unsupported\n    try:\n        libc.fflush(None)\n    except (AttributeError, ValueError, IOError):\n        pass", "code_tokens": "def flush ( ) : try : sys . stdout . flush ( ) sys . stderr . flush ( ) except ( AttributeError , ValueError , IOError ) : pass # unsupported try : libc . fflush ( None ) except ( AttributeError , ValueError , IOError ) : pass", "docstring_tokens": "Try to flush all stdio buffers both from python and from C .", "label": 0}, {"idx": "cosqa-train-2379", "doc": "compare two xml documents python", "code": "def are_equal_xml(a_xml, b_xml):\n    \"\"\"Normalize and compare XML documents for equality. The document may or may not be\n    a DataONE type.\n\n    Args:\n      a_xml: str\n      b_xml: str\n        XML documents to compare for equality.\n\n    Returns:\n      bool: ``True`` if the XML documents are semantically equivalent.\n\n    \"\"\"\n    a_dom = xml.dom.minidom.parseString(a_xml)\n    b_dom = xml.dom.minidom.parseString(b_xml)\n    return are_equal_elements(a_dom.documentElement, b_dom.documentElement)", "code_tokens": "def are_equal_xml ( a_xml , b_xml ) : a_dom = xml . dom . minidom . parseString ( a_xml ) b_dom = xml . dom . minidom . parseString ( b_xml ) return are_equal_elements ( a_dom . documentElement , b_dom . documentElement )", "docstring_tokens": "Normalize and compare XML documents for equality . The document may or may not be a DataONE type .", "label": 0}, {"idx": "cosqa-train-2380", "doc": "python force a int type", "code": "def safe_int_conv(number):\n    \"\"\"Safely convert a single number to integer.\"\"\"\n    try:\n        return int(np.array(number).astype(int, casting='safe'))\n    except TypeError:\n        raise ValueError('cannot safely convert {} to integer'.format(number))", "code_tokens": "def safe_int_conv ( number ) : try : return int ( np . array ( number ) . astype ( int , casting = 'safe' ) ) except TypeError : raise ValueError ( 'cannot safely convert {} to integer' . format ( number ) )", "docstring_tokens": "Safely convert a single number to integer .", "label": 0}, {"idx": "cosqa-train-2381", "doc": "compare unhashable lists python unique values", "code": "def dedupe(items):\n    \"\"\"Remove duplicates from a sequence (of hashable items) while maintaining\n    order. NOTE: This only works if items in the list are hashable types.\n\n    Taken from the Python Cookbook, 3rd ed. Such a great book!\n\n    \"\"\"\n    seen = set()\n    for item in items:\n        if item not in seen:\n            yield item\n            seen.add(item)", "code_tokens": "def dedupe ( items ) : seen = set ( ) for item in items : if item not in seen : yield item seen . add ( item )", "docstring_tokens": "Remove duplicates from a sequence ( of hashable items ) while maintaining order . NOTE : This only works if items in the list are hashable types .", "label": 0}, {"idx": "cosqa-train-2382", "doc": "python fork off command and quit", "code": "def go_to_background():\n    \"\"\" Daemonize the running process. \"\"\"\n    try:\n        if os.fork():\n            sys.exit()\n    except OSError as errmsg:\n        LOGGER.error('Fork failed: {0}'.format(errmsg))\n        sys.exit('Fork failed')", "code_tokens": "def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "docstring_tokens": "Daemonize the running process .", "label": 0}, {"idx": "cosqa-train-2383", "doc": "compile c++ and python files into oneproject", "code": "def generate(env):\n    \"\"\"Add Builders and construction variables for SGI MIPS C++ to an Environment.\"\"\"\n\n    cplusplus.generate(env)\n\n    env['CXX']         = 'CC'\n    env['CXXFLAGS']    = SCons.Util.CLVar('-LANG:std')\n    env['SHCXX']       = '$CXX'\n    env['SHOBJSUFFIX'] = '.o'\n    env['STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME'] = 1", "code_tokens": "def generate ( env ) : cplusplus . generate ( env ) env [ 'CXX' ] = 'CC' env [ 'CXXFLAGS' ] = SCons . Util . CLVar ( '-LANG:std' ) env [ 'SHCXX' ] = '$CXX' env [ 'SHOBJSUFFIX' ] = '.o' env [ 'STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME' ] = 1", "docstring_tokens": "Add Builders and construction variables for SGI MIPS C ++ to an Environment .", "label": 0}, {"idx": "cosqa-train-2384", "doc": "python format multiline table", "code": "def multis_2_mono(table):\n    \"\"\"\n    Converts each multiline string in a table to single line.\n\n    Parameters\n    ----------\n    table : list of list of str\n        A list of rows containing strings\n\n    Returns\n    -------\n    table : list of lists of str\n    \"\"\"\n    for row in range(len(table)):\n        for column in range(len(table[row])):\n            table[row][column] = table[row][column].replace('\\n', ' ')\n\n    return table", "code_tokens": "def multis_2_mono ( table ) : for row in range ( len ( table ) ) : for column in range ( len ( table [ row ] ) ) : table [ row ] [ column ] = table [ row ] [ column ] . replace ( '\\n' , ' ' ) return table", "docstring_tokens": "Converts each multiline string in a table to single line .", "label": 0}, {"idx": "cosqa-train-2385", "doc": "compute manhattan distance python", "code": "def _manhattan_distance(vec_a, vec_b):\n    \"\"\"Return manhattan distance between two lists of numbers.\"\"\"\n    if len(vec_a) != len(vec_b):\n        raise ValueError('len(vec_a) must equal len(vec_b)')\n    return sum(map(lambda a, b: abs(a - b), vec_a, vec_b))", "code_tokens": "def _manhattan_distance ( vec_a , vec_b ) : if len ( vec_a ) != len ( vec_b ) : raise ValueError ( 'len(vec_a) must equal len(vec_b)' ) return sum ( map ( lambda a , b : abs ( a - b ) , vec_a , vec_b ) )", "docstring_tokens": "Return manhattan distance between two lists of numbers .", "label": 1}, {"idx": "cosqa-train-2386", "doc": "python format string multiple arguemtns example", "code": "def safe_format(s, **kwargs):\n  \"\"\"\n  :type s str\n  \"\"\"\n  return string.Formatter().vformat(s, (), defaultdict(str, **kwargs))", "code_tokens": "def safe_format ( s , * * kwargs ) : return string . Formatter ( ) . vformat ( s , ( ) , defaultdict ( str , * * kwargs ) )", "docstring_tokens": ": type s str", "label": 0}, {"idx": "cosqa-train-2387", "doc": "compute the number of nodes in the tree python", "code": "def num_leaves(tree):\n    \"\"\"Determine the number of leaves in a tree\"\"\"\n    if tree.is_leaf:\n        return 1\n    else:\n        return num_leaves(tree.left_child) + num_leaves(tree.right_child)", "code_tokens": "def num_leaves ( tree ) : if tree . is_leaf : return 1 else : return num_leaves ( tree . left_child ) + num_leaves ( tree . right_child )", "docstring_tokens": "Determine the number of leaves in a tree", "label": 0}, {"idx": "cosqa-train-2388", "doc": "python format work with latex", "code": "def print_latex(o):\n    \"\"\"A function to generate the latex representation of sympy\n    expressions.\"\"\"\n    if can_print_latex(o):\n        s = latex(o, mode='plain')\n        s = s.replace('\\\\dag','\\\\dagger')\n        s = s.strip('$')\n        return '$$%s$$' % s\n    # Fallback to the string printer\n    return None", "code_tokens": "def print_latex ( o ) : if can_print_latex ( o ) : s = latex ( o , mode = 'plain' ) s = s . replace ( '\\\\dag' , '\\\\dagger' ) s = s . strip ( '$' ) return '$$%s$$' % s # Fallback to the string printer return None", "docstring_tokens": "A function to generate the latex representation of sympy expressions .", "label": 0}, {"idx": "cosqa-train-2389", "doc": "comupile python into native", "code": "def xeval(source, optimize=True):\n    \"\"\"Compiles to native Python bytecode and runs program, returning the\n    topmost value on the stack.\n\n    Args:\n        optimize: Whether to optimize the code after parsing it.\n\n    Returns:\n        None: If the stack is empty\n        obj: If the stack contains a single value\n        [obj, obj, ...]: If the stack contains many values\n    \"\"\"\n    native = xcompile(source, optimize=optimize)\n    return native()", "code_tokens": "def xeval ( source , optimize = True ) : native = xcompile ( source , optimize = optimize ) return native ( )", "docstring_tokens": "Compiles to native Python bytecode and runs program returning the topmost value on the stack .", "label": 0}, {"idx": "cosqa-train-2390", "doc": "python formatted print of a tuple", "code": "def _tuple_repr(data):\n    \"\"\"Return a repr() for a list/tuple\"\"\"\n    if len(data) == 1:\n        return \"(%s,)\" % rpr(data[0])\n    else:\n        return \"(%s)\" % \", \".join([rpr(x) for x in data])", "code_tokens": "def _tuple_repr ( data ) : if len ( data ) == 1 : return \"(%s,)\" % rpr ( data [ 0 ] ) else : return \"(%s)\" % \", \" . join ( [ rpr ( x ) for x in data ] )", "docstring_tokens": "Return a repr () for a list / tuple", "label": 0}, {"idx": "cosqa-train-2391", "doc": "comvert timestamp to datetime python", "code": "def timestamp_to_datetime(timestamp):\n    \"\"\"Convert an ARF timestamp to a datetime.datetime object (naive local time)\"\"\"\n    from datetime import datetime, timedelta\n    obj = datetime.fromtimestamp(timestamp[0])\n    return obj + timedelta(microseconds=int(timestamp[1]))", "code_tokens": "def timestamp_to_datetime ( timestamp ) : from datetime import datetime , timedelta obj = datetime . fromtimestamp ( timestamp [ 0 ] ) return obj + timedelta ( microseconds = int ( timestamp [ 1 ] ) )", "docstring_tokens": "Convert an ARF timestamp to a datetime . datetime object ( naive local time )", "label": 0}, {"idx": "cosqa-train-2392", "doc": "python fromtimestamp without time zone", "code": "def fromtimestamp(cls, timestamp):\n    \"\"\"Returns a datetime object of a given timestamp (in local tz).\"\"\"\n    d = cls.utcfromtimestamp(timestamp)\n    return d.astimezone(localtz())", "code_tokens": "def fromtimestamp ( cls , timestamp ) : d = cls . utcfromtimestamp ( timestamp ) return d . astimezone ( localtz ( ) )", "docstring_tokens": "Returns a datetime object of a given timestamp ( in local tz ) .", "label": 1}, {"idx": "cosqa-train-2393", "doc": "conbining str with int in python", "code": "def str2int(num, radix=10, alphabet=BASE85):\n    \"\"\"helper function for quick base conversions from strings to integers\"\"\"\n    return NumConv(radix, alphabet).str2int(num)", "code_tokens": "def str2int ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . str2int ( num )", "docstring_tokens": "helper function for quick base conversions from strings to integers", "label": 1}, {"idx": "cosqa-train-2394", "doc": "python function definition of position of occurrences of substring", "code": "def get_substring_idxs(substr, string):\n    \"\"\"\n    Return a list of indexes of substr. If substr not found, list is\n    empty.\n\n    Arguments:\n        substr (str): Substring to match.\n        string (str): String to match in.\n\n    Returns:\n        list of int: Start indices of substr.\n    \"\"\"\n    return [match.start() for match in re.finditer(substr, string)]", "code_tokens": "def get_substring_idxs ( substr , string ) : return [ match . start ( ) for match in re . finditer ( substr , string ) ]", "docstring_tokens": "Return a list of indexes of substr . If substr not found list is empty .", "label": 1}, {"idx": "cosqa-train-2395", "doc": "concatenate 1d arrays column wise python", "code": "def _concatenate_virtual_arrays(arrs, cols=None, scaling=None):\n    \"\"\"Return a virtual concatenate of several NumPy arrays.\"\"\"\n    return None if not len(arrs) else ConcatenatedArrays(arrs, cols,\n                                                         scaling=scaling)", "code_tokens": "def _concatenate_virtual_arrays ( arrs , cols = None , scaling = None ) : return None if not len ( arrs ) else ConcatenatedArrays ( arrs , cols , scaling = scaling )", "docstring_tokens": "Return a virtual concatenate of several NumPy arrays .", "label": 0}, {"idx": "cosqa-train-2396", "doc": "python function doc returns none", "code": "def short_description(func):\n    \"\"\"\n    Given an object with a docstring, return the first line of the docstring\n    \"\"\"\n\n    doc = inspect.getdoc(func)\n    if doc is not None:\n        doc = inspect.cleandoc(doc)\n        lines = doc.splitlines()\n        return lines[0]\n\n    return \"\"", "code_tokens": "def short_description ( func ) : doc = inspect . getdoc ( func ) if doc is not None : doc = inspect . cleandoc ( doc ) lines = doc . splitlines ( ) return lines [ 0 ] return \"\"", "docstring_tokens": "Given an object with a docstring return the first line of the docstring", "label": 0}, {"idx": "cosqa-train-2397", "doc": "concatenate array along axis python", "code": "def _concatenate_virtual_arrays(arrs, cols=None, scaling=None):\n    \"\"\"Return a virtual concatenate of several NumPy arrays.\"\"\"\n    return None if not len(arrs) else ConcatenatedArrays(arrs, cols,\n                                                         scaling=scaling)", "code_tokens": "def _concatenate_virtual_arrays ( arrs , cols = None , scaling = None ) : return None if not len ( arrs ) else ConcatenatedArrays ( arrs , cols , scaling = scaling )", "docstring_tokens": "Return a virtual concatenate of several NumPy arrays .", "label": 0}, {"idx": "cosqa-train-2398", "doc": "python function get previous coupon date", "code": "def get_previous(self):\n        \"\"\"Get the billing cycle prior to this one. May return None\"\"\"\n        return BillingCycle.objects.filter(date_range__lt=self.date_range).order_by('date_range').last()", "code_tokens": "def get_previous ( self ) : return BillingCycle . objects . filter ( date_range__lt = self . date_range ) . order_by ( 'date_range' ) . last ( )", "docstring_tokens": "Get the billing cycle prior to this one . May return None", "label": 0}, {"idx": "cosqa-train-2399", "doc": "concatenate multidimensional arrays python", "code": "def _concatenate_virtual_arrays(arrs, cols=None, scaling=None):\n    \"\"\"Return a virtual concatenate of several NumPy arrays.\"\"\"\n    return None if not len(arrs) else ConcatenatedArrays(arrs, cols,\n                                                         scaling=scaling)", "code_tokens": "def _concatenate_virtual_arrays ( arrs , cols = None , scaling = None ) : return None if not len ( arrs ) else ConcatenatedArrays ( arrs , cols , scaling = scaling )", "docstring_tokens": "Return a virtual concatenate of several NumPy arrays .", "label": 0}, {"idx": "cosqa-train-2400", "doc": "python function modify global varable", "code": "def set_global(node: Node, key: str, value: Any):\n    \"\"\"Adds passed value to node's globals\"\"\"\n    node.node_globals[key] = value", "code_tokens": "def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "docstring_tokens": "Adds passed value to node s globals", "label": 0}, {"idx": "cosqa-train-2401", "doc": "concatenate string to list in python", "code": "def to_list(var):\n    \"\"\"Checks if given value is a list, tries to convert, if it is not.\"\"\"\n    if var is None:\n        return []\n    if isinstance(var, str):\n        var = var.split('\\n')\n    elif not isinstance(var, list):\n        try:\n            var = list(var)\n        except TypeError:\n            raise ValueError(\"{} cannot be converted to the list.\".format(var))\n    return var", "code_tokens": "def to_list ( var ) : if var is None : return [ ] if isinstance ( var , str ) : var = var . split ( '\\n' ) elif not isinstance ( var , list ) : try : var = list ( var ) except TypeError : raise ValueError ( \"{} cannot be converted to the list.\" . format ( var ) ) return var", "docstring_tokens": "Checks if given value is a list tries to convert if it is not .", "label": 0}, {"idx": "cosqa-train-2402", "doc": "python function to remove spaces from a string", "code": "def unpunctuate(s, *, char_blacklist=string.punctuation):\n    \"\"\" Remove punctuation from string s. \"\"\"\n    # remove punctuation\n    s = \"\".join(c for c in s if c not in char_blacklist)\n    # remove consecutive spaces\n    return \" \".join(filter(None, s.split(\" \")))", "code_tokens": "def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = \"\" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return \" \" . join ( filter ( None , s . split ( \" \" ) ) )", "docstring_tokens": "Remove punctuation from string s .", "label": 0}, {"idx": "cosqa-train-2403", "doc": "conda create environment without python", "code": "def create_conda_env(sandbox_dir, env_name, dependencies, options=()):\n    \"\"\"\n    Create a conda environment inside the current sandbox for the given list of dependencies and options.\n\n    Parameters\n    ----------\n    sandbox_dir : str\n    env_name : str\n    dependencies : list\n        List of conda specs\n    options\n        List of additional options to pass to conda.  Things like [\"-c\", \"conda-forge\"]\n\n    Returns\n    -------\n    (env_dir, env_name)\n    \"\"\"\n\n    env_dir = os.path.join(sandbox_dir, env_name)\n    cmdline = [\"conda\", \"create\", \"--yes\", \"--copy\", \"--quiet\", \"-p\", env_dir] + list(options) + dependencies\n\n    log.info(\"Creating conda environment: \")\n    log.info(\"  command line: %s\", cmdline)\n    subprocess.check_call(cmdline, stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n    log.debug(\"Environment created\")\n\n    return env_dir, env_name", "code_tokens": "def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ \"conda\" , \"create\" , \"--yes\" , \"--copy\" , \"--quiet\" , \"-p\" , env_dir ] + list ( options ) + dependencies log . info ( \"Creating conda environment: \" ) log . info ( \"  command line: %s\" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( \"Environment created\" ) return env_dir , env_name", "docstring_tokens": "Create a conda environment inside the current sandbox for the given list of dependencies and options .", "label": 0}, {"idx": "cosqa-train-2404", "doc": "python function to restrict decimal places", "code": "def get_decimal_quantum(precision):\n    \"\"\"Return minimal quantum of a number, as defined by precision.\"\"\"\n    assert isinstance(precision, (int, decimal.Decimal))\n    return decimal.Decimal(10) ** (-precision)", "code_tokens": "def get_decimal_quantum ( precision ) : assert isinstance ( precision , ( int , decimal . Decimal ) ) return decimal . Decimal ( 10 ) ** ( - precision )", "docstring_tokens": "Return minimal quantum of a number as defined by precision .", "label": 0}, {"idx": "cosqa-train-2405", "doc": "construct url without making request python", "code": "def get_url(self, cmd, **args):\n        \"\"\"Expand the request URL for a request.\"\"\"\n        return self.http.base_url + self._mkurl(cmd, *args)", "code_tokens": "def get_url ( self , cmd , * * args ) : return self . http . base_url + self . _mkurl ( cmd , * args )", "docstring_tokens": "Expand the request URL for a request .", "label": 0}, {"idx": "cosqa-train-2406", "doc": "python functions eucladian distance", "code": "def euclidean(c1, c2):\n    \"\"\"Square of the euclidean distance\"\"\"\n    diffs = ((i - j) for i, j in zip(c1, c2))\n    return sum(x * x for x in diffs)", "code_tokens": "def euclidean ( c1 , c2 ) : diffs = ( ( i - j ) for i , j in zip ( c1 , c2 ) ) return sum ( x * x for x in diffs )", "docstring_tokens": "Square of the euclidean distance", "label": 1}, {"idx": "cosqa-train-2407", "doc": "continuous read of stdin python", "code": "def _read_stdin():\n    \"\"\"\n    Generator for reading from standard input in nonblocking mode.\n\n    Other ways of reading from ``stdin`` in python waits, until the buffer is\n    big enough, or until EOF character is sent.\n\n    This functions yields immediately after each line.\n    \"\"\"\n    line = sys.stdin.readline()\n    while line:\n        yield line\n        line = sys.stdin.readline()", "code_tokens": "def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )", "docstring_tokens": "Generator for reading from standard input in nonblocking mode .", "label": 0}, {"idx": "cosqa-train-2408", "doc": "python garbage collector how to delete unnecessary", "code": "def detach_all(self):\n        \"\"\"\n        Detach from all tracked classes and objects.\n        Restore the original constructors and cleanse the tracking lists.\n        \"\"\"\n        self.detach_all_classes()\n        self.objects.clear()\n        self.index.clear()\n        self._keepalive[:] = []", "code_tokens": "def detach_all ( self ) : self . detach_all_classes ( ) self . objects . clear ( ) self . index . clear ( ) self . _keepalive [ : ] = [ ]", "docstring_tokens": "Detach from all tracked classes and objects . Restore the original constructors and cleanse the tracking lists .", "label": 1}, {"idx": "cosqa-train-2409", "doc": "conver list to dictionary python", "code": "def list2dict(lst):\n    \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"\n\n    dic = {}\n    for k,v in lst: dic[k] = v\n    return dic", "code_tokens": "def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic", "docstring_tokens": "Takes a list of ( key value ) pairs and turns it into a dict .", "label": 0}, {"idx": "cosqa-train-2410", "doc": "python generat descrupt hash", "code": "def double_sha256(data):\n    \"\"\"A standard compound hash.\"\"\"\n    return bytes_as_revhex(hashlib.sha256(hashlib.sha256(data).digest()).digest())", "code_tokens": "def double_sha256 ( data ) : return bytes_as_revhex ( hashlib . sha256 ( hashlib . sha256 ( data ) . digest ( ) ) . digest ( ) )", "docstring_tokens": "A standard compound hash .", "label": 0}, {"idx": "cosqa-train-2411", "doc": "conver python 2 to python3", "code": "def command_py2to3(args):\n    \"\"\"\n    Apply '2to3' tool (Python2 to Python3 conversion tool) to Python sources.\n    \"\"\"\n    from lib2to3.main import main\n    sys.exit(main(\"lib2to3.fixes\", args=args.sources))", "code_tokens": "def command_py2to3 ( args ) : from lib2to3 . main import main sys . exit ( main ( \"lib2to3.fixes\" , args = args . sources ) )", "docstring_tokens": "Apply 2to3 tool ( Python2 to Python3 conversion tool ) to Python sources .", "label": 0}, {"idx": "cosqa-train-2412", "doc": "python generate a range of dates", "code": "def daterange(start_date, end_date):\n    \"\"\"\n    Yield one date per day from starting date to ending date.\n\n    Args:\n        start_date (date): starting date.\n        end_date (date): ending date.\n\n    Yields:\n        date: a date for each day within the range.\n    \"\"\"\n    for n in range(int((end_date - start_date).days)):\n        yield start_date + timedelta(n)", "code_tokens": "def daterange ( start_date , end_date ) : for n in range ( int ( ( end_date - start_date ) . days ) ) : yield start_date + timedelta ( n )", "docstring_tokens": "Yield one date per day from starting date to ending date .", "label": 0}, {"idx": "cosqa-train-2413", "doc": "convering string to float in python", "code": "def energy_string_to_float( string ):\n    \"\"\"\n    Convert a string of a calculation energy, e.g. '-1.2345 eV' to a float.\n\n    Args:\n        string (str): The string to convert.\n  \n    Return\n        (float) \n    \"\"\"\n    energy_re = re.compile( \"(-?\\d+\\.\\d+)\" )\n    return float( energy_re.match( string ).group(0) )", "code_tokens": "def energy_string_to_float ( string ) : energy_re = re . compile ( \"(-?\\d+\\.\\d+)\" ) return float ( energy_re . match ( string ) . group ( 0 ) )", "docstring_tokens": "Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float .", "label": 0}, {"idx": "cosqa-train-2414", "doc": "python generate html report jinja", "code": "def render(template=None, ostr=None, **kwargs):\n    \"\"\"Generate report from a campaign\n\n    :param template: Jinja template to use, ``DEFAULT_TEMPLATE`` is used\n    if not specified\n    :param ostr: output file or filename. Default is standard output\n    \"\"\"\n    jinja_environment.filters['texscape'] = tex_escape\n    template = template or DEFAULT_TEMPLATE\n    ostr = ostr or sys.stdout\n    jinja_template = jinja_environment.get_template(template)\n    jinja_template.stream(**kwargs).dump(ostr)", "code_tokens": "def render ( template = None , ostr = None , * * kwargs ) : jinja_environment . filters [ 'texscape' ] = tex_escape template = template or DEFAULT_TEMPLATE ostr = ostr or sys . stdout jinja_template = jinja_environment . get_template ( template ) jinja_template . stream ( * * kwargs ) . dump ( ostr )", "docstring_tokens": "Generate report from a campaign", "label": 0}, {"idx": "cosqa-train-2415", "doc": "convertblack and white image to booleans python", "code": "def abs_img(img):\n    \"\"\" Return an image with the binarised version of the data of `img`.\"\"\"\n    bool_img = np.abs(read_img(img).get_data())\n    return bool_img.astype(int)", "code_tokens": "def abs_img ( img ) : bool_img = np . abs ( read_img ( img ) . get_data ( ) ) return bool_img . astype ( int )", "docstring_tokens": "Return an image with the binarised version of the data of img .", "label": 1}, {"idx": "cosqa-train-2416", "doc": "python get a date from a string", "code": "def _read_date_from_string(str1):\n    \"\"\"\n    Reads the date from a string in the format YYYY/MM/DD and returns\n    :class: datetime.date\n    \"\"\"\n    full_date = [int(x) for x in str1.split('/')]\n    return datetime.date(full_date[0], full_date[1], full_date[2])", "code_tokens": "def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )", "docstring_tokens": "Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date", "label": 0}, {"idx": "cosqa-train-2417", "doc": "convolve grid with gaussian python", "code": "def convolve_gaussian_2d(image, gaussian_kernel_1d):\n    \"\"\"Convolve 2d gaussian.\"\"\"\n    result = scipy.ndimage.filters.correlate1d(\n        image, gaussian_kernel_1d, axis=0)\n    result = scipy.ndimage.filters.correlate1d(\n        result, gaussian_kernel_1d, axis=1)\n    return result", "code_tokens": "def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result", "docstring_tokens": "Convolve 2d gaussian .", "label": 0}, {"idx": "cosqa-train-2418", "doc": "python get a file from remote host", "code": "def get_remote_content(filepath):\n        \"\"\" A handy wrapper to get a remote file content \"\"\"\n        with hide('running'):\n            temp = BytesIO()\n            get(filepath, temp)\n            content = temp.getvalue().decode('utf-8')\n        return content.strip()", "code_tokens": "def get_remote_content ( filepath ) : with hide ( 'running' ) : temp = BytesIO ( ) get ( filepath , temp ) content = temp . getvalue ( ) . decode ( 'utf-8' ) return content . strip ( )", "docstring_tokens": "A handy wrapper to get a remote file content", "label": 0}, {"idx": "cosqa-train-2419", "doc": "copy slice of list in python", "code": "def Slice(a, begin, size):\n    \"\"\"\n    Slicing op.\n    \"\"\"\n    return np.copy(a)[[slice(*tpl) for tpl in zip(begin, begin+size)]],", "code_tokens": "def Slice ( a , begin , size ) : return np . copy ( a ) [ [ slice ( * tpl ) for tpl in zip ( begin , begin + size ) ] ] ,", "docstring_tokens": "Slicing op .", "label": 1}, {"idx": "cosqa-train-2420", "doc": "python get a list item by name", "code": "def get_by(self, name):\n    \"\"\"get element by name\"\"\"\n    return next((item for item in self if item.name == name), None)", "code_tokens": "def get_by ( self , name ) : return next ( ( item for item in self if item . name == name ) , None )", "docstring_tokens": "get element by name", "label": 0}, {"idx": "cosqa-train-2421", "doc": "cosine distance between vectors python ten", "code": "def angle(x, y):\n    \"\"\"Return the angle between vectors a and b in degrees.\"\"\"\n    return arccos(dot(x, y)/(norm(x)*norm(y)))*180./pi", "code_tokens": "def angle ( x , y ) : return arccos ( dot ( x , y ) / ( norm ( x ) * norm ( y ) ) ) * 180. / pi", "docstring_tokens": "Return the angle between vectors a and b in degrees .", "label": 0}, {"idx": "cosqa-train-2422", "doc": "python get all fields from object", "code": "def object_as_dict(obj):\n    \"\"\"Turn an SQLAlchemy model into a dict of field names and values.\n\n    Based on https://stackoverflow.com/a/37350445/1579058\n    \"\"\"\n    return {c.key: getattr(obj, c.key)\n            for c in inspect(obj).mapper.column_attrs}", "code_tokens": "def object_as_dict ( obj ) : return { c . key : getattr ( obj , c . key ) for c in inspect ( obj ) . mapper . column_attrs }", "docstring_tokens": "Turn an SQLAlchemy model into a dict of field names and values .", "label": 0}, {"idx": "cosqa-train-2423", "doc": "cosine similarity vectors python", "code": "def similarity(self, other):\n        \"\"\"Calculates the cosine similarity between this vector and another\n        vector.\"\"\"\n        if self.magnitude == 0 or other.magnitude == 0:\n            return 0\n\n        return self.dot(other) / self.magnitude", "code_tokens": "def similarity ( self , other ) : if self . magnitude == 0 or other . magnitude == 0 : return 0 return self . dot ( other ) / self . magnitude", "docstring_tokens": "Calculates the cosine similarity between this vector and another vector .", "label": 0}, {"idx": "cosqa-train-2424", "doc": "python get all followers in twitter by twitter api #tweepy", "code": "def twitter_timeline(screen_name, since_id=None):\n    \"\"\" Return relevant twitter timeline \"\"\"\n    consumer_key = twitter_credential('consumer_key')\n    consumer_secret = twitter_credential('consumer_secret')\n    access_token = twitter_credential('access_token')\n    access_token_secret = twitter_credential('access_secret')\n    auth = tweepy.OAuthHandler(consumer_key, consumer_secret)\n    auth.set_access_token(access_token, access_token_secret)\n    api = tweepy.API(auth)\n    return get_all_tweets(screen_name, api, since_id)", "code_tokens": "def twitter_timeline ( screen_name , since_id = None ) : consumer_key = twitter_credential ( 'consumer_key' ) consumer_secret = twitter_credential ( 'consumer_secret' ) access_token = twitter_credential ( 'access_token' ) access_token_secret = twitter_credential ( 'access_secret' ) auth = tweepy . OAuthHandler ( consumer_key , consumer_secret ) auth . set_access_token ( access_token , access_token_secret ) api = tweepy . API ( auth ) return get_all_tweets ( screen_name , api , since_id )", "docstring_tokens": "Return relevant twitter timeline", "label": 0}, {"idx": "cosqa-train-2425", "doc": "count complete tree nodes python", "code": "def size(self):\n        \"\"\"\n        Recursively find size of a tree. Slow.\n        \"\"\"\n\n        if self is NULL:\n            return 0\n        return 1 + self.left.size() + self.right.size()", "code_tokens": "def size ( self ) : if self is NULL : return 0 return 1 + self . left . size ( ) + self . right . size ( )", "docstring_tokens": "Recursively find size of a tree . Slow .", "label": 1}, {"idx": "cosqa-train-2426", "doc": "python get all unique strings in list", "code": "def uniq(seq):\n    \"\"\" Return a copy of seq without duplicates. \"\"\"\n    seen = set()\n    return [x for x in seq if str(x) not in seen and not seen.add(str(x))]", "code_tokens": "def uniq ( seq ) : seen = set ( ) return [ x for x in seq if str ( x ) not in seen and not seen . add ( str ( x ) ) ]", "docstring_tokens": "Return a copy of seq without duplicates .", "label": 0}, {"idx": "cosqa-train-2427", "doc": "count function foe binary treee python", "code": "def size(self):\n        \"\"\"\n        Recursively find size of a tree. Slow.\n        \"\"\"\n\n        if self is NULL:\n            return 0\n        return 1 + self.left.size() + self.right.size()", "code_tokens": "def size ( self ) : if self is NULL : return 0 return 1 + self . left . size ( ) + self . right . size ( )", "docstring_tokens": "Recursively find size of a tree . Slow .", "label": 1}, {"idx": "cosqa-train-2428", "doc": "python get appdata directory", "code": "def data_directory():\n    \"\"\"Return the absolute path to the directory containing the package data.\"\"\"\n    package_directory = os.path.abspath(os.path.dirname(__file__))\n    return os.path.join(package_directory, \"data\")", "code_tokens": "def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , \"data\" )", "docstring_tokens": "Return the absolute path to the directory containing the package data .", "label": 1}, {"idx": "cosqa-train-2429", "doc": "count number of nodes in each subtree python", "code": "def num_leaves(tree):\n    \"\"\"Determine the number of leaves in a tree\"\"\"\n    if tree.is_leaf:\n        return 1\n    else:\n        return num_leaves(tree.left_child) + num_leaves(tree.right_child)", "code_tokens": "def num_leaves ( tree ) : if tree . is_leaf : return 1 else : return num_leaves ( tree . left_child ) + num_leaves ( tree . right_child )", "docstring_tokens": "Determine the number of leaves in a tree", "label": 1}, {"idx": "cosqa-train-2430", "doc": "python get args for a called function", "code": "def get_Callable_args_res(clb):\n    \"\"\"Python version independent function to obtain the parameters\n    of a typing.Callable object. Returns as tuple: args, result.\n    Tested with CPython 2.7, 3.5, 3.6 and Jython 2.7.1.\n    \"\"\"\n    try:\n        return clb.__args__, clb.__result__\n    except AttributeError:\n        # Python 3.6\n        return clb.__args__[:-1], clb.__args__[-1]", "code_tokens": "def get_Callable_args_res ( clb ) : try : return clb . __args__ , clb . __result__ except AttributeError : # Python 3.6 return clb . __args__ [ : - 1 ] , clb . __args__ [ - 1 ]", "docstring_tokens": "Python version independent function to obtain the parameters of a typing . Callable object . Returns as tuple : args result . Tested with CPython 2 . 7 3 . 5 3 . 6 and Jython 2 . 7 . 1 .", "label": 0}, {"idx": "cosqa-train-2431", "doc": "count number of unique values in list python", "code": "def count_list(the_list):\n    \"\"\"\n    Generates a count of the number of times each unique item appears in a list\n    \"\"\"\n    count = the_list.count\n    result = [(item, count(item)) for item in set(the_list)]\n    result.sort()\n    return result", "code_tokens": "def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result", "docstring_tokens": "Generates a count of the number of times each unique item appears in a list", "label": 0}, {"idx": "cosqa-train-2432", "doc": "python get column name of max value", "code": "def get_max(qs, field):\n    \"\"\"\n    get max for queryset.\n\n    qs: queryset\n    field: The field name to max.\n    \"\"\"\n    max_field = '%s__max' % field\n    num = qs.aggregate(Max(field))[max_field]\n    return num if num else 0", "code_tokens": "def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0", "docstring_tokens": "get max for queryset .", "label": 1}, {"idx": "cosqa-train-2433", "doc": "count numbers of nan in python numpy", "code": "def count_rows_with_nans(X):\n    \"\"\"Count the number of rows in 2D arrays that contain any nan values.\"\"\"\n    if X.ndim == 2:\n        return np.where(np.isnan(X).sum(axis=1) != 0, 1, 0).sum()", "code_tokens": "def count_rows_with_nans ( X ) : if X . ndim == 2 : return np . where ( np . isnan ( X ) . sum ( axis = 1 ) != 0 , 1 , 0 ) . sum ( )", "docstring_tokens": "Count the number of rows in 2D arrays that contain any nan values .", "label": 0}, {"idx": "cosqa-train-2434", "doc": "python get cosine similarity between 0 and 1", "code": "def similarity(self, other):\n        \"\"\"Calculates the cosine similarity between this vector and another\n        vector.\"\"\"\n        if self.magnitude == 0 or other.magnitude == 0:\n            return 0\n\n        return self.dot(other) / self.magnitude", "code_tokens": "def similarity ( self , other ) : if self . magnitude == 0 or other . magnitude == 0 : return 0 return self . dot ( other ) / self . magnitude", "docstring_tokens": "Calculates the cosine similarity between this vector and another vector .", "label": 0}, {"idx": "cosqa-train-2435", "doc": "count the depth of recursion in python", "code": "def min_depth(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if root is None:\n        return 0\n    if root.left is not None or root.right is not None:\n        return max(self.minDepth(root.left), self.minDepth(root.right))+1\n    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1", "code_tokens": "def min_depth ( self , root ) : if root is None : return 0 if root . left is not None or root . right is not None : return max ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1 return min ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1", "docstring_tokens": ": type root : TreeNode : rtype : int", "label": 0}, {"idx": "cosqa-train-2436", "doc": "count the frequency of each letter in a string python", "code": "def entropy(string):\n    \"\"\"Compute entropy on the string\"\"\"\n    p, lns = Counter(string), float(len(string))\n    return -sum(count/lns * math.log(count/lns, 2) for count in p.values())", "code_tokens": "def entropy ( string ) : p , lns = Counter ( string ) , float ( len ( string ) ) return - sum ( count / lns * math . log ( count / lns , 2 ) for count in p . values ( ) )", "docstring_tokens": "Compute entropy on the string", "label": 0}, {"idx": "cosqa-train-2437", "doc": "python get df column names as list", "code": "def _get_str_columns(sf):\n    \"\"\"\n    Returns a list of names of columns that are string type.\n    \"\"\"\n    return [name for name in sf.column_names() if sf[name].dtype == str]", "code_tokens": "def _get_str_columns ( sf ) : return [ name for name in sf . column_names ( ) if sf [ name ] . dtype == str ]", "docstring_tokens": "Returns a list of names of columns that are string type .", "label": 0}, {"idx": "cosqa-train-2438", "doc": "count white space in python", "code": "def _count_leading_whitespace(text):\n  \"\"\"Returns the number of characters at the beginning of text that are whitespace.\"\"\"\n  idx = 0\n  for idx, char in enumerate(text):\n    if not char.isspace():\n      return idx\n  return idx + 1", "code_tokens": "def _count_leading_whitespace ( text ) : idx = 0 for idx , char in enumerate ( text ) : if not char . isspace ( ) : return idx return idx + 1", "docstring_tokens": "Returns the number of characters at the beginning of text that are whitespace .", "label": 0}, {"idx": "cosqa-train-2439", "doc": "python get digits from int without str", "code": "def str2int(string_with_int):\n    \"\"\" Collect digits from a string \"\"\"\n    return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)", "code_tokens": "def str2int ( string_with_int ) : return int ( \"\" . join ( [ char for char in string_with_int if char in string . digits ] ) or 0 )", "docstring_tokens": "Collect digits from a string", "label": 0}, {"idx": "cosqa-train-2440", "doc": "covert str to bytes in python", "code": "def str2bytes(x):\n  \"\"\"Convert input argument to bytes\"\"\"\n  if type(x) is bytes:\n    return x\n  elif type(x) is str:\n    return bytes([ ord(i) for i in x ])\n  else:\n    return str2bytes(str(x))", "code_tokens": "def str2bytes ( x ) : if type ( x ) is bytes : return x elif type ( x ) is str : return bytes ( [ ord ( i ) for i in x ] ) else : return str2bytes ( str ( x ) )", "docstring_tokens": "Convert input argument to bytes", "label": 0}, {"idx": "cosqa-train-2441", "doc": "python get dimensions from web image", "code": "def get_image_dimension(self, url):\n        \"\"\"\n        Return a tuple that contains (width, height)\n        Pass in a url to an image and find out its size without loading the whole file\n        If the image wxh could not be found, the tuple will contain `None` values\n        \"\"\"\n        w_h = (None, None)\n        try:\n            if url.startswith('//'):\n                url = 'http:' + url\n            data = requests.get(url).content\n            im = Image.open(BytesIO(data))\n\n            w_h = im.size\n        except Exception:\n            logger.warning(\"Error getting image size {}\".format(url), exc_info=True)\n\n        return w_h", "code_tokens": "def get_image_dimension ( self , url ) : w_h = ( None , None ) try : if url . startswith ( '//' ) : url = 'http:' + url data = requests . get ( url ) . content im = Image . open ( BytesIO ( data ) ) w_h = im . size except Exception : logger . warning ( \"Error getting image size {}\" . format ( url ) , exc_info = True ) return w_h", "docstring_tokens": "Return a tuple that contains ( width height ) Pass in a url to an image and find out its size without loading the whole file If the image wxh could not be found the tuple will contain None values", "label": 0}, {"idx": "cosqa-train-2442", "doc": "create a 3x3 identity matrix in python", "code": "def ident():\n    \"\"\"\n    This routine returns the 3x3 identity matrix.\n\n    http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ident_c.html\n\n    :return: The 3x3 identity matrix.\n    :rtype: 3x3-Element Array of floats\n    \"\"\"\n    matrix = stypes.emptyDoubleMatrix()\n    libspice.ident_c(matrix)\n    return stypes.cMatrixToNumpy(matrix)", "code_tokens": "def ident ( ) : matrix = stypes . emptyDoubleMatrix ( ) libspice . ident_c ( matrix ) return stypes . cMatrixToNumpy ( matrix )", "docstring_tokens": "This routine returns the 3x3 identity matrix .", "label": 0}, {"idx": "cosqa-train-2443", "doc": "python get directory modification time", "code": "def dir_modtime(dpath):\n    \"\"\"\n    Returns the latest modification time of all files/subdirectories in a\n    directory\n    \"\"\"\n    return max(os.path.getmtime(d) for d, _, _ in os.walk(dpath))", "code_tokens": "def dir_modtime ( dpath ) : return max ( os . path . getmtime ( d ) for d , _ , _ in os . walk ( dpath ) )", "docstring_tokens": "Returns the latest modification time of all files / subdirectories in a directory", "label": 1}, {"idx": "cosqa-train-2444", "doc": "create a data frame in python and display first 5 rows", "code": "def head_and_tail_print(self, n=5):\n        \"\"\"Display the first and last n elements of a DataFrame.\"\"\"\n        from IPython import display\n        display.display(display.HTML(self._head_and_tail_table(n)))", "code_tokens": "def head_and_tail_print ( self , n = 5 ) : from IPython import display display . display ( display . HTML ( self . _head_and_tail_table ( n ) ) )", "docstring_tokens": "Display the first and last n elements of a DataFrame .", "label": 0}, {"idx": "cosqa-train-2445", "doc": "python get epoch milis from datetime", "code": "def _dt_to_epoch(dt):\n        \"\"\"Convert datetime to epoch seconds.\"\"\"\n        try:\n            epoch = dt.timestamp()\n        except AttributeError:  # py2\n            epoch = (dt - datetime(1970, 1, 1)).total_seconds()\n        return epoch", "code_tokens": "def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch", "docstring_tokens": "Convert datetime to epoch seconds .", "label": 1}, {"idx": "cosqa-train-2446", "doc": "create an algorithm that will count the number of letters in a given string python", "code": "def entropy(string):\n    \"\"\"Compute entropy on the string\"\"\"\n    p, lns = Counter(string), float(len(string))\n    return -sum(count/lns * math.log(count/lns, 2) for count in p.values())", "code_tokens": "def entropy ( string ) : p , lns = Counter ( string ) , float ( len ( string ) ) return - sum ( count / lns * math . log ( count / lns , 2 ) for count in p . values ( ) )", "docstring_tokens": "Compute entropy on the string", "label": 0}, {"idx": "cosqa-train-2447", "doc": "python get file's parent directory", "code": "def get_parent_dir(name):\n    \"\"\"Get the parent directory of a filename.\"\"\"\n    parent_dir = os.path.dirname(os.path.dirname(name))\n    if parent_dir:\n        return parent_dir\n    return os.path.abspath('.')", "code_tokens": "def get_parent_dir ( name ) : parent_dir = os . path . dirname ( os . path . dirname ( name ) ) if parent_dir : return parent_dir return os . path . abspath ( '.' )", "docstring_tokens": "Get the parent directory of a filename .", "label": 1}, {"idx": "cosqa-train-2448", "doc": "create an inner join python", "code": "def merge(left, right, how='inner', key=None, left_key=None, right_key=None,\n          left_as='left', right_as='right'):\n    \"\"\" Performs a join using the union join function. \"\"\"\n    return join(left, right, how, key, left_key, right_key,\n                join_fn=make_union_join(left_as, right_as))", "code_tokens": "def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "docstring_tokens": "Performs a join using the union join function .", "label": 0}, {"idx": "cosqa-train-2449", "doc": "python get first element from list quickly", "code": "def findfirst(f, coll):\n    \"\"\"Return first occurrence matching f, otherwise None\"\"\"\n    result = list(dropwhile(f, coll))\n    return result[0] if result else None", "code_tokens": "def findfirst ( f , coll ) : result = list ( dropwhile ( f , coll ) ) return result [ 0 ] if result else None", "docstring_tokens": "Return first occurrence matching f otherwise None", "label": 0}, {"idx": "cosqa-train-2450", "doc": "create concave polygon from given points in python", "code": "def polyline(*points):\n    \"\"\"Converts a list of points to a Path composed of lines connecting those \n    points (i.e. a linear spline or polyline).  See also `polygon()`.\"\"\"\n    return Path(*[Line(points[i], points[i+1])\n                  for i in range(len(points) - 1)])", "code_tokens": "def polyline ( * points ) : return Path ( * [ Line ( points [ i ] , points [ i + 1 ] ) for i in range ( len ( points ) - 1 ) ] )", "docstring_tokens": "Converts a list of points to a Path composed of lines connecting those points ( i . e . a linear spline or polyline ) . See also polygon () .", "label": 0}, {"idx": "cosqa-train-2451", "doc": "python get first n items from iterator", "code": "def split_every(n, iterable):\n    \"\"\"Returns a generator that spits an iteratable into n-sized chunks. The last chunk may have\n    less than n elements.\n\n    See http://stackoverflow.com/a/22919323/503377.\"\"\"\n    items = iter(iterable)\n    return itertools.takewhile(bool, (list(itertools.islice(items, n)) for _ in itertools.count()))", "code_tokens": "def split_every ( n , iterable ) : items = iter ( iterable ) return itertools . takewhile ( bool , ( list ( itertools . islice ( items , n ) ) for _ in itertools . count ( ) ) )", "docstring_tokens": "Returns a generator that spits an iteratable into n - sized chunks . The last chunk may have less than n elements .", "label": 0}, {"idx": "cosqa-train-2452", "doc": "create dictionary with list of lists of tuples are values python", "code": "def list2dict(list_of_options):\n    \"\"\"Transforms a list of 2 element tuples to a dictionary\"\"\"\n    d = {}\n    for key, value in list_of_options:\n        d[key] = value\n    return d", "code_tokens": "def list2dict ( list_of_options ) : d = { } for key , value in list_of_options : d [ key ] = value return d", "docstring_tokens": "Transforms a list of 2 element tuples to a dictionary", "label": 0}, {"idx": "cosqa-train-2453", "doc": "python get frequncy from fft", "code": "def fft_freqs(n_fft, fs):\n    \"\"\"Return frequencies for DFT\n\n    Parameters\n    ----------\n    n_fft : int\n        Number of points in the FFT.\n    fs : float\n        The sampling rate.\n    \"\"\"\n    return np.arange(0, (n_fft // 2 + 1)) / float(n_fft) * float(fs)", "code_tokens": "def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )", "docstring_tokens": "Return frequencies for DFT", "label": 0}, {"idx": "cosqa-train-2454", "doc": "create iterables from list in python", "code": "def concat(cls, iterables):\n    \"\"\"\n    Similar to #itertools.chain.from_iterable().\n    \"\"\"\n\n    def generator():\n      for it in iterables:\n        for element in it:\n          yield element\n    return cls(generator())", "code_tokens": "def concat ( cls , iterables ) : def generator ( ) : for it in iterables : for element in it : yield element return cls ( generator ( ) )", "docstring_tokens": "Similar to #itertools . chain . from_iterable () .", "label": 1}, {"idx": "cosqa-train-2455", "doc": "python get function name", "code": "def get_func_name(func):\n    \"\"\"Return a name which includes the module name and function name.\"\"\"\n    func_name = getattr(func, '__name__', func.__class__.__name__)\n    module_name = func.__module__\n\n    if module_name is not None:\n        module_name = func.__module__\n        return '{}.{}'.format(module_name, func_name)\n\n    return func_name", "code_tokens": "def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name", "docstring_tokens": "Return a name which includes the module name and function name .", "label": 0}, {"idx": "cosqa-train-2456", "doc": "create many symbols python sympy", "code": "def symbol_pos_int(*args, **kwargs):\n    \"\"\"Create a sympy.Symbol with positive and integer assumptions.\"\"\"\n    kwargs.update({'positive': True,\n                   'integer': True})\n    return sympy.Symbol(*args, **kwargs)", "code_tokens": "def symbol_pos_int ( * args , * * kwargs ) : kwargs . update ( { 'positive' : True , 'integer' : True } ) return sympy . Symbol ( * args , * * kwargs )", "docstring_tokens": "Create a sympy . Symbol with positive and integer assumptions .", "label": 0}, {"idx": "cosqa-train-2457", "doc": "python get git branch name", "code": "def get_git_branch(git_path='git'):\n    \"\"\"Returns the name of the current git branch\n    \"\"\"\n    branch_match = call((git_path, 'rev-parse', '--symbolic-full-name', 'HEAD'))\n    if branch_match == \"HEAD\":\n        return None\n    else:\n        return os.path.basename(branch_match)", "code_tokens": "def get_git_branch ( git_path = 'git' ) : branch_match = call ( ( git_path , 'rev-parse' , '--symbolic-full-name' , 'HEAD' ) ) if branch_match == \"HEAD\" : return None else : return os . path . basename ( branch_match )", "docstring_tokens": "Returns the name of the current git branch", "label": 1}, {"idx": "cosqa-train-2458", "doc": "create numpy array from list python", "code": "def _to_array(value):\n    \"\"\"As a convenience, turn Python lists and tuples into NumPy arrays.\"\"\"\n    if isinstance(value, (tuple, list)):\n        return array(value)\n    elif isinstance(value, (float, int)):\n        return np.float64(value)\n    else:\n        return value", "code_tokens": "def _to_array ( value ) : if isinstance ( value , ( tuple , list ) ) : return array ( value ) elif isinstance ( value , ( float , int ) ) : return np . float64 ( value ) else : return value", "docstring_tokens": "As a convenience turn Python lists and tuples into NumPy arrays .", "label": 0}, {"idx": "cosqa-train-2459", "doc": "python get global varibles", "code": "def getvariable(name):\n    \"\"\"Get the value of a local variable somewhere in the call stack.\"\"\"\n    import inspect\n    fr = inspect.currentframe()\n    try:\n        while fr:\n            fr = fr.f_back\n            vars = fr.f_locals\n            if name in vars:\n                return vars[name]\n    except:\n        pass\n    return None", "code_tokens": "def getvariable ( name ) : import inspect fr = inspect . currentframe ( ) try : while fr : fr = fr . f_back vars = fr . f_locals if name in vars : return vars [ name ] except : pass return None", "docstring_tokens": "Get the value of a local variable somewhere in the call stack .", "label": 0}, {"idx": "cosqa-train-2460", "doc": "create one hot values for input lenght python", "code": "def one_hot(x, size, dtype=np.float32):\n  \"\"\"Make a n+1 dim one-hot array from n dim int-categorical array.\"\"\"\n  return np.array(x[..., np.newaxis] == np.arange(size), dtype)", "code_tokens": "def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )", "docstring_tokens": "Make a n + 1 dim one - hot array from n dim int - categorical array .", "label": 0}, {"idx": "cosqa-train-2461", "doc": "python get image from a url and save as", "code": "def url_to_image(url):\n    \"\"\"\n    Fetch an image from url and convert it into a Pillow Image object\n    \"\"\"\n    r = requests.get(url)\n    image = StringIO(r.content)\n    return image", "code_tokens": "def url_to_image ( url ) : r = requests . get ( url ) image = StringIO ( r . content ) return image", "docstring_tokens": "Fetch an image from url and convert it into a Pillow Image object", "label": 0}, {"idx": "cosqa-train-2462", "doc": "create python api fucntion that takes params url", "code": "def home():\n    \"\"\"Temporary helper function to link to the API routes\"\"\"\n    return dict(links=dict(api='{}{}'.format(request.url, PREFIX[1:]))), \\\n        HTTPStatus.OK", "code_tokens": "def home ( ) : return dict ( links = dict ( api = '{}{}' . format ( request . url , PREFIX [ 1 : ] ) ) ) , HTTPStatus . OK", "docstring_tokens": "Temporary helper function to link to the API routes", "label": 0}, {"idx": "cosqa-train-2463", "doc": "python get key form value", "code": "def get(key, default=None):\n    \"\"\" return the key from the request\n    \"\"\"\n    data = get_form() or get_query_string()\n    return data.get(key, default)", "code_tokens": "def get ( key , default = None ) : data = get_form ( ) or get_query_string ( ) return data . get ( key , default )", "docstring_tokens": "return the key from the request", "label": 0}, {"idx": "cosqa-train-2464", "doc": "create python docstring site", "code": "def debug_src(src, pm=False, globs=None):\n    \"\"\"Debug a single doctest docstring, in argument `src`'\"\"\"\n    testsrc = script_from_examples(src)\n    debug_script(testsrc, pm, globs)", "code_tokens": "def debug_src ( src , pm = False , globs = None ) : testsrc = script_from_examples ( src ) debug_script ( testsrc , pm , globs )", "docstring_tokens": "Debug a single doctest docstring in argument src", "label": 0}, {"idx": "cosqa-train-2465", "doc": "python get len of two dimentional array", "code": "def difference(ydata1, ydata2):\n    \"\"\"\n\n    Returns the number you should add to ydata1 to make it line up with ydata2\n\n    \"\"\"\n\n    y1 = _n.array(ydata1)\n    y2 = _n.array(ydata2)\n\n    return(sum(y2-y1)/len(ydata1))", "code_tokens": "def difference ( ydata1 , ydata2 ) : y1 = _n . array ( ydata1 ) y2 = _n . array ( ydata2 ) return ( sum ( y2 - y1 ) / len ( ydata1 ) )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-2466", "doc": "create rdd using parallelize python", "code": "def to_simple_rdd(sc, features, labels):\n    \"\"\"Convert numpy arrays of features and labels into\n    an RDD of pairs.\n\n    :param sc: Spark context\n    :param features: numpy array with features\n    :param labels: numpy array with labels\n    :return: Spark RDD with feature-label pairs\n    \"\"\"\n    pairs = [(x, y) for x, y in zip(features, labels)]\n    return sc.parallelize(pairs)", "code_tokens": "def to_simple_rdd ( sc , features , labels ) : pairs = [ ( x , y ) for x , y in zip ( features , labels ) ] return sc . parallelize ( pairs )", "docstring_tokens": "Convert numpy arrays of features and labels into an RDD of pairs .", "label": 0}, {"idx": "cosqa-train-2467", "doc": "python get list of devices on home network", "code": "def get_available_gpus():\n  \"\"\"\n  Returns a list of string names of all available GPUs\n  \"\"\"\n  local_device_protos = device_lib.list_local_devices()\n  return [x.name for x in local_device_protos if x.device_type == 'GPU']", "code_tokens": "def get_available_gpus ( ) : local_device_protos = device_lib . list_local_devices ( ) return [ x . name for x in local_device_protos if x . device_type == 'GPU' ]", "docstring_tokens": "Returns a list of string names of all available GPUs", "label": 0}, {"idx": "cosqa-train-2468", "doc": "python get list of keys on an object", "code": "def get_keys_from_class(cc):\n    \"\"\"Return list of the key property names for a class \"\"\"\n    return [prop.name for prop in cc.properties.values() \\\n            if 'key' in prop.qualifiers]", "code_tokens": "def get_keys_from_class ( cc ) : return [ prop . name for prop in cc . properties . values ( ) if 'key' in prop . qualifiers ]", "docstring_tokens": "Return list of the key property names for a class", "label": 1}, {"idx": "cosqa-train-2469", "doc": "creating a convolution function in python", "code": "def conv_block(inputs, filters, dilation_rates_and_kernel_sizes, **kwargs):\n  \"\"\"A block of standard 2d convolutions.\"\"\"\n  return conv_block_internal(conv, inputs, filters,\n                             dilation_rates_and_kernel_sizes, **kwargs)", "code_tokens": "def conv_block ( inputs , filters , dilation_rates_and_kernel_sizes , * * kwargs ) : return conv_block_internal ( conv , inputs , filters , dilation_rates_and_kernel_sizes , * * kwargs )", "docstring_tokens": "A block of standard 2d convolutions .", "label": 0}, {"idx": "cosqa-train-2470", "doc": "python get locals for stack frame", "code": "def extract_module_locals(depth=0):\n    \"\"\"Returns (module, locals) of the funciton `depth` frames away from the caller\"\"\"\n    f = sys._getframe(depth + 1)\n    global_ns = f.f_globals\n    module = sys.modules[global_ns['__name__']]\n    return (module, f.f_locals)", "code_tokens": "def extract_module_locals ( depth = 0 ) : f = sys . _getframe ( depth + 1 ) global_ns = f . f_globals module = sys . modules [ global_ns [ '__name__' ] ] return ( module , f . f_locals )", "docstring_tokens": "Returns ( module locals ) of the funciton depth frames away from the caller", "label": 0}, {"idx": "cosqa-train-2471", "doc": "creating a sequence of points python", "code": "def debug(sequence):\n    \"\"\"\n    adds information to the sequence for better debugging, currently only\n    an index property on each point in the sequence.\n    \"\"\"\n    points = []\n    for i, p in enumerate(sequence):\n        copy = Point(p)\n        copy['index'] = i\n        points.append(copy)\n    return sequence.__class__(points)", "code_tokens": "def debug ( sequence ) : points = [ ] for i , p in enumerate ( sequence ) : copy = Point ( p ) copy [ 'index' ] = i points . append ( copy ) return sequence . __class__ ( points )", "docstring_tokens": "adds information to the sequence for better debugging currently only an index property on each point in the sequence .", "label": 1}, {"idx": "cosqa-train-2472", "doc": "python get md5 hash file", "code": "def get_file_md5sum(path):\n    \"\"\"Calculate the MD5 hash for a file.\"\"\"\n    with open(path, 'rb') as fh:\n        h = str(hashlib.md5(fh.read()).hexdigest())\n    return h", "code_tokens": "def get_file_md5sum ( path ) : with open ( path , 'rb' ) as fh : h = str ( hashlib . md5 ( fh . read ( ) ) . hexdigest ( ) ) return h", "docstring_tokens": "Calculate the MD5 hash for a file .", "label": 0}, {"idx": "cosqa-train-2473", "doc": "creating voronoi polygons in python", "code": "def voronoi(data, line_color=None, line_width=2, f_tooltip=None, cmap=None, max_area=1e4, alpha=220):\n    \"\"\"\n    Draw the voronoi tesselation of the points\n\n    :param data: data access object\n    :param line_color: line color\n    :param line_width: line width\n    :param f_tooltip: function to generate a tooltip on mouseover\n    :param cmap: color map\n    :param max_area: scaling constant to determine the color of the voronoi areas\n    :param alpha: color alpha\n    \"\"\"\n    from geoplotlib.layers import VoronoiLayer\n    _global_config.layers.append(VoronoiLayer(data, line_color, line_width, f_tooltip, cmap, max_area, alpha))", "code_tokens": "def voronoi ( data , line_color = None , line_width = 2 , f_tooltip = None , cmap = None , max_area = 1e4 , alpha = 220 ) : from geoplotlib . layers import VoronoiLayer _global_config . layers . append ( VoronoiLayer ( data , line_color , line_width , f_tooltip , cmap , max_area , alpha ) )", "docstring_tokens": "Draw the voronoi tesselation of the points", "label": 0}, {"idx": "cosqa-train-2474", "doc": "python get memory size of all ndarray", "code": "def bytesize(arr):\n    \"\"\"\n    Returns the memory byte size of a Numpy array as an integer.\n    \"\"\"\n    byte_size = np.prod(arr.shape) * np.dtype(arr.dtype).itemsize\n    return byte_size", "code_tokens": "def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size", "docstring_tokens": "Returns the memory byte size of a Numpy array as an integer .", "label": 0}, {"idx": "cosqa-train-2475", "doc": "python get minutes elapsed two datetimes", "code": "def _elapsed_time(begin_time, end_time):\n    \"\"\"Assuming format YYYY-MM-DD hh:mm:ss\n\n    Returns the elapsed time in seconds\n    \"\"\"\n\n    bt = _str2datetime(begin_time)\n    et = _str2datetime(end_time)\n\n    return float((et - bt).seconds)", "code_tokens": "def _elapsed_time ( begin_time , end_time ) : bt = _str2datetime ( begin_time ) et = _str2datetime ( end_time ) return float ( ( et - bt ) . seconds )", "docstring_tokens": "Assuming format YYYY - MM - DD hh : mm : ss", "label": 0}, {"idx": "cosqa-train-2476", "doc": "crrate python list from json data", "code": "def from_json_list(cls, api_client, data):\n        \"\"\"Convert a list of JSON values to a list of models\n        \"\"\"\n        return [cls.from_json(api_client, item) for item in data]", "code_tokens": "def from_json_list ( cls , api_client , data ) : return [ cls . from_json ( api_client , item ) for item in data ]", "docstring_tokens": "Convert a list of JSON values to a list of models", "label": 0}, {"idx": "cosqa-train-2477", "doc": "python get name of a passed variable", "code": "def get_var(self, name):\n        \"\"\" Returns the variable set with the given name.\n        \"\"\"\n        for var in self.vars:\n            if var.name == name:\n                return var\n        else:\n            raise ValueError", "code_tokens": "def get_var ( self , name ) : for var in self . vars : if var . name == name : return var else : raise ValueError", "docstring_tokens": "Returns the variable set with the given name .", "label": 0}, {"idx": "cosqa-train-2478", "doc": "ctype array python initialize with list", "code": "def c_array(ctype, values):\n    \"\"\"Convert a python string to c array.\"\"\"\n    if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype):\n        return (ctype * len(values)).from_buffer_copy(values)\n    return (ctype * len(values))(*values)", "code_tokens": "def c_array ( ctype , values ) : if isinstance ( values , np . ndarray ) and values . dtype . itemsize == ctypes . sizeof ( ctype ) : return ( ctype * len ( values ) ) . from_buffer_copy ( values ) return ( ctype * len ( values ) ) ( * values )", "docstring_tokens": "Convert a python string to c array .", "label": 0}, {"idx": "cosqa-train-2479", "doc": "python get name of current node", "code": "def node__name__(self):\n        \"\"\"Return the name of this node or its class name.\"\"\"\n\n        return self.node.__name__ \\\n            if self.node.__name__ is not None else self.node.__class__.__name__", "code_tokens": "def node__name__ ( self ) : return self . node . __name__ if self . node . __name__ is not None else self . node . __class__ . __name__", "docstring_tokens": "Return the name of this node or its class name .", "label": 0}, {"idx": "cosqa-train-2480", "doc": "ctypes pointer to python variable", "code": "def pointer(self):\n        \"\"\"Get a ctypes void pointer to the memory mapped region.\n\n        :type: ctypes.c_void_p\n        \"\"\"\n        return ctypes.cast(ctypes.pointer(ctypes.c_uint8.from_buffer(self.mapping, 0)), ctypes.c_void_p)", "code_tokens": "def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )", "docstring_tokens": "Get a ctypes void pointer to the memory mapped region .", "label": 0}, {"idx": "cosqa-train-2481", "doc": "python get object attribute by string", "code": "def load_object_by_name(object_name):\n    \"\"\"Load an object from a module by name\"\"\"\n    mod_name, attr = object_name.rsplit('.', 1)\n    mod = import_module(mod_name)\n    return getattr(mod, attr)", "code_tokens": "def load_object_by_name ( object_name ) : mod_name , attr = object_name . rsplit ( '.' , 1 ) mod = import_module ( mod_name ) return getattr ( mod , attr )", "docstring_tokens": "Load an object from a module by name", "label": 0}, {"idx": "cosqa-train-2482", "doc": "ctypes python pointer to iunt", "code": "def pointer(self):\n        \"\"\"Get a ctypes void pointer to the memory mapped region.\n\n        :type: ctypes.c_void_p\n        \"\"\"\n        return ctypes.cast(ctypes.pointer(ctypes.c_uint8.from_buffer(self.mapping, 0)), ctypes.c_void_p)", "code_tokens": "def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )", "docstring_tokens": "Get a ctypes void pointer to the memory mapped region .", "label": 1}, {"idx": "cosqa-train-2483", "doc": "python get objectthat called a function", "code": "def __get__(self, obj, objtype):\n        \"\"\" Support instance methods \"\"\"\n        import functools\n        return functools.partial(self.__call__, obj)", "code_tokens": "def __get__ ( self , obj , objtype ) : import functools return functools . partial ( self . __call__ , obj )", "docstring_tokens": "Support instance methods", "label": 1}, {"idx": "cosqa-train-2484", "doc": "custom exponential fit python", "code": "def exp_fit_fun(x, a, tau, c):\n    \"\"\"Function used to fit the exponential decay.\"\"\"\n    # pylint: disable=invalid-name\n    return a * np.exp(-x / tau) + c", "code_tokens": "def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "docstring_tokens": "Function used to fit the exponential decay .", "label": 0}, {"idx": "cosqa-train-2485", "doc": "python get open file length", "code": "def file_length(file_obj):\n    \"\"\"\n    Returns the length in bytes of a given file object.\n    Necessary because os.fstat only works on real files and not file-like\n    objects. This works on more types of streams, primarily StringIO.\n    \"\"\"\n    file_obj.seek(0, 2)\n    length = file_obj.tell()\n    file_obj.seek(0)\n    return length", "code_tokens": "def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length", "docstring_tokens": "Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO .", "label": 0}, {"idx": "cosqa-train-2486", "doc": "cv2 python image grb2gray", "code": "def gray2bgr(img):\n    \"\"\"Convert a grayscale image to BGR image.\n\n    Args:\n        img (ndarray or str): The input image.\n\n    Returns:\n        ndarray: The converted BGR image.\n    \"\"\"\n    img = img[..., None] if img.ndim == 2 else img\n    out_img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n    return out_img", "code_tokens": "def gray2bgr ( img ) : img = img [ ... , None ] if img . ndim == 2 else img out_img = cv2 . cvtColor ( img , cv2 . COLOR_GRAY2BGR ) return out_img", "docstring_tokens": "Convert a grayscale image to BGR image .", "label": 0}, {"idx": "cosqa-train-2487", "doc": "python get opengl matrix", "code": "def matrix_to_gl(matrix):\n    \"\"\"\n    Convert a numpy row- major homogenous transformation matrix\n    to a flat column- major GLfloat transformation.\n\n    Parameters\n    -------------\n    matrix : (4,4) float\n      Row- major homogenous transform\n\n    Returns\n    -------------\n    glmatrix : (16,) gl.GLfloat\n      Transform in pyglet format\n    \"\"\"\n    matrix = np.asanyarray(matrix, dtype=np.float64)\n    if matrix.shape != (4, 4):\n        raise ValueError('matrix must be (4,4)!')\n\n    # switch to column major and flatten to (16,)\n    column = matrix.T.flatten()\n    # convert to GLfloat\n    glmatrix = (gl.GLfloat * 16)(*column)\n\n    return glmatrix", "code_tokens": "def matrix_to_gl ( matrix ) : matrix = np . asanyarray ( matrix , dtype = np . float64 ) if matrix . shape != ( 4 , 4 ) : raise ValueError ( 'matrix must be (4,4)!' ) # switch to column major and flatten to (16,) column = matrix . T . flatten ( ) # convert to GLfloat glmatrix = ( gl . GLfloat * 16 ) ( * column ) return glmatrix", "docstring_tokens": "Convert a numpy row - major homogenous transformation matrix to a flat column - major GLfloat transformation .", "label": 1}, {"idx": "cosqa-train-2488", "doc": "datetime data type python", "code": "def is_timestamp(instance):\n    \"\"\"Validates data is a timestamp\"\"\"\n    if not isinstance(instance, (int, str)):\n        return True\n    return datetime.fromtimestamp(int(instance))", "code_tokens": "def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )", "docstring_tokens": "Validates data is a timestamp", "label": 1}, {"idx": "cosqa-train-2489", "doc": "python get output of subprocess run", "code": "def check_output(args):\n    \"\"\"Runs command and returns the output as string.\"\"\"\n    log.debug('run: %s', args)\n    out = subprocess.check_output(args=args).decode('utf-8')\n    log.debug('out: %r', out)\n    return out", "code_tokens": "def check_output ( args ) : log . debug ( 'run: %s' , args ) out = subprocess . check_output ( args = args ) . decode ( 'utf-8' ) log . debug ( 'out: %r' , out ) return out", "docstring_tokens": "Runs command and returns the output as string .", "label": 0}, {"idx": "cosqa-train-2490", "doc": "datetime format for elasticsearch python", "code": "def format_timestamp(timestamp):\n        \"\"\"\n        Format the UTC timestamp for Elasticsearch\n        eg. 2014-07-09T08:37:18.000Z\n\n        @see https://docs.python.org/2/library/time.html#time.strftime\n\n        :type timestamp int\n        :rtype: str\n        \"\"\"\n        tz_info = tz.tzutc()\n        return datetime.fromtimestamp(timestamp, tz=tz_info).strftime(\"%Y-%m-%dT%H:%M:%S.000Z\")", "code_tokens": "def format_timestamp ( timestamp ) : tz_info = tz . tzutc ( ) return datetime . fromtimestamp ( timestamp , tz = tz_info ) . strftime ( \"%Y-%m-%dT%H:%M:%S.000Z\" )", "docstring_tokens": "Format the UTC timestamp for Elasticsearch eg . 2014 - 07 - 09T08 : 37 : 18 . 000Z", "label": 1}, {"idx": "cosqa-train-2491", "doc": "python get page text", "code": "def get_page_text(self, page):\n        \"\"\"\n        Downloads and returns the full text of a particular page\n        in the document.\n        \"\"\"\n        url = self.get_page_text_url(page)\n        return self._get_url(url)", "code_tokens": "def get_page_text ( self , page ) : url = self . get_page_text_url ( page ) return self . _get_url ( url )", "docstring_tokens": "Downloads and returns the full text of a particular page in the document .", "label": 0}, {"idx": "cosqa-train-2492", "doc": "datetime get local time zone python", "code": "def localize(dt):\n    \"\"\"Localize a datetime object to local time.\"\"\"\n    if dt.tzinfo is UTC:\n        return (dt + LOCAL_UTC_OFFSET).replace(tzinfo=None)\n    # No TZ info so not going to assume anything, return as-is.\n    return dt", "code_tokens": "def localize ( dt ) : if dt . tzinfo is UTC : return ( dt + LOCAL_UTC_OFFSET ) . replace ( tzinfo = None ) # No TZ info so not going to assume anything, return as-is. return dt", "docstring_tokens": "Localize a datetime object to local time .", "label": 1}, {"idx": "cosqa-train-2493", "doc": "python get parent dir name", "code": "def get_parent_dir(name):\n    \"\"\"Get the parent directory of a filename.\"\"\"\n    parent_dir = os.path.dirname(os.path.dirname(name))\n    if parent_dir:\n        return parent_dir\n    return os.path.abspath('.')", "code_tokens": "def get_parent_dir ( name ) : parent_dir = os . path . dirname ( os . path . dirname ( name ) ) if parent_dir : return parent_dir return os . path . abspath ( '.' )", "docstring_tokens": "Get the parent directory of a filename .", "label": 1}, {"idx": "cosqa-train-2494", "doc": "datetime get utc offset python", "code": "def convert_2_utc(self, datetime_, timezone):\n        \"\"\"convert to datetime to UTC offset.\"\"\"\n\n        datetime_ = self.tz_mapper[timezone].localize(datetime_)\n        return datetime_.astimezone(pytz.UTC)", "code_tokens": "def convert_2_utc ( self , datetime_ , timezone ) : datetime_ = self . tz_mapper [ timezone ] . localize ( datetime_ ) return datetime_ . astimezone ( pytz . UTC )", "docstring_tokens": "convert to datetime to UTC offset .", "label": 0}, {"idx": "cosqa-train-2495", "doc": "python get parent directory of file", "code": "def get_parent_folder_name(file_path):\n    \"\"\"Finds parent folder of file\n\n    :param file_path: path\n    :return: Name of folder container\n    \"\"\"\n    return os.path.split(os.path.split(os.path.abspath(file_path))[0])[-1]", "code_tokens": "def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]", "docstring_tokens": "Finds parent folder of file", "label": 0}, {"idx": "cosqa-train-2496", "doc": "datetime to epoch seconds python", "code": "def _DateToEpoch(date):\n  \"\"\"Converts python datetime to epoch microseconds.\"\"\"\n  tz_zero = datetime.datetime.utcfromtimestamp(0)\n  diff_sec = int((date - tz_zero).total_seconds())\n  return diff_sec * 1000000", "code_tokens": "def _DateToEpoch ( date ) : tz_zero = datetime . datetime . utcfromtimestamp ( 0 ) diff_sec = int ( ( date - tz_zero ) . total_seconds ( ) ) return diff_sec * 1000000", "docstring_tokens": "Converts python datetime to epoch microseconds .", "label": 0}, {"idx": "cosqa-train-2497", "doc": "python get path of file in project", "code": "def read(filename):\n    \"\"\"Read and return `filename` in root dir of project and return string\"\"\"\n    return codecs.open(os.path.join(__DIR__, filename), 'r').read()", "code_tokens": "def read ( filename ) : return codecs . open ( os . path . join ( __DIR__ , filename ) , 'r' ) . read ( )", "docstring_tokens": "Read and return filename in root dir of project and return string", "label": 1}, {"idx": "cosqa-train-2498", "doc": "datetime64[ns, utc] python equivilant in mysql", "code": "def convert_timestamp(timestamp):\n    \"\"\"\n    Converts bokehJS timestamp to datetime64.\n    \"\"\"\n    datetime = dt.datetime.utcfromtimestamp(timestamp/1000.)\n    return np.datetime64(datetime.replace(tzinfo=None))", "code_tokens": "def convert_timestamp ( timestamp ) : datetime = dt . datetime . utcfromtimestamp ( timestamp / 1000. ) return np . datetime64 ( datetime . replace ( tzinfo = None ) )", "docstring_tokens": "Converts bokehJS timestamp to datetime64 .", "label": 1}, {"idx": "cosqa-train-2499", "doc": "python get pathname for font", "code": "def family_directory(fonts):\n  \"\"\"Get the path of font project directory.\"\"\"\n  if fonts:\n    dirname = os.path.dirname(fonts[0])\n    if dirname == '':\n      dirname = '.'\n    return dirname", "code_tokens": "def family_directory ( fonts ) : if fonts : dirname = os . path . dirname ( fonts [ 0 ] ) if dirname == '' : dirname = '.' return dirname", "docstring_tokens": "Get the path of font project directory .", "label": 0}, {"idx": "cosqa-train-2500", "doc": "decode base64 text string in python", "code": "def decode_bytes(string):\n    \"\"\" Decodes a given base64 string into bytes.\n\n    :param str string: The string to decode\n    :return: The decoded bytes\n    :rtype: bytes\n    \"\"\"\n\n    if is_string_type(type(string)):\n        string = bytes(string, \"utf-8\")\n    return base64.decodebytes(string)", "code_tokens": "def decode_bytes ( string ) : if is_string_type ( type ( string ) ) : string = bytes ( string , \"utf-8\" ) return base64 . decodebytes ( string )", "docstring_tokens": "Decodes a given base64 string into bytes .", "label": 1}, {"idx": "cosqa-train-2501", "doc": "python get pdf file properties", "code": "def security(self):\n        \"\"\"Print security object information for a pdf document\"\"\"\n        return {k: v for i in self.pdf.resolvedObjects.items() for k, v in i[1].items()}", "code_tokens": "def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "docstring_tokens": "Print security object information for a pdf document", "label": 0}, {"idx": "cosqa-train-2502", "doc": "decompose a decimal number into binary numbersbin python", "code": "def intToBin(i):\n    \"\"\" Integer to two bytes \"\"\"\n    # devide in two parts (bytes)\n    i1 = i % 256\n    i2 = int(i / 256)\n    # make string (little endian)\n    return chr(i1) + chr(i2)", "code_tokens": "def intToBin ( i ) : # devide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return chr ( i1 ) + chr ( i2 )", "docstring_tokens": "Integer to two bytes", "label": 0}, {"idx": "cosqa-train-2503", "doc": "python get percentage of scrollbars for edge", "code": "def p(self):\n        \"\"\"\n        Helper property containing the percentage this slider is \"filled\".\n        \n        This property is read-only.\n        \"\"\"\n        return (self.n-self.nmin)/max((self.nmax-self.nmin),1)", "code_tokens": "def p ( self ) : return ( self . n - self . nmin ) / max ( ( self . nmax - self . nmin ) , 1 )", "docstring_tokens": "Helper property containing the percentage this slider is filled . This property is read - only .", "label": 0}, {"idx": "cosqa-train-2504", "doc": "define list python dynmic boolean values", "code": "def isbinary(*args):\n    \"\"\"Checks if value can be part of binary/bitwise operations.\"\"\"\n    return all(map(lambda c: isnumber(c) or isbool(c), args))", "code_tokens": "def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )", "docstring_tokens": "Checks if value can be part of binary / bitwise operations .", "label": 0}, {"idx": "cosqa-train-2505", "doc": "python get pre decorated function", "code": "def extra_funcs(*funcs):\n  \"\"\"Decorator which adds extra functions to be downloaded to the pyboard.\"\"\"\n  def extra_funcs_decorator(real_func):\n    def wrapper(*args, **kwargs):\n      return real_func(*args, **kwargs)\n    wrapper.extra_funcs = list(funcs)\n    wrapper.source = inspect.getsource(real_func)\n    wrapper.name = real_func.__name__\n    return wrapper\n  return extra_funcs_decorator", "code_tokens": "def extra_funcs ( * funcs ) : def extra_funcs_decorator ( real_func ) : def wrapper ( * args , * * kwargs ) : return real_func ( * args , * * kwargs ) wrapper . extra_funcs = list ( funcs ) wrapper . source = inspect . getsource ( real_func ) wrapper . name = real_func . __name__ return wrapper return extra_funcs_decorator", "docstring_tokens": "Decorator which adds extra functions to be downloaded to the pyboard .", "label": 0}, {"idx": "cosqa-train-2506", "doc": "defining dictionary from a csv file in python", "code": "def csv_to_dicts(file, header=None):\n    \"\"\"Reads a csv and returns a List of Dicts with keys given by header row.\"\"\"\n    with open(file) as csvfile:\n        return [row for row in csv.DictReader(csvfile, fieldnames=header)]", "code_tokens": "def csv_to_dicts ( file , header = None ) : with open ( file ) as csvfile : return [ row for row in csv . DictReader ( csvfile , fieldnames = header ) ]", "docstring_tokens": "Reads a csv and returns a List of Dicts with keys given by header row .", "label": 0}, {"idx": "cosqa-train-2507", "doc": "python get process's network usage", "code": "def current_memory_usage():\n    \"\"\"\n    Returns this programs current memory usage in bytes\n    \"\"\"\n    import psutil\n    proc = psutil.Process(os.getpid())\n    #meminfo = proc.get_memory_info()\n    meminfo = proc.memory_info()\n    rss = meminfo[0]  # Resident Set Size / Mem Usage\n    vms = meminfo[1]  # Virtual Memory Size / VM Size  # NOQA\n    return rss", "code_tokens": "def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss", "docstring_tokens": "Returns this programs current memory usage in bytes", "label": 0}, {"idx": "cosqa-train-2508", "doc": "degree of similarity between strings python", "code": "def basic_word_sim(word1, word2):\n    \"\"\"\n    Simple measure of similarity: Number of letters in common / max length\n    \"\"\"\n    return sum([1 for c in word1 if c in word2]) / max(len(word1), len(word2))", "code_tokens": "def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )", "docstring_tokens": "Simple measure of similarity : Number of letters in common / max length", "label": 0}, {"idx": "cosqa-train-2509", "doc": "python get ram usage in kb", "code": "def current_memory_usage():\n    \"\"\"\n    Returns this programs current memory usage in bytes\n    \"\"\"\n    import psutil\n    proc = psutil.Process(os.getpid())\n    #meminfo = proc.get_memory_info()\n    meminfo = proc.memory_info()\n    rss = meminfo[0]  # Resident Set Size / Mem Usage\n    vms = meminfo[1]  # Virtual Memory Size / VM Size  # NOQA\n    return rss", "code_tokens": "def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss", "docstring_tokens": "Returns this programs current memory usage in bytes", "label": 1}, {"idx": "cosqa-train-2510", "doc": "delete a json key in python", "code": "def remove(parent, idx):\n  \"\"\"Remove a value from a dict.\"\"\"\n  if isinstance(parent, dict):\n    del parent[idx]\n  elif isinstance(parent, list):\n    del parent[int(idx)]\n  else:\n    raise JSONPathError(\"Invalid path for operation\")", "code_tokens": "def remove ( parent , idx ) : if isinstance ( parent , dict ) : del parent [ idx ] elif isinstance ( parent , list ) : del parent [ int ( idx ) ] else : raise JSONPathError ( \"Invalid path for operation\" )", "docstring_tokens": "Remove a value from a dict .", "label": 0}, {"idx": "cosqa-train-2511", "doc": "python get rid of duplicates in a list", "code": "def unique(list):\n    \"\"\" Returns a copy of the list without duplicates.\n    \"\"\"\n    unique = []; [unique.append(x) for x in list if x not in unique]\n    return unique", "code_tokens": "def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique", "docstring_tokens": "Returns a copy of the list without duplicates .", "label": 0}, {"idx": "cosqa-train-2512", "doc": "delete none value form dictionary python3", "code": "def purge_dict(idict):\n    \"\"\"Remove null items from a dictionary \"\"\"\n    odict = {}\n    for key, val in idict.items():\n        if is_null(val):\n            continue\n        odict[key] = val\n    return odict", "code_tokens": "def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict", "docstring_tokens": "Remove null items from a dictionary", "label": 0}, {"idx": "cosqa-train-2513", "doc": "python get samples from wave file", "code": "def readwav(filename):\n    \"\"\"Read a WAV file and returns the data and sample rate\n\n    ::\n\n        from spectrum.io import readwav\n        readwav()\n\n    \"\"\"\n    from scipy.io.wavfile import read as readwav\n    samplerate, signal = readwav(filename)\n    return signal, samplerate", "code_tokens": "def readwav ( filename ) : from scipy . io . wavfile import read as readwav samplerate , signal = readwav ( filename ) return signal , samplerate", "docstring_tokens": "Read a WAV file and returns the data and sample rate", "label": 1}, {"idx": "cosqa-train-2514", "doc": "delete variables in python from memory", "code": "def invalidate_cache(cpu, address, size):\n        \"\"\" remove decoded instruction from instruction cache \"\"\"\n        cache = cpu.instruction_cache\n        for offset in range(size):\n            if address + offset in cache:\n                del cache[address + offset]", "code_tokens": "def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]", "docstring_tokens": "remove decoded instruction from instruction cache", "label": 0}, {"idx": "cosqa-train-2515", "doc": "python get second value form tuple", "code": "def option2tuple(opt):\n    \"\"\"Return a tuple of option, taking possible presence of level into account\"\"\"\n\n    if isinstance(opt[0], int):\n        tup = opt[1], opt[2:]\n    else:\n        tup = opt[0], opt[1:]\n\n    return tup", "code_tokens": "def option2tuple ( opt ) : if isinstance ( opt [ 0 ] , int ) : tup = opt [ 1 ] , opt [ 2 : ] else : tup = opt [ 0 ] , opt [ 1 : ] return tup", "docstring_tokens": "Return a tuple of option taking possible presence of level into account", "label": 0}, {"idx": "cosqa-train-2516", "doc": "deleting duplicate eelements in list python", "code": "def remove_list_duplicates(lista, unique=False):\n    \"\"\"\n    Remove duplicated elements in a list.\n    Args:\n        lista: List with elements to clean duplicates.\n    \"\"\"\n    result = []\n    allready = []\n\n    for elem in lista:\n        if elem not in result:\n            result.append(elem)\n        else:\n            allready.append(elem)\n\n    if unique:\n        for elem in allready:\n            result = list(filter((elem).__ne__, result))\n\n    return result", "code_tokens": "def remove_list_duplicates ( lista , unique = False ) : result = [ ] allready = [ ] for elem in lista : if elem not in result : result . append ( elem ) else : allready . append ( elem ) if unique : for elem in allready : result = list ( filter ( ( elem ) . __ne__ , result ) ) return result", "docstring_tokens": "Remove duplicated elements in a list . Args : lista : List with elements to clean duplicates .", "label": 1}, {"idx": "cosqa-train-2517", "doc": "python get shell output", "code": "def _run_cmd_get_output(cmd):\n    \"\"\"Runs a shell command, returns console output.\n\n    Mimics python3's subprocess.getoutput\n    \"\"\"\n    process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)\n    out, err = process.communicate()\n    return out or err", "code_tokens": "def _run_cmd_get_output ( cmd ) : process = subprocess . Popen ( cmd . split ( ) , stdout = subprocess . PIPE ) out , err = process . communicate ( ) return out or err", "docstring_tokens": "Runs a shell command returns console output .", "label": 0}, {"idx": "cosqa-train-2518", "doc": "deleting files from a folder in python", "code": "def clean_out_dir(directory):\n    \"\"\"\n    Delete all the files and subdirectories in a directory.\n    \"\"\"\n    if not isinstance(directory, path):\n        directory = path(directory)\n    for file_path in directory.files():\n        file_path.remove()\n    for dir_path in directory.dirs():\n        dir_path.rmtree()", "code_tokens": "def clean_out_dir ( directory ) : if not isinstance ( directory , path ) : directory = path ( directory ) for file_path in directory . files ( ) : file_path . remove ( ) for dir_path in directory . dirs ( ) : dir_path . rmtree ( )", "docstring_tokens": "Delete all the files and subdirectories in a directory .", "label": 0}, {"idx": "cosqa-train-2519", "doc": "python get shell width", "code": "def get_width():\n    \"\"\"Get terminal width\"\"\"\n    # Get terminal size\n    ws = struct.pack(\"HHHH\", 0, 0, 0, 0)\n    ws = fcntl.ioctl(sys.stdout.fileno(), termios.TIOCGWINSZ, ws)\n    lines, columns, x, y = struct.unpack(\"HHHH\", ws)\n    width = min(columns * 39 // 40, columns - 2)\n    return width", "code_tokens": "def get_width ( ) : # Get terminal size ws = struct . pack ( \"HHHH\" , 0 , 0 , 0 , 0 ) ws = fcntl . ioctl ( sys . stdout . fileno ( ) , termios . TIOCGWINSZ , ws ) lines , columns , x , y = struct . unpack ( \"HHHH\" , ws ) width = min ( columns * 39 // 40 , columns - 2 ) return width", "docstring_tokens": "Get terminal width", "label": 0}, {"idx": "cosqa-train-2520", "doc": "denormalize normalized array python", "code": "def _normalize_abmn(abmn):\n    \"\"\"return a normalized version of abmn\n    \"\"\"\n    abmn_2d = np.atleast_2d(abmn)\n    abmn_normalized = np.hstack((\n        np.sort(abmn_2d[:, 0:2], axis=1),\n        np.sort(abmn_2d[:, 2:4], axis=1),\n    ))\n    return abmn_normalized", "code_tokens": "def _normalize_abmn ( abmn ) : abmn_2d = np . atleast_2d ( abmn ) abmn_normalized = np . hstack ( ( np . sort ( abmn_2d [ : , 0 : 2 ] , axis = 1 ) , np . sort ( abmn_2d [ : , 2 : 4 ] , axis = 1 ) , ) ) return abmn_normalized", "docstring_tokens": "return a normalized version of abmn", "label": 0}, {"idx": "cosqa-train-2521", "doc": "python get tf holder size", "code": "def size(dtype):\n  \"\"\"Returns the number of bytes to represent this `dtype`.\"\"\"\n  dtype = tf.as_dtype(dtype)\n  if hasattr(dtype, 'size'):\n    return dtype.size\n  return np.dtype(dtype).itemsize", "code_tokens": "def size ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'size' ) : return dtype . size return np . dtype ( dtype ) . itemsize", "docstring_tokens": "Returns the number of bytes to represent this dtype .", "label": 1}, {"idx": "cosqa-train-2522", "doc": "design binary tree in python", "code": "def make_bintree(levels):\n    \"\"\"Make a symmetrical binary tree with @levels\"\"\"\n    G = nx.DiGraph()\n    root = '0'\n    G.add_node(root)\n    add_children(G, root, levels, 2)\n    return G", "code_tokens": "def make_bintree ( levels ) : G = nx . DiGraph ( ) root = '0' G . add_node ( root ) add_children ( G , root , levels , 2 ) return G", "docstring_tokens": "Make a symmetrical binary tree with", "label": 0}, {"idx": "cosqa-train-2523", "doc": "python get the column name of the minimum value", "code": "def index(self, value):\n\t\t\"\"\"\n\t\tReturn the smallest index of the row(s) with this column\n\t\tequal to value.\n\t\t\"\"\"\n\t\tfor i in xrange(len(self.parentNode)):\n\t\t\tif getattr(self.parentNode[i], self.Name) == value:\n\t\t\t\treturn i\n\t\traise ValueError(value)", "code_tokens": "def index ( self , value ) : for i in xrange ( len ( self . parentNode ) ) : if getattr ( self . parentNode [ i ] , self . Name ) == value : return i raise ValueError ( value )", "docstring_tokens": "Return the smallest index of the row ( s ) with this column equal to value .", "label": 0}, {"idx": "cosqa-train-2524", "doc": "design db memory cache python", "code": "def refresh(self, document):\n\t\t\"\"\" Load a new copy of a document from the database.  does not\n\t\t\treplace the old one \"\"\"\n\t\ttry:\n\t\t\told_cache_size = self.cache_size\n\t\t\tself.cache_size = 0\n\t\t\tobj = self.query(type(document)).filter_by(mongo_id=document.mongo_id).one()\n\t\tfinally:\n\t\t\tself.cache_size = old_cache_size\n\t\tself.cache_write(obj)\n\t\treturn obj", "code_tokens": "def refresh ( self , document ) : try : old_cache_size = self . cache_size self . cache_size = 0 obj = self . query ( type ( document ) ) . filter_by ( mongo_id = document . mongo_id ) . one ( ) finally : self . cache_size = old_cache_size self . cache_write ( obj ) return obj", "docstring_tokens": "Load a new copy of a document from the database . does not replace the old one", "label": 1}, {"idx": "cosqa-train-2525", "doc": "python get the item from index", "code": "def __getitem__(self, index):\n    \"\"\"Get the item at the given index.\n\n    Index is a tuple of (row, col)\n    \"\"\"\n    row, col = index\n    return self.rows[row][col]", "code_tokens": "def __getitem__ ( self , index ) : row , col = index return self . rows [ row ] [ col ]", "docstring_tokens": "Get the item at the given index .", "label": 0}, {"idx": "cosqa-train-2526", "doc": "detect screen changes python", "code": "def update_screen(self):\n        \"\"\"Refresh the screen. You don't need to override this except to update only small portins of the screen.\"\"\"\n        self.clock.tick(self.FPS)\n        pygame.display.update()", "code_tokens": "def update_screen ( self ) : self . clock . tick ( self . FPS ) pygame . display . update ( )", "docstring_tokens": "Refresh the screen . You don t need to override this except to update only small portins of the screen .", "label": 0}, {"idx": "cosqa-train-2527", "doc": "python get the length of a file", "code": "def file_length(file_obj):\n    \"\"\"\n    Returns the length in bytes of a given file object.\n    Necessary because os.fstat only works on real files and not file-like\n    objects. This works on more types of streams, primarily StringIO.\n    \"\"\"\n    file_obj.seek(0, 2)\n    length = file_obj.tell()\n    file_obj.seek(0)\n    return length", "code_tokens": "def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length", "docstring_tokens": "Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO .", "label": 1}, {"idx": "cosqa-train-2528", "doc": "determine audio input volume in python", "code": "def calc_volume(self, sample: np.ndarray):\n        \"\"\"Find the RMS of the audio\"\"\"\n        return sqrt(np.mean(np.square(sample)))", "code_tokens": "def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )", "docstring_tokens": "Find the RMS of the audio", "label": 0}, {"idx": "cosqa-train-2529", "doc": "python get the local hostname", "code": "def _get_local_ip(self):\n        \"\"\"Try to determine the local IP address of the machine.\"\"\"\n        try:\n            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n            # Use Google Public DNS server to determine own IP\n            sock.connect(('8.8.8.8', 80))\n\n            return sock.getsockname()[0]\n        except socket.error:\n            try:\n                return socket.gethostbyname(socket.gethostname())\n            except socket.gaierror:\n                return '127.0.0.1'\n        finally:\n            sock.close()", "code_tokens": "def _get_local_ip ( self ) : try : sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) # Use Google Public DNS server to determine own IP sock . connect ( ( '8.8.8.8' , 80 ) ) return sock . getsockname ( ) [ 0 ] except socket . error : try : return socket . gethostbyname ( socket . gethostname ( ) ) except socket . gaierror : return '127.0.0.1' finally : sock . close ( )", "docstring_tokens": "Try to determine the local IP address of the machine .", "label": 0}, {"idx": "cosqa-train-2530", "doc": "python get the location of the script", "code": "def getScriptLocation():\n\t\"\"\"Helper function to get the location of a Python file.\"\"\"\n\tlocation = os.path.abspath(\"./\")\n\tif __file__.rfind(\"/\") != -1:\n\t\tlocation = __file__[:__file__.rfind(\"/\")]\n\treturn location", "code_tokens": "def getScriptLocation ( ) : location = os . path . abspath ( \"./\" ) if __file__ . rfind ( \"/\" ) != - 1 : location = __file__ [ : __file__ . rfind ( \"/\" ) ] return location", "docstring_tokens": "Helper function to get the location of a Python file .", "label": 0}, {"idx": "cosqa-train-2531", "doc": "determine the number of columns in a spreadsheet in python openpyxl", "code": "def series_table_row_offset(self, series):\n        \"\"\"\n        Return the number of rows preceding the data table for *series* in\n        the Excel worksheet.\n        \"\"\"\n        title_and_spacer_rows = series.index * 2\n        data_point_rows = series.data_point_offset\n        return title_and_spacer_rows + data_point_rows", "code_tokens": "def series_table_row_offset ( self , series ) : title_and_spacer_rows = series . index * 2 data_point_rows = series . data_point_offset return title_and_spacer_rows + data_point_rows", "docstring_tokens": "Return the number of rows preceding the data table for * series * in the Excel worksheet .", "label": 0}, {"idx": "cosqa-train-2532", "doc": "develop smart contract in python using flask", "code": "def initialize_api(flask_app):\n    \"\"\"Initialize an API.\"\"\"\n    if not flask_restplus:\n        return\n\n    api = flask_restplus.Api(version=\"1.0\", title=\"My Example API\")\n    api.add_resource(HelloWorld, \"/hello\")\n\n    blueprint = flask.Blueprint(\"api\", __name__, url_prefix=\"/api\")\n    api.init_app(blueprint)\n    flask_app.register_blueprint(blueprint)", "code_tokens": "def initialize_api ( flask_app ) : if not flask_restplus : return api = flask_restplus . Api ( version = \"1.0\" , title = \"My Example API\" ) api . add_resource ( HelloWorld , \"/hello\" ) blueprint = flask . Blueprint ( \"api\" , __name__ , url_prefix = \"/api\" ) api . init_app ( blueprint ) flask_app . register_blueprint ( blueprint )", "docstring_tokens": "Initialize an API .", "label": 0}, {"idx": "cosqa-train-2533", "doc": "python get the object name", "code": "def class_name(obj):\n    \"\"\"\n    Get the name of an object, including the module name if available.\n    \"\"\"\n\n    name = obj.__name__\n    module = getattr(obj, '__module__')\n\n    if module:\n        name = f'{module}.{name}'\n    return name", "code_tokens": "def class_name ( obj ) : name = obj . __name__ module = getattr ( obj , '__module__' ) if module : name = f'{module}.{name}' return name", "docstring_tokens": "Get the name of an object including the module name if available .", "label": 0}, {"idx": "cosqa-train-2534", "doc": "different types of extensions python", "code": "def register_extension_class(ext, base, *args, **kwargs):\n    \"\"\"Instantiate the given extension class and register as a public attribute of the given base.\n\n    README: The expected protocol here is to instantiate the given extension and pass the base\n    object as the first positional argument, then unpack args and kwargs as additional arguments to\n    the extension's constructor.\n    \"\"\"\n    ext_instance = ext.plugin(base, *args, **kwargs)\n    setattr(base, ext.name.lstrip('_'), ext_instance)", "code_tokens": "def register_extension_class ( ext , base , * args , * * kwargs ) : ext_instance = ext . plugin ( base , * args , * * kwargs ) setattr ( base , ext . name . lstrip ( '_' ) , ext_instance )", "docstring_tokens": "Instantiate the given extension class and register as a public attribute of the given base .", "label": 0}, {"idx": "cosqa-train-2535", "doc": "python get timestamp of files in dir", "code": "def dir_modtime(dpath):\n    \"\"\"\n    Returns the latest modification time of all files/subdirectories in a\n    directory\n    \"\"\"\n    return max(os.path.getmtime(d) for d, _, _ in os.walk(dpath))", "code_tokens": "def dir_modtime ( dpath ) : return max ( os . path . getmtime ( d ) for d , _ , _ in os . walk ( dpath ) )", "docstring_tokens": "Returns the latest modification time of all files / subdirectories in a directory", "label": 1}, {"idx": "cosqa-train-2536", "doc": "difne python list size", "code": "def array_dim(arr):\n    \"\"\"Return the size of a multidimansional array.\n    \"\"\"\n    dim = []\n    while True:\n        try:\n            dim.append(len(arr))\n            arr = arr[0]\n        except TypeError:\n            return dim", "code_tokens": "def array_dim ( arr ) : dim = [ ] while True : try : dim . append ( len ( arr ) ) arr = arr [ 0 ] except TypeError : return dim", "docstring_tokens": "Return the size of a multidimansional array .", "label": 0}, {"idx": "cosqa-train-2537", "doc": "python get top post form reddit", "code": "def get_top(self, *args, **kwargs):\n        \"\"\"Return a get_content generator for top submissions.\n\n        Corresponds to the submissions provided by\n        ``https://www.reddit.com/top/`` for the session.\n\n        The additional parameters are passed directly into\n        :meth:`.get_content`. Note: the `url` parameter cannot be altered.\n\n        \"\"\"\n        return self.get_content(self.config['top'], *args, **kwargs)", "code_tokens": "def get_top ( self , * args , * * kwargs ) : return self . get_content ( self . config [ 'top' ] , * args , * * kwargs )", "docstring_tokens": "Return a get_content generator for top submissions .", "label": 0}, {"idx": "cosqa-train-2538", "doc": "dimension check list python", "code": "def _rectangular(n):\n    \"\"\"Checks to see if a 2D list is a valid 2D matrix\"\"\"\n    for i in n:\n        if len(i) != len(n[0]):\n            return False\n    return True", "code_tokens": "def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True", "docstring_tokens": "Checks to see if a 2D list is a valid 2D matrix", "label": 1}, {"idx": "cosqa-train-2539", "doc": "python get url of active browser", "code": "def url(self):\n        \"\"\" The url of this window \"\"\"\n        with switch_window(self._browser, self.name):\n            return self._browser.url", "code_tokens": "def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "docstring_tokens": "The url of this window", "label": 0}, {"idx": "cosqa-train-2540", "doc": "dimension of the array to a variable in python", "code": "def size(self):\n        \"\"\"The size of this parameter, equivalent to self.value.size\"\"\"\n        return np.multiply.reduce(self.shape, dtype=np.int32)", "code_tokens": "def size ( self ) : return np . multiply . reduce ( self . shape , dtype = np . int32 )", "docstring_tokens": "The size of this parameter equivalent to self . value . size", "label": 0}, {"idx": "cosqa-train-2541", "doc": "python get username and password from file", "code": "def read_credentials(fname):\n    \"\"\"\n    read a simple text file from a private location to get\n    username and password\n    \"\"\"\n    with open(fname, 'r') as f:\n        username = f.readline().strip('\\n')\n        password = f.readline().strip('\\n')\n    return username, password", "code_tokens": "def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\\n' ) password = f . readline ( ) . strip ( '\\n' ) return username , password", "docstring_tokens": "read a simple text file from a private location to get username and password", "label": 0}, {"idx": "cosqa-train-2542", "doc": "dimensions of the array python", "code": "def length(self):\n        \"\"\"Array of vector lengths\"\"\"\n        return np.sqrt(np.sum(self**2, axis=1)).view(np.ndarray)", "code_tokens": "def length ( self ) : return np . sqrt ( np . sum ( self ** 2 , axis = 1 ) ) . view ( np . ndarray )", "docstring_tokens": "Array of vector lengths", "label": 0}, {"idx": "cosqa-train-2543", "doc": "python get username by id", "code": "def get_user_by_id(self, id):\n        \"\"\"Retrieve a User object by ID.\"\"\"\n        return self.db_adapter.get_object(self.UserClass, id=id)", "code_tokens": "def get_user_by_id ( self , id ) : return self . db_adapter . get_object ( self . UserClass , id = id )", "docstring_tokens": "Retrieve a User object by ID .", "label": 0}, {"idx": "cosqa-train-2544", "doc": "discord python bot join voice", "code": "async def join(self, ctx, *, channel: discord.VoiceChannel):\n        \"\"\"Joins a voice channel\"\"\"\n\n        if ctx.voice_client is not None:\n            return await ctx.voice_client.move_to(channel)\n\n        await channel.connect()", "code_tokens": "async def join ( self , ctx , * , channel : discord . VoiceChannel ) : if ctx . voice_client is not None : return await ctx . voice_client . move_to ( channel ) await channel . connect ( )", "docstring_tokens": "Joins a voice channel", "label": 0}, {"idx": "cosqa-train-2545", "doc": "python get variable object from name as string", "code": "def load_object_by_name(object_name):\n    \"\"\"Load an object from a module by name\"\"\"\n    mod_name, attr = object_name.rsplit('.', 1)\n    mod = import_module(mod_name)\n    return getattr(mod, attr)", "code_tokens": "def load_object_by_name ( object_name ) : mod_name , attr = object_name . rsplit ( '.' , 1 ) mod = import_module ( mod_name ) return getattr ( mod , attr )", "docstring_tokens": "Load an object from a module by name", "label": 0}, {"idx": "cosqa-train-2546", "doc": "discord python join voice channel;", "code": "async def join(self, ctx, *, channel: discord.VoiceChannel):\n        \"\"\"Joins a voice channel\"\"\"\n\n        if ctx.voice_client is not None:\n            return await ctx.voice_client.move_to(channel)\n\n        await channel.connect()", "code_tokens": "async def join ( self , ctx , * , channel : discord . VoiceChannel ) : if ctx . voice_client is not None : return await ctx . voice_client . move_to ( channel ) await channel . connect ( )", "docstring_tokens": "Joins a voice channel", "label": 0}, {"idx": "cosqa-train-2547", "doc": "python get window position", "code": "def OnMove(self, event):\n        \"\"\"Main window move event\"\"\"\n\n        # Store window position in config\n        position = self.main_window.GetScreenPositionTuple()\n\n        config[\"window_position\"] = repr(position)", "code_tokens": "def OnMove ( self , event ) : # Store window position in config position = self . main_window . GetScreenPositionTuple ( ) config [ \"window_position\" ] = repr ( position )", "docstring_tokens": "Main window move event", "label": 0}, {"idx": "cosqa-train-2548", "doc": "discord python user name change event", "code": "def _handle_chat_name(self, data):\n        \"\"\"Handle user name changes\"\"\"\n\n        self.room.user.nick = data\n        self.conn.enqueue_data(\"user\", self.room.user)", "code_tokens": "def _handle_chat_name ( self , data ) : self . room . user . nick = data self . conn . enqueue_data ( \"user\" , self . room . user )", "docstring_tokens": "Handle user name changes", "label": 0}, {"idx": "cosqa-train-2549", "doc": "python get windows screen resolution", "code": "def size():\n    \"\"\"Determines the height and width of the console window\n\n        Returns:\n            tuple of int: The height in lines, then width in characters\n    \"\"\"\n    try:\n        assert os != 'nt' and sys.stdout.isatty()\n        rows, columns = os.popen('stty size', 'r').read().split()\n    except (AssertionError, AttributeError, ValueError):\n        # in case of failure, use dimensions of a full screen 13\" laptop\n        rows, columns = DEFAULT_HEIGHT, DEFAULT_WIDTH\n\n    return int(rows), int(columns)", "code_tokens": "def size ( ) : try : assert os != 'nt' and sys . stdout . isatty ( ) rows , columns = os . popen ( 'stty size' , 'r' ) . read ( ) . split ( ) except ( AssertionError , AttributeError , ValueError ) : # in case of failure, use dimensions of a full screen 13\" laptop rows , columns = DEFAULT_HEIGHT , DEFAULT_WIDTH return int ( rows ) , int ( columns )", "docstring_tokens": "Determines the height and width of the console window", "label": 0}, {"idx": "cosqa-train-2550", "doc": "display top 2sum in column python", "code": "def table_top_abs(self):\n        \"\"\"Returns the absolute position of table top\"\"\"\n        table_height = np.array([0, 0, self.table_full_size[2]])\n        return string_to_array(self.floor.get(\"pos\")) + table_height", "code_tokens": "def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( \"pos\" ) ) + table_height", "docstring_tokens": "Returns the absolute position of table top", "label": 0}, {"idx": "cosqa-train-2551", "doc": "python get/post with a authtoken", "code": "def auth_request(self, url, headers, body):\n        \"\"\"Perform auth request for token.\"\"\"\n\n        return self.req.post(url, headers, body=body)", "code_tokens": "def auth_request ( self , url , headers , body ) : return self . req . post ( url , headers , body = body )", "docstring_tokens": "Perform auth request for token .", "label": 1}, {"idx": "cosqa-train-2552", "doc": "displaying a png image in a widget using python", "code": "def get_plain_image_as_widget(self):\n        \"\"\"Used for generating thumbnails.  Does not include overlaid\n        graphics.\n        \"\"\"\n        arr = self.getwin_array(order=self.rgb_order)\n        image = self._get_qimage(arr, self.qimg_fmt)\n        return image", "code_tokens": "def get_plain_image_as_widget ( self ) : arr = self . getwin_array ( order = self . rgb_order ) image = self . _get_qimage ( arr , self . qimg_fmt ) return image", "docstring_tokens": "Used for generating thumbnails . Does not include overlaid graphics .", "label": 0}, {"idx": "cosqa-train-2553", "doc": "python getlogger set formal", "code": "def _get_loggers():\n    \"\"\"Return list of Logger classes.\"\"\"\n    from .. import loader\n    modules = loader.get_package_modules('logger')\n    return list(loader.get_plugins(modules, [_Logger]))", "code_tokens": "def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )", "docstring_tokens": "Return list of Logger classes .", "label": 0}, {"idx": "cosqa-train-2554", "doc": "displaying the page number of a pdf with python", "code": "def dimensions(self):\n        \"\"\"Get width and height of a PDF\"\"\"\n        size = self.pdf.getPage(0).mediaBox\n        return {'w': float(size[2]), 'h': float(size[3])}", "code_tokens": "def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "docstring_tokens": "Get width and height of a PDF", "label": 0}, {"idx": "cosqa-train-2555", "doc": "python gevent pool crawler", "code": "def fetch_event(urls):\n    \"\"\"\n    This parallel fetcher uses gevent one uses gevent\n    \"\"\"\n    rs = (grequests.get(u) for u in urls)\n    return [content.json() for content in grequests.map(rs)]", "code_tokens": "def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]", "docstring_tokens": "This parallel fetcher uses gevent one uses gevent", "label": 0}, {"idx": "cosqa-train-2556", "doc": "django create copy of object python", "code": "def copy(self):\n        \"\"\"\n        Creates a copy of model\n        \"\"\"\n        return self.__class__(field_type=self.get_field_type(), data=self.export_data())", "code_tokens": "def copy ( self ) : return self . __class__ ( field_type = self . get_field_type ( ) , data = self . export_data ( ) )", "docstring_tokens": "Creates a copy of model", "label": 1}, {"idx": "cosqa-train-2557", "doc": "python gevent request slow", "code": "def fetch_event(urls):\n    \"\"\"\n    This parallel fetcher uses gevent one uses gevent\n    \"\"\"\n    rs = (grequests.get(u) for u in urls)\n    return [content.json() for content in grequests.map(rs)]", "code_tokens": "def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]", "docstring_tokens": "This parallel fetcher uses gevent one uses gevent", "label": 0}, {"idx": "cosqa-train-2558", "doc": "django distinct values python", "code": "def fast_distinct(self):\n        \"\"\"\n        Because standard distinct used on the all fields are very slow and works only with PostgreSQL database\n        this method provides alternative to the standard distinct method.\n        :return: qs with unique objects\n        \"\"\"\n        return self.model.objects.filter(pk__in=self.values_list('pk', flat=True))", "code_tokens": "def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )", "docstring_tokens": "Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects", "label": 0}, {"idx": "cosqa-train-2559", "doc": "python gif too large", "code": "def ffmpeg_works():\n  \"\"\"Tries to encode images with ffmpeg to check if it works.\"\"\"\n  images = np.zeros((2, 32, 32, 3), dtype=np.uint8)\n  try:\n    _encode_gif(images, 2)\n    return True\n  except (IOError, OSError):\n    return False", "code_tokens": "def ffmpeg_works ( ) : images = np . zeros ( ( 2 , 32 , 32 , 3 ) , dtype = np . uint8 ) try : _encode_gif ( images , 2 ) return True except ( IOError , OSError ) : return False", "docstring_tokens": "Tries to encode images with ffmpeg to check if it works .", "label": 0}, {"idx": "cosqa-train-2560", "doc": "django managepy to run python file", "code": "def managepy(cmd, extra=None):\n    \"\"\"Run manage.py using this component's specific Django settings\"\"\"\n\n    extra = extra.split() if extra else []\n    run_django_cli(['invoke', cmd] + extra)", "code_tokens": "def managepy ( cmd , extra = None ) : extra = extra . split ( ) if extra else [ ] run_django_cli ( [ 'invoke' , cmd ] + extra )", "docstring_tokens": "Run manage . py using this component s specific Django settings", "label": 0}, {"idx": "cosqa-train-2561", "doc": "python git list branches", "code": "def branches(self):\n        \"\"\"All branches in a list\"\"\"\n        result = self.git(self.default + ['branch', '-a', '--no-color'])\n        return [l.strip(' *\\n') for l in result.split('\\n') if l.strip(' *\\n')]", "code_tokens": "def branches ( self ) : result = self . git ( self . default + [ 'branch' , '-a' , '--no-color' ] ) return [ l . strip ( ' *\\n' ) for l in result . split ( '\\n' ) if l . strip ( ' *\\n' ) ]", "docstring_tokens": "All branches in a list", "label": 0}, {"idx": "cosqa-train-2562", "doc": "django python returns object not name", "code": "def get_qualified_name(_object):\n    \"\"\"Return the Fully Qualified Name from an instance or class.\"\"\"\n    module = _object.__module__\n    if hasattr(_object, '__name__'):\n        _class = _object.__name__\n\n    else:\n        _class = _object.__class__.__name__\n\n    return module + '.' + _class", "code_tokens": "def get_qualified_name ( _object ) : module = _object . __module__ if hasattr ( _object , '__name__' ) : _class = _object . __name__ else : _class = _object . __class__ . __name__ return module + '.' + _class", "docstring_tokens": "Return the Fully Qualified Name from an instance or class .", "label": 0}, {"idx": "cosqa-train-2563", "doc": "python given two coordinates get distance azimuth", "code": "def _calculate_distance(latlon1, latlon2):\n    \"\"\"Calculates the distance between two points on earth.\n    \"\"\"\n    lat1, lon1 = latlon1\n    lat2, lon2 = latlon2\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    R = 6371  # radius of the earth in kilometers\n    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * (np.sin(dlon / 2))**2\n    c = 2 * np.pi * R * np.arctan2(np.sqrt(a), np.sqrt(1 - a)) / 180\n    return c", "code_tokens": "def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c", "docstring_tokens": "Calculates the distance between two points on earth .", "label": 0}, {"idx": "cosqa-train-2564", "doc": "django set form data in python", "code": "def __init__(self, form_post_data=None, *args, **kwargs):\n        \"\"\"\n        Overriding init so we can set the post vars like a normal form and generate\n        the form the same way Django does.\n        \"\"\"\n        kwargs.update({'form_post_data': form_post_data})\n        super(MongoModelForm, self).__init__(*args, **kwargs)", "code_tokens": "def __init__ ( self , form_post_data = None , * args , * * kwargs ) : kwargs . update ( { 'form_post_data' : form_post_data } ) super ( MongoModelForm , self ) . __init__ ( * args , * * kwargs )", "docstring_tokens": "Overriding init so we can set the post vars like a normal form and generate the form the same way Django does .", "label": 0}, {"idx": "cosqa-train-2565", "doc": "python grab information from pdf", "code": "def security(self):\n        \"\"\"Print security object information for a pdf document\"\"\"\n        return {k: v for i in self.pdf.resolvedObjects.items() for k, v in i[1].items()}", "code_tokens": "def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "docstring_tokens": "Print security object information for a pdf document", "label": 0}, {"idx": "cosqa-train-2566", "doc": "django template python object to javascript", "code": "def object_to_json(obj, indent=2):\n    \"\"\"\n        transform object to json\n    \"\"\"\n    instance_json = json.dumps(obj, indent=indent, ensure_ascii=False, cls=DjangoJSONEncoder)\n    return instance_json", "code_tokens": "def object_to_json ( obj , indent = 2 ) : instance_json = json . dumps ( obj , indent = indent , ensure_ascii = False , cls = DjangoJSONEncoder ) return instance_json", "docstring_tokens": "transform object to json", "label": 0}, {"idx": "cosqa-train-2567", "doc": "python graphviz output html", "code": "def _text_to_graphiz(self, text):\n        \"\"\"create a graphviz graph from text\"\"\"\n        dot = Source(text, format='svg')\n        return dot.pipe().decode('utf-8')", "code_tokens": "def _text_to_graphiz ( self , text ) : dot = Source ( text , format = 'svg' ) return dot . pipe ( ) . decode ( 'utf-8' )", "docstring_tokens": "create a graphviz graph from text", "label": 0}, {"idx": "cosqa-train-2568", "doc": "do an array with the same value of a scalar python", "code": "def full_like(array, value, dtype=None):\n    \"\"\" Create a shared memory array with the same shape and type as a given array, filled with `value`.\n    \"\"\"\n    shared = empty_like(array, dtype)\n    shared[:] = value\n    return shared", "code_tokens": "def full_like ( array , value , dtype = None ) : shared = empty_like ( array , dtype ) shared [ : ] = value return shared", "docstring_tokens": "Create a shared memory array with the same shape and type as a given array filled with value .", "label": 0}, {"idx": "cosqa-train-2569", "doc": "python grouped calculation for standard deviation", "code": "def weighted_std(values, weights):\n    \"\"\" Calculate standard deviation weighted by errors \"\"\"\n    average = np.average(values, weights=weights)\n    variance = np.average((values-average)**2, weights=weights)\n    return np.sqrt(variance)", "code_tokens": "def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )", "docstring_tokens": "Calculate standard deviation weighted by errors", "label": 0}, {"idx": "cosqa-train-2570", "doc": "do python dictionary keys have to be strings", "code": "def _check_conversion(key, valid_dict):\n    \"\"\"Check for existence of key in dict, return value or raise error\"\"\"\n    if key not in valid_dict and key not in valid_dict.values():\n        # Only show users the nice string values\n        keys = [v for v in valid_dict.keys() if isinstance(v, string_types)]\n        raise ValueError('value must be one of %s, not %s' % (keys, key))\n    return valid_dict[key] if key in valid_dict else key", "code_tokens": "def _check_conversion ( key , valid_dict ) : if key not in valid_dict and key not in valid_dict . values ( ) : # Only show users the nice string values keys = [ v for v in valid_dict . keys ( ) if isinstance ( v , string_types ) ] raise ValueError ( 'value must be one of %s, not %s' % ( keys , key ) ) return valid_dict [ key ] if key in valid_dict else key", "docstring_tokens": "Check for existence of key in dict return value or raise error", "label": 0}, {"idx": "cosqa-train-2571", "doc": "document content docx python", "code": "def fill_document(doc):\n    \"\"\"Add a section, a subsection and some text to the document.\n\n    :param doc: the document\n    :type doc: :class:`pylatex.document.Document` instance\n    \"\"\"\n    with doc.create(Section('A section')):\n        doc.append('Some regular text and some ')\n        doc.append(italic('italic text. '))\n\n        with doc.create(Subsection('A subsection')):\n            doc.append('Also some crazy characters: $&#{}')", "code_tokens": "def fill_document ( doc ) : with doc . create ( Section ( 'A section' ) ) : doc . append ( 'Some regular text and some ' ) doc . append ( italic ( 'italic text. ' ) ) with doc . create ( Subsection ( 'A subsection' ) ) : doc . append ( 'Also some crazy characters: $&#{}' )", "docstring_tokens": "Add a section a subsection and some text to the document .", "label": 0}, {"idx": "cosqa-train-2572", "doc": "python hex to hsv", "code": "def hex_to_hsv(color):\n    \"\"\"\n    Converts from hex to hsv\n\n    Parameters:\n    -----------\n            color : string\n                    Color representation on color\n\n    Example:\n            hex_to_hsv('#ff9933')\n    \"\"\"\n    color = normalize(color)\n    color = color[1:]\n    # color=tuple(ord(c)/255.0 for c in color.decode('hex'))\n    color = (int(color[0:2], base=16) / 255.0, int(color[2:4],\n                                                   base=16) / 255.0, int(color[4:6], base=16) / 255.0)\n    return colorsys.rgb_to_hsv(*color)", "code_tokens": "def hex_to_hsv ( color ) : color = normalize ( color ) color = color [ 1 : ] # color=tuple(ord(c)/255.0 for c in color.decode('hex')) color = ( int ( color [ 0 : 2 ] , base = 16 ) / 255.0 , int ( color [ 2 : 4 ] , base = 16 ) / 255.0 , int ( color [ 4 : 6 ] , base = 16 ) / 255.0 ) return colorsys . rgb_to_hsv ( * color )", "docstring_tokens": "Converts from hex to hsv", "label": 0}, {"idx": "cosqa-train-2573", "doc": "does django under python2 and python3 different", "code": "def polite_string(a_string):\n    \"\"\"Returns a \"proper\" string that should work in both Py3/Py2\"\"\"\n    if is_py3() and hasattr(a_string, 'decode'):\n        try:\n            return a_string.decode('utf-8')\n        except UnicodeDecodeError:\n            return a_string\n\n    return a_string", "code_tokens": "def polite_string ( a_string ) : if is_py3 ( ) and hasattr ( a_string , 'decode' ) : try : return a_string . decode ( 'utf-8' ) except UnicodeDecodeError : return a_string return a_string", "docstring_tokens": "Returns a proper string that should work in both Py3 / Py2", "label": 0}, {"idx": "cosqa-train-2574", "doc": "python how can you tell if a method is async", "code": "def isfunc(x):\n    \"\"\"\n    Returns `True` if the given value is a function or method object.\n\n    Arguments:\n        x (mixed): value to check.\n\n    Returns:\n        bool\n    \"\"\"\n    return any([\n        inspect.isfunction(x) and not asyncio.iscoroutinefunction(x),\n        inspect.ismethod(x) and not asyncio.iscoroutinefunction(x)\n    ])", "code_tokens": "def isfunc ( x ) : return any ( [ inspect . isfunction ( x ) and not asyncio . iscoroutinefunction ( x ) , inspect . ismethod ( x ) and not asyncio . iscoroutinefunction ( x ) ] )", "docstring_tokens": "Returns True if the given value is a function or method object .", "label": 0}, {"idx": "cosqa-train-2575", "doc": "does every python object have repr", "code": "def _get_pretty_string(obj):\n    \"\"\"Return a prettier version of obj\n\n    Parameters\n    ----------\n    obj : object\n        Object to pretty print\n\n    Returns\n    -------\n    s : str\n        Pretty print object repr\n    \"\"\"\n    sio = StringIO()\n    pprint.pprint(obj, stream=sio)\n    return sio.getvalue()", "code_tokens": "def _get_pretty_string ( obj ) : sio = StringIO ( ) pprint . pprint ( obj , stream = sio ) return sio . getvalue ( )", "docstring_tokens": "Return a prettier version of obj", "label": 0}, {"idx": "cosqa-train-2576", "doc": "python how to access self arrgument of one function in another function", "code": "def action(self):\n        \"\"\"\n        This class overrides this method\n        \"\"\"\n        self.return_value = self.function(*self.args, **self.kwargs)", "code_tokens": "def action ( self ) : self . return_value = self . function ( * self . args , * * self . kwargs )", "docstring_tokens": "This class overrides this method", "label": 0}, {"idx": "cosqa-train-2577", "doc": "does http reuesta return a filehandle python", "code": "def _open_url(url):\n    \"\"\"Open a HTTP connection to the URL and return a file-like object.\"\"\"\n    response = requests.get(url, stream=True)\n    if response.status_code != 200:\n        raise IOError(\"Unable to download {}, HTTP {}\".format(url, response.status_code))\n    return response", "code_tokens": "def _open_url ( url ) : response = requests . get ( url , stream = True ) if response . status_code != 200 : raise IOError ( \"Unable to download {}, HTTP {}\" . format ( url , response . status_code ) ) return response", "docstring_tokens": "Open a HTTP connection to the URL and return a file - like object .", "label": 0}, {"idx": "cosqa-train-2578", "doc": "python how to add parent path", "code": "def set_parent_path(self, value):\n        \"\"\"\n        Set the parent path and the path from the new parent path.\n\n        :param value: The path to the object's parent\n        \"\"\"\n\n        self._parent_path = value\n        self.path = value + r'/' + self.name\n        self._update_childrens_parent_path()", "code_tokens": "def set_parent_path ( self , value ) : self . _parent_path = value self . path = value + r'/' + self . name self . _update_childrens_parent_path ( )", "docstring_tokens": "Set the parent path and the path from the new parent path .", "label": 0}, {"idx": "cosqa-train-2579", "doc": "draw a line python", "code": "def hline(self, x, y, width, color):\n        \"\"\"Draw a horizontal line up to a given length.\"\"\"\n        self.rect(x, y, width, 1, color, fill=True)", "code_tokens": "def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )", "docstring_tokens": "Draw a horizontal line up to a given length .", "label": 0}, {"idx": "cosqa-train-2580", "doc": "python how to adjust time for timezone", "code": "def normalize_time(timestamp):\n    \"\"\"Normalize time in arbitrary timezone to UTC naive object.\"\"\"\n    offset = timestamp.utcoffset()\n    if offset is None:\n        return timestamp\n    return timestamp.replace(tzinfo=None) - offset", "code_tokens": "def normalize_time ( timestamp ) : offset = timestamp . utcoffset ( ) if offset is None : return timestamp return timestamp . replace ( tzinfo = None ) - offset", "docstring_tokens": "Normalize time in arbitrary timezone to UTC naive object .", "label": 0}, {"idx": "cosqa-train-2581", "doc": "dynamically get the global constants of a python file", "code": "def _get_all_constants():\n    \"\"\"\n    Get list of all uppercase, non-private globals (doesn't start with ``_``).\n\n    Returns:\n        list: Uppercase names defined in `globals()` (variables from this \\\n              module).\n    \"\"\"\n    return [\n        key for key in globals().keys()\n        if all([\n            not key.startswith(\"_\"),          # publicly accesible\n            key.upper() == key,               # uppercase\n            type(globals()[key]) in _ALLOWED  # and with type from _ALLOWED\n        ])\n    ]", "code_tokens": "def _get_all_constants ( ) : return [ key for key in globals ( ) . keys ( ) if all ( [ not key . startswith ( \"_\" ) , # publicly accesible key . upper ( ) == key , # uppercase type ( globals ( ) [ key ] ) in _ALLOWED # and with type from _ALLOWED ] ) ]", "docstring_tokens": "Get list of all uppercase non - private globals ( doesn t start with _ ) .", "label": 1}, {"idx": "cosqa-train-2582", "doc": "python how to apply linear transform to features", "code": "def inverse_transform(self, X):\n        \"\"\"Undo the scaling of X according to feature_range.\n\n        Note that if truncate is true, any truncated points will not\n        be restored exactly.\n\n        Parameters\n        ----------\n        X : array-like with shape [n_samples, n_features]\n            Input data that will be transformed.\n        \"\"\"\n        X = check_array(X, copy=self.copy)\n        X -= self.min_\n        X /= self.scale_\n        return X", "code_tokens": "def inverse_transform ( self , X ) : X = check_array ( X , copy = self . copy ) X -= self . min_ X /= self . scale_ return X", "docstring_tokens": "Undo the scaling of X according to feature_range .", "label": 0}, {"idx": "cosqa-train-2583", "doc": "dynamically opening serial ports python", "code": "def do_serial(self, p):\n\t\t\"\"\"Set the serial port, e.g.: /dev/tty.usbserial-A4001ib8\"\"\"\n\t\ttry:\n\t\t\tself.serial.port = p\n\t\t\tself.serial.open()\n\t\t\tprint 'Opening serial port: %s' % p\n\t\texcept Exception, e:\n\t\t\tprint 'Unable to open serial port: %s' % p", "code_tokens": "def do_serial ( self , p ) : try : self . serial . port = p self . serial . open ( ) print 'Opening serial port: %s' % p except Exception , e : print 'Unable to open serial port: %s' % p", "docstring_tokens": "Set the serial port e . g . : / dev / tty . usbserial - A4001ib8", "label": 1}, {"idx": "cosqa-train-2584", "doc": "python how to bind window closing event", "code": "def closeEvent(self, e):\n        \"\"\"Qt slot when the window is closed.\"\"\"\n        self.emit('close_widget')\n        super(DockWidget, self).closeEvent(e)", "code_tokens": "def closeEvent ( self , e ) : self . emit ( 'close_widget' ) super ( DockWidget , self ) . closeEvent ( e )", "docstring_tokens": "Qt slot when the window is closed .", "label": 0}, {"idx": "cosqa-train-2585", "doc": "dynamodb delete all items python", "code": "def wipe(self):\n        \"\"\" Wipe the store\n        \"\"\"\n        keys = list(self.keys()).copy()\n        for key in keys:\n            self.delete(key)", "code_tokens": "def wipe ( self ) : keys = list ( self . keys ( ) ) . copy ( ) for key in keys : self . delete ( key )", "docstring_tokens": "Wipe the store", "label": 0}, {"idx": "cosqa-train-2586", "doc": "python how to change datetime to different time zone", "code": "def datetime_to_timezone(date, tz=\"UTC\"):\n    \"\"\" convert naive datetime to timezone-aware datetime \"\"\"\n    if not date.tzinfo:\n        date = date.replace(tzinfo=timezone(get_timezone()))\n    return date.astimezone(timezone(tz))", "code_tokens": "def datetime_to_timezone ( date , tz = \"UTC\" ) : if not date . tzinfo : date = date . replace ( tzinfo = timezone ( get_timezone ( ) ) ) return date . astimezone ( timezone ( tz ) )", "docstring_tokens": "convert naive datetime to timezone - aware datetime", "label": 0}, {"idx": "cosqa-train-2587", "doc": "easy python decompiler invalid pys file", "code": "def disassemble_file(filename, outstream=None):\n    \"\"\"\n    disassemble Python byte-code file (.pyc)\n\n    If given a Python source file (\".py\") file, we'll\n    try to find the corresponding compiled object.\n    \"\"\"\n    filename = check_object_path(filename)\n    (version, timestamp, magic_int, co, is_pypy,\n     source_size) = load_module(filename)\n    if type(co) == list:\n        for con in co:\n            disco(version, con, outstream)\n    else:\n        disco(version, co, outstream, is_pypy=is_pypy)\n    co = None", "code_tokens": "def disassemble_file ( filename , outstream = None ) : filename = check_object_path ( filename ) ( version , timestamp , magic_int , co , is_pypy , source_size ) = load_module ( filename ) if type ( co ) == list : for con in co : disco ( version , con , outstream ) else : disco ( version , co , outstream , is_pypy = is_pypy ) co = None", "docstring_tokens": "disassemble Python byte - code file ( . pyc )", "label": 1}, {"idx": "cosqa-train-2588", "doc": "python how to change key name", "code": "def unit_key_from_name(name):\n  \"\"\"Return a legal python name for the given name for use as a unit key.\"\"\"\n  result = name\n\n  for old, new in six.iteritems(UNIT_KEY_REPLACEMENTS):\n    result = result.replace(old, new)\n\n  # Collapse redundant underscores and convert to uppercase.\n  result = re.sub(r'_+', '_', result.upper())\n\n  return result", "code_tokens": "def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result", "docstring_tokens": "Return a legal python name for the given name for use as a unit key .", "label": 0}, {"idx": "cosqa-train-2589", "doc": "ecef xyz to lat lon alt python", "code": "def geodetic_to_ecef(latitude, longitude, altitude):\n    \"\"\"Convert WGS84 geodetic coordinates into ECEF\n    \n    Parameters\n    ----------\n    latitude : float or array_like\n        Geodetic latitude (degrees)\n    longitude : float or array_like\n        Geodetic longitude (degrees)\n    altitude : float or array_like\n        Geodetic Height (km) above WGS84 reference ellipsoid.\n        \n    Returns\n    -------\n    x, y, z\n        numpy arrays of x, y, z locations in km\n        \n    \"\"\"\n\n\n    ellip = np.sqrt(1. - earth_b ** 2 / earth_a ** 2)\n    r_n = earth_a / np.sqrt(1. - ellip ** 2 * np.sin(np.deg2rad(latitude)) ** 2)\n\n    # colatitude = 90. - latitude\n    x = (r_n + altitude) * np.cos(np.deg2rad(latitude)) * np.cos(np.deg2rad(longitude))\n    y = (r_n + altitude) * np.cos(np.deg2rad(latitude)) * np.sin(np.deg2rad(longitude))\n    z = (r_n * (1. - ellip ** 2) + altitude) * np.sin(np.deg2rad(latitude))\n\n    return x, y, z", "code_tokens": "def geodetic_to_ecef ( latitude , longitude , altitude ) : ellip = np . sqrt ( 1. - earth_b ** 2 / earth_a ** 2 ) r_n = earth_a / np . sqrt ( 1. - ellip ** 2 * np . sin ( np . deg2rad ( latitude ) ) ** 2 ) # colatitude = 90. - latitude x = ( r_n + altitude ) * np . cos ( np . deg2rad ( latitude ) ) * np . cos ( np . deg2rad ( longitude ) ) y = ( r_n + altitude ) * np . cos ( np . deg2rad ( latitude ) ) * np . sin ( np . deg2rad ( longitude ) ) z = ( r_n * ( 1. - ellip ** 2 ) + altitude ) * np . sin ( np . deg2rad ( latitude ) ) return x , y , z", "docstring_tokens": "Convert WGS84 geodetic coordinates into ECEF Parameters ---------- latitude : float or array_like Geodetic latitude ( degrees ) longitude : float or array_like Geodetic longitude ( degrees ) altitude : float or array_like Geodetic Height ( km ) above WGS84 reference ellipsoid . Returns ------- x y z numpy arrays of x y z locations in km", "label": 0}, {"idx": "cosqa-train-2590", "doc": "python how to check datatype", "code": "def make_kind_check(python_types, numpy_kind):\n    \"\"\"\n    Make a function that checks whether a scalar or array is of a given kind\n    (e.g. float, int, datetime, timedelta).\n    \"\"\"\n    def check(value):\n        if hasattr(value, 'dtype'):\n            return value.dtype.kind == numpy_kind\n        return isinstance(value, python_types)\n    return check", "code_tokens": "def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check", "docstring_tokens": "Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) .", "label": 0}, {"idx": "cosqa-train-2591", "doc": "elasticsearch python scroll results lmit", "code": "def scan(client, query=None, scroll='5m', raise_on_error=True,\n         preserve_order=False, size=1000, **kwargs):\n    \"\"\"\n    Simple abstraction on top of the\n    :meth:`~elasticsearch.Elasticsearch.scroll` api - a simple iterator that\n    yields all hits as returned by underlining scroll requests.\n    By default scan does not return results in any pre-determined order. To\n    have a standard order in the returned documents (either by score or\n    explicit sort definition) when scrolling, use ``preserve_order=True``. This\n    may be an expensive operation and will negate the performance benefits of\n    using ``scan``.\n    :arg client: instance of :class:`~elasticsearch.Elasticsearch` to use\n    :arg query: body for the :meth:`~elasticsearch.Elasticsearch.search` api\n    :arg scroll: Specify how long a consistent view of the index should be\n        maintained for scrolled search\n    :arg raise_on_error: raises an exception (``ScanError``) if an error is\n        encountered (some shards fail to execute). By default we raise.\n    :arg preserve_order: don't set the ``search_type`` to ``scan`` - this will\n        cause the scroll to paginate with preserving the order. Note that this\n        can be an extremely expensive operation and can easily lead to\n        unpredictable results, use with caution.\n    :arg size: size (per shard) of the batch send at each iteration.\n    Any additional keyword arguments will be passed to the initial\n    :meth:`~elasticsearch.Elasticsearch.search` call::\n        scan(es,\n            query={\"query\": {\"match\": {\"title\": \"python\"}}},\n            index=\"orders-*\",\n            doc_type=\"books\"\n        )\n    \"\"\"\n    if not preserve_order:\n        kwargs['search_type'] = 'scan'\n    # initial search\n    resp = client.search(body=query, scroll=scroll, size=size, **kwargs)\n\n    scroll_id = resp.get('_scroll_id')\n    if scroll_id is None:\n        return\n\n    first_run = True\n    while True:\n        # if we didn't set search_type to scan initial search contains data\n        if preserve_order and first_run:\n            first_run = False\n        else:\n            resp = client.scroll(scroll_id, scroll=scroll)\n\n        for hit in resp['hits']['hits']:\n            yield hit\n\n        # check if we have any errrors\n        if resp[\"_shards\"][\"failed\"]:\n            logger.warning(\n                'Scroll request has failed on %d shards out of %d.',\n                resp['_shards']['failed'], resp['_shards']['total']\n            )\n            if raise_on_error:\n                raise ScanError(\n                    'Scroll request has failed on %d shards out of %d.' %\n                    (resp['_shards']['failed'], resp['_shards']['total'])\n                )\n\n        scroll_id = resp.get('_scroll_id')\n        # end of scroll\n        if scroll_id is None or not resp['hits']['hits']:\n            break", "code_tokens": "def scan ( client , query = None , scroll = '5m' , raise_on_error = True , preserve_order = False , size = 1000 , * * kwargs ) : if not preserve_order : kwargs [ 'search_type' ] = 'scan' # initial search resp = client . search ( body = query , scroll = scroll , size = size , * * kwargs ) scroll_id = resp . get ( '_scroll_id' ) if scroll_id is None : return first_run = True while True : # if we didn't set search_type to scan initial search contains data if preserve_order and first_run : first_run = False else : resp = client . scroll ( scroll_id , scroll = scroll ) for hit in resp [ 'hits' ] [ 'hits' ] : yield hit # check if we have any errrors if resp [ \"_shards\" ] [ \"failed\" ] : logger . warning ( 'Scroll request has failed on %d shards out of %d.' , resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) if raise_on_error : raise ScanError ( 'Scroll request has failed on %d shards out of %d.' % ( resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) ) scroll_id = resp . get ( '_scroll_id' ) # end of scroll if scroll_id is None or not resp [ 'hits' ] [ 'hits' ] : break", "docstring_tokens": "Simple abstraction on top of the : meth : ~elasticsearch . Elasticsearch . scroll api - a simple iterator that yields all hits as returned by underlining scroll requests . By default scan does not return results in any pre - determined order . To have a standard order in the returned documents ( either by score or explicit sort definition ) when scrolling use preserve_order = True . This may be an expensive operation and will negate the performance benefits of using scan . : arg client : instance of : class : ~elasticsearch . Elasticsearch to use : arg query : body for the : meth : ~elasticsearch . Elasticsearch . search api : arg scroll : Specify how long a consistent view of the index should be maintained for scrolled search : arg raise_on_error : raises an exception ( ScanError ) if an error is encountered ( some shards fail to execute ) . By default we raise . : arg preserve_order : don t set the search_type to scan - this will cause the scroll to paginate with preserving the order . Note that this can be an extremely expensive operation and can easily lead to unpredictable results use with caution . : arg size : size ( per shard ) of the batch send at each iteration . Any additional keyword arguments will be passed to the initial : meth : ~elasticsearch . Elasticsearch . search call :: scan ( es query = { query : { match : { title : python }}} index = orders - * doc_type = books )", "label": 0}, {"idx": "cosqa-train-2592", "doc": "python how to check file size", "code": "def get_file_size(filename):\n    \"\"\"\n    Get the file size of a given file\n\n    :param filename: string: pathname of a file\n    :return: human readable filesize\n    \"\"\"\n    if os.path.isfile(filename):\n        return convert_size(os.path.getsize(filename))\n    return None", "code_tokens": "def get_file_size ( filename ) : if os . path . isfile ( filename ) : return convert_size ( os . path . getsize ( filename ) ) return None", "docstring_tokens": "Get the file size of a given file", "label": 1}, {"idx": "cosqa-train-2593", "doc": "eliminate non alpha in a string in python", "code": "def _to_lower_alpha_only(s):\n    \"\"\"Return a lowercased string with non alphabetic chars removed.\n\n    White spaces are not to be removed.\"\"\"\n    s = re.sub(r'\\n', ' ',  s.lower())\n    return re.sub(r'[^a-z\\s]', '', s)", "code_tokens": "def _to_lower_alpha_only ( s ) : s = re . sub ( r'\\n' , ' ' , s . lower ( ) ) return re . sub ( r'[^a-z\\s]' , '' , s )", "docstring_tokens": "Return a lowercased string with non alphabetic chars removed .", "label": 0}, {"idx": "cosqa-train-2594", "doc": "python how to check if dictionaries are equal", "code": "def is_same_dict(d1, d2):\n    \"\"\"Test two dictionary is equal on values. (ignore order)\n    \"\"\"\n    for k, v in d1.items():\n        if isinstance(v, dict):\n            is_same_dict(v, d2[k])\n        else:\n            assert d1[k] == d2[k]\n\n    for k, v in d2.items():\n        if isinstance(v, dict):\n            is_same_dict(v, d1[k])\n        else:\n            assert d1[k] == d2[k]", "code_tokens": "def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]", "docstring_tokens": "Test two dictionary is equal on values . ( ignore order )", "label": 0}, {"idx": "cosqa-train-2595", "doc": "enerate random numbers python normal distribution", "code": "def rnormal(mu, tau, size=None):\n    \"\"\"\n    Random normal variates.\n    \"\"\"\n    return np.random.normal(mu, 1. / np.sqrt(tau), size)", "code_tokens": "def rnormal ( mu , tau , size = None ) : return np . random . normal ( mu , 1. / np . sqrt ( tau ) , size )", "docstring_tokens": "Random normal variates .", "label": 0}, {"idx": "cosqa-train-2596", "doc": "python how to check regex", "code": "def is_valid_regex(regex):\n    \"\"\"Function for checking a valid regex.\"\"\"\n    if len(regex) == 0:\n        return False\n    try:\n        re.compile(regex)\n        return True\n    except sre_constants.error:\n        return False", "code_tokens": "def is_valid_regex ( regex ) : if len ( regex ) == 0 : return False try : re . compile ( regex ) return True except sre_constants . error : return False", "docstring_tokens": "Function for checking a valid regex .", "label": 1}, {"idx": "cosqa-train-2597", "doc": "ensure python magicmock was called with same dictionary", "code": "def requests_post(url, data=None, json=None, **kwargs):\n    \"\"\"Requests-mock requests.post wrapper.\"\"\"\n    return requests_request('post', url, data=data, json=json, **kwargs)", "code_tokens": "def requests_post ( url , data = None , json = None , * * kwargs ) : return requests_request ( 'post' , url , data = data , json = json , * * kwargs )", "docstring_tokens": "Requests - mock requests . post wrapper .", "label": 0}, {"idx": "cosqa-train-2598", "doc": "python how to check value length", "code": "def check_length(value, length):\n    \"\"\"\n    Checks length of value\n\n    @param value: value to check\n    @type value: C{str}\n\n    @param length: length checking for\n    @type length: C{int}\n\n    @return: None when check successful\n\n    @raise ValueError: check failed\n    \"\"\"\n    _length = len(value)\n    if _length != length:\n        raise ValueError(\"length must be %d, not %d\" % \\\n                         (length, _length))", "code_tokens": "def check_length ( value , length ) : _length = len ( value ) if _length != length : raise ValueError ( \"length must be %d, not %d\" % ( length , _length ) )", "docstring_tokens": "Checks length of value", "label": 0}, {"idx": "cosqa-train-2599", "doc": "epoch time to utc python", "code": "def session_to_epoch(timestamp):\n    \"\"\" converts Synergy Timestamp for session to UTC zone seconds since epoch \"\"\"\n    utc_timetuple = datetime.strptime(timestamp, SYNERGY_SESSION_PATTERN).replace(tzinfo=None).utctimetuple()\n    return calendar.timegm(utc_timetuple)", "code_tokens": "def session_to_epoch ( timestamp ) : utc_timetuple = datetime . strptime ( timestamp , SYNERGY_SESSION_PATTERN ) . replace ( tzinfo = None ) . utctimetuple ( ) return calendar . timegm ( utc_timetuple )", "docstring_tokens": "converts Synergy Timestamp for session to UTC zone seconds since epoch", "label": 0}, {"idx": "cosqa-train-2600", "doc": "python how to check what type a value is", "code": "def is_type(value):\n        \"\"\"Determine if value is an instance or subclass of the class Type.\"\"\"\n        if isinstance(value, type):\n            return issubclass(value, Type)\n        return isinstance(value, Type)", "code_tokens": "def is_type ( value ) : if isinstance ( value , type ) : return issubclass ( value , Type ) return isinstance ( value , Type )", "docstring_tokens": "Determine if value is an instance or subclass of the class Type .", "label": 0}, {"idx": "cosqa-train-2601", "doc": "epoch to utc time python", "code": "def session_to_epoch(timestamp):\n    \"\"\" converts Synergy Timestamp for session to UTC zone seconds since epoch \"\"\"\n    utc_timetuple = datetime.strptime(timestamp, SYNERGY_SESSION_PATTERN).replace(tzinfo=None).utctimetuple()\n    return calendar.timegm(utc_timetuple)", "code_tokens": "def session_to_epoch ( timestamp ) : utc_timetuple = datetime . strptime ( timestamp , SYNERGY_SESSION_PATTERN ) . replace ( tzinfo = None ) . utctimetuple ( ) return calendar . timegm ( utc_timetuple )", "docstring_tokens": "converts Synergy Timestamp for session to UTC zone seconds since epoch", "label": 0}, {"idx": "cosqa-train-2602", "doc": "python how to clear empty spots in a list", "code": "def rm_empty_indices(*args):\n    \"\"\"\n    Remove unwanted list indices. First argument is the list\n    of indices to remove. Other elements are the lists\n    to trim.\n    \"\"\"\n    rm_inds = args[0]\n\n    if not rm_inds:\n        return args[1:]\n\n    keep_inds = [i for i in range(len(args[1])) if i not in rm_inds]\n\n    return [[a[i] for i in keep_inds] for a in args[1:]]", "code_tokens": "def rm_empty_indices ( * args ) : rm_inds = args [ 0 ] if not rm_inds : return args [ 1 : ] keep_inds = [ i for i in range ( len ( args [ 1 ] ) ) if i not in rm_inds ] return [ [ a [ i ] for i in keep_inds ] for a in args [ 1 : ] ]", "docstring_tokens": "Remove unwanted list indices . First argument is the list of indices to remove . Other elements are the lists to trim .", "label": 0}, {"idx": "cosqa-train-2603", "doc": "equation to tell whether two line segments overlap python", "code": "def line_line_collide(line1, line2):\n    \"\"\"Determine if two line segments meet.\n\n    This is a helper for :func:`convex_hull_collide` in the\n    special case that the two convex hulls are actually\n    just line segments. (Even in this case, this is only\n    problematic if both segments are on a single line.)\n\n    Args:\n        line1 (numpy.ndarray): ``2 x 2`` array of start and end nodes.\n        line2 (numpy.ndarray): ``2 x 2`` array of start and end nodes.\n\n    Returns:\n        bool: Indicating if the line segments collide.\n    \"\"\"\n    s, t, success = segment_intersection(\n        line1[:, 0], line1[:, 1], line2[:, 0], line2[:, 1]\n    )\n    if success:\n        return _helpers.in_interval(s, 0.0, 1.0) and _helpers.in_interval(\n            t, 0.0, 1.0\n        )\n\n    else:\n        disjoint, _ = parallel_lines_parameters(\n            line1[:, 0], line1[:, 1], line2[:, 0], line2[:, 1]\n        )\n        return not disjoint", "code_tokens": "def line_line_collide ( line1 , line2 ) : s , t , success = segment_intersection ( line1 [ : , 0 ] , line1 [ : , 1 ] , line2 [ : , 0 ] , line2 [ : , 1 ] ) if success : return _helpers . in_interval ( s , 0.0 , 1.0 ) and _helpers . in_interval ( t , 0.0 , 1.0 ) else : disjoint , _ = parallel_lines_parameters ( line1 [ : , 0 ] , line1 [ : , 1 ] , line2 [ : , 0 ] , line2 [ : , 1 ] ) return not disjoint", "docstring_tokens": "Determine if two line segments meet .", "label": 0}, {"idx": "cosqa-train-2604", "doc": "python how to compare type", "code": "def is_type(value):\n        \"\"\"Determine if value is an instance or subclass of the class Type.\"\"\"\n        if isinstance(value, type):\n            return issubclass(value, Type)\n        return isinstance(value, Type)", "code_tokens": "def is_type ( value ) : if isinstance ( value , type ) : return issubclass ( value , Type ) return isinstance ( value , Type )", "docstring_tokens": "Determine if value is an instance or subclass of the class Type .", "label": 0}, {"idx": "cosqa-train-2605", "doc": "equivalent or not equivalent python", "code": "def hard_equals(a, b):\n    \"\"\"Implements the '===' operator.\"\"\"\n    if type(a) != type(b):\n        return False\n    return a == b", "code_tokens": "def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b", "docstring_tokens": "Implements the === operator .", "label": 1}, {"idx": "cosqa-train-2606", "doc": "python how to construct a n list", "code": "def chunk_list(l, n):\n    \"\"\"Return `n` size lists from a given list `l`\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Return n size lists from a given list l", "label": 0}, {"idx": "cosqa-train-2607", "doc": "escape python % in string", "code": "def _escape(self, s):\n        \"\"\"Escape bad characters for regular expressions.\n\n        Similar to `re.escape` but allows '%' to pass through.\n\n        \"\"\"\n        for ch, r_ch in self.ESCAPE_SETS:\n            s = s.replace(ch, r_ch)\n        return s", "code_tokens": "def _escape ( self , s ) : for ch , r_ch in self . ESCAPE_SETS : s = s . replace ( ch , r_ch ) return s", "docstring_tokens": "Escape bad characters for regular expressions .", "label": 0}, {"idx": "cosqa-train-2608", "doc": "python how to copy a file to theclipboard", "code": "def copy(string, **kwargs):\n    \"\"\"Copy given string into system clipboard.\"\"\"\n    window = Tk()\n    window.withdraw()\n    window.clipboard_clear()\n    window.clipboard_append(string)\n    window.destroy()\n    return", "code_tokens": "def copy ( string , * * kwargs ) : window = Tk ( ) window . withdraw ( ) window . clipboard_clear ( ) window . clipboard_append ( string ) window . destroy ( ) return", "docstring_tokens": "Copy given string into system clipboard .", "label": 0}, {"idx": "cosqa-train-2609", "doc": "escape string for percent sign python", "code": "def quote(s, unsafe='/'):\n    \"\"\"Pass in a dictionary that has unsafe characters as the keys, and the percent\n    encoded value as the value.\"\"\"\n    res = s.replace('%', '%25')\n    for c in unsafe:\n        res = res.replace(c, '%' + (hex(ord(c)).upper())[2:])\n    return res", "code_tokens": "def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res", "docstring_tokens": "Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value .", "label": 1}, {"idx": "cosqa-train-2610", "doc": "python how to def (x,y)", "code": "def __call__(self, xy):\n        \"\"\"Project x and y\"\"\"\n        x, y = xy\n        return (self.x(x), self.y(y))", "code_tokens": "def __call__ ( self , xy ) : x , y = xy return ( self . x ( x ) , self . y ( y ) )", "docstring_tokens": "Project x and y", "label": 0}, {"idx": "cosqa-train-2611", "doc": "exit python memory leak", "code": "def fast_exit(code):\n    \"\"\"Exit without garbage collection, this speeds up exit by about 10ms for\n    things like bash completion.\n    \"\"\"\n    sys.stdout.flush()\n    sys.stderr.flush()\n    os._exit(code)", "code_tokens": "def fast_exit ( code ) : sys . stdout . flush ( ) sys . stderr . flush ( ) os . _exit ( code )", "docstring_tokens": "Exit without garbage collection this speeds up exit by about 10ms for things like bash completion .", "label": 0}, {"idx": "cosqa-train-2612", "doc": "python how to define an bytearray", "code": "def __init__(self, ba=None):\n        \"\"\"Constructor.\"\"\"\n        self.bytearray = ba or (bytearray(b'\\0') * self.SIZEOF)", "code_tokens": "def __init__ ( self , ba = None ) : self . bytearray = ba or ( bytearray ( b'\\0' ) * self . SIZEOF )", "docstring_tokens": "Constructor .", "label": 0}, {"idx": "cosqa-train-2613", "doc": "explicitly specify the path in python", "code": "def relative_path(path):\n    \"\"\"\n    Return the given path relative to this file.\n    \"\"\"\n    return os.path.join(os.path.dirname(__file__), path)", "code_tokens": "def relative_path ( path ) : return os . path . join ( os . path . dirname ( __file__ ) , path )", "docstring_tokens": "Return the given path relative to this file .", "label": 0}, {"idx": "cosqa-train-2614", "doc": "python how to delete a directory", "code": "def safe_rmtree(directory):\n  \"\"\"Delete a directory if it's present. If it's not present, no-op.\"\"\"\n  if os.path.exists(directory):\n    shutil.rmtree(directory, True)", "code_tokens": "def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )", "docstring_tokens": "Delete a directory if it s present . If it s not present no - op .", "label": 0}, {"idx": "cosqa-train-2615", "doc": "exponential moving std in python", "code": "def double_exponential_moving_average(data, period):\n    \"\"\"\n    Double Exponential Moving Average.\n\n    Formula:\n    DEMA = 2*EMA - EMA(EMA)\n    \"\"\"\n    catch_errors.check_for_period_error(data, period)\n\n    dema = (2 * ema(data, period)) - ema(ema(data, period), period)\n    return dema", "code_tokens": "def double_exponential_moving_average ( data , period ) : catch_errors . check_for_period_error ( data , period ) dema = ( 2 * ema ( data , period ) ) - ema ( ema ( data , period ) , period ) return dema", "docstring_tokens": "Double Exponential Moving Average .", "label": 0}, {"idx": "cosqa-train-2616", "doc": "python how to determine a string is a file path or url", "code": "def is_file_url(url):\n    \"\"\"Returns true if the given url is a file url\"\"\"\n    from .misc import to_text\n\n    if not url:\n        return False\n    if not isinstance(url, six.string_types):\n        try:\n            url = getattr(url, \"url\")\n        except AttributeError:\n            raise ValueError(\"Cannot parse url from unknown type: {0!r}\".format(url))\n    url = to_text(url, encoding=\"utf-8\")\n    return urllib_parse.urlparse(url.lower()).scheme == \"file\"", "code_tokens": "def is_file_url ( url ) : from . misc import to_text if not url : return False if not isinstance ( url , six . string_types ) : try : url = getattr ( url , \"url\" ) except AttributeError : raise ValueError ( \"Cannot parse url from unknown type: {0!r}\" . format ( url ) ) url = to_text ( url , encoding = \"utf-8\" ) return urllib_parse . urlparse ( url . lower ( ) ) . scheme == \"file\"", "docstring_tokens": "Returns true if the given url is a file url", "label": 0}, {"idx": "cosqa-train-2617", "doc": "extract images from pdf and save it in different pdf using python", "code": "def save_image(pdf_path, img_path, page_num):\n    \"\"\"\n\n    Creates images for a page of the input pdf document and saves it\n    at img_path.\n\n    :param pdf_path: path to pdf to create images for.\n    :param img_path: path where to save the images.\n    :param page_num: page number to create image from in the pdf file.\n    :return:\n    \"\"\"\n    pdf_img = Image(filename=\"{}[{}]\".format(pdf_path, page_num))\n    with pdf_img.convert(\"png\") as converted:\n        # Set white background.\n        converted.background_color = Color(\"white\")\n        converted.alpha_channel = \"remove\"\n        converted.save(filename=img_path)", "code_tokens": "def save_image ( pdf_path , img_path , page_num ) : pdf_img = Image ( filename = \"{}[{}]\" . format ( pdf_path , page_num ) ) with pdf_img . convert ( \"png\" ) as converted : # Set white background. converted . background_color = Color ( \"white\" ) converted . alpha_channel = \"remove\" converted . save ( filename = img_path )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-2618", "doc": "python how to do enter new line", "code": "def go_to_new_line(self):\n        \"\"\"Go to the end of the current line and create a new line\"\"\"\n        self.stdkey_end(False, False)\n        self.insert_text(self.get_line_separator())", "code_tokens": "def go_to_new_line ( self ) : self . stdkey_end ( False , False ) self . insert_text ( self . get_line_separator ( ) )", "docstring_tokens": "Go to the end of the current line and create a new line", "label": 0}, {"idx": "cosqa-train-2619", "doc": "python how to do next next", "code": "def __next__(self, reward, ask_id, lbl):\n        \"\"\"For Python3 compatibility of generator.\"\"\"\n        return self.next(reward, ask_id, lbl)", "code_tokens": "def __next__ ( self , reward , ask_id , lbl ) : return self . next ( reward , ask_id , lbl )", "docstring_tokens": "For Python3 compatibility of generator .", "label": 0}, {"idx": "cosqa-train-2620", "doc": "python how to download a json file", "code": "def download_json(local_filename, url, clobber=False):\n    \"\"\"Download the given JSON file, and pretty-print before we output it.\"\"\"\n    with open(local_filename, 'w') as json_file:\n        json_file.write(json.dumps(requests.get(url).json(), sort_keys=True, indent=2, separators=(',', ': ')))", "code_tokens": "def download_json ( local_filename , url , clobber = False ) : with open ( local_filename , 'w' ) as json_file : json_file . write ( json . dumps ( requests . get ( url ) . json ( ) , sort_keys = True , indent = 2 , separators = ( ',' , ': ' ) ) )", "docstring_tokens": "Download the given JSON file and pretty - print before we output it .", "label": 0}, {"idx": "cosqa-train-2621", "doc": "faster way to get indices of nan in array, python", "code": "def check_precomputed_distance_matrix(X):\n    \"\"\"Perform check_array(X) after removing infinite values (numpy.inf) from the given distance matrix.\n    \"\"\"\n    tmp = X.copy()\n    tmp[np.isinf(tmp)] = 1\n    check_array(tmp)", "code_tokens": "def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "docstring_tokens": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix .", "label": 0}, {"idx": "cosqa-train-2622", "doc": "python how to exit current directory", "code": "def clean_tmpdir(path):\n    \"\"\"Invoked atexit, this removes our tmpdir\"\"\"\n    if os.path.exists(path) and \\\n       os.path.isdir(path):\n        rmtree(path)", "code_tokens": "def clean_tmpdir ( path ) : if os . path . exists ( path ) and os . path . isdir ( path ) : rmtree ( path )", "docstring_tokens": "Invoked atexit this removes our tmpdir", "label": 0}, {"idx": "cosqa-train-2623", "doc": "fastest way of finding maximum number in a heap python", "code": "def _heappop_max(heap):\n    \"\"\"Maxheap version of a heappop.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup_max(heap, 0)\n        return returnitem\n    return lastelt", "code_tokens": "def _heappop_max ( heap ) : lastelt = heap . pop ( ) # raises appropriate IndexError if heap is empty if heap : returnitem = heap [ 0 ] heap [ 0 ] = lastelt _siftup_max ( heap , 0 ) return returnitem return lastelt", "docstring_tokens": "Maxheap version of a heappop .", "label": 0}, {"idx": "cosqa-train-2624", "doc": "python how to get all object method", "code": "def get_method_names(obj):\n        \"\"\"\n        Gets names of all methods implemented in specified object.\n\n        :param obj: an object to introspect.\n\n        :return: a list with method names.\n        \"\"\"\n        method_names = []\n        \n        for method_name in dir(obj):\n\n            method = getattr(obj, method_name)\n\n            if MethodReflector._is_method(method, method_name):\n                method_names.append(method_name)\n\n        return method_names", "code_tokens": "def get_method_names ( obj ) : method_names = [ ] for method_name in dir ( obj ) : method = getattr ( obj , method_name ) if MethodReflector . _is_method ( method , method_name ) : method_names . append ( method_name ) return method_names", "docstring_tokens": "Gets names of all methods implemented in specified object .", "label": 1}, {"idx": "cosqa-train-2625", "doc": "fastest way to iterate python", "code": "def iterate(obj):\n\t\"\"\"Loop over an iterable and track progress, including first and last state.\n\t\n\tOn each iteration yield an Iteration named tuple with the first and last flags, current element index, total\n\titerable length (if possible to acquire), and value, in that order.\n\t\n\t\tfor iteration in iterate(something):\n\t\t\titeration.value  # Do something.\n\t\n\tYou can unpack these safely:\n\t\n\t\tfor first, last, index, total, value in iterate(something):\n\t\t\tpass\n\t\n\tIf you want to unpack the values you are iterating across, you can by wrapping the nested unpacking in parenthesis:\n\t\n\t\tfor first, last, index, total, (foo, bar, baz) in iterate(something):\n\t\t\tpass\n\t\n\tEven if the length of the iterable can't be reliably determined this function will still capture the \"last\" state\n\tof the final loop iteration.  (Basically: this works with generators.)\n\t\n\tThis process is about 10x slower than simple enumeration on CPython 3.4, so only use it where you actually need to\n\ttrack state.  Use `enumerate()` elsewhere.\n\t\"\"\"\n\t\n\tglobal next, Iteration\n\tnext = next\n\tIteration = Iteration\n\t\n\ttotal = len(obj) if isinstance(obj, Sized) else None\n\titerator = iter(obj)\n\tfirst = True\n\tlast = False\n\ti = 0\n\t\n\ttry:\n\t\tvalue = next(iterator)\n\texcept StopIteration:\n\t\treturn\n\t\n\twhile True:\n\t\ttry:\n\t\t\tnext_value = next(iterator)\n\t\texcept StopIteration:\n\t\t\tlast = True\n\t\t\n\t\tyield Iteration(first, last, i, total, value)\n\t\tif last: return\n\t\t\n\t\tvalue = next_value\n\t\ti += 1\n\t\tfirst = False", "code_tokens": "def iterate ( obj ) : global next , Iteration next = next Iteration = Iteration total = len ( obj ) if isinstance ( obj , Sized ) else None iterator = iter ( obj ) first = True last = False i = 0 try : value = next ( iterator ) except StopIteration : return while True : try : next_value = next ( iterator ) except StopIteration : last = True yield Iteration ( first , last , i , total , value ) if last : return value = next_value i += 1 first = False", "docstring_tokens": "Loop over an iterable and track progress including first and last state . On each iteration yield an Iteration named tuple with the first and last flags current element index total iterable length ( if possible to acquire ) and value in that order . for iteration in iterate ( something ) : iteration . value # Do something . You can unpack these safely : for first last index total value in iterate ( something ) : pass If you want to unpack the values you are iterating across you can by wrapping the nested unpacking in parenthesis : for first last index total ( foo bar baz ) in iterate ( something ) : pass Even if the length of the iterable can t be reliably determined this function will still capture the last state of the final loop iteration . ( Basically : this works with generators . ) This process is about 10x slower than simple enumeration on CPython 3 . 4 so only use it where you actually need to track state . Use enumerate () elsewhere .", "label": 0}, {"idx": "cosqa-train-2626", "doc": "python how to get back current method name", "code": "def get_method_name(method):\n    \"\"\"\n    Returns given method name.\n\n    :param method: Method to retrieve the name.\n    :type method: object\n    :return: Method name.\n    :rtype: unicode\n    \"\"\"\n\n    name = get_object_name(method)\n    if name.startswith(\"__\") and not name.endswith(\"__\"):\n        name = \"_{0}{1}\".format(get_object_name(method.im_class), name)\n    return name", "code_tokens": "def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( \"__\" ) and not name . endswith ( \"__\" ) : name = \"_{0}{1}\" . format ( get_object_name ( method . im_class ) , name ) return name", "docstring_tokens": "Returns given method name .", "label": 0}, {"idx": "cosqa-train-2627", "doc": "features with single value python", "code": "def _select_features(example, feature_list=None):\n  \"\"\"Select a subset of features from the example dict.\"\"\"\n  feature_list = feature_list or [\"inputs\", \"targets\"]\n  return {f: example[f] for f in feature_list}", "code_tokens": "def _select_features ( example , feature_list = None ) : feature_list = feature_list or [ \"inputs\" , \"targets\" ] return { f : example [ f ] for f in feature_list }", "docstring_tokens": "Select a subset of features from the example dict .", "label": 1}, {"idx": "cosqa-train-2628", "doc": "python how to get column type from database views", "code": "def datatype(dbtype, description, cursor):\n    \"\"\"Google AppEngine Helper to convert a data type into a string.\"\"\"\n    dt = cursor.db.introspection.get_field_type(dbtype, description)\n    if type(dt) is tuple:\n        return dt[0]\n    else:\n        return dt", "code_tokens": "def datatype ( dbtype , description , cursor ) : dt = cursor . db . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt", "docstring_tokens": "Google AppEngine Helper to convert a data type into a string .", "label": 1}, {"idx": "cosqa-train-2629", "doc": "fetch last row python sql", "code": "def get_last(self, table=None):\n        \"\"\"Just the last entry.\"\"\"\n        if table is None: table = self.main_table\n        query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table\n        return self.own_cursor.execute(query).fetchone()", "code_tokens": "def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )", "docstring_tokens": "Just the last entry .", "label": 0}, {"idx": "cosqa-train-2630", "doc": "python how to get dimension of list", "code": "def get_list_dimensions(_list):\n    \"\"\"\n    Takes a nested list and returns the size of each dimension followed\n    by the element type in the list\n    \"\"\"\n    if isinstance(_list, list) or isinstance(_list, tuple):\n        return [len(_list)] + get_list_dimensions(_list[0])\n    return []", "code_tokens": "def get_list_dimensions ( _list ) : if isinstance ( _list , list ) or isinstance ( _list , tuple ) : return [ len ( _list ) ] + get_list_dimensions ( _list [ 0 ] ) return [ ]", "docstring_tokens": "Takes a nested list and returns the size of each dimension followed by the element type in the list", "label": 1}, {"idx": "cosqa-train-2631", "doc": "fft 3d code in pure python", "code": "def stft_magnitude(signal, fft_length,\n                   hop_length=None,\n                   window_length=None):\n  \"\"\"Calculate the short-time Fourier transform magnitude.\n\n  Args:\n    signal: 1D np.array of the input time-domain signal.\n    fft_length: Size of the FFT to apply.\n    hop_length: Advance (in samples) between each frame passed to FFT.\n    window_length: Length of each block of samples to pass to FFT.\n\n  Returns:\n    2D np.array where each row contains the magnitudes of the fft_length/2+1\n    unique values of the FFT for the corresponding frame of input samples.\n  \"\"\"\n  frames = frame(signal, window_length, hop_length)\n  # Apply frame window to each frame. We use a periodic Hann (cosine of period\n  # window_length) instead of the symmetric Hann of np.hanning (period\n  # window_length-1).\n  window = periodic_hann(window_length)\n  windowed_frames = frames * window\n  return np.abs(np.fft.rfft(windowed_frames, int(fft_length)))", "code_tokens": "def stft_magnitude ( signal , fft_length , hop_length = None , window_length = None ) : frames = frame ( signal , window_length , hop_length ) # Apply frame window to each frame. We use a periodic Hann (cosine of period # window_length) instead of the symmetric Hann of np.hanning (period # window_length-1). window = periodic_hann ( window_length ) windowed_frames = frames * window return np . abs ( np . fft . rfft ( windowed_frames , int ( fft_length ) ) )", "docstring_tokens": "Calculate the short - time Fourier transform magnitude .", "label": 0}, {"idx": "cosqa-train-2632", "doc": "python how to get downloaded file", "code": "def wget(url):\n    \"\"\"\n    Download the page into a string\n    \"\"\"\n    import urllib.parse\n    request = urllib.request.urlopen(url)\n    filestring = request.read()\n    return filestring", "code_tokens": "def wget ( url ) : import urllib . parse request = urllib . request . urlopen ( url ) filestring = request . read ( ) return filestring", "docstring_tokens": "Download the page into a string", "label": 0}, {"idx": "cosqa-train-2633", "doc": "file not read in python with utf encoding", "code": "def _read_text(self, filename):\n        \"\"\"\n        Helper that reads the UTF-8 content of the specified file, or\n        None if the file doesn't exist. This returns a unicode string.\n        \"\"\"\n        with io.open(filename, 'rt', encoding='utf-8') as f:\n            return f.read()", "code_tokens": "def _read_text ( self , filename ) : with io . open ( filename , 'rt' , encoding = 'utf-8' ) as f : return f . read ( )", "docstring_tokens": "Helper that reads the UTF - 8 content of the specified file or None if the file doesn t exist . This returns a unicode string .", "label": 0}, {"idx": "cosqa-train-2634", "doc": "python how to get kubernetes pods counts on same namespace", "code": "def pods(self):\n        \"\"\" A list of kubernetes pods corresponding to current workers\n\n        See Also\n        --------\n        KubeCluster.logs\n        \"\"\"\n        return self.core_api.list_namespaced_pod(\n            self.namespace,\n            label_selector=format_labels(self.pod_template.metadata.labels)\n        ).items", "code_tokens": "def pods ( self ) : return self . core_api . list_namespaced_pod ( self . namespace , label_selector = format_labels ( self . pod_template . metadata . labels ) ) . items", "docstring_tokens": "A list of kubernetes pods corresponding to current workers", "label": 0}, {"idx": "cosqa-train-2635", "doc": "file object python size", "code": "def file_length(file_obj):\n    \"\"\"\n    Returns the length in bytes of a given file object.\n    Necessary because os.fstat only works on real files and not file-like\n    objects. This works on more types of streams, primarily StringIO.\n    \"\"\"\n    file_obj.seek(0, 2)\n    length = file_obj.tell()\n    file_obj.seek(0)\n    return length", "code_tokens": "def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length", "docstring_tokens": "Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO .", "label": 1}, {"idx": "cosqa-train-2636", "doc": "python how to get sorted list of dictionary keys", "code": "def unique_list_dicts(dlist, key):\n    \"\"\"Return a list of dictionaries which are sorted for only unique entries.\n\n    :param dlist:\n    :param key:\n    :return list:\n    \"\"\"\n\n    return list(dict((val[key], val) for val in dlist).values())", "code_tokens": "def unique_list_dicts ( dlist , key ) : return list ( dict ( ( val [ key ] , val ) for val in dlist ) . values ( ) )", "docstring_tokens": "Return a list of dictionaries which are sorted for only unique entries .", "label": 0}, {"idx": "cosqa-train-2637", "doc": "fill all numeric columns null values python", "code": "def fill_nulls(self, col: str):\n        \"\"\"\n        Fill all null values with NaN values in a column.\n        Null values are ``None`` or en empty string\n\n        :param col: column name\n        :type col: str\n\n        :example: ``ds.fill_nulls(\"mycol\")``\n        \"\"\"\n        n = [None, \"\"]\n        try:\n            self.df[col] = self.df[col].replace(n, nan)\n        except Exception as e:\n            self.err(e)", "code_tokens": "def fill_nulls ( self , col : str ) : n = [ None , \"\" ] try : self . df [ col ] = self . df [ col ] . replace ( n , nan ) except Exception as e : self . err ( e )", "docstring_tokens": "Fill all null values with NaN values in a column . Null values are None or en empty string", "label": 0}, {"idx": "cosqa-train-2638", "doc": "python how to get the amount of charaters in a varible", "code": "def display_len(text):\n    \"\"\"\n    Get the display length of a string. This can differ from the character\n    length if the string contains wide characters.\n    \"\"\"\n    text = unicodedata.normalize('NFD', text)\n    return sum(char_width(char) for char in text)", "code_tokens": "def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )", "docstring_tokens": "Get the display length of a string . This can differ from the character length if the string contains wide characters .", "label": 0}, {"idx": "cosqa-train-2639", "doc": "fill holes mask python", "code": "def inpaint(self):\n        \"\"\" Replace masked-out elements in an array using an iterative image inpainting algorithm. \"\"\"\n\n        import inpaint\n        filled = inpaint.replace_nans(np.ma.filled(self.raster_data, np.NAN).astype(np.float32), 3, 0.01, 2)\n        self.raster_data = np.ma.masked_invalid(filled)", "code_tokens": "def inpaint ( self ) : import inpaint filled = inpaint . replace_nans ( np . ma . filled ( self . raster_data , np . NAN ) . astype ( np . float32 ) , 3 , 0.01 , 2 ) self . raster_data = np . ma . masked_invalid ( filled )", "docstring_tokens": "Replace masked - out elements in an array using an iterative image inpainting algorithm .", "label": 1}, {"idx": "cosqa-train-2640", "doc": "python how to get the max value in a field of a dictionary with ints", "code": "def get_max(qs, field):\n    \"\"\"\n    get max for queryset.\n\n    qs: queryset\n    field: The field name to max.\n    \"\"\"\n    max_field = '%s__max' % field\n    num = qs.aggregate(Max(field))[max_field]\n    return num if num else 0", "code_tokens": "def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0", "docstring_tokens": "get max for queryset .", "label": 0}, {"idx": "cosqa-train-2641", "doc": "filling missing values in python df", "code": "def clean_dataframe(df):\n    \"\"\"Fill NaNs with the previous value, the next value or if all are NaN then 1.0\"\"\"\n    df = df.fillna(method='ffill')\n    df = df.fillna(0.0)\n    return df", "code_tokens": "def clean_dataframe ( df ) : df = df . fillna ( method = 'ffill' ) df = df . fillna ( 0.0 ) return df", "docstring_tokens": "Fill NaNs with the previous value the next value or if all are NaN then 1 . 0", "label": 0}, {"idx": "cosqa-train-2642", "doc": "python how to get the number of rows in a table", "code": "def count_rows(self, table_name):\n        \"\"\"Return the number of entries in a table by counting them.\"\"\"\n        self.table_must_exist(table_name)\n        query = \"SELECT COUNT (*) FROM `%s`\" % table_name.lower()\n        self.own_cursor.execute(query)\n        return int(self.own_cursor.fetchone()[0])", "code_tokens": "def count_rows ( self , table_name ) : self . table_must_exist ( table_name ) query = \"SELECT COUNT (*) FROM `%s`\" % table_name . lower ( ) self . own_cursor . execute ( query ) return int ( self . own_cursor . fetchone ( ) [ 0 ] )", "docstring_tokens": "Return the number of entries in a table by counting them .", "label": 0}, {"idx": "cosqa-train-2643", "doc": "filter dictionary on key basis in python", "code": "def filter_dict(d, keys):\n    \"\"\"\n    Creates a new dict from an existing dict that only has the given keys\n    \"\"\"\n    return {k: v for k, v in d.items() if k in keys}", "code_tokens": "def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "docstring_tokens": "Creates a new dict from an existing dict that only has the given keys", "label": 1}, {"idx": "cosqa-train-2644", "doc": "python how to hide axes", "code": "def _hide_tick_lines_and_labels(axis):\n    \"\"\"\n    Set visible property of ticklines and ticklabels of an axis to False\n    \"\"\"\n    for item in axis.get_ticklines() + axis.get_ticklabels():\n        item.set_visible(False)", "code_tokens": "def _hide_tick_lines_and_labels ( axis ) : for item in axis . get_ticklines ( ) + axis . get_ticklabels ( ) : item . set_visible ( False )", "docstring_tokens": "Set visible property of ticklines and ticklabels of an axis to False", "label": 1}, {"idx": "cosqa-train-2645", "doc": "filter out columns that is str python", "code": "def _drop_str_columns(df):\n    \"\"\"\n\n    Parameters\n    ----------\n    df : DataFrame\n\n    Returns\n    -------\n\n    \"\"\"\n    str_columns = filter(lambda pair: pair[1].char == 'S', df._gather_dtypes().items())\n    str_column_names = list(map(lambda pair: pair[0], str_columns))\n\n    return df.drop(str_column_names)", "code_tokens": "def _drop_str_columns ( df ) : str_columns = filter ( lambda pair : pair [ 1 ] . char == 'S' , df . _gather_dtypes ( ) . items ( ) ) str_column_names = list ( map ( lambda pair : pair [ 0 ] , str_columns ) ) return df . drop ( str_column_names )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-2646", "doc": "python how to hide password typing input", "code": "def getpass(self, prompt, default=None):\n        \"\"\"Provide a password prompt.\"\"\"\n        return click.prompt(prompt, hide_input=True, default=default)", "code_tokens": "def getpass ( self , prompt , default = None ) : return click . prompt ( prompt , hide_input = True , default = default )", "docstring_tokens": "Provide a password prompt .", "label": 0}, {"idx": "cosqa-train-2647", "doc": "finding a median code python", "code": "def median_high(data):\n    \"\"\"Return the high median of data.\n\n    When the number of data points is odd, the middle value is returned.\n    When it is even, the larger of the two middle values is returned.\n\n    \"\"\"\n    data = sorted(data)\n    n = len(data)\n    if n == 0:\n        raise StatisticsError(\"no median for empty data\")\n    return data[n // 2]", "code_tokens": "def median_high ( data ) : data = sorted ( data ) n = len ( data ) if n == 0 : raise StatisticsError ( \"no median for empty data\" ) return data [ n // 2 ]", "docstring_tokens": "Return the high median of data .", "label": 1}, {"idx": "cosqa-train-2648", "doc": "python how to join 2 data frame", "code": "def cross_join(df1, df2):\n    \"\"\"\n    Return a dataframe that is a cross between dataframes\n    df1 and df2\n\n    ref: https://github.com/pydata/pandas/issues/5401\n    \"\"\"\n    if len(df1) == 0:\n        return df2\n\n    if len(df2) == 0:\n        return df1\n\n    # Add as lists so that the new index keeps the items in\n    # the order that they are added together\n    all_columns = pd.Index(list(df1.columns) + list(df2.columns))\n    df1['key'] = 1\n    df2['key'] = 1\n    return pd.merge(df1, df2, on='key').loc[:, all_columns]", "code_tokens": "def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]", "docstring_tokens": "Return a dataframe that is a cross between dataframes df1 and df2", "label": 0}, {"idx": "cosqa-train-2649", "doc": "finding absolute angle between two vectors python", "code": "def vec_angle(a, b):\n    \"\"\"\n    Calculate angle between two vectors\n    \"\"\"\n    cosang = np.dot(a, b)\n    sinang = fast_norm(np.cross(a, b))\n    return np.arctan2(sinang, cosang)", "code_tokens": "def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )", "docstring_tokens": "Calculate angle between two vectors", "label": 0}, {"idx": "cosqa-train-2650", "doc": "python how to kill background threads", "code": "def finish():\n    \"\"\"Print warning about interrupt and empty the job queue.\"\"\"\n    out.warn(\"Interrupted!\")\n    for t in threads:\n        t.stop()\n    jobs.clear()\n    out.warn(\"Waiting for download threads to finish.\")", "code_tokens": "def finish ( ) : out . warn ( \"Interrupted!\" ) for t in threads : t . stop ( ) jobs . clear ( ) out . warn ( \"Waiting for download threads to finish.\" )", "docstring_tokens": "Print warning about interrupt and empty the job queue .", "label": 0}, {"idx": "cosqa-train-2651", "doc": "finding datframe type python", "code": "def _to_corrected_pandas_type(dt):\n    \"\"\"\n    When converting Spark SQL records to Pandas DataFrame, the inferred data type may be wrong.\n    This method gets the corrected data type for Pandas if that type may be inferred uncorrectly.\n    \"\"\"\n    import numpy as np\n    if type(dt) == ByteType:\n        return np.int8\n    elif type(dt) == ShortType:\n        return np.int16\n    elif type(dt) == IntegerType:\n        return np.int32\n    elif type(dt) == FloatType:\n        return np.float32\n    else:\n        return None", "code_tokens": "def _to_corrected_pandas_type ( dt ) : import numpy as np if type ( dt ) == ByteType : return np . int8 elif type ( dt ) == ShortType : return np . int16 elif type ( dt ) == IntegerType : return np . int32 elif type ( dt ) == FloatType : return np . float32 else : return None", "docstring_tokens": "When converting Spark SQL records to Pandas DataFrame the inferred data type may be wrong . This method gets the corrected data type for Pandas if that type may be inferred uncorrectly .", "label": 0}, {"idx": "cosqa-train-2652", "doc": "python how to kill process and child process", "code": "def kill_process_children(pid):\n    \"\"\"Find and kill child processes of a process.\n\n    :param pid: PID of parent process (process ID)\n    :return: Nothing\n    \"\"\"\n    if sys.platform == \"darwin\":\n        kill_process_children_osx(pid)\n    elif sys.platform == \"linux\":\n        kill_process_children_unix(pid)\n    else:\n        pass", "code_tokens": "def kill_process_children ( pid ) : if sys . platform == \"darwin\" : kill_process_children_osx ( pid ) elif sys . platform == \"linux\" : kill_process_children_unix ( pid ) else : pass", "docstring_tokens": "Find and kill child processes of a process .", "label": 0}, {"idx": "cosqa-train-2653", "doc": "finding intersection points python", "code": "def search_overlap(self, point_list):\n        \"\"\"\n        Returns all intervals that overlap the point_list.\n        \"\"\"\n        result = set()\n        for j in point_list:\n            self.search_point(j, result)\n        return result", "code_tokens": "def search_overlap ( self , point_list ) : result = set ( ) for j in point_list : self . search_point ( j , result ) return result", "docstring_tokens": "Returns all intervals that overlap the point_list .", "label": 0}, {"idx": "cosqa-train-2654", "doc": "python how to know the encoding of a text", "code": "def guess_encoding(text, default=DEFAULT_ENCODING):\n    \"\"\"Guess string encoding.\n\n    Given a piece of text, apply character encoding detection to\n    guess the appropriate encoding of the text.\n    \"\"\"\n    result = chardet.detect(text)\n    return normalize_result(result, default=default)", "code_tokens": "def guess_encoding ( text , default = DEFAULT_ENCODING ) : result = chardet . detect ( text ) return normalize_result ( result , default = default )", "docstring_tokens": "Guess string encoding .", "label": 0}, {"idx": "cosqa-train-2655", "doc": "finding max in arrays python", "code": "def findMax(arr):\n    \"\"\"\n    in comparison to argrelmax() more simple and  reliable peak finder\n    \"\"\"\n    out = np.zeros(shape=arr.shape, dtype=bool)\n    _calcMax(arr, out)\n    return out", "code_tokens": "def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out", "docstring_tokens": "in comparison to argrelmax () more simple and reliable peak finder", "label": 0}, {"idx": "cosqa-train-2656", "doc": "python how to list database tables", "code": "def get_table_names(connection):\n\t\"\"\"\n\tReturn a list of the table names in the database.\n\t\"\"\"\n\tcursor = connection.cursor()\n\tcursor.execute(\"SELECT name FROM sqlite_master WHERE type == 'table'\")\n\treturn [name for (name,) in cursor]", "code_tokens": "def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( \"SELECT name FROM sqlite_master WHERE type == 'table'\" ) return [ name for ( name , ) in cursor ]", "docstring_tokens": "Return a list of the table names in the database .", "label": 0}, {"idx": "cosqa-train-2657", "doc": "finding max node in tree python", "code": "def maxDepth(self, currentDepth=0):\n        \"\"\"Compute the depth of the longest branch of the tree\"\"\"\n        if not any((self.left, self.right)):\n            return currentDepth\n        result = 0\n        for child in (self.left, self.right):\n            if child:\n                result = max(result, child.maxDepth(currentDepth + 1))\n        return result", "code_tokens": "def maxDepth ( self , currentDepth = 0 ) : if not any ( ( self . left , self . right ) ) : return currentDepth result = 0 for child in ( self . left , self . right ) : if child : result = max ( result , child . maxDepth ( currentDepth + 1 ) ) return result", "docstring_tokens": "Compute the depth of the longest branch of the tree", "label": 0}, {"idx": "cosqa-train-2658", "doc": "python how to log instead of print", "code": "def pout(msg, log=None):\n    \"\"\"Print 'msg' to stdout, and option 'log' at info level.\"\"\"\n    _print(msg, sys.stdout, log_func=log.info if log else None)", "code_tokens": "def pout ( msg , log = None ) : _print ( msg , sys . stdout , log_func = log . info if log else None )", "docstring_tokens": "Print msg to stdout and option log at info level .", "label": 1}, {"idx": "cosqa-train-2659", "doc": "finding max with lambda python", "code": "def argmax(l,f=None):\n    \"\"\"http://stackoverflow.com/questions/5098580/implementing-argmax-in-python\"\"\"\n    if f:\n        l = [f(i) for i in l]\n    return max(enumerate(l), key=lambda x:x[1])[0]", "code_tokens": "def argmax ( l , f = None ) : if f : l = [ f ( i ) for i in l ] return max ( enumerate ( l ) , key = lambda x : x [ 1 ] ) [ 0 ]", "docstring_tokens": "http : // stackoverflow . com / questions / 5098580 / implementing - argmax - in - python", "label": 0}, {"idx": "cosqa-train-2660", "doc": "python how to make a folder", "code": "def mkdir(dir, enter):\n    \"\"\"Create directory with template for topic of the current environment\n\n    \"\"\"\n\n    if not os.path.exists(dir):\n        os.makedirs(dir)", "code_tokens": "def mkdir ( dir , enter ) : if not os . path . exists ( dir ) : os . makedirs ( dir )", "docstring_tokens": "Create directory with template for topic of the current environment", "label": 0}, {"idx": "cosqa-train-2661", "doc": "finding the depth of a node in python", "code": "def min_depth(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if root is None:\n        return 0\n    if root.left is not None or root.right is not None:\n        return max(self.minDepth(root.left), self.minDepth(root.right))+1\n    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1", "code_tokens": "def min_depth ( self , root ) : if root is None : return 0 if root . left is not None or root . right is not None : return max ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1 return min ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1", "docstring_tokens": ": type root : TreeNode : rtype : int", "label": 0}, {"idx": "cosqa-train-2662", "doc": "python how to make a list a string", "code": "def list_i2str(ilist):\n    \"\"\"\n    Convert an integer list into a string list.\n    \"\"\"\n    slist = []\n    for el in ilist:\n        slist.append(str(el))\n    return slist", "code_tokens": "def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist", "docstring_tokens": "Convert an integer list into a string list .", "label": 1}, {"idx": "cosqa-train-2663", "doc": "finding the index of an element in a list python", "code": "def binSearch(arr, val):\n  \"\"\" \n  Function for running binary search on a sorted list.\n\n  :param arr: (list) a sorted list of integers to search\n  :param val: (int)  a integer to search for in the sorted array\n  :returns: (int) the index of the element if it is found and -1 otherwise.\n  \"\"\"\n  i = bisect_left(arr, val)\n  if i != len(arr) and arr[i] == val:\n    return i\n  return -1", "code_tokens": "def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1", "docstring_tokens": "Function for running binary search on a sorted list .", "label": 0}, {"idx": "cosqa-train-2664", "doc": "python how to move window position", "code": "def OnMove(self, event):\n        \"\"\"Main window move event\"\"\"\n\n        # Store window position in config\n        position = self.main_window.GetScreenPositionTuple()\n\n        config[\"window_position\"] = repr(position)", "code_tokens": "def OnMove ( self , event ) : # Store window position in config position = self . main_window . GetScreenPositionTuple ( ) config [ \"window_position\" ] = repr ( position )", "docstring_tokens": "Main window move event", "label": 0}, {"idx": "cosqa-train-2665", "doc": "finding the index of an entry python", "code": "def find(self, name):\n        \"\"\"Return the index of the toc entry with name NAME.\n\n           Return -1 for failure.\"\"\"\n        for i, nm in enumerate(self.data):\n            if nm[-1] == name:\n                return i\n        return -1", "code_tokens": "def find ( self , name ) : for i , nm in enumerate ( self . data ) : if nm [ - 1 ] == name : return i return - 1", "docstring_tokens": "Return the index of the toc entry with name NAME .", "label": 0}, {"idx": "cosqa-train-2666", "doc": "python how to multiply function by value", "code": "def multiply(self, number):\n        \"\"\"Return a Vector as the product of the vector and a real number.\"\"\"\n        return self.from_list([x * number for x in self.to_list()])", "code_tokens": "def multiply ( self , number ) : return self . from_list ( [ x * number for x in self . to_list ( ) ] )", "docstring_tokens": "Return a Vector as the product of the vector and a real number .", "label": 0}, {"idx": "cosqa-train-2667", "doc": "finding the least common divisor in python", "code": "def _gcd_array(X):\n    \"\"\"\n    Return the largest real value h such that all elements in x are integer\n    multiples of h.\n    \"\"\"\n    greatest_common_divisor = 0.0\n    for x in X:\n        greatest_common_divisor = _gcd(greatest_common_divisor, x)\n\n    return greatest_common_divisor", "code_tokens": "def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor", "docstring_tokens": "Return the largest real value h such that all elements in x are integer multiples of h .", "label": 0}, {"idx": "cosqa-train-2668", "doc": "finding the width and height of an image python", "code": "def get_image_dimension(self, url):\n        \"\"\"\n        Return a tuple that contains (width, height)\n        Pass in a url to an image and find out its size without loading the whole file\n        If the image wxh could not be found, the tuple will contain `None` values\n        \"\"\"\n        w_h = (None, None)\n        try:\n            if url.startswith('//'):\n                url = 'http:' + url\n            data = requests.get(url).content\n            im = Image.open(BytesIO(data))\n\n            w_h = im.size\n        except Exception:\n            logger.warning(\"Error getting image size {}\".format(url), exc_info=True)\n\n        return w_h", "code_tokens": "def get_image_dimension ( self , url ) : w_h = ( None , None ) try : if url . startswith ( '//' ) : url = 'http:' + url data = requests . get ( url ) . content im = Image . open ( BytesIO ( data ) ) w_h = im . size except Exception : logger . warning ( \"Error getting image size {}\" . format ( url ) , exc_info = True ) return w_h", "docstring_tokens": "Return a tuple that contains ( width height ) Pass in a url to an image and find out its size without loading the whole file If the image wxh could not be found the tuple will contain None values", "label": 1}, {"idx": "cosqa-train-2669", "doc": "python how to read from tty stdin", "code": "def read_stdin():\n    \"\"\" Read text from stdin, and print a helpful message for ttys. \"\"\"\n    if sys.stdin.isatty() and sys.stdout.isatty():\n        print('\\nReading from stdin until end of file (Ctrl + D)...')\n\n    return sys.stdin.read()", "code_tokens": "def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )", "docstring_tokens": "Read text from stdin and print a helpful message for ttys .", "label": 0}, {"idx": "cosqa-train-2670", "doc": "fit and transform two functions in python", "code": "def apply_fit(xy,coeffs):\n    \"\"\" Apply the coefficients from a linear fit to\n        an array of x,y positions.\n\n        The coeffs come from the 'coeffs' member of the\n        'fit_arrays()' output.\n    \"\"\"\n    x_new = coeffs[0][2] + coeffs[0][0]*xy[:,0] + coeffs[0][1]*xy[:,1]\n    y_new = coeffs[1][2] + coeffs[1][0]*xy[:,0] + coeffs[1][1]*xy[:,1]\n\n    return x_new,y_new", "code_tokens": "def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "docstring_tokens": "Apply the coefficients from a linear fit to an array of x y positions .", "label": 0}, {"idx": "cosqa-train-2671", "doc": "python how to read keypressed", "code": "def read_key(suppress=False):\n    \"\"\"\n    Blocks until a keyboard event happens, then returns that event's name or,\n    if missing, its scan code.\n    \"\"\"\n    event = read_event(suppress)\n    return event.name or event.scan_code", "code_tokens": "def read_key ( suppress = False ) : event = read_event ( suppress ) return event . name or event . scan_code", "docstring_tokens": "Blocks until a keyboard event happens then returns that event s name or if missing its scan code .", "label": 0}, {"idx": "cosqa-train-2672", "doc": "fit transform tfidf python", "code": "def fit_transform(self, raw_documents, y=None):\n        \"\"\"Learn vocabulary and idf, return term-document matrix.\n        This is equivalent to fit followed by transform, but more efficiently\n        implemented.\n        Parameters\n        ----------\n        raw_documents : iterable\n            an iterable which yields either str, unicode or file objects\n        Returns\n        -------\n        X : sparse matrix, [n_samples, n_features]\n            Tf-idf-weighted document-term matrix.\n        \"\"\"\n        documents = super(TfidfVectorizer, self).fit_transform(\n            raw_documents=raw_documents, y=y)\n        count = CountVectorizer(encoding=self.encoding,\n                                decode_error=self.decode_error,\n                                strip_accents=self.strip_accents,\n                                lowercase=self.lowercase,\n                                preprocessor=self.preprocessor,\n                                tokenizer=self.tokenizer,\n                                stop_words=self.stop_words,\n                                token_pattern=self.token_pattern,\n                                ngram_range=self.ngram_range,\n                                analyzer=self.analyzer,\n                                max_df=self.max_df,\n                                min_df=self.min_df,\n                                max_features=self.max_features,\n                                vocabulary=self.vocabulary_,\n                                binary=self.binary,\n                                dtype=self.dtype)\n        count.fit_transform(raw_documents=raw_documents, y=y)\n        self.period_ = count.period_\n        self.df_ = count.df_\n        self.n = count.n\n        return documents", "code_tokens": "def fit_transform ( self , raw_documents , y = None ) : documents = super ( TfidfVectorizer , self ) . fit_transform ( raw_documents = raw_documents , y = y ) count = CountVectorizer ( encoding = self . encoding , decode_error = self . decode_error , strip_accents = self . strip_accents , lowercase = self . lowercase , preprocessor = self . preprocessor , tokenizer = self . tokenizer , stop_words = self . stop_words , token_pattern = self . token_pattern , ngram_range = self . ngram_range , analyzer = self . analyzer , max_df = self . max_df , min_df = self . min_df , max_features = self . max_features , vocabulary = self . vocabulary_ , binary = self . binary , dtype = self . dtype ) count . fit_transform ( raw_documents = raw_documents , y = y ) self . period_ = count . period_ self . df_ = count . df_ self . n = count . n return documents", "docstring_tokens": "Learn vocabulary and idf return term - document matrix . This is equivalent to fit followed by transform but more efficiently implemented . Parameters ---------- raw_documents : iterable an iterable which yields either str unicode or file objects Returns ------- X : sparse matrix [ n_samples n_features ] Tf - idf - weighted document - term matrix .", "label": 0}, {"idx": "cosqa-train-2673", "doc": "python how to read returned command output", "code": "def call_out(command):\n  \"\"\"\n  Run the given command (with shell=False) and return a tuple of\n  (int returncode, str output). Strip the output of enclosing whitespace.\n  \"\"\"\n  # start external command process\n  p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n  # get outputs\n  out, _ = p.communicate()\n\n  return p.returncode, out.strip()", "code_tokens": "def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "docstring_tokens": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace .", "label": 0}, {"idx": "cosqa-train-2674", "doc": "fix ssl error on windows for python", "code": "def inject_into_urllib3():\n    \"\"\"\n    Monkey-patch urllib3 with SecureTransport-backed SSL-support.\n    \"\"\"\n    util.ssl_.SSLContext = SecureTransportContext\n    util.HAS_SNI = HAS_SNI\n    util.ssl_.HAS_SNI = HAS_SNI\n    util.IS_SECURETRANSPORT = True\n    util.ssl_.IS_SECURETRANSPORT = True", "code_tokens": "def inject_into_urllib3 ( ) : util . ssl_ . SSLContext = SecureTransportContext util . HAS_SNI = HAS_SNI util . ssl_ . HAS_SNI = HAS_SNI util . IS_SECURETRANSPORT = True util . ssl_ . IS_SECURETRANSPORT = True", "docstring_tokens": "Monkey - patch urllib3 with SecureTransport - backed SSL - support .", "label": 1}, {"idx": "cosqa-train-2675", "doc": "python how to read stdout realtime", "code": "def report_stdout(host, stdout):\n    \"\"\"Take a stdout and print it's lines to output if lines are present.\n\n    :param host: the host where the process is running\n    :type host: str\n    :param stdout: the std out of that process\n    :type stdout: paramiko.channel.Channel\n    \"\"\"\n    lines = stdout.readlines()\n    if lines:\n        print(\"STDOUT from {host}:\".format(host=host))\n        for line in lines:\n            print(line.rstrip(), file=sys.stdout)", "code_tokens": "def report_stdout ( host , stdout ) : lines = stdout . readlines ( ) if lines : print ( \"STDOUT from {host}:\" . format ( host = host ) ) for line in lines : print ( line . rstrip ( ) , file = sys . stdout )", "docstring_tokens": "Take a stdout and print it s lines to output if lines are present .", "label": 0}, {"idx": "cosqa-train-2676", "doc": "flask python check request is localproxy unbound", "code": "def is_local_url(target):\n    \"\"\"Determine if URL is safe to redirect to.\"\"\"\n    ref_url = urlparse(request.host_url)\n    test_url = urlparse(urljoin(request.host_url, target))\n    return test_url.scheme in ('http', 'https') and \\\n        ref_url.netloc == test_url.netloc", "code_tokens": "def is_local_url ( target ) : ref_url = urlparse ( request . host_url ) test_url = urlparse ( urljoin ( request . host_url , target ) ) return test_url . scheme in ( 'http' , 'https' ) and ref_url . netloc == test_url . netloc", "docstring_tokens": "Determine if URL is safe to redirect to .", "label": 0}, {"idx": "cosqa-train-2677", "doc": "python how to replace a string with underscores", "code": "def normalise_string(string):\n    \"\"\" Strips trailing whitespace from string, lowercases it and replaces\n        spaces with underscores\n    \"\"\"\n    string = (string.strip()).lower()\n    return re.sub(r'\\W+', '_', string)", "code_tokens": "def normalise_string ( string ) : string = ( string . strip ( ) ) . lower ( ) return re . sub ( r'\\W+' , '_' , string )", "docstring_tokens": "Strips trailing whitespace from string lowercases it and replaces spaces with underscores", "label": 1}, {"idx": "cosqa-train-2678", "doc": "flatten list in python 3 using isinstance", "code": "def flatten(l, types=(list, float)):\n    \"\"\"\n    Flat nested list of lists into a single list.\n    \"\"\"\n    l = [item if isinstance(item, types) else [item] for item in l]\n    return [item for sublist in l for item in sublist]", "code_tokens": "def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Flat nested list of lists into a single list .", "label": 0}, {"idx": "cosqa-train-2679", "doc": "python how to represent sql queries in a data structure", "code": "def export_all(self):\n\t\tquery = \"\"\"\n\t\t\tSELECT quote, library, logid\n\t\t\tfrom quotes\n\t\t\tleft outer join quote_log on quotes.quoteid = quote_log.quoteid\n\t\t\t\"\"\"\n\t\tfields = 'text', 'library', 'log_id'\n\t\treturn (dict(zip(fields, res)) for res in self.db.execute(query))", "code_tokens": "def export_all ( self ) : query = \"\"\"\n\t\t\tSELECT quote, library, logid\n\t\t\tfrom quotes\n\t\t\tleft outer join quote_log on quotes.quoteid = quote_log.quoteid\n\t\t\t\"\"\" fields = 'text' , 'library' , 'log_id' return ( dict ( zip ( fields , res ) ) for res in self . db . execute ( query ) )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-2680", "doc": "flatten lists inside a list in python", "code": "def flatten_list(l):\n    \"\"\" Nested lists to single-level list, does not split strings\"\"\"\n    return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "code_tokens": "def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )", "docstring_tokens": "Nested lists to single - level list does not split strings", "label": 0}, {"idx": "cosqa-train-2681", "doc": "python how to rotate an array 90 degrees", "code": "def rotateImage(image, angle):\n    \"\"\"\n        rotates a 2d array to a multiple of 90 deg.\n        0 = default\n        1 = 90 deg. cw\n        2 = 180 deg.\n        3 = 90 deg. ccw\n    \"\"\"\n    image = [list(row) for row in image]\n\n    for n in range(angle % 4):\n        image = list(zip(*image[::-1]))\n\n    return image", "code_tokens": "def rotateImage ( image , angle ) : image = [ list ( row ) for row in image ] for n in range ( angle % 4 ) : image = list ( zip ( * image [ : : - 1 ] ) ) return image", "docstring_tokens": "rotates a 2d array to a multiple of 90 deg . 0 = default 1 = 90 deg . cw 2 = 180 deg . 3 = 90 deg . ccw", "label": 0}, {"idx": "cosqa-train-2682", "doc": "flatten nested list python", "code": "def flatten(lis):\n    \"\"\"Given a list, possibly nested to any level, return it flattened.\"\"\"\n    new_lis = []\n    for item in lis:\n        if isinstance(item, collections.Sequence) and not isinstance(item, basestring):\n            new_lis.extend(flatten(item))\n        else:\n            new_lis.append(item)\n    return new_lis", "code_tokens": "def flatten ( lis ) : new_lis = [ ] for item in lis : if isinstance ( item , collections . Sequence ) and not isinstance ( item , basestring ) : new_lis . extend ( flatten ( item ) ) else : new_lis . append ( item ) return new_lis", "docstring_tokens": "Given a list possibly nested to any level return it flattened .", "label": 0}, {"idx": "cosqa-train-2683", "doc": "python how to run unittests", "code": "def test():\n    \"\"\"Run the unit tests.\"\"\"\n    import unittest\n    tests = unittest.TestLoader().discover('tests')\n    unittest.TextTestRunner(verbosity=2).run(tests)", "code_tokens": "def test ( ) : import unittest tests = unittest . TestLoader ( ) . discover ( 'tests' ) unittest . TextTestRunner ( verbosity = 2 ) . run ( tests )", "docstring_tokens": "Run the unit tests .", "label": 0}, {"idx": "cosqa-train-2684", "doc": "flip images vertically python", "code": "def hflip(img):\n    \"\"\"Horizontally flip the given PIL Image.\n\n    Args:\n        img (PIL Image): Image to be flipped.\n\n    Returns:\n        PIL Image:  Horizontall flipped image.\n    \"\"\"\n    if not _is_pil_image(img):\n        raise TypeError('img should be PIL Image. Got {}'.format(type(img)))\n\n    return img.transpose(Image.FLIP_LEFT_RIGHT)", "code_tokens": "def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )", "docstring_tokens": "Horizontally flip the given PIL Image .", "label": 0}, {"idx": "cosqa-train-2685", "doc": "python how to set global random seed", "code": "def generate_seed(seed):\n    \"\"\"Generate seed for random number generator\"\"\"\n    if seed is None:\n        random.seed()\n        seed = random.randint(0, sys.maxsize)\n    random.seed(a=seed)\n\n    return seed", "code_tokens": "def generate_seed ( seed ) : if seed is None : random . seed ( ) seed = random . randint ( 0 , sys . maxsize ) random . seed ( a = seed ) return seed", "docstring_tokens": "Generate seed for random number generator", "label": 0}, {"idx": "cosqa-train-2686", "doc": "flush out the serial buffer python", "code": "def __clear_buffers(self):\n        \"\"\"Clears the input and output buffers\"\"\"\n        try:\n            self._port.reset_input_buffer()\n            self._port.reset_output_buffer()\n        except AttributeError:\n            #pySerial 2.7\n            self._port.flushInput()\n            self._port.flushOutput()", "code_tokens": "def __clear_buffers ( self ) : try : self . _port . reset_input_buffer ( ) self . _port . reset_output_buffer ( ) except AttributeError : #pySerial 2.7 self . _port . flushInput ( ) self . _port . flushOutput ( )", "docstring_tokens": "Clears the input and output buffers", "label": 0}, {"idx": "cosqa-train-2687", "doc": "python how to specify width in bar chart", "code": "def _change_height(self, ax, new_value):\n        \"\"\"Make bars in horizontal bar chart thinner\"\"\"\n        for patch in ax.patches:\n            current_height = patch.get_height()\n            diff = current_height - new_value\n\n            # we change the bar height\n            patch.set_height(new_value)\n\n            # we recenter the bar\n            patch.set_y(patch.get_y() + diff * .5)", "code_tokens": "def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )", "docstring_tokens": "Make bars in horizontal bar chart thinner", "label": 0}, {"idx": "cosqa-train-2688", "doc": "flushing memory i python", "code": "def Flush(self):\n    \"\"\"Flush all items from cache.\"\"\"\n    while self._age:\n      node = self._age.PopLeft()\n      self.KillObject(node.data)\n\n    self._hash = dict()", "code_tokens": "def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )", "docstring_tokens": "Flush all items from cache .", "label": 0}, {"idx": "cosqa-train-2689", "doc": "python how to tell if a file is a symlink", "code": "def is_symlink(self):\n        \"\"\"\n        Whether this path is a symbolic link.\n        \"\"\"\n        try:\n            return S_ISLNK(self.lstat().st_mode)\n        except OSError as e:\n            if e.errno != ENOENT:\n                raise\n            # Path doesn't exist\n            return False", "code_tokens": "def is_symlink ( self ) : try : return S_ISLNK ( self . lstat ( ) . st_mode ) except OSError as e : if e . errno != ENOENT : raise # Path doesn't exist return False", "docstring_tokens": "Whether this path is a symbolic link .", "label": 1}, {"idx": "cosqa-train-2690", "doc": "force python to use tensorflow back end", "code": "def flatten_all_but_last(a):\n  \"\"\"Flatten all dimensions of a except the last.\"\"\"\n  ret = tf.reshape(a, [-1, tf.shape(a)[-1]])\n  if not tf.executing_eagerly():\n    ret.set_shape([None] + a.get_shape().as_list()[-1:])\n  return ret", "code_tokens": "def flatten_all_but_last ( a ) : ret = tf . reshape ( a , [ - 1 , tf . shape ( a ) [ - 1 ] ] ) if not tf . executing_eagerly ( ) : ret . set_shape ( [ None ] + a . get_shape ( ) . as_list ( ) [ - 1 : ] ) return ret", "docstring_tokens": "Flatten all dimensions of a except the last .", "label": 1}, {"idx": "cosqa-train-2691", "doc": "python how to tell if an object is a collection", "code": "def is_collection(obj):\n    \"\"\"Tests if an object is a collection.\"\"\"\n\n    col = getattr(obj, '__getitem__', False)\n    val = False if (not col) else True\n\n    if isinstance(obj, basestring):\n        val = False\n\n    return val", "code_tokens": "def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val", "docstring_tokens": "Tests if an object is a collection .", "label": 0}, {"idx": "cosqa-train-2692", "doc": "forcefully quit python execution", "code": "async def terminate(self):\n        \"\"\"Terminate a running script.\"\"\"\n        self.proc.terminate()\n\n        await asyncio.wait_for(self.proc.wait(), self.kill_delay)\n        if self.proc.returncode is None:\n            self.proc.kill()\n        await self.proc.wait()\n\n        await super().terminate()", "code_tokens": "async def terminate ( self ) : self . proc . terminate ( ) await asyncio . wait_for ( self . proc . wait ( ) , self . kill_delay ) if self . proc . returncode is None : self . proc . kill ( ) await self . proc . wait ( ) await super ( ) . terminate ( )", "docstring_tokens": "Terminate a running script .", "label": 0}, {"idx": "cosqa-train-2693", "doc": "python how to tell is a value is a string", "code": "def is_string(val):\n    \"\"\"Determines whether the passed value is a string, safe for 2/3.\"\"\"\n    try:\n        basestring\n    except NameError:\n        return isinstance(val, str)\n    return isinstance(val, basestring)", "code_tokens": "def is_string ( val ) : try : basestring except NameError : return isinstance ( val , str ) return isinstance ( val , basestring )", "docstring_tokens": "Determines whether the passed value is a string safe for 2 / 3 .", "label": 0}, {"idx": "cosqa-train-2694", "doc": "fork off and die python", "code": "def go_to_background():\n    \"\"\" Daemonize the running process. \"\"\"\n    try:\n        if os.fork():\n            sys.exit()\n    except OSError as errmsg:\n        LOGGER.error('Fork failed: {0}'.format(errmsg))\n        sys.exit('Fork failed')", "code_tokens": "def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "docstring_tokens": "Daemonize the running process .", "label": 0}, {"idx": "cosqa-train-2695", "doc": "python how to time out if no response", "code": "def _wait_for_response(self):\n\t\t\"\"\"\n\t\tWait until the user accepted or rejected the request\n\t\t\"\"\"\n\t\twhile not self.server.response_code:\n\t\t\ttime.sleep(2)\n\t\ttime.sleep(5)\n\t\tself.server.shutdown()", "code_tokens": "def _wait_for_response ( self ) : while not self . server . response_code : time . sleep ( 2 ) time . sleep ( 5 ) self . server . shutdown ( )", "docstring_tokens": "Wait until the user accepted or rejected the request", "label": 0}, {"idx": "cosqa-train-2696", "doc": "format a number to m or k if large python", "code": "def reportMemory(k, options, field=None, isBytes=False):\n    \"\"\" Given k kilobytes, report back the correct format as string.\n    \"\"\"\n    if options.pretty:\n        return prettyMemory(int(k), field=field, isBytes=isBytes)\n    else:\n        if isBytes:\n            k /= 1024.\n        if field is not None:\n            return \"%*dK\" % (field - 1, k)  # -1 for the \"K\"\n        else:\n            return \"%dK\" % int(k)", "code_tokens": "def reportMemory ( k , options , field = None , isBytes = False ) : if options . pretty : return prettyMemory ( int ( k ) , field = field , isBytes = isBytes ) else : if isBytes : k /= 1024. if field is not None : return \"%*dK\" % ( field - 1 , k ) # -1 for the \"K\" else : return \"%dK\" % int ( k )", "docstring_tokens": "Given k kilobytes report back the correct format as string .", "label": 1}, {"idx": "cosqa-train-2697", "doc": "python how to update fig by keyboard", "code": "def OnUpdateFigurePanel(self, event):\n        \"\"\"Redraw event handler for the figure panel\"\"\"\n\n        if self.updating:\n            return\n\n        self.updating = True\n        self.figure_panel.update(self.get_figure(self.code))\n        self.updating = False", "code_tokens": "def OnUpdateFigurePanel ( self , event ) : if self . updating : return self . updating = True self . figure_panel . update ( self . get_figure ( self . code ) ) self . updating = False", "docstring_tokens": "Redraw event handler for the figure panel", "label": 0}, {"idx": "cosqa-train-2698", "doc": "format multiline string python", "code": "def format_line(data, linestyle):\n    \"\"\"Formats a list of elements using the given line style\"\"\"\n    return linestyle.begin + linestyle.sep.join(data) + linestyle.end", "code_tokens": "def format_line ( data , linestyle ) : return linestyle . begin + linestyle . sep . join ( data ) + linestyle . end", "docstring_tokens": "Formats a list of elements using the given line style", "label": 0}, {"idx": "cosqa-train-2699", "doc": "python how write an apostraphy in a string", "code": "def format_screen(strng):\n    \"\"\"Format a string for screen printing.\n\n    This removes some latex-type format codes.\"\"\"\n    # Paragraph continue\n    par_re = re.compile(r'\\\\$',re.MULTILINE)\n    strng = par_re.sub('',strng)\n    return strng", "code_tokens": "def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng", "docstring_tokens": "Format a string for screen printing .", "label": 0}, {"idx": "cosqa-train-2700", "doc": "format numbers to percent python", "code": "def to_percentage(number, rounding=2):\n    \"\"\"Creates a percentage string representation from the given `number`. The\n    number is multiplied by 100 before adding a '%' character.\n\n    Raises `ValueError` if `number` cannot be converted to a number.\n    \"\"\"\n    number = float(number) * 100\n    number_as_int = int(number)\n    rounded = round(number, rounding)\n\n    return '{}%'.format(number_as_int if number_as_int == rounded else rounded)", "code_tokens": "def to_percentage ( number , rounding = 2 ) : number = float ( number ) * 100 number_as_int = int ( number ) rounded = round ( number , rounding ) return '{}%' . format ( number_as_int if number_as_int == rounded else rounded )", "docstring_tokens": "Creates a percentage string representation from the given number . The number is multiplied by 100 before adding a % character .", "label": 0}, {"idx": "cosqa-train-2701", "doc": "python httpserver for production", "code": "def web(host, port):\n    \"\"\"Start web application\"\"\"\n    from .webserver.web import get_app\n    get_app().run(host=host, port=port)", "code_tokens": "def web ( host , port ) : from . webserver . web import get_app get_app ( ) . run ( host = host , port = port )", "docstring_tokens": "Start web application", "label": 0}, {"idx": "cosqa-train-2702", "doc": "python httpserver separate thread", "code": "def start(self):\n        \"\"\"Create a background thread for httpd and serve 'forever'\"\"\"\n        self._process = threading.Thread(target=self._background_runner)\n        self._process.start()", "code_tokens": "def start ( self ) : self . _process = threading . Thread ( target = self . _background_runner ) self . _process . start ( )", "docstring_tokens": "Create a background thread for httpd and serve forever", "label": 0}, {"idx": "cosqa-train-2703", "doc": "fourier transfrom of an array in python", "code": "def irfftn(a, s, axes=None):\n    \"\"\"\n    Compute the inverse of the multi-dimensional discrete Fourier transform\n    for real input. This function is a wrapper for\n    :func:`pyfftw.interfaces.numpy_fft.irfftn`, with an interface similar to\n    that of :func:`numpy.fft.irfftn`.\n\n    Parameters\n    ----------\n    a : array_like\n      Input array\n    s : sequence of ints\n      Shape of the output along each transformed axis (input is cropped or\n      zero-padded to match). This parameter is not optional because, unlike\n      :func:`ifftn`, the output shape cannot be uniquely determined from\n      the input shape.\n    axes : sequence of ints, optional (default None)\n      Axes over which to compute the inverse DFT.\n\n    Returns\n    -------\n    af : ndarray\n      Inverse DFT of input array\n    \"\"\"\n\n    return pyfftw.interfaces.numpy_fft.irfftn(\n        a, s=s, axes=axes, overwrite_input=False,\n        planner_effort='FFTW_MEASURE', threads=pyfftw_threads)", "code_tokens": "def irfftn ( a , s , axes = None ) : return pyfftw . interfaces . numpy_fft . irfftn ( a , s = s , axes = axes , overwrite_input = False , planner_effort = 'FFTW_MEASURE' , threads = pyfftw_threads )", "docstring_tokens": "Compute the inverse of the multi - dimensional discrete Fourier transform for real input . This function is a wrapper for : func : pyfftw . interfaces . numpy_fft . irfftn with an interface similar to that of : func : numpy . fft . irfftn .", "label": 0}, {"idx": "cosqa-train-2704", "doc": "python identify closest value to x in an array", "code": "def closest(xarr, val):\n    \"\"\" Return the index of the closest in xarr to value val \"\"\"\n    idx_closest = np.argmin(np.abs(np.array(xarr) - val))\n    return idx_closest", "code_tokens": "def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest", "docstring_tokens": "Return the index of the closest in xarr to value val", "label": 0}, {"idx": "cosqa-train-2705", "doc": "function in python that takes list and returns most common item", "code": "def _most_common(iterable):\n    \"\"\"Returns the most common element in `iterable`.\"\"\"\n    data = Counter(iterable)\n    return max(data, key=data.__getitem__)", "code_tokens": "def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )", "docstring_tokens": "Returns the most common element in iterable .", "label": 0}, {"idx": "cosqa-train-2706", "doc": "python identify empty cells in columns", "code": "def drop_empty(rows):\n    \"\"\"Transpose the columns into rows, remove all of the rows that are empty after the first cell, then\n    transpose back. The result is that columns that have a header but no data in the body are removed, assuming\n    the header is the first row. \"\"\"\n    return zip(*[col for col in zip(*rows) if bool(filter(bool, col[1:]))])", "code_tokens": "def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )", "docstring_tokens": "Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row .", "label": 0}, {"idx": "cosqa-train-2707", "doc": "function names in python lowercase", "code": "def to_snake_case(s):\n    \"\"\"Converts camel-case identifiers to snake-case.\"\"\"\n    return re.sub('([^_A-Z])([A-Z])', lambda m: m.group(1) + '_' + m.group(2).lower(), s)", "code_tokens": "def to_snake_case ( s ) : return re . sub ( '([^_A-Z])([A-Z])' , lambda m : m . group ( 1 ) + '_' + m . group ( 2 ) . lower ( ) , s )", "docstring_tokens": "Converts camel - case identifiers to snake - case .", "label": 0}, {"idx": "cosqa-train-2708", "doc": "python identify relative redirect http", "code": "def dereference_url(url):\n    \"\"\"\n    Makes a HEAD request to find the final destination of a URL after\n    following any redirects\n    \"\"\"\n    res = open_url(url, method='HEAD')\n    res.close()\n    return res.url", "code_tokens": "def dereference_url ( url ) : res = open_url ( url , method = 'HEAD' ) res . close ( ) return res . url", "docstring_tokens": "Makes a HEAD request to find the final destination of a URL after following any redirects", "label": 1}, {"idx": "cosqa-train-2709", "doc": "function of measuring time in python code", "code": "def speedtest(func, *args, **kwargs):\n    \"\"\" Test the speed of a function. \"\"\"\n    n = 100\n    start = time.time()\n    for i in range(n): func(*args,**kwargs)\n    end = time.time()\n    return (end-start)/n", "code_tokens": "def speedtest ( func , * args , * * kwargs ) : n = 100 start = time . time ( ) for i in range ( n ) : func ( * args , * * kwargs ) end = time . time ( ) return ( end - start ) / n", "docstring_tokens": "Test the speed of a function .", "label": 0}, {"idx": "cosqa-train-2710", "doc": "python if a value is not in an array", "code": "def isin(value, values):\n    \"\"\" Check that value is in values \"\"\"\n    for i, v in enumerate(value):\n        if v not in np.array(values)[:, i]:\n            return False\n    return True", "code_tokens": "def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True", "docstring_tokens": "Check that value is in values", "label": 0}, {"idx": "cosqa-train-2711", "doc": "function that converts string into a tuple in python", "code": "def ver_to_tuple(value):\n    \"\"\"\n    Convert version like string to a tuple of integers.\n    \"\"\"\n    return tuple(int(_f) for _f in re.split(r'\\D+', value) if _f)", "code_tokens": "def ver_to_tuple ( value ) : return tuple ( int ( _f ) for _f in re . split ( r'\\D+' , value ) if _f )", "docstring_tokens": "Convert version like string to a tuple of integers .", "label": 0}, {"idx": "cosqa-train-2712", "doc": "python if character is punctuation", "code": "def is_delimiter(line):\n    \"\"\" True if a line consists only of a single punctuation character.\"\"\"\n    return bool(line) and line[0] in punctuation and line[0]*len(line) == line", "code_tokens": "def is_delimiter ( line ) : return bool ( line ) and line [ 0 ] in punctuation and line [ 0 ] * len ( line ) == line", "docstring_tokens": "True if a line consists only of a single punctuation character .", "label": 0}, {"idx": "cosqa-train-2713", "doc": "generate random float between 1 and 10 python", "code": "def money(min=0, max=10):\n    \"\"\"Return a str of decimal with two digits after a decimal mark.\"\"\"\n    value = random.choice(range(min * 100, max * 100))\n    return \"%1.2f\" % (float(value) / 100)", "code_tokens": "def money ( min = 0 , max = 10 ) : value = random . choice ( range ( min * 100 , max * 100 ) ) return \"%1.2f\" % ( float ( value ) / 100 )", "docstring_tokens": "Return a str of decimal with two digits after a decimal mark .", "label": 0}, {"idx": "cosqa-train-2714", "doc": "python if float empty", "code": "def clean_float(v):\n    \"\"\"Remove commas from a float\"\"\"\n\n    if v is None or not str(v).strip():\n        return None\n\n    return float(str(v).replace(',', ''))", "code_tokens": "def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )", "docstring_tokens": "Remove commas from a float", "label": 0}, {"idx": "cosqa-train-2715", "doc": "generate random floats between 0 and 10 python", "code": "def money(min=0, max=10):\n    \"\"\"Return a str of decimal with two digits after a decimal mark.\"\"\"\n    value = random.choice(range(min * 100, max * 100))\n    return \"%1.2f\" % (float(value) / 100)", "code_tokens": "def money ( min = 0 , max = 10 ) : value = random . choice ( range ( min * 100 , max * 100 ) ) return \"%1.2f\" % ( float ( value ) / 100 )", "docstring_tokens": "Return a str of decimal with two digits after a decimal mark .", "label": 0}, {"idx": "cosqa-train-2716", "doc": "python if folder is empty, delete", "code": "def remove_examples_all():\n    \"\"\"remove arduino/examples/all directory.\n\n    :rtype: None\n\n    \"\"\"\n    d = examples_all_dir()\n    if d.exists():\n        log.debug('remove %s', d)\n        d.rmtree()\n    else:\n        log.debug('nothing to remove: %s', d)", "code_tokens": "def remove_examples_all ( ) : d = examples_all_dir ( ) if d . exists ( ) : log . debug ( 'remove %s' , d ) d . rmtree ( ) else : log . debug ( 'nothing to remove: %s' , d )", "docstring_tokens": "remove arduino / examples / all directory .", "label": 0}, {"idx": "cosqa-train-2717", "doc": "generate random letter sequences in python", "code": "def random_letters(n):\n    \"\"\"\n    Generate a random string from a-zA-Z\n    :param n: length of the string\n    :return: the random string\n    \"\"\"\n    return ''.join(random.SystemRandom().choice(string.ascii_letters) for _ in range(n))", "code_tokens": "def random_letters ( n ) : return '' . join ( random . SystemRandom ( ) . choice ( string . ascii_letters ) for _ in range ( n ) )", "docstring_tokens": "Generate a random string from a - zA - Z : param n : length of the string : return : the random string", "label": 0}, {"idx": "cosqa-train-2718", "doc": "python if nan then fill from other column", "code": "def _maybe_fill(arr, fill_value=np.nan):\n    \"\"\"\n    if we have a compatible fill_value and arr dtype, then fill\n    \"\"\"\n    if _isna_compat(arr, fill_value):\n        arr.fill(fill_value)\n    return arr", "code_tokens": "def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr", "docstring_tokens": "if we have a compatible fill_value and arr dtype then fill", "label": 0}, {"idx": "cosqa-train-2719", "doc": "generating sin wave with python", "code": "def sine_wave(frequency):\n  \"\"\"Emit a sine wave at the given frequency.\"\"\"\n  xs = tf.reshape(tf.range(_samples(), dtype=tf.float32), [1, _samples(), 1])\n  ts = xs / FLAGS.sample_rate\n  return tf.sin(2 * math.pi * frequency * ts)", "code_tokens": "def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )", "docstring_tokens": "Emit a sine wave at the given frequency .", "label": 0}, {"idx": "cosqa-train-2720", "doc": "python if only one of two files exist", "code": "def _file_and_exists(val, input_files):\n    \"\"\"Check if an input is a file and exists.\n\n    Checks both locally (staged) and from input files (re-passed but never localized).\n    \"\"\"\n    return ((os.path.exists(val) and os.path.isfile(val)) or\n            val in input_files)", "code_tokens": "def _file_and_exists ( val , input_files ) : return ( ( os . path . exists ( val ) and os . path . isfile ( val ) ) or val in input_files )", "docstring_tokens": "Check if an input is a file and exists .", "label": 0}, {"idx": "cosqa-train-2721", "doc": "get a byte by index from byte array in python not converted to int", "code": "def read_uint(data, start, length):\n    \"\"\"Extract a uint from a position in a sequence.\"\"\"\n    return int.from_bytes(data[start:start+length], byteorder='big')", "code_tokens": "def read_uint ( data , start , length ) : return int . from_bytes ( data [ start : start + length ] , byteorder = 'big' )", "docstring_tokens": "Extract a uint from a position in a sequence .", "label": 0}, {"idx": "cosqa-train-2722", "doc": "python if someone changes the file, remind me", "code": "def example_write_file_to_disk_if_changed():\n    \"\"\" Try to remove all comments from a file, and save it if changes were made. \"\"\"\n    my_file = FileAsObj('/tmp/example_file.txt')\n    my_file.rm(my_file.egrep('^#'))\n    if my_file.changed:\n        my_file.save()", "code_tokens": "def example_write_file_to_disk_if_changed ( ) : my_file = FileAsObj ( '/tmp/example_file.txt' ) my_file . rm ( my_file . egrep ( '^#' ) ) if my_file . changed : my_file . save ( )", "docstring_tokens": "Try to remove all comments from a file and save it if changes were made .", "label": 0}, {"idx": "cosqa-train-2723", "doc": "get absolute path of file being called from script python", "code": "def rel_path(filename):\n    \"\"\"\n    Function that gets relative path to the filename\n    \"\"\"\n    return os.path.join(os.getcwd(), os.path.dirname(__file__), filename)", "code_tokens": "def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )", "docstring_tokens": "Function that gets relative path to the filename", "label": 0}, {"idx": "cosqa-train-2724", "doc": "python if string is hex", "code": "def is_hex_string(string):\n    \"\"\"Check if the string is only composed of hex characters.\"\"\"\n    pattern = re.compile(r'[A-Fa-f0-9]+')\n    if isinstance(string, six.binary_type):\n        string = str(string)\n    return pattern.match(string) is not None", "code_tokens": "def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None", "docstring_tokens": "Check if the string is only composed of hex characters .", "label": 0}, {"idx": "cosqa-train-2725", "doc": "get all days between two dates python", "code": "def dates_in_range(start_date, end_date):\n    \"\"\"Returns all dates between two dates.\n\n    Inclusive of the start date but not the end date.\n\n    Args:\n        start_date (datetime.date)\n        end_date (datetime.date)\n\n    Returns:\n        (list) of datetime.date objects\n    \"\"\"\n    return [\n        start_date + timedelta(n)\n        for n in range(int((end_date - start_date).days))\n    ]", "code_tokens": "def dates_in_range ( start_date , end_date ) : return [ start_date + timedelta ( n ) for n in range ( int ( ( end_date - start_date ) . days ) ) ]", "docstring_tokens": "Returns all dates between two dates .", "label": 0}, {"idx": "cosqa-train-2726", "doc": "python if variable is str", "code": "def chkstr(s, v):\n    \"\"\"\n    Small routine for checking whether a string is empty\n    even a string\n\n    :param s: the string in question\n    :param v: variable name\n    \"\"\"\n    if type(s) != str:\n        raise TypeError(\"{var} must be str\".format(var=v))\n    if not s:\n        raise ValueError(\"{var} cannot be empty\".format(var=v))", "code_tokens": "def chkstr ( s , v ) : if type ( s ) != str : raise TypeError ( \"{var} must be str\" . format ( var = v ) ) if not s : raise ValueError ( \"{var} cannot be empty\" . format ( var = v ) )", "docstring_tokens": "Small routine for checking whether a string is empty even a string", "label": 0}, {"idx": "cosqa-train-2727", "doc": "get all loggers python", "code": "def _get_loggers():\n    \"\"\"Return list of Logger classes.\"\"\"\n    from .. import loader\n    modules = loader.get_package_modules('logger')\n    return list(loader.get_plugins(modules, [_Logger]))", "code_tokens": "def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )", "docstring_tokens": "Return list of Logger classes .", "label": 0}, {"idx": "cosqa-train-2728", "doc": "python image crop getbbox white", "code": "def crop_box(im, box=False, **kwargs):\n    \"\"\"Uses box coordinates to crop an image without resizing it first.\"\"\"\n    if box:\n        im = im.crop(box)\n    return im", "code_tokens": "def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im", "docstring_tokens": "Uses box coordinates to crop an image without resizing it first .", "label": 0}, {"idx": "cosqa-train-2729", "doc": "get basename from url python", "code": "def get_url_file_name(url):\n    \"\"\"Get the file name from an url\n    \n    Parameters\n    ----------\n    url : str\n\n    Returns\n    -------\n    str\n        The file name \n    \"\"\"\n\n    assert isinstance(url, (str, _oldstr))\n    return urlparse.urlparse(url).path.split('/')[-1]", "code_tokens": "def get_url_file_name ( url ) : assert isinstance ( url , ( str , _oldstr ) ) return urlparse . urlparse ( url ) . path . split ( '/' ) [ - 1 ]", "docstring_tokens": "Get the file name from an url Parameters ---------- url : str", "label": 0}, {"idx": "cosqa-train-2730", "doc": "python image intensity scale show", "code": "def extent(self):\n        \"\"\"Helper for matplotlib imshow\"\"\"\n        return (\n            self.intervals[1].pix1 - 0.5,\n            self.intervals[1].pix2 - 0.5,\n            self.intervals[0].pix1 - 0.5,\n            self.intervals[0].pix2 - 0.5,\n        )", "code_tokens": "def extent ( self ) : return ( self . intervals [ 1 ] . pix1 - 0.5 , self . intervals [ 1 ] . pix2 - 0.5 , self . intervals [ 0 ] . pix1 - 0.5 , self . intervals [ 0 ] . pix2 - 0.5 , )", "docstring_tokens": "Helper for matplotlib imshow", "label": 0}, {"idx": "cosqa-train-2731", "doc": "python image mirror enlarge", "code": "def resize(self, size):\n        \"\"\"Return a new Image instance with the given size.\"\"\"\n        return Image(self.pil_image.resize(size, PIL.Image.ANTIALIAS))", "code_tokens": "def resize ( self , size ) : return Image ( self . pil_image . resize ( size , PIL . Image . ANTIALIAS ) )", "docstring_tokens": "Return a new Image instance with the given size .", "label": 0}, {"idx": "cosqa-train-2732", "doc": "get current time string python", "code": "def now_time(str=False):\n    \"\"\"Get the current time.\"\"\"\n    if str:\n        return datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    return datetime.datetime.now()", "code_tokens": "def now_time ( str = False ) : if str : return datetime . datetime . now ( ) . strftime ( \"%Y-%m-%d %H:%M:%S\" ) return datetime . datetime . now ( )", "docstring_tokens": "Get the current time .", "label": 0}, {"idx": "cosqa-train-2733", "doc": "get date from string date python", "code": "def get_date(date):\n    \"\"\"\n    Get the date from a value that could be a date object or a string.\n\n    :param date: The date object or string.\n\n    :returns: The date object.\n    \"\"\"\n    if type(date) is str:\n        return datetime.strptime(date, '%Y-%m-%d').date()\n    else:\n        return date", "code_tokens": "def get_date ( date ) : if type ( date ) is str : return datetime . strptime ( date , '%Y-%m-%d' ) . date ( ) else : return date", "docstring_tokens": "Get the date from a value that could be a date object or a string .", "label": 1}, {"idx": "cosqa-train-2734", "doc": "python image shape detection", "code": "def get_shape(img):\n    \"\"\"Return the shape of img.\n\n    Paramerers\n    -----------\n    img:\n\n    Returns\n    -------\n    shape: tuple\n    \"\"\"\n    if hasattr(img, 'shape'):\n        shape = img.shape\n    else:\n        shape = img.get_data().shape\n    return shape", "code_tokens": "def get_shape ( img ) : if hasattr ( img , 'shape' ) : shape = img . shape else : shape = img . get_data ( ) . shape return shape", "docstring_tokens": "Return the shape of img .", "label": 0}, {"idx": "cosqa-train-2735", "doc": "python include files in a sibling folder", "code": "def setup_path():\n    \"\"\"Sets up the python include paths to include src\"\"\"\n    import os.path; import sys\n\n    if sys.argv[0]:\n        top_dir = os.path.dirname(os.path.abspath(sys.argv[0]))\n        sys.path = [os.path.join(top_dir, \"src\")] + sys.path\n        pass\n    return", "code_tokens": "def setup_path ( ) : import os . path import sys if sys . argv [ 0 ] : top_dir = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ] ) ) sys . path = [ os . path . join ( top_dir , \"src\" ) ] + sys . path pass return", "docstring_tokens": "Sets up the python include paths to include src", "label": 0}, {"idx": "cosqa-train-2736", "doc": "get first date from month in python", "code": "def monthly(date=datetime.date.today()):\n    \"\"\"\n    Take a date object and return the first day of the month.\n    \"\"\"\n    return datetime.date(date.year, date.month, 1)", "code_tokens": "def monthly ( date = datetime . date . today ( ) ) : return datetime . date ( date . year , date . month , 1 )", "docstring_tokens": "Take a date object and return the first day of the month .", "label": 0}, {"idx": "cosqa-train-2737", "doc": "python increase file size padding", "code": "def write_padding(fp, size, divisor=2):\n    \"\"\"\n    Writes padding bytes given the currently written size.\n\n    :param fp: file-like object\n    :param divisor: divisor of the byte alignment\n    :return: written byte size\n    \"\"\"\n    remainder = size % divisor\n    if remainder:\n        return write_bytes(fp, struct.pack('%dx' % (divisor - remainder)))\n    return 0", "code_tokens": "def write_padding ( fp , size , divisor = 2 ) : remainder = size % divisor if remainder : return write_bytes ( fp , struct . pack ( '%dx' % ( divisor - remainder ) ) ) return 0", "docstring_tokens": "Writes padding bytes given the currently written size .", "label": 0}, {"idx": "cosqa-train-2738", "doc": "get first element of a filter python", "code": "def findfirst(f, coll):\n    \"\"\"Return first occurrence matching f, otherwise None\"\"\"\n    result = list(dropwhile(f, coll))\n    return result[0] if result else None", "code_tokens": "def findfirst ( f , coll ) : result = list ( dropwhile ( f , coll ) ) return result [ 0 ] if result else None", "docstring_tokens": "Return first occurrence matching f otherwise None", "label": 0}, {"idx": "cosqa-train-2739", "doc": "python increase value of key", "code": "def incr(self, key, incr_by=1):\n        \"\"\"Increment the key by the given amount.\"\"\"\n        return self.database.hincrby(self.key, key, incr_by)", "code_tokens": "def incr ( self , key , incr_by = 1 ) : return self . database . hincrby ( self . key , key , incr_by )", "docstring_tokens": "Increment the key by the given amount .", "label": 0}, {"idx": "cosqa-train-2740", "doc": "get fitted values of ols python", "code": "def fit_linear(X, y):\n    \"\"\"\n    Uses OLS to fit the regression.\n    \"\"\"\n    model = linear_model.LinearRegression()\n    model.fit(X, y)\n    return model", "code_tokens": "def fit_linear ( X , y ) : model = linear_model . LinearRegression ( ) model . fit ( X , y ) return model", "docstring_tokens": "Uses OLS to fit the regression .", "label": 0}, {"idx": "cosqa-train-2741", "doc": "python index specific value in data frame", "code": "def idx(df, index):\n    \"\"\"Universal indexing for numpy and pandas objects.\"\"\"\n    if isinstance(df, (pd.DataFrame, pd.Series)):\n        return df.iloc[index]\n    else:\n        return df[index, :]", "code_tokens": "def idx ( df , index ) : if isinstance ( df , ( pd . DataFrame , pd . Series ) ) : return df . iloc [ index ] else : return df [ index , : ]", "docstring_tokens": "Universal indexing for numpy and pandas objects .", "label": 0}, {"idx": "cosqa-train-2742", "doc": "get frequencies for column in python", "code": "def col_frequencies(col, weights=None, gap_chars='-.'):\n    \"\"\"Frequencies of each residue type (totaling 1.0) in a single column.\"\"\"\n    counts = col_counts(col, weights, gap_chars)\n    # Reduce to frequencies\n    scale = 1.0 / sum(counts.values())\n    return dict((aa, cnt * scale) for aa, cnt in counts.iteritems())", "code_tokens": "def col_frequencies ( col , weights = None , gap_chars = '-.' ) : counts = col_counts ( col , weights , gap_chars ) # Reduce to frequencies scale = 1.0 / sum ( counts . values ( ) ) return dict ( ( aa , cnt * scale ) for aa , cnt in counts . iteritems ( ) )", "docstring_tokens": "Frequencies of each residue type ( totaling 1 . 0 ) in a single column .", "label": 0}, {"idx": "cosqa-train-2743", "doc": "python initialize logging config", "code": "def ServerLoggingStartupInit():\n  \"\"\"Initialize the server logging configuration.\"\"\"\n  global LOGGER\n  if local_log:\n    logging.debug(\"Using local LogInit from %s\", local_log)\n    local_log.LogInit()\n    logging.debug(\"Using local AppLogInit from %s\", local_log)\n    LOGGER = local_log.AppLogInit()\n  else:\n    LogInit()\n    LOGGER = AppLogInit()", "code_tokens": "def ServerLoggingStartupInit ( ) : global LOGGER if local_log : logging . debug ( \"Using local LogInit from %s\" , local_log ) local_log . LogInit ( ) logging . debug ( \"Using local AppLogInit from %s\" , local_log ) LOGGER = local_log . AppLogInit ( ) else : LogInit ( ) LOGGER = AppLogInit ( )", "docstring_tokens": "Initialize the server logging configuration .", "label": 0}, {"idx": "cosqa-train-2744", "doc": "get glortho matrix opengl python", "code": "def matrix_to_gl(matrix):\n    \"\"\"\n    Convert a numpy row- major homogenous transformation matrix\n    to a flat column- major GLfloat transformation.\n\n    Parameters\n    -------------\n    matrix : (4,4) float\n      Row- major homogenous transform\n\n    Returns\n    -------------\n    glmatrix : (16,) gl.GLfloat\n      Transform in pyglet format\n    \"\"\"\n    matrix = np.asanyarray(matrix, dtype=np.float64)\n    if matrix.shape != (4, 4):\n        raise ValueError('matrix must be (4,4)!')\n\n    # switch to column major and flatten to (16,)\n    column = matrix.T.flatten()\n    # convert to GLfloat\n    glmatrix = (gl.GLfloat * 16)(*column)\n\n    return glmatrix", "code_tokens": "def matrix_to_gl ( matrix ) : matrix = np . asanyarray ( matrix , dtype = np . float64 ) if matrix . shape != ( 4 , 4 ) : raise ValueError ( 'matrix must be (4,4)!' ) # switch to column major and flatten to (16,) column = matrix . T . flatten ( ) # convert to GLfloat glmatrix = ( gl . GLfloat * 16 ) ( * column ) return glmatrix", "docstring_tokens": "Convert a numpy row - major homogenous transformation matrix to a flat column - major GLfloat transformation .", "label": 1}, {"idx": "cosqa-train-2745", "doc": "get http header python flask", "code": "def get_trace_id_from_flask():\n    \"\"\"Get trace_id from flask request headers.\n\n    :rtype: str\n    :returns: TraceID in HTTP request headers.\n    \"\"\"\n    if flask is None or not flask.request:\n        return None\n\n    header = flask.request.headers.get(_FLASK_TRACE_HEADER)\n\n    if header is None:\n        return None\n\n    trace_id = header.split(\"/\", 1)[0]\n\n    return trace_id", "code_tokens": "def get_trace_id_from_flask ( ) : if flask is None or not flask . request : return None header = flask . request . headers . get ( _FLASK_TRACE_HEADER ) if header is None : return None trace_id = header . split ( \"/\" , 1 ) [ 0 ] return trace_id", "docstring_tokens": "Get trace_id from flask request headers .", "label": 0}, {"idx": "cosqa-train-2746", "doc": "python input is not a tty", "code": "def intty(cls):\n        \"\"\" Check if we are in a tty. \"\"\"\n        # XXX: temporary hack until we can detect if we are in a pipe or not\n        return True\n\n        if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty():\n            return True\n\n        return False", "code_tokens": "def intty ( cls ) : # XXX: temporary hack until we can detect if we are in a pipe or not return True if hasattr ( sys . stdout , 'isatty' ) and sys . stdout . isatty ( ) : return True return False", "docstring_tokens": "Check if we are in a tty .", "label": 0}, {"idx": "cosqa-train-2747", "doc": "get index from key at python", "code": "def wrap_key(self, key):\n        \"\"\"Translate the key into the central cell\n\n           This method is only applicable in case of a periodic system.\n        \"\"\"\n        return tuple(np.round(\n            self.integer_cell.shortest_vector(key)\n        ).astype(int))", "code_tokens": "def wrap_key ( self , key ) : return tuple ( np . round ( self . integer_cell . shortest_vector ( key ) ) . astype ( int ) )", "docstring_tokens": "Translate the key into the central cell", "label": 0}, {"idx": "cosqa-train-2748", "doc": "python input without blocking", "code": "async def async_input(prompt):\n    \"\"\"\n    Python's ``input()`` is blocking, which means the event loop we set\n    above can't be running while we're blocking there. This method will\n    let the loop run while we wait for input.\n    \"\"\"\n    print(prompt, end='', flush=True)\n    return (await loop.run_in_executor(None, sys.stdin.readline)).rstrip()", "code_tokens": "async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "docstring_tokens": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input .", "label": 1}, {"idx": "cosqa-train-2749", "doc": "get index of iterator python", "code": "def index(self, elem):\n        \"\"\"Find the index of elem in the reversed iterator.\"\"\"\n        return _coconut.len(self._iter) - self._iter.index(elem) - 1", "code_tokens": "def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1", "docstring_tokens": "Find the index of elem in the reversed iterator .", "label": 1}, {"idx": "cosqa-train-2750", "doc": "python insert delimiters in a list", "code": "def linedelimited (inlist,delimiter):\n    \"\"\"\nReturns a string composed of elements in inlist, with each element\nseparated by 'delimiter.'  Used by function writedelimited.  Use '\\t'\nfor tab-delimiting.\n\nUsage:   linedelimited (inlist,delimiter)\n\"\"\"\n    outstr = ''\n    for item in inlist:\n        if type(item) != StringType:\n            item = str(item)\n        outstr = outstr + item + delimiter\n    outstr = outstr[0:-1]\n    return outstr", "code_tokens": "def linedelimited ( inlist , delimiter ) : outstr = '' for item in inlist : if type ( item ) != StringType : item = str ( item ) outstr = outstr + item + delimiter outstr = outstr [ 0 : - 1 ] return outstr", "docstring_tokens": "Returns a string composed of elements in inlist with each element separated by delimiter . Used by function writedelimited . Use \\ t for tab - delimiting .", "label": 0}, {"idx": "cosqa-train-2751", "doc": "get indices of an array python", "code": "def get_inputs_from_cm(index, cm):\n    \"\"\"Return indices of inputs to the node with the given index.\"\"\"\n    return tuple(i for i in range(cm.shape[0]) if cm[i][index])", "code_tokens": "def get_inputs_from_cm ( index , cm ) : return tuple ( i for i in range ( cm . shape [ 0 ] ) if cm [ i ] [ index ] )", "docstring_tokens": "Return indices of inputs to the node with the given index .", "label": 1}, {"idx": "cosqa-train-2752", "doc": "python insert image pdf", "code": "def main(filename):\n    \"\"\"\n    Creates a PDF by embedding the first page from the given image and\n    writes some text to it.\n\n    @param[in] filename\n        The source filename of the image to embed.\n    \"\"\"\n\n    # Prepare font.\n    font_family = 'arial'\n    font = Font(font_family, bold=True)\n    if not font:\n        raise RuntimeError('No font found for %r' % font_family)\n\n    # Initialize PDF document on a stream.\n    with Document('output.pdf') as document:\n\n        # Initialize a new page and begin its context.\n        with document.Page() as ctx:\n\n            # Open the image to embed.\n            with Image(filename) as embed:\n\n                # Set the media box for the page to the same as the\n                # image to embed.\n                ctx.box = embed.box\n\n                # Embed the image.\n                ctx.embed(embed)\n\n            # Write some text.\n            ctx.add(Text('Hello World', font, size=14, x=100, y=60))", "code_tokens": "def main ( filename ) : # Prepare font. font_family = 'arial' font = Font ( font_family , bold = True ) if not font : raise RuntimeError ( 'No font found for %r' % font_family ) # Initialize PDF document on a stream. with Document ( 'output.pdf' ) as document : # Initialize a new page and begin its context. with document . Page ( ) as ctx : # Open the image to embed. with Image ( filename ) as embed : # Set the media box for the page to the same as the # image to embed. ctx . box = embed . box # Embed the image. ctx . embed ( embed ) # Write some text. ctx . add ( Text ( 'Hello World' , font , size = 14 , x = 100 , y = 60 ) )", "docstring_tokens": "Creates a PDF by embedding the first page from the given image and writes some text to it .", "label": 0}, {"idx": "cosqa-train-2753", "doc": "get indices of reverse sorted matrix in python", "code": "def _index_ordering(redshift_list):\n        \"\"\"\n\n        :param redshift_list: list of redshifts\n        :return: indexes in acending order to be evaluated (from z=0 to z=z_source)\n        \"\"\"\n        redshift_list = np.array(redshift_list)\n        sort_index = np.argsort(redshift_list)\n        return sort_index", "code_tokens": "def _index_ordering ( redshift_list ) : redshift_list = np . array ( redshift_list ) sort_index = np . argsort ( redshift_list ) return sort_index", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-2754", "doc": "python instance to return a product of 2 numbers", "code": "def __mul__(self, other):\n        \"\"\"Handle the `*` operator.\"\"\"\n        return self._handle_type(other)(self.value * other.value)", "code_tokens": "def __mul__ ( self , other ) : return self . _handle_type ( other ) ( self . value * other . value )", "docstring_tokens": "Handle the * operator .", "label": 0}, {"idx": "cosqa-train-2755", "doc": "get ipdaddress of machine python", "code": "def get_own_ip():\n    \"\"\"Get the host's ip number.\n    \"\"\"\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    try:\n        sock.connect((\"8.8.8.8\", 80))\n    except socket.gaierror:\n        ip_ = \"127.0.0.1\"\n    else:\n        ip_ = sock.getsockname()[0]\n    finally:\n        sock.close()\n    return ip_", "code_tokens": "def get_own_ip ( ) : sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) try : sock . connect ( ( \"8.8.8.8\" , 80 ) ) except socket . gaierror : ip_ = \"127.0.0.1\" else : ip_ = sock . getsockname ( ) [ 0 ] finally : sock . close ( ) return ip_", "docstring_tokens": "Get the host s ip number .", "label": 0}, {"idx": "cosqa-train-2756", "doc": "python int from bytes signed", "code": "def bin_to_int(string):\n    \"\"\"Convert a one element byte string to signed int for python 2 support.\"\"\"\n    if isinstance(string, str):\n        return struct.unpack(\"b\", string)[0]\n    else:\n        return struct.unpack(\"b\", bytes([string]))[0]", "code_tokens": "def bin_to_int ( string ) : if isinstance ( string , str ) : return struct . unpack ( \"b\" , string ) [ 0 ] else : return struct . unpack ( \"b\" , bytes ( [ string ] ) ) [ 0 ]", "docstring_tokens": "Convert a one element byte string to signed int for python 2 support .", "label": 1}, {"idx": "cosqa-train-2757", "doc": "get last item of iterator python", "code": "def end_index(self):\n        \"\"\"\n        Returns the 1-based index of the last object on this page,\n        relative to total objects found (hits).\n        \"\"\"\n        return ((self.number - 1) * self.paginator.per_page +\n            len(self.object_list))", "code_tokens": "def end_index ( self ) : return ( ( self . number - 1 ) * self . paginator . per_page + len ( self . object_list ) )", "docstring_tokens": "Returns the 1 - based index of the last object on this page relative to total objects found ( hits ) .", "label": 0}, {"idx": "cosqa-train-2758", "doc": "get last monday python", "code": "def prevmonday(num):\n    \"\"\"\n    Return unix SECOND timestamp of \"num\" mondays ago\n    \"\"\"\n    today = get_today()\n    lastmonday = today - timedelta(days=today.weekday(), weeks=num)\n    return lastmonday", "code_tokens": "def prevmonday ( num ) : today = get_today ( ) lastmonday = today - timedelta ( days = today . weekday ( ) , weeks = num ) return lastmonday", "docstring_tokens": "Return unix SECOND timestamp of num mondays ago", "label": 0}, {"idx": "cosqa-train-2759", "doc": "get length of queue python", "code": "def qsize(self):\n        \"\"\"Return the approximate size of the queue (not reliable!).\"\"\"\n        self.mutex.acquire()\n        n = self._qsize()\n        self.mutex.release()\n        return n", "code_tokens": "def qsize ( self ) : self . mutex . acquire ( ) n = self . _qsize ( ) self . mutex . release ( ) return n", "docstring_tokens": "Return the approximate size of the queue ( not reliable! ) .", "label": 0}, {"idx": "cosqa-train-2760", "doc": "python integer max value how to present", "code": "def max(self):\n        \"\"\"\n        Returns the maximum value of the domain.\n\n        :rtype: `float` or `np.inf`\n        \"\"\"\n        return int(self._max) if not np.isinf(self._max) else self._max", "code_tokens": "def max ( self ) : return int ( self . _max ) if not np . isinf ( self . _max ) else self . _max", "docstring_tokens": "Returns the maximum value of the domain .", "label": 0}, {"idx": "cosqa-train-2761", "doc": "get line without newline character python", "code": "def get_line_ending(line):\n    \"\"\"Return line ending.\"\"\"\n    non_whitespace_index = len(line.rstrip()) - len(line)\n    if not non_whitespace_index:\n        return ''\n    else:\n        return line[non_whitespace_index:]", "code_tokens": "def get_line_ending ( line ) : non_whitespace_index = len ( line . rstrip ( ) ) - len ( line ) if not non_whitespace_index : return '' else : return line [ non_whitespace_index : ]", "docstring_tokens": "Return line ending .", "label": 0}, {"idx": "cosqa-train-2762", "doc": "python interploating a key from a dict", "code": "def subkey(dct, keys):\n    \"\"\"Get an entry from a dict of dicts by the list of keys to 'follow'\n    \"\"\"\n    key = keys[0]\n    if len(keys) == 1:\n        return dct[key]\n    return subkey(dct[key], keys[1:])", "code_tokens": "def subkey ( dct , keys ) : key = keys [ 0 ] if len ( keys ) == 1 : return dct [ key ] return subkey ( dct [ key ] , keys [ 1 : ] )", "docstring_tokens": "Get an entry from a dict of dicts by the list of keys to follow", "label": 0}, {"idx": "cosqa-train-2763", "doc": "get list of collections names in mongo db from python", "code": "def all_collections(db):\n\t\"\"\"\n\tYield all non-sytem collections in db.\n\t\"\"\"\n\tinclude_pattern = r'(?!system\\.)'\n\treturn (\n\t\tdb[name]\n\t\tfor name in db.list_collection_names()\n\t\tif re.match(include_pattern, name)\n\t)", "code_tokens": "def all_collections ( db ) : include_pattern = r'(?!system\\.)' return ( db [ name ] for name in db . list_collection_names ( ) if re . match ( include_pattern , name ) )", "docstring_tokens": "Yield all non - sytem collections in db .", "label": 0}, {"idx": "cosqa-train-2764", "doc": "python interpolate periodic y coordinates", "code": "def lin_interp(x, rangeX, rangeY):\n    \"\"\"\n    Interpolate linearly variable x in rangeX onto rangeY.\n    \"\"\"\n    s = (x - rangeX[0]) / mag(rangeX[1] - rangeX[0])\n    y = rangeY[0] * (1 - s) + rangeY[1] * s\n    return y", "code_tokens": "def lin_interp ( x , rangeX , rangeY ) : s = ( x - rangeX [ 0 ] ) / mag ( rangeX [ 1 ] - rangeX [ 0 ] ) y = rangeY [ 0 ] * ( 1 - s ) + rangeY [ 1 ] * s return y", "docstring_tokens": "Interpolate linearly variable x in rangeX onto rangeY .", "label": 0}, {"idx": "cosqa-train-2765", "doc": "get local address python", "code": "def _get_local_ip():\n        \"\"\"\n        Get the local ip of this device\n\n        :return: Ip of this computer\n        :rtype: str\n        \"\"\"\n        return set([x[4][0] for x in socket.getaddrinfo(\n            socket.gethostname(),\n            80,\n            socket.AF_INET\n        )]).pop()", "code_tokens": "def _get_local_ip ( ) : return set ( [ x [ 4 ] [ 0 ] for x in socket . getaddrinfo ( socket . gethostname ( ) , 80 , socket . AF_INET ) ] ) . pop ( )", "docstring_tokens": "Get the local ip of this device", "label": 1}, {"idx": "cosqa-train-2766", "doc": "python interpolates x axis timestamp", "code": "def spline_interpolate_by_datetime(datetime_axis, y_axis, datetime_new_axis):\n    \"\"\"A datetime-version that takes datetime object list as x_axis\n    \"\"\"\n    numeric_datetime_axis = [\n        totimestamp(a_datetime) for a_datetime in datetime_axis\n    ]\n\n    numeric_datetime_new_axis = [\n        totimestamp(a_datetime) for a_datetime in datetime_new_axis\n    ]\n\n    return spline_interpolate(\n        numeric_datetime_axis, y_axis, numeric_datetime_new_axis)", "code_tokens": "def spline_interpolate_by_datetime ( datetime_axis , y_axis , datetime_new_axis ) : numeric_datetime_axis = [ totimestamp ( a_datetime ) for a_datetime in datetime_axis ] numeric_datetime_new_axis = [ totimestamp ( a_datetime ) for a_datetime in datetime_new_axis ] return spline_interpolate ( numeric_datetime_axis , y_axis , numeric_datetime_new_axis )", "docstring_tokens": "A datetime - version that takes datetime object list as x_axis", "label": 1}, {"idx": "cosqa-train-2767", "doc": "get most recent file in directory python linux", "code": "def get_last_modified_timestamp(self):\n        \"\"\"\n        Looks at the files in a git root directory and grabs the last modified timestamp\n        \"\"\"\n        cmd = \"find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '\"\n        ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        output = ps.communicate()[0]\n        print output", "code_tokens": "def get_last_modified_timestamp ( self ) : cmd = \"find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '\" ps = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) output = ps . communicate ( ) [ 0 ] print output", "docstring_tokens": "Looks at the files in a git root directory and grabs the last modified timestamp", "label": 0}, {"idx": "cosqa-train-2768", "doc": "python intersection of 3d lines", "code": "def intersect_3d(p1, p2):\n    \"\"\"Find the closes point for a given set of lines in 3D.\n\n    Parameters\n    ----------\n    p1 : (M, N) array_like\n        Starting points\n    p2 : (M, N) array_like\n        End points.\n\n    Returns\n    -------\n    x : (N,) ndarray\n        Least-squares solution - the closest point of the intersections.\n\n    Raises\n    ------\n    numpy.linalg.LinAlgError\n        If computation does not converge.\n\n    \"\"\"\n    v = p2 - p1\n    normed_v = unit_vector(v)\n    nx = normed_v[:, 0]\n    ny = normed_v[:, 1]\n    nz = normed_v[:, 2]\n    xx = np.sum(nx**2 - 1)\n    yy = np.sum(ny**2 - 1)\n    zz = np.sum(nz**2 - 1)\n    xy = np.sum(nx * ny)\n    xz = np.sum(nx * nz)\n    yz = np.sum(ny * nz)\n    M = np.array([(xx, xy, xz), (xy, yy, yz), (xz, yz, zz)])\n    x = np.sum(\n        p1[:, 0] * (nx**2 - 1) + p1[:, 1] * (nx * ny) + p1[:, 2] * (nx * nz)\n    )\n    y = np.sum(\n        p1[:, 0] * (nx * ny) + p1[:, 1] * (ny * ny - 1) + p1[:, 2] * (ny * nz)\n    )\n    z = np.sum(\n        p1[:, 0] * (nx * nz) + p1[:, 1] * (ny * nz) + p1[:, 2] * (nz**2 - 1)\n    )\n    return np.linalg.lstsq(M, np.array((x, y, z)), rcond=None)[0]", "code_tokens": "def intersect_3d ( p1 , p2 ) : v = p2 - p1 normed_v = unit_vector ( v ) nx = normed_v [ : , 0 ] ny = normed_v [ : , 1 ] nz = normed_v [ : , 2 ] xx = np . sum ( nx ** 2 - 1 ) yy = np . sum ( ny ** 2 - 1 ) zz = np . sum ( nz ** 2 - 1 ) xy = np . sum ( nx * ny ) xz = np . sum ( nx * nz ) yz = np . sum ( ny * nz ) M = np . array ( [ ( xx , xy , xz ) , ( xy , yy , yz ) , ( xz , yz , zz ) ] ) x = np . sum ( p1 [ : , 0 ] * ( nx ** 2 - 1 ) + p1 [ : , 1 ] * ( nx * ny ) + p1 [ : , 2 ] * ( nx * nz ) ) y = np . sum ( p1 [ : , 0 ] * ( nx * ny ) + p1 [ : , 1 ] * ( ny * ny - 1 ) + p1 [ : , 2 ] * ( ny * nz ) ) z = np . sum ( p1 [ : , 0 ] * ( nx * nz ) + p1 [ : , 1 ] * ( ny * nz ) + p1 [ : , 2 ] * ( nz ** 2 - 1 ) ) return np . linalg . lstsq ( M , np . array ( ( x , y , z ) ) , rcond = None ) [ 0 ]", "docstring_tokens": "Find the closes point for a given set of lines in 3D .", "label": 0}, {"idx": "cosqa-train-2769", "doc": "get n and n+1 elements from a list in python 3", "code": "def chunk_list(l, n):\n    \"\"\"Return `n` size lists from a given list `l`\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Return n size lists from a given list l", "label": 0}, {"idx": "cosqa-train-2770", "doc": "python is arraybyte or not", "code": "def is_sequence(obj):\n    \"\"\"Check if `obj` is a sequence, but not a string or bytes.\"\"\"\n    return isinstance(obj, Sequence) and not (\n        isinstance(obj, str) or BinaryClass.is_valid_type(obj))", "code_tokens": "def is_sequence ( obj ) : return isinstance ( obj , Sequence ) and not ( isinstance ( obj , str ) or BinaryClass . is_valid_type ( obj ) )", "docstring_tokens": "Check if obj is a sequence but not a string or bytes .", "label": 0}, {"idx": "cosqa-train-2771", "doc": "get number of days in year in python", "code": "def gday_of_year(self):\n        \"\"\"Return the number of days since January 1 of the given year.\"\"\"\n        return (self.date - dt.date(self.date.year, 1, 1)).days", "code_tokens": "def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days", "docstring_tokens": "Return the number of days since January 1 of the given year .", "label": 0}, {"idx": "cosqa-train-2772", "doc": "get number of rows of data frame python", "code": "def count_(self):\n        \"\"\"\n        Returns the number of rows of the main dataframe\n        \"\"\"\n        try:\n            num = len(self.df.index)\n        except Exception as e:\n            self.err(e, \"Can not count data\")\n            return\n        return num", "code_tokens": "def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , \"Can not count data\" ) return return num", "docstring_tokens": "Returns the number of rows of the main dataframe", "label": 0}, {"idx": "cosqa-train-2773", "doc": "python is randint(a,b) a uniform distribution", "code": "def runiform(lower, upper, size=None):\n    \"\"\"\n    Random uniform variates.\n    \"\"\"\n    return np.random.uniform(lower, upper, size)", "code_tokens": "def runiform ( lower , upper , size = None ) : return np . random . uniform ( lower , upper , size )", "docstring_tokens": "Random uniform variates .", "label": 0}, {"idx": "cosqa-train-2774", "doc": "get output from a linux command in python", "code": "def _run_cmd_get_output(cmd):\n    \"\"\"Runs a shell command, returns console output.\n\n    Mimics python3's subprocess.getoutput\n    \"\"\"\n    process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)\n    out, err = process.communicate()\n    return out or err", "code_tokens": "def _run_cmd_get_output ( cmd ) : process = subprocess . Popen ( cmd . split ( ) , stdout = subprocess . PIPE ) out , err = process . communicate ( ) return out or err", "docstring_tokens": "Runs a shell command returns console output .", "label": 0}, {"idx": "cosqa-train-2775", "doc": "python iterable take first n elements", "code": "def split_every(n, iterable):\n    \"\"\"Returns a generator that spits an iteratable into n-sized chunks. The last chunk may have\n    less than n elements.\n\n    See http://stackoverflow.com/a/22919323/503377.\"\"\"\n    items = iter(iterable)\n    return itertools.takewhile(bool, (list(itertools.islice(items, n)) for _ in itertools.count()))", "code_tokens": "def split_every ( n , iterable ) : items = iter ( iterable ) return itertools . takewhile ( bool , ( list ( itertools . islice ( items , n ) ) for _ in itertools . count ( ) ) )", "docstring_tokens": "Returns a generator that spits an iteratable into n - sized chunks . The last chunk may have less than n elements .", "label": 0}, {"idx": "cosqa-train-2776", "doc": "get parent of element python xml", "code": "def root_parent(self, category=None):\n        \"\"\" Returns the topmost parent of the current category. \"\"\"\n        return next(filter(lambda c: c.is_root, self.hierarchy()))", "code_tokens": "def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )", "docstring_tokens": "Returns the topmost parent of the current category .", "label": 0}, {"idx": "cosqa-train-2777", "doc": "python iterat with index and element", "code": "def stop_at(iterable, idx):\n    \"\"\"Stops iterating before yielding the specified idx.\"\"\"\n    for i, item in enumerate(iterable):\n        if i == idx: return\n        yield item", "code_tokens": "def stop_at ( iterable , idx ) : for i , item in enumerate ( iterable ) : if i == idx : return yield item", "docstring_tokens": "Stops iterating before yielding the specified idx .", "label": 0}, {"idx": "cosqa-train-2778", "doc": "get pinyin from characters python", "code": "def get(s, delimiter='', format=\"diacritical\"):\n    \"\"\"Return pinyin of string, the string must be unicode\n    \"\"\"\n    return delimiter.join(_pinyin_generator(u(s), format=format))", "code_tokens": "def get ( s , delimiter = '' , format = \"diacritical\" ) : return delimiter . join ( _pinyin_generator ( u ( s ) , format = format ) )", "docstring_tokens": "Return pinyin of string the string must be unicode", "label": 0}, {"idx": "cosqa-train-2779", "doc": "python iterate dict sorted by key", "code": "def _dict_values_sorted_by_key(dictionary):\n    # This should be a yield from instead.\n    \"\"\"Internal helper to return the values of a dictionary, sorted by key.\n    \"\"\"\n    for _, value in sorted(dictionary.iteritems(), key=operator.itemgetter(0)):\n        yield value", "code_tokens": "def _dict_values_sorted_by_key ( dictionary ) : # This should be a yield from instead. for _ , value in sorted ( dictionary . iteritems ( ) , key = operator . itemgetter ( 0 ) ) : yield value", "docstring_tokens": "Internal helper to return the values of a dictionary sorted by key .", "label": 0}, {"idx": "cosqa-train-2780", "doc": "get quarter of date python", "code": "def previous_quarter(d):\n    \"\"\"\n    Retrieve the previous quarter for dt\n    \"\"\"\n    from django_toolkit.datetime_util import quarter as datetime_quarter\n    return quarter( (datetime_quarter(datetime(d.year, d.month, d.day))[0] + timedelta(days=-1)).date() )", "code_tokens": "def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )", "docstring_tokens": "Retrieve the previous quarter for dt", "label": 1}, {"idx": "cosqa-train-2781", "doc": "python iterate throgh links", "code": "def links(cls, page):\n    \"\"\"return all links on a page, including potentially rel= links.\"\"\"\n    for match in cls.HREF_RE.finditer(page):\n      yield cls.href_match_to_url(match)", "code_tokens": "def links ( cls , page ) : for match in cls . HREF_RE . finditer ( page ) : yield cls . href_match_to_url ( match )", "docstring_tokens": "return all links on a page including potentially rel = links .", "label": 0}, {"idx": "cosqa-train-2782", "doc": "get size for files in directory in python", "code": "def get_size(path):\n    \"\"\" Returns the size in bytes if `path` is a file,\n        or the size of all files in `path` if it's a directory.\n        Analogous to `du -s`.\n    \"\"\"\n    if os.path.isfile(path):\n        return os.path.getsize(path)\n    return sum(get_size(os.path.join(path, f)) for f in os.listdir(path))", "code_tokens": "def get_size ( path ) : if os . path . isfile ( path ) : return os . path . getsize ( path ) return sum ( get_size ( os . path . join ( path , f ) ) for f in os . listdir ( path ) )", "docstring_tokens": "Returns the size in bytes if path is a file or the size of all files in path if it s a directory . Analogous to du - s .", "label": 0}, {"idx": "cosqa-train-2783", "doc": "python iterate through queryset", "code": "def _unordered_iterator(self):\n        \"\"\"\n        Return the value of each QuerySet, but also add the '#' property to each\n        return item.\n        \"\"\"\n        for i, qs in zip(self._queryset_idxs, self._querysets):\n            for item in qs:\n                setattr(item, '#', i)\n                yield item", "code_tokens": "def _unordered_iterator ( self ) : for i , qs in zip ( self . _queryset_idxs , self . _querysets ) : for item in qs : setattr ( item , '#' , i ) yield item", "docstring_tokens": "Return the value of each QuerySet but also add the # property to each return item .", "label": 1}, {"idx": "cosqa-train-2784", "doc": "get size of an array in python", "code": "def bytesize(arr):\n    \"\"\"\n    Returns the memory byte size of a Numpy array as an integer.\n    \"\"\"\n    byte_size = np.prod(arr.shape) * np.dtype(arr.dtype).itemsize\n    return byte_size", "code_tokens": "def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size", "docstring_tokens": "Returns the memory byte size of a Numpy array as an integer .", "label": 0}, {"idx": "cosqa-train-2785", "doc": "python iterator cycle set first element", "code": "def _fill(self):\n    \"\"\"Advance the iterator without returning the old head.\"\"\"\n    try:\n      self._head = self._iterable.next()\n    except StopIteration:\n      self._head = None", "code_tokens": "def _fill ( self ) : try : self . _head = self . _iterable . next ( ) except StopIteration : self . _head = None", "docstring_tokens": "Advance the iterator without returning the old head .", "label": 0}, {"idx": "cosqa-train-2786", "doc": "get size of range python", "code": "def memsize(self):\n        \"\"\" Total array cell + indexes size\n        \"\"\"\n        return self.size + 1 + TYPE.size(gl.BOUND_TYPE) * len(self.bounds)", "code_tokens": "def memsize ( self ) : return self . size + 1 + TYPE . size ( gl . BOUND_TYPE ) * len ( self . bounds )", "docstring_tokens": "Total array cell + indexes size", "label": 0}, {"idx": "cosqa-train-2787", "doc": "python iterator still memory increase", "code": "def _fill(self):\n    \"\"\"Advance the iterator without returning the old head.\"\"\"\n    try:\n      self._head = self._iterable.next()\n    except StopIteration:\n      self._head = None", "code_tokens": "def _fill ( self ) : try : self . _head = self . _iterable . next ( ) except StopIteration : self . _head = None", "docstring_tokens": "Advance the iterator without returning the old head .", "label": 0}, {"idx": "cosqa-train-2788", "doc": "get table list python sql", "code": "def get_tablenames(cur):\n    \"\"\" Conveinience: \"\"\"\n    cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n    tablename_list_ = cur.fetchall()\n    tablename_list = [str(tablename[0]) for tablename in tablename_list_ ]\n    return tablename_list", "code_tokens": "def get_tablenames ( cur ) : cur . execute ( \"SELECT name FROM sqlite_master WHERE type='table'\" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list", "docstring_tokens": "Conveinience :", "label": 0}, {"idx": "cosqa-train-2789", "doc": "python jieba 'nonetype' object has no attribute 'decode'", "code": "def load(raw_bytes):\n        \"\"\"\n        given a bytes object, should return a base python data\n        structure that represents the object.\n        \"\"\"\n        try:\n            if not isinstance(raw_bytes, string_type):\n                raw_bytes = raw_bytes.decode()\n            return json.loads(raw_bytes)\n        except ValueError as e:\n            raise SerializationException(str(e))", "code_tokens": "def load ( raw_bytes ) : try : if not isinstance ( raw_bytes , string_type ) : raw_bytes = raw_bytes . decode ( ) return json . loads ( raw_bytes ) except ValueError as e : raise SerializationException ( str ( e ) )", "docstring_tokens": "given a bytes object should return a base python data structure that represents the object .", "label": 0}, {"idx": "cosqa-train-2790", "doc": "get text by xpath python", "code": "def _extract_node_text(node):\n    \"\"\"Extract text from a given lxml node.\"\"\"\n\n    texts = map(\n        six.text_type.strip, map(six.text_type, map(unescape, node.xpath(\".//text()\")))\n    )\n    return \" \".join(text for text in texts if text)", "code_tokens": "def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( \".//text()\" ) ) ) ) return \" \" . join ( text for text in texts if text )", "docstring_tokens": "Extract text from a given lxml node .", "label": 0}, {"idx": "cosqa-train-2791", "doc": "python join all elements in a tuple", "code": "def compose_all(tups):\n  \"\"\"Compose all given tuples together.\"\"\"\n  from . import ast  # I weep for humanity\n  return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))", "code_tokens": "def compose_all ( tups ) : from . import ast # I weep for humanity return functools . reduce ( lambda x , y : x . compose ( y ) , map ( ast . make_tuple , tups ) , ast . make_tuple ( { } ) )", "docstring_tokens": "Compose all given tuples together .", "label": 0}, {"idx": "cosqa-train-2792", "doc": "get the 4th sunday of every month in a year in python", "code": "def first_sunday(self, year, month):\n        \"\"\"Get the first sunday of a month.\"\"\"\n        date = datetime(year, month, 1, 0)\n        days_until_sunday = 6 - date.weekday()\n\n        return date + timedelta(days=days_until_sunday)", "code_tokens": "def first_sunday ( self , year , month ) : date = datetime ( year , month , 1 , 0 ) days_until_sunday = 6 - date . weekday ( ) return date + timedelta ( days = days_until_sunday )", "docstring_tokens": "Get the first sunday of a month .", "label": 0}, {"idx": "cosqa-train-2793", "doc": "python json bytes deserialize", "code": "def json(body, charset='utf-8', **kwargs):\n    \"\"\"Takes JSON formatted data, converting it into native Python objects\"\"\"\n    return json_converter.loads(text(body, charset=charset))", "code_tokens": "def json ( body , charset = 'utf-8' , * * kwargs ) : return json_converter . loads ( text ( body , charset = charset ) )", "docstring_tokens": "Takes JSON formatted data converting it into native Python objects", "label": 0}, {"idx": "cosqa-train-2794", "doc": "get the excel cell background color into a list using python", "code": "def _get_background_color(self):\n        \"\"\"Returns background color rgb tuple of right line\"\"\"\n\n        color = self.cell_attributes[self.key][\"bgcolor\"]\n        return tuple(c / 255.0 for c in color_pack2rgb(color))", "code_tokens": "def _get_background_color ( self ) : color = self . cell_attributes [ self . key ] [ \"bgcolor\" ] return tuple ( c / 255.0 for c in color_pack2rgb ( color ) )", "docstring_tokens": "Returns background color rgb tuple of right line", "label": 0}, {"idx": "cosqa-train-2795", "doc": "python json datetime object", "code": "def parse_json_date(value):\n    \"\"\"\n    Parses an ISO8601 formatted datetime from a string value\n    \"\"\"\n    if not value:\n        return None\n\n    return datetime.datetime.strptime(value, JSON_DATETIME_FORMAT).replace(tzinfo=pytz.UTC)", "code_tokens": "def parse_json_date ( value ) : if not value : return None return datetime . datetime . strptime ( value , JSON_DATETIME_FORMAT ) . replace ( tzinfo = pytz . UTC )", "docstring_tokens": "Parses an ISO8601 formatted datetime from a string value", "label": 0}, {"idx": "cosqa-train-2796", "doc": "get the extension python", "code": "def _get_compiled_ext():\n    \"\"\"Official way to get the extension of compiled files (.pyc or .pyo)\"\"\"\n    for ext, mode, typ in imp.get_suffixes():\n        if typ == imp.PY_COMPILED:\n            return ext", "code_tokens": "def _get_compiled_ext ( ) : for ext , mode , typ in imp . get_suffixes ( ) : if typ == imp . PY_COMPILED : return ext", "docstring_tokens": "Official way to get the extension of compiled files ( . pyc or . pyo )", "label": 0}, {"idx": "cosqa-train-2797", "doc": "python json dump precision", "code": "def dump_json(obj):\n    \"\"\"Dump Python object as JSON string.\"\"\"\n    return simplejson.dumps(obj, ignore_nan=True, default=json_util.default)", "code_tokens": "def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )", "docstring_tokens": "Dump Python object as JSON string .", "label": 1}, {"idx": "cosqa-train-2798", "doc": "get the file extension python", "code": "def get_abi3_suffix():\n    \"\"\"Return the file extension for an abi3-compliant Extension()\"\"\"\n    for suffix, _, _ in (s for s in imp.get_suffixes() if s[2] == imp.C_EXTENSION):\n        if '.abi3' in suffix:  # Unix\n            return suffix\n        elif suffix == '.pyd':  # Windows\n            return suffix", "code_tokens": "def get_abi3_suffix ( ) : for suffix , _ , _ in ( s for s in imp . get_suffixes ( ) if s [ 2 ] == imp . C_EXTENSION ) : if '.abi3' in suffix : # Unix return suffix elif suffix == '.pyd' : # Windows return suffix", "docstring_tokens": "Return the file extension for an abi3 - compliant Extension ()", "label": 0}, {"idx": "cosqa-train-2799", "doc": "python json dump separator", "code": "def dump_json(obj):\n    \"\"\"Dump Python object as JSON string.\"\"\"\n    return simplejson.dumps(obj, ignore_nan=True, default=json_util.default)", "code_tokens": "def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )", "docstring_tokens": "Dump Python object as JSON string .", "label": 0}, {"idx": "cosqa-train-2800", "doc": "get the location of a file in python", "code": "def getScriptLocation():\n\t\"\"\"Helper function to get the location of a Python file.\"\"\"\n\tlocation = os.path.abspath(\"./\")\n\tif __file__.rfind(\"/\") != -1:\n\t\tlocation = __file__[:__file__.rfind(\"/\")]\n\treturn location", "code_tokens": "def getScriptLocation ( ) : location = os . path . abspath ( \"./\" ) if __file__ . rfind ( \"/\" ) != - 1 : location = __file__ [ : __file__ . rfind ( \"/\" ) ] return location", "docstring_tokens": "Helper function to get the location of a Python file .", "label": 1}, {"idx": "cosqa-train-2801", "doc": "python json dumps not json serializable", "code": "def json_dumps(self, obj):\n        \"\"\"Serializer for consistency\"\"\"\n        return json.dumps(obj, sort_keys=True, indent=4, separators=(',', ': '))", "code_tokens": "def json_dumps ( self , obj ) : return json . dumps ( obj , sort_keys = True , indent = 4 , separators = ( ',' , ': ' ) )", "docstring_tokens": "Serializer for consistency", "label": 0}, {"idx": "cosqa-train-2802", "doc": "get the number of rows of a data frame in python", "code": "def count_(self):\n        \"\"\"\n        Returns the number of rows of the main dataframe\n        \"\"\"\n        try:\n            num = len(self.df.index)\n        except Exception as e:\n            self.err(e, \"Can not count data\")\n            return\n        return num", "code_tokens": "def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , \"Can not count data\" ) return return num", "docstring_tokens": "Returns the number of rows of the main dataframe", "label": 0}, {"idx": "cosqa-train-2803", "doc": "python json dumps object", "code": "def to_json(obj):\n    \"\"\"Return a json string representing the python object obj.\"\"\"\n    i = StringIO.StringIO()\n    w = Writer(i, encoding='UTF-8')\n    w.write_value(obj)\n    return i.getvalue()", "code_tokens": "def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )", "docstring_tokens": "Return a json string representing the python object obj .", "label": 0}, {"idx": "cosqa-train-2804", "doc": "get the product of the numbers in a list python", "code": "def _cumprod(l):\n  \"\"\"Cumulative product of a list.\n\n  Args:\n    l: a list of integers\n  Returns:\n    a list with one more element (starting with 1)\n  \"\"\"\n  ret = [1]\n  for item in l:\n    ret.append(ret[-1] * item)\n  return ret", "code_tokens": "def _cumprod ( l ) : ret = [ 1 ] for item in l : ret . append ( ret [ - 1 ] * item ) return ret", "docstring_tokens": "Cumulative product of a list .", "label": 0}, {"idx": "cosqa-train-2805", "doc": "python json serializer array order", "code": "def json_dumps(self, obj):\n        \"\"\"Serializer for consistency\"\"\"\n        return json.dumps(obj, sort_keys=True, indent=4, separators=(',', ': '))", "code_tokens": "def json_dumps ( self , obj ) : return json . dumps ( obj , sort_keys = True , indent = 4 , separators = ( ',' , ': ' ) )", "docstring_tokens": "Serializer for consistency", "label": 0}, {"idx": "cosqa-train-2806", "doc": "get type name python", "code": "def typename(obj):\n    \"\"\"Returns the type of obj as a string. More descriptive and specific than\n    type(obj), and safe for any object, unlike __class__.\"\"\"\n    if hasattr(obj, '__class__'):\n        return getattr(obj, '__class__').__name__\n    else:\n        return type(obj).__name__", "code_tokens": "def typename ( obj ) : if hasattr ( obj , '__class__' ) : return getattr ( obj , '__class__' ) . __name__ else : return type ( obj ) . __name__", "docstring_tokens": "Returns the type of obj as a string . More descriptive and specific than type ( obj ) and safe for any object unlike __class__ .", "label": 0}, {"idx": "cosqa-train-2807", "doc": "python json type preserve", "code": "def json_decode(data):\n    \"\"\"\n    Decodes the given JSON as primitives\n    \"\"\"\n    if isinstance(data, six.binary_type):\n        data = data.decode('utf-8')\n\n    return json.loads(data)", "code_tokens": "def json_decode ( data ) : if isinstance ( data , six . binary_type ) : data = data . decode ( 'utf-8' ) return json . loads ( data )", "docstring_tokens": "Decodes the given JSON as primitives", "label": 1}, {"idx": "cosqa-train-2808", "doc": "get uniques of list python", "code": "def uniq(seq):\n    \"\"\" Return a copy of seq without duplicates. \"\"\"\n    seen = set()\n    return [x for x in seq if str(x) not in seen and not seen.add(str(x))]", "code_tokens": "def uniq ( seq ) : seen = set ( ) return [ x for x in seq if str ( x ) not in seen and not seen . add ( str ( x ) ) ]", "docstring_tokens": "Return a copy of seq without duplicates .", "label": 1}, {"idx": "cosqa-train-2809", "doc": "python judge obj as str", "code": "def is_collection(obj):\n    \"\"\"Tests if an object is a collection.\"\"\"\n\n    col = getattr(obj, '__getitem__', False)\n    val = False if (not col) else True\n\n    if isinstance(obj, basestring):\n        val = False\n\n    return val", "code_tokens": "def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val", "docstring_tokens": "Tests if an object is a collection .", "label": 0}, {"idx": "cosqa-train-2810", "doc": "get values from dictionary in a iterator python", "code": "def itervalues(d, **kw):\n    \"\"\"Return an iterator over the values of a dictionary.\"\"\"\n    if not PY2:\n        return iter(d.values(**kw))\n    return d.itervalues(**kw)", "code_tokens": "def itervalues ( d , * * kw ) : if not PY2 : return iter ( d . values ( * * kw ) ) return d . itervalues ( * * kw )", "docstring_tokens": "Return an iterator over the values of a dictionary .", "label": 1}, {"idx": "cosqa-train-2811", "doc": "python key sort not found", "code": "def transcript_sort_key(transcript):\n    \"\"\"\n    Key function used to sort transcripts. Taking the negative of\n    protein sequence length and nucleotide sequence length so that\n    the transcripts with longest sequences come first in the list. This couldn't\n    be accomplished with `reverse=True` since we're also sorting by\n    transcript name (which places TP53-001 before TP53-002).\n    \"\"\"\n    return (\n        -len(transcript.protein_sequence),\n        -len(transcript.sequence),\n        transcript.name\n    )", "code_tokens": "def transcript_sort_key ( transcript ) : return ( - len ( transcript . protein_sequence ) , - len ( transcript . sequence ) , transcript . name )", "docstring_tokens": "Key function used to sort transcripts . Taking the negative of protein sequence length and nucleotide sequence length so that the transcripts with longest sequences come first in the list . This couldn t be accomplished with reverse = True since we re also sorting by transcript name ( which places TP53 - 001 before TP53 - 002 ) .", "label": 1}, {"idx": "cosqa-train-2812", "doc": "get variable in python in robotframework", "code": "def getSystemVariable(self, remote, name):\n        \"\"\"Get single system variable from CCU / Homegear\"\"\"\n        if self._server is not None:\n            return self._server.getSystemVariable(remote, name)", "code_tokens": "def getSystemVariable ( self , remote , name ) : if self . _server is not None : return self . _server . getSystemVariable ( remote , name )", "docstring_tokens": "Get single system variable from CCU / Homegear", "label": 1}, {"idx": "cosqa-train-2813", "doc": "python keyword extracton nltk", "code": "def extract_keywords_from_text(self, text):\n        \"\"\"Method to extract keywords from the text provided.\n\n        :param text: Text to extract keywords from, provided as a string.\n        \"\"\"\n        sentences = nltk.tokenize.sent_tokenize(text)\n        self.extract_keywords_from_sentences(sentences)", "code_tokens": "def extract_keywords_from_text ( self , text ) : sentences = nltk . tokenize . sent_tokenize ( text ) self . extract_keywords_from_sentences ( sentences )", "docstring_tokens": "Method to extract keywords from the text provided .", "label": 0}, {"idx": "cosqa-train-2814", "doc": "get xml element and prettify python", "code": "def prettify(elem):\n    \"\"\"Return a pretty-printed XML string for the Element.\n    \"\"\"\n    rough_string = ET.tostring(elem, 'utf-8')\n    reparsed = minidom.parseString(rough_string)\n    return reparsed.toprettyxml(indent=\"\\t\")", "code_tokens": "def prettify ( elem ) : rough_string = ET . tostring ( elem , 'utf-8' ) reparsed = minidom . parseString ( rough_string ) return reparsed . toprettyxml ( indent = \"\\t\" )", "docstring_tokens": "Return a pretty - printed XML string for the Element .", "label": 0}, {"idx": "cosqa-train-2815", "doc": "python kill process by pid not working", "code": "def kill_process_children(pid):\n    \"\"\"Find and kill child processes of a process.\n\n    :param pid: PID of parent process (process ID)\n    :return: Nothing\n    \"\"\"\n    if sys.platform == \"darwin\":\n        kill_process_children_osx(pid)\n    elif sys.platform == \"linux\":\n        kill_process_children_unix(pid)\n    else:\n        pass", "code_tokens": "def kill_process_children ( pid ) : if sys . platform == \"darwin\" : kill_process_children_osx ( pid ) elif sys . platform == \"linux\" : kill_process_children_unix ( pid ) else : pass", "docstring_tokens": "Find and kill child processes of a process .", "label": 0}, {"idx": "cosqa-train-2816", "doc": "python kmeans clustering 1d array", "code": "def classify_clusters(points, n=10):\n    \"\"\"\n    Return an array of K-Means cluster classes for an array of `shapely.geometry.Point` objects.\n    \"\"\"\n    arr = [[p.x, p.y] for p in points.values]\n    clf = KMeans(n_clusters=n)\n    clf.fit(arr)\n    classes = clf.predict(arr)\n    return classes", "code_tokens": "def classify_clusters ( points , n = 10 ) : arr = [ [ p . x , p . y ] for p in points . values ] clf = KMeans ( n_clusters = n ) clf . fit ( arr ) classes = clf . predict ( arr ) return classes", "docstring_tokens": "Return an array of K - Means cluster classes for an array of shapely . geometry . Point objects .", "label": 0}, {"idx": "cosqa-train-2817", "doc": "getattr of local variable python", "code": "def getSystemVariable(self, remote, name):\n        \"\"\"Get single system variable from CCU / Homegear\"\"\"\n        if self._server is not None:\n            return self._server.getSystemVariable(remote, name)", "code_tokens": "def getSystemVariable ( self , remote , name ) : if self . _server is not None : return self . _server . getSystemVariable ( remote , name )", "docstring_tokens": "Get single system variable from CCU / Homegear", "label": 0}, {"idx": "cosqa-train-2818", "doc": "python kwargs with speicifed", "code": "def _sourced_dict(self, source=None, **kwargs):\n        \"\"\"Like ``dict(**kwargs)``, but where the ``source`` key is special.\n        \"\"\"\n        if source:\n            kwargs['source'] = source\n        elif self.source:\n            kwargs['source'] = self.source\n        return kwargs", "code_tokens": "def _sourced_dict ( self , source = None , * * kwargs ) : if source : kwargs [ 'source' ] = source elif self . source : kwargs [ 'source' ] = self . source return kwargs", "docstring_tokens": "Like dict ( ** kwargs ) but where the source key is special .", "label": 0}, {"idx": "cosqa-train-2819", "doc": "getattribute empty xml in python", "code": "def get_element_attribute_or_empty(element, attribute_name):\n    \"\"\"\n\n    Args:\n        element (element): The xib's element.\n        attribute_name (str): The desired attribute's name.\n\n    Returns:\n        The attribute's value, or an empty str if none exists.\n\n    \"\"\"\n    return element.attributes[attribute_name].value if element.hasAttribute(attribute_name) else \"\"", "code_tokens": "def get_element_attribute_or_empty ( element , attribute_name ) : return element . attributes [ attribute_name ] . value if element . hasAttribute ( attribute_name ) else \"\"", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-2820", "doc": "python lambda expression using two variables", "code": "def make_lambda(call):\n    \"\"\"Wrap an AST Call node to lambda expression node.\n    call: ast.Call node\n    \"\"\"\n    empty_args = ast.arguments(args=[], vararg=None, kwarg=None, defaults=[])\n    return ast.Lambda(args=empty_args, body=call)", "code_tokens": "def make_lambda ( call ) : empty_args = ast . arguments ( args = [ ] , vararg = None , kwarg = None , defaults = [ ] ) return ast . Lambda ( args = empty_args , body = call )", "docstring_tokens": "Wrap an AST Call node to lambda expression node . call : ast . Call node", "label": 0}, {"idx": "cosqa-train-2821", "doc": "gitpython get list of changed files and status", "code": "def is_changed():\n    \"\"\" Checks if current project has any noncommited changes. \"\"\"\n    executed, changed_lines = execute_git('status --porcelain', output=False)\n    merge_not_finished = mod_path.exists('.git/MERGE_HEAD')\n    return changed_lines.strip() or merge_not_finished", "code_tokens": "def is_changed ( ) : executed , changed_lines = execute_git ( 'status --porcelain' , output = False ) merge_not_finished = mod_path . exists ( '.git/MERGE_HEAD' ) return changed_lines . strip ( ) or merge_not_finished", "docstring_tokens": "Checks if current project has any noncommited changes .", "label": 0}, {"idx": "cosqa-train-2822", "doc": "giving a variable name to a function return python", "code": "def color_func(func_name):\n    \"\"\"\n    Call color function base on name\n    \"\"\"\n    if str(func_name).isdigit():\n        return term_color(int(func_name))\n    return globals()[func_name]", "code_tokens": "def color_func ( func_name ) : if str ( func_name ) . isdigit ( ) : return term_color ( int ( func_name ) ) return globals ( ) [ func_name ]", "docstring_tokens": "Call color function base on name", "label": 0}, {"idx": "cosqa-train-2823", "doc": "python latest browser user agent chrome", "code": "def copy_user_agent_from_driver(self):\n        \"\"\" Updates requests' session user-agent with the driver's user agent\n\n        This method will start the browser process if its not already running.\n        \"\"\"\n        selenium_user_agent = self.driver.execute_script(\"return navigator.userAgent;\")\n        self.headers.update({\"user-agent\": selenium_user_agent})", "code_tokens": "def copy_user_agent_from_driver ( self ) : selenium_user_agent = self . driver . execute_script ( \"return navigator.userAgent;\" ) self . headers . update ( { \"user-agent\" : selenium_user_agent } )", "docstring_tokens": "Updates requests session user - agent with the driver s user agent", "label": 0}, {"idx": "cosqa-train-2824", "doc": "good indentations for matrix python", "code": "def print_matrix(X, decimals=1):\n    \"\"\"Pretty printing for numpy matrix X\"\"\"\n    for row in np.round(X, decimals=decimals):\n        print(row)", "code_tokens": "def print_matrix ( X , decimals = 1 ) : for row in np . round ( X , decimals = decimals ) : print ( row )", "docstring_tokens": "Pretty printing for numpy matrix X", "label": 0}, {"idx": "cosqa-train-2825", "doc": "python length width table", "code": "def get_table_width(table):\n    \"\"\"\n    Gets the width of the table that would be printed.\n    :rtype: ``int``\n    \"\"\"\n    columns = transpose_table(prepare_rows(table))\n    widths = [max(len(cell) for cell in column) for column in columns]\n    return len('+' + '|'.join('-' * (w + 2) for w in widths) + '+')", "code_tokens": "def get_table_width ( table ) : columns = transpose_table ( prepare_rows ( table ) ) widths = [ max ( len ( cell ) for cell in column ) for column in columns ] return len ( '+' + '|' . join ( '-' * ( w + 2 ) for w in widths ) + '+' )", "docstring_tokens": "Gets the width of the table that would be printed . : rtype : int", "label": 0}, {"idx": "cosqa-train-2826", "doc": "graph exponential function python", "code": "def algo_exp(x, m, t, b):\n    \"\"\"mono-exponential curve.\"\"\"\n    return m*np.exp(-t*x)+b", "code_tokens": "def algo_exp ( x , m , t , b ) : return m * np . exp ( - t * x ) + b", "docstring_tokens": "mono - exponential curve .", "label": 0}, {"idx": "cosqa-train-2827", "doc": "python limit to positive values", "code": "def open01(x, limit=1.e-6):\n    \"\"\"Constrain numbers to (0,1) interval\"\"\"\n    try:\n        return np.array([min(max(y, limit), 1. - limit) for y in x])\n    except TypeError:\n        return min(max(x, limit), 1. - limit)", "code_tokens": "def open01 ( x , limit = 1.e-6 ) : try : return np . array ( [ min ( max ( y , limit ) , 1. - limit ) for y in x ] ) except TypeError : return min ( max ( x , limit ) , 1. - limit )", "docstring_tokens": "Constrain numbers to ( 0 1 ) interval", "label": 0}, {"idx": "cosqa-train-2828", "doc": "graphviz executable not found python", "code": "def _check_graphviz_available(output_format):\n    \"\"\"check if we need graphviz for different output format\"\"\"\n    try:\n        subprocess.call([\"dot\", \"-V\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    except OSError:\n        print(\n            \"The output format '%s' is currently not available.\\n\"\n            \"Please install 'Graphviz' to have other output formats \"\n            \"than 'dot' or 'vcg'.\" % output_format\n        )\n        sys.exit(32)", "code_tokens": "def _check_graphviz_available ( output_format ) : try : subprocess . call ( [ \"dot\" , \"-V\" ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) except OSError : print ( \"The output format '%s' is currently not available.\\n\" \"Please install 'Graphviz' to have other output formats \" \"than 'dot' or 'vcg'.\" % output_format ) sys . exit ( 32 )", "docstring_tokens": "check if we need graphviz for different output format", "label": 0}, {"idx": "cosqa-train-2829", "doc": "graphviz set graph in python", "code": "def _text_to_graphiz(self, text):\n        \"\"\"create a graphviz graph from text\"\"\"\n        dot = Source(text, format='svg')\n        return dot.pipe().decode('utf-8')", "code_tokens": "def _text_to_graphiz ( self , text ) : dot = Source ( text , format = 'svg' ) return dot . pipe ( ) . decode ( 'utf-8' )", "docstring_tokens": "create a graphviz graph from text", "label": 1}, {"idx": "cosqa-train-2830", "doc": "python linux shell hide output", "code": "def disown(cmd):\n    \"\"\"Call a system command in the background,\n       disown it and hide it's output.\"\"\"\n    subprocess.Popen(cmd,\n                     stdout=subprocess.DEVNULL,\n                     stderr=subprocess.DEVNULL)", "code_tokens": "def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "docstring_tokens": "Call a system command in the background disown it and hide it s output .", "label": 1}, {"idx": "cosqa-train-2831", "doc": "greater than condition on column python", "code": "def selectgt(table, field, value, complement=False):\n    \"\"\"Select rows where the given field is greater than the given value.\"\"\"\n\n    value = Comparable(value)\n    return selectop(table, field, value, operator.gt, complement=complement)", "code_tokens": "def selectgt ( table , field , value , complement = False ) : value = Comparable ( value ) return selectop ( table , field , value , operator . gt , complement = complement )", "docstring_tokens": "Select rows where the given field is greater than the given value .", "label": 0}, {"idx": "cosqa-train-2832", "doc": "python list all indices of a value", "code": "def index(m, val):\n    \"\"\"\n    Return the indices of all the ``val`` in ``m``\n    \"\"\"\n    mm = np.array(m)\n    idx_tuple = np.where(mm == val)\n    idx = idx_tuple[0].tolist()\n\n    return idx", "code_tokens": "def index ( m , val ) : mm = np . array ( m ) idx_tuple = np . where ( mm == val ) idx = idx_tuple [ 0 ] . tolist ( ) return idx", "docstring_tokens": "Return the indices of all the val in m", "label": 0}, {"idx": "cosqa-train-2833", "doc": "gui designer for python script", "code": "def page_guiref(arg_s=None):\n    \"\"\"Show a basic reference about the GUI Console.\"\"\"\n    from IPython.core import page\n    page.page(gui_reference, auto_html=True)", "code_tokens": "def page_guiref ( arg_s = None ) : from IPython . core import page page . page ( gui_reference , auto_html = True )", "docstring_tokens": "Show a basic reference about the GUI Console .", "label": 1}, {"idx": "cosqa-train-2834", "doc": "python list all unique elements in 2d array", "code": "def _unique_rows_numpy(a):\n    \"\"\"return unique rows\"\"\"\n    a = np.ascontiguousarray(a)\n    unique_a = np.unique(a.view([('', a.dtype)] * a.shape[1]))\n    return unique_a.view(a.dtype).reshape((unique_a.shape[0], a.shape[1]))", "code_tokens": "def _unique_rows_numpy ( a ) : a = np . ascontiguousarray ( a ) unique_a = np . unique ( a . view ( [ ( '' , a . dtype ) ] * a . shape [ 1 ] ) ) return unique_a . view ( a . dtype ) . reshape ( ( unique_a . shape [ 0 ] , a . shape [ 1 ] ) )", "docstring_tokens": "return unique rows", "label": 1}, {"idx": "cosqa-train-2835", "doc": "heck if environemnt variabl eexists python", "code": "def executable_exists(executable):\n    \"\"\"Test if an executable is available on the system.\"\"\"\n    for directory in os.getenv(\"PATH\").split(\":\"):\n        if os.path.exists(os.path.join(directory, executable)):\n            return True\n    return False", "code_tokens": "def executable_exists ( executable ) : for directory in os . getenv ( \"PATH\" ) . split ( \":\" ) : if os . path . exists ( os . path . join ( directory , executable ) ) : return True return False", "docstring_tokens": "Test if an executable is available on the system .", "label": 0}, {"idx": "cosqa-train-2836", "doc": "python list of all states", "code": "def values(self):\n        \"\"\"return a list of all state values\"\"\"\n        values = []\n        for __, data in self.items():\n            values.append(data)\n        return values", "code_tokens": "def values ( self ) : values = [ ] for __ , data in self . items ( ) : values . append ( data ) return values", "docstring_tokens": "return a list of all state values", "label": 0}, {"idx": "cosqa-train-2837", "doc": "hex to bitcoin script python", "code": "def btc_make_p2sh_address( script_hex ):\n    \"\"\"\n    Make a P2SH address from a hex script\n    \"\"\"\n    h = hashing.bin_hash160(binascii.unhexlify(script_hex))\n    addr = bin_hash160_to_address(h, version_byte=multisig_version_byte)\n    return addr", "code_tokens": "def btc_make_p2sh_address ( script_hex ) : h = hashing . bin_hash160 ( binascii . unhexlify ( script_hex ) ) addr = bin_hash160_to_address ( h , version_byte = multisig_version_byte ) return addr", "docstring_tokens": "Make a P2SH address from a hex script", "label": 0}, {"idx": "cosqa-train-2838", "doc": "python list of array to dimension", "code": "def get_dimension_array(array):\n    \"\"\"\n    Get dimension of an array getting the number of rows and the max num of\n    columns.\n    \"\"\"\n    if all(isinstance(el, list) for el in array):\n        result = [len(array), len(max([x for x in array], key=len,))]\n\n    # elif array and isinstance(array, list):\n    else:\n        result = [len(array), 1]\n\n    return result", "code_tokens": "def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result", "docstring_tokens": "Get dimension of an array getting the number of rows and the max num of columns .", "label": 1}, {"idx": "cosqa-train-2839", "doc": "how adjust the size of colorbar in python", "code": "def colorbar(height, length, colormap):\n    \"\"\"Return the channels of a colorbar.\n    \"\"\"\n    cbar = np.tile(np.arange(length) * 1.0 / (length - 1), (height, 1))\n    cbar = (cbar * (colormap.values.max() - colormap.values.min())\n            + colormap.values.min())\n\n    return colormap.colorize(cbar)", "code_tokens": "def colorbar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . colorize ( cbar )", "docstring_tokens": "Return the channels of a colorbar .", "label": 0}, {"idx": "cosqa-train-2840", "doc": "python list of dates datetime", "code": "def get_dt_list(fn_list):\n    \"\"\"Get list of datetime objects, extracted from a filename\n    \"\"\"\n    dt_list = np.array([fn_getdatetime(fn) for fn in fn_list])\n    return dt_list", "code_tokens": "def get_dt_list ( fn_list ) : dt_list = np . array ( [ fn_getdatetime ( fn ) for fn in fn_list ] ) return dt_list", "docstring_tokens": "Get list of datetime objects extracted from a filename", "label": 0}, {"idx": "cosqa-train-2841", "doc": "how are python sets unique", "code": "def _init_unique_sets(self):\n        \"\"\"Initialise sets used for uniqueness checking.\"\"\"\n\n        ks = dict()\n        for t in self._unique_checks:\n            key = t[0]\n            ks[key] = set() # empty set\n        return ks", "code_tokens": "def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks", "docstring_tokens": "Initialise sets used for uniqueness checking .", "label": 1}, {"idx": "cosqa-train-2842", "doc": "python list of indices with value", "code": "def index(m, val):\n    \"\"\"\n    Return the indices of all the ``val`` in ``m``\n    \"\"\"\n    mm = np.array(m)\n    idx_tuple = np.where(mm == val)\n    idx = idx_tuple[0].tolist()\n\n    return idx", "code_tokens": "def index ( m , val ) : mm = np . array ( m ) idx_tuple = np . where ( mm == val ) idx = idx_tuple [ 0 ] . tolist ( ) return idx", "docstring_tokens": "Return the indices of all the val in m", "label": 1}, {"idx": "cosqa-train-2843", "doc": "how can i do arrays in python", "code": "def poke_array(self, store, name, elemtype, elements, container, visited, _stack):\n        \"\"\"abstract method\"\"\"\n        raise NotImplementedError", "code_tokens": "def poke_array ( self , store , name , elemtype , elements , container , visited , _stack ) : raise NotImplementedError", "docstring_tokens": "abstract method", "label": 0}, {"idx": "cosqa-train-2844", "doc": "python list of strings get average length", "code": "def get_average_length_of_string(strings):\n    \"\"\"Computes average length of words\n\n    :param strings: list of words\n    :return: Average length of word on list\n    \"\"\"\n    if not strings:\n        return 0\n\n    return sum(len(word) for word in strings) / len(strings)", "code_tokens": "def get_average_length_of_string ( strings ) : if not strings : return 0 return sum ( len ( word ) for word in strings ) / len ( strings )", "docstring_tokens": "Computes average length of words", "label": 0}, {"idx": "cosqa-train-2845", "doc": "how can i validate email syntax in python", "code": "def is_valid(email):\n        \"\"\"Email address validation method.\n\n        :param email: Email address to be saved.\n        :type email: basestring\n        :returns: True if email address is correct, False otherwise.\n        :rtype: bool\n        \"\"\"\n        if isinstance(email, basestring) and EMAIL_RE.match(email):\n            return True\n        return False", "code_tokens": "def is_valid ( email ) : if isinstance ( email , basestring ) and EMAIL_RE . match ( email ) : return True return False", "docstring_tokens": "Email address validation method .", "label": 0}, {"idx": "cosqa-train-2846", "doc": "python list transforms into array", "code": "def C_dict2array(C):\n    \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"\n    return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "code_tokens": "def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )", "docstring_tokens": "Convert an OrderedDict containing C values to a 1D array .", "label": 1}, {"idx": "cosqa-train-2847", "doc": "how clear screen in python", "code": "def update_screen(self):\n        \"\"\"Refresh the screen. You don't need to override this except to update only small portins of the screen.\"\"\"\n        self.clock.tick(self.FPS)\n        pygame.display.update()", "code_tokens": "def update_screen ( self ) : self . clock . tick ( self . FPS ) pygame . display . update ( )", "docstring_tokens": "Refresh the screen . You don t need to override this except to update only small portins of the screen .", "label": 0}, {"idx": "cosqa-train-2848", "doc": "python load mat efficient", "code": "def loadmat(filename):\n    \"\"\"This function should be called instead of direct spio.loadmat\n    as it cures the problem of not properly recovering python dictionaries\n    from mat files. It calls the function check keys to cure all entries\n    which are still mat-objects\n    \"\"\"\n    data = sploadmat(filename, struct_as_record=False, squeeze_me=True)\n    return _check_keys(data)", "code_tokens": "def loadmat ( filename ) : data = sploadmat ( filename , struct_as_record = False , squeeze_me = True ) return _check_keys ( data )", "docstring_tokens": "This function should be called instead of direct spio . loadmat as it cures the problem of not properly recovering python dictionaries from mat files . It calls the function check keys to cure all entries which are still mat - objects", "label": 0}, {"idx": "cosqa-train-2849", "doc": "how do i adjust colormap scale in matplotlib python", "code": "def add_matplotlib_cmap(cm, name=None):\n    \"\"\"Add a matplotlib colormap.\"\"\"\n    global cmaps\n    cmap = matplotlib_to_ginga_cmap(cm, name=name)\n    cmaps[cmap.name] = cmap", "code_tokens": "def add_matplotlib_cmap ( cm , name = None ) : global cmaps cmap = matplotlib_to_ginga_cmap ( cm , name = name ) cmaps [ cmap . name ] = cmap", "docstring_tokens": "Add a matplotlib colormap .", "label": 1}, {"idx": "cosqa-train-2850", "doc": "python load string from file as f string", "code": "def loads(s, model=None, parser=None):\n    \"\"\"Deserialize s (a str) to a Python object.\"\"\"\n    with StringIO(s) as f:\n        return load(f, model=model, parser=parser)", "code_tokens": "def loads ( s , model = None , parser = None ) : with StringIO ( s ) as f : return load ( f , model = model , parser = parser )", "docstring_tokens": "Deserialize s ( a str ) to a Python object .", "label": 0}, {"idx": "cosqa-train-2851", "doc": "how do i check if a float is between two floats in python", "code": "def _float_almost_equal(float1, float2, places=7):\n    \"\"\"Return True if two numbers are equal up to the\n    specified number of \"places\" after the decimal point.\n    \"\"\"\n\n    if round(abs(float2 - float1), places) == 0:\n        return True\n\n    return False", "code_tokens": "def _float_almost_equal ( float1 , float2 , places = 7 ) : if round ( abs ( float2 - float1 ) , places ) == 0 : return True return False", "docstring_tokens": "Return True if two numbers are equal up to the specified number of places after the decimal point .", "label": 0}, {"idx": "cosqa-train-2852", "doc": "python local function capture", "code": "def getFunction(self):\n        \"\"\"Called by remote workers. Useful to populate main module globals()\n        for interactive shells. Retrieves the serialized function.\"\"\"\n        return functionFactory(\n            self.code,\n            self.name,\n            self.defaults,\n            self.globals,\n            self.imports,\n        )", "code_tokens": "def getFunction ( self ) : return functionFactory ( self . code , self . name , self . defaults , self . globals , self . imports , )", "docstring_tokens": "Called by remote workers . Useful to populate main module globals () for interactive shells . Retrieves the serialized function .", "label": 0}, {"idx": "cosqa-train-2853", "doc": "how do i check if it is text in python", "code": "def is_text(obj, name=None):\n    \"\"\"\n    returns True if object is text-like\n    \"\"\"\n    try:  # python2\n        ans = isinstance(obj, basestring)\n    except NameError:  # python3\n        ans = isinstance(obj, str)\n    if name:\n        print(\"is_text: (%s) %s = %s\" % (ans, name, obj.__class__),\n              file=sys.stderr)\n    return ans", "code_tokens": "def is_text ( obj , name = None ) : try : # python2 ans = isinstance ( obj , basestring ) except NameError : # python3 ans = isinstance ( obj , str ) if name : print ( \"is_text: (%s) %s = %s\" % ( ans , name , obj . __class__ ) , file = sys . stderr ) return ans", "docstring_tokens": "returns True if object is text - like", "label": 0}, {"idx": "cosqa-train-2854", "doc": "python local variable stack release", "code": "def _get_or_create_stack(name):\n  \"\"\"Returns a thread local stack uniquified by the given name.\"\"\"\n  stack = getattr(_LOCAL_STACKS, name, None)\n  if stack is None:\n    stack = []\n    setattr(_LOCAL_STACKS, name, stack)\n  return stack", "code_tokens": "def _get_or_create_stack ( name ) : stack = getattr ( _LOCAL_STACKS , name , None ) if stack is None : stack = [ ] setattr ( _LOCAL_STACKS , name , stack ) return stack", "docstring_tokens": "Returns a thread local stack uniquified by the given name .", "label": 0}, {"idx": "cosqa-train-2855", "doc": "how do i clear the variables in python", "code": "def forget_coords(self):\n        \"\"\"Forget all loaded coordinates.\"\"\"\n        self.w.ntotal.set_text('0')\n        self.coords_dict.clear()\n        self.redo()", "code_tokens": "def forget_coords ( self ) : self . w . ntotal . set_text ( '0' ) self . coords_dict . clear ( ) self . redo ( )", "docstring_tokens": "Forget all loaded coordinates .", "label": 0}, {"idx": "cosqa-train-2856", "doc": "python localize datetime already timezone data", "code": "def localize(dt):\n    \"\"\"Localize a datetime object to local time.\"\"\"\n    if dt.tzinfo is UTC:\n        return (dt + LOCAL_UTC_OFFSET).replace(tzinfo=None)\n    # No TZ info so not going to assume anything, return as-is.\n    return dt", "code_tokens": "def localize ( dt ) : if dt . tzinfo is UTC : return ( dt + LOCAL_UTC_OFFSET ) . replace ( tzinfo = None ) # No TZ info so not going to assume anything, return as-is. return dt", "docstring_tokens": "Localize a datetime object to local time .", "label": 0}, {"idx": "cosqa-train-2857", "doc": "how do i close engine in python sqlalchemy", "code": "def unlock(self):\n    \"\"\"Closes the session to the database.\"\"\"\n    if not hasattr(self, 'session'):\n      raise RuntimeError('Error detected! The session that you want to close does not exist any more!')\n    logger.debug(\"Closed database session of '%s'\" % self._database)\n    self.session.close()\n    del self.session", "code_tokens": "def unlock ( self ) : if not hasattr ( self , 'session' ) : raise RuntimeError ( 'Error detected! The session that you want to close does not exist any more!' ) logger . debug ( \"Closed database session of '%s'\" % self . _database ) self . session . close ( ) del self . session", "docstring_tokens": "Closes the session to the database .", "label": 0}, {"idx": "cosqa-train-2858", "doc": "python log probability normpdf", "code": "def lognorm(x, mu, sigma=1.0):\n    \"\"\" Log-normal function from scipy \"\"\"\n    return stats.lognorm(sigma, scale=mu).pdf(x)", "code_tokens": "def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )", "docstring_tokens": "Log - normal function from scipy", "label": 0}, {"idx": "cosqa-train-2859", "doc": "how do i perform fast fourier transform in python", "code": "def find_frequencies(data, freq=44100, bits=16):\n    \"\"\"Convert audio data into a frequency-amplitude table using fast fourier\n    transformation.\n\n    Return a list of tuples (frequency, amplitude).\n\n    Data should only contain one channel of audio.\n    \"\"\"\n    # Fast fourier transform\n    n = len(data)\n    p = _fft(data)\n    uniquePts = numpy.ceil((n + 1) / 2.0)\n\n    # Scale by the length (n) and square the value to get the amplitude\n    p = [(abs(x) / float(n)) ** 2 * 2 for x in p[0:uniquePts]]\n    p[0] = p[0] / 2\n    if n % 2 == 0:\n        p[-1] = p[-1] / 2\n\n    # Generate the frequencies and zip with the amplitudes\n    s = freq / float(n)\n    freqArray = numpy.arange(0, uniquePts * s, s)\n    return zip(freqArray, p)", "code_tokens": "def find_frequencies ( data , freq = 44100 , bits = 16 ) : # Fast fourier transform n = len ( data ) p = _fft ( data ) uniquePts = numpy . ceil ( ( n + 1 ) / 2.0 ) # Scale by the length (n) and square the value to get the amplitude p = [ ( abs ( x ) / float ( n ) ) ** 2 * 2 for x in p [ 0 : uniquePts ] ] p [ 0 ] = p [ 0 ] / 2 if n % 2 == 0 : p [ - 1 ] = p [ - 1 ] / 2 # Generate the frequencies and zip with the amplitudes s = freq / float ( n ) freqArray = numpy . arange ( 0 , uniquePts * s , s ) return zip ( freqArray , p )", "docstring_tokens": "Convert audio data into a frequency - amplitude table using fast fourier transformation .", "label": 0}, {"idx": "cosqa-train-2860", "doc": "python logger not creating a file", "code": "def log_no_newline(self, msg):\n      \"\"\" print the message to the predefined log file without newline \"\"\"\n      self.print2file(self.logfile, False, False, msg)", "code_tokens": "def log_no_newline ( self , msg ) : self . print2file ( self . logfile , False , False , msg )", "docstring_tokens": "print the message to the predefined log file without newline", "label": 0}, {"idx": "cosqa-train-2861", "doc": "how do i set a field to enum type python 3", "code": "def to_python(self, value):\n        \"\"\"\n        Convert a string from a form into an Enum value.\n        \"\"\"\n        if value is None:\n            return value\n        if isinstance(value, self.enum):\n            return value\n        return self.enum[value]", "code_tokens": "def to_python ( self , value ) : if value is None : return value if isinstance ( value , self . enum ) : return value return self . enum [ value ]", "docstring_tokens": "Convert a string from a form into an Enum value .", "label": 1}, {"idx": "cosqa-train-2862", "doc": "python logger print summary", "code": "def pylog(self, *args, **kwargs):\n        \"\"\"Display all available logging information.\"\"\"\n        printerr(self.name, args, kwargs, traceback.format_exc())", "code_tokens": "def pylog ( self , * args , * * kwargs ) : printerr ( self . name , args , kwargs , traceback . format_exc ( ) )", "docstring_tokens": "Display all available logging information .", "label": 0}, {"idx": "cosqa-train-2863", "doc": "how do i stop python from closing a popup", "code": "def closing_plugin(self, cancelable=False):\n        \"\"\"Perform actions before parent main window is closed\"\"\"\n        self.dialog_manager.close_all()\n        self.shell.exit_interpreter()\n        return True", "code_tokens": "def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True", "docstring_tokens": "Perform actions before parent main window is closed", "label": 0}, {"idx": "cosqa-train-2864", "doc": "python logging close file", "code": "def close_log(log, verbose=True):\n    \"\"\"Close log\n\n    This method closes and active logging.Logger instance.\n\n    Parameters\n    ----------\n    log : logging.Logger\n        Logging instance\n\n    \"\"\"\n\n    if verbose:\n        print('Closing log file:', log.name)\n\n    # Send closing message.\n    log.info('The log file has been closed.')\n\n    # Remove all handlers from log.\n    [log.removeHandler(handler) for handler in log.handlers]", "code_tokens": "def close_log ( log , verbose = True ) : if verbose : print ( 'Closing log file:' , log . name ) # Send closing message. log . info ( 'The log file has been closed.' ) # Remove all handlers from log. [ log . removeHandler ( handler ) for handler in log . handlers ]", "docstring_tokens": "Close log", "label": 0}, {"idx": "cosqa-train-2865", "doc": "how do you extract the username and password from the password file in python", "code": "def read_credentials(fname):\n    \"\"\"\n    read a simple text file from a private location to get\n    username and password\n    \"\"\"\n    with open(fname, 'r') as f:\n        username = f.readline().strip('\\n')\n        password = f.readline().strip('\\n')\n    return username, password", "code_tokens": "def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\\n' ) password = f . readline ( ) . strip ( '\\n' ) return username , password", "docstring_tokens": "read a simple text file from a private location to get username and password", "label": 1}, {"idx": "cosqa-train-2866", "doc": "python logging config using ini files", "code": "def load_config(filename=\"logging.ini\", *args, **kwargs):\n    \"\"\"\n    Load logger config from file\n    \n    Keyword arguments:\n    filename -- configuration filename (Default: \"logging.ini\")\n    *args -- options passed to fileConfig\n    **kwargs -- options passed to fileConfigg\n    \n    \"\"\"\n    logging.config.fileConfig(filename, *args, **kwargs)", "code_tokens": "def load_config ( filename = \"logging.ini\" , * args , * * kwargs ) : logging . config . fileConfig ( filename , * args , * * kwargs )", "docstring_tokens": "Load logger config from file Keyword arguments : filename -- configuration filename ( Default : logging . ini ) * args -- options passed to fileConfig ** kwargs -- options passed to fileConfigg", "label": 0}, {"idx": "cosqa-train-2867", "doc": "how do you get only latitude and longitude using geocode in python", "code": "def get_geoip(ip):\n    \"\"\"Lookup country for IP address.\"\"\"\n    reader = geolite2.reader()\n    ip_data = reader.get(ip) or {}\n    return ip_data.get('country', {}).get('iso_code')", "code_tokens": "def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )", "docstring_tokens": "Lookup country for IP address .", "label": 0}, {"idx": "cosqa-train-2868", "doc": "python logging fro mdict, handler not in logger handlers", "code": "def setLoggerAll(self, mthd):\n        \"\"\" Sends all messages to ``logger.[mthd]()`` for handling \"\"\"\n        for key in self._logger_methods:\n            self._logger_methods[key] = mthd", "code_tokens": "def setLoggerAll ( self , mthd ) : for key in self . _logger_methods : self . _logger_methods [ key ] = mthd", "docstring_tokens": "Sends all messages to logger . [ mthd ] () for handling", "label": 0}, {"idx": "cosqa-train-2869", "doc": "how do you give python range in django", "code": "def time_range(from_=None, to=None):  # todo datetime conversion\n    \"\"\"\n    :param str from_:\n    :param str to:\n\n    :return: dict\n    \"\"\"\n    args = locals()\n    return {\n        k.replace('_', ''): v for k, v in args.items()\n    }", "code_tokens": "def time_range ( from_ = None , to = None ) : # todo datetime conversion args = locals ( ) return { k . replace ( '_' , '' ) : v for k , v in args . items ( ) }", "docstring_tokens": ": param str from_ : : param str to :", "label": 0}, {"idx": "cosqa-train-2870", "doc": "python logging get all loggers", "code": "def _get_loggers():\n    \"\"\"Return list of Logger classes.\"\"\"\n    from .. import loader\n    modules = loader.get_package_modules('logger')\n    return list(loader.get_plugins(modules, [_Logger]))", "code_tokens": "def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )", "docstring_tokens": "Return list of Logger classes .", "label": 1}, {"idx": "cosqa-train-2871", "doc": "how do you join 2 data frames python", "code": "def cross_join(df1, df2):\n    \"\"\"\n    Return a dataframe that is a cross between dataframes\n    df1 and df2\n\n    ref: https://github.com/pydata/pandas/issues/5401\n    \"\"\"\n    if len(df1) == 0:\n        return df2\n\n    if len(df2) == 0:\n        return df1\n\n    # Add as lists so that the new index keeps the items in\n    # the order that they are added together\n    all_columns = pd.Index(list(df1.columns) + list(df2.columns))\n    df1['key'] = 1\n    df2['key'] = 1\n    return pd.merge(df1, df2, on='key').loc[:, all_columns]", "code_tokens": "def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]", "docstring_tokens": "Return a dataframe that is a cross between dataframes df1 and df2", "label": 0}, {"idx": "cosqa-train-2872", "doc": "python logging handlers rotatingfilehandler", "code": "def timed_rotating_file_handler(name, logname, filename, when='h',\n                                interval=1, backupCount=0,\n                                encoding=None, delay=False, utc=False):\n    \"\"\"\n    A Bark logging handler logging output to a named file.  At\n    intervals specified by the 'when', the file will be rotated, under\n    control of 'backupCount'.\n\n    Similar to logging.handlers.TimedRotatingFileHandler.\n    \"\"\"\n\n    return wrap_log_handler(logging.handlers.TimedRotatingFileHandler(\n        filename, when=when, interval=interval, backupCount=backupCount,\n        encoding=encoding, delay=delay, utc=utc))", "code_tokens": "def timed_rotating_file_handler ( name , logname , filename , when = 'h' , interval = 1 , backupCount = 0 , encoding = None , delay = False , utc = False ) : return wrap_log_handler ( logging . handlers . TimedRotatingFileHandler ( filename , when = when , interval = interval , backupCount = backupCount , encoding = encoding , delay = delay , utc = utc ) )", "docstring_tokens": "A Bark logging handler logging output to a named file . At intervals specified by the when the file will be rotated under control of backupCount .", "label": 0}, {"idx": "cosqa-train-2873", "doc": "how do you make a string into a list in python", "code": "def path_to_list(pathstr):\n    \"\"\"Conver a path string to a list of path elements.\"\"\"\n    return [elem for elem in pathstr.split(os.path.pathsep) if elem]", "code_tokens": "def path_to_list ( pathstr ) : return [ elem for elem in pathstr . split ( os . path . pathsep ) if elem ]", "docstring_tokens": "Conver a path string to a list of path elements .", "label": 1}, {"idx": "cosqa-train-2874", "doc": "python logging how to define handler in code", "code": "def logger(message, level=10):\n    \"\"\"Handle logging.\"\"\"\n    logging.getLogger(__name__).log(level, str(message))", "code_tokens": "def logger ( message , level = 10 ) : logging . getLogger ( __name__ ) . log ( level , str ( message ) )", "docstring_tokens": "Handle logging .", "label": 0}, {"idx": "cosqa-train-2875", "doc": "how do you specify absolute path name in python", "code": "def relative_path(path):\n    \"\"\"\n    Return the given path relative to this file.\n    \"\"\"\n    return os.path.join(os.path.dirname(__file__), path)", "code_tokens": "def relative_path ( path ) : return os . path . join ( os . path . dirname ( __file__ ) , path )", "docstring_tokens": "Return the given path relative to this file .", "label": 0}, {"idx": "cosqa-train-2876", "doc": "python logging print function name", "code": "def pylog(self, *args, **kwargs):\n        \"\"\"Display all available logging information.\"\"\"\n        printerr(self.name, args, kwargs, traceback.format_exc())", "code_tokens": "def pylog ( self , * args , * * kwargs ) : printerr ( self . name , args , kwargs , traceback . format_exc ( ) )", "docstring_tokens": "Display all available logging information .", "label": 1}, {"idx": "cosqa-train-2877", "doc": "how exit python in linux", "code": "def fast_exit(code):\n    \"\"\"Exit without garbage collection, this speeds up exit by about 10ms for\n    things like bash completion.\n    \"\"\"\n    sys.stdout.flush()\n    sys.stderr.flush()\n    os._exit(code)", "code_tokens": "def fast_exit ( code ) : sys . stdout . flush ( ) sys . stderr . flush ( ) os . _exit ( code )", "docstring_tokens": "Exit without garbage collection this speeds up exit by about 10ms for things like bash completion .", "label": 0}, {"idx": "cosqa-train-2878", "doc": "how invoke web services in python", "code": "def web(host, port):\n    \"\"\"Start web application\"\"\"\n    from .webserver.web import get_app\n    get_app().run(host=host, port=port)", "code_tokens": "def web ( host , port ) : from . webserver . web import get_app get_app ( ) . run ( host = host , port = port )", "docstring_tokens": "Start web application", "label": 0}, {"idx": "cosqa-train-2879", "doc": "how ot multi index in python", "code": "def validate_multiindex(self, obj):\n        \"\"\"validate that we can store the multi-index; reset and return the\n        new object\n        \"\"\"\n        levels = [l if l is not None else \"level_{0}\".format(i)\n                  for i, l in enumerate(obj.index.names)]\n        try:\n            return obj.reset_index(), levels\n        except ValueError:\n            raise ValueError(\"duplicate names/columns in the multi-index when \"\n                             \"storing as a table\")", "code_tokens": "def validate_multiindex ( self , obj ) : levels = [ l if l is not None else \"level_{0}\" . format ( i ) for i , l in enumerate ( obj . index . names ) ] try : return obj . reset_index ( ) , levels except ValueError : raise ValueError ( \"duplicate names/columns in the multi-index when \" \"storing as a table\" )", "docstring_tokens": "validate that we can store the multi - index ; reset and return the new object", "label": 0}, {"idx": "cosqa-train-2880", "doc": "python lookup country based on lat long", "code": "def get_geoip(ip):\n    \"\"\"Lookup country for IP address.\"\"\"\n    reader = geolite2.reader()\n    ip_data = reader.get(ip) or {}\n    return ip_data.get('country', {}).get('iso_code')", "code_tokens": "def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )", "docstring_tokens": "Lookup country for IP address .", "label": 1}, {"idx": "cosqa-train-2881", "doc": "how t op ass sys arghuments from another python script \\", "code": "def aug_sysargv(cmdstr):\n    \"\"\" DEBUG FUNC modify argv to look like you ran a command \"\"\"\n    import shlex\n    argv = shlex.split(cmdstr)\n    sys.argv.extend(argv)", "code_tokens": "def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )", "docstring_tokens": "DEBUG FUNC modify argv to look like you ran a command", "label": 0}, {"idx": "cosqa-train-2882", "doc": "python loop to compare every element in 2 arrays to every element", "code": "def compare(a, b):\n    \"\"\"\n     Compare items in 2 arrays. Returns sum(abs(a(i)-b(i)))\n    \"\"\"\n    s=0\n    for i in range(len(a)):\n        s=s+abs(a[i]-b[i])\n    return s", "code_tokens": "def compare ( a , b ) : s = 0 for i in range ( len ( a ) ) : s = s + abs ( a [ i ] - b [ i ] ) return s", "docstring_tokens": "Compare items in 2 arrays . Returns sum ( abs ( a ( i ) - b ( i )))", "label": 0}, {"idx": "cosqa-train-2883", "doc": "how to access 1d array in python", "code": "def torecarray(*args, **kwargs):\n    \"\"\"\n    Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.\n\n    \"\"\"\n\n    import numpy as np\n    return toarray(*args, **kwargs).view(np.recarray)", "code_tokens": "def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )", "docstring_tokens": "Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) .", "label": 0}, {"idx": "cosqa-train-2884", "doc": "python lower and slash string", "code": "def camelcase_to_slash(name):\n    \"\"\" Converts CamelCase to camel/case\n\n    code ripped from http://stackoverflow.com/questions/1175208/does-the-python-standard-library-have-function-to-convert-camelcase-to-camel-cas\n    \"\"\"\n\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1/\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1/\\2', s1).lower()", "code_tokens": "def camelcase_to_slash ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1/\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1/\\2' , s1 ) . lower ( )", "docstring_tokens": "Converts CamelCase to camel / case", "label": 0}, {"idx": "cosqa-train-2885", "doc": "how to access the message in attributeerror python", "code": "def clean_error(err):\n    \"\"\"\n    Take stderr bytes returned from MicroPython and attempt to create a\n    non-verbose error message.\n    \"\"\"\n    if err:\n        decoded = err.decode('utf-8')\n        try:\n            return decoded.split('\\r\\n')[-2]\n        except Exception:\n            return decoded\n    return 'There was an error.'", "code_tokens": "def clean_error ( err ) : if err : decoded = err . decode ( 'utf-8' ) try : return decoded . split ( '\\r\\n' ) [ - 2 ] except Exception : return decoded return 'There was an error.'", "docstring_tokens": "Take stderr bytes returned from MicroPython and attempt to create a non - verbose error message .", "label": 0}, {"idx": "cosqa-train-2886", "doc": "python lxml account for notext in xpath", "code": "def _extract_node_text(node):\n    \"\"\"Extract text from a given lxml node.\"\"\"\n\n    texts = map(\n        six.text_type.strip, map(six.text_type, map(unescape, node.xpath(\".//text()\")))\n    )\n    return \" \".join(text for text in texts if text)", "code_tokens": "def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( \".//text()\" ) ) ) ) return \" \" . join ( text for text in texts if text )", "docstring_tokens": "Extract text from a given lxml node .", "label": 0}, {"idx": "cosqa-train-2887", "doc": "how to activate tensorflow in python", "code": "def main(argv=None):\n  \"\"\"Run a Tensorflow model on the Iris dataset.\"\"\"\n  args = parse_arguments(sys.argv if argv is None else argv)\n\n  tf.logging.set_verbosity(tf.logging.INFO)\n  learn_runner.run(\n      experiment_fn=get_experiment_fn(args),\n      output_dir=args.job_dir)", "code_tokens": "def main ( argv = None ) : args = parse_arguments ( sys . argv if argv is None else argv ) tf . logging . set_verbosity ( tf . logging . INFO ) learn_runner . run ( experiment_fn = get_experiment_fn ( args ) , output_dir = args . job_dir )", "docstring_tokens": "Run a Tensorflow model on the Iris dataset .", "label": 0}, {"idx": "cosqa-train-2888", "doc": "python lxml get all text under node", "code": "def _extract_node_text(node):\n    \"\"\"Extract text from a given lxml node.\"\"\"\n\n    texts = map(\n        six.text_type.strip, map(six.text_type, map(unescape, node.xpath(\".//text()\")))\n    )\n    return \" \".join(text for text in texts if text)", "code_tokens": "def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( \".//text()\" ) ) ) ) return \" \" . join ( text for text in texts if text )", "docstring_tokens": "Extract text from a given lxml node .", "label": 0}, {"idx": "cosqa-train-2889", "doc": "how to add a suffix to a file in python", "code": "def add_suffix(fullname, suffix):\n    \"\"\" Add suffix to a full file name\"\"\"\n    name, ext = os.path.splitext(fullname)\n    return name + '_' + suffix + ext", "code_tokens": "def add_suffix ( fullname , suffix ) : name , ext = os . path . splitext ( fullname ) return name + '_' + suffix + ext", "docstring_tokens": "Add suffix to a full file name", "label": 0}, {"idx": "cosqa-train-2890", "doc": "how to add assertion error in python", "code": "def process_instance(self, instance):\n        self.log.debug(\"e = mc^2\")\n        self.log.info(\"About to fail..\")\n        self.log.warning(\"Failing.. soooon..\")\n        self.log.critical(\"Ok, you're done.\")\n        assert False, \"\"\"ValidateFailureMock was destined to fail..\n\nHere's some extended information about what went wrong.\n\nIt has quite the long string associated with it, including\na few newlines and a list.\n\n- Item 1\n- Item 2\n\n\"\"\"", "code_tokens": "def process_instance ( self , instance ) : self . log . debug ( \"e = mc^2\" ) self . log . info ( \"About to fail..\" ) self . log . warning ( \"Failing.. soooon..\" ) self . log . critical ( \"Ok, you're done.\" ) assert False , \"\"\"ValidateFailureMock was destined to fail..\n\nHere's some extended information about what went wrong.\n\nIt has quite the long string associated with it, including\na few newlines and a list.\n\n- Item 1\n- Item 2\n\n\"\"\"", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-2891", "doc": "python magicmock add a function", "code": "def mock_add_spec(self, spec, spec_set=False):\n        \"\"\"Add a spec to a mock. `spec` can either be an object or a\n        list of strings. Only attributes on the `spec` can be fetched as\n        attributes from the mock.\n\n        If `spec_set` is True then only attributes on the spec can be set.\"\"\"\n        self._mock_add_spec(spec, spec_set)\n        self._mock_set_magics()", "code_tokens": "def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )", "docstring_tokens": "Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock .", "label": 0}, {"idx": "cosqa-train-2892", "doc": "how to add css to python using django", "code": "def markdown_media_css():\n    \"\"\" Add css requirements to HTML.\n\n    :returns: Editor template context.\n\n    \"\"\"\n    return dict(\n        CSS_SET=posixpath.join(\n            settings.MARKDOWN_SET_PATH, settings.MARKDOWN_SET_NAME, 'style.css'\n        ),\n        CSS_SKIN=posixpath.join(\n            'django_markdown', 'skins', settings.MARKDOWN_EDITOR_SKIN,\n            'style.css'\n        )\n    )", "code_tokens": "def markdown_media_css ( ) : return dict ( CSS_SET = posixpath . join ( settings . MARKDOWN_SET_PATH , settings . MARKDOWN_SET_NAME , 'style.css' ) , CSS_SKIN = posixpath . join ( 'django_markdown' , 'skins' , settings . MARKDOWN_EDITOR_SKIN , 'style.css' ) )", "docstring_tokens": "Add css requirements to HTML .", "label": 0}, {"idx": "cosqa-train-2893", "doc": "python main conditional guard", "code": "def less_strict_bool(x):\n    \"\"\"Idempotent and None-safe version of strict_bool.\"\"\"\n    if x is None:\n        return False\n    elif x is True or x is False:\n        return x\n    else:\n        return strict_bool(x)", "code_tokens": "def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )", "docstring_tokens": "Idempotent and None - safe version of strict_bool .", "label": 0}, {"idx": "cosqa-train-2894", "doc": "how to add gaussian noise to an image python", "code": "def smooth_gaussian(image, sigma=1):\n    \"\"\"Returns Gaussian smoothed image.\n\n    :param image: numpy array or :class:`jicimagelib.image.Image`\n    :param sigma: standard deviation\n    :returns: :class:`jicimagelib.image.Image`\n    \"\"\"\n    return scipy.ndimage.filters.gaussian_filter(image, sigma=sigma, mode=\"nearest\")", "code_tokens": "def smooth_gaussian ( image , sigma = 1 ) : return scipy . ndimage . filters . gaussian_filter ( image , sigma = sigma , mode = \"nearest\" )", "docstring_tokens": "Returns Gaussian smoothed image .", "label": 0}, {"idx": "cosqa-train-2895", "doc": "python make 3 list into one", "code": "def cross_list(*sequences):\n  \"\"\"\n  From: http://book.opensourceproject.org.cn/lamp/python/pythoncook2/opensource/0596007973/pythoncook2-chp-19-sect-9.html\n  \"\"\"\n  result = [[ ]]\n  for seq in sequences:\n    result = [sublist+[item] for sublist in result for item in seq]\n  return result", "code_tokens": "def cross_list ( * sequences ) : result = [ [ ] ] for seq in sequences : result = [ sublist + [ item ] for sublist in result for item in seq ] return result", "docstring_tokens": "From : http : // book . opensourceproject . org . cn / lamp / python / pythoncook2 / opensource / 0596007973 / pythoncook2 - chp - 19 - sect - 9 . html", "label": 0}, {"idx": "cosqa-train-2896", "doc": "how to add jquery to my python static folder", "code": "def default_static_path():\n    \"\"\"\n        Return the path to the javascript bundle\n    \"\"\"\n    fdir = os.path.dirname(__file__)\n    return os.path.abspath(os.path.join(fdir, '../assets/'))", "code_tokens": "def default_static_path ( ) : fdir = os . path . dirname ( __file__ ) return os . path . abspath ( os . path . join ( fdir , '../assets/' ) )", "docstring_tokens": "Return the path to the javascript bundle", "label": 0}, {"idx": "cosqa-train-2897", "doc": "python make a string html safe", "code": "def safe_quotes(text, escape_single_quotes=False):\n    \"\"\"htmlify string\"\"\"\n    if isinstance(text, str):\n        safe_text = text.replace('\"', \"&quot;\")\n        if escape_single_quotes:\n            safe_text = safe_text.replace(\"'\", \"&#92;'\")\n        return safe_text.replace('True', 'true')\n    return text", "code_tokens": "def safe_quotes ( text , escape_single_quotes = False ) : if isinstance ( text , str ) : safe_text = text . replace ( '\"' , \"&quot;\" ) if escape_single_quotes : safe_text = safe_text . replace ( \"'\" , \"&#92;'\" ) return safe_text . replace ( 'True' , 'true' ) return text", "docstring_tokens": "htmlify string", "label": 1}, {"idx": "cosqa-train-2898", "doc": "how to apply fillna to none in python", "code": "def clean_dataframe(df):\n    \"\"\"Fill NaNs with the previous value, the next value or if all are NaN then 1.0\"\"\"\n    df = df.fillna(method='ffill')\n    df = df.fillna(0.0)\n    return df", "code_tokens": "def clean_dataframe ( df ) : df = df . fillna ( method = 'ffill' ) df = df . fillna ( 0.0 ) return df", "docstring_tokens": "Fill NaNs with the previous value the next value or if all are NaN then 1 . 0", "label": 0}, {"idx": "cosqa-train-2899", "doc": "python make a string safe for filenames", "code": "def get_filename_safe_string(string):\n    \"\"\"\n    Converts a string to a string that is safe for a filename\n    Args:\n        string (str): A string to make safe for a filename\n\n    Returns:\n        str: A string safe for a filename\n    \"\"\"\n    invalid_filename_chars = ['\\\\', '/', ':', '\"', '*', '?', '|', '\\n',\n                              '\\r']\n    if string is None:\n        string = \"None\"\n    for char in invalid_filename_chars:\n        string = string.replace(char, \"\")\n    string = string.rstrip(\".\")\n\n    return string", "code_tokens": "def get_filename_safe_string ( string ) : invalid_filename_chars = [ '\\\\' , '/' , ':' , '\"' , '*' , '?' , '|' , '\\n' , '\\r' ] if string is None : string = \"None\" for char in invalid_filename_chars : string = string . replace ( char , \"\" ) string = string . rstrip ( \".\" ) return string", "docstring_tokens": "Converts a string to a string that is safe for a filename Args : string ( str ) : A string to make safe for a filename", "label": 1}, {"idx": "cosqa-train-2900", "doc": "how to auto open excel with python", "code": "def _openpyxl_read_xl(xl_path: str):\n    \"\"\" Use openpyxl to read an Excel file. \"\"\"\n    try:\n        wb = load_workbook(filename=xl_path, read_only=True)\n    except:\n        raise\n    else:\n        return wb", "code_tokens": "def _openpyxl_read_xl ( xl_path : str ) : try : wb = load_workbook ( filename = xl_path , read_only = True ) except : raise else : return wb", "docstring_tokens": "Use openpyxl to read an Excel file .", "label": 0}, {"idx": "cosqa-train-2901", "doc": "python make datetime aware", "code": "def date_to_datetime(x):\n    \"\"\"Convert a date into a datetime\"\"\"\n    if not isinstance(x, datetime) and isinstance(x, date):\n        return datetime.combine(x, time())\n    return x", "code_tokens": "def date_to_datetime ( x ) : if not isinstance ( x , datetime ) and isinstance ( x , date ) : return datetime . combine ( x , time ( ) ) return x", "docstring_tokens": "Convert a date into a datetime", "label": 0}, {"idx": "cosqa-train-2902", "doc": "how to automatically open a excel file after a python program runs", "code": "def _openpyxl_read_xl(xl_path: str):\n    \"\"\" Use openpyxl to read an Excel file. \"\"\"\n    try:\n        wb = load_workbook(filename=xl_path, read_only=True)\n    except:\n        raise\n    else:\n        return wb", "code_tokens": "def _openpyxl_read_xl ( xl_path : str ) : try : wb = load_workbook ( filename = xl_path , read_only = True ) except : raise else : return wb", "docstring_tokens": "Use openpyxl to read an Excel file .", "label": 0}, {"idx": "cosqa-train-2903", "doc": "python make input non blocking", "code": "async def async_input(prompt):\n    \"\"\"\n    Python's ``input()`` is blocking, which means the event loop we set\n    above can't be running while we're blocking there. This method will\n    let the loop run while we wait for input.\n    \"\"\"\n    print(prompt, end='', flush=True)\n    return (await loop.run_in_executor(None, sys.stdin.readline)).rstrip()", "code_tokens": "async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "docstring_tokens": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input .", "label": 0}, {"idx": "cosqa-train-2904", "doc": "how to average multiple grided datasets python", "code": "def aggregate(d, y_size, x_size):\n        \"\"\"Average every 4 elements (2x2) in a 2D array\"\"\"\n        if d.ndim != 2:\n            # we can't guarantee what blocks we are getting and how\n            # it should be reshaped to do the averaging.\n            raise ValueError(\"Can't aggregrate (reduce) data arrays with \"\n                             \"more than 2 dimensions.\")\n        if not (x_size.is_integer() and y_size.is_integer()):\n            raise ValueError(\"Aggregation factors are not integers\")\n        for agg_size, chunks in zip([y_size, x_size], d.chunks):\n            for chunk_size in chunks:\n                if chunk_size % agg_size != 0:\n                    raise ValueError(\"Aggregation requires arrays with \"\n                                     \"shapes and chunks divisible by the \"\n                                     \"factor\")\n\n        new_chunks = (tuple(int(x / y_size) for x in d.chunks[0]),\n                      tuple(int(x / x_size) for x in d.chunks[1]))\n        return da.core.map_blocks(_mean, d, y_size, x_size, dtype=d.dtype, chunks=new_chunks)", "code_tokens": "def aggregate ( d , y_size , x_size ) : if d . ndim != 2 : # we can't guarantee what blocks we are getting and how # it should be reshaped to do the averaging. raise ValueError ( \"Can't aggregrate (reduce) data arrays with \" \"more than 2 dimensions.\" ) if not ( x_size . is_integer ( ) and y_size . is_integer ( ) ) : raise ValueError ( \"Aggregation factors are not integers\" ) for agg_size , chunks in zip ( [ y_size , x_size ] , d . chunks ) : for chunk_size in chunks : if chunk_size % agg_size != 0 : raise ValueError ( \"Aggregation requires arrays with \" \"shapes and chunks divisible by the \" \"factor\" ) new_chunks = ( tuple ( int ( x / y_size ) for x in d . chunks [ 0 ] ) , tuple ( int ( x / x_size ) for x in d . chunks [ 1 ] ) ) return da . core . map_blocks ( _mean , d , y_size , x_size , dtype = d . dtype , chunks = new_chunks )", "docstring_tokens": "Average every 4 elements ( 2x2 ) in a 2D array", "label": 0}, {"idx": "cosqa-train-2905", "doc": "python make regex pattern from string", "code": "def make_regex(separator):\n    \"\"\"Utility function to create regexp for matching escaped separators\n    in strings.\n\n    \"\"\"\n    return re.compile(r'(?:' + re.escape(separator) + r')?((?:[^' +\n                      re.escape(separator) + r'\\\\]|\\\\.)+)')", "code_tokens": "def make_regex ( separator ) : return re . compile ( r'(?:' + re . escape ( separator ) + r')?((?:[^' + re . escape ( separator ) + r'\\\\]|\\\\.)+)' )", "docstring_tokens": "Utility function to create regexp for matching escaped separators in strings .", "label": 0}, {"idx": "cosqa-train-2906", "doc": "how to best implement rollbacks in python", "code": "def rollback(self):\n\t\t\"\"\"\n\t\tRollback MySQL Transaction to database.\n\t\tMySQLDB: If the database and tables support transactions, this rolls \n\t\tback (cancels) the current transaction; otherwise a \n\t\tNotSupportedError is raised.\n\t\t\n\t\t@author: Nick Verbeck\n\t\t@since: 5/12/2008\n\t\t\"\"\"\n\t\ttry:\n\t\t\tif self.connection is not None:\n\t\t\t\tself.connection.rollback()\n\t\t\t\tself._updateCheckTime()\n\t\t\t\tself.release()\n\t\texcept Exception, e:\n\t\t\tpass", "code_tokens": "def rollback ( self ) : try : if self . connection is not None : self . connection . rollback ( ) self . _updateCheckTime ( ) self . release ( ) except Exception , e : pass", "docstring_tokens": "Rollback MySQL Transaction to database . MySQLDB : If the database and tables support transactions this rolls back ( cancels ) the current transaction ; otherwise a NotSupportedError is raised .", "label": 1}, {"idx": "cosqa-train-2907", "doc": "python mapping array of arrays to dict", "code": "def to_dicts(recarray):\n    \"\"\"convert record array to a dictionaries\"\"\"\n    for rec in recarray:\n        yield dict(zip(recarray.dtype.names, rec.tolist()))", "code_tokens": "def to_dicts ( recarray ) : for rec in recarray : yield dict ( zip ( recarray . dtype . names , rec . tolist ( ) ) )", "docstring_tokens": "convert record array to a dictionaries", "label": 0}, {"idx": "cosqa-train-2908", "doc": "how to build a scalar function in python", "code": "def Softsign(a):\n    \"\"\"\n    Softsign op.\n    \"\"\"\n    return np.divide(a, np.add(np.abs(a), 1)),", "code_tokens": "def Softsign ( a ) : return np . divide ( a , np . add ( np . abs ( a ) , 1 ) ) ,", "docstring_tokens": "Softsign op .", "label": 0}, {"idx": "cosqa-train-2909", "doc": "python match return a word", "code": "def find_whole_word(w):\n    \"\"\"\n    Scan through string looking for a location where this word produces a match,\n    and return a corresponding MatchObject instance.\n    Return None if no position in the string matches the pattern;\n    note that this is different from finding a zero-length match at some point in the string.\n    \"\"\"\n    return re.compile(r'\\b({0})\\b'.format(w), flags=re.IGNORECASE).search", "code_tokens": "def find_whole_word ( w ) : return re . compile ( r'\\b({0})\\b' . format ( w ) , flags = re . IGNORECASE ) . search", "docstring_tokens": "Scan through string looking for a location where this word produces a match and return a corresponding MatchObject instance . Return None if no position in the string matches the pattern ; note that this is different from finding a zero - length match at some point in the string .", "label": 0}, {"idx": "cosqa-train-2910", "doc": "how to calculate average data in array python", "code": "def variance(arr):\n  \"\"\"variance of the values, must have 2 or more entries.\n\n  :param arr: list of numbers\n  :type arr: number[] a number array\n  :return: variance\n  :rtype: float\n\n  \"\"\"\n  avg = average(arr)\n  return sum([(float(x)-avg)**2 for x in arr])/float(len(arr)-1)", "code_tokens": "def variance ( arr ) : avg = average ( arr ) return sum ( [ ( float ( x ) - avg ) ** 2 for x in arr ] ) / float ( len ( arr ) - 1 )", "docstring_tokens": "variance of the values must have 2 or more entries .", "label": 0}, {"idx": "cosqa-train-2911", "doc": "python matplot plot the histogram with fitting", "code": "def plot(self):\n        \"\"\"Plot the empirical histogram versus best-fit distribution's PDF.\"\"\"\n        plt.plot(self.bin_edges, self.hist, self.bin_edges, self.best_pdf)", "code_tokens": "def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )", "docstring_tokens": "Plot the empirical histogram versus best - fit distribution s PDF .", "label": 0}, {"idx": "cosqa-train-2912", "doc": "how to calculate the pitch of each frame of an audio in python", "code": "def calc_volume(self, sample: np.ndarray):\n        \"\"\"Find the RMS of the audio\"\"\"\n        return sqrt(np.mean(np.square(sample)))", "code_tokens": "def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )", "docstring_tokens": "Find the RMS of the audio", "label": 0}, {"idx": "cosqa-train-2913", "doc": "python matplotlib plot histogram with dynamic bins", "code": "def _histplot_op(ax, data, **kwargs):\n    \"\"\"Add a histogram for the data to the axes.\"\"\"\n    bins = get_bins(data)\n    ax.hist(data, bins=bins, align=\"left\", density=True, **kwargs)\n    return ax", "code_tokens": "def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "docstring_tokens": "Add a histogram for the data to the axes .", "label": 0}, {"idx": "cosqa-train-2914", "doc": "how to calculate the variance of column of an array in python", "code": "def variance(arr):\n  \"\"\"variance of the values, must have 2 or more entries.\n\n  :param arr: list of numbers\n  :type arr: number[] a number array\n  :return: variance\n  :rtype: float\n\n  \"\"\"\n  avg = average(arr)\n  return sum([(float(x)-avg)**2 for x in arr])/float(len(arr)-1)", "code_tokens": "def variance ( arr ) : avg = average ( arr ) return sum ( [ ( float ( x ) - avg ) ** 2 for x in arr ] ) / float ( len ( arr ) - 1 )", "docstring_tokens": "variance of the values must have 2 or more entries .", "label": 0}, {"idx": "cosqa-train-2915", "doc": "python matplotlib remove yaxis", "code": "def axes_off(ax):\n    \"\"\"Get rid of all axis ticks, lines, etc.\n    \"\"\"\n    ax.set_frame_on(False)\n    ax.axes.get_yaxis().set_visible(False)\n    ax.axes.get_xaxis().set_visible(False)", "code_tokens": "def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )", "docstring_tokens": "Get rid of all axis ticks lines etc .", "label": 0}, {"idx": "cosqa-train-2916", "doc": "how to calculate upper and lower case letters in python", "code": "def to_camel_case(snake_case_name):\n    \"\"\"\n    Converts snake_cased_names to CamelCaseNames.\n\n    :param snake_case_name: The name you'd like to convert from.\n    :type snake_case_name: string\n\n    :returns: A converted string\n    :rtype: string\n    \"\"\"\n    bits = snake_case_name.split('_')\n    return ''.join([bit.capitalize() for bit in bits])", "code_tokens": "def to_camel_case ( snake_case_name ) : bits = snake_case_name . split ( '_' ) return '' . join ( [ bit . capitalize ( ) for bit in bits ] )", "docstring_tokens": "Converts snake_cased_names to CamelCaseNames .", "label": 0}, {"idx": "cosqa-train-2917", "doc": "python matplotlib square layout aspect ratio", "code": "def figsize(x=8, y=7., aspect=1.):\n    \"\"\" manually set the default figure size of plots\n    ::Arguments::\n        x (float): x-axis size\n        y (float): y-axis size\n        aspect (float): aspect ratio scalar\n    \"\"\"\n    # update rcparams with adjusted figsize params\n    mpl.rcParams.update({'figure.figsize': (x*aspect, y)})", "code_tokens": "def figsize ( x = 8 , y = 7. , aspect = 1. ) : # update rcparams with adjusted figsize params mpl . rcParams . update ( { 'figure.figsize' : ( x * aspect , y ) } )", "docstring_tokens": "manually set the default figure size of plots :: Arguments :: x ( float ) : x - axis size y ( float ) : y - axis size aspect ( float ) : aspect ratio scalar", "label": 0}, {"idx": "cosqa-train-2918", "doc": "how to call last item in column in python", "code": "def get_last(self, table=None):\n        \"\"\"Just the last entry.\"\"\"\n        if table is None: table = self.main_table\n        query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table\n        return self.own_cursor.execute(query).fetchone()", "code_tokens": "def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )", "docstring_tokens": "Just the last entry .", "label": 0}, {"idx": "cosqa-train-2919", "doc": "python matrix to grey scale image", "code": "def rgb2gray(img):\n    \"\"\"Converts an RGB image to grayscale using matlab's algorithm.\"\"\"\n    T = np.linalg.inv(np.array([\n        [1.0,  0.956,  0.621],\n        [1.0, -0.272, -0.647],\n        [1.0, -1.106,  1.703],\n    ]))\n    r_c, g_c, b_c = T[0]\n    r, g, b = np.rollaxis(as_float_image(img), axis=-1)\n    return r_c * r + g_c * g + b_c * b", "code_tokens": "def rgb2gray ( img ) : T = np . linalg . inv ( np . array ( [ [ 1.0 , 0.956 , 0.621 ] , [ 1.0 , - 0.272 , - 0.647 ] , [ 1.0 , - 1.106 , 1.703 ] , ] ) ) r_c , g_c , b_c = T [ 0 ] r , g , b = np . rollaxis ( as_float_image ( img ) , axis = - 1 ) return r_c * r + g_c * g + b_c * b", "docstring_tokens": "Converts an RGB image to grayscale using matlab s algorithm .", "label": 1}, {"idx": "cosqa-train-2920", "doc": "how to call on a matrix and eac column python", "code": "def jac(x,a):\n    \"\"\" Jacobian matrix given Christophe's suggestion of f \"\"\"\n    return (x-a) / np.sqrt(((x-a)**2).sum(1))[:,np.newaxis]", "code_tokens": "def jac ( x , a ) : return ( x - a ) / np . sqrt ( ( ( x - a ) ** 2 ) . sum ( 1 ) ) [ : , np . newaxis ]", "docstring_tokens": "Jacobian matrix given Christophe s suggestion of f", "label": 0}, {"idx": "cosqa-train-2921", "doc": "how to call unit test python", "code": "def test(*args):\n    \"\"\"\n    Run unit tests.\n    \"\"\"\n    subprocess.call([\"py.test-2.7\"] + list(args))\n    subprocess.call([\"py.test-3.4\"] + list(args))", "code_tokens": "def test ( * args ) : subprocess . call ( [ \"py.test-2.7\" ] + list ( args ) ) subprocess . call ( [ \"py.test-3.4\" ] + list ( args ) )", "docstring_tokens": "Run unit tests .", "label": 1}, {"idx": "cosqa-train-2922", "doc": "python max heap with input list is a file", "code": "def _heapify_max(x):\n    \"\"\"Transform list into a maxheap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    for i in reversed(range(n//2)):\n        _siftup_max(x, i)", "code_tokens": "def _heapify_max ( x ) : n = len ( x ) for i in reversed ( range ( n // 2 ) ) : _siftup_max ( x , i )", "docstring_tokens": "Transform list into a maxheap in - place in O ( len ( x )) time .", "label": 0}, {"idx": "cosqa-train-2923", "doc": "how to cast each and everyelemnt of a list to string in python", "code": "def commajoin_as_strings(iterable):\n    \"\"\" Join the given iterable with ',' \"\"\"\n    return _(u',').join((six.text_type(i) for i in iterable))", "code_tokens": "def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )", "docstring_tokens": "Join the given iterable with", "label": 0}, {"idx": "cosqa-train-2924", "doc": "python max over 2d array", "code": "def SegmentMax(a, ids):\n    \"\"\"\n    Segmented max op.\n    \"\"\"\n    func = lambda idxs: np.amax(a[idxs], axis=0)\n    return seg_map(func, a, ids),", "code_tokens": "def SegmentMax ( a , ids ) : func = lambda idxs : np . amax ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,", "docstring_tokens": "Segmented max op .", "label": 0}, {"idx": "cosqa-train-2925", "doc": "how to change a 1 value list to a tuple in python", "code": "def as_tuple(self, value):\n        \"\"\"Utility function which converts lists to tuples.\"\"\"\n        if isinstance(value, list):\n            value = tuple(value)\n        return value", "code_tokens": "def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value", "docstring_tokens": "Utility function which converts lists to tuples .", "label": 0}, {"idx": "cosqa-train-2926", "doc": "python max sub min inline range", "code": "def min_values(args):\n    \"\"\" Return possible range for min function. \"\"\"\n    return Interval(min(x.low for x in args), min(x.high for x in args))", "code_tokens": "def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )", "docstring_tokens": "Return possible range for min function .", "label": 0}, {"idx": "cosqa-train-2927", "doc": "how to change a dictionary to a numy array in python", "code": "def C_dict2array(C):\n    \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"\n    return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "code_tokens": "def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )", "docstring_tokens": "Convert an OrderedDict containing C values to a 1D array .", "label": 1}, {"idx": "cosqa-train-2928", "doc": "python md5 large file", "code": "def md5_hash_file(fh):\n    \"\"\"Return the md5 hash of the given file-object\"\"\"\n    md5 = hashlib.md5()\n    while True:\n        data = fh.read(8192)\n        if not data:\n            break\n        md5.update(data)\n    return md5.hexdigest()", "code_tokens": "def md5_hash_file ( fh ) : md5 = hashlib . md5 ( ) while True : data = fh . read ( 8192 ) if not data : break md5 . update ( data ) return md5 . hexdigest ( )", "docstring_tokens": "Return the md5 hash of the given file - object", "label": 0}, {"idx": "cosqa-train-2929", "doc": "how to change cell color through python", "code": "def change_cell(self, x, y, ch, fg, bg):\n        \"\"\"Change cell in position (x;y).\n        \"\"\"\n        self.console.draw_char(x, y, ch, fg, bg)", "code_tokens": "def change_cell ( self , x , y , ch , fg , bg ) : self . console . draw_char ( x , y , ch , fg , bg )", "docstring_tokens": "Change cell in position ( x ; y ) .", "label": 0}, {"idx": "cosqa-train-2930", "doc": "python measure function time", "code": "def memory_usage(method):\n  \"\"\"Log memory usage before and after a method.\"\"\"\n  def wrapper(*args, **kwargs):\n    logging.info('Memory before method %s is %s.',\n                 method.__name__, runtime.memory_usage().current())\n    result = method(*args, **kwargs)\n    logging.info('Memory after method %s is %s',\n                 method.__name__, runtime.memory_usage().current())\n    return result\n  return wrapper", "code_tokens": "def memory_usage ( method ) : def wrapper ( * args , * * kwargs ) : logging . info ( 'Memory before method %s is %s.' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) result = method ( * args , * * kwargs ) logging . info ( 'Memory after method %s is %s' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) return result return wrapper", "docstring_tokens": "Log memory usage before and after a method .", "label": 1}, {"idx": "cosqa-train-2931", "doc": "how to change color of print in python 3", "code": "def auto():\n\t\"\"\"set colouring on if STDOUT is a terminal device, off otherwise\"\"\"\n\ttry:\n\t\tStyle.enabled = False\n\t\tStyle.enabled = sys.stdout.isatty()\n\texcept (AttributeError, TypeError):\n\t\tpass", "code_tokens": "def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass", "docstring_tokens": "set colouring on if STDOUT is a terminal device off otherwise", "label": 0}, {"idx": "cosqa-train-2932", "doc": "python measure string in font", "code": "def _rendered_size(text, point_size, font_file):\n    \"\"\"\n    Return a (width, height) pair representing the size of *text* in English\n    Metric Units (EMU) when rendered at *point_size* in the font defined in\n    *font_file*.\n    \"\"\"\n    emu_per_inch = 914400\n    px_per_inch = 72.0\n\n    font = _Fonts.font(font_file, point_size)\n    px_width, px_height = font.getsize(text)\n\n    emu_width = int(px_width / px_per_inch * emu_per_inch)\n    emu_height = int(px_height / px_per_inch * emu_per_inch)\n\n    return emu_width, emu_height", "code_tokens": "def _rendered_size ( text , point_size , font_file ) : emu_per_inch = 914400 px_per_inch = 72.0 font = _Fonts . font ( font_file , point_size ) px_width , px_height = font . getsize ( text ) emu_width = int ( px_width / px_per_inch * emu_per_inch ) emu_height = int ( px_height / px_per_inch * emu_per_inch ) return emu_width , emu_height", "docstring_tokens": "Return a ( width height ) pair representing the size of * text * in English Metric Units ( EMU ) when rendered at * point_size * in the font defined in * font_file * .", "label": 0}, {"idx": "cosqa-train-2933", "doc": "how to change one speicifc column name python", "code": "def col_rename(df,col_name,new_col_name):\n    \"\"\" Changes a column name in a DataFrame\n    Parameters:\n    df - DataFrame\n        DataFrame to operate on\n    col_name - string\n        Name of column to change\n    new_col_name - string\n        New name of column\n    \"\"\"\n    col_list = list(df.columns)\n    for index,value in enumerate(col_list):\n        if value == col_name:\n            col_list[index] = new_col_name\n            break\n    df.columns = col_list", "code_tokens": "def col_rename ( df , col_name , new_col_name ) : col_list = list ( df . columns ) for index , value in enumerate ( col_list ) : if value == col_name : col_list [ index ] = new_col_name break df . columns = col_list", "docstring_tokens": "Changes a column name in a DataFrame Parameters : df - DataFrame DataFrame to operate on col_name - string Name of column to change new_col_name - string New name of column", "label": 0}, {"idx": "cosqa-train-2934", "doc": "python mechanize how to identify login form by id", "code": "def submit_form_id(step, id):\n    \"\"\"\n    Submit the form having given id.\n    \"\"\"\n    form = world.browser.find_element_by_xpath(str('id(\"{id}\")'.format(id=id)))\n    form.submit()", "code_tokens": "def submit_form_id ( step , id ) : form = world . browser . find_element_by_xpath ( str ( 'id(\"{id}\")' . format ( id = id ) ) ) form . submit ( )", "docstring_tokens": "Submit the form having given id .", "label": 1}, {"idx": "cosqa-train-2935", "doc": "how to change string type to a float python", "code": "def _tofloat(obj):\n    \"\"\"Convert to float if object is a float string.\"\"\"\n    if \"inf\" in obj.lower().strip():\n        return obj\n    try:\n        return int(obj)\n    except ValueError:\n        try:\n            return float(obj)\n        except ValueError:\n            return obj", "code_tokens": "def _tofloat ( obj ) : if \"inf\" in obj . lower ( ) . strip ( ) : return obj try : return int ( obj ) except ValueError : try : return float ( obj ) except ValueError : return obj", "docstring_tokens": "Convert to float if object is a float string .", "label": 0}, {"idx": "cosqa-train-2936", "doc": "python message subject decode", "code": "def get_subject(self, msg):\n        \"\"\"Extracts the subject line from an EmailMessage object.\"\"\"\n\n        text, encoding = decode_header(msg['subject'])[-1]\n\n        try:\n            text = text.decode(encoding)\n\n        # If it's already decoded, ignore error\n        except AttributeError:\n            pass\n\n        return text", "code_tokens": "def get_subject ( self , msg ) : text , encoding = decode_header ( msg [ 'subject' ] ) [ - 1 ] try : text = text . decode ( encoding ) # If it's already decoded, ignore error except AttributeError : pass return text", "docstring_tokens": "Extracts the subject line from an EmailMessage object .", "label": 1}, {"idx": "cosqa-train-2937", "doc": "how to change the cmd to conda config anaconda python", "code": "def update(packages, env=None, user=None):\n    \"\"\"\n    Update conda packages in a conda env\n\n    Attributes\n    ----------\n        packages: list of packages comma delimited\n    \"\"\"\n    packages = ' '.join(packages.split(','))\n    cmd = _create_conda_cmd('update', args=[packages, '--yes', '-q'], env=env, user=user)\n    return _execcmd(cmd, user=user)", "code_tokens": "def update ( packages , env = None , user = None ) : packages = ' ' . join ( packages . split ( ',' ) ) cmd = _create_conda_cmd ( 'update' , args = [ packages , '--yes' , '-q' ] , env = env , user = user ) return _execcmd ( cmd , user = user )", "docstring_tokens": "Update conda packages in a conda env", "label": 0}, {"idx": "cosqa-train-2938", "doc": "python method to make lowercase", "code": "def downcaseTokens(s,l,t):\n    \"\"\"Helper parse action to convert tokens to lower case.\"\"\"\n    return [ tt.lower() for tt in map(_ustr,t) ]", "code_tokens": "def downcaseTokens ( s , l , t ) : return [ tt . lower ( ) for tt in map ( _ustr , t ) ]", "docstring_tokens": "Helper parse action to convert tokens to lower case .", "label": 0}, {"idx": "cosqa-train-2939", "doc": "how to check a datatype in python", "code": "def make_kind_check(python_types, numpy_kind):\n    \"\"\"\n    Make a function that checks whether a scalar or array is of a given kind\n    (e.g. float, int, datetime, timedelta).\n    \"\"\"\n    def check(value):\n        if hasattr(value, 'dtype'):\n            return value.dtype.kind == numpy_kind\n        return isinstance(value, python_types)\n    return check", "code_tokens": "def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check", "docstring_tokens": "Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) .", "label": 0}, {"idx": "cosqa-train-2940", "doc": "how to check a file format in python stack overflow", "code": "def _check_fpos(self, fp_, fpos, offset, block):\n        \"\"\"Check file position matches blocksize\"\"\"\n        if (fp_.tell() + offset != fpos):\n            warnings.warn(\"Actual \"+block+\" header size does not match expected\")\n        return", "code_tokens": "def _check_fpos ( self , fp_ , fpos , offset , block ) : if ( fp_ . tell ( ) + offset != fpos ) : warnings . warn ( \"Actual \" + block + \" header size does not match expected\" ) return", "docstring_tokens": "Check file position matches blocksize", "label": 0}, {"idx": "cosqa-train-2941", "doc": "python mock call check all calls", "code": "def assert_any_call(self, *args, **kwargs):\n        \"\"\"assert the mock has been called with the specified arguments.\n\n        The assert passes if the mock has *ever* been called, unlike\n        `assert_called_with` and `assert_called_once_with` that only pass if\n        the call is the most recent one.\"\"\"\n        kall = call(*args, **kwargs)\n        if kall not in self.call_args_list:\n            expected_string = self._format_mock_call_signature(args, kwargs)\n            raise AssertionError(\n                '%s call not found' % expected_string\n            )", "code_tokens": "def assert_any_call ( self , * args , * * kwargs ) : kall = call ( * args , * * kwargs ) if kall not in self . call_args_list : expected_string = self . _format_mock_call_signature ( args , kwargs ) raise AssertionError ( '%s call not found' % expected_string )", "docstring_tokens": "assert the mock has been called with the specified arguments .", "label": 0}, {"idx": "cosqa-train-2942", "doc": "how to check a type of a arguement in python", "code": "def email_type(arg):\n\t\"\"\"An argparse type representing an email address.\"\"\"\n\tif not is_valid_email_address(arg):\n\t\traise argparse.ArgumentTypeError(\"{0} is not a valid email address\".format(repr(arg)))\n\treturn arg", "code_tokens": "def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( \"{0} is not a valid email address\" . format ( repr ( arg ) ) ) return arg", "docstring_tokens": "An argparse type representing an email address .", "label": 0}, {"idx": "cosqa-train-2943", "doc": "python mock comparing calls ids are same, but has name", "code": "def assert_any_call(self, *args, **kwargs):\n        \"\"\"assert the mock has been called with the specified arguments.\n\n        The assert passes if the mock has *ever* been called, unlike\n        `assert_called_with` and `assert_called_once_with` that only pass if\n        the call is the most recent one.\"\"\"\n        kall = call(*args, **kwargs)\n        if kall not in self.call_args_list:\n            expected_string = self._format_mock_call_signature(args, kwargs)\n            raise AssertionError(\n                '%s call not found' % expected_string\n            )", "code_tokens": "def assert_any_call ( self , * args , * * kwargs ) : kall = call ( * args , * * kwargs ) if kall not in self . call_args_list : expected_string = self . _format_mock_call_signature ( args , kwargs ) raise AssertionError ( '%s call not found' % expected_string )", "docstring_tokens": "assert the mock has been called with the specified arguments .", "label": 0}, {"idx": "cosqa-train-2944", "doc": "how to check a work case insensitive in a string in python", "code": "def _match_literal(self, a, b=None):\n        \"\"\"Match two names.\"\"\"\n\n        return a.lower() == b if not self.case_sensitive else a == b", "code_tokens": "def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b", "docstring_tokens": "Match two names .", "label": 0}, {"idx": "cosqa-train-2945", "doc": "python modify instance with dict", "code": "def update(self, *args, **kwargs):\n        \"\"\" A handy update() method which returns self :)\n\n        :rtype: DictProxy\n        \"\"\"\n        super(DictProxy, self).update(*args, **kwargs)\n        return self", "code_tokens": "def update ( self , * args , * * kwargs ) : super ( DictProxy , self ) . update ( * args , * * kwargs ) return self", "docstring_tokens": "A handy update () method which returns self : )", "label": 0}, {"idx": "cosqa-train-2946", "doc": "how to check array to see if there are any strings in python", "code": "def all_strings(arr):\n        \"\"\"\n        Ensures that the argument is a list that either is empty or contains only strings\n        :param arr: list\n        :return:\n        \"\"\"\n        if not isinstance([], list):\n            raise TypeError(\"non-list value found where list is expected\")\n        return all(isinstance(x, str) for x in arr)", "code_tokens": "def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( \"non-list value found where list is expected\" ) return all ( isinstance ( x , str ) for x in arr )", "docstring_tokens": "Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return :", "label": 0}, {"idx": "cosqa-train-2947", "doc": "python monkeypatch instance method with another method", "code": "def install():\n        \"\"\"\n        Installs ScoutApm SQL Instrumentation by monkeypatching the `cursor`\n        method of BaseDatabaseWrapper, to return a wrapper that instruments any\n        calls going through it.\n        \"\"\"\n\n        @monkeypatch_method(BaseDatabaseWrapper)\n        def cursor(original, self, *args, **kwargs):\n            result = original(*args, **kwargs)\n            return _DetailedTracingCursorWrapper(result, self)\n\n        logger.debug(\"Monkey patched SQL\")", "code_tokens": "def install ( ) : @ monkeypatch_method ( BaseDatabaseWrapper ) def cursor ( original , self , * args , * * kwargs ) : result = original ( * args , * * kwargs ) return _DetailedTracingCursorWrapper ( result , self ) logger . debug ( \"Monkey patched SQL\" )", "docstring_tokens": "Installs ScoutApm SQL Instrumentation by monkeypatching the cursor method of BaseDatabaseWrapper to return a wrapper that instruments any calls going through it .", "label": 0}, {"idx": "cosqa-train-2948", "doc": "how to check data type of object python 3", "code": "def is_integer(obj):\n    \"\"\"Is this an integer.\n\n    :param object obj:\n    :return:\n    \"\"\"\n    if PYTHON3:\n        return isinstance(obj, int)\n    return isinstance(obj, (int, long))", "code_tokens": "def is_integer ( obj ) : if PYTHON3 : return isinstance ( obj , int ) return isinstance ( obj , ( int , long ) )", "docstring_tokens": "Is this an integer .", "label": 0}, {"idx": "cosqa-train-2949", "doc": "python move cursor up one line", "code": "def move_up(lines=1, file=sys.stdout):\n    \"\"\" Move the cursor up a number of lines.\n\n        Esc[ValueA:\n        Moves the cursor up by the specified number of lines without changing\n        columns. If the cursor is already on the top line, ANSI.SYS ignores\n        this sequence.\n    \"\"\"\n    move.up(lines).write(file=file)", "code_tokens": "def move_up ( lines = 1 , file = sys . stdout ) : move . up ( lines ) . write ( file = file )", "docstring_tokens": "Move the cursor up a number of lines .", "label": 1}, {"idx": "cosqa-train-2950", "doc": "how to check datatype in python", "code": "def make_kind_check(python_types, numpy_kind):\n    \"\"\"\n    Make a function that checks whether a scalar or array is of a given kind\n    (e.g. float, int, datetime, timedelta).\n    \"\"\"\n    def check(value):\n        if hasattr(value, 'dtype'):\n            return value.dtype.kind == numpy_kind\n        return isinstance(value, python_types)\n    return check", "code_tokens": "def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check", "docstring_tokens": "Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) .", "label": 0}, {"idx": "cosqa-train-2951", "doc": "python move element to the tail of a list", "code": "def list_move_to_front(l,value='other'):\n    \"\"\"if the value is in the list, move it to the front and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n        l.insert(0,value)\n    return l", "code_tokens": "def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l", "docstring_tokens": "if the value is in the list move it to the front and return it .", "label": 0}, {"idx": "cosqa-train-2952", "doc": "how to check equal row size in matrix python", "code": "def is_square_matrix(mat):\n    \"\"\"Test if an array is a square matrix.\"\"\"\n    mat = np.array(mat)\n    if mat.ndim != 2:\n        return False\n    shape = mat.shape\n    return shape[0] == shape[1]", "code_tokens": "def is_square_matrix ( mat ) : mat = np . array ( mat ) if mat . ndim != 2 : return False shape = mat . shape return shape [ 0 ] == shape [ 1 ]", "docstring_tokens": "Test if an array is a square matrix .", "label": 0}, {"idx": "cosqa-train-2953", "doc": "python move file pointer to start", "code": "def align_file_position(f, size):\n    \"\"\" Align the position in the file to the next block of specified size \"\"\"\n    align = (size - 1) - (f.tell() % size)\n    f.seek(align, 1)", "code_tokens": "def align_file_position ( f , size ) : align = ( size - 1 ) - ( f . tell ( ) % size ) f . seek ( align , 1 )", "docstring_tokens": "Align the position in the file to the next block of specified size", "label": 0}, {"idx": "cosqa-train-2954", "doc": "how to check for a pattern in a tuple of tuples in python", "code": "def filter_regex(names, regex):\n    \"\"\"\n    Return a tuple of strings that match the regular expression pattern.\n    \"\"\"\n    return tuple(name for name in names\n                 if regex.search(name) is not None)", "code_tokens": "def filter_regex ( names , regex ) : return tuple ( name for name in names if regex . search ( name ) is not None )", "docstring_tokens": "Return a tuple of strings that match the regular expression pattern .", "label": 0}, {"idx": "cosqa-train-2955", "doc": "python move files wildcard", "code": "def gmove(pattern, destination):\n    \"\"\"Move all file found by glob.glob(pattern) to destination directory.\n\n    Args:\n        pattern (str): Glob pattern\n        destination (str): Path to the destination directory.\n\n    Returns:\n        bool: True if the operation is successful, False otherwise.\n    \"\"\"\n    for item in glob.glob(pattern):\n        if not move(item, destination):\n            return False\n    return True", "code_tokens": "def gmove ( pattern , destination ) : for item in glob . glob ( pattern ) : if not move ( item , destination ) : return False return True", "docstring_tokens": "Move all file found by glob . glob ( pattern ) to destination directory .", "label": 0}, {"idx": "cosqa-train-2956", "doc": "how to check if a column is dense in a sparse matrix in python", "code": "def is_sparse_vector(x):\n    \"\"\" x is a 2D sparse matrix with it's first shape equal to 1.\n    \"\"\"\n    return sp.issparse(x) and len(x.shape) == 2 and x.shape[0] == 1", "code_tokens": "def is_sparse_vector ( x ) : return sp . issparse ( x ) and len ( x . shape ) == 2 and x . shape [ 0 ] == 1", "docstring_tokens": "x is a 2D sparse matrix with it s first shape equal to 1 .", "label": 0}, {"idx": "cosqa-train-2957", "doc": "python moving window smoothing in 2d", "code": "def movingaverage(arr, window):\n    \"\"\"\n    Calculates the moving average (\"rolling mean\") of an array\n    of a certain window size.\n    \"\"\"\n    m = np.ones(int(window)) / int(window)\n    return scipy.ndimage.convolve1d(arr, m, axis=0, mode='reflect')", "code_tokens": "def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )", "docstring_tokens": "Calculates the moving average ( rolling mean ) of an array of a certain window size .", "label": 0}, {"idx": "cosqa-train-2958", "doc": "how to check if a column is string or not in python", "code": "def _isstring(dtype):\n    \"\"\"Given a numpy dtype, determines whether it is a string. Returns True\n    if the dtype is string or unicode.\n    \"\"\"\n    return dtype.type == numpy.unicode_ or dtype.type == numpy.string_", "code_tokens": "def _isstring ( dtype ) : return dtype . type == numpy . unicode_ or dtype . type == numpy . string_", "docstring_tokens": "Given a numpy dtype determines whether it is a string . Returns True if the dtype is string or unicode .", "label": 0}, {"idx": "cosqa-train-2959", "doc": "python multiindex index in", "code": "def validate_multiindex(self, obj):\n        \"\"\"validate that we can store the multi-index; reset and return the\n        new object\n        \"\"\"\n        levels = [l if l is not None else \"level_{0}\".format(i)\n                  for i, l in enumerate(obj.index.names)]\n        try:\n            return obj.reset_index(), levels\n        except ValueError:\n            raise ValueError(\"duplicate names/columns in the multi-index when \"\n                             \"storing as a table\")", "code_tokens": "def validate_multiindex ( self , obj ) : levels = [ l if l is not None else \"level_{0}\" . format ( i ) for i , l in enumerate ( obj . index . names ) ] try : return obj . reset_index ( ) , levels except ValueError : raise ValueError ( \"duplicate names/columns in the multi-index when \" \"storing as a table\" )", "docstring_tokens": "validate that we can store the multi - index ; reset and return the new object", "label": 0}, {"idx": "cosqa-train-2960", "doc": "how to check if a discord user is a user with python", "code": "def me(self):\n        \"\"\"Similar to :attr:`.Guild.me` except it may return the :class:`.ClientUser` in private message contexts.\"\"\"\n        return self.guild.me if self.guild is not None else self.bot.user", "code_tokens": "def me ( self ) : return self . guild . me if self . guild is not None else self . bot . user", "docstring_tokens": "Similar to : attr : . Guild . me except it may return the : class : . ClientUser in private message contexts .", "label": 0}, {"idx": "cosqa-train-2961", "doc": "python multiline string split", "code": "def split_multiline(value):\n    \"\"\"Split a multiline string into a list, excluding blank lines.\"\"\"\n    return [element for element in (line.strip() for line in value.split('\\n'))\n            if element]", "code_tokens": "def split_multiline ( value ) : return [ element for element in ( line . strip ( ) for line in value . split ( '\\n' ) ) if element ]", "docstring_tokens": "Split a multiline string into a list excluding blank lines .", "label": 0}, {"idx": "cosqa-train-2962", "doc": "how to check if a folder contains a particular file python", "code": "def contained_in(filename, directory):\n    \"\"\"Test if a file is located within the given directory.\"\"\"\n    filename = os.path.normcase(os.path.abspath(filename))\n    directory = os.path.normcase(os.path.abspath(directory))\n    return os.path.commonprefix([filename, directory]) == directory", "code_tokens": "def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory", "docstring_tokens": "Test if a file is located within the given directory .", "label": 0}, {"idx": "cosqa-train-2963", "doc": "python multiple queries to json", "code": "def graphql_queries_to_json(*queries):\n    \"\"\"\n    Queries should be a list of GraphQL objects\n    \"\"\"\n    rtn = {}\n    for i, query in enumerate(queries):\n        rtn[\"q{}\".format(i)] = query.value\n    return json.dumps(rtn)", "code_tokens": "def graphql_queries_to_json ( * queries ) : rtn = { } for i , query in enumerate ( queries ) : rtn [ \"q{}\" . format ( i ) ] = query . value return json . dumps ( rtn )", "docstring_tokens": "Queries should be a list of GraphQL objects", "label": 1}, {"idx": "cosqa-train-2964", "doc": "how to check if a python object has a field", "code": "def has_field(mc, field_name):\n    \"\"\"\n    detect if a model has a given field has\n\n    :param field_name:\n    :param mc:\n    :return:\n    \"\"\"\n    try:\n        mc._meta.get_field(field_name)\n    except FieldDoesNotExist:\n        return False\n    return True", "code_tokens": "def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True", "docstring_tokens": "detect if a model has a given field has", "label": 0}, {"idx": "cosqa-train-2965", "doc": "python multiple regression scipy", "code": "def linregress(x, y, return_stats=False):\n    \"\"\"linear regression calculation\n\n    Parameters\n    ----\n    x :         independent variable (series)\n    y :         dependent variable (series)\n    return_stats : returns statistical values as well if required (bool)\n    \n\n    Returns\n    ----\n    list of parameters (and statistics)\n    \"\"\"\n    a1, a0, r_value, p_value, stderr = scipy.stats.linregress(x, y)\n\n    retval = a1, a0\n    if return_stats:\n        retval += r_value, p_value, stderr\n\n    return retval", "code_tokens": "def linregress ( x , y , return_stats = False ) : a1 , a0 , r_value , p_value , stderr = scipy . stats . linregress ( x , y ) retval = a1 , a0 if return_stats : retval += r_value , p_value , stderr return retval", "docstring_tokens": "linear regression calculation", "label": 1}, {"idx": "cosqa-train-2966", "doc": "how to check if a string is in a string in a list python", "code": "def isin(elems, line):\n    \"\"\"Check if an element from a list is in a string.\n\n    :type elems: list\n    :type line: str\n\n    \"\"\"\n    found = False\n    for e in elems:\n        if e in line.lower():\n            found = True\n            break\n    return found", "code_tokens": "def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found", "docstring_tokens": "Check if an element from a list is in a string .", "label": 0}, {"idx": "cosqa-train-2967", "doc": "python multiple returns in a function", "code": "def many_until1(these, term):\n    \"\"\"Like many_until but must consume at least one of these.\n    \"\"\"\n    first = [these()]\n    these_results, term_result = many_until(these, term)\n    return (first + these_results, term_result)", "code_tokens": "def many_until1 ( these , term ) : first = [ these ( ) ] these_results , term_result = many_until ( these , term ) return ( first + these_results , term_result )", "docstring_tokens": "Like many_until but must consume at least one of these .", "label": 0}, {"idx": "cosqa-train-2968", "doc": "how to check if all the items in a list are the same python", "code": "def allsame(list_, strict=True):\n    \"\"\"\n    checks to see if list is equal everywhere\n\n    Args:\n        list_ (list):\n\n    Returns:\n        True if all items in the list are equal\n    \"\"\"\n    if len(list_) == 0:\n        return True\n    first_item = list_[0]\n    return list_all_eq_to(list_, first_item, strict)", "code_tokens": "def allsame ( list_ , strict = True ) : if len ( list_ ) == 0 : return True first_item = list_ [ 0 ] return list_all_eq_to ( list_ , first_item , strict )", "docstring_tokens": "checks to see if list is equal everywhere", "label": 1}, {"idx": "cosqa-train-2969", "doc": "python multiprocessing get number of all cores on machine", "code": "def ncores_reserved(self):\n        \"\"\"\n        Returns the number of cores reserved in this moment.\n        A core is reserved if it's still not running but\n        we have submitted the task to the queue manager.\n        \"\"\"\n        return sum(task.manager.num_cores for task in self if task.status == task.S_SUB)", "code_tokens": "def ncores_reserved ( self ) : return sum ( task . manager . num_cores for task in self if task . status == task . S_SUB )", "docstring_tokens": "Returns the number of cores reserved in this moment . A core is reserved if it s still not running but we have submitted the task to the queue manager .", "label": 0}, {"idx": "cosqa-train-2970", "doc": "how to check if an item is in a tuple python", "code": "def is_list_of_list(item):\n    \"\"\"\n    check whether the item is list (tuple)\n    and consist of list (tuple) elements\n    \"\"\"\n    if (\n        type(item) in (list, tuple)\n        and len(item)\n        and isinstance(item[0], (list, tuple))\n    ):\n        return True\n    return False", "code_tokens": "def is_list_of_list ( item ) : if ( type ( item ) in ( list , tuple ) and len ( item ) and isinstance ( item [ 0 ] , ( list , tuple ) ) ) : return True return False", "docstring_tokens": "check whether the item is list ( tuple ) and consist of list ( tuple ) elements", "label": 1}, {"idx": "cosqa-train-2971", "doc": "python multiprocessing get number of core", "code": "def ncores_reserved(self):\n        \"\"\"\n        Returns the number of cores reserved in this moment.\n        A core is reserved if it's still not running but\n        we have submitted the task to the queue manager.\n        \"\"\"\n        return sum(task.manager.num_cores for task in self if task.status == task.S_SUB)", "code_tokens": "def ncores_reserved ( self ) : return sum ( task . manager . num_cores for task in self if task . status == task . S_SUB )", "docstring_tokens": "Returns the number of cores reserved in this moment . A core is reserved if it s still not running but we have submitted the task to the queue manager .", "label": 0}, {"idx": "cosqa-train-2972", "doc": "how to check if an object is data frame in python", "code": "def is_dataframe(obj):\n    \"\"\"\n    Returns True if the given object is a Pandas Data Frame.\n\n    Parameters\n    ----------\n    obj: instance\n        The object to test whether or not is a Pandas DataFrame.\n    \"\"\"\n    try:\n        # This is the best method of type checking\n        from pandas import DataFrame\n        return isinstance(obj, DataFrame)\n    except ImportError:\n        # Pandas is not a dependency, so this is scary\n        return obj.__class__.__name__ == \"DataFrame\"", "code_tokens": "def is_dataframe ( obj ) : try : # This is the best method of type checking from pandas import DataFrame return isinstance ( obj , DataFrame ) except ImportError : # Pandas is not a dependency, so this is scary return obj . __class__ . __name__ == \"DataFrame\"", "docstring_tokens": "Returns True if the given object is a Pandas Data Frame .", "label": 0}, {"idx": "cosqa-train-2973", "doc": "python multiprocessing kill mongo", "code": "def stop(self):\n        \"\"\"stop server\"\"\"\n        try:\n            self.shutdown()\n        except (PyMongoError, ServersError) as exc:\n            logger.info(\"Killing %s with signal, shutdown command failed: %r\",\n                        self.name, exc)\n            return process.kill_mprocess(self.proc)", "code_tokens": "def stop ( self ) : try : self . shutdown ( ) except ( PyMongoError , ServersError ) as exc : logger . info ( \"Killing %s with signal, shutdown command failed: %r\" , self . name , exc ) return process . kill_mprocess ( self . proc )", "docstring_tokens": "stop server", "label": 0}, {"idx": "cosqa-train-2974", "doc": "how to check if any element of list is valid in a function in python", "code": "def build_list_type_validator(item_validator):\n    \"\"\"Return a function which validates that the value is a list of items\n    which are validated using item_validator.\n    \"\"\"\n    def validate_list_of_type(value):\n        return [item_validator(item) for item in validate_list(value)]\n    return validate_list_of_type", "code_tokens": "def build_list_type_validator ( item_validator ) : def validate_list_of_type ( value ) : return [ item_validator ( item ) for item in validate_list ( value ) ] return validate_list_of_type", "docstring_tokens": "Return a function which validates that the value is a list of items which are validated using item_validator .", "label": 0}, {"idx": "cosqa-train-2975", "doc": "python multiprocessing pool return value", "code": "def compute(args):\n    x, y, params = args\n    \"\"\"Callable function for the multiprocessing pool.\"\"\"\n    return x, y, mandelbrot(x, y, params)", "code_tokens": "def compute ( args ) : x , y , params = args return x , y , mandelbrot ( x , y , params )", "docstring_tokens": "Callable function for the multiprocessing pool .", "label": 0}, {"idx": "cosqa-train-2976", "doc": "how to check if byte is empty python", "code": "def allZero(buffer):\n    \"\"\"\n    Tries to determine if a buffer is empty.\n    \n    @type buffer: str\n    @param buffer: Buffer to test if it is empty.\n        \n    @rtype: bool\n    @return: C{True} if the given buffer is empty, i.e. full of zeros,\n        C{False} if it doesn't.\n    \"\"\"\n    allZero = True\n    for byte in buffer:\n        if byte != \"\\x00\":\n            allZero = False\n            break\n    return allZero", "code_tokens": "def allZero ( buffer ) : allZero = True for byte in buffer : if byte != \"\\x00\" : allZero = False break return allZero", "docstring_tokens": "Tries to determine if a buffer is empty .", "label": 0}, {"idx": "cosqa-train-2977", "doc": "python multiprocessing start multiple processes", "code": "def parallel(processes, threads):\n    \"\"\"\n    execute jobs in processes using N threads\n    \"\"\"\n    pool = multithread(threads)\n    pool.map(run_process, processes)\n    pool.close()\n    pool.join()", "code_tokens": "def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )", "docstring_tokens": "execute jobs in processes using N threads", "label": 0}, {"idx": "cosqa-train-2978", "doc": "how to check if data is string python", "code": "def isString(s):\n    \"\"\"Convenience method that works with all 2.x versions of Python\n    to determine whether or not something is stringlike.\"\"\"\n    try:\n        return isinstance(s, unicode) or isinstance(s, basestring)\n    except NameError:\n        return isinstance(s, str)", "code_tokens": "def isString ( s ) : try : return isinstance ( s , unicode ) or isinstance ( s , basestring ) except NameError : return isinstance ( s , str )", "docstring_tokens": "Convenience method that works with all 2 . x versions of Python to determine whether or not something is stringlike .", "label": 0}, {"idx": "cosqa-train-2979", "doc": "python multiprocessing workers spawning workers", "code": "def parallel(processes, threads):\n    \"\"\"\n    execute jobs in processes using N threads\n    \"\"\"\n    pool = multithread(threads)\n    pool.map(run_process, processes)\n    pool.close()\n    pool.join()", "code_tokens": "def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )", "docstring_tokens": "execute jobs in processes using N threads", "label": 0}, {"idx": "cosqa-train-2980", "doc": "python mysql can not connect to mysql server on local host", "code": "def connect_mysql(host, port, user, password, database):\n    \"\"\"Connect to MySQL with retries.\"\"\"\n    return pymysql.connect(\n        host=host, port=port,\n        user=user, passwd=password,\n        db=database\n    )", "code_tokens": "def connect_mysql ( host , port , user , password , database ) : return pymysql . connect ( host = host , port = port , user = user , passwd = password , db = database )", "docstring_tokens": "Connect to MySQL with retries .", "label": 0}, {"idx": "cosqa-train-2981", "doc": "how to check if its bytes or str in python", "code": "def isstring(value):\n    \"\"\"Report whether the given value is a byte or unicode string.\"\"\"\n    classes = (str, bytes) if pyutils.PY3 else basestring  # noqa: F821\n    return isinstance(value, classes)", "code_tokens": "def isstring ( value ) : classes = ( str , bytes ) if pyutils . PY3 else basestring # noqa: F821 return isinstance ( value , classes )", "docstring_tokens": "Report whether the given value is a byte or unicode string .", "label": 0}, {"idx": "cosqa-train-2982", "doc": "python mysql get scalar value from query", "code": "async def scalar(self, query, as_tuple=False):\n        \"\"\"Get single value from ``select()`` query, i.e. for aggregation.\n\n        :return: result is the same as after sync ``query.scalar()`` call\n        \"\"\"\n        query = self._swap_database(query)\n        return (await scalar(query, as_tuple=as_tuple))", "code_tokens": "async def scalar ( self , query , as_tuple = False ) : query = self . _swap_database ( query ) return ( await scalar ( query , as_tuple = as_tuple ) )", "docstring_tokens": "Get single value from select () query i . e . for aggregation .", "label": 0}, {"idx": "cosqa-train-2983", "doc": "how to check if object defined python", "code": "def is_defined(self, objtxt, force_import=False):\n        \"\"\"Return True if object is defined\"\"\"\n        return self.interpreter.is_defined(objtxt, force_import)", "code_tokens": "def is_defined ( self , objtxt , force_import = False ) : return self . interpreter . is_defined ( objtxt , force_import )", "docstring_tokens": "Return True if object is defined", "label": 1}, {"idx": "cosqa-train-2984", "doc": "python mysql sync database table structure", "code": "def init_db():\n    \"\"\"\n    Drops and re-creates the SQL schema\n    \"\"\"\n    db.drop_all()\n    db.configure_mappers()\n    db.create_all()\n    db.session.commit()", "code_tokens": "def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )", "docstring_tokens": "Drops and re - creates the SQL schema", "label": 0}, {"idx": "cosqa-train-2985", "doc": "how to check if sql connection is open in python", "code": "def raw_connection_from(engine_or_conn):\n    \"\"\"Extract a raw_connection and determine if it should be automatically closed.\n\n    Only connections opened by this package will be closed automatically.\n    \"\"\"\n    if hasattr(engine_or_conn, 'cursor'):\n        return engine_or_conn, False\n    if hasattr(engine_or_conn, 'connection'):\n        return engine_or_conn.connection, False\n    return engine_or_conn.raw_connection(), True", "code_tokens": "def raw_connection_from ( engine_or_conn ) : if hasattr ( engine_or_conn , 'cursor' ) : return engine_or_conn , False if hasattr ( engine_or_conn , 'connection' ) : return engine_or_conn . connection , False return engine_or_conn . raw_connection ( ) , True", "docstring_tokens": "Extract a raw_connection and determine if it should be automatically closed .", "label": 1}, {"idx": "cosqa-train-2986", "doc": "python mysqldb semicolon executemany", "code": "def executemany(self, sql, *params):\n        \"\"\"Prepare a database query or command and then execute it against\n        all parameter sequences  found in the sequence seq_of_params.\n\n        :param sql: the SQL statement to execute with optional ? parameters\n        :param params: sequence parameters for the markers in the SQL.\n        \"\"\"\n        fut = self._run_operation(self._impl.executemany, sql, *params)\n        return fut", "code_tokens": "def executemany ( self , sql , * params ) : fut = self . _run_operation ( self . _impl . executemany , sql , * params ) return fut", "docstring_tokens": "Prepare a database query or command and then execute it against all parameter sequences found in the sequence seq_of_params .", "label": 0}, {"idx": "cosqa-train-2987", "doc": "how to check internet connection python", "code": "def _internet_on(address):\n    \"\"\"\n    Check to see if the internet is on by pinging a set address.\n    :param address: the IP or address to hit\n    :return: a boolean - true if can be reached, false if not.\n    \"\"\"\n    try:\n        urllib2.urlopen(address, timeout=1)\n        return True\n    except urllib2.URLError as err:\n        return False", "code_tokens": "def _internet_on ( address ) : try : urllib2 . urlopen ( address , timeout = 1 ) return True except urllib2 . URLError as err : return False", "docstring_tokens": "Check to see if the internet is on by pinging a set address . : param address : the IP or address to hit : return : a boolean - true if can be reached false if not .", "label": 0}, {"idx": "cosqa-train-2988", "doc": "python namedtuple to dictionary", "code": "def dictify(a_named_tuple):\n    \"\"\"Transform a named tuple into a dictionary\"\"\"\n    return dict((s, getattr(a_named_tuple, s)) for s in a_named_tuple._fields)", "code_tokens": "def dictify ( a_named_tuple ) : return dict ( ( s , getattr ( a_named_tuple , s ) ) for s in a_named_tuple . _fields )", "docstring_tokens": "Transform a named tuple into a dictionary", "label": 0}, {"idx": "cosqa-train-2989", "doc": "how to check json files exists using python", "code": "def information(filename):\n    \"\"\"Returns the file exif\"\"\"\n    check_if_this_file_exist(filename)\n    filename = os.path.abspath(filename)\n    result = get_json(filename)\n    result = result[0]\n    return result", "code_tokens": "def information ( filename ) : check_if_this_file_exist ( filename ) filename = os . path . abspath ( filename ) result = get_json ( filename ) result = result [ 0 ] return result", "docstring_tokens": "Returns the file exif", "label": 0}, {"idx": "cosqa-train-2990", "doc": "python naming convention for enum", "code": "def _Enum(docstring, *names):\n  \"\"\"Utility to generate enum classes used by annotations.\n\n  Args:\n    docstring: Docstring for the generated enum class.\n    *names: Enum names.\n\n  Returns:\n    A class that contains enum names as attributes.\n  \"\"\"\n  enums = dict(zip(names, range(len(names))))\n  reverse = dict((value, key) for key, value in enums.iteritems())\n  enums['reverse_mapping'] = reverse\n  enums['__doc__'] = docstring\n  return type('Enum', (object,), enums)", "code_tokens": "def _Enum ( docstring , * names ) : enums = dict ( zip ( names , range ( len ( names ) ) ) ) reverse = dict ( ( value , key ) for key , value in enums . iteritems ( ) ) enums [ 'reverse_mapping' ] = reverse enums [ '__doc__' ] = docstring return type ( 'Enum' , ( object , ) , enums )", "docstring_tokens": "Utility to generate enum classes used by annotations .", "label": 0}, {"idx": "cosqa-train-2991", "doc": "how to check number of columns in 2d list python", "code": "def _rectangular(n):\n    \"\"\"Checks to see if a 2D list is a valid 2D matrix\"\"\"\n    for i in n:\n        if len(i) != len(n[0]):\n            return False\n    return True", "code_tokens": "def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True", "docstring_tokens": "Checks to see if a 2D list is a valid 2D matrix", "label": 0}, {"idx": "cosqa-train-2992", "doc": "python nested include files", "code": "def setup_path():\n    \"\"\"Sets up the python include paths to include src\"\"\"\n    import os.path; import sys\n\n    if sys.argv[0]:\n        top_dir = os.path.dirname(os.path.abspath(sys.argv[0]))\n        sys.path = [os.path.join(top_dir, \"src\")] + sys.path\n        pass\n    return", "code_tokens": "def setup_path ( ) : import os . path import sys if sys . argv [ 0 ] : top_dir = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ] ) ) sys . path = [ os . path . join ( top_dir , \"src\" ) ] + sys . path pass return", "docstring_tokens": "Sets up the python include paths to include src", "label": 0}, {"idx": "cosqa-train-2993", "doc": "how to check python filepath in windows", "code": "def is_exe(fpath):\n    \"\"\"\n    Path references an executable file.\n    \"\"\"\n    return os.path.isfile(fpath) and os.access(fpath, os.X_OK)", "code_tokens": "def is_exe ( fpath ) : return os . path . isfile ( fpath ) and os . access ( fpath , os . X_OK )", "docstring_tokens": "Path references an executable file .", "label": 0}, {"idx": "cosqa-train-2994", "doc": "python network activity log on and log off", "code": "def logout(self):\n        \"\"\"\n            Logout from the remote server.\n        \"\"\"\n        self.client.write('exit\\r\\n')\n        self.client.read_all()\n        self.client.close()", "code_tokens": "def logout ( self ) : self . client . write ( 'exit\\r\\n' ) self . client . read_all ( ) self . client . close ( )", "docstring_tokens": "Logout from the remote server .", "label": 1}, {"idx": "cosqa-train-2995", "doc": "how to check pythonpath variable in virtualenv", "code": "def _pip_exists(self):\n        \"\"\"Returns True if pip exists inside the virtual environment. Can be\n        used as a naive way to verify that the environment is installed.\"\"\"\n        return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))", "code_tokens": "def _pip_exists ( self ) : return os . path . isfile ( os . path . join ( self . path , 'bin' , 'pip' ) )", "docstring_tokens": "Returns True if pip exists inside the virtual environment . Can be used as a naive way to verify that the environment is installed .", "label": 0}, {"idx": "cosqa-train-2996", "doc": "python network to adjancency matrix", "code": "def get_adjacent_matrix(self):\n        \"\"\"Get adjacency matrix.\n\n        Returns:\n            :param adj: adjacency matrix\n            :type adj: np.ndarray\n        \"\"\"\n        edges = self.edges\n        num_edges = len(edges) + 1\n        adj = np.zeros([num_edges, num_edges])\n\n        for k in range(num_edges - 1):\n            adj[edges[k].L, edges[k].R] = 1\n            adj[edges[k].R, edges[k].L] = 1\n\n        return adj", "code_tokens": "def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj", "docstring_tokens": "Get adjacency matrix .", "label": 0}, {"idx": "cosqa-train-2997", "doc": "how to check size of avilable memory python", "code": "def get_shared_memory_bytes():\n    \"\"\"Get the size of the shared memory file system.\n\n    Returns:\n        The size of the shared memory file system in bytes.\n    \"\"\"\n    # Make sure this is only called on Linux.\n    assert sys.platform == \"linux\" or sys.platform == \"linux2\"\n\n    shm_fd = os.open(\"/dev/shm\", os.O_RDONLY)\n    try:\n        shm_fs_stats = os.fstatvfs(shm_fd)\n        # The value shm_fs_stats.f_bsize is the block size and the\n        # value shm_fs_stats.f_bavail is the number of available\n        # blocks.\n        shm_avail = shm_fs_stats.f_bsize * shm_fs_stats.f_bavail\n    finally:\n        os.close(shm_fd)\n\n    return shm_avail", "code_tokens": "def get_shared_memory_bytes ( ) : # Make sure this is only called on Linux. assert sys . platform == \"linux\" or sys . platform == \"linux2\" shm_fd = os . open ( \"/dev/shm\" , os . O_RDONLY ) try : shm_fs_stats = os . fstatvfs ( shm_fd ) # The value shm_fs_stats.f_bsize is the block size and the # value shm_fs_stats.f_bavail is the number of available # blocks. shm_avail = shm_fs_stats . f_bsize * shm_fs_stats . f_bavail finally : os . close ( shm_fd ) return shm_avail", "docstring_tokens": "Get the size of the shared memory file system .", "label": 0}, {"idx": "cosqa-train-2998", "doc": "python new a instance from a string", "code": "def from_json_str(cls, json_str):\n    \"\"\"Convert json string representation into class instance.\n\n    Args:\n      json_str: json representation as string.\n\n    Returns:\n      New instance of the class with data loaded from json string.\n    \"\"\"\n    return cls.from_json(json.loads(json_str, cls=JsonDecoder))", "code_tokens": "def from_json_str ( cls , json_str ) : return cls . from_json ( json . loads ( json_str , cls = JsonDecoder ) )", "docstring_tokens": "Convert json string representation into class instance .", "label": 0}, {"idx": "cosqa-train-2999", "doc": "how to check the data type of python instance", "code": "def is_timestamp(obj):\n    \"\"\"\n    Yaml either have automatically converted it to a datetime object\n    or it is a string that will be validated later.\n    \"\"\"\n    return isinstance(obj, datetime.datetime) or is_string(obj) or is_int(obj) or is_float(obj)", "code_tokens": "def is_timestamp ( obj ) : return isinstance ( obj , datetime . datetime ) or is_string ( obj ) or is_int ( obj ) or is_float ( obj )", "docstring_tokens": "Yaml either have automatically converted it to a datetime object or it is a string that will be validated later .", "label": 0}, {"idx": "cosqa-train-3000", "doc": "python new zero array", "code": "def zeros(self, name, **kwargs):\n        \"\"\"Create an array. Keyword arguments as per\n        :func:`zarr.creation.zeros`.\"\"\"\n        return self._write_op(self._zeros_nosync, name, **kwargs)", "code_tokens": "def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )", "docstring_tokens": "Create an array . Keyword arguments as per : func : zarr . creation . zeros .", "label": 0}, {"idx": "cosqa-train-3001", "doc": "how to check the python path", "code": "def launched():\n    \"\"\"Test whether the current python environment is the correct lore env.\n\n    :return:  :any:`True` if the environment is launched\n    :rtype: bool\n    \"\"\"\n    if not PREFIX:\n        return False\n\n    return os.path.realpath(sys.prefix) == os.path.realpath(PREFIX)", "code_tokens": "def launched ( ) : if not PREFIX : return False return os . path . realpath ( sys . prefix ) == os . path . realpath ( PREFIX )", "docstring_tokens": "Test whether the current python environment is the correct lore env .", "label": 1}, {"idx": "cosqa-train-3002", "doc": "python nltk named entity corpus", "code": "def ner_chunk(args):\n  \"\"\"Chunk named entities.\"\"\"\n  chunker = NEChunker(lang=args.lang)\n  tag(chunker, args)", "code_tokens": "def ner_chunk ( args ) : chunker = NEChunker ( lang = args . lang ) tag ( chunker , args )", "docstring_tokens": "Chunk named entities .", "label": 0}, {"idx": "cosqa-train-3003", "doc": "python none json dumps null", "code": "def get_prep_value(self, value):\n        \"\"\"Convert JSON object to a string\"\"\"\n        if self.null and value is None:\n            return None\n        return json.dumps(value, **self.dump_kwargs)", "code_tokens": "def get_prep_value ( self , value ) : if self . null and value is None : return None return json . dumps ( value , * * self . dump_kwargs )", "docstring_tokens": "Convert JSON object to a string", "label": 0}, {"idx": "cosqa-train-3004", "doc": "how to clear previous code in python", "code": "def reset(self):\n        \"\"\"Reset analyzer state\n        \"\"\"\n        self.prevframe = None\n        self.wasmoving = False\n        self.t0 = 0\n        self.ismoving = False", "code_tokens": "def reset ( self ) : self . prevframe = None self . wasmoving = False self . t0 = 0 self . ismoving = False", "docstring_tokens": "Reset analyzer state", "label": 1}, {"idx": "cosqa-train-3005", "doc": "python none type object not iterable", "code": "def _get_non_empty_list(cls, iter):\n        \"\"\"Return a list of the input, excluding all ``None`` values.\"\"\"\n        res = []\n        for value in iter:\n            if hasattr(value, 'items'):\n                value = cls._get_non_empty_dict(value) or None\n            if value is not None:\n                res.append(value)\n        return res", "code_tokens": "def _get_non_empty_list ( cls , iter ) : res = [ ] for value in iter : if hasattr ( value , 'items' ) : value = cls . _get_non_empty_dict ( value ) or None if value is not None : res . append ( value ) return res", "docstring_tokens": "Return a list of the input excluding all None values .", "label": 0}, {"idx": "cosqa-train-3006", "doc": "how to clear python memory after every loop", "code": "def Flush(self):\n    \"\"\"Flush all items from cache.\"\"\"\n    while self._age:\n      node = self._age.PopLeft()\n      self.KillObject(node.data)\n\n    self._hash = dict()", "code_tokens": "def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )", "docstring_tokens": "Flush all items from cache .", "label": 0}, {"idx": "cosqa-train-3007", "doc": "python normalize image array 0 1", "code": "def _normalize(mat: np.ndarray):\n    \"\"\"rescales a numpy array, so that min is 0 and max is 255\"\"\"\n    return ((mat - mat.min()) * (255 / mat.max())).astype(np.uint8)", "code_tokens": "def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )", "docstring_tokens": "rescales a numpy array so that min is 0 and max is 255", "label": 0}, {"idx": "cosqa-train-3008", "doc": "how to close all files in python", "code": "def __exit__(self, *args):\n        \"\"\"\n        Cleanup any necessary opened files\n        \"\"\"\n\n        if self._output_file_handle:\n            self._output_file_handle.close()\n            self._output_file_handle = None", "code_tokens": "def __exit__ ( self , * args ) : if self . _output_file_handle : self . _output_file_handle . close ( ) self . _output_file_handle = None", "docstring_tokens": "Cleanup any necessary opened files", "label": 0}, {"idx": "cosqa-train-3009", "doc": "python normalize matrix by row", "code": "def normalize(X):\n    \"\"\" equivalent to scipy.preprocessing.normalize on sparse matrices\n    , but lets avoid another depedency just for a small utility function \"\"\"\n    X = coo_matrix(X)\n    X.data = X.data / sqrt(bincount(X.row, X.data ** 2))[X.row]\n    return X", "code_tokens": "def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X", "docstring_tokens": "equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function", "label": 0}, {"idx": "cosqa-train-3010", "doc": "how to code selection lists in python", "code": "def get_selected_values(self, selection):\n        \"\"\"Return a list of values for the given selection.\"\"\"\n        return [v for b, v in self._choices if b & selection]", "code_tokens": "def get_selected_values ( self , selection ) : return [ v for b , v in self . _choices if b & selection ]", "docstring_tokens": "Return a list of values for the given selection .", "label": 0}, {"idx": "cosqa-train-3011", "doc": "python nosetests skip if example", "code": "def isTestCaseDisabled(test_case_class, method_name):\n    \"\"\"\n    I check to see if a method on a TestCase has been disabled via nose's\n    convention for disabling a TestCase.  This makes it so that users can\n    mix nose's parameterized tests with green as a runner.\n    \"\"\"\n    test_method = getattr(test_case_class, method_name)\n    return getattr(test_method, \"__test__\", 'not nose') is False", "code_tokens": "def isTestCaseDisabled ( test_case_class , method_name ) : test_method = getattr ( test_case_class , method_name ) return getattr ( test_method , \"__test__\" , 'not nose' ) is False", "docstring_tokens": "I check to see if a method on a TestCase has been disabled via nose s convention for disabling a TestCase . This makes it so that users can mix nose s parameterized tests with green as a runner .", "label": 0}, {"idx": "cosqa-train-3012", "doc": "how to compare 2 arrays and give accurecy in percent python", "code": "def compare(a, b):\n    \"\"\"\n     Compare items in 2 arrays. Returns sum(abs(a(i)-b(i)))\n    \"\"\"\n    s=0\n    for i in range(len(a)):\n        s=s+abs(a[i]-b[i])\n    return s", "code_tokens": "def compare ( a , b ) : s = 0 for i in range ( len ( a ) ) : s = s + abs ( a [ i ] - b [ i ] ) return s", "docstring_tokens": "Compare items in 2 arrays . Returns sum ( abs ( a ( i ) - b ( i )))", "label": 0}, {"idx": "cosqa-train-3013", "doc": "python not exit runtime exec", "code": "def call_and_exit(self, cmd, shell=True):\n        \"\"\"Run the *cmd* and exit with the proper exit code.\"\"\"\n        sys.exit(subprocess.call(cmd, shell=shell))", "code_tokens": "def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )", "docstring_tokens": "Run the * cmd * and exit with the proper exit code .", "label": 0}, {"idx": "cosqa-train-3014", "doc": "how to compare if two objects are equal python", "code": "def equal(obj1, obj2):\n    \"\"\"Calculate equality between two (Comparable) objects.\"\"\"\n    Comparable.log(obj1, obj2, '==')\n    equality = obj1.equality(obj2)\n    Comparable.log(obj1, obj2, '==', result=equality)\n    return equality", "code_tokens": "def equal ( obj1 , obj2 ) : Comparable . log ( obj1 , obj2 , '==' ) equality = obj1 . equality ( obj2 ) Comparable . log ( obj1 , obj2 , '==' , result = equality ) return equality", "docstring_tokens": "Calculate equality between two ( Comparable ) objects .", "label": 0}, {"idx": "cosqa-train-3015", "doc": "python not null dict", "code": "def purge_dict(idict):\n    \"\"\"Remove null items from a dictionary \"\"\"\n    odict = {}\n    for key, val in idict.items():\n        if is_null(val):\n            continue\n        odict[key] = val\n    return odict", "code_tokens": "def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict", "docstring_tokens": "Remove null items from a dictionary", "label": 0}, {"idx": "cosqa-train-3016", "doc": "how to compute median of 3 values in python", "code": "def getMedian(numericValues):\n    \"\"\"\n    Gets the median of a list of values\n    Returns a float/int\n    \"\"\"\n    theValues = sorted(numericValues)\n\n    if len(theValues) % 2 == 1:\n        return theValues[(len(theValues) + 1) / 2 - 1]\n    else:\n        lower = theValues[len(theValues) / 2 - 1]\n        upper = theValues[len(theValues) / 2]\n\n        return (float(lower + upper)) / 2", "code_tokens": "def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2", "docstring_tokens": "Gets the median of a list of values Returns a float / int", "label": 0}, {"idx": "cosqa-train-3017", "doc": "python not to ask overwrite a file", "code": "def check_exists(filename, oappend=False):\n    \"\"\"\n    Avoid overwriting some files accidentally.\n    \"\"\"\n    if op.exists(filename):\n        if oappend:\n            return oappend\n        logging.error(\"`{0}` found, overwrite (Y/N)?\".format(filename))\n        overwrite = (raw_input() == 'Y')\n    else:\n        overwrite = True\n\n    return overwrite", "code_tokens": "def check_exists ( filename , oappend = False ) : if op . exists ( filename ) : if oappend : return oappend logging . error ( \"`{0}` found, overwrite (Y/N)?\" . format ( filename ) ) overwrite = ( raw_input ( ) == 'Y' ) else : overwrite = True return overwrite", "docstring_tokens": "Avoid overwriting some files accidentally .", "label": 0}, {"idx": "cosqa-train-3018", "doc": "how to compute the output shape of pooling layer in python", "code": "def _pooling_output_shape(input_shape, pool_size=(2, 2),\n                          strides=None, padding='VALID'):\n  \"\"\"Helper: compute the output shape for the pooling layer.\"\"\"\n  dims = (1,) + pool_size + (1,)  # NHWC\n  spatial_strides = strides or (1,) * len(pool_size)\n  strides = (1,) + spatial_strides + (1,)\n  pads = padtype_to_pads(input_shape, dims, strides, padding)\n  operand_padded = onp.add(input_shape, onp.add(*zip(*pads)))\n  t = onp.floor_divide(onp.subtract(operand_padded, dims), strides) + 1\n  return tuple(t)", "code_tokens": "def _pooling_output_shape ( input_shape , pool_size = ( 2 , 2 ) , strides = None , padding = 'VALID' ) : dims = ( 1 , ) + pool_size + ( 1 , ) # NHWC spatial_strides = strides or ( 1 , ) * len ( pool_size ) strides = ( 1 , ) + spatial_strides + ( 1 , ) pads = padtype_to_pads ( input_shape , dims , strides , padding ) operand_padded = onp . add ( input_shape , onp . add ( * zip ( * pads ) ) ) t = onp . floor_divide ( onp . subtract ( operand_padded , dims ) , strides ) + 1 return tuple ( t )", "docstring_tokens": "Helper : compute the output shape for the pooling layer .", "label": 0}, {"idx": "cosqa-train-3019", "doc": "python numpy access last value", "code": "def other_ind(self):\n        \"\"\"last row or column of square A\"\"\"\n        return np.full(self.n_min, self.size - 1, dtype=np.int)", "code_tokens": "def other_ind ( self ) : return np . full ( self . n_min , self . size - 1 , dtype = np . int )", "docstring_tokens": "last row or column of square A", "label": 0}, {"idx": "cosqa-train-3020", "doc": "how to concainate list and string in python", "code": "def encode(strs):\n    \"\"\"Encodes a list of strings to a single string.\n    :type strs: List[str]\n    :rtype: str\n    \"\"\"\n    res = ''\n    for string in strs.split():\n        res += str(len(string)) + \":\" + string\n    return res", "code_tokens": "def encode ( strs ) : res = '' for string in strs . split ( ) : res += str ( len ( string ) ) + \":\" + string return res", "docstring_tokens": "Encodes a list of strings to a single string . : type strs : List [ str ] : rtype : str", "label": 1}, {"idx": "cosqa-train-3021", "doc": "python numpy argmax top", "code": "def Max(a, axis, keep_dims):\n    \"\"\"\n    Max reduction op.\n    \"\"\"\n    return np.amax(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis),\n                   keepdims=keep_dims),", "code_tokens": "def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "docstring_tokens": "Max reduction op .", "label": 0}, {"idx": "cosqa-train-3022", "doc": "how to connect to a redis local host from python", "code": "def __connect():\n    \"\"\"\n    Connect to a redis instance.\n    \"\"\"\n    global redis_instance\n    if use_tcp_socket:\n        redis_instance = redis.StrictRedis(host=hostname, port=port)\n    else:\n        redis_instance = redis.StrictRedis(unix_socket_path=unix_socket)", "code_tokens": "def __connect ( ) : global redis_instance if use_tcp_socket : redis_instance = redis . StrictRedis ( host = hostname , port = port ) else : redis_instance = redis . StrictRedis ( unix_socket_path = unix_socket )", "docstring_tokens": "Connect to a redis instance .", "label": 1}, {"idx": "cosqa-train-3023", "doc": "python numpy array from table", "code": "def from_array(cls, arr):\n        \"\"\"Convert a structured NumPy array into a Table.\"\"\"\n        return cls().with_columns([(f, arr[f]) for f in arr.dtype.names])", "code_tokens": "def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )", "docstring_tokens": "Convert a structured NumPy array into a Table .", "label": 0}, {"idx": "cosqa-train-3024", "doc": "how to construct mapper object from dictionary python", "code": "def from_dict(cls, d):\n        \"\"\"Create an instance from a dictionary.\"\"\"\n        return cls(**{k: v for k, v in d.items() if k in cls.ENTRIES})", "code_tokens": "def from_dict ( cls , d ) : return cls ( * * { k : v for k , v in d . items ( ) if k in cls . ENTRIES } )", "docstring_tokens": "Create an instance from a dictionary .", "label": 0}, {"idx": "cosqa-train-3025", "doc": "python numpy array object of array", "code": "def recarray(self):\n        \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"\n        return numpy.rec.fromrecords(self.records, names=self.names)", "code_tokens": "def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "docstring_tokens": "Returns data as : class : numpy . recarray .", "label": 0}, {"idx": "cosqa-train-3026", "doc": "how to count nodes on a tree through recursion in python", "code": "def num_leaves(tree):\n    \"\"\"Determine the number of leaves in a tree\"\"\"\n    if tree.is_leaf:\n        return 1\n    else:\n        return num_leaves(tree.left_child) + num_leaves(tree.right_child)", "code_tokens": "def num_leaves ( tree ) : if tree . is_leaf : return 1 else : return num_leaves ( tree . left_child ) + num_leaves ( tree . right_child )", "docstring_tokens": "Determine the number of leaves in a tree", "label": 0}, {"idx": "cosqa-train-3027", "doc": "python numpy compute standard deviation", "code": "def _std(self,x):\n        \"\"\"\n        Compute standard deviation with ddof degrees of freedom\n        \"\"\"\n        return np.nanstd(x.values,ddof=self._ddof)", "code_tokens": "def _std ( self , x ) : return np . nanstd ( x . values , ddof = self . _ddof )", "docstring_tokens": "Compute standard deviation with ddof degrees of freedom", "label": 0}, {"idx": "cosqa-train-3028", "doc": "how to count number of values attached to key python", "code": "def objectcount(data, key):\n    \"\"\"return the count of objects of key\"\"\"\n    objkey = key.upper()\n    return len(data.dt[objkey])", "code_tokens": "def objectcount ( data , key ) : objkey = key . upper ( ) return len ( data . dt [ objkey ] )", "docstring_tokens": "return the count of objects of key", "label": 0}, {"idx": "cosqa-train-3029", "doc": "python numpy extend dimension by filling 0", "code": "def iterexpand(arry, extra):\n    \"\"\"\n    Expand dimensions by iteratively append empty axes.\n\n    Parameters\n    ----------\n    arry : ndarray\n        The original array\n\n    extra : int\n        The number of empty axes to append\n    \"\"\"\n    for d in range(arry.ndim, arry.ndim+extra):\n        arry = expand_dims(arry, axis=d)\n    return arry", "code_tokens": "def iterexpand ( arry , extra ) : for d in range ( arry . ndim , arry . ndim + extra ) : arry = expand_dims ( arry , axis = d ) return arry", "docstring_tokens": "Expand dimensions by iteratively append empty axes .", "label": 0}, {"idx": "cosqa-train-3030", "doc": "how to covert string to 128 bit lenght key in python", "code": "def aws_to_unix_id(aws_key_id):\n    \"\"\"Converts a AWS Key ID into a UID\"\"\"\n    uid_bytes = hashlib.sha256(aws_key_id.encode()).digest()[-2:]\n    if USING_PYTHON2:\n        return 2000 + int(from_bytes(uid_bytes) // 2)\n    else:\n        return 2000 + (int.from_bytes(uid_bytes, byteorder=sys.byteorder) // 2)", "code_tokens": "def aws_to_unix_id ( aws_key_id ) : uid_bytes = hashlib . sha256 ( aws_key_id . encode ( ) ) . digest ( ) [ - 2 : ] if USING_PYTHON2 : return 2000 + int ( from_bytes ( uid_bytes ) // 2 ) else : return 2000 + ( int . from_bytes ( uid_bytes , byteorder = sys . byteorder ) // 2 )", "docstring_tokens": "Converts a AWS Key ID into a UID", "label": 0}, {"idx": "cosqa-train-3031", "doc": "python numpy flip vertical", "code": "def imflip(img, direction='horizontal'):\n    \"\"\"Flip an image horizontally or vertically.\n\n    Args:\n        img (ndarray): Image to be flipped.\n        direction (str): The flip direction, either \"horizontal\" or \"vertical\".\n\n    Returns:\n        ndarray: The flipped image.\n    \"\"\"\n    assert direction in ['horizontal', 'vertical']\n    if direction == 'horizontal':\n        return np.flip(img, axis=1)\n    else:\n        return np.flip(img, axis=0)", "code_tokens": "def imflip ( img , direction = 'horizontal' ) : assert direction in [ 'horizontal' , 'vertical' ] if direction == 'horizontal' : return np . flip ( img , axis = 1 ) else : return np . flip ( img , axis = 0 )", "docstring_tokens": "Flip an image horizontally or vertically .", "label": 1}, {"idx": "cosqa-train-3032", "doc": "how to create a conda environment in python", "code": "def create_conda_env(sandbox_dir, env_name, dependencies, options=()):\n    \"\"\"\n    Create a conda environment inside the current sandbox for the given list of dependencies and options.\n\n    Parameters\n    ----------\n    sandbox_dir : str\n    env_name : str\n    dependencies : list\n        List of conda specs\n    options\n        List of additional options to pass to conda.  Things like [\"-c\", \"conda-forge\"]\n\n    Returns\n    -------\n    (env_dir, env_name)\n    \"\"\"\n\n    env_dir = os.path.join(sandbox_dir, env_name)\n    cmdline = [\"conda\", \"create\", \"--yes\", \"--copy\", \"--quiet\", \"-p\", env_dir] + list(options) + dependencies\n\n    log.info(\"Creating conda environment: \")\n    log.info(\"  command line: %s\", cmdline)\n    subprocess.check_call(cmdline, stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n    log.debug(\"Environment created\")\n\n    return env_dir, env_name", "code_tokens": "def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ \"conda\" , \"create\" , \"--yes\" , \"--copy\" , \"--quiet\" , \"-p\" , env_dir ] + list ( options ) + dependencies log . info ( \"Creating conda environment: \" ) log . info ( \"  command line: %s\" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( \"Environment created\" ) return env_dir , env_name", "docstring_tokens": "Create a conda environment inside the current sandbox for the given list of dependencies and options .", "label": 0}, {"idx": "cosqa-train-3033", "doc": "python numpy linear interpolation", "code": "def _linear_interpolation(x, X, Y):\n    \"\"\"Given two data points [X,Y], linearly interpolate those at x.\n    \"\"\"\n    return (Y[1] * (x - X[0]) + Y[0] * (X[1] - x)) / (X[1] - X[0])", "code_tokens": "def _linear_interpolation ( x , X , Y ) : return ( Y [ 1 ] * ( x - X [ 0 ] ) + Y [ 0 ] * ( X [ 1 ] - x ) ) / ( X [ 1 ] - X [ 0 ] )", "docstring_tokens": "Given two data points [ X Y ] linearly interpolate those at x .", "label": 0}, {"idx": "cosqa-train-3034", "doc": "how to create a dict with nested keys in python", "code": "def flattened_nested_key_indices(nested_dict):\n    \"\"\"\n    Combine the outer and inner keys of nested dictionaries into a single\n    ordering.\n    \"\"\"\n    outer_keys, inner_keys = collect_nested_keys(nested_dict)\n    combined_keys = list(sorted(set(outer_keys + inner_keys)))\n    return {k: i for (i, k) in enumerate(combined_keys)}", "code_tokens": "def flattened_nested_key_indices ( nested_dict ) : outer_keys , inner_keys = collect_nested_keys ( nested_dict ) combined_keys = list ( sorted ( set ( outer_keys + inner_keys ) ) ) return { k : i for ( i , k ) in enumerate ( combined_keys ) }", "docstring_tokens": "Combine the outer and inner keys of nested dictionaries into a single ordering .", "label": 0}, {"idx": "cosqa-train-3035", "doc": "python numpy moving aretmetic average", "code": "def movingaverage(arr, window):\n    \"\"\"\n    Calculates the moving average (\"rolling mean\") of an array\n    of a certain window size.\n    \"\"\"\n    m = np.ones(int(window)) / int(window)\n    return scipy.ndimage.convolve1d(arr, m, axis=0, mode='reflect')", "code_tokens": "def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )", "docstring_tokens": "Calculates the moving average ( rolling mean ) of an array of a certain window size .", "label": 1}, {"idx": "cosqa-train-3036", "doc": "how to create a discord bot using python and asyncio", "code": "def run(self, *args, **kwargs):\n        \"\"\" Connect and run bot in event loop. \"\"\"\n        self.eventloop.run_until_complete(self.connect(*args, **kwargs))\n        try:\n            self.eventloop.run_forever()\n        finally:\n            self.eventloop.stop()", "code_tokens": "def run ( self , * args , * * kwargs ) : self . eventloop . run_until_complete ( self . connect ( * args , * * kwargs ) ) try : self . eventloop . run_forever ( ) finally : self . eventloop . stop ( )", "docstring_tokens": "Connect and run bot in event loop .", "label": 0}, {"idx": "cosqa-train-3037", "doc": "python numpy one hot", "code": "def one_hot(x, size, dtype=np.float32):\n  \"\"\"Make a n+1 dim one-hot array from n dim int-categorical array.\"\"\"\n  return np.array(x[..., np.newaxis] == np.arange(size), dtype)", "code_tokens": "def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )", "docstring_tokens": "Make a n + 1 dim one - hot array from n dim int - categorical array .", "label": 1}, {"idx": "cosqa-train-3038", "doc": "how to create a new folder if one does not exist in python", "code": "def ensure_dir_exists(directory):\n    \"\"\"Se asegura de que un directorio exista.\"\"\"\n    if directory and not os.path.exists(directory):\n        os.makedirs(directory)", "code_tokens": "def ensure_dir_exists ( directory ) : if directory and not os . path . exists ( directory ) : os . makedirs ( directory )", "docstring_tokens": "Se asegura de que un directorio exista .", "label": 0}, {"idx": "cosqa-train-3039", "doc": "python numpy read tif image", "code": "def ReadTif(tifFile):\n        \"\"\"Reads a tif file to a 2D NumPy array\"\"\"\n        img = Image.open(tifFile)\n        img = np.array(img)\n        return img", "code_tokens": "def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img", "docstring_tokens": "Reads a tif file to a 2D NumPy array", "label": 0}, {"idx": "cosqa-train-3040", "doc": "how to create a scope in python", "code": "def append_scope(self):\n        \"\"\"Create a new scope in the current frame.\"\"\"\n        self.stack.current.append(Scope(self.stack.current.current))", "code_tokens": "def append_scope ( self ) : self . stack . current . append ( Scope ( self . stack . current . current ) )", "docstring_tokens": "Create a new scope in the current frame .", "label": 0}, {"idx": "cosqa-train-3041", "doc": "python numpy replace all nan with none", "code": "def _isnan(self):\n        \"\"\"\n        Return if each value is NaN.\n        \"\"\"\n        if self._can_hold_na:\n            return isna(self)\n        else:\n            # shouldn't reach to this condition by checking hasnans beforehand\n            values = np.empty(len(self), dtype=np.bool_)\n            values.fill(False)\n            return values", "code_tokens": "def _isnan ( self ) : if self . _can_hold_na : return isna ( self ) else : # shouldn't reach to this condition by checking hasnans beforehand values = np . empty ( len ( self ) , dtype = np . bool_ ) values . fill ( False ) return values", "docstring_tokens": "Return if each value is NaN .", "label": 0}, {"idx": "cosqa-train-3042", "doc": "how to create a string of color name in python", "code": "def write_color(string, name, style='normal', when='auto'):\n    \"\"\" Write the given colored string to standard out. \"\"\"\n    write(color(string, name, style, when))", "code_tokens": "def write_color ( string , name , style = 'normal' , when = 'auto' ) : write ( color ( string , name , style , when ) )", "docstring_tokens": "Write the given colored string to standard out .", "label": 1}, {"idx": "cosqa-train-3043", "doc": "python numpy round to integer", "code": "def round_array(array_in):\n    \"\"\"\n    arr_out = round_array(array_in)\n\n    Rounds an array and recasts it to int. Also works on scalars.\n    \"\"\"\n    if isinstance(array_in, ndarray):\n        return np.round(array_in).astype(int)\n    else:\n        return int(np.round(array_in))", "code_tokens": "def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )", "docstring_tokens": "arr_out = round_array ( array_in )", "label": 0}, {"idx": "cosqa-train-3044", "doc": "how to create directory in remote server using ssh in python", "code": "def send_dir(self, local_path, remote_path, user='root'):\n        \"\"\"Upload a directory on the remote host.\n        \"\"\"\n        self.enable_user(user)\n        return self.ssh_pool.send_dir(user, local_path, remote_path)", "code_tokens": "def send_dir ( self , local_path , remote_path , user = 'root' ) : self . enable_user ( user ) return self . ssh_pool . send_dir ( user , local_path , remote_path )", "docstring_tokens": "Upload a directory on the remote host .", "label": 1}, {"idx": "cosqa-train-3045", "doc": "python numpy round up int", "code": "def round_array(array_in):\n    \"\"\"\n    arr_out = round_array(array_in)\n\n    Rounds an array and recasts it to int. Also works on scalars.\n    \"\"\"\n    if isinstance(array_in, ndarray):\n        return np.round(array_in).astype(int)\n    else:\n        return int(np.round(array_in))", "code_tokens": "def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )", "docstring_tokens": "arr_out = round_array ( array_in )", "label": 0}, {"idx": "cosqa-train-3046", "doc": "how to create symlink in python", "code": "def symlink(source, destination):\n    \"\"\"Create a symbolic link\"\"\"\n    log(\"Symlinking {} as {}\".format(source, destination))\n    cmd = [\n        'ln',\n        '-sf',\n        source,\n        destination,\n    ]\n    subprocess.check_call(cmd)", "code_tokens": "def symlink ( source , destination ) : log ( \"Symlinking {} as {}\" . format ( source , destination ) ) cmd = [ 'ln' , '-sf' , source , destination , ] subprocess . check_call ( cmd )", "docstring_tokens": "Create a symbolic link", "label": 0}, {"idx": "cosqa-train-3047", "doc": "python numpy to string", "code": "def _array2cstr(arr):\n    \"\"\" Serializes a numpy array to a compressed base64 string \"\"\"\n    out = StringIO()\n    np.save(out, arr)\n    return b64encode(out.getvalue())", "code_tokens": "def _array2cstr ( arr ) : out = StringIO ( ) np . save ( out , arr ) return b64encode ( out . getvalue ( ) )", "docstring_tokens": "Serializes a numpy array to a compressed base64 string", "label": 0}, {"idx": "cosqa-train-3048", "doc": "how to custom headers in connect request in python", "code": "def set_header(self, key, value):\n    \"\"\" Sets a HTTP header for future requests. \"\"\"\n    self.conn.issue_command(\"Header\", _normalize_header(key), value)", "code_tokens": "def set_header ( self , key , value ) : self . conn . issue_command ( \"Header\" , _normalize_header ( key ) , value )", "docstring_tokens": "Sets a HTTP header for future requests .", "label": 1}, {"idx": "cosqa-train-3049", "doc": "how to cut numerical variable into equal size in python", "code": "def batchify(data, batch_size):\n    \"\"\"Reshape data into (num_example, batch_size)\"\"\"\n    nbatch = data.shape[0] // batch_size\n    data = data[:nbatch * batch_size]\n    data = data.reshape((batch_size, nbatch)).T\n    return data", "code_tokens": "def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data", "docstring_tokens": "Reshape data into ( num_example batch_size )", "label": 0}, {"idx": "cosqa-train-3050", "doc": "python numpy using max function for an array", "code": "def Max(a, axis, keep_dims):\n    \"\"\"\n    Max reduction op.\n    \"\"\"\n    return np.amax(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis),\n                   keepdims=keep_dims),", "code_tokens": "def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "docstring_tokens": "Max reduction op .", "label": 0}, {"idx": "cosqa-train-3051", "doc": "how to cut the first chars of a string in python", "code": "def _clip(sid, prefix):\n    \"\"\"Clips a prefix from the beginning of a string if it exists.\"\"\"\n    return sid[len(prefix):] if sid.startswith(prefix) else sid", "code_tokens": "def _clip ( sid , prefix ) : return sid [ len ( prefix ) : ] if sid . startswith ( prefix ) else sid", "docstring_tokens": "Clips a prefix from the beginning of a string if it exists .", "label": 0}, {"idx": "cosqa-train-3052", "doc": "python object by string name", "code": "def load_object_by_name(object_name):\n    \"\"\"Load an object from a module by name\"\"\"\n    mod_name, attr = object_name.rsplit('.', 1)\n    mod = import_module(mod_name)\n    return getattr(mod, attr)", "code_tokens": "def load_object_by_name ( object_name ) : mod_name , attr = object_name . rsplit ( '.' , 1 ) mod = import_module ( mod_name ) return getattr ( mod , attr )", "docstring_tokens": "Load an object from a module by name", "label": 1}, {"idx": "cosqa-train-3053", "doc": "how to deal python attributeerror", "code": "def safe_setattr(obj, name, value):\n    \"\"\"Attempt to setattr but catch AttributeErrors.\"\"\"\n    try:\n        setattr(obj, name, value)\n        return True\n    except AttributeError:\n        return False", "code_tokens": "def safe_setattr ( obj , name , value ) : try : setattr ( obj , name , value ) return True except AttributeError : return False", "docstring_tokens": "Attempt to setattr but catch AttributeErrors .", "label": 1}, {"idx": "cosqa-train-3054", "doc": "python object is not json serializable datetime now", "code": "def _time_to_json(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\"\"\"\n    if isinstance(value, datetime.time):\n        value = value.isoformat()\n    return value", "code_tokens": "def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 0}, {"idx": "cosqa-train-3055", "doc": "how to define enums in python", "code": "def _Enum(docstring, *names):\n  \"\"\"Utility to generate enum classes used by annotations.\n\n  Args:\n    docstring: Docstring for the generated enum class.\n    *names: Enum names.\n\n  Returns:\n    A class that contains enum names as attributes.\n  \"\"\"\n  enums = dict(zip(names, range(len(names))))\n  reverse = dict((value, key) for key, value in enums.iteritems())\n  enums['reverse_mapping'] = reverse\n  enums['__doc__'] = docstring\n  return type('Enum', (object,), enums)", "code_tokens": "def _Enum ( docstring , * names ) : enums = dict ( zip ( names , range ( len ( names ) ) ) ) reverse = dict ( ( value , key ) for key , value in enums . iteritems ( ) ) enums [ 'reverse_mapping' ] = reverse enums [ '__doc__' ] = docstring return type ( 'Enum' , ( object , ) , enums )", "docstring_tokens": "Utility to generate enum classes used by annotations .", "label": 0}, {"idx": "cosqa-train-3056", "doc": "python object member to dict keys", "code": "def object_as_dict(obj):\n    \"\"\"Turn an SQLAlchemy model into a dict of field names and values.\n\n    Based on https://stackoverflow.com/a/37350445/1579058\n    \"\"\"\n    return {c.key: getattr(obj, c.key)\n            for c in inspect(obj).mapper.column_attrs}", "code_tokens": "def object_as_dict ( obj ) : return { c . key : getattr ( obj , c . key ) for c in inspect ( obj ) . mapper . column_attrs }", "docstring_tokens": "Turn an SQLAlchemy model into a dict of field names and values .", "label": 0}, {"idx": "cosqa-train-3057", "doc": "how to define return type for python methods", "code": "def return_value(self, *args, **kwargs):\n        \"\"\"Extracts the real value to be returned from the wrapping callable.\n\n        :return: The value the double should return when called.\n        \"\"\"\n\n        self._called()\n        return self._return_value(*args, **kwargs)", "code_tokens": "def return_value ( self , * args , * * kwargs ) : self . _called ( ) return self . _return_value ( * args , * * kwargs )", "docstring_tokens": "Extracts the real value to be returned from the wrapping callable .", "label": 0}, {"idx": "cosqa-train-3058", "doc": "python ols fit model output", "code": "def fit_linear(X, y):\n    \"\"\"\n    Uses OLS to fit the regression.\n    \"\"\"\n    model = linear_model.LinearRegression()\n    model.fit(X, y)\n    return model", "code_tokens": "def fit_linear ( X , y ) : model = linear_model . LinearRegression ( ) model . fit ( X , y ) return model", "docstring_tokens": "Uses OLS to fit the regression .", "label": 0}, {"idx": "cosqa-train-3059", "doc": "how to delete a file or folder python stackoverflow", "code": "def remover(file_path):\n    \"\"\"Delete a file or directory path only if it exists.\"\"\"\n    if os.path.isfile(file_path):\n        os.remove(file_path)\n        return True\n    elif os.path.isdir(file_path):\n        shutil.rmtree(file_path)\n        return True\n    else:\n        return False", "code_tokens": "def remover ( file_path ) : if os . path . isfile ( file_path ) : os . remove ( file_path ) return True elif os . path . isdir ( file_path ) : shutil . rmtree ( file_path ) return True else : return False", "docstring_tokens": "Delete a file or directory path only if it exists .", "label": 0}, {"idx": "cosqa-train-3060", "doc": "python one column value unless nan", "code": "def reduce_fn(x):\n    \"\"\"\n    Aggregation function to get the first non-zero value.\n    \"\"\"\n    values = x.values if pd and isinstance(x, pd.Series) else x\n    for v in values:\n        if not is_nan(v):\n            return v\n    return np.NaN", "code_tokens": "def reduce_fn ( x ) : values = x . values if pd and isinstance ( x , pd . Series ) else x for v in values : if not is_nan ( v ) : return v return np . NaN", "docstring_tokens": "Aggregation function to get the first non - zero value .", "label": 1}, {"idx": "cosqa-train-3061", "doc": "how to delete a label in python", "code": "def del_label(self, name):\n        \"\"\"Delete a label by name.\"\"\"\n        labels_tag = self.root[0]\n        labels_tag.remove(self._find_label(name))", "code_tokens": "def del_label ( self , name ) : labels_tag = self . root [ 0 ] labels_tag . remove ( self . _find_label ( name ) )", "docstring_tokens": "Delete a label by name .", "label": 0}, {"idx": "cosqa-train-3062", "doc": "python one hot dense array", "code": "def one_hot(x, size, dtype=np.float32):\n  \"\"\"Make a n+1 dim one-hot array from n dim int-categorical array.\"\"\"\n  return np.array(x[..., np.newaxis] == np.arange(size), dtype)", "code_tokens": "def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )", "docstring_tokens": "Make a n + 1 dim one - hot array from n dim int - categorical array .", "label": 0}, {"idx": "cosqa-train-3063", "doc": "how to delete a text file in python", "code": "def safe_delete(filename):\n  \"\"\"Delete a file safely. If it's not present, no-op.\"\"\"\n  try:\n    os.unlink(filename)\n  except OSError as e:\n    if e.errno != errno.ENOENT:\n      raise", "code_tokens": "def safe_delete ( filename ) : try : os . unlink ( filename ) except OSError as e : if e . errno != errno . ENOENT : raise", "docstring_tokens": "Delete a file safely . If it s not present no - op .", "label": 0}, {"idx": "cosqa-train-3064", "doc": "python open a file to read in project folder", "code": "def read(filename):\n    \"\"\"Read and return `filename` in root dir of project and return string\"\"\"\n    return codecs.open(os.path.join(__DIR__, filename), 'r').read()", "code_tokens": "def read ( filename ) : return codecs . open ( os . path . join ( __DIR__ , filename ) , 'r' ) . read ( )", "docstring_tokens": "Read and return filename in root dir of project and return string", "label": 0}, {"idx": "cosqa-train-3065", "doc": "how to delete image from an image using python", "code": "def cli(env, identifier):\n    \"\"\"Delete an image.\"\"\"\n\n    image_mgr = SoftLayer.ImageManager(env.client)\n    image_id = helpers.resolve_id(image_mgr.resolve_ids, identifier, 'image')\n\n    image_mgr.delete_image(image_id)", "code_tokens": "def cli ( env , identifier ) : image_mgr = SoftLayer . ImageManager ( env . client ) image_id = helpers . resolve_id ( image_mgr . resolve_ids , identifier , 'image' ) image_mgr . delete_image ( image_id )", "docstring_tokens": "Delete an image .", "label": 0}, {"idx": "cosqa-train-3066", "doc": "python open file in encoding", "code": "def read_string_from_file(path, encoding=\"utf8\"):\n  \"\"\"\n  Read entire contents of file into a string.\n  \"\"\"\n  with codecs.open(path, \"rb\", encoding=encoding) as f:\n    value = f.read()\n  return value", "code_tokens": "def read_string_from_file ( path , encoding = \"utf8\" ) : with codecs . open ( path , \"rb\" , encoding = encoding ) as f : value = f . read ( ) return value", "docstring_tokens": "Read entire contents of file into a string .", "label": 0}, {"idx": "cosqa-train-3067", "doc": "how to delete non empty directory in python", "code": "def remove_examples_all():\n    \"\"\"remove arduino/examples/all directory.\n\n    :rtype: None\n\n    \"\"\"\n    d = examples_all_dir()\n    if d.exists():\n        log.debug('remove %s', d)\n        d.rmtree()\n    else:\n        log.debug('nothing to remove: %s', d)", "code_tokens": "def remove_examples_all ( ) : d = examples_all_dir ( ) if d . exists ( ) : log . debug ( 'remove %s' , d ) d . rmtree ( ) else : log . debug ( 'nothing to remove: %s' , d )", "docstring_tokens": "remove arduino / examples / all directory .", "label": 0}, {"idx": "cosqa-train-3068", "doc": "python open file with different encoding", "code": "def open_with_encoding(filename, encoding, mode='r'):\n    \"\"\"Return opened file with a specific encoding.\"\"\"\n    return io.open(filename, mode=mode, encoding=encoding,\n                   newline='')", "code_tokens": "def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )", "docstring_tokens": "Return opened file with a specific encoding .", "label": 1}, {"idx": "cosqa-train-3069", "doc": "how to describe a binary tree in python", "code": "def make_bintree(levels):\n    \"\"\"Make a symmetrical binary tree with @levels\"\"\"\n    G = nx.DiGraph()\n    root = '0'\n    G.add_node(root)\n    add_children(G, root, levels, 2)\n    return G", "code_tokens": "def make_bintree ( levels ) : G = nx . DiGraph ( ) root = '0' G . add_node ( root ) add_children ( G , root , levels , 2 ) return G", "docstring_tokens": "Make a symmetrical binary tree with", "label": 0}, {"idx": "cosqa-train-3070", "doc": "python open text file with encoding", "code": "def read_string_from_file(path, encoding=\"utf8\"):\n  \"\"\"\n  Read entire contents of file into a string.\n  \"\"\"\n  with codecs.open(path, \"rb\", encoding=encoding) as f:\n    value = f.read()\n  return value", "code_tokens": "def read_string_from_file ( path , encoding = \"utf8\" ) : with codecs . open ( path , \"rb\" , encoding = encoding ) as f : value = f . read ( ) return value", "docstring_tokens": "Read entire contents of file into a string .", "label": 1}, {"idx": "cosqa-train-3071", "doc": "how to detect an integer in a string python", "code": "def str2int(string_with_int):\n    \"\"\" Collect digits from a string \"\"\"\n    return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)", "code_tokens": "def str2int ( string_with_int ) : return int ( \"\" . join ( [ char for char in string_with_int if char in string . digits ] ) or 0 )", "docstring_tokens": "Collect digits from a string", "label": 0}, {"idx": "cosqa-train-3072", "doc": "python opencv decode base64 image", "code": "def imdecode(image_path):\n    \"\"\"Return BGR image read by opencv\"\"\"\n    import os\n    assert os.path.exists(image_path), image_path + ' not found'\n    im = cv2.imread(image_path)\n    return im", "code_tokens": "def imdecode ( image_path ) : import os assert os . path . exists ( image_path ) , image_path + ' not found' im = cv2 . imread ( image_path ) return im", "docstring_tokens": "Return BGR image read by opencv", "label": 0}, {"idx": "cosqa-train-3073", "doc": "how to detect blank line in python", "code": "def _match_space_at_line(line):\n    \"\"\"Return a re.match object if an empty comment was found on line.\"\"\"\n    regex = re.compile(r\"^{0}$\".format(_MDL_COMMENT))\n    return regex.match(line)", "code_tokens": "def _match_space_at_line ( line ) : regex = re . compile ( r\"^{0}$\" . format ( _MDL_COMMENT ) ) return regex . match ( line )", "docstring_tokens": "Return a re . match object if an empty comment was found on line .", "label": 1}, {"idx": "cosqa-train-3074", "doc": "python opencv load image from byte string", "code": "def from_bytes(cls, b):\n\t\t\"\"\"Create :class:`PNG` from raw bytes.\n\t\t\n\t\t:arg bytes b: The raw bytes of the PNG file.\n\t\t:rtype: :class:`PNG`\n\t\t\"\"\"\n\t\tim = cls()\n\t\tim.chunks = list(parse_chunks(b))\n\t\tim.init()\n\t\treturn im", "code_tokens": "def from_bytes ( cls , b ) : im = cls ( ) im . chunks = list ( parse_chunks ( b ) ) im . init ( ) return im", "docstring_tokens": "Create : class : PNG from raw bytes . : arg bytes b : The raw bytes of the PNG file . : rtype : : class : PNG", "label": 0}, {"idx": "cosqa-train-3075", "doc": "how to determine if something is in the a line in a list in python", "code": "def isin(elems, line):\n    \"\"\"Check if an element from a list is in a string.\n\n    :type elems: list\n    :type line: str\n\n    \"\"\"\n    found = False\n    for e in elems:\n        if e in line.lower():\n            found = True\n            break\n    return found", "code_tokens": "def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found", "docstring_tokens": "Check if an element from a list is in a string .", "label": 0}, {"idx": "cosqa-train-3076", "doc": "python operstion every interval", "code": "def set_rate(rate):\n    \"\"\"Defines the ideal rate at which computation is to be performed\n\n    :arg rate: the frequency in Hertz \n    :type rate: int or float\n\n    :raises: TypeError: if argument 'rate' is not int or float\n    \"\"\"\n    if not (isinstance(rate, int) or isinstance(rate, float)):\n        raise TypeError(\"argument to set_rate is expected to be int or float\")\n    global loop_duration\n    loop_duration = 1.0/rate", "code_tokens": "def set_rate ( rate ) : if not ( isinstance ( rate , int ) or isinstance ( rate , float ) ) : raise TypeError ( \"argument to set_rate is expected to be int or float\" ) global loop_duration loop_duration = 1.0 / rate", "docstring_tokens": "Defines the ideal rate at which computation is to be performed", "label": 0}, {"idx": "cosqa-train-3077", "doc": "how to determine the availability of multiple extensions in python", "code": "def _platform_pylib_exts():  # nocover\n    \"\"\"\n    Returns .so, .pyd, or .dylib depending on linux, win or mac.\n    On python3 return the previous with and without abi (e.g.\n    .cpython-35m-x86_64-linux-gnu) flags. On python2 returns with\n    and without multiarch.\n    \"\"\"\n    import sysconfig\n    valid_exts = []\n    if six.PY2:\n        # see also 'SHLIB_EXT'\n        base_ext = '.' + sysconfig.get_config_var('SO').split('.')[-1]\n    else:\n        # return with and without API flags\n        # handle PEP 3149 -- ABI version tagged .so files\n        base_ext = '.' + sysconfig.get_config_var('EXT_SUFFIX').split('.')[-1]\n    for tag in _extension_module_tags():\n        valid_exts.append('.' + tag + base_ext)\n    valid_exts.append(base_ext)\n    return tuple(valid_exts)", "code_tokens": "def _platform_pylib_exts ( ) : # nocover import sysconfig valid_exts = [ ] if six . PY2 : # see also 'SHLIB_EXT' base_ext = '.' + sysconfig . get_config_var ( 'SO' ) . split ( '.' ) [ - 1 ] else : # return with and without API flags # handle PEP 3149 -- ABI version tagged .so files base_ext = '.' + sysconfig . get_config_var ( 'EXT_SUFFIX' ) . split ( '.' ) [ - 1 ] for tag in _extension_module_tags ( ) : valid_exts . append ( '.' + tag + base_ext ) valid_exts . append ( base_ext ) return tuple ( valid_exts )", "docstring_tokens": "Returns . so . pyd or . dylib depending on linux win or mac . On python3 return the previous with and without abi ( e . g . . cpython - 35m - x86_64 - linux - gnu ) flags . On python2 returns with and without multiarch .", "label": 0}, {"idx": "cosqa-train-3078", "doc": "python optionparser defualt args", "code": "def apply_argument_parser(argumentsParser, options=None):\n    \"\"\" Apply the argument parser. \"\"\"\n    if options is not None:\n        args = argumentsParser.parse_args(options)\n    else:\n        args = argumentsParser.parse_args()\n    return args", "code_tokens": "def apply_argument_parser ( argumentsParser , options = None ) : if options is not None : args = argumentsParser . parse_args ( options ) else : args = argumentsParser . parse_args ( ) return args", "docstring_tokens": "Apply the argument parser .", "label": 0}, {"idx": "cosqa-train-3079", "doc": "how to determine the number of lines in a python string", "code": "def _visual_width(line):\n    \"\"\"Get the the number of columns required to display a string\"\"\"\n\n    return len(re.sub(colorama.ansitowin32.AnsiToWin32.ANSI_CSI_RE, \"\", line))", "code_tokens": "def _visual_width ( line ) : return len ( re . sub ( colorama . ansitowin32 . AnsiToWin32 . ANSI_CSI_RE , \"\" , line ) )", "docstring_tokens": "Get the the number of columns required to display a string", "label": 0}, {"idx": "cosqa-train-3080", "doc": "python optionparser print help", "code": "def help(self, level=0):\n        \"\"\"return the usage string for available options \"\"\"\n        self.cmdline_parser.formatter.output_level = level\n        with _patch_optparse():\n            return self.cmdline_parser.format_help()", "code_tokens": "def help ( self , level = 0 ) : self . cmdline_parser . formatter . output_level = level with _patch_optparse ( ) : return self . cmdline_parser . format_help ( )", "docstring_tokens": "return the usage string for available options", "label": 0}, {"idx": "cosqa-train-3081", "doc": "how to displa an image in a window with cv2 python", "code": "def screen_cv2(self):\n        \"\"\"cv2 Image of current window screen\"\"\"\n        pil_image = self.screen.convert('RGB')\n        cv2_image = np.array(pil_image)\n        pil_image.close()\n        # Convert RGB to BGR \n        cv2_image = cv2_image[:, :, ::-1]\n        return cv2_image", "code_tokens": "def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR \n cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image", "docstring_tokens": "cv2 Image of current window screen", "label": 0}, {"idx": "cosqa-train-3082", "doc": "python os check if folder exists and create otherwise", "code": "def check_create_folder(filename):\n    \"\"\"Check if the folder exisits. If not, create the folder\"\"\"\n    os.makedirs(os.path.dirname(filename), exist_ok=True)", "code_tokens": "def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )", "docstring_tokens": "Check if the folder exisits . If not create the folder", "label": 1}, {"idx": "cosqa-train-3083", "doc": "how to divide pixel values by 255 to normalize in python", "code": "def _normalize(mat: np.ndarray):\n    \"\"\"rescales a numpy array, so that min is 0 and max is 255\"\"\"\n    return ((mat - mat.min()) * (255 / mat.max())).astype(np.uint8)", "code_tokens": "def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )", "docstring_tokens": "rescales a numpy array so that min is 0 and max is 255", "label": 0}, {"idx": "cosqa-train-3084", "doc": "python pad a number zeros", "code": "def zero_pad(m, n=1):\n    \"\"\"Pad a matrix with zeros, on all sides.\"\"\"\n    return np.pad(m, (n, n), mode='constant', constant_values=[0])", "code_tokens": "def zero_pad ( m , n = 1 ) : return np . pad ( m , ( n , n ) , mode = 'constant' , constant_values = [ 0 ] )", "docstring_tokens": "Pad a matrix with zeros on all sides .", "label": 0}, {"idx": "cosqa-train-3085", "doc": "how to do an action on python before termination", "code": "def _quit(self, *args):\n        \"\"\" quit crash \"\"\"\n        self.logger.warn('Bye!')\n        sys.exit(self.exit())", "code_tokens": "def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )", "docstring_tokens": "quit crash", "label": 0}, {"idx": "cosqa-train-3086", "doc": "python pad spaces to left and zeros to right", "code": "def zero_pad(m, n=1):\n    \"\"\"Pad a matrix with zeros, on all sides.\"\"\"\n    return np.pad(m, (n, n), mode='constant', constant_values=[0])", "code_tokens": "def zero_pad ( m , n = 1 ) : return np . pad ( m , ( n , n ) , mode = 'constant' , constant_values = [ 0 ] )", "docstring_tokens": "Pad a matrix with zeros on all sides .", "label": 0}, {"idx": "cosqa-train-3087", "doc": "how to do an exponential in python", "code": "def algo_exp(x, m, t, b):\n    \"\"\"mono-exponential curve.\"\"\"\n    return m*np.exp(-t*x)+b", "code_tokens": "def algo_exp ( x , m , t , b ) : return m * np . exp ( - t * x ) + b", "docstring_tokens": "mono - exponential curve .", "label": 0}, {"idx": "cosqa-train-3088", "doc": "python panda check if column exists", "code": "def column_exists(cr, table, column):\n    \"\"\" Check whether a certain column exists \"\"\"\n    cr.execute(\n        'SELECT count(attname) FROM pg_attribute '\n        'WHERE attrelid = '\n        '( SELECT oid FROM pg_class WHERE relname = %s ) '\n        'AND attname = %s',\n        (table, column))\n    return cr.fetchone()[0] == 1", "code_tokens": "def column_exists ( cr , table , column ) : cr . execute ( 'SELECT count(attname) FROM pg_attribute ' 'WHERE attrelid = ' '( SELECT oid FROM pg_class WHERE relname = %s ) ' 'AND attname = %s' , ( table , column ) ) return cr . fetchone ( ) [ 0 ] == 1", "docstring_tokens": "Check whether a certain column exists", "label": 0}, {"idx": "cosqa-train-3089", "doc": "how to do outer join python", "code": "def merge(left, right, how='inner', key=None, left_key=None, right_key=None,\n          left_as='left', right_as='right'):\n    \"\"\" Performs a join using the union join function. \"\"\"\n    return join(left, right, how, key, left_key, right_key,\n                join_fn=make_union_join(left_as, right_as))", "code_tokens": "def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "docstring_tokens": "Performs a join using the union join function .", "label": 0}, {"idx": "cosqa-train-3090", "doc": "python pands sum all fields", "code": "def query_sum(queryset, field):\n    \"\"\"\n    Let the DBMS perform a sum on a queryset\n    \"\"\"\n    return queryset.aggregate(s=models.functions.Coalesce(models.Sum(field), 0))['s']", "code_tokens": "def query_sum ( queryset , field ) : return queryset . aggregate ( s = models . functions . Coalesce ( models . Sum ( field ) , 0 ) ) [ 's' ]", "docstring_tokens": "Let the DBMS perform a sum on a queryset", "label": 0}, {"idx": "cosqa-train-3091", "doc": "how to do tabular format with the appropriate header in python", "code": "def adapter(data, headers, **kwargs):\n    \"\"\"Wrap vertical table in a function for TabularOutputFormatter.\"\"\"\n    keys = ('sep_title', 'sep_character', 'sep_length')\n    return vertical_table(data, headers, **filter_dict_by_key(kwargs, keys))", "code_tokens": "def adapter ( data , headers , * * kwargs ) : keys = ( 'sep_title' , 'sep_character' , 'sep_length' ) return vertical_table ( data , headers , * * filter_dict_by_key ( kwargs , keys ) )", "docstring_tokens": "Wrap vertical table in a function for TabularOutputFormatter .", "label": 0}, {"idx": "cosqa-train-3092", "doc": "python parse data from api", "code": "def user_parse(data):\n        \"\"\"Parse information from the provider.\"\"\"\n        _user = data.get('response', {}).get('user', {})\n        yield 'id', _user.get('name')\n        yield 'username', _user.get('name')\n        yield 'link', _user.get('blogs', [{}])[0].get('url')", "code_tokens": "def user_parse ( data ) : _user = data . get ( 'response' , { } ) . get ( 'user' , { } ) yield 'id' , _user . get ( 'name' ) yield 'username' , _user . get ( 'name' ) yield 'link' , _user . get ( 'blogs' , [ { } ] ) [ 0 ] . get ( 'url' )", "docstring_tokens": "Parse information from the provider .", "label": 0}, {"idx": "cosqa-train-3093", "doc": "how to do thresholding of an image in python", "code": "def clip_image(image, clip_min, clip_max):\n  \"\"\" Clip an image, or an image batch, with upper and lower threshold. \"\"\"\n  return np.minimum(np.maximum(clip_min, image), clip_max)", "code_tokens": "def clip_image ( image , clip_min , clip_max ) : return np . minimum ( np . maximum ( clip_min , image ) , clip_max )", "docstring_tokens": "Clip an image or an image batch with upper and lower threshold .", "label": 0}, {"idx": "cosqa-train-3094", "doc": "python parse date string to timestamp with timezone", "code": "def clean_time(time_string):\n    \"\"\"Return a datetime from the Amazon-provided datetime string\"\"\"\n    # Get a timezone-aware datetime object from the string\n    time = dateutil.parser.parse(time_string)\n    if not settings.USE_TZ:\n        # If timezone support is not active, convert the time to UTC and\n        # remove the timezone field\n        time = time.astimezone(timezone.utc).replace(tzinfo=None)\n    return time", "code_tokens": "def clean_time ( time_string ) : # Get a timezone-aware datetime object from the string time = dateutil . parser . parse ( time_string ) if not settings . USE_TZ : # If timezone support is not active, convert the time to UTC and # remove the timezone field time = time . astimezone ( timezone . utc ) . replace ( tzinfo = None ) return time", "docstring_tokens": "Return a datetime from the Amazon - provided datetime string", "label": 0}, {"idx": "cosqa-train-3095", "doc": "how to document kwargs python", "code": "def updateFromKwargs(self, properties, kwargs, collector, **unused):\n        \"\"\"Primary entry point to turn 'kwargs' into 'properties'\"\"\"\n        properties[self.name] = self.getFromKwargs(kwargs)", "code_tokens": "def updateFromKwargs ( self , properties , kwargs , collector , * * unused ) : properties [ self . name ] = self . getFromKwargs ( kwargs )", "docstring_tokens": "Primary entry point to turn kwargs into properties", "label": 0}, {"idx": "cosqa-train-3096", "doc": "python parse float list form string", "code": "def string_to_float_list(string_var):\n        \"\"\"Pull comma separated string values out of a text file and converts them to float list\"\"\"\n        try:\n            return [float(s) for s in string_var.strip('[').strip(']').split(', ')]\n        except:\n            return [float(s) for s in string_var.strip('[').strip(']').split(',')]", "code_tokens": "def string_to_float_list ( string_var ) : try : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ', ' ) ] except : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ',' ) ]", "docstring_tokens": "Pull comma separated string values out of a text file and converts them to float list", "label": 0}, {"idx": "cosqa-train-3097", "doc": "how to download a regular file from the web in python", "code": "def wget(url):\n    \"\"\"\n    Download the page into a string\n    \"\"\"\n    import urllib.parse\n    request = urllib.request.urlopen(url)\n    filestring = request.read()\n    return filestring", "code_tokens": "def wget ( url ) : import urllib . parse request = urllib . request . urlopen ( url ) filestring = request . read ( ) return filestring", "docstring_tokens": "Download the page into a string", "label": 0}, {"idx": "cosqa-train-3098", "doc": "python parse json datetime", "code": "def parse_json_date(value):\n    \"\"\"\n    Parses an ISO8601 formatted datetime from a string value\n    \"\"\"\n    if not value:\n        return None\n\n    return datetime.datetime.strptime(value, JSON_DATETIME_FORMAT).replace(tzinfo=pytz.UTC)", "code_tokens": "def parse_json_date ( value ) : if not value : return None return datetime . datetime . strptime ( value , JSON_DATETIME_FORMAT ) . replace ( tzinfo = pytz . UTC )", "docstring_tokens": "Parses an ISO8601 formatted datetime from a string value", "label": 0}, {"idx": "cosqa-train-3099", "doc": "how to duplicate something in a list python", "code": "def dedupe_list(l):\n    \"\"\"Remove duplicates from a list preserving the order.\n\n    We might be tempted to use the list(set(l)) idiom, but it doesn't preserve\n    the order, which hinders testability and does not work for lists with\n    unhashable elements.\n    \"\"\"\n    result = []\n\n    for el in l:\n        if el not in result:\n            result.append(el)\n\n    return result", "code_tokens": "def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result", "docstring_tokens": "Remove duplicates from a list preserving the order .", "label": 0}, {"idx": "cosqa-train-3100", "doc": "python parse query param", "code": "def parse_query_string(query):\n    \"\"\"\n    parse_query_string:\n    very simplistic. won't do the right thing with list values\n    \"\"\"\n    result = {}\n    qparts = query.split('&')\n    for item in qparts:\n        key, value = item.split('=')\n        key = key.strip()\n        value = value.strip()\n        result[key] = unquote_plus(value)\n    return result", "code_tokens": "def parse_query_string ( query ) : result = { } qparts = query . split ( '&' ) for item in qparts : key , value = item . split ( '=' ) key = key . strip ( ) value = value . strip ( ) result [ key ] = unquote_plus ( value ) return result", "docstring_tokens": "parse_query_string : very simplistic . won t do the right thing with list values", "label": 0}, {"idx": "cosqa-train-3101", "doc": "how to dynamically build a dictionary in python", "code": "def get_dict_for_attrs(obj, attrs):\n    \"\"\"\n    Returns dictionary for each attribute from given ``obj``.\n    \"\"\"\n    data = {}\n    for attr in attrs:\n        data[attr] = getattr(obj, attr)\n    return data", "code_tokens": "def get_dict_for_attrs ( obj , attrs ) : data = { } for attr in attrs : data [ attr ] = getattr ( obj , attr ) return data", "docstring_tokens": "Returns dictionary for each attribute from given obj .", "label": 0}, {"idx": "cosqa-train-3102", "doc": "python parse string by token", "code": "def tree(string, token=[WORD, POS, CHUNK, PNP, REL, ANCHOR, LEMMA]):\n    \"\"\" Transforms the output of parse() into a Text object.\n        The token parameter lists the order of tags in each token in the input string.\n    \"\"\"\n    return Text(string, token)", "code_tokens": "def tree ( string , token = [ WORD , POS , CHUNK , PNP , REL , ANCHOR , LEMMA ] ) : return Text ( string , token )", "docstring_tokens": "Transforms the output of parse () into a Text object . The token parameter lists the order of tags in each token in the input string .", "label": 1}, {"idx": "cosqa-train-3103", "doc": "how to dynamically wrap a function python", "code": "def map_wrap(f):\n    \"\"\"Wrap standard function to easily pass into 'map' processing.\n    \"\"\"\n    @functools.wraps(f)\n    def wrapper(*args, **kwargs):\n        return f(*args, **kwargs)\n    return wrapper", "code_tokens": "def map_wrap ( f ) : @ functools . wraps ( f ) def wrapper ( * args , * * kwargs ) : return f ( * args , * * kwargs ) return wrapper", "docstring_tokens": "Wrap standard function to easily pass into map processing .", "label": 0}, {"idx": "cosqa-train-3104", "doc": "python parse xml keep comments", "code": "def parse(source, remove_comments=True, **kw):\n    \"\"\"Thin wrapper around ElementTree.parse\"\"\"\n    return ElementTree.parse(source, SourceLineParser(), **kw)", "code_tokens": "def parse ( source , remove_comments = True , * * kw ) : return ElementTree . parse ( source , SourceLineParser ( ) , * * kw )", "docstring_tokens": "Thin wrapper around ElementTree . parse", "label": 0}, {"idx": "cosqa-train-3105", "doc": "how to eliminate na values in a data frame in python", "code": "def dropna(self, subset=None):\n        \"\"\"Remove missing values according to Baloo's convention.\n\n        Parameters\n        ----------\n        subset : list of str, optional\n            Which columns to check for missing values in.\n\n        Returns\n        -------\n        DataFrame\n            DataFrame with no null values in columns.\n\n        \"\"\"\n        subset = check_and_obtain_subset_columns(subset, self)\n        not_nas = [v.notna() for v in self[subset]._iter()]\n        and_filter = reduce(lambda x, y: x & y, not_nas)\n\n        return self[and_filter]", "code_tokens": "def dropna ( self , subset = None ) : subset = check_and_obtain_subset_columns ( subset , self ) not_nas = [ v . notna ( ) for v in self [ subset ] . _iter ( ) ] and_filter = reduce ( lambda x , y : x & y , not_nas ) return self [ and_filter ]", "docstring_tokens": "Remove missing values according to Baloo s convention .", "label": 0}, {"idx": "cosqa-train-3106", "doc": "python pass dict to be a kwargs", "code": "def updateFromKwargs(self, properties, kwargs, collector, **unused):\n        \"\"\"Primary entry point to turn 'kwargs' into 'properties'\"\"\"\n        properties[self.name] = self.getFromKwargs(kwargs)", "code_tokens": "def updateFromKwargs ( self , properties , kwargs , collector , * * unused ) : properties [ self . name ] = self . getFromKwargs ( kwargs )", "docstring_tokens": "Primary entry point to turn kwargs into properties", "label": 0}, {"idx": "cosqa-train-3107", "doc": "how to encode letters with dictionary python", "code": "def clean_dict_keys(d):\n    \"\"\"Convert all keys of the dict 'd' to (ascii-)strings.\n\n    :Raises: UnicodeEncodeError\n    \"\"\"\n    new_d = {}\n    for (k, v) in d.iteritems():\n        new_d[str(k)] = v\n    return new_d", "code_tokens": "def clean_dict_keys ( d ) : new_d = { } for ( k , v ) in d . iteritems ( ) : new_d [ str ( k ) ] = v return new_d", "docstring_tokens": "Convert all keys of the dict d to ( ascii - ) strings .", "label": 0}, {"idx": "cosqa-train-3108", "doc": "python pass function as empty variabl", "code": "def def_linear(fun):\n    \"\"\"Flags that a function is linear wrt all args\"\"\"\n    defjvp_argnum(fun, lambda argnum, g, ans, args, kwargs:\n                  fun(*subval(args, argnum, g), **kwargs))", "code_tokens": "def def_linear ( fun ) : defjvp_argnum ( fun , lambda argnum , g , ans , args , kwargs : fun ( * subval ( args , argnum , g ) , * * kwargs ) )", "docstring_tokens": "Flags that a function is linear wrt all args", "label": 0}, {"idx": "cosqa-train-3109", "doc": "how to end a while loop with sleep function python", "code": "def test3():\n    \"\"\"Test the multiprocess\n    \"\"\"\n    import time\n    \n    p = MVisionProcess()\n    p.start()\n    time.sleep(5)\n    p.stop()", "code_tokens": "def test3 ( ) : import time p = MVisionProcess ( ) p . start ( ) time . sleep ( 5 ) p . stop ( )", "docstring_tokens": "Test the multiprocess", "label": 0}, {"idx": "cosqa-train-3110", "doc": "python passing **kwargs into a formatted string", "code": "def reprkwargs(kwargs, sep=', ', fmt=\"{0!s}={1!r}\"):\n    \"\"\"Display kwargs.\"\"\"\n    return sep.join(fmt.format(k, v) for k, v in kwargs.iteritems())", "code_tokens": "def reprkwargs ( kwargs , sep = ', ' , fmt = \"{0!s}={1!r}\" ) : return sep . join ( fmt . format ( k , v ) for k , v in kwargs . iteritems ( ) )", "docstring_tokens": "Display kwargs .", "label": 0}, {"idx": "cosqa-train-3111", "doc": "how to exclude symbols and punctuation in python", "code": "def remove_punctuation(text, exceptions=[]):\n    \"\"\"\n    Return a string with punctuation removed.\n\n    Parameters:\n        text (str): The text to remove punctuation from.\n        exceptions (list): List of symbols to keep in the given text.\n\n    Return:\n        str: The input text without the punctuation.\n    \"\"\"\n\n    all_but = [\n        r'\\w',\n        r'\\s'\n    ]\n\n    all_but.extend(exceptions)\n\n    pattern = '[^{}]'.format(''.join(all_but))\n\n    return re.sub(pattern, '', text)", "code_tokens": "def remove_punctuation ( text , exceptions = [ ] ) : all_but = [ r'\\w' , r'\\s' ] all_but . extend ( exceptions ) pattern = '[^{}]' . format ( '' . join ( all_but ) ) return re . sub ( pattern , '' , text )", "docstring_tokens": "Return a string with punctuation removed .", "label": 0}, {"idx": "cosqa-train-3112", "doc": "python path isfile doesnt work macos", "code": "def is_file(path):\n    \"\"\"Determine if a Path or string is a file on the file system.\"\"\"\n    try:\n        return path.expanduser().absolute().is_file()\n    except AttributeError:\n        return os.path.isfile(os.path.abspath(os.path.expanduser(str(path))))", "code_tokens": "def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )", "docstring_tokens": "Determine if a Path or string is a file on the file system .", "label": 0}, {"idx": "cosqa-train-3113", "doc": "how to execute a python code from file", "code": "def execfile(fname, variables):\n    \"\"\" This is builtin in python2, but we have to roll our own on py3. \"\"\"\n    with open(fname) as f:\n        code = compile(f.read(), fname, 'exec')\n        exec(code, variables)", "code_tokens": "def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )", "docstring_tokens": "This is builtin in python2 but we have to roll our own on py3 .", "label": 0}, {"idx": "cosqa-train-3114", "doc": "python pathlib change dir", "code": "def dir_path(dir):\n    \"\"\"with dir_path(path) to change into a directory.\"\"\"\n    old_dir = os.getcwd()\n    os.chdir(dir)\n    yield\n    os.chdir(old_dir)", "code_tokens": "def dir_path ( dir ) : old_dir = os . getcwd ( ) os . chdir ( dir ) yield os . chdir ( old_dir )", "docstring_tokens": "with dir_path ( path ) to change into a directory .", "label": 0}, {"idx": "cosqa-train-3115", "doc": "how to exit a python fuction with error message", "code": "def exit_and_fail(self, msg=None, out=None):\n    \"\"\"Exits the runtime with a nonzero exit code, indicating failure.\n\n    :param msg: A string message to print to stderr or another custom file desciptor before exiting.\n                (Optional)\n    :param out: The file descriptor to emit `msg` to. (Optional)\n    \"\"\"\n    self.exit(result=PANTS_FAILED_EXIT_CODE, msg=msg, out=out)", "code_tokens": "def exit_and_fail ( self , msg = None , out = None ) : self . exit ( result = PANTS_FAILED_EXIT_CODE , msg = msg , out = out )", "docstring_tokens": "Exits the runtime with a nonzero exit code indicating failure .", "label": 0}, {"idx": "cosqa-train-3116", "doc": "python pcolormesh set colorbar min/max", "code": "def palettebar(height, length, colormap):\n    \"\"\"Return the channels of a palettebar.\n    \"\"\"\n    cbar = np.tile(np.arange(length) * 1.0 / (length - 1), (height, 1))\n    cbar = (cbar * (colormap.values.max() + 1 - colormap.values.min())\n            + colormap.values.min())\n\n    return colormap.palettize(cbar)", "code_tokens": "def palettebar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) + 1 - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . palettize ( cbar )", "docstring_tokens": "Return the channels of a palettebar .", "label": 1}, {"idx": "cosqa-train-3117", "doc": "how to exit python from shel", "code": "def do_exit(self, arg):\n        \"\"\"Exit the shell session.\"\"\"\n\n        if self.current:\n            self.current.close()\n        self.resource_manager.close()\n        del self.resource_manager\n        return True", "code_tokens": "def do_exit ( self , arg ) : if self . current : self . current . close ( ) self . resource_manager . close ( ) del self . resource_manager return True", "docstring_tokens": "Exit the shell session .", "label": 0}, {"idx": "cosqa-train-3118", "doc": "python pdb setting variable", "code": "def user_return(self, frame, return_value):\n        \"\"\"This function is called when a return trap is set here.\"\"\"\n        pdb.Pdb.user_return(self, frame, return_value)", "code_tokens": "def user_return ( self , frame , return_value ) : pdb . Pdb . user_return ( self , frame , return_value )", "docstring_tokens": "This function is called when a return trap is set here .", "label": 0}, {"idx": "cosqa-train-3119", "doc": "how to export a zipped folder from python", "code": "def unzip_file_to_dir(path_to_zip, output_directory):\n    \"\"\"\n    Extract a ZIP archive to a directory\n    \"\"\"\n    z = ZipFile(path_to_zip, 'r')\n    z.extractall(output_directory)\n    z.close()", "code_tokens": "def unzip_file_to_dir ( path_to_zip , output_directory ) : z = ZipFile ( path_to_zip , 'r' ) z . extractall ( output_directory ) z . close ( )", "docstring_tokens": "Extract a ZIP archive to a directory", "label": 0}, {"idx": "cosqa-train-3120", "doc": "python pdfpages combine files", "code": "def _single_page_pdf(page):\n    \"\"\"Construct a single page PDF from the provided page in memory\"\"\"\n    pdf = Pdf.new()\n    pdf.pages.append(page)\n    bio = BytesIO()\n    pdf.save(bio)\n    bio.seek(0)\n    return bio.read()", "code_tokens": "def _single_page_pdf ( page ) : pdf = Pdf . new ( ) pdf . pages . append ( page ) bio = BytesIO ( ) pdf . save ( bio ) bio . seek ( 0 ) return bio . read ( )", "docstring_tokens": "Construct a single page PDF from the provided page in memory", "label": 0}, {"idx": "cosqa-train-3121", "doc": "how to expose an object field in python", "code": "def _basic_field_data(field, obj):\n    \"\"\"Returns ``obj.field`` data as a dict\"\"\"\n    value = field.value_from_object(obj)\n    return {Field.TYPE: FieldType.VAL, Field.VALUE: value}", "code_tokens": "def _basic_field_data ( field , obj ) : value = field . value_from_object ( obj ) return { Field . TYPE : FieldType . VAL , Field . VALUE : value }", "docstring_tokens": "Returns obj . field data as a dict", "label": 0}, {"idx": "cosqa-train-3122", "doc": "python phase shift fourier", "code": "def translate_fourier(image, dx):\n    \"\"\" Translate an image in fourier-space with plane waves \"\"\"\n    N = image.shape[0]\n\n    f = 2*np.pi*np.fft.fftfreq(N)\n    kx,ky,kz = np.meshgrid(*(f,)*3, indexing='ij')\n    kv = np.array([kx,ky,kz]).T\n\n    q = np.fft.fftn(image)*np.exp(-1.j*(kv*dx).sum(axis=-1)).T\n    return np.real(np.fft.ifftn(q))", "code_tokens": "def translate_fourier ( image , dx ) : N = image . shape [ 0 ] f = 2 * np . pi * np . fft . fftfreq ( N ) kx , ky , kz = np . meshgrid ( * ( f , ) * 3 , indexing = 'ij' ) kv = np . array ( [ kx , ky , kz ] ) . T q = np . fft . fftn ( image ) * np . exp ( - 1.j * ( kv * dx ) . sum ( axis = - 1 ) ) . T return np . real ( np . fft . ifftn ( q ) )", "docstring_tokens": "Translate an image in fourier - space with plane waves", "label": 0}, {"idx": "cosqa-train-3123", "doc": "how to expose file over local network python", "code": "def get_remote_content(filepath):\n        \"\"\" A handy wrapper to get a remote file content \"\"\"\n        with hide('running'):\n            temp = BytesIO()\n            get(filepath, temp)\n            content = temp.getvalue().decode('utf-8')\n        return content.strip()", "code_tokens": "def get_remote_content ( filepath ) : with hide ( 'running' ) : temp = BytesIO ( ) get ( filepath , temp ) content = temp . getvalue ( ) . decode ( 'utf-8' ) return content . strip ( )", "docstring_tokens": "A handy wrapper to get a remote file content", "label": 0}, {"idx": "cosqa-train-3124", "doc": "python pick one element randomly from set", "code": "def random_choice(sequence):\n    \"\"\" Same as :meth:`random.choice`, but also supports :class:`set` type to be passed as sequence. \"\"\"\n    return random.choice(tuple(sequence) if isinstance(sequence, set) else sequence)", "code_tokens": "def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )", "docstring_tokens": "Same as : meth : random . choice but also supports : class : set type to be passed as sequence .", "label": 1}, {"idx": "cosqa-train-3125", "doc": "how to extend vectors python3", "code": "def translate_v3(vec, amount):\n    \"\"\"Return a new Vec3 that is translated version of vec.\"\"\"\n\n    return Vec3(vec.x+amount, vec.y+amount, vec.z+amount)", "code_tokens": "def translate_v3 ( vec , amount ) : return Vec3 ( vec . x + amount , vec . y + amount , vec . z + amount )", "docstring_tokens": "Return a new Vec3 that is translated version of vec .", "label": 0}, {"idx": "cosqa-train-3126", "doc": "python pickling rlock objects", "code": "def _parallel_compare_helper(class_obj, pairs, x, x_link=None):\n    \"\"\"Internal function to overcome pickling problem in python2.\"\"\"\n    return class_obj._compute(pairs, x, x_link)", "code_tokens": "def _parallel_compare_helper ( class_obj , pairs , x , x_link = None ) : return class_obj . _compute ( pairs , x , x_link )", "docstring_tokens": "Internal function to overcome pickling problem in python2 .", "label": 1}, {"idx": "cosqa-train-3127", "doc": "how to extract image from open cv in python", "code": "def imdecode(image_path):\n    \"\"\"Return BGR image read by opencv\"\"\"\n    import os\n    assert os.path.exists(image_path), image_path + ' not found'\n    im = cv2.imread(image_path)\n    return im", "code_tokens": "def imdecode ( image_path ) : import os assert os . path . exists ( image_path ) , image_path + ' not found' im = cv2 . imread ( image_path ) return im", "docstring_tokens": "Return BGR image read by opencv", "label": 0}, {"idx": "cosqa-train-3128", "doc": "python pil image to cv2", "code": "def screen_cv2(self):\n        \"\"\"cv2 Image of current window screen\"\"\"\n        pil_image = self.screen.convert('RGB')\n        cv2_image = np.array(pil_image)\n        pil_image.close()\n        # Convert RGB to BGR \n        cv2_image = cv2_image[:, :, ::-1]\n        return cv2_image", "code_tokens": "def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR \n cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image", "docstring_tokens": "cv2 Image of current window screen", "label": 0}, {"idx": "cosqa-train-3129", "doc": "how to extract property names from schema using python", "code": "def get_keys_from_class(cc):\n    \"\"\"Return list of the key property names for a class \"\"\"\n    return [prop.name for prop in cc.properties.values() \\\n            if 'key' in prop.qualifiers]", "code_tokens": "def get_keys_from_class ( cc ) : return [ prop . name for prop in cc . properties . values ( ) if 'key' in prop . qualifiers ]", "docstring_tokens": "Return list of the key property names for a class", "label": 0}, {"idx": "cosqa-train-3130", "doc": "python pil to resize an image", "code": "def resize(self, size):\n        \"\"\"Return a new Image instance with the given size.\"\"\"\n        return Image(self.pil_image.resize(size, PIL.Image.ANTIALIAS))", "code_tokens": "def resize ( self , size ) : return Image ( self . pil_image . resize ( size , PIL . Image . ANTIALIAS ) )", "docstring_tokens": "Return a new Image instance with the given size .", "label": 0}, {"idx": "cosqa-train-3131", "doc": "how to extract the date a file was created in python", "code": "def datetime_created(self):\n        \"\"\"Returns file group's create aware *datetime* in UTC format.\"\"\"\n        if self.info().get('datetime_created'):\n            return dateutil.parser.parse(self.info()['datetime_created'])", "code_tokens": "def datetime_created ( self ) : if self . info ( ) . get ( 'datetime_created' ) : return dateutil . parser . parse ( self . info ( ) [ 'datetime_created' ] )", "docstring_tokens": "Returns file group s create aware * datetime * in UTC format .", "label": 0}, {"idx": "cosqa-train-3132", "doc": "python pool shared context object", "code": "def context(self):\n        \"\"\" Convenient access to shared context \"\"\"\n        if self._context is not None:\n            return self._context\n        else:\n            logger.warning(\"Using shared context without a lock\")\n            return self._executor._shared_context", "code_tokens": "def context ( self ) : if self . _context is not None : return self . _context else : logger . warning ( \"Using shared context without a lock\" ) return self . _executor . _shared_context", "docstring_tokens": "Convenient access to shared context", "label": 0}, {"idx": "cosqa-train-3133", "doc": "how to filter out the counter object python", "code": "def counter(items):\n    \"\"\"\n    Simplest required implementation of collections.Counter. Required as 2.6\n    does not have Counter in collections.\n    \"\"\"\n    results = {}\n    for item in items:\n        results[item] = results.get(item, 0) + 1\n    return results", "code_tokens": "def counter ( items ) : results = { } for item in items : results [ item ] = results . get ( item , 0 ) + 1 return results", "docstring_tokens": "Simplest required implementation of collections . Counter . Required as 2 . 6 does not have Counter in collections .", "label": 0}, {"idx": "cosqa-train-3134", "doc": "python prefix self to list", "code": "def as_list(self):\n        \"\"\"Return all child objects in nested lists of strings.\"\"\"\n        return [self.name, self.value, [x.as_list for x in self.children]]", "code_tokens": "def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]", "docstring_tokens": "Return all child objects in nested lists of strings .", "label": 0}, {"idx": "cosqa-train-3135", "doc": "how to filter table in python", "code": "def filter_bolts(table, header):\n  \"\"\" filter to keep bolts \"\"\"\n  bolts_info = []\n  for row in table:\n    if row[0] == 'bolt':\n      bolts_info.append(row)\n  return bolts_info, header", "code_tokens": "def filter_bolts ( table , header ) : bolts_info = [ ] for row in table : if row [ 0 ] == 'bolt' : bolts_info . append ( row ) return bolts_info , header", "docstring_tokens": "filter to keep bolts", "label": 0}, {"idx": "cosqa-train-3136", "doc": "python print 20 first characters file", "code": "def head(filename, n=10):\n    \"\"\" prints the top `n` lines of a file \"\"\"\n    with freader(filename) as fr:\n        for _ in range(n):\n            print(fr.readline().strip())", "code_tokens": "def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )", "docstring_tokens": "prints the top n lines of a file", "label": 0}, {"idx": "cosqa-train-3137", "doc": "how to fix pylint error in python", "code": "def pylint_raw(options):\n    \"\"\"\n    Use check_output to run pylint.\n    Because pylint changes the exit code based on the code score,\n    we have to wrap it in a try/except block.\n\n    :param options:\n    :return:\n    \"\"\"\n    command = ['pylint']\n    command.extend(options)\n\n    proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    outs, __ = proc.communicate()\n\n    return outs.decode()", "code_tokens": "def pylint_raw ( options ) : command = [ 'pylint' ] command . extend ( options ) proc = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) outs , __ = proc . communicate ( ) return outs . decode ( )", "docstring_tokens": "Use check_output to run pylint . Because pylint changes the exit code based on the code score we have to wrap it in a try / except block .", "label": 0}, {"idx": "cosqa-train-3138", "doc": "python print all member vars", "code": "def print_param_values(self_):\n        \"\"\"Print the values of all this object's Parameters.\"\"\"\n        self = self_.self\n        for name,val in self.param.get_param_values():\n            print('%s.%s = %s' % (self.name,name,val))", "code_tokens": "def print_param_values ( self_ ) : self = self_ . self for name , val in self . param . get_param_values ( ) : print ( '%s.%s = %s' % ( self . name , name , val ) )", "docstring_tokens": "Print the values of all this object s Parameters .", "label": 0}, {"idx": "cosqa-train-3139", "doc": "how to format something x amount of spaces over python", "code": "def indented_show(text, howmany=1):\n        \"\"\"Print a formatted indented text.\n        \"\"\"\n        print(StrTemplate.pad_indent(text=text, howmany=howmany))", "code_tokens": "def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )", "docstring_tokens": "Print a formatted indented text .", "label": 1}, {"idx": "cosqa-train-3140", "doc": "python print an env variable", "code": "def print_env_info(key, out=sys.stderr):\n    \"\"\"If given environment key is defined, print it out.\"\"\"\n    value = os.getenv(key)\n    if value is not None:\n        print(key, \"=\", repr(value), file=out)", "code_tokens": "def print_env_info ( key , out = sys . stderr ) : value = os . getenv ( key ) if value is not None : print ( key , \"=\" , repr ( value ) , file = out )", "docstring_tokens": "If given environment key is defined print it out .", "label": 0}, {"idx": "cosqa-train-3141", "doc": "how to generate a random list with n characters in python", "code": "def random_letters(n):\n    \"\"\"\n    Generate a random string from a-zA-Z\n    :param n: length of the string\n    :return: the random string\n    \"\"\"\n    return ''.join(random.SystemRandom().choice(string.ascii_letters) for _ in range(n))", "code_tokens": "def random_letters ( n ) : return '' . join ( random . SystemRandom ( ) . choice ( string . ascii_letters ) for _ in range ( n ) )", "docstring_tokens": "Generate a random string from a - zA - Z : param n : length of the string : return : the random string", "label": 0}, {"idx": "cosqa-train-3142", "doc": "python print color and bold", "code": "def info(txt):\n    \"\"\"Print, emphasized 'neutral', the given 'txt' message\"\"\"\n\n    print(\"%s# %s%s%s\" % (PR_EMPH_CC, get_time_stamp(), txt, PR_NC))\n    sys.stdout.flush()", "code_tokens": "def info ( txt ) : print ( \"%s# %s%s%s\" % ( PR_EMPH_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "docstring_tokens": "Print emphasized neutral the given txt message", "label": 0}, {"idx": "cosqa-train-3143", "doc": "how to generate passwords with python", "code": "def GeneratePassphrase(length=20):\n  \"\"\"Create a 20 char passphrase with easily typeable chars.\"\"\"\n  valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  valid_chars += \"0123456789 ,-_&$#\"\n  return \"\".join(random.choice(valid_chars) for i in range(length))", "code_tokens": "def GeneratePassphrase ( length = 20 ) : valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" valid_chars += \"0123456789 ,-_&$#\" return \"\" . join ( random . choice ( valid_chars ) for i in range ( length ) )", "docstring_tokens": "Create a 20 char passphrase with easily typeable chars .", "label": 0}, {"idx": "cosqa-train-3144", "doc": "python print full precision", "code": "def pprint(obj, verbose=False, max_width=79, newline='\\n'):\n    \"\"\"\n    Like `pretty` but print to stdout.\n    \"\"\"\n    printer = RepresentationPrinter(sys.stdout, verbose, max_width, newline)\n    printer.pretty(obj)\n    printer.flush()\n    sys.stdout.write(newline)\n    sys.stdout.flush()", "code_tokens": "def pprint ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )", "docstring_tokens": "Like pretty but print to stdout .", "label": 0}, {"idx": "cosqa-train-3145", "doc": "how to generate sublist with equal length python", "code": "def batch(items, size):\n    \"\"\"Batches a list into a list of lists, with sub-lists sized by a specified\n    batch size.\"\"\"\n    return [items[x:x + size] for x in xrange(0, len(items), size)]", "code_tokens": "def batch ( items , size ) : return [ items [ x : x + size ] for x in xrange ( 0 , len ( items ) , size ) ]", "docstring_tokens": "Batches a list into a list of lists with sub - lists sized by a specified batch size .", "label": 0}, {"idx": "cosqa-train-3146", "doc": "python print how long a function runs for", "code": "def timeit(output):\n    \"\"\"\n    If output is string, then print the string and also time used\n    \"\"\"\n    b = time.time()\n    yield\n    print output, 'time used: %.3fs' % (time.time()-b)", "code_tokens": "def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )", "docstring_tokens": "If output is string then print the string and also time used", "label": 0}, {"idx": "cosqa-train-3147", "doc": "how to generate test case report in python unittest", "code": "def pytest_runtest_logreport(self, report):\n        \"\"\"Store all test reports for evaluation on finish\"\"\"\n        rep = report\n        res = self.config.hook.pytest_report_teststatus(report=rep)\n        cat, letter, word = res\n        self.stats.setdefault(cat, []).append(rep)", "code_tokens": "def pytest_runtest_logreport ( self , report ) : rep = report res = self . config . hook . pytest_report_teststatus ( report = rep ) cat , letter , word = res self . stats . setdefault ( cat , [ ] ) . append ( rep )", "docstring_tokens": "Store all test reports for evaluation on finish", "label": 0}, {"idx": "cosqa-train-3148", "doc": "python print json tree", "code": "def prettyprint(d):\n        \"\"\"Print dicttree in Json-like format. keys are sorted\n        \"\"\"\n        print(json.dumps(d, sort_keys=True, \n                         indent=4, separators=(\",\" , \": \")))", "code_tokens": "def prettyprint ( d ) : print ( json . dumps ( d , sort_keys = True , indent = 4 , separators = ( \",\" , \": \" ) ) )", "docstring_tokens": "Print dicttree in Json - like format . keys are sorted", "label": 0}, {"idx": "cosqa-train-3149", "doc": "how to generate yaml files in python", "code": "def generate_write_yaml_to_file(file_name):\n    \"\"\" generate a method to write the configuration in yaml to the method desired \"\"\"\n    def write_yaml(config):\n        with open(file_name, 'w+') as fh:\n            fh.write(yaml.dump(config))\n    return write_yaml", "code_tokens": "def generate_write_yaml_to_file ( file_name ) : def write_yaml ( config ) : with open ( file_name , 'w+' ) as fh : fh . write ( yaml . dump ( config ) ) return write_yaml", "docstring_tokens": "generate a method to write the configuration in yaml to the method desired", "label": 1}, {"idx": "cosqa-train-3150", "doc": "python print multiple dictionaries in order", "code": "def printdict(adict):\n    \"\"\"printdict\"\"\"\n    dlist = list(adict.keys())\n    dlist.sort()\n    for i in range(0, len(dlist)):\n        print(dlist[i], adict[dlist[i]])", "code_tokens": "def printdict ( adict ) : dlist = list ( adict . keys ( ) ) dlist . sort ( ) for i in range ( 0 , len ( dlist ) ) : print ( dlist [ i ] , adict [ dlist [ i ] ] )", "docstring_tokens": "printdict", "label": 0}, {"idx": "cosqa-train-3151", "doc": "how to get 2 last row of a list in python", "code": "def get_last_row(dbconn, tablename, n=1, uuid=None):\n    \"\"\"\n    Returns the last `n` rows in the table\n    \"\"\"\n    return fetch(dbconn, tablename, n, uuid, end=True)", "code_tokens": "def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )", "docstring_tokens": "Returns the last n rows in the table", "label": 1}, {"idx": "cosqa-train-3152", "doc": "python print on last pass only", "code": "def show_progress(self):\n        \"\"\"If we are in a progress scope, and no log messages have been\n        shown, write out another '.'\"\"\"\n        if self.in_progress_hanging:\n            sys.stdout.write('.')\n            sys.stdout.flush()", "code_tokens": "def show_progress ( self ) : if self . in_progress_hanging : sys . stdout . write ( '.' ) sys . stdout . flush ( )", "docstring_tokens": "If we are in a progress scope and no log messages have been shown write out another .", "label": 0}, {"idx": "cosqa-train-3153", "doc": "how to get area of a triangle python", "code": "def get_tri_area(pts):\n    \"\"\"\n    Given a list of coords for 3 points,\n    Compute the area of this triangle.\n\n    Args:\n        pts: [a, b, c] three points\n    \"\"\"\n    a, b, c = pts[0], pts[1], pts[2]\n    v1 = np.array(b) - np.array(a)\n    v2 = np.array(c) - np.array(a)\n    area_tri = abs(sp.linalg.norm(sp.cross(v1, v2)) / 2)\n    return area_tri", "code_tokens": "def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri", "docstring_tokens": "Given a list of coords for 3 points Compute the area of this triangle .", "label": 0}, {"idx": "cosqa-train-3154", "doc": "python print output to a printer", "code": "def pprint(o, stream=None, indent=1, width=80, depth=None):\n    \"\"\"Pretty-print a Python o to a stream [default is sys.stdout].\"\"\"\n    printer = PrettyPrinter(\n        stream=stream, indent=indent, width=width, depth=depth)\n    printer.pprint(o)", "code_tokens": "def pprint ( o , stream = None , indent = 1 , width = 80 , depth = None ) : printer = PrettyPrinter ( stream = stream , indent = indent , width = width , depth = depth ) printer . pprint ( o )", "docstring_tokens": "Pretty - print a Python o to a stream [ default is sys . stdout ] .", "label": 0}, {"idx": "cosqa-train-3155", "doc": "how to get both return code and output executed by the code from subprocess in python", "code": "def call_out(command):\n  \"\"\"\n  Run the given command (with shell=False) and return a tuple of\n  (int returncode, str output). Strip the output of enclosing whitespace.\n  \"\"\"\n  # start external command process\n  p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n  # get outputs\n  out, _ = p.communicate()\n\n  return p.returncode, out.strip()", "code_tokens": "def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "docstring_tokens": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace .", "label": 0}, {"idx": "cosqa-train-3156", "doc": "python print sqlite3 table column names", "code": "def get_table_columns(dbconn, tablename):\n    \"\"\"\n    Return a list of tuples specifying the column name and type\n    \"\"\"\n    cur = dbconn.cursor()\n    cur.execute(\"PRAGMA table_info('%s');\" % tablename)\n    info = cur.fetchall()\n    cols = [(i[1], i[2]) for i in info]\n    return cols", "code_tokens": "def get_table_columns ( dbconn , tablename ) : cur = dbconn . cursor ( ) cur . execute ( \"PRAGMA table_info('%s');\" % tablename ) info = cur . fetchall ( ) cols = [ ( i [ 1 ] , i [ 2 ] ) for i in info ] return cols", "docstring_tokens": "Return a list of tuples specifying the column name and type", "label": 0}, {"idx": "cosqa-train-3157", "doc": "how to get child proccesses to run differently python", "code": "def get(cls):\n    \"\"\"Subsystems used outside of any task.\"\"\"\n    return {\n      SourceRootConfig,\n      Reporting,\n      Reproducer,\n      RunTracker,\n      Changed,\n      BinaryUtil.Factory,\n      Subprocess.Factory\n    }", "code_tokens": "def get ( cls ) : return { SourceRootConfig , Reporting , Reproducer , RunTracker , Changed , BinaryUtil . Factory , Subprocess . Factory }", "docstring_tokens": "Subsystems used outside of any task .", "label": 1}, {"idx": "cosqa-train-3158", "doc": "python print stdout imeddiatly", "code": "def _stdout_raw(self, s):\n        \"\"\"Writes the string to stdout\"\"\"\n        print(s, end='', file=sys.stdout)\n        sys.stdout.flush()", "code_tokens": "def _stdout_raw ( self , s ) : print ( s , end = '' , file = sys . stdout ) sys . stdout . flush ( )", "docstring_tokens": "Writes the string to stdout", "label": 0}, {"idx": "cosqa-train-3159", "doc": "how to get datetime now in python utc", "code": "def now(self):\n\t\t\"\"\"\n\t\tReturn a :py:class:`datetime.datetime` instance representing the current time.\n\n\t\t:rtype: :py:class:`datetime.datetime`\n\t\t\"\"\"\n\t\tif self.use_utc:\n\t\t\treturn datetime.datetime.utcnow()\n\t\telse:\n\t\t\treturn datetime.datetime.now()", "code_tokens": "def now ( self ) : if self . use_utc : return datetime . datetime . utcnow ( ) else : return datetime . datetime . now ( )", "docstring_tokens": "Return a : py : class : datetime . datetime instance representing the current time .", "label": 0}, {"idx": "cosqa-train-3160", "doc": "python print string to varaible", "code": "def ss(*args, **kwargs):\n    \"\"\"\n    exactly like s, but doesn't return variable names or file positions (useful for logging)\n\n    since -- 10-15-2015\n    return -- str\n    \"\"\"\n    if not args:\n        raise ValueError(\"you didn't pass any arguments to print out\")\n\n    with Reflect.context(args, **kwargs) as r:\n        instance = V_CLASS(r, stream, **kwargs)\n        return instance.value().strip()", "code_tokens": "def ss ( * args , * * kwargs ) : if not args : raise ValueError ( \"you didn't pass any arguments to print out\" ) with Reflect . context ( args , * * kwargs ) as r : instance = V_CLASS ( r , stream , * * kwargs ) return instance . value ( ) . strip ( )", "docstring_tokens": "exactly like s but doesn t return variable names or file positions ( useful for logging )", "label": 0}, {"idx": "cosqa-train-3161", "doc": "how to get dimenstionn of data frame python", "code": "def _shape(self, df):\n        \"\"\"\n        Calculate table chape considering index levels.\n        \"\"\"\n\n        row, col = df.shape\n        return row + df.columns.nlevels, col + df.index.nlevels", "code_tokens": "def _shape ( self , df ) : row , col = df . shape return row + df . columns . nlevels , col + df . index . nlevels", "docstring_tokens": "Calculate table chape considering index levels .", "label": 0}, {"idx": "cosqa-train-3162", "doc": "python print string with visible ansi codes", "code": "def ansi(color, text):\n    \"\"\"Wrap text in an ansi escape sequence\"\"\"\n    code = COLOR_CODES[color]\n    return '\\033[1;{0}m{1}{2}'.format(code, text, RESET_TERM)", "code_tokens": "def ansi ( color , text ) : code = COLOR_CODES [ color ] return '\\033[1;{0}m{1}{2}' . format ( code , text , RESET_TERM )", "docstring_tokens": "Wrap text in an ansi escape sequence", "label": 1}, {"idx": "cosqa-train-3163", "doc": "how to get encoding type in python", "code": "def get_encoding(binary):\n    \"\"\"Return the encoding type.\"\"\"\n\n    try:\n        from chardet import detect\n    except ImportError:\n        LOGGER.error(\"Please install the 'chardet' module\")\n        sys.exit(1)\n\n    encoding = detect(binary).get('encoding')\n\n    return 'iso-8859-1' if encoding == 'CP949' else encoding", "code_tokens": "def get_encoding ( binary ) : try : from chardet import detect except ImportError : LOGGER . error ( \"Please install the 'chardet' module\" ) sys . exit ( 1 ) encoding = detect ( binary ) . get ( 'encoding' ) return 'iso-8859-1' if encoding == 'CP949' else encoding", "docstring_tokens": "Return the encoding type .", "label": 0}, {"idx": "cosqa-train-3164", "doc": "python print+formatting output width", "code": "def pprint(obj, verbose=False, max_width=79, newline='\\n'):\n    \"\"\"\n    Like `pretty` but print to stdout.\n    \"\"\"\n    printer = RepresentationPrinter(sys.stdout, verbose, max_width, newline)\n    printer.pretty(obj)\n    printer.flush()\n    sys.stdout.write(newline)\n    sys.stdout.flush()", "code_tokens": "def pprint ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )", "docstring_tokens": "Like pretty but print to stdout .", "label": 0}, {"idx": "cosqa-train-3165", "doc": "how to get environement variables and its name in python", "code": "def _get_os_environ_dict(keys):\n  \"\"\"Return a dictionary of key/values from os.environ.\"\"\"\n  return {k: os.environ.get(k, _UNDEFINED) for k in keys}", "code_tokens": "def _get_os_environ_dict ( keys ) : return { k : os . environ . get ( k , _UNDEFINED ) for k in keys }", "docstring_tokens": "Return a dictionary of key / values from os . environ .", "label": 0}, {"idx": "cosqa-train-3166", "doc": "python produce a string for json", "code": "def to_json(data):\n    \"\"\"Return data as a JSON string.\"\"\"\n    return json.dumps(data, default=lambda x: x.__dict__, sort_keys=True, indent=4)", "code_tokens": "def to_json ( data ) : return json . dumps ( data , default = lambda x : x . __dict__ , sort_keys = True , indent = 4 )", "docstring_tokens": "Return data as a JSON string .", "label": 0}, {"idx": "cosqa-train-3167", "doc": "how to get field in css in python", "code": "def getfield(f):\n    \"\"\"convert values from cgi.Field objects to plain values.\"\"\"\n    if isinstance(f, list):\n        return [getfield(x) for x in f]\n    else:\n        return f.value", "code_tokens": "def getfield ( f ) : if isinstance ( f , list ) : return [ getfield ( x ) for x in f ] else : return f . value", "docstring_tokens": "convert values from cgi . Field objects to plain values .", "label": 0}, {"idx": "cosqa-train-3168", "doc": "python program dividng seconds into hours minutes and seconds", "code": "def time_string(seconds):\n    \"\"\"Returns time in seconds as a string formatted HHHH:MM:SS.\"\"\"\n    s = int(round(seconds))  # round to nearest second\n    h, s = divmod(s, 3600)  # get hours and remainder\n    m, s = divmod(s, 60)  # split remainder into minutes and seconds\n    return \"%2i:%02i:%02i\" % (h, m, s)", "code_tokens": "def time_string ( seconds ) : s = int ( round ( seconds ) ) # round to nearest second h , s = divmod ( s , 3600 ) # get hours and remainder m , s = divmod ( s , 60 ) # split remainder into minutes and seconds return \"%2i:%02i:%02i\" % ( h , m , s )", "docstring_tokens": "Returns time in seconds as a string formatted HHHH : MM : SS .", "label": 0}, {"idx": "cosqa-train-3169", "doc": "how to get fields of object in python", "code": "def fields(self):\n        \"\"\"Returns the list of field names of the model.\"\"\"\n        return (self.attributes.values() + self.lists.values()\n                + self.references.values())", "code_tokens": "def fields ( self ) : return ( self . attributes . values ( ) + self . lists . values ( ) + self . references . values ( ) )", "docstring_tokens": "Returns the list of field names of the model .", "label": 0}, {"idx": "cosqa-train-3170", "doc": "python prompt input hide", "code": "def _normal_prompt(self):\n        \"\"\"\n        Flushes the prompt before requesting the input\n\n        :return: The command line\n        \"\"\"\n        sys.stdout.write(self.__get_ps1())\n        sys.stdout.flush()\n        return safe_input()", "code_tokens": "def _normal_prompt ( self ) : sys . stdout . write ( self . __get_ps1 ( ) ) sys . stdout . flush ( ) return safe_input ( )", "docstring_tokens": "Flushes the prompt before requesting the input", "label": 0}, {"idx": "cosqa-train-3171", "doc": "how to get index of a line in python", "code": "def translate_index_to_position(self, index):\n        \"\"\"\n        Given an index for the text, return the corresponding (row, col) tuple.\n        (0-based. Returns (0, 0) for index=0.)\n        \"\"\"\n        # Find start of this line.\n        row, row_index = self._find_line_start_index(index)\n        col = index - row_index\n\n        return row, col", "code_tokens": "def translate_index_to_position ( self , index ) : # Find start of this line. row , row_index = self . _find_line_start_index ( index ) col = index - row_index return row , col", "docstring_tokens": "Given an index for the text return the corresponding ( row col ) tuple . ( 0 - based . Returns ( 0 0 ) for index = 0 . )", "label": 0}, {"idx": "cosqa-train-3172", "doc": "python property with only a setter", "code": "def _set_property(self, val, *args):\n        \"\"\"Private method that sets the value currently of the property\"\"\"\n        val = UserClassAdapter._set_property(self, val, *args)\n        if val:\n            Adapter._set_property(self, val, *args)\n        return val", "code_tokens": "def _set_property ( self , val , * args ) : val = UserClassAdapter . _set_property ( self , val , * args ) if val : Adapter . _set_property ( self , val , * args ) return val", "docstring_tokens": "Private method that sets the value currently of the property", "label": 0}, {"idx": "cosqa-train-3173", "doc": "how to get index or poition of an array input python", "code": "def get_inputs_from_cm(index, cm):\n    \"\"\"Return indices of inputs to the node with the given index.\"\"\"\n    return tuple(i for i in range(cm.shape[0]) if cm[i][index])", "code_tokens": "def get_inputs_from_cm ( index , cm ) : return tuple ( i for i in range ( cm . shape [ 0 ] ) if cm [ i ] [ index ] )", "docstring_tokens": "Return indices of inputs to the node with the given index .", "label": 0}, {"idx": "cosqa-train-3174", "doc": "python protobuf functions delimited", "code": "def metadata(self):\n        \"\"\"google.protobuf.Message: the current operation metadata.\"\"\"\n        if not self._operation.HasField(\"metadata\"):\n            return None\n\n        return protobuf_helpers.from_any_pb(\n            self._metadata_type, self._operation.metadata\n        )", "code_tokens": "def metadata ( self ) : if not self . _operation . HasField ( \"metadata\" ) : return None return protobuf_helpers . from_any_pb ( self . _metadata_type , self . _operation . metadata )", "docstring_tokens": "google . protobuf . Message : the current operation metadata .", "label": 0}, {"idx": "cosqa-train-3175", "doc": "how to get input of ordered dictionary in python", "code": "def format_result(input):\n        \"\"\"From: http://stackoverflow.com/questions/13062300/convert-a-dict-to-sorted-dict-in-python\n        \"\"\"\n        items = list(iteritems(input))\n        return OrderedDict(sorted(items, key=lambda x: x[0]))", "code_tokens": "def format_result ( input ) : items = list ( iteritems ( input ) ) return OrderedDict ( sorted ( items , key = lambda x : x [ 0 ] ) )", "docstring_tokens": "From : http : // stackoverflow . com / questions / 13062300 / convert - a - dict - to - sorted - dict - in - python", "label": 0}, {"idx": "cosqa-train-3176", "doc": "python psutil windows suspend", "code": "def stop(pid):\n    \"\"\"Shut down a specific process.\n\n    Args:\n      pid: the pid of the process to shutdown.\n    \"\"\"\n    if psutil.pid_exists(pid):\n      try:\n        p = psutil.Process(pid)\n        p.kill()\n      except Exception:\n        pass", "code_tokens": "def stop ( pid ) : if psutil . pid_exists ( pid ) : try : p = psutil . Process ( pid ) p . kill ( ) except Exception : pass", "docstring_tokens": "Shut down a specific process .", "label": 0}, {"idx": "cosqa-train-3177", "doc": "how to get list of python dictionary values only", "code": "def get_all_items(obj):\n    \"\"\"\n    dict.items() but with a separate row for each value in a MultiValueDict\n    \"\"\"\n    if hasattr(obj, 'getlist'):\n        items = []\n        for key in obj:\n            for value in obj.getlist(key):\n                items.append((key, value))\n        return items\n    else:\n        return obj.items()", "code_tokens": "def get_all_items ( obj ) : if hasattr ( obj , 'getlist' ) : items = [ ] for key in obj : for value in obj . getlist ( key ) : items . append ( ( key , value ) ) return items else : return obj . items ( )", "docstring_tokens": "dict . items () but with a separate row for each value in a MultiValueDict", "label": 0}, {"idx": "cosqa-train-3178", "doc": "python pull large json from url and put into file", "code": "def download_json(local_filename, url, clobber=False):\n    \"\"\"Download the given JSON file, and pretty-print before we output it.\"\"\"\n    with open(local_filename, 'w') as json_file:\n        json_file.write(json.dumps(requests.get(url).json(), sort_keys=True, indent=2, separators=(',', ': ')))", "code_tokens": "def download_json ( local_filename , url , clobber = False ) : with open ( local_filename , 'w' ) as json_file : json_file . write ( json . dumps ( requests . get ( url ) . json ( ) , sort_keys = True , indent = 2 , separators = ( ',' , ': ' ) ) )", "docstring_tokens": "Download the given JSON file and pretty - print before we output it .", "label": 0}, {"idx": "cosqa-train-3179", "doc": "how to get number of objects in document in python", "code": "def get_size(objects):\n    \"\"\"Compute the total size of all elements in objects.\"\"\"\n    res = 0\n    for o in objects:\n        try:\n            res += _getsizeof(o)\n        except AttributeError:\n            print(\"IGNORING: type=%s; o=%s\" % (str(type(o)), str(o)))\n    return res", "code_tokens": "def get_size ( objects ) : res = 0 for o in objects : try : res += _getsizeof ( o ) except AttributeError : print ( \"IGNORING: type=%s; o=%s\" % ( str ( type ( o ) ) , str ( o ) ) ) return res", "docstring_tokens": "Compute the total size of all elements in objects .", "label": 1}, {"idx": "cosqa-train-3180", "doc": "python pygla transparent background color", "code": "def get_translucent_cmap(r, g, b):\n\n    class TranslucentCmap(BaseColormap):\n        glsl_map = \"\"\"\n        vec4 translucent_fire(float t) {{\n            return vec4({0}, {1}, {2}, t);\n        }}\n        \"\"\".format(r, g, b)\n\n    return TranslucentCmap()", "code_tokens": "def get_translucent_cmap ( r , g , b ) : class TranslucentCmap ( BaseColormap ) : glsl_map = \"\"\"\n        vec4 translucent_fire(float t) {{\n            return vec4({0}, {1}, {2}, t);\n        }}\n        \"\"\" . format ( r , g , b ) return TranslucentCmap ( )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-3181", "doc": "how to get object name in python blender", "code": "def get_qualified_name(_object):\n    \"\"\"Return the Fully Qualified Name from an instance or class.\"\"\"\n    module = _object.__module__\n    if hasattr(_object, '__name__'):\n        _class = _object.__name__\n\n    else:\n        _class = _object.__class__.__name__\n\n    return module + '.' + _class", "code_tokens": "def get_qualified_name ( _object ) : module = _object . __module__ if hasattr ( _object , '__name__' ) : _class = _object . __name__ else : _class = _object . __class__ . __name__ return module + '.' + _class", "docstring_tokens": "Return the Fully Qualified Name from an instance or class .", "label": 0}, {"idx": "cosqa-train-3182", "doc": "python pymssql database how to set transaction", "code": "def execute(self, sql, params=None):\n        \"\"\"Just a pointer to engine.execute\n        \"\"\"\n        # wrap in a transaction to ensure things are committed\n        # https://github.com/smnorris/pgdata/issues/3\n        with self.engine.begin() as conn:\n            result = conn.execute(sql, params)\n        return result", "code_tokens": "def execute ( self , sql , params = None ) : # wrap in a transaction to ensure things are committed # https://github.com/smnorris/pgdata/issues/3 with self . engine . begin ( ) as conn : result = conn . execute ( sql , params ) return result", "docstring_tokens": "Just a pointer to engine . execute", "label": 0}, {"idx": "cosqa-train-3183", "doc": "how to get object name in python rather than long code", "code": "def get_qualified_name(_object):\n    \"\"\"Return the Fully Qualified Name from an instance or class.\"\"\"\n    module = _object.__module__\n    if hasattr(_object, '__name__'):\n        _class = _object.__name__\n\n    else:\n        _class = _object.__class__.__name__\n\n    return module + '.' + _class", "code_tokens": "def get_qualified_name ( _object ) : module = _object . __module__ if hasattr ( _object , '__name__' ) : _class = _object . __name__ else : _class = _object . __class__ . __name__ return module + '.' + _class", "docstring_tokens": "Return the Fully Qualified Name from an instance or class .", "label": 0}, {"idx": "cosqa-train-3184", "doc": "python pyplot limit y axis range", "code": "def set_ylimits(self, row, column, min=None, max=None):\n        \"\"\"Set y-axis limits of a subplot.\n\n        :param row,column: specify the subplot.\n        :param min: minimal axis value\n        :param max: maximum axis value\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_ylimits(min, max)", "code_tokens": "def set_ylimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_ylimits ( min , max )", "docstring_tokens": "Set y - axis limits of a subplot .", "label": 1}, {"idx": "cosqa-train-3185", "doc": "how to get past ssl error python", "code": "def _shutdown_transport(self):\n        \"\"\"Unwrap a Python 2.6 SSL socket, so we can call shutdown()\"\"\"\n        if self.sock is not None:\n            try:\n                unwrap = self.sock.unwrap\n            except AttributeError:\n                return\n            try:\n                self.sock = unwrap()\n            except ValueError:\n                # Failure within SSL might mean unwrap exists but socket is not\n                # deemed wrapped\n                pass", "code_tokens": "def _shutdown_transport ( self ) : if self . sock is not None : try : unwrap = self . sock . unwrap except AttributeError : return try : self . sock = unwrap ( ) except ValueError : # Failure within SSL might mean unwrap exists but socket is not # deemed wrapped pass", "docstring_tokens": "Unwrap a Python 2 . 6 SSL socket so we can call shutdown ()", "label": 1}, {"idx": "cosqa-train-3186", "doc": "python pytest single file", "code": "def run_tests(self):\n\t\t\"\"\"\n\t\tInvoke pytest, replacing argv. Return result code.\n\t\t\"\"\"\n\t\twith _save_argv(_sys.argv[:1] + self.addopts):\n\t\t\tresult_code = __import__('pytest').main()\n\t\t\tif result_code:\n\t\t\t\traise SystemExit(result_code)", "code_tokens": "def run_tests ( self ) : with _save_argv ( _sys . argv [ : 1 ] + self . addopts ) : result_code = __import__ ( 'pytest' ) . main ( ) if result_code : raise SystemExit ( result_code )", "docstring_tokens": "Invoke pytest replacing argv . Return result code .", "label": 0}, {"idx": "cosqa-train-3187", "doc": "how to get python to iterate over files in a folder", "code": "def each_img(dir_path):\n    \"\"\"\n    Iterates through each image in the given directory. (not recursive)\n    :param dir_path: Directory path where images files are present\n    :return: Iterator to iterate through image files\n    \"\"\"\n    for fname in os.listdir(dir_path):\n        if fname.endswith('.jpg') or fname.endswith('.png') or fname.endswith('.bmp'):\n            yield fname", "code_tokens": "def each_img ( dir_path ) : for fname in os . listdir ( dir_path ) : if fname . endswith ( '.jpg' ) or fname . endswith ( '.png' ) or fname . endswith ( '.bmp' ) : yield fname", "docstring_tokens": "Iterates through each image in the given directory . ( not recursive ) : param dir_path : Directory path where images files are present : return : Iterator to iterate through image files", "label": 0}, {"idx": "cosqa-train-3188", "doc": "python pytz timezone api", "code": "def now(timezone=None):\n    \"\"\"\n    Return a naive datetime object for the given ``timezone``. A ``timezone``\n    is any pytz- like or datetime.tzinfo-like timezone object. If no timezone\n    is given, then UTC is assumed.\n\n    This method is best used with pytz installed::\n\n        pip install pytz\n    \"\"\"\n    d = datetime.datetime.utcnow()\n    if not timezone:\n        return d\n\n    return to_timezone(d, timezone).replace(tzinfo=None)", "code_tokens": "def now ( timezone = None ) : d = datetime . datetime . utcnow ( ) if not timezone : return d return to_timezone ( d , timezone ) . replace ( tzinfo = None )", "docstring_tokens": "Return a naive datetime object for the given timezone . A timezone is any pytz - like or datetime . tzinfo - like timezone object . If no timezone is given then UTC is assumed .", "label": 0}, {"idx": "cosqa-train-3189", "doc": "how to get rid of an axis in python", "code": "def clean_axis(axis):\n    \"\"\"Remove ticks, tick labels, and frame from axis\"\"\"\n    axis.get_xaxis().set_ticks([])\n    axis.get_yaxis().set_ticks([])\n    for spine in list(axis.spines.values()):\n        spine.set_visible(False)", "code_tokens": "def clean_axis ( axis ) : axis . get_xaxis ( ) . set_ticks ( [ ] ) axis . get_yaxis ( ) . set_ticks ( [ ] ) for spine in list ( axis . spines . values ( ) ) : spine . set_visible ( False )", "docstring_tokens": "Remove ticks tick labels and frame from axis", "label": 0}, {"idx": "cosqa-train-3190", "doc": "python queue get but not remove", "code": "def get(self):\n        \"\"\"Get the highest priority Processing Block from the queue.\"\"\"\n        with self._mutex:\n            entry = self._queue.pop()\n            del self._block_map[entry[2]]\n            return entry[2]", "code_tokens": "def get ( self ) : with self . _mutex : entry = self . _queue . pop ( ) del self . _block_map [ entry [ 2 ] ] return entry [ 2 ]", "docstring_tokens": "Get the highest priority Processing Block from the queue .", "label": 0}, {"idx": "cosqa-train-3191", "doc": "how to get rid of spaces in python comma string", "code": "def seq_to_str(obj, sep=\",\"):\n    \"\"\"\n    Given a sequence convert it to a comma separated string.\n    If, however, the argument is a single object, return its string\n    representation.\n    \"\"\"\n    if isinstance(obj, string_classes):\n        return obj\n    elif isinstance(obj, (list, tuple)):\n        return sep.join([str(x) for x in obj])\n    else:\n        return str(obj)", "code_tokens": "def seq_to_str ( obj , sep = \",\" ) : if isinstance ( obj , string_classes ) : return obj elif isinstance ( obj , ( list , tuple ) ) : return sep . join ( [ str ( x ) for x in obj ] ) else : return str ( obj )", "docstring_tokens": "Given a sequence convert it to a comma separated string . If however the argument is a single object return its string representation .", "label": 0}, {"idx": "cosqa-train-3192", "doc": "python queue get delete", "code": "async def delete(self):\n        \"\"\"\n        Delete task (in any state) permanently.\n\n        Returns `True` is task is deleted.\n        \"\"\"\n        the_tuple = await self.queue.delete(self.tube, self.task_id)\n\n        self.update_from_tuple(the_tuple)\n\n        return bool(self.state == DONE)", "code_tokens": "async def delete ( self ) : the_tuple = await self . queue . delete ( self . tube , self . task_id ) self . update_from_tuple ( the_tuple ) return bool ( self . state == DONE )", "docstring_tokens": "Delete task ( in any state ) permanently .", "label": 1}, {"idx": "cosqa-train-3193", "doc": "how to get rid of the endline of a string python", "code": "def get_line_ending(line):\n    \"\"\"Return line ending.\"\"\"\n    non_whitespace_index = len(line.rstrip()) - len(line)\n    if not non_whitespace_index:\n        return ''\n    else:\n        return line[non_whitespace_index:]", "code_tokens": "def get_line_ending ( line ) : non_whitespace_index = len ( line . rstrip ( ) ) - len ( line ) if not non_whitespace_index : return '' else : return line [ non_whitespace_index : ]", "docstring_tokens": "Return line ending .", "label": 0}, {"idx": "cosqa-train-3194", "doc": "python random string of n length", "code": "def rndstr(size=16):\n    \"\"\"\n    Returns a string of random ascii characters or digits\n\n    :param size: The length of the string\n    :return: string\n    \"\"\"\n    _basech = string.ascii_letters + string.digits\n    return \"\".join([rnd.choice(_basech) for _ in range(size)])", "code_tokens": "def rndstr ( size = 16 ) : _basech = string . ascii_letters + string . digits return \"\" . join ( [ rnd . choice ( _basech ) for _ in range ( size ) ] )", "docstring_tokens": "Returns a string of random ascii characters or digits", "label": 0}, {"idx": "cosqa-train-3195", "doc": "how to get start of an offset in python", "code": "def column(self):\n        \"\"\"\n        Returns a zero-based column number of the beginning of this range.\n        \"\"\"\n        line, column = self.source_buffer.decompose_position(self.begin_pos)\n        return column", "code_tokens": "def column ( self ) : line , column = self . source_buffer . decompose_position ( self . begin_pos ) return column", "docstring_tokens": "Returns a zero - based column number of the beginning of this range .", "label": 1}, {"idx": "cosqa-train-3196", "doc": "python range function choose intervals", "code": "def min_values(args):\n    \"\"\" Return possible range for min function. \"\"\"\n    return Interval(min(x.low for x in args), min(x.high for x in args))", "code_tokens": "def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )", "docstring_tokens": "Return possible range for min function .", "label": 0}, {"idx": "cosqa-train-3197", "doc": "how to get subset of attributes from python object", "code": "def get_object_attrs(obj):\n    \"\"\"\n    Get the attributes of an object using dir.\n\n    This filters protected attributes\n    \"\"\"\n    attrs = [k for k in dir(obj) if not k.startswith('__')]\n    if not attrs:\n        attrs = dir(obj)\n    return attrs", "code_tokens": "def get_object_attrs ( obj ) : attrs = [ k for k in dir ( obj ) if not k . startswith ( '__' ) ] if not attrs : attrs = dir ( obj ) return attrs", "docstring_tokens": "Get the attributes of an object using dir .", "label": 0}, {"idx": "cosqa-train-3198", "doc": "python rank according to key", "code": "def zrank(self, name, value):\n        \"\"\"\n        Returns the rank of the element.\n\n        :param name: str     the name of the redis key\n        :param value: the element in the sorted set\n        \"\"\"\n        with self.pipe as pipe:\n            value = self.valueparse.encode(value)\n            return pipe.zrank(self.redis_key(name), value)", "code_tokens": "def zrank ( self , name , value ) : with self . pipe as pipe : value = self . valueparse . encode ( value ) return pipe . zrank ( self . redis_key ( name ) , value )", "docstring_tokens": "Returns the rank of the element .", "label": 0}, {"idx": "cosqa-train-3199", "doc": "how to get the directory of the file inpython", "code": "def data_directory():\n    \"\"\"Return the absolute path to the directory containing the package data.\"\"\"\n    package_directory = os.path.abspath(os.path.dirname(__file__))\n    return os.path.join(package_directory, \"data\")", "code_tokens": "def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , \"data\" )", "docstring_tokens": "Return the absolute path to the directory containing the package data .", "label": 0}, {"idx": "cosqa-train-3200", "doc": "python read bytes till file end", "code": "def _readuntil(f, end=_TYPE_END):\n\t\"\"\"Helper function to read bytes until a certain end byte is hit\"\"\"\n\tbuf = bytearray()\n\tbyte = f.read(1)\n\twhile byte != end:\n\t\tif byte == b'':\n\t\t\traise ValueError('File ended unexpectedly. Expected end byte {}.'.format(end))\n\t\tbuf += byte\n\t\tbyte = f.read(1)\n\treturn buf", "code_tokens": "def _readuntil ( f , end = _TYPE_END ) : buf = bytearray ( ) byte = f . read ( 1 ) while byte != end : if byte == b'' : raise ValueError ( 'File ended unexpectedly. Expected end byte {}.' . format ( end ) ) buf += byte byte = f . read ( 1 ) return buf", "docstring_tokens": "Helper function to read bytes until a certain end byte is hit", "label": 0}, {"idx": "cosqa-train-3201", "doc": "how to get the highest observation within the group by function in python", "code": "def view_extreme_groups(token, dstore):\n    \"\"\"\n    Show the source groups contributing the most to the highest IML\n    \"\"\"\n    data = dstore['disagg_by_grp'].value\n    data.sort(order='extreme_poe')\n    return rst_table(data[::-1])", "code_tokens": "def view_extreme_groups ( token , dstore ) : data = dstore [ 'disagg_by_grp' ] . value data . sort ( order = 'extreme_poe' ) return rst_table ( data [ : : - 1 ] )", "docstring_tokens": "Show the source groups contributing the most to the highest IML", "label": 0}, {"idx": "cosqa-train-3202", "doc": "python read file in wondows absolute path", "code": "def get_file_string(filepath):\n    \"\"\"Get string from file.\"\"\"\n    with open(os.path.abspath(filepath)) as f:\n        return f.read()", "code_tokens": "def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )", "docstring_tokens": "Get string from file .", "label": 0}, {"idx": "cosqa-train-3203", "doc": "how to get the integer value for a string in python", "code": "def str2int(string_with_int):\n    \"\"\" Collect digits from a string \"\"\"\n    return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)", "code_tokens": "def str2int ( string_with_int ) : return int ( \"\" . join ( [ char for char in string_with_int if char in string . digits ] ) or 0 )", "docstring_tokens": "Collect digits from a string", "label": 0}, {"idx": "cosqa-train-3204", "doc": "python read file specified content", "code": "def read(fname):\n    \"\"\"Quick way to read a file content.\"\"\"\n    content = None\n    with open(os.path.join(here, fname)) as f:\n        content = f.read()\n    return content", "code_tokens": "def read ( fname ) : content = None with open ( os . path . join ( here , fname ) ) as f : content = f . read ( ) return content", "docstring_tokens": "Quick way to read a file content .", "label": 0}, {"idx": "cosqa-train-3205", "doc": "how to get the location of an list object in python", "code": "def get_list_index(lst, index_or_name):\n    \"\"\"\n    Return the index of an element in the list.\n\n    Args:\n        lst (list): The list.\n        index_or_name (int or str): The value of the reference element, or directly its numeric index.\n\n    Returns:\n        (int) The index of the element in the list.\n    \"\"\"\n    if isinstance(index_or_name, six.integer_types):\n        return index_or_name\n\n    return lst.index(index_or_name)", "code_tokens": "def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )", "docstring_tokens": "Return the index of an element in the list .", "label": 0}, {"idx": "cosqa-train-3206", "doc": "python read file with encoding", "code": "def read_string_from_file(path, encoding=\"utf8\"):\n  \"\"\"\n  Read entire contents of file into a string.\n  \"\"\"\n  with codecs.open(path, \"rb\", encoding=encoding) as f:\n    value = f.read()\n  return value", "code_tokens": "def read_string_from_file ( path , encoding = \"utf8\" ) : with codecs . open ( path , \"rb\" , encoding = encoding ) as f : value = f . read ( ) return value", "docstring_tokens": "Read entire contents of file into a string .", "label": 0}, {"idx": "cosqa-train-3207", "doc": "how to get the root of the treeview if click onchild treeview tkinter python", "code": "def OnRootView(self, event):\n        \"\"\"Reset view to the root of the tree\"\"\"\n        self.adapter, tree, rows = self.RootNode()\n        self.squareMap.SetModel(tree, self.adapter)\n        self.RecordHistory()\n        self.ConfigureViewTypeChoices()", "code_tokens": "def OnRootView ( self , event ) : self . adapter , tree , rows = self . RootNode ( ) self . squareMap . SetModel ( tree , self . adapter ) self . RecordHistory ( ) self . ConfigureViewTypeChoices ( )", "docstring_tokens": "Reset view to the root of the tree", "label": 0}, {"idx": "cosqa-train-3208", "doc": "python read folder of text file into array", "code": "def read_folder(directory):\n    \"\"\"read text files in directory and returns them as array\n\n    Args:\n        directory: where the text files are\n\n    Returns:\n        Array of text\n    \"\"\"\n    res = []\n    for filename in os.listdir(directory):\n        with io.open(os.path.join(directory, filename), encoding=\"utf-8\") as f:\n            content = f.read()\n            res.append(content)\n    return res", "code_tokens": "def read_folder ( directory ) : res = [ ] for filename in os . listdir ( directory ) : with io . open ( os . path . join ( directory , filename ) , encoding = \"utf-8\" ) as f : content = f . read ( ) res . append ( content ) return res", "docstring_tokens": "read text files in directory and returns them as array", "label": 0}, {"idx": "cosqa-train-3209", "doc": "how to get the size of a data type in python", "code": "def size(dtype):\n  \"\"\"Returns the number of bytes to represent this `dtype`.\"\"\"\n  dtype = tf.as_dtype(dtype)\n  if hasattr(dtype, 'size'):\n    return dtype.size\n  return np.dtype(dtype).itemsize", "code_tokens": "def size ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'size' ) : return dtype . size return np . dtype ( dtype ) . itemsize", "docstring_tokens": "Returns the number of bytes to represent this dtype .", "label": 0}, {"idx": "cosqa-train-3210", "doc": "python read from stdin forever", "code": "def _read_stdin():\n    \"\"\"\n    Generator for reading from standard input in nonblocking mode.\n\n    Other ways of reading from ``stdin`` in python waits, until the buffer is\n    big enough, or until EOF character is sent.\n\n    This functions yields immediately after each line.\n    \"\"\"\n    line = sys.stdin.readline()\n    while line:\n        yield line\n        line = sys.stdin.readline()", "code_tokens": "def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )", "docstring_tokens": "Generator for reading from standard input in nonblocking mode .", "label": 0}, {"idx": "cosqa-train-3211", "doc": "how to get the smallest item in a list in python", "code": "def find_lt(a, x):\n    \"\"\"Find rightmost value less than x\"\"\"\n    i = bisect.bisect_left(a, x)\n    if i:\n        return a[i-1]\n    raise ValueError", "code_tokens": "def find_lt ( a , x ) : i = bisect . bisect_left ( a , x ) if i : return a [ i - 1 ] raise ValueError", "docstring_tokens": "Find rightmost value less than x", "label": 0}, {"idx": "cosqa-train-3212", "doc": "python read from stdin immediately", "code": "def _read_stdin():\n    \"\"\"\n    Generator for reading from standard input in nonblocking mode.\n\n    Other ways of reading from ``stdin`` in python waits, until the buffer is\n    big enough, or until EOF character is sent.\n\n    This functions yields immediately after each line.\n    \"\"\"\n    line = sys.stdin.readline()\n    while line:\n        yield line\n        line = sys.stdin.readline()", "code_tokens": "def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )", "docstring_tokens": "Generator for reading from standard input in nonblocking mode .", "label": 0}, {"idx": "cosqa-train-3213", "doc": "how to get the x labels to run vertically instead of horizontally in python matplotlib", "code": "def yticks(self):\n        \"\"\"Compute the yticks labels of this grid, used for plotting the y-axis ticks when visualizing a regular\"\"\"\n        return np.linspace(np.min(self[:, 0]), np.max(self[:, 0]), 4)", "code_tokens": "def yticks ( self ) : return np . linspace ( np . min ( self [ : , 0 ] ) , np . max ( self [ : , 0 ] ) , 4 )", "docstring_tokens": "Compute the yticks labels of this grid used for plotting the y - axis ticks when visualizing a regular", "label": 0}, {"idx": "cosqa-train-3214", "doc": "python read json from web page", "code": "def get_jsonparsed_data(url):\n    \"\"\"Receive the content of ``url``, parse it as JSON and return the\n       object.\n    \"\"\"\n    response = urlopen(url)\n    data = response.read().decode('utf-8')\n    return json.loads(data)", "code_tokens": "def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )", "docstring_tokens": "Receive the content of url parse it as JSON and return the object .", "label": 0}, {"idx": "cosqa-train-3215", "doc": "how to get unique constraints from a msssql table in python", "code": "def _model_unique(ins):\n    \"\"\" Get unique constraints info\n\n    :type ins: sqlalchemy.orm.mapper.Mapper\n    :rtype: list[tuple[str]]\n    \"\"\"\n    unique = []\n    for t in ins.tables:\n        for c in t.constraints:\n            if isinstance(c, UniqueConstraint):\n                unique.append(tuple(col.key for col in c.columns))\n    return unique", "code_tokens": "def _model_unique ( ins ) : unique = [ ] for t in ins . tables : for c in t . constraints : if isinstance ( c , UniqueConstraint ) : unique . append ( tuple ( col . key for col in c . columns ) ) return unique", "docstring_tokens": "Get unique constraints info", "label": 0}, {"idx": "cosqa-train-3216", "doc": "python read large binary file bytes yeild", "code": "def read_string(buff, byteorder='big'):\n    \"\"\"Read a string from a file-like object.\"\"\"\n    length = read_numeric(USHORT, buff, byteorder)\n    return buff.read(length).decode('utf-8')", "code_tokens": "def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )", "docstring_tokens": "Read a string from a file - like object .", "label": 0}, {"idx": "cosqa-train-3217", "doc": "how to get url params flask python", "code": "def get_url_args(url):\n    \"\"\" Returns a dictionary from a URL params \"\"\"\n    url_data = urllib.parse.urlparse(url)\n    arg_dict = urllib.parse.parse_qs(url_data.query)\n    return arg_dict", "code_tokens": "def get_url_args ( url ) : url_data = urllib . parse . urlparse ( url ) arg_dict = urllib . parse . parse_qs ( url_data . query ) return arg_dict", "docstring_tokens": "Returns a dictionary from a URL params", "label": 0}, {"idx": "cosqa-train-3218", "doc": "python read large tif into numpy array", "code": "def ReadTif(tifFile):\n        \"\"\"Reads a tif file to a 2D NumPy array\"\"\"\n        img = Image.open(tifFile)\n        img = np.array(img)\n        return img", "code_tokens": "def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img", "docstring_tokens": "Reads a tif file to a 2D NumPy array", "label": 0}, {"idx": "cosqa-train-3219", "doc": "how to give type annotation in defining a funciton in python", "code": "def return_type(type_name, formatter=None):\n    \"\"\"Specify that this function returns a typed value.\n\n    Args:\n        type_name (str): A type name known to the global typedargs type system\n        formatter (str): An optional name of a formatting function specified\n            for the type given in type_name.\n    \"\"\"\n\n    def _returns(func):\n        annotated(func)\n        func.metadata.typed_returnvalue(type_name, formatter)\n        return func\n\n    return _returns", "code_tokens": "def return_type ( type_name , formatter = None ) : def _returns ( func ) : annotated ( func ) func . metadata . typed_returnvalue ( type_name , formatter ) return func return _returns", "docstring_tokens": "Specify that this function returns a typed value .", "label": 1}, {"idx": "cosqa-train-3220", "doc": "python read list of tuples from file space separated", "code": "def readTuple(self, line, n=3):\n        \"\"\" Reads a tuple of numbers. e.g. vertices, normals or teture coords.\n        \"\"\"\n        numbers = [num for num in line.split(' ') if num]\n        return [float(num) for num in numbers[1:n + 1]]", "code_tokens": "def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]", "docstring_tokens": "Reads a tuple of numbers . e . g . vertices normals or teture coords .", "label": 0}, {"idx": "cosqa-train-3221", "doc": "python read protobuf pb file", "code": "def from_pb(cls, pb):\n        \"\"\"Instantiate the object from a protocol buffer.\n\n        Args:\n            pb (protobuf)\n\n        Save a reference to the protocol buffer on the object.\n        \"\"\"\n        obj = cls._from_pb(pb)\n        obj._pb = pb\n        return obj", "code_tokens": "def from_pb ( cls , pb ) : obj = cls . _from_pb ( pb ) obj . _pb = pb return obj", "docstring_tokens": "Instantiate the object from a protocol buffer .", "label": 0}, {"idx": "cosqa-train-3222", "doc": "how to grab each word in a line python", "code": "def extract_words(lines):\n    \"\"\"\n    Extract from the given iterable of lines the list of words.\n\n    :param lines: an iterable of lines;\n    :return: a generator of words of lines.\n    \"\"\"\n    for line in lines:\n        for word in re.findall(r\"\\w+\", line):\n            yield word", "code_tokens": "def extract_words ( lines ) : for line in lines : for word in re . findall ( r\"\\w+\" , line ) : yield word", "docstring_tokens": "Extract from the given iterable of lines the list of words .", "label": 1}, {"idx": "cosqa-train-3223", "doc": "python read tiff file to numpy array", "code": "def ReadTif(tifFile):\n        \"\"\"Reads a tif file to a 2D NumPy array\"\"\"\n        img = Image.open(tifFile)\n        img = np.array(img)\n        return img", "code_tokens": "def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img", "docstring_tokens": "Reads a tif file to a 2D NumPy array", "label": 1}, {"idx": "cosqa-train-3224", "doc": "how to have a function check for integers python", "code": "def _check_for_int(x):\n    \"\"\"\n    This is a compatibility function that takes a C{float} and converts it to an\n    C{int} if the values are equal.\n    \"\"\"\n    try:\n        y = int(x)\n    except (OverflowError, ValueError):\n        pass\n    else:\n        # There is no way in AMF0 to distinguish between integers and floats\n        if x == x and y == x:\n            return y\n\n    return x", "code_tokens": "def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x", "docstring_tokens": "This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal .", "label": 0}, {"idx": "cosqa-train-3225", "doc": "python reading in data ints as objects", "code": "def r_num(obj):\n    \"\"\"Read list of numbers.\"\"\"\n    if isinstance(obj, (list, tuple)):\n        it = iter\n    else:\n        it = LinesIterator\n    dataset = Dataset([Dataset.FLOAT])\n    return dataset.load(it(obj))", "code_tokens": "def r_num ( obj ) : if isinstance ( obj , ( list , tuple ) ) : it = iter else : it = LinesIterator dataset = Dataset ( [ Dataset . FLOAT ] ) return dataset . load ( it ( obj ) )", "docstring_tokens": "Read list of numbers .", "label": 0}, {"idx": "cosqa-train-3226", "doc": "how to identify the encoding of a line in python", "code": "def process_module(self, module):\n        \"\"\"inspect the source file to find encoding problem\"\"\"\n        if module.file_encoding:\n            encoding = module.file_encoding\n        else:\n            encoding = \"ascii\"\n\n        with module.stream() as stream:\n            for lineno, line in enumerate(stream):\n                self._check_encoding(lineno + 1, line, encoding)", "code_tokens": "def process_module ( self , module ) : if module . file_encoding : encoding = module . file_encoding else : encoding = \"ascii\" with module . stream ( ) as stream : for lineno , line in enumerate ( stream ) : self . _check_encoding ( lineno + 1 , line , encoding )", "docstring_tokens": "inspect the source file to find encoding problem", "label": 0}, {"idx": "cosqa-train-3227", "doc": "how to identify type of inpupt python", "code": "def is_builtin_type(tp):\n    \"\"\"Checks if the given type is a builtin one.\n    \"\"\"\n    return hasattr(__builtins__, tp.__name__) and tp is getattr(__builtins__, tp.__name__)", "code_tokens": "def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )", "docstring_tokens": "Checks if the given type is a builtin one .", "label": 0}, {"idx": "cosqa-train-3228", "doc": "python redirect stdout and stdin subprocess", "code": "def redirect_std():\n    \"\"\"\n    Connect stdin/stdout to controlling terminal even if the scripts input and output\n    were redirected. This is useful in utilities based on termenu.\n    \"\"\"\n    stdin = sys.stdin\n    stdout = sys.stdout\n    if not sys.stdin.isatty():\n        sys.stdin = open_raw(\"/dev/tty\", \"r\", 0)\n    if not sys.stdout.isatty():\n        sys.stdout = open_raw(\"/dev/tty\", \"w\", 0)\n\n    return stdin, stdout", "code_tokens": "def redirect_std ( ) : stdin = sys . stdin stdout = sys . stdout if not sys . stdin . isatty ( ) : sys . stdin = open_raw ( \"/dev/tty\" , \"r\" , 0 ) if not sys . stdout . isatty ( ) : sys . stdout = open_raw ( \"/dev/tty\" , \"w\" , 0 ) return stdin , stdout", "docstring_tokens": "Connect stdin / stdout to controlling terminal even if the scripts input and output were redirected . This is useful in utilities based on termenu .", "label": 0}, {"idx": "cosqa-train-3229", "doc": "how to implement help in python", "code": "def _help():\n    \"\"\" Display both SQLAlchemy and Python help statements \"\"\"\n\n    statement = '%s%s' % (shelp, phelp % ', '.join(cntx_.keys()))\n    print statement.strip()", "code_tokens": "def _help ( ) : statement = '%s%s' % ( shelp , phelp % ', ' . join ( cntx_ . keys ( ) ) ) print statement . strip ( )", "docstring_tokens": "Display both SQLAlchemy and Python help statements", "label": 0}, {"idx": "cosqa-train-3230", "doc": "python redis batch set", "code": "def __setitem__(self, field, value):\n        \"\"\" :see::meth:RedisMap.__setitem__ \"\"\"\n        return self._client.hset(self.key_prefix, field, self._dumps(value))", "code_tokens": "def __setitem__ ( self , field , value ) : return self . _client . hset ( self . key_prefix , field , self . _dumps ( value ) )", "docstring_tokens": ": see :: meth : RedisMap . __setitem__", "label": 0}, {"idx": "cosqa-train-3231", "doc": "how to implement websocket in python", "code": "def send(message, request_context=None, binary=False):\n    \"\"\"Sends a message to websocket.\n\n    :param str message: data to send\n\n    :param request_context:\n\n    :raises IOError: If unable to send a message.\n    \"\"\"\n    if binary:\n        return uwsgi.websocket_send_binary(message, request_context)\n\n    return uwsgi.websocket_send(message, request_context)", "code_tokens": "def send ( message , request_context = None , binary = False ) : if binary : return uwsgi . websocket_send_binary ( message , request_context ) return uwsgi . websocket_send ( message , request_context )", "docstring_tokens": "Sends a message to websocket .", "label": 0}, {"idx": "cosqa-train-3232", "doc": "python redis connection pooling", "code": "def __connect():\n    \"\"\"\n    Connect to a redis instance.\n    \"\"\"\n    global redis_instance\n    if use_tcp_socket:\n        redis_instance = redis.StrictRedis(host=hostname, port=port)\n    else:\n        redis_instance = redis.StrictRedis(unix_socket_path=unix_socket)", "code_tokens": "def __connect ( ) : global redis_instance if use_tcp_socket : redis_instance = redis . StrictRedis ( host = hostname , port = port ) else : redis_instance = redis . StrictRedis ( unix_socket_path = unix_socket )", "docstring_tokens": "Connect to a redis instance .", "label": 0}, {"idx": "cosqa-train-3233", "doc": "how to increase the number of ticks timeseries python", "code": "def mark(self, n=1):\n        \"\"\"Mark the occurrence of a given number of events.\"\"\"\n        self.tick_if_necessary()\n        self.count += n\n        self.m1_rate.update(n)\n        self.m5_rate.update(n)\n        self.m15_rate.update(n)", "code_tokens": "def mark ( self , n = 1 ) : self . tick_if_necessary ( ) self . count += n self . m1_rate . update ( n ) self . m5_rate . update ( n ) self . m15_rate . update ( n )", "docstring_tokens": "Mark the occurrence of a given number of events .", "label": 1}, {"idx": "cosqa-train-3234", "doc": "python redis connectionpool close", "code": "def exit(self):\n        \"\"\"\n        Closes the connection\n        \"\"\"\n        self.pubsub.unsubscribe()\n        self.client.connection_pool.disconnect()\n\n        logger.info(\"Connection to Redis closed\")", "code_tokens": "def exit ( self ) : self . pubsub . unsubscribe ( ) self . client . connection_pool . disconnect ( ) logger . info ( \"Connection to Redis closed\" )", "docstring_tokens": "Closes the connection", "label": 0}, {"idx": "cosqa-train-3235", "doc": "how to invoke post method from another method in python", "code": "def _post(self, url, params, uploads=None):\n        \"\"\" Wrapper method for POST calls. \"\"\"\n        self._call(self.POST, url, params, uploads)", "code_tokens": "def _post ( self , url , params , uploads = None ) : self . _call ( self . POST , url , params , uploads )", "docstring_tokens": "Wrapper method for POST calls .", "label": 0}, {"idx": "cosqa-train-3236", "doc": "python regex how to specify a list of patterns", "code": "def prep_regex(patterns):\n    \"\"\"Compile regex patterns.\"\"\"\n\n    flags = 0 if Config.options.case_sensitive else re.I\n\n    return [re.compile(pattern, flags) for pattern in patterns]", "code_tokens": "def prep_regex ( patterns ) : flags = 0 if Config . options . case_sensitive else re . I return [ re . compile ( pattern , flags ) for pattern in patterns ]", "docstring_tokens": "Compile regex patterns .", "label": 0}, {"idx": "cosqa-train-3237", "doc": "how to join two data frame by a common column in python", "code": "def cross_join(df1, df2):\n    \"\"\"\n    Return a dataframe that is a cross between dataframes\n    df1 and df2\n\n    ref: https://github.com/pydata/pandas/issues/5401\n    \"\"\"\n    if len(df1) == 0:\n        return df2\n\n    if len(df2) == 0:\n        return df1\n\n    # Add as lists so that the new index keeps the items in\n    # the order that they are added together\n    all_columns = pd.Index(list(df1.columns) + list(df2.columns))\n    df1['key'] = 1\n    df2['key'] = 1\n    return pd.merge(df1, df2, on='key').loc[:, all_columns]", "code_tokens": "def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]", "docstring_tokens": "Return a dataframe that is a cross between dataframes df1 and df2", "label": 0}, {"idx": "cosqa-train-3238", "doc": "python regex match any kind of paranthesis", "code": "def match_paren(self, tokens, item):\n        \"\"\"Matches a paren.\"\"\"\n        match, = tokens\n        return self.match(match, item)", "code_tokens": "def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "docstring_tokens": "Matches a paren .", "label": 0}, {"idx": "cosqa-train-3239", "doc": "how to keep the legend outside the python graph", "code": "def remove_legend(ax=None):\n    \"\"\"Remove legend for axes or gca.\n\n    See http://osdir.com/ml/python.matplotlib.general/2005-07/msg00285.html\n    \"\"\"\n    from pylab import gca, draw\n    if ax is None:\n        ax = gca()\n    ax.legend_ = None\n    draw()", "code_tokens": "def remove_legend ( ax = None ) : from pylab import gca , draw if ax is None : ax = gca ( ) ax . legend_ = None draw ( )", "docstring_tokens": "Remove legend for axes or gca .", "label": 0}, {"idx": "cosqa-train-3240", "doc": "python regex return beggining of match", "code": "def unmatched(match):\n    \"\"\"Return unmatched part of re.Match object.\"\"\"\n    start, end = match.span(0)\n    return match.string[:start]+match.string[end:]", "code_tokens": "def unmatched ( match ) : start , end = match . span ( 0 ) return match . string [ : start ] + match . string [ end : ]", "docstring_tokens": "Return unmatched part of re . Match object .", "label": 0}, {"idx": "cosqa-train-3241", "doc": "how to keep track of occurrences in python", "code": "def seq():\n    \"\"\"\n    Counts up sequentially from a number based on the current time\n\n    :rtype int:\n    \"\"\"\n    current_frame     = inspect.currentframe().f_back\n    trace_string      = \"\"\n    while current_frame.f_back:\n      trace_string = trace_string + current_frame.f_back.f_code.co_name\n      current_frame = current_frame.f_back\n    return counter.get_from_trace(trace_string)", "code_tokens": "def seq ( ) : current_frame = inspect . currentframe ( ) . f_back trace_string = \"\" while current_frame . f_back : trace_string = trace_string + current_frame . f_back . f_code . co_name current_frame = current_frame . f_back return counter . get_from_trace ( trace_string )", "docstring_tokens": "Counts up sequentially from a number based on the current time", "label": 0}, {"idx": "cosqa-train-3242", "doc": "python regex to check given email is valid or not", "code": "def is_valid_email(email):\n    \"\"\"\n    Check if email is valid\n    \"\"\"\n    pattern = re.compile(r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+')\n    return bool(pattern.match(email))", "code_tokens": "def is_valid_email ( email ) : pattern = re . compile ( r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+' ) return bool ( pattern . match ( email ) )", "docstring_tokens": "Check if email is valid", "label": 0}, {"idx": "cosqa-train-3243", "doc": "how to kik member in group in python", "code": "def _Members(self, group):\n    \"\"\"Unify members of a group and accounts with the group as primary gid.\"\"\"\n    group.members = set(group.members).union(self.gids.get(group.gid, []))\n    return group", "code_tokens": "def _Members ( self , group ) : group . members = set ( group . members ) . union ( self . gids . get ( group . gid , [ ] ) ) return group", "docstring_tokens": "Unify members of a group and accounts with the group as primary gid .", "label": 0}, {"idx": "cosqa-train-3244", "doc": "python regular expression tuple", "code": "def version_triple(tag):\n    \"\"\"\n    returns: a triple of integers from a version tag\n    \"\"\"\n    groups = re.match(r'v?(\\d+)\\.(\\d+)\\.(\\d+)', tag).groups()\n    return tuple(int(n) for n in groups)", "code_tokens": "def version_triple ( tag ) : groups = re . match ( r'v?(\\d+)\\.(\\d+)\\.(\\d+)' , tag ) . groups ( ) return tuple ( int ( n ) for n in groups )", "docstring_tokens": "returns : a triple of integers from a version tag", "label": 0}, {"idx": "cosqa-train-3245", "doc": "how to kill a running python script", "code": "def kill(self):\n        \"\"\"Kill the browser.\n\n        This is useful when the browser is stuck.\n        \"\"\"\n        if self.process:\n            self.process.kill()\n            self.process.wait()", "code_tokens": "def kill ( self ) : if self . process : self . process . kill ( ) self . process . wait ( )", "docstring_tokens": "Kill the browser .", "label": 0}, {"idx": "cosqa-train-3246", "doc": "python relative data path", "code": "def data_directory():\n    \"\"\"Return the absolute path to the directory containing the package data.\"\"\"\n    package_directory = os.path.abspath(os.path.dirname(__file__))\n    return os.path.join(package_directory, \"data\")", "code_tokens": "def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , \"data\" )", "docstring_tokens": "Return the absolute path to the directory containing the package data .", "label": 1}, {"idx": "cosqa-train-3247", "doc": "how to kill python process in linux", "code": "def kill_process_children(pid):\n    \"\"\"Find and kill child processes of a process.\n\n    :param pid: PID of parent process (process ID)\n    :return: Nothing\n    \"\"\"\n    if sys.platform == \"darwin\":\n        kill_process_children_osx(pid)\n    elif sys.platform == \"linux\":\n        kill_process_children_unix(pid)\n    else:\n        pass", "code_tokens": "def kill_process_children ( pid ) : if sys . platform == \"darwin\" : kill_process_children_osx ( pid ) elif sys . platform == \"linux\" : kill_process_children_unix ( pid ) else : pass", "docstring_tokens": "Find and kill child processes of a process .", "label": 0}, {"idx": "cosqa-train-3248", "doc": "python relu gradient function", "code": "def f(x, a, c):\n    \"\"\" Objective function (sum of squared residuals) \"\"\"\n    v = g(x, a, c)\n    return v.dot(v)", "code_tokens": "def f ( x , a , c ) : v = g ( x , a , c ) return v . dot ( v )", "docstring_tokens": "Objective function ( sum of squared residuals )", "label": 0}, {"idx": "cosqa-train-3249", "doc": "how to kill the process using python by accessing the variable", "code": "def stop(pid):\n    \"\"\"Shut down a specific process.\n\n    Args:\n      pid: the pid of the process to shutdown.\n    \"\"\"\n    if psutil.pid_exists(pid):\n      try:\n        p = psutil.Process(pid)\n        p.kill()\n      except Exception:\n        pass", "code_tokens": "def stop ( pid ) : if psutil . pid_exists ( pid ) : try : p = psutil . Process ( pid ) p . kill ( ) except Exception : pass", "docstring_tokens": "Shut down a specific process .", "label": 0}, {"idx": "cosqa-train-3250", "doc": "python remove all compiled files", "code": "def clean():\n    \"\"\"clean - remove build artifacts.\"\"\"\n    run('rm -rf build/')\n    run('rm -rf dist/')\n    run('rm -rf puzzle.egg-info')\n    run('find . -name __pycache__ -delete')\n    run('find . -name *.pyc -delete')\n    run('find . -name *.pyo -delete')\n    run('find . -name *~ -delete')\n\n    log.info('cleaned up')", "code_tokens": "def clean ( ) : run ( 'rm -rf build/' ) run ( 'rm -rf dist/' ) run ( 'rm -rf puzzle.egg-info' ) run ( 'find . -name __pycache__ -delete' ) run ( 'find . -name *.pyc -delete' ) run ( 'find . -name *.pyo -delete' ) run ( 'find . -name *~ -delete' ) log . info ( 'cleaned up' )", "docstring_tokens": "clean - remove build artifacts .", "label": 0}, {"idx": "cosqa-train-3251", "doc": "how to know if a python code is running", "code": "def IPYTHON_MAIN():\n    \"\"\"Decide if the Ipython command line is running code.\"\"\"\n    import pkg_resources\n\n    runner_frame = inspect.getouterframes(inspect.currentframe())[-2]\n    return (\n        getattr(runner_frame, \"function\", None)\n        == pkg_resources.load_entry_point(\"ipython\", \"console_scripts\", \"ipython\").__name__\n    )", "code_tokens": "def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , \"function\" , None ) == pkg_resources . load_entry_point ( \"ipython\" , \"console_scripts\" , \"ipython\" ) . __name__ )", "docstring_tokens": "Decide if the Ipython command line is running code .", "label": 0}, {"idx": "cosqa-train-3252", "doc": "python remove all dictionary entires with specified value", "code": "def filter_dict(d, keys):\n    \"\"\"\n    Creates a new dict from an existing dict that only has the given keys\n    \"\"\"\n    return {k: v for k, v in d.items() if k in keys}", "code_tokens": "def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "docstring_tokens": "Creates a new dict from an existing dict that only has the given keys", "label": 0}, {"idx": "cosqa-train-3253", "doc": "how to know if python environment is correct", "code": "def check_version():\n    \"\"\"Sanity check version information for corrupt virtualenv symlinks\n    \"\"\"\n    if sys.version_info[0:3] == PYTHON_VERSION_INFO[0:3]:\n        return\n\n    sys.exit(\n        ansi.error() + ' your virtual env points to the wrong python version. '\n                       'This is likely because you used a python installer that clobbered '\n                       'the system installation, which breaks virtualenv creation. '\n                       'To fix, check this symlink, and delete the installation of python '\n                       'that it is brokenly pointing to, then delete the virtual env itself '\n                       'and rerun lore install: ' + os.linesep + os.linesep + BIN_PYTHON +\n        os.linesep\n    )", "code_tokens": "def check_version ( ) : if sys . version_info [ 0 : 3 ] == PYTHON_VERSION_INFO [ 0 : 3 ] : return sys . exit ( ansi . error ( ) + ' your virtual env points to the wrong python version. ' 'This is likely because you used a python installer that clobbered ' 'the system installation, which breaks virtualenv creation. ' 'To fix, check this symlink, and delete the installation of python ' 'that it is brokenly pointing to, then delete the virtual env itself ' 'and rerun lore install: ' + os . linesep + os . linesep + BIN_PYTHON + os . linesep )", "docstring_tokens": "Sanity check version information for corrupt virtualenv symlinks", "label": 0}, {"idx": "cosqa-train-3254", "doc": "python remove all none items from a list", "code": "def _remove_none_values(dictionary):\n    \"\"\" Remove dictionary keys whose value is None \"\"\"\n    return list(map(dictionary.pop,\n                    [i for i in dictionary if dictionary[i] is None]))", "code_tokens": "def _remove_none_values ( dictionary ) : return list ( map ( dictionary . pop , [ i for i in dictionary if dictionary [ i ] is None ] ) )", "docstring_tokens": "Remove dictionary keys whose value is None", "label": 0}, {"idx": "cosqa-train-3255", "doc": "how to limit the range of x axis python", "code": "def set_xlimits_widgets(self, set_min=True, set_max=True):\n        \"\"\"Populate axis limits GUI with current plot values.\"\"\"\n        xmin, xmax = self.tab_plot.ax.get_xlim()\n        if set_min:\n            self.w.x_lo.set_text('{0}'.format(xmin))\n        if set_max:\n            self.w.x_hi.set_text('{0}'.format(xmax))", "code_tokens": "def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )", "docstring_tokens": "Populate axis limits GUI with current plot values .", "label": 0}, {"idx": "cosqa-train-3256", "doc": "python remove c comment", "code": "def CleanseComments(line):\n  \"\"\"Removes //-comments and single-line C-style /* */ comments.\n\n  Args:\n    line: A line of C++ source.\n\n  Returns:\n    The line with single-line comments removed.\n  \"\"\"\n  commentpos = line.find('//')\n  if commentpos != -1 and not IsCppString(line[:commentpos]):\n    line = line[:commentpos].rstrip()\n  # get rid of /* ... */\n  return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS.sub('', line)", "code_tokens": "def CleanseComments ( line ) : commentpos = line . find ( '//' ) if commentpos != - 1 and not IsCppString ( line [ : commentpos ] ) : line = line [ : commentpos ] . rstrip ( ) # get rid of /* ... */ return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS . sub ( '' , line )", "docstring_tokens": "Removes // - comments and single - line C - style / * * / comments .", "label": 0}, {"idx": "cosqa-train-3257", "doc": "how to link rooms in python", "code": "def join(self, room):\n        \"\"\"Lets a user join a room on a specific Namespace.\"\"\"\n        self.socket.rooms.add(self._get_room_name(room))", "code_tokens": "def join ( self , room ) : self . socket . rooms . add ( self . _get_room_name ( room ) )", "docstring_tokens": "Lets a user join a room on a specific Namespace .", "label": 0}, {"idx": "cosqa-train-3258", "doc": "python remove duplicate elemnts in list", "code": "def dedup_list(l):\n    \"\"\"Given a list (l) will removing duplicates from the list,\n       preserving the original order of the list. Assumes that\n       the list entrie are hashable.\"\"\"\n    dedup = set()\n    return [ x for x in l if not (x in dedup or dedup.add(x))]", "code_tokens": "def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]", "docstring_tokens": "Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable .", "label": 1}, {"idx": "cosqa-train-3259", "doc": "how to list columns and data types in data frames python", "code": "def get_obj_cols(df):\n    \"\"\"\n    Returns names of 'object' columns in the DataFrame.\n    \"\"\"\n    obj_cols = []\n    for idx, dt in enumerate(df.dtypes):\n        if dt == 'object' or is_category(dt):\n            obj_cols.append(df.columns.values[idx])\n\n    return obj_cols", "code_tokens": "def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols", "docstring_tokens": "Returns names of object columns in the DataFrame .", "label": 0}, {"idx": "cosqa-train-3260", "doc": "python remove duplicated from files", "code": "def _remove_duplicate_files(xs):\n    \"\"\"Remove files specified multiple times in a list.\n    \"\"\"\n    seen = set([])\n    out = []\n    for x in xs:\n        if x[\"path\"] not in seen:\n            out.append(x)\n            seen.add(x[\"path\"])\n    return out", "code_tokens": "def _remove_duplicate_files ( xs ) : seen = set ( [ ] ) out = [ ] for x in xs : if x [ \"path\" ] not in seen : out . append ( x ) seen . add ( x [ \"path\" ] ) return out", "docstring_tokens": "Remove files specified multiple times in a list .", "label": 0}, {"idx": "cosqa-train-3261", "doc": "how to log all my python errors in a log file", "code": "def on_error(e):  # pragma: no cover\n    \"\"\"Error handler\n\n    RuntimeError or ValueError exceptions raised by commands will be handled\n    by this function.\n    \"\"\"\n    exname = {'RuntimeError': 'Runtime error', 'Value Error': 'Value error'}\n    sys.stderr.write('{}: {}\\n'.format(exname[e.__class__.__name__], str(e)))\n    sys.stderr.write('See file slam_error.log for additional details.\\n')\n    sys.exit(1)", "code_tokens": "def on_error ( e ) : # pragma: no cover exname = { 'RuntimeError' : 'Runtime error' , 'Value Error' : 'Value error' } sys . stderr . write ( '{}: {}\\n' . format ( exname [ e . __class__ . __name__ ] , str ( e ) ) ) sys . stderr . write ( 'See file slam_error.log for additional details.\\n' ) sys . exit ( 1 )", "docstring_tokens": "Error handler", "label": 1}, {"idx": "cosqa-train-3262", "doc": "python remove file if it exists", "code": "def _delete_local(self, filename):\n        \"\"\"Deletes the specified file from the local filesystem.\"\"\"\n\n        if os.path.exists(filename):\n            os.remove(filename)", "code_tokens": "def _delete_local ( self , filename ) : if os . path . exists ( filename ) : os . remove ( filename )", "docstring_tokens": "Deletes the specified file from the local filesystem .", "label": 0}, {"idx": "cosqa-train-3263", "doc": "how to make a copy of a python object", "code": "def __copy__(self):\n        \"\"\"A magic method to implement shallow copy behavior.\"\"\"\n        return self.__class__.load(self.dump(), context=self.context)", "code_tokens": "def __copy__ ( self ) : return self . __class__ . load ( self . dump ( ) , context = self . context )", "docstring_tokens": "A magic method to implement shallow copy behavior .", "label": 0}, {"idx": "cosqa-train-3264", "doc": "python remove item from heapq", "code": "def PopTask(self):\n    \"\"\"Retrieves and removes the first task from the heap.\n\n    Returns:\n      Task: the task or None if the heap is empty.\n    \"\"\"\n    try:\n      _, task = heapq.heappop(self._heap)\n\n    except IndexError:\n      return None\n    self._task_identifiers.remove(task.identifier)\n    return task", "code_tokens": "def PopTask ( self ) : try : _ , task = heapq . heappop ( self . _heap ) except IndexError : return None self . _task_identifiers . remove ( task . identifier ) return task", "docstring_tokens": "Retrieves and removes the first task from the heap .", "label": 0}, {"idx": "cosqa-train-3265", "doc": "how to make a curved path on python", "code": "def _curve(x1, y1, x2, y2, hunit = HUNIT, vunit = VUNIT):\n    \"\"\"\n    Return a PyX curved path from (x1, y1) to (x2, y2),\n    such that the slope at either end is zero.\n    \"\"\"\n    ax1, ax2, axm = x1 * hunit, x2 * hunit, (x1 + x2) * hunit / 2\n    ay1, ay2 = y1 * vunit, y2 * vunit\n    return pyx.path.curve(ax1, ay1, axm, ay1, axm, ay2, ax2, ay2)", "code_tokens": "def _curve ( x1 , y1 , x2 , y2 , hunit = HUNIT , vunit = VUNIT ) : ax1 , ax2 , axm = x1 * hunit , x2 * hunit , ( x1 + x2 ) * hunit / 2 ay1 , ay2 = y1 * vunit , y2 * vunit return pyx . path . curve ( ax1 , ay1 , axm , ay1 , axm , ay2 , ax2 , ay2 )", "docstring_tokens": "Return a PyX curved path from ( x1 y1 ) to ( x2 y2 ) such that the slope at either end is zero .", "label": 0}, {"idx": "cosqa-train-3266", "doc": "python remove non alphanumeric except whitespace", "code": "def drop_bad_characters(text):\n    \"\"\"Takes a text and drops all non-printable and non-ascii characters and\n    also any whitespace characters that aren't space.\n\n    :arg str text: the text to fix\n\n    :returns: text with all bad characters dropped\n\n    \"\"\"\n    # Strip all non-ascii and non-printable characters\n    text = ''.join([c for c in text if c in ALLOWED_CHARS])\n    return text", "code_tokens": "def drop_bad_characters ( text ) : # Strip all non-ascii and non-printable characters text = '' . join ( [ c for c in text if c in ALLOWED_CHARS ] ) return text", "docstring_tokens": "Takes a text and drops all non - printable and non - ascii characters and also any whitespace characters that aren t space .", "label": 0}, {"idx": "cosqa-train-3267", "doc": "how to make a function run once in python", "code": "def once(func):\n    \"\"\"Runs a thing once and once only.\"\"\"\n    lock = threading.Lock()\n\n    def new_func(*args, **kwargs):\n        if new_func.called:\n            return\n        with lock:\n            if new_func.called:\n                return\n            rv = func(*args, **kwargs)\n            new_func.called = True\n            return rv\n\n    new_func = update_wrapper(new_func, func)\n    new_func.called = False\n    return new_func", "code_tokens": "def once ( func ) : lock = threading . Lock ( ) def new_func ( * args , * * kwargs ) : if new_func . called : return with lock : if new_func . called : return rv = func ( * args , * * kwargs ) new_func . called = True return rv new_func = update_wrapper ( new_func , func ) new_func . called = False return new_func", "docstring_tokens": "Runs a thing once and once only .", "label": 1}, {"idx": "cosqa-train-3268", "doc": "python remove none values from list", "code": "def filter_none(list_of_points):\n    \"\"\"\n    \n    :param list_of_points: \n    :return: list_of_points with None's removed\n    \"\"\"\n    remove_elementnone = filter(lambda p: p is not None, list_of_points)\n    remove_sublistnone = filter(lambda p: not contains_none(p), remove_elementnone)\n    return list(remove_sublistnone)", "code_tokens": "def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "docstring_tokens": ": param list_of_points : : return : list_of_points with None s removed", "label": 0}, {"idx": "cosqa-train-3269", "doc": "python remove overlap items betweem two lists", "code": "def union_overlapping(intervals):\n    \"\"\"Union any overlapping intervals in the given set.\"\"\"\n    disjoint_intervals = []\n\n    for interval in intervals:\n        if disjoint_intervals and disjoint_intervals[-1].overlaps(interval):\n            disjoint_intervals[-1] = disjoint_intervals[-1].union(interval)\n        else:\n            disjoint_intervals.append(interval)\n\n    return disjoint_intervals", "code_tokens": "def union_overlapping ( intervals ) : disjoint_intervals = [ ] for interval in intervals : if disjoint_intervals and disjoint_intervals [ - 1 ] . overlaps ( interval ) : disjoint_intervals [ - 1 ] = disjoint_intervals [ - 1 ] . union ( interval ) else : disjoint_intervals . append ( interval ) return disjoint_intervals", "docstring_tokens": "Union any overlapping intervals in the given set .", "label": 0}, {"idx": "cosqa-train-3270", "doc": "how to make a list of words into corpus python", "code": "def _generate_phrases(self, sentences):\n        \"\"\"Method to generate contender phrases given the sentences of the text\n        document.\n\n        :param sentences: List of strings where each string represents a\n                          sentence which forms the text.\n        :return: Set of string tuples where each tuple is a collection\n                 of words forming a contender phrase.\n        \"\"\"\n        phrase_list = set()\n        # Create contender phrases from sentences.\n        for sentence in sentences:\n            word_list = [word.lower() for word in wordpunct_tokenize(sentence)]\n            phrase_list.update(self._get_phrase_list_from_words(word_list))\n        return phrase_list", "code_tokens": "def _generate_phrases ( self , sentences ) : phrase_list = set ( ) # Create contender phrases from sentences. for sentence in sentences : word_list = [ word . lower ( ) for word in wordpunct_tokenize ( sentence ) ] phrase_list . update ( self . _get_phrase_list_from_words ( word_list ) ) return phrase_list", "docstring_tokens": "Method to generate contender phrases given the sentences of the text document .", "label": 0}, {"idx": "cosqa-train-3271", "doc": "python remove paranthesis from string", "code": "def unapostrophe(text):\n    \"\"\"Strip apostrophe and 's' from the end of a string.\"\"\"\n    text = re.sub(r'[%s]s?$' % ''.join(APOSTROPHES), '', text)\n    return text", "code_tokens": "def unapostrophe ( text ) : text = re . sub ( r'[%s]s?$' % '' . join ( APOSTROPHES ) , '' , text ) return text", "docstring_tokens": "Strip apostrophe and s from the end of a string .", "label": 0}, {"idx": "cosqa-train-3272", "doc": "how to make a number indicate the number of spaces in python", "code": "def indentsize(line):\n    \"\"\"Return the indent size, in spaces, at the start of a line of text.\"\"\"\n    expline = string.expandtabs(line)\n    return len(expline) - len(string.lstrip(expline))", "code_tokens": "def indentsize ( line ) : expline = string . expandtabs ( line ) return len ( expline ) - len ( string . lstrip ( expline ) )", "docstring_tokens": "Return the indent size in spaces at the start of a line of text .", "label": 0}, {"idx": "cosqa-train-3273", "doc": "python remove prefix columns", "code": "def _do_remove_prefix(name):\n    \"\"\"Strip the possible prefix 'Table: ' from a table name.\"\"\"\n    res = name\n    if isinstance(res, str):\n        if (res.find('Table: ') == 0):\n            res = res.replace('Table: ', '', 1)\n    return res", "code_tokens": "def _do_remove_prefix ( name ) : res = name if isinstance ( res , str ) : if ( res . find ( 'Table: ' ) == 0 ) : res = res . replace ( 'Table: ' , '' , 1 ) return res", "docstring_tokens": "Strip the possible prefix Table : from a table name .", "label": 0}, {"idx": "cosqa-train-3274", "doc": "how to make a restart button using python", "code": "def do_restart(self, line):\n        \"\"\"Request that the Outstation perform a cold restart. Command syntax is: restart\"\"\"\n        self.application.master.Restart(opendnp3.RestartType.COLD, restart_callback)", "code_tokens": "def do_restart ( self , line ) : self . application . master . Restart ( opendnp3 . RestartType . COLD , restart_callback )", "docstring_tokens": "Request that the Outstation perform a cold restart . Command syntax is : restart", "label": 1}, {"idx": "cosqa-train-3275", "doc": "python remove redunant in array", "code": "def distinct(l):\n    \"\"\"\n    Return a list where the duplicates have been removed.\n\n    Args:\n        l (list): the list to filter.\n\n    Returns:\n        list: the same list without duplicates.\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return (_ for _ in l if not (_ in seen or seen_add(_)))", "code_tokens": "def distinct ( l ) : seen = set ( ) seen_add = seen . add return ( _ for _ in l if not ( _ in seen or seen_add ( _ ) ) )", "docstring_tokens": "Return a list where the duplicates have been removed .", "label": 0}, {"idx": "cosqa-train-3276", "doc": "how to make a string as datetime date in python", "code": "def _datetime_to_date(arg):\n    \"\"\"\n    convert datetime/str to date\n    :param arg:\n    :return:\n    \"\"\"\n    _arg = parse(arg)\n    if isinstance(_arg, datetime.datetime):\n        _arg = _arg.date()\n    return _arg", "code_tokens": "def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "docstring_tokens": "convert datetime / str to date : param arg : : return :", "label": 0}, {"idx": "cosqa-train-3277", "doc": "python remove spaces between specific chars", "code": "def strip_accents(text):\n    \"\"\"\n    Strip agents from a string.\n    \"\"\"\n\n    normalized_str = unicodedata.normalize('NFD', text)\n\n    return ''.join([\n        c for c in normalized_str if unicodedata.category(c) != 'Mn'])", "code_tokens": "def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "docstring_tokens": "Strip agents from a string .", "label": 0}, {"idx": "cosqa-train-3278", "doc": "how to make a string into a path python", "code": "def fixpath(path):\n    \"\"\"Uniformly format a path.\"\"\"\n    return os.path.normpath(os.path.realpath(os.path.expanduser(path)))", "code_tokens": "def fixpath ( path ) : return os . path . normpath ( os . path . realpath ( os . path . expanduser ( path ) ) )", "docstring_tokens": "Uniformly format a path .", "label": 0}, {"idx": "cosqa-train-3279", "doc": "python remove trailing zeros decimal format", "code": "def drop_trailing_zeros_decimal(num):\n    \"\"\" Drops the trailinz zeros from decimal value.\n        Returns a string\n    \"\"\"\n    out = str(num)\n    return out.rstrip('0').rstrip('.') if '.' in out else out", "code_tokens": "def drop_trailing_zeros_decimal ( num ) : out = str ( num ) return out . rstrip ( '0' ) . rstrip ( '.' ) if '.' in out else out", "docstring_tokens": "Drops the trailinz zeros from decimal value . Returns a string", "label": 0}, {"idx": "cosqa-train-3280", "doc": "how to make a symlink in python", "code": "def symlink(source, destination):\n    \"\"\"Create a symbolic link\"\"\"\n    log(\"Symlinking {} as {}\".format(source, destination))\n    cmd = [\n        'ln',\n        '-sf',\n        source,\n        destination,\n    ]\n    subprocess.check_call(cmd)", "code_tokens": "def symlink ( source , destination ) : log ( \"Symlinking {} as {}\" . format ( source , destination ) ) cmd = [ 'ln' , '-sf' , source , destination , ] subprocess . check_call ( cmd )", "docstring_tokens": "Create a symbolic link", "label": 0}, {"idx": "cosqa-train-3281", "doc": "python render jinja2 without flask", "code": "def rstjinja(app, docname, source):\n    \"\"\"\n    Render our pages as a jinja template for fancy templating goodness.\n    \"\"\"\n    # Make sure we're outputting HTML\n    if app.builder.format != 'html':\n        return\n    src = source[0]\n    rendered = app.builder.templates.render_string(\n        src, app.config.html_context\n    )\n    source[0] = rendered", "code_tokens": "def rstjinja ( app , docname , source ) : # Make sure we're outputting HTML if app . builder . format != 'html' : return src = source [ 0 ] rendered = app . builder . templates . render_string ( src , app . config . html_context ) source [ 0 ] = rendered", "docstring_tokens": "Render our pages as a jinja template for fancy templating goodness .", "label": 0}, {"idx": "cosqa-train-3282", "doc": "how to make an array of zeros in python", "code": "def zeros(self, name, **kwargs):\n        \"\"\"Create an array. Keyword arguments as per\n        :func:`zarr.creation.zeros`.\"\"\"\n        return self._write_op(self._zeros_nosync, name, **kwargs)", "code_tokens": "def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )", "docstring_tokens": "Create an array . Keyword arguments as per : func : zarr . creation . zeros .", "label": 1}, {"idx": "cosqa-train-3283", "doc": "python render jinjia yaml template", "code": "def conf(self):\n        \"\"\"Generate the Sphinx `conf.py` configuration file\n\n        Returns:\n            (str): the contents of the `conf.py` file.\n        \"\"\"\n        return self.env.get_template('conf.py.j2').render(\n            metadata=self.metadata,\n            package=self.package)", "code_tokens": "def conf ( self ) : return self . env . get_template ( 'conf.py.j2' ) . render ( metadata = self . metadata , package = self . package )", "docstring_tokens": "Generate the Sphinx conf . py configuration file", "label": 0}, {"idx": "cosqa-train-3284", "doc": "how to make caps lowercase in python", "code": "def to_capitalized_camel_case(snake_case_string):\n    \"\"\"\n    Convert a string from snake case to camel case with the first letter capitalized. For example, \"some_var\"\n    would become \"SomeVar\".\n\n    :param snake_case_string: Snake-cased string to convert to camel case.\n    :returns: Camel-cased version of snake_case_string.\n    \"\"\"\n    parts = snake_case_string.split('_')\n    return ''.join([i.title() for i in parts])", "code_tokens": "def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )", "docstring_tokens": "Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar .", "label": 0}, {"idx": "cosqa-train-3285", "doc": "python rendering json, and html", "code": "def render_to_json(templates, context, request):\n    \"\"\"\n    Generate a JSON HttpResponse with rendered template HTML.\n    \"\"\"\n    html = render_to_string(\n        templates,\n        context=context,\n        request=request\n    )\n    _json = json.dumps({\n        \"html\": html\n    })\n    return HttpResponse(_json)", "code_tokens": "def render_to_json ( templates , context , request ) : html = render_to_string ( templates , context = context , request = request ) _json = json . dumps ( { \"html\" : html } ) return HttpResponse ( _json )", "docstring_tokens": "Generate a JSON HttpResponse with rendered template HTML .", "label": 0}, {"idx": "cosqa-train-3286", "doc": "how to make charachters in python", "code": "def to_unicode_repr( _letter ):\n    \"\"\" helpful in situations where browser/app may recognize Unicode encoding\n        in the \\u0b8e type syntax but not actual unicode glyph/code-point\"\"\"\n    # Python 2-3 compatible\n    return u\"u'\"+ u\"\".join( [ u\"\\\\u%04x\"%ord(l) for l in _letter ] ) + u\"'\"", "code_tokens": "def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u\"u'\" + u\"\" . join ( [ u\"\\\\u%04x\" % ord ( l ) for l in _letter ] ) + u\"'\"", "docstring_tokens": "helpful in situations where browser / app may recognize Unicode encoding in the \\ u0b8e type syntax but not actual unicode glyph / code - point", "label": 0}, {"idx": "cosqa-train-3287", "doc": "how to make columns python using strings", "code": "def join_cols(cols):\n    \"\"\"Join list of columns into a string for a SQL query\"\"\"\n    return \", \".join([i for i in cols]) if isinstance(cols, (list, tuple, set)) else cols", "code_tokens": "def join_cols ( cols ) : return \", \" . join ( [ i for i in cols ] ) if isinstance ( cols , ( list , tuple , set ) ) else cols", "docstring_tokens": "Join list of columns into a string for a SQL query", "label": 1}, {"idx": "cosqa-train-3288", "doc": "python replace case insensitive", "code": "def to_snake_case(name):\n    \"\"\" Given a name in camelCase return in snake_case \"\"\"\n    s1 = FIRST_CAP_REGEX.sub(r'\\1_\\2', name)\n    return ALL_CAP_REGEX.sub(r'\\1_\\2', s1).lower()", "code_tokens": "def to_snake_case ( name ) : s1 = FIRST_CAP_REGEX . sub ( r'\\1_\\2' , name ) return ALL_CAP_REGEX . sub ( r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Given a name in camelCase return in snake_case", "label": 0}, {"idx": "cosqa-train-3289", "doc": "how to make flask standalone python", "code": "def initialize_api(flask_app):\n    \"\"\"Initialize an API.\"\"\"\n    if not flask_restplus:\n        return\n\n    api = flask_restplus.Api(version=\"1.0\", title=\"My Example API\")\n    api.add_resource(HelloWorld, \"/hello\")\n\n    blueprint = flask.Blueprint(\"api\", __name__, url_prefix=\"/api\")\n    api.init_app(blueprint)\n    flask_app.register_blueprint(blueprint)", "code_tokens": "def initialize_api ( flask_app ) : if not flask_restplus : return api = flask_restplus . Api ( version = \"1.0\" , title = \"My Example API\" ) api . add_resource ( HelloWorld , \"/hello\" ) blueprint = flask . Blueprint ( \"api\" , __name__ , url_prefix = \"/api\" ) api . init_app ( blueprint ) flask_app . register_blueprint ( blueprint )", "docstring_tokens": "Initialize an API .", "label": 1}, {"idx": "cosqa-train-3290", "doc": "python replace specific text in string", "code": "def multi_replace(instr, search_list=[], repl_list=None):\n    \"\"\"\n    Does a string replace with a list of search and replacements\n\n    TODO: rename\n    \"\"\"\n    repl_list = [''] * len(search_list) if repl_list is None else repl_list\n    for ser, repl in zip(search_list, repl_list):\n        instr = instr.replace(ser, repl)\n    return instr", "code_tokens": "def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr", "docstring_tokens": "Does a string replace with a list of search and replacements", "label": 0}, {"idx": "cosqa-train-3291", "doc": "how to make multiple lines python into comments", "code": "def _comment(string):\n    \"\"\"return string as a comment\"\"\"\n    lines = [line.strip() for line in string.splitlines()]\n    return \"# \" + (\"%s# \" % linesep).join(lines)", "code_tokens": "def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return \"# \" + ( \"%s# \" % linesep ) . join ( lines )", "docstring_tokens": "return string as a comment", "label": 0}, {"idx": "cosqa-train-3292", "doc": "python replace string range", "code": "def _replace_token_range(tokens, start, end, replacement):\n    \"\"\"For a range indicated from start to end, replace with replacement.\"\"\"\n    tokens = tokens[:start] + replacement + tokens[end:]\n    return tokens", "code_tokens": "def _replace_token_range ( tokens , start , end , replacement ) : tokens = tokens [ : start ] + replacement + tokens [ end : ] return tokens", "docstring_tokens": "For a range indicated from start to end replace with replacement .", "label": 0}, {"idx": "cosqa-train-3293", "doc": "how to make my timezone offset aware python", "code": "def make_aware(dt):\n    \"\"\"Appends tzinfo and assumes UTC, if datetime object has no tzinfo already.\"\"\"\n    return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)", "code_tokens": "def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "docstring_tokens": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already .", "label": 0}, {"idx": "cosqa-train-3294", "doc": "python replacing multiple substrings", "code": "def _sub_patterns(patterns, text):\n    \"\"\"\n    Apply re.sub to bunch of (pattern, repl)\n    \"\"\"\n    for pattern, repl in patterns:\n        text = re.sub(pattern, repl, text)\n    return text", "code_tokens": "def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text", "docstring_tokens": "Apply re . sub to bunch of ( pattern repl )", "label": 0}, {"idx": "cosqa-train-3295", "doc": "how to make numbers rounded in python", "code": "def specialRound(number, rounding):\n    \"\"\"A method used to round a number in the way that UsefulUtils rounds.\"\"\"\n    temp = 0\n    if rounding == 0:\n        temp = number\n    else:\n        temp =  round(number, rounding)\n    if temp % 1 == 0:\n        return int(temp)\n    else:\n        return float(temp)", "code_tokens": "def specialRound ( number , rounding ) : temp = 0 if rounding == 0 : temp = number else : temp = round ( number , rounding ) if temp % 1 == 0 : return int ( temp ) else : return float ( temp )", "docstring_tokens": "A method used to round a number in the way that UsefulUtils rounds .", "label": 0}, {"idx": "cosqa-train-3296", "doc": "python request mock cookie session", "code": "def requests_request(method, url, **kwargs):\n    \"\"\"Requests-mock requests.request wrapper.\"\"\"\n    session = local_sessions.session\n    response = session.request(method=method, url=url, **kwargs)\n    session.close()\n    return response", "code_tokens": "def requests_request ( method , url , * * kwargs ) : session = local_sessions . session response = session . request ( method = method , url = url , * * kwargs ) session . close ( ) return response", "docstring_tokens": "Requests - mock requests . request wrapper .", "label": 0}, {"idx": "cosqa-train-3297", "doc": "how to make string name unique value python", "code": "def unique(self, name):\n    \"\"\"Make a variable name unique by appending a number if needed.\"\"\"\n    # Make sure the name is valid\n    name = self.valid(name)\n    # Make sure it's not too long\n    name = self.trim(name)\n    # Now make sure it's unique\n    unique_name = name\n    i = 2\n    while unique_name in self.names:\n      unique_name = name + str(i)\n      i += 1\n    self.names.add(unique_name)\n    return unique_name", "code_tokens": "def unique ( self , name ) : # Make sure the name is valid name = self . valid ( name ) # Make sure it's not too long name = self . trim ( name ) # Now make sure it's unique unique_name = name i = 2 while unique_name in self . names : unique_name = name + str ( i ) i += 1 self . names . add ( unique_name ) return unique_name", "docstring_tokens": "Make a variable name unique by appending a number if needed .", "label": 0}, {"idx": "cosqa-train-3298", "doc": "python requests auth token post", "code": "def auth_request(self, url, headers, body):\n        \"\"\"Perform auth request for token.\"\"\"\n\n        return self.req.post(url, headers, body=body)", "code_tokens": "def auth_request ( self , url , headers , body ) : return self . req . post ( url , headers , body = body )", "docstring_tokens": "Perform auth request for token .", "label": 0}, {"idx": "cosqa-train-3299", "doc": "how to make sure a list has a certain amount of elements python", "code": "def check_type_and_size_of_param_list(param_list, expected_length):\n    \"\"\"\n    Ensure that param_list is a list with the expected length. Raises a helpful\n    ValueError if this is not the case.\n    \"\"\"\n    try:\n        assert isinstance(param_list, list)\n        assert len(param_list) == expected_length\n    except AssertionError:\n        msg = \"param_list must be a list containing {} elements.\"\n        raise ValueError(msg.format(expected_length))\n\n    return None", "code_tokens": "def check_type_and_size_of_param_list ( param_list , expected_length ) : try : assert isinstance ( param_list , list ) assert len ( param_list ) == expected_length except AssertionError : msg = \"param_list must be a list containing {} elements.\" raise ValueError ( msg . format ( expected_length ) ) return None", "docstring_tokens": "Ensure that param_list is a list with the expected length . Raises a helpful ValueError if this is not the case .", "label": 0}, {"idx": "cosqa-train-3300", "doc": "python requests check if 404", "code": "def _request_limit_reached(exception):\n    \"\"\" Checks if exception was raised because of too many executed requests. (This is a temporal solution and\n    will be changed in later package versions.)\n\n    :param exception: Exception raised during download\n    :type exception: Exception\n    :return: True if exception is caused because too many requests were executed at once and False otherwise\n    :rtype: bool\n    \"\"\"\n    return isinstance(exception, requests.HTTPError) and \\\n        exception.response.status_code == requests.status_codes.codes.TOO_MANY_REQUESTS", "code_tokens": "def _request_limit_reached ( exception ) : return isinstance ( exception , requests . HTTPError ) and exception . response . status_code == requests . status_codes . codes . TOO_MANY_REQUESTS", "docstring_tokens": "Checks if exception was raised because of too many executed requests . ( This is a temporal solution and will be changed in later package versions . )", "label": 0}, {"idx": "cosqa-train-3301", "doc": "how to make sure a matrix is float in python", "code": "def is_float_array(val):\n    \"\"\"\n    Checks whether a variable is a numpy float array.\n\n    Parameters\n    ----------\n    val\n        The variable to check.\n\n    Returns\n    -------\n    bool\n        True if the variable is a numpy float array. Otherwise False.\n\n    \"\"\"\n    return is_np_array(val) and issubclass(val.dtype.type, np.floating)", "code_tokens": "def is_float_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . floating )", "docstring_tokens": "Checks whether a variable is a numpy float array .", "label": 0}, {"idx": "cosqa-train-3302", "doc": "python requests dictionary to query string", "code": "def dict_to_querystring(dictionary):\n    \"\"\"Converts a dict to a querystring suitable to be appended to a URL.\"\"\"\n    s = u\"\"\n    for d in dictionary.keys():\n        s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d])\n    return s[:-1]", "code_tokens": "def dict_to_querystring ( dictionary ) : s = u\"\" for d in dictionary . keys ( ) : s = unicode . format ( u\"{0}{1}={2}&\" , s , d , dictionary [ d ] ) return s [ : - 1 ]", "docstring_tokens": "Converts a dict to a querystring suitable to be appended to a URL .", "label": 0}, {"idx": "cosqa-train-3303", "doc": "how to make the root default loggingtimedrotatingfilehandler python", "code": "def init_rotating_logger(level, logfile, max_files, max_bytes):\n  \"\"\"Initializes a rotating logger\n\n  It also makes sure that any StreamHandler is removed, so as to avoid stdout/stderr\n  constipation issues\n  \"\"\"\n  logging.basicConfig()\n\n  root_logger = logging.getLogger()\n  log_format = \"[%(asctime)s] [%(levelname)s] %(filename)s: %(message)s\"\n\n  root_logger.setLevel(level)\n  handler = RotatingFileHandler(logfile, maxBytes=max_bytes, backupCount=max_files)\n  handler.setFormatter(logging.Formatter(fmt=log_format, datefmt=date_format))\n  root_logger.addHandler(handler)\n\n  for handler in root_logger.handlers:\n    root_logger.debug(\"Associated handlers - \" + str(handler))\n    if isinstance(handler, logging.StreamHandler):\n      root_logger.debug(\"Removing StreamHandler: \" + str(handler))\n      root_logger.handlers.remove(handler)", "code_tokens": "def init_rotating_logger ( level , logfile , max_files , max_bytes ) : logging . basicConfig ( ) root_logger = logging . getLogger ( ) log_format = \"[%(asctime)s] [%(levelname)s] %(filename)s: %(message)s\" root_logger . setLevel ( level ) handler = RotatingFileHandler ( logfile , maxBytes = max_bytes , backupCount = max_files ) handler . setFormatter ( logging . Formatter ( fmt = log_format , datefmt = date_format ) ) root_logger . addHandler ( handler ) for handler in root_logger . handlers : root_logger . debug ( \"Associated handlers - \" + str ( handler ) ) if isinstance ( handler , logging . StreamHandler ) : root_logger . debug ( \"Removing StreamHandler: \" + str ( handler ) ) root_logger . handlers . remove ( handler )", "docstring_tokens": "Initializes a rotating logger", "label": 1}, {"idx": "cosqa-train-3304", "doc": "python requests do not log all connections", "code": "def _log_disconnect(self):\n        \"\"\" Decrement connection count \"\"\"\n        if self.logged:\n            self.server.stats.connectionClosed()\n            self.logged = False", "code_tokens": "def _log_disconnect ( self ) : if self . logged : self . server . stats . connectionClosed ( ) self . logged = False", "docstring_tokens": "Decrement connection count", "label": 0}, {"idx": "cosqa-train-3305", "doc": "how to measur length of strings in python", "code": "def display_len(text):\n    \"\"\"\n    Get the display length of a string. This can differ from the character\n    length if the string contains wide characters.\n    \"\"\"\n    text = unicodedata.normalize('NFD', text)\n    return sum(char_width(char) for char in text)", "code_tokens": "def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )", "docstring_tokens": "Get the display length of a string . This can differ from the character length if the string contains wide characters .", "label": 1}, {"idx": "cosqa-train-3306", "doc": "python requests how to download a zip file", "code": "def download_sdk(url):\n    \"\"\"Downloads the SDK and returns a file-like object for the zip content.\"\"\"\n    r = requests.get(url)\n    r.raise_for_status()\n    return StringIO(r.content)", "code_tokens": "def download_sdk ( url ) : r = requests . get ( url ) r . raise_for_status ( ) return StringIO ( r . content )", "docstring_tokens": "Downloads the SDK and returns a file - like object for the zip content .", "label": 0}, {"idx": "cosqa-train-3307", "doc": "how to merge to dictionaries together in python", "code": "def merge_dict(data, *args):\n    \"\"\"Merge any number of dictionaries\n    \"\"\"\n    results = {}\n    for current in (data,) + args:\n        results.update(current)\n    return results", "code_tokens": "def merge_dict ( data , * args ) : results = { } for current in ( data , ) + args : results . update ( current ) return results", "docstring_tokens": "Merge any number of dictionaries", "label": 0}, {"idx": "cosqa-train-3308", "doc": "python requests params value hyphen underscore", "code": "def normalise_string(string):\n    \"\"\" Strips trailing whitespace from string, lowercases it and replaces\n        spaces with underscores\n    \"\"\"\n    string = (string.strip()).lower()\n    return re.sub(r'\\W+', '_', string)", "code_tokens": "def normalise_string ( string ) : string = ( string . strip ( ) ) . lower ( ) return re . sub ( r'\\W+' , '_' , string )", "docstring_tokens": "Strips trailing whitespace from string lowercases it and replaces spaces with underscores", "label": 0}, {"idx": "cosqa-train-3309", "doc": "how to move a file into a certain folder by matching the names of the file and folder in python", "code": "def gmove(pattern, destination):\n    \"\"\"Move all file found by glob.glob(pattern) to destination directory.\n\n    Args:\n        pattern (str): Glob pattern\n        destination (str): Path to the destination directory.\n\n    Returns:\n        bool: True if the operation is successful, False otherwise.\n    \"\"\"\n    for item in glob.glob(pattern):\n        if not move(item, destination):\n            return False\n    return True", "code_tokens": "def gmove ( pattern , destination ) : for item in glob . glob ( pattern ) : if not move ( item , destination ) : return False return True", "docstring_tokens": "Move all file found by glob . glob ( pattern ) to destination directory .", "label": 0}, {"idx": "cosqa-train-3310", "doc": "python requests thread safe gevent", "code": "def fetch_event(urls):\n    \"\"\"\n    This parallel fetcher uses gevent one uses gevent\n    \"\"\"\n    rs = (grequests.get(u) for u in urls)\n    return [content.json() for content in grequests.map(rs)]", "code_tokens": "def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]", "docstring_tokens": "This parallel fetcher uses gevent one uses gevent", "label": 0}, {"idx": "cosqa-train-3311", "doc": "how to move cursor in a circle python", "code": "def ensure_hbounds(self):\n        \"\"\"Ensure the cursor is within horizontal screen bounds.\"\"\"\n        self.cursor.x = min(max(0, self.cursor.x), self.columns - 1)", "code_tokens": "def ensure_hbounds ( self ) : self . cursor . x = min ( max ( 0 , self . cursor . x ) , self . columns - 1 )", "docstring_tokens": "Ensure the cursor is within horizontal screen bounds .", "label": 1}, {"idx": "cosqa-train-3312", "doc": "python requests url safe characters", "code": "def url_encode(url):\n    \"\"\"\n    Convert special characters using %xx escape.\n\n    :param url: str\n    :return: str - encoded url\n    \"\"\"\n    if isinstance(url, text_type):\n        url = url.encode('utf8')\n    return quote(url, ':/%?&=')", "code_tokens": "def url_encode ( url ) : if isinstance ( url , text_type ) : url = url . encode ( 'utf8' ) return quote ( url , ':/%?&=' )", "docstring_tokens": "Convert special characters using %xx escape .", "label": 1}, {"idx": "cosqa-train-3313", "doc": "python requests verify false insecurerequestwarnig", "code": "def disable_insecure_request_warning():\n    \"\"\"Suppress warning about untrusted SSL certificate.\"\"\"\n    import requests\n    from requests.packages.urllib3.exceptions import InsecureRequestWarning\n    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)", "code_tokens": "def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )", "docstring_tokens": "Suppress warning about untrusted SSL certificate .", "label": 0}, {"idx": "cosqa-train-3314", "doc": "how to normalize matrix data python", "code": "def _normalize_abmn(abmn):\n    \"\"\"return a normalized version of abmn\n    \"\"\"\n    abmn_2d = np.atleast_2d(abmn)\n    abmn_normalized = np.hstack((\n        np.sort(abmn_2d[:, 0:2], axis=1),\n        np.sort(abmn_2d[:, 2:4], axis=1),\n    ))\n    return abmn_normalized", "code_tokens": "def _normalize_abmn ( abmn ) : abmn_2d = np . atleast_2d ( abmn ) abmn_normalized = np . hstack ( ( np . sort ( abmn_2d [ : , 0 : 2 ] , axis = 1 ) , np . sort ( abmn_2d [ : , 2 : 4 ] , axis = 1 ) , ) ) return abmn_normalized", "docstring_tokens": "return a normalized version of abmn", "label": 0}, {"idx": "cosqa-train-3315", "doc": "python resize image and maintain aspect ration", "code": "def resize_image_to_fit_width(image, dest_w):\n    \"\"\"\n    Resize and image to fit the passed in width, keeping the aspect ratio the same\n\n    :param image: PIL.Image\n    :param dest_w: The desired width\n    \"\"\"\n    scale_factor = dest_w / image.size[0]\n    dest_h = image.size[1] * scale_factor\n    \n    scaled_image = image.resize((int(dest_w), int(dest_h)), PIL.Image.ANTIALIAS)\n\n    return scaled_image", "code_tokens": "def resize_image_to_fit_width ( image , dest_w ) : scale_factor = dest_w / image . size [ 0 ] dest_h = image . size [ 1 ] * scale_factor scaled_image = image . resize ( ( int ( dest_w ) , int ( dest_h ) ) , PIL . Image . ANTIALIAS ) return scaled_image", "docstring_tokens": "Resize and image to fit the passed in width keeping the aspect ratio the same", "label": 0}, {"idx": "cosqa-train-3316", "doc": "how to obtin decimals in python", "code": "def price_rounding(price, decimals=2):\n    \"\"\"Takes a decimal price and rounds to a number of decimal places\"\"\"\n    try:\n        exponent = D('.' + decimals * '0')\n    except InvalidOperation:\n        # Currencies with no decimal places, ex. JPY, HUF\n        exponent = D()\n    return price.quantize(exponent, rounding=ROUND_UP)", "code_tokens": "def price_rounding ( price , decimals = 2 ) : try : exponent = D ( '.' + decimals * '0' ) except InvalidOperation : # Currencies with no decimal places, ex. JPY, HUF exponent = D ( ) return price . quantize ( exponent , rounding = ROUND_UP )", "docstring_tokens": "Takes a decimal price and rounds to a number of decimal places", "label": 0}, {"idx": "cosqa-train-3317", "doc": "python resize image keep aspect ratio", "code": "def resize_image_to_fit_width(image, dest_w):\n    \"\"\"\n    Resize and image to fit the passed in width, keeping the aspect ratio the same\n\n    :param image: PIL.Image\n    :param dest_w: The desired width\n    \"\"\"\n    scale_factor = dest_w / image.size[0]\n    dest_h = image.size[1] * scale_factor\n    \n    scaled_image = image.resize((int(dest_w), int(dest_h)), PIL.Image.ANTIALIAS)\n\n    return scaled_image", "code_tokens": "def resize_image_to_fit_width ( image , dest_w ) : scale_factor = dest_w / image . size [ 0 ] dest_h = image . size [ 1 ] * scale_factor scaled_image = image . resize ( ( int ( dest_w ) , int ( dest_h ) ) , PIL . Image . ANTIALIAS ) return scaled_image", "docstring_tokens": "Resize and image to fit the passed in width keeping the aspect ratio the same", "label": 1}, {"idx": "cosqa-train-3318", "doc": "how to order features alphabetically in python", "code": "def get_feature_order(dataset, features):\n    \"\"\" Returns a list with the order that features requested appear in\n    dataset \"\"\"\n    all_features = dataset.get_feature_names()\n\n    i = [all_features.index(f) for f in features]\n\n    return i", "code_tokens": "def get_feature_order ( dataset , features ) : all_features = dataset . get_feature_names ( ) i = [ all_features . index ( f ) for f in features ] return i", "docstring_tokens": "Returns a list with the order that features requested appear in dataset", "label": 0}, {"idx": "cosqa-train-3319", "doc": "python response json load", "code": "def process_response(self, response):\n        \"\"\"\n        Load a JSON response.\n\n        :param Response response: The HTTP response.\n        :return dict: The JSON-loaded content.\n        \"\"\"\n        if response.status_code != 200:\n            raise TwilioException('Unable to fetch page', response)\n\n        return json.loads(response.text)", "code_tokens": "def process_response ( self , response ) : if response . status_code != 200 : raise TwilioException ( 'Unable to fetch page' , response ) return json . loads ( response . text )", "docstring_tokens": "Load a JSON response .", "label": 0}, {"idx": "cosqa-train-3320", "doc": "how to pad in python", "code": "def _pad(self, text):\n        \"\"\"Pad the text.\"\"\"\n        top_bottom = (\"\\n\" * self._padding) + \" \"\n        right_left = \" \" * self._padding * self.PAD_WIDTH\n        return top_bottom + right_left + text + right_left + top_bottom", "code_tokens": "def _pad ( self , text ) : top_bottom = ( \"\\n\" * self . _padding ) + \" \" right_left = \" \" * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom", "docstring_tokens": "Pad the text .", "label": 0}, {"idx": "cosqa-train-3321", "doc": "python rest 403 forbidden", "code": "def HttpResponse403(request, template=KEY_AUTH_403_TEMPLATE,\ncontent=KEY_AUTH_403_CONTENT, content_type=KEY_AUTH_403_CONTENT_TYPE):\n    \"\"\"\n    HTTP response for forbidden access (status code 403)\n    \"\"\"\n    return AccessFailedResponse(request, template, content, content_type, status=403)", "code_tokens": "def HttpResponse403 ( request , template = KEY_AUTH_403_TEMPLATE , content = KEY_AUTH_403_CONTENT , content_type = KEY_AUTH_403_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 403 )", "docstring_tokens": "HTTP response for forbidden access ( status code 403 )", "label": 0}, {"idx": "cosqa-train-3322", "doc": "how to pass a pythonfile to every testcase in pytest", "code": "def run_tests(self):\n\t\t\"\"\"\n\t\tInvoke pytest, replacing argv. Return result code.\n\t\t\"\"\"\n\t\twith _save_argv(_sys.argv[:1] + self.addopts):\n\t\t\tresult_code = __import__('pytest').main()\n\t\t\tif result_code:\n\t\t\t\traise SystemExit(result_code)", "code_tokens": "def run_tests ( self ) : with _save_argv ( _sys . argv [ : 1 ] + self . addopts ) : result_code = __import__ ( 'pytest' ) . main ( ) if result_code : raise SystemExit ( result_code )", "docstring_tokens": "Invoke pytest replacing argv . Return result code .", "label": 0}, {"idx": "cosqa-train-3323", "doc": "python restart an iterator", "code": "def _fill(self):\n    \"\"\"Advance the iterator without returning the old head.\"\"\"\n    try:\n      self._head = self._iterable.next()\n    except StopIteration:\n      self._head = None", "code_tokens": "def _fill ( self ) : try : self . _head = self . _iterable . next ( ) except StopIteration : self . _head = None", "docstring_tokens": "Advance the iterator without returning the old head .", "label": 0}, {"idx": "cosqa-train-3324", "doc": "how to pass the corpus files to tfidfvectorizer to vectorize in python", "code": "def encode_dataset(dataset, vocabulary):\n  \"\"\"Encode from strings to token ids.\n\n  Args:\n    dataset: a tf.data.Dataset with string values.\n    vocabulary: a mesh_tensorflow.transformer.Vocabulary\n  Returns:\n    a tf.data.Dataset with integer-vector values ending in EOS=1\n  \"\"\"\n  def encode(features):\n    return {k: vocabulary.encode_tf(v) for k, v in features.items()}\n  return dataset.map(encode, num_parallel_calls=tf.data.experimental.AUTOTUNE)", "code_tokens": "def encode_dataset ( dataset , vocabulary ) : def encode ( features ) : return { k : vocabulary . encode_tf ( v ) for k , v in features . items ( ) } return dataset . map ( encode , num_parallel_calls = tf . data . experimental . AUTOTUNE )", "docstring_tokens": "Encode from strings to token ids .", "label": 0}, {"idx": "cosqa-train-3325", "doc": "python restrict methods to certain objects", "code": "def __get__(self, obj, objtype):\n        if not self.is_method:\n            self.is_method = True\n        \"\"\"Support instance methods.\"\"\"\n        return functools.partial(self.__call__, obj)", "code_tokens": "def __get__ ( self , obj , objtype ) : if not self . is_method : self . is_method = True return functools . partial ( self . __call__ , obj )", "docstring_tokens": "Support instance methods .", "label": 0}, {"idx": "cosqa-train-3326", "doc": "how to perform element wise multiplication of a matrix in python", "code": "def matrixTimesVector(MM, aa):\n    \"\"\"\n\n    :param MM: A matrix of size 3x3\n    :param aa: A vector of size 3\n    :return: A vector of size 3 which is the product of the matrix by the vector\n    \"\"\"\n    bb = np.zeros(3, np.float)\n    for ii in range(3):\n        bb[ii] = np.sum(MM[ii, :] * aa)\n    return bb", "code_tokens": "def matrixTimesVector ( MM , aa ) : bb = np . zeros ( 3 , np . float ) for ii in range ( 3 ) : bb [ ii ] = np . sum ( MM [ ii , : ] * aa ) return bb", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-3327", "doc": "python retrieve own ip", "code": "def get_own_ip():\n    \"\"\"Get the host's ip number.\n    \"\"\"\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    try:\n        sock.connect((\"8.8.8.8\", 80))\n    except socket.gaierror:\n        ip_ = \"127.0.0.1\"\n    else:\n        ip_ = sock.getsockname()[0]\n    finally:\n        sock.close()\n    return ip_", "code_tokens": "def get_own_ip ( ) : sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) try : sock . connect ( ( \"8.8.8.8\" , 80 ) ) except socket . gaierror : ip_ = \"127.0.0.1\" else : ip_ = sock . getsockname ( ) [ 0 ] finally : sock . close ( ) return ip_", "docstring_tokens": "Get the host s ip number .", "label": 0}, {"idx": "cosqa-train-3328", "doc": "how to perform if function once python", "code": "def execute_only_once():\n    \"\"\"\n    Each called in the code to this function is guaranteed to return True the\n    first time and False afterwards.\n\n    Returns:\n        bool: whether this is the first time this function gets called from this line of code.\n\n    Example:\n        .. code-block:: python\n\n            if execute_only_once():\n                # do something only once\n    \"\"\"\n    f = inspect.currentframe().f_back\n    ident = (f.f_code.co_filename, f.f_lineno)\n    if ident in _EXECUTE_HISTORY:\n        return False\n    _EXECUTE_HISTORY.add(ident)\n    return True", "code_tokens": "def execute_only_once ( ) : f = inspect . currentframe ( ) . f_back ident = ( f . f_code . co_filename , f . f_lineno ) if ident in _EXECUTE_HISTORY : return False _EXECUTE_HISTORY . add ( ident ) return True", "docstring_tokens": "Each called in the code to this function is guaranteed to return True the first time and False afterwards .", "label": 0}, {"idx": "cosqa-train-3329", "doc": "python retunr index of all items that matach a pattern in a list", "code": "def where_is(strings, pattern, n=1, lookup_func=re.match):\n    \"\"\"Return index of the nth match found of pattern in strings\n\n    Parameters\n    ----------\n    strings: list of str\n        List of strings\n\n    pattern: str\n        Pattern to be matched\n\n    nth: int\n        Number of times the match must happen to return the item index.\n\n    lookup_func: callable\n        Function to match each item in strings to the pattern, e.g., re.match or re.search.\n\n    Returns\n    -------\n    index: int\n        Index of the nth item that matches the pattern.\n        If there are no n matches will return -1\n    \"\"\"\n    count = 0\n    for idx, item in enumerate(strings):\n        if lookup_func(pattern, item):\n            count += 1\n            if count == n:\n                return idx\n    return -1", "code_tokens": "def where_is ( strings , pattern , n = 1 , lookup_func = re . match ) : count = 0 for idx , item in enumerate ( strings ) : if lookup_func ( pattern , item ) : count += 1 if count == n : return idx return - 1", "docstring_tokens": "Return index of the nth match found of pattern in strings", "label": 1}, {"idx": "cosqa-train-3330", "doc": "how to plot a distribution plot python", "code": "def plot(self):\n        \"\"\"Plot the empirical histogram versus best-fit distribution's PDF.\"\"\"\n        plt.plot(self.bin_edges, self.hist, self.bin_edges, self.best_pdf)", "code_tokens": "def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )", "docstring_tokens": "Plot the empirical histogram versus best - fit distribution s PDF .", "label": 0}, {"idx": "cosqa-train-3331", "doc": "python return all info in a dict", "code": "def conv_dict(self):\n        \"\"\"dictionary of conversion\"\"\"\n        return dict(integer=self.integer, real=self.real, no_type=self.no_type)", "code_tokens": "def conv_dict ( self ) : return dict ( integer = self . integer , real = self . real , no_type = self . no_type )", "docstring_tokens": "dictionary of conversion", "label": 1}, {"idx": "cosqa-train-3332", "doc": "how to plot a standard deviation of a list python", "code": "def sem(inlist):\n    \"\"\"\nReturns the estimated standard error of the mean (sx-bar) of the\nvalues in the passed list.  sem = stdev / sqrt(n)\n\nUsage:   lsem(inlist)\n\"\"\"\n    sd = stdev(inlist)\n    n = len(inlist)\n    return sd / math.sqrt(n)", "code_tokens": "def sem ( inlist ) : sd = stdev ( inlist ) n = len ( inlist ) return sd / math . sqrt ( n )", "docstring_tokens": "Returns the estimated standard error of the mean ( sx - bar ) of the values in the passed list . sem = stdev / sqrt ( n )", "label": 0}, {"idx": "cosqa-train-3333", "doc": "python return ancestors of node", "code": "def unwind(self):\n        \"\"\" Get a list of all ancestors in descending order of level, including a new instance  of self\n        \"\"\"\n        return [ QuadKey(self.key[:l+1]) for l in reversed(range(len(self.key))) ]", "code_tokens": "def unwind ( self ) : return [ QuadKey ( self . key [ : l + 1 ] ) for l in reversed ( range ( len ( self . key ) ) ) ]", "docstring_tokens": "Get a list of all ancestors in descending order of level including a new instance of self", "label": 0}, {"idx": "cosqa-train-3334", "doc": "how to plot distribution python", "code": "def plot(self):\n        \"\"\"Plot the empirical histogram versus best-fit distribution's PDF.\"\"\"\n        plt.plot(self.bin_edges, self.hist, self.bin_edges, self.best_pdf)", "code_tokens": "def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )", "docstring_tokens": "Plot the empirical histogram versus best - fit distribution s PDF .", "label": 0}, {"idx": "cosqa-train-3335", "doc": "python return index of closest value", "code": "def closest(xarr, val):\n    \"\"\" Return the index of the closest in xarr to value val \"\"\"\n    idx_closest = np.argmin(np.abs(np.array(xarr) - val))\n    return idx_closest", "code_tokens": "def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest", "docstring_tokens": "Return the index of the closest in xarr to value val", "label": 0}, {"idx": "cosqa-train-3336", "doc": "how to plot line from array in python", "code": "def polyline(self, arr):\n        \"\"\"Draw a set of lines\"\"\"\n        for i in range(0, len(arr) - 1):\n            self.line(arr[i][0], arr[i][1], arr[i + 1][0], arr[i + 1][1])", "code_tokens": "def polyline ( self , arr ) : for i in range ( 0 , len ( arr ) - 1 ) : self . line ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] , arr [ i + 1 ] [ 0 ] , arr [ i + 1 ] [ 1 ] )", "docstring_tokens": "Draw a set of lines", "label": 0}, {"idx": "cosqa-train-3337", "doc": "python return index of series", "code": "def series_index(self, series):\n        \"\"\"\n        Return the integer index of *series* in this sequence.\n        \"\"\"\n        for idx, s in enumerate(self):\n            if series is s:\n                return idx\n        raise ValueError('series not in chart data object')", "code_tokens": "def series_index ( self , series ) : for idx , s in enumerate ( self ) : if series is s : return idx raise ValueError ( 'series not in chart data object' )", "docstring_tokens": "Return the integer index of * series * in this sequence .", "label": 0}, {"idx": "cosqa-train-3338", "doc": "how to post something in python to a api", "code": "def make_post_request(self, url, auth, json_payload):\n        \"\"\"This function executes the request with the provided\n        json payload and return the json response\"\"\"\n        response = requests.post(url, auth=auth, json=json_payload)\n        return response.json()", "code_tokens": "def make_post_request ( self , url , auth , json_payload ) : response = requests . post ( url , auth = auth , json = json_payload ) return response . json ( )", "docstring_tokens": "This function executes the request with the provided json payload and return the json response", "label": 0}, {"idx": "cosqa-train-3339", "doc": "python return middle index a list", "code": "def bisect_index(a, x):\n    \"\"\" Find the leftmost index of an element in a list using binary search.\n\n    Parameters\n    ----------\n    a: list\n        A sorted list.\n    x: arbitrary\n        The element.\n\n    Returns\n    -------\n    int\n        The index.\n\n    \"\"\"\n    i = bisect.bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    raise ValueError", "code_tokens": "def bisect_index ( a , x ) : i = bisect . bisect_left ( a , x ) if i != len ( a ) and a [ i ] == x : return i raise ValueError", "docstring_tokens": "Find the leftmost index of an element in a list using binary search .", "label": 0}, {"idx": "cosqa-train-3340", "doc": "how to print a json in a formatted manner with python", "code": "def prettyprint(d):\n        \"\"\"Print dicttree in Json-like format. keys are sorted\n        \"\"\"\n        print(json.dumps(d, sort_keys=True, \n                         indent=4, separators=(\",\" , \": \")))", "code_tokens": "def prettyprint ( d ) : print ( json . dumps ( d , sort_keys = True , indent = 4 , separators = ( \",\" , \": \" ) ) )", "docstring_tokens": "Print dicttree in Json - like format . keys are sorted", "label": 0}, {"idx": "cosqa-train-3341", "doc": "python return tuple from function show nothing", "code": "def print(*a):\n    \"\"\" print just one that returns what you give it instead of None \"\"\"\n    try:\n        _print(*a)\n        return a[0] if len(a) == 1 else a\n    except:\n        _print(*a)", "code_tokens": "def print ( * a ) : try : _print ( * a ) return a [ 0 ] if len ( a ) == 1 else a except : _print ( * a )", "docstring_tokens": "print just one that returns what you give it instead of None", "label": 0}, {"idx": "cosqa-train-3342", "doc": "python returns number of days for month/year pair", "code": "def _days_in_month(date):\n    \"\"\"The number of days in the month of the given date\"\"\"\n    if date.month == 12:\n        reference = type(date)(date.year + 1, 1, 1)\n    else:\n        reference = type(date)(date.year, date.month + 1, 1)\n    return (reference - timedelta(days=1)).day", "code_tokens": "def _days_in_month ( date ) : if date . month == 12 : reference = type ( date ) ( date . year + 1 , 1 , 1 ) else : reference = type ( date ) ( date . year , date . month + 1 , 1 ) return ( reference - timedelta ( days = 1 ) ) . day", "docstring_tokens": "The number of days in the month of the given date", "label": 0}, {"idx": "cosqa-train-3343", "doc": "how to print hours minutes seconds python", "code": "def pprint(self, seconds):\n        \"\"\"\n        Pretty Prints seconds as Hours:Minutes:Seconds.MilliSeconds\n\n        :param seconds:  The time in seconds.\n        \"\"\"\n        return (\"%d:%02d:%02d.%03d\", reduce(lambda ll, b: divmod(ll[0], b) + ll[1:], [(seconds * 1000,), 1000, 60, 60]))", "code_tokens": "def pprint ( self , seconds ) : return ( \"%d:%02d:%02d.%03d\" , reduce ( lambda ll , b : divmod ( ll [ 0 ] , b ) + ll [ 1 : ] , [ ( seconds * 1000 , ) , 1000 , 60 , 60 ] ) )", "docstring_tokens": "Pretty Prints seconds as Hours : Minutes : Seconds . MilliSeconds", "label": 0}, {"idx": "cosqa-train-3344", "doc": "python reverse iterator index", "code": "def index(self, elem):\n        \"\"\"Find the index of elem in the reversed iterator.\"\"\"\n        return _coconut.len(self._iter) - self._iter.index(elem) - 1", "code_tokens": "def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1", "docstring_tokens": "Find the index of elem in the reversed iterator .", "label": 0}, {"idx": "cosqa-train-3345", "doc": "how to print message error in python tkinter", "code": "def error(*args):\n    \"\"\"Display error message via stderr or GUI.\"\"\"\n    if sys.stdin.isatty():\n        print('ERROR:', *args, file=sys.stderr)\n    else:\n        notify_error(*args)", "code_tokens": "def error ( * args ) : if sys . stdin . isatty ( ) : print ( 'ERROR:' , * args , file = sys . stderr ) else : notify_error ( * args )", "docstring_tokens": "Display error message via stderr or GUI .", "label": 0}, {"idx": "cosqa-train-3346", "doc": "python roc auc sklearn", "code": "def roc_auc(y_true, y_score):\n    \"\"\"\n    Returns are under the ROC curve\n    \"\"\"\n    notnull = ~np.isnan(y_true)\n    fpr, tpr, thresholds = sklearn.metrics.roc_curve(y_true[notnull], y_score[notnull])\n    return sklearn.metrics.auc(fpr, tpr)", "code_tokens": "def roc_auc ( y_true , y_score ) : notnull = ~ np . isnan ( y_true ) fpr , tpr , thresholds = sklearn . metrics . roc_curve ( y_true [ notnull ] , y_score [ notnull ] ) return sklearn . metrics . auc ( fpr , tpr )", "docstring_tokens": "Returns are under the ROC curve", "label": 0}, {"idx": "cosqa-train-3347", "doc": "how to print stack trace error in python", "code": "def format_exception(e):\n    \"\"\"Returns a string containing the type and text of the exception.\n\n    \"\"\"\n    from .utils.printing import fill\n    return '\\n'.join(fill(line) for line in traceback.format_exception_only(type(e), e))", "code_tokens": "def format_exception ( e ) : from . utils . printing import fill return '\\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )", "docstring_tokens": "Returns a string containing the type and text of the exception .", "label": 0}, {"idx": "cosqa-train-3348", "doc": "python rotate 2d array 90 degrees", "code": "def rotateImage(image, angle):\n    \"\"\"\n        rotates a 2d array to a multiple of 90 deg.\n        0 = default\n        1 = 90 deg. cw\n        2 = 180 deg.\n        3 = 90 deg. ccw\n    \"\"\"\n    image = [list(row) for row in image]\n\n    for n in range(angle % 4):\n        image = list(zip(*image[::-1]))\n\n    return image", "code_tokens": "def rotateImage ( image , angle ) : image = [ list ( row ) for row in image ] for n in range ( angle % 4 ) : image = list ( zip ( * image [ : : - 1 ] ) ) return image", "docstring_tokens": "rotates a 2d array to a multiple of 90 deg . 0 = default 1 = 90 deg . cw 2 = 180 deg . 3 = 90 deg . ccw", "label": 0}, {"idx": "cosqa-train-3349", "doc": "how to print text in color for python", "code": "def printc(cls, txt, color=colors.red):\n        \"\"\"Print in color.\"\"\"\n        print(cls.color_txt(txt, color))", "code_tokens": "def printc ( cls , txt , color = colors . red ) : print ( cls . color_txt ( txt , color ) )", "docstring_tokens": "Print in color .", "label": 0}, {"idx": "cosqa-train-3350", "doc": "python round adding digit", "code": "def get_rounded(self, digits):\n        \"\"\" Return a vector with the elements rounded to the given number of digits. \"\"\"\n        result = self.copy()\n        result.round(digits)\n        return result", "code_tokens": "def get_rounded ( self , digits ) : result = self . copy ( ) result . round ( digits ) return result", "docstring_tokens": "Return a vector with the elements rounded to the given number of digits .", "label": 0}, {"idx": "cosqa-train-3351", "doc": "how to print the error returned by python", "code": "def clean_error(err):\n    \"\"\"\n    Take stderr bytes returned from MicroPython and attempt to create a\n    non-verbose error message.\n    \"\"\"\n    if err:\n        decoded = err.decode('utf-8')\n        try:\n            return decoded.split('\\r\\n')[-2]\n        except Exception:\n            return decoded\n    return 'There was an error.'", "code_tokens": "def clean_error ( err ) : if err : decoded = err . decode ( 'utf-8' ) try : return decoded . split ( '\\r\\n' ) [ - 2 ] except Exception : return decoded return 'There was an error.'", "docstring_tokens": "Take stderr bytes returned from MicroPython and attempt to create a non - verbose error message .", "label": 0}, {"idx": "cosqa-train-3352", "doc": "python rpc not response", "code": "def parse_response(self, resp):\n        \"\"\"\n        Parse the xmlrpc response.\n        \"\"\"\n        p, u = self.getparser()\n        p.feed(resp.content)\n        p.close()\n        return u.close()", "code_tokens": "def parse_response ( self , resp ) : p , u = self . getparser ( ) p . feed ( resp . content ) p . close ( ) return u . close ( )", "docstring_tokens": "Parse the xmlrpc response .", "label": 0}, {"idx": "cosqa-train-3353", "doc": "how to pull up reference id in python", "code": "def get_obj(ref):\n    \"\"\"Get object from string reference.\"\"\"\n    oid = int(ref)\n    return server.id2ref.get(oid) or server.id2obj[oid]", "code_tokens": "def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]", "docstring_tokens": "Get object from string reference .", "label": 0}, {"idx": "cosqa-train-3354", "doc": "how to put a image as a background python", "code": "def copy_image_on_background(image, color=WHITE):\n    \"\"\"\n    Create a new image by copying the image on a *color* background.\n\n    Args:\n        image (PIL.Image.Image): Image to copy\n        color (tuple): Background color usually WHITE or BLACK\n\n    Returns:\n        PIL.Image.Image\n\n    \"\"\"\n    background = Image.new(\"RGB\", image.size, color)\n    background.paste(image, mask=image.split()[3])\n    return background", "code_tokens": "def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( \"RGB\" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background", "docstring_tokens": "Create a new image by copying the image on a * color * background .", "label": 0}, {"idx": "cosqa-train-3355", "doc": "python s3client to s3resources", "code": "def s3(ctx, bucket_name, data_file, region):\n    \"\"\"Use the S3 SWAG backend.\"\"\"\n    if not ctx.data_file:\n        ctx.data_file = data_file\n\n    if not ctx.bucket_name:\n        ctx.bucket_name = bucket_name\n\n    if not ctx.region:\n        ctx.region = region\n\n    ctx.type = 's3'", "code_tokens": "def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'", "docstring_tokens": "Use the S3 SWAG backend .", "label": 0}, {"idx": "cosqa-train-3356", "doc": "how to put all sql columns in a list python", "code": "def select_fields_as_sql(self):\n        \"\"\"\n        Returns the selected fields or expressions as a SQL string.\n        \"\"\"\n        return comma_join(list(self._fields) + ['%s AS %s' % (v, k) for k, v in self._calculated_fields.items()])", "code_tokens": "def select_fields_as_sql ( self ) : return comma_join ( list ( self . _fields ) + [ '%s AS %s' % ( v , k ) for k , v in self . _calculated_fields . items ( ) ] )", "docstring_tokens": "Returns the selected fields or expressions as a SQL string .", "label": 0}, {"idx": "cosqa-train-3357", "doc": "python sanic child process not kill", "code": "def kill_mprocess(process):\n    \"\"\"kill process\n    Args:\n        process - Popen object for process\n    \"\"\"\n    if process and proc_alive(process):\n        process.terminate()\n        process.communicate()\n    return not proc_alive(process)", "code_tokens": "def kill_mprocess ( process ) : if process and proc_alive ( process ) : process . terminate ( ) process . communicate ( ) return not proc_alive ( process )", "docstring_tokens": "kill process Args : process - Popen object for process", "label": 1}, {"idx": "cosqa-train-3358", "doc": "how to put tokens into sentence python", "code": "def sent2features(sentence, template):\n    \"\"\" extract features in a sentence\n\n    :type sentence: list of token, each token is a list of tag\n    \"\"\"\n    return [word2features(sentence, i, template) for i in range(len(sentence))]", "code_tokens": "def sent2features ( sentence , template ) : return [ word2features ( sentence , i , template ) for i in range ( len ( sentence ) ) ]", "docstring_tokens": "extract features in a sentence", "label": 1}, {"idx": "cosqa-train-3359", "doc": "python save file portability", "code": "def pickle_save(thing,fname):\n    \"\"\"save something to a pickle file\"\"\"\n    pickle.dump(thing, open(fname,\"wb\"),pickle.HIGHEST_PROTOCOL)\n    return thing", "code_tokens": "def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , \"wb\" ) , pickle . HIGHEST_PROTOCOL ) return thing", "docstring_tokens": "save something to a pickle file", "label": 0}, {"idx": "cosqa-train-3360", "doc": "how to randomize the objects in a list python", "code": "def get_randomized_guid_sample(self, item_count):\n        \"\"\" Fetch a subset of randomzied GUIDs from the whitelist \"\"\"\n        dataset = self.get_whitelist()\n        random.shuffle(dataset)\n        return dataset[:item_count]", "code_tokens": "def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]", "docstring_tokens": "Fetch a subset of randomzied GUIDs from the whitelist", "label": 0}, {"idx": "cosqa-train-3361", "doc": "how to randomly choose one element from array python", "code": "def downsample(array, k):\n    \"\"\"Choose k random elements of array.\"\"\"\n    length = array.shape[0]\n    indices = random.sample(xrange(length), k)\n    return array[indices]", "code_tokens": "def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]", "docstring_tokens": "Choose k random elements of array .", "label": 1}, {"idx": "cosqa-train-3362", "doc": "python savefig do no show figure", "code": "def plot_and_save(self, **kwargs):\n        \"\"\"Used when the plot method defined does not create a figure nor calls save_plot\n        Then the plot method has to use self.fig\"\"\"\n        self.fig = pyplot.figure()\n        self.plot()\n        self.axes = pyplot.gca()\n        self.save_plot(self.fig, self.axes, **kwargs)\n        pyplot.close(self.fig)", "code_tokens": "def plot_and_save ( self , * * kwargs ) : self . fig = pyplot . figure ( ) self . plot ( ) self . axes = pyplot . gca ( ) self . save_plot ( self . fig , self . axes , * * kwargs ) pyplot . close ( self . fig )", "docstring_tokens": "Used when the plot method defined does not create a figure nor calls save_plot Then the plot method has to use self . fig", "label": 0}, {"idx": "cosqa-train-3363", "doc": "how to read data using url in python", "code": "def get(url):\n    \"\"\"Recieving the JSON file from uulm\"\"\"\n    response = urllib.request.urlopen(url)\n    data = response.read()\n    data = data.decode(\"utf-8\")\n    data = json.loads(data)\n    return data", "code_tokens": "def get ( url ) : response = urllib . request . urlopen ( url ) data = response . read ( ) data = data . decode ( \"utf-8\" ) data = json . loads ( data ) return data", "docstring_tokens": "Recieving the JSON file from uulm", "label": 0}, {"idx": "cosqa-train-3364", "doc": "python saving dictonary to file json", "code": "def save(self, fname):\n        \"\"\" Saves the dictionary in json format\n        :param fname: file to save to\n        \"\"\"\n        with open(fname, 'wb') as f:\n            json.dump(self, f)", "code_tokens": "def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )", "docstring_tokens": "Saves the dictionary in json format : param fname : file to save to", "label": 0}, {"idx": "cosqa-train-3365", "doc": "how to read file in chunks and write in chunks in python", "code": "def iterate_chunks(file, chunk_size):\n    \"\"\"\n    Iterate chunks of size chunk_size from a file-like object\n    \"\"\"\n    chunk = file.read(chunk_size)\n    while chunk:\n        yield chunk\n        chunk = file.read(chunk_size)", "code_tokens": "def iterate_chunks ( file , chunk_size ) : chunk = file . read ( chunk_size ) while chunk : yield chunk chunk = file . read ( chunk_size )", "docstring_tokens": "Iterate chunks of size chunk_size from a file - like object", "label": 0}, {"idx": "cosqa-train-3366", "doc": "python saving figure as svg", "code": "def fig2x(figure, format):\n    \"\"\"Returns svg from matplotlib chart\"\"\"\n\n    # Save svg to file like object svg_io\n    io = StringIO()\n    figure.savefig(io, format=format)\n\n    # Rewind the file like object\n    io.seek(0)\n\n    data = io.getvalue()\n    io.close()\n\n    return data", "code_tokens": "def fig2x ( figure , format ) : # Save svg to file like object svg_io io = StringIO ( ) figure . savefig ( io , format = format ) # Rewind the file like object io . seek ( 0 ) data = io . getvalue ( ) io . close ( ) return data", "docstring_tokens": "Returns svg from matplotlib chart", "label": 1}, {"idx": "cosqa-train-3367", "doc": "how to read python error", "code": "def clean_error(err):\n    \"\"\"\n    Take stderr bytes returned from MicroPython and attempt to create a\n    non-verbose error message.\n    \"\"\"\n    if err:\n        decoded = err.decode('utf-8')\n        try:\n            return decoded.split('\\r\\n')[-2]\n        except Exception:\n            return decoded\n    return 'There was an error.'", "code_tokens": "def clean_error ( err ) : if err : decoded = err . decode ( 'utf-8' ) try : return decoded . split ( '\\r\\n' ) [ - 2 ] except Exception : return decoded return 'There was an error.'", "docstring_tokens": "Take stderr bytes returned from MicroPython and attempt to create a non - verbose error message .", "label": 0}, {"idx": "cosqa-train-3368", "doc": "python says list is string", "code": "def validate_string_list(lst):\n    \"\"\"Validate that the input is a list of strings.\n\n    Raises ValueError if not.\"\"\"\n    if not isinstance(lst, list):\n        raise ValueError('input %r must be a list' % lst)\n    for x in lst:\n        if not isinstance(x, basestring):\n            raise ValueError('element %r in list must be a string' % x)", "code_tokens": "def validate_string_list ( lst ) : if not isinstance ( lst , list ) : raise ValueError ( 'input %r must be a list' % lst ) for x in lst : if not isinstance ( x , basestring ) : raise ValueError ( 'element %r in list must be a string' % x )", "docstring_tokens": "Validate that the input is a list of strings .", "label": 0}, {"idx": "cosqa-train-3369", "doc": "how to reindex using python", "code": "def cmd_reindex():\n    \"\"\"Uses CREATE INDEX CONCURRENTLY to create a duplicate index, then tries to swap the new index for the original.\n\n    The index swap is done using a short lock timeout to prevent it from interfering with running queries. Retries until\n    the rename succeeds.\n    \"\"\"\n    db = connect(args.database)\n    for idx in args.indexes:\n        pg_reindex(db, idx)", "code_tokens": "def cmd_reindex ( ) : db = connect ( args . database ) for idx in args . indexes : pg_reindex ( db , idx )", "docstring_tokens": "Uses CREATE INDEX CONCURRENTLY to create a duplicate index then tries to swap the new index for the original .", "label": 0}, {"idx": "cosqa-train-3370", "doc": "python script that checks and validates folder name", "code": "def is_valid_folder(parser, arg):\n    \"\"\"Check if arg is a valid file that already exists on the file system.\"\"\"\n    arg = os.path.abspath(arg)\n    if not os.path.isdir(arg):\n        parser.error(\"The folder %s does not exist!\" % arg)\n    else:\n        return arg", "code_tokens": "def is_valid_folder ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . isdir ( arg ) : parser . error ( \"The folder %s does not exist!\" % arg ) else : return arg", "docstring_tokens": "Check if arg is a valid file that already exists on the file system .", "label": 0}, {"idx": "cosqa-train-3371", "doc": "how to remove a paranthesis in a string python", "code": "def unapostrophe(text):\n    \"\"\"Strip apostrophe and 's' from the end of a string.\"\"\"\n    text = re.sub(r'[%s]s?$' % ''.join(APOSTROPHES), '', text)\n    return text", "code_tokens": "def unapostrophe ( text ) : text = re . sub ( r'[%s]s?$' % '' . join ( APOSTROPHES ) , '' , text ) return text", "docstring_tokens": "Strip apostrophe and s from the end of a string .", "label": 1}, {"idx": "cosqa-train-3372", "doc": "how to remove full nan columns in python", "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True):\n    \"\"\"Clean a pandas dataframe by:\n        1. Filling empty values with Nan\n        2. Dropping columns with all empty values\n\n    Args:\n        df: Pandas DataFrame\n        fill_nan (bool): If any empty values (strings, None, etc) should be replaced with NaN\n        drop_empty_columns (bool): If columns whose values are all empty should be dropped\n\n    Returns:\n        DataFrame: cleaned DataFrame\n\n    \"\"\"\n    if fill_nan:\n        df = df.fillna(value=np.nan)\n    if drop_empty_columns:\n        df = df.dropna(axis=1, how='all')\n    return df.sort_index()", "code_tokens": "def clean_df ( df , fill_nan = True , drop_empty_columns = True ) : if fill_nan : df = df . fillna ( value = np . nan ) if drop_empty_columns : df = df . dropna ( axis = 1 , how = 'all' ) return df . sort_index ( )", "docstring_tokens": "Clean a pandas dataframe by : 1 . Filling empty values with Nan 2 . Dropping columns with all empty values", "label": 0}, {"idx": "cosqa-train-3373", "doc": "python select every other item in a numpy", "code": "def extract(self):\n        \"\"\"\n        Creates a copy of this tabarray in the form of a numpy ndarray.\n\n        Useful if you want to do math on array elements, e.g. if you have a \n        subset of the columns that are all numerical, you can construct a \n        numerical matrix and do matrix operations.\n\n        \"\"\"\n        return np.vstack([self[r] for r in self.dtype.names]).T.squeeze()", "code_tokens": "def extract ( self ) : return np . vstack ( [ self [ r ] for r in self . dtype . names ] ) . T . squeeze ( )", "docstring_tokens": "Creates a copy of this tabarray in the form of a numpy ndarray .", "label": 0}, {"idx": "cosqa-train-3374", "doc": "how to remove key from dictionalry python", "code": "def delete_entry(self, key):\n        \"\"\"Delete an object from the redis table\"\"\"\n        pipe = self.client.pipeline()\n        pipe.srem(self.keys_container, key)\n        pipe.delete(key)\n        pipe.execute()", "code_tokens": "def delete_entry ( self , key ) : pipe = self . client . pipeline ( ) pipe . srem ( self . keys_container , key ) pipe . delete ( key ) pipe . execute ( )", "docstring_tokens": "Delete an object from the redis table", "label": 0}, {"idx": "cosqa-train-3375", "doc": "python select files by pattern", "code": "def match_files(files, pattern: Pattern):\n    \"\"\"Yields file name if matches a regular expression pattern.\"\"\"\n\n    for name in files:\n        if re.match(pattern, name):\n            yield name", "code_tokens": "def match_files ( files , pattern : Pattern ) : for name in files : if re . match ( pattern , name ) : yield name", "docstring_tokens": "Yields file name if matches a regular expression pattern .", "label": 1}, {"idx": "cosqa-train-3376", "doc": "how to remove masked items in python array", "code": "def ma(self):\n        \"\"\"Represent data as a masked array.\n\n        The array is returned with column-first indexing, i.e. for a data file with\n        columns X Y1 Y2 Y3 ... the array a will be a[0] = X, a[1] = Y1, ... .\n\n        inf and nan are filtered via :func:`numpy.isfinite`.\n        \"\"\"\n        a = self.array\n        return numpy.ma.MaskedArray(a, mask=numpy.logical_not(numpy.isfinite(a)))", "code_tokens": "def ma ( self ) : a = self . array return numpy . ma . MaskedArray ( a , mask = numpy . logical_not ( numpy . isfinite ( a ) ) )", "docstring_tokens": "Represent data as a masked array .", "label": 1}, {"idx": "cosqa-train-3377", "doc": "python select index from tkinter listbox", "code": "def _selectItem(self, index):\n        \"\"\"Select item in the list\n        \"\"\"\n        self._selectedIndex = index\n        self.setCurrentIndex(self.model().createIndex(index, 0))", "code_tokens": "def _selectItem ( self , index ) : self . _selectedIndex = index self . setCurrentIndex ( self . model ( ) . createIndex ( index , 0 ) )", "docstring_tokens": "Select item in the list", "label": 1}, {"idx": "cosqa-train-3378", "doc": "how to remove punctuation from a text python", "code": "def remove_punctuation(text, exceptions=[]):\n    \"\"\"\n    Return a string with punctuation removed.\n\n    Parameters:\n        text (str): The text to remove punctuation from.\n        exceptions (list): List of symbols to keep in the given text.\n\n    Return:\n        str: The input text without the punctuation.\n    \"\"\"\n\n    all_but = [\n        r'\\w',\n        r'\\s'\n    ]\n\n    all_but.extend(exceptions)\n\n    pattern = '[^{}]'.format(''.join(all_but))\n\n    return re.sub(pattern, '', text)", "code_tokens": "def remove_punctuation ( text , exceptions = [ ] ) : all_but = [ r'\\w' , r'\\s' ] all_but . extend ( exceptions ) pattern = '[^{}]' . format ( '' . join ( all_but ) ) return re . sub ( pattern , '' , text )", "docstring_tokens": "Return a string with punctuation removed .", "label": 0}, {"idx": "cosqa-train-3379", "doc": "python select the index of value metting the criteria in an array", "code": "def percentile_index(a, q):\n    \"\"\"\n    Returns the index of the value at the Qth percentile in array a.\n    \"\"\"\n    return np.where(\n        a==np.percentile(a, q, interpolation='nearest')\n    )[0][0]", "code_tokens": "def percentile_index ( a , q ) : return np . where ( a == np . percentile ( a , q , interpolation = 'nearest' ) ) [ 0 ] [ 0 ]", "docstring_tokens": "Returns the index of the value at the Qth percentile in array a .", "label": 0}, {"idx": "cosqa-train-3380", "doc": "how to remove punctuation in python string", "code": "def _clean_str(self, s):\n        \"\"\" Returns a lowercase string with punctuation and bad chars removed\n        :param s: string to clean\n        \"\"\"\n        return s.translate(str.maketrans('', '', punctuation)).replace('\\u200b', \" \").strip().lower()", "code_tokens": "def _clean_str ( self , s ) : return s . translate ( str . maketrans ( '' , '' , punctuation ) ) . replace ( '\\u200b' , \" \" ) . strip ( ) . lower ( )", "docstring_tokens": "Returns a lowercase string with punctuation and bad chars removed : param s : string to clean", "label": 1}, {"idx": "cosqa-train-3381", "doc": "python select unique elements in list", "code": "def delete_duplicates(seq):\n    \"\"\"\n    Remove duplicates from an iterable, preserving the order.\n\n    Args:\n        seq: Iterable of various type.\n\n    Returns:\n        list: List of unique objects.\n\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "Remove duplicates from an iterable preserving the order .", "label": 0}, {"idx": "cosqa-train-3382", "doc": "how to remove space in strings in python", "code": "def sanitize_word(s):\n    \"\"\"Remove non-alphanumerical characters from metric word.\n    And trim excessive underscores.\n    \"\"\"\n    s = re.sub('[^\\w-]+', '_', s)\n    s = re.sub('__+', '_', s)\n    return s.strip('_')", "code_tokens": "def sanitize_word ( s ) : s = re . sub ( '[^\\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )", "docstring_tokens": "Remove non - alphanumerical characters from metric word . And trim excessive underscores .", "label": 1}, {"idx": "cosqa-train-3383", "doc": "python send email attach multiple files", "code": "def _attach_files(filepaths, email_):\n    \"\"\"Take a list of filepaths and attach the files to a MIMEMultipart.\n\n    Args:\n        filepaths (list(str)): A list of filepaths.\n        email_ (email.MIMEMultipart): A MIMEMultipart email_.\n    \"\"\"\n    for filepath in filepaths:\n        base = os.path.basename(filepath)\n        with open(filepath, \"rb\") as file:\n            part = MIMEApplication(file.read(), Name=base)\n            part[\"Content-Disposition\"] = 'attachment; filename=\"%s\"' % base\n            email_.attach(part)", "code_tokens": "def _attach_files ( filepaths , email_ ) : for filepath in filepaths : base = os . path . basename ( filepath ) with open ( filepath , \"rb\" ) as file : part = MIMEApplication ( file . read ( ) , Name = base ) part [ \"Content-Disposition\" ] = 'attachment; filename=\"%s\"' % base email_ . attach ( part )", "docstring_tokens": "Take a list of filepaths and attach the files to a MIMEMultipart .", "label": 1}, {"idx": "cosqa-train-3384", "doc": "how to remove the duplicates in list in python", "code": "def remove_duplicates(lst):\n    \"\"\"\n    Emulate what a Python ``set()`` does, but keeping the element's order.\n    \"\"\"\n    dset = set()\n    return [l for l in lst if l not in dset and not dset.add(l)]", "code_tokens": "def remove_duplicates ( lst ) : dset = set ( ) return [ l for l in lst if l not in dset and not dset . add ( l ) ]", "docstring_tokens": "Emulate what a Python set () does but keeping the element s order .", "label": 1}, {"idx": "cosqa-train-3385", "doc": "python send rtsp stream", "code": "def send(r, stream=False):\n    \"\"\"Just sends the request using its send method and returns its response.  \"\"\"\n    r.send(stream=stream)\n    return r.response", "code_tokens": "def send ( r , stream = False ) : r . send ( stream = stream ) return r . response", "docstring_tokens": "Just sends the request using its send method and returns its response .", "label": 1}, {"idx": "cosqa-train-3386", "doc": "how to render html with data in python django", "code": "def handle_data(self, data):\n        \"\"\"\n        Djeffify data between tags\n        \"\"\"\n        if data.strip():\n            data = djeffify_string(data)\n        self.djhtml += data", "code_tokens": "def handle_data ( self , data ) : if data . strip ( ) : data = djeffify_string ( data ) self . djhtml += data", "docstring_tokens": "Djeffify data between tags", "label": 0}, {"idx": "cosqa-train-3387", "doc": "python separate filename and extension", "code": "def splitext_no_dot(filename):\n    \"\"\"\n    Wrap os.path.splitext to return the name and the extension\n    without the '.' (e.g., csv instead of .csv)\n    \"\"\"\n    name, ext = os.path.splitext(filename)\n    ext = ext.lower()\n    return name, ext.strip('.')", "code_tokens": "def splitext_no_dot ( filename ) : name , ext = os . path . splitext ( filename ) ext = ext . lower ( ) return name , ext . strip ( '.' )", "docstring_tokens": "Wrap os . path . splitext to return the name and the extension without the . ( e . g . csv instead of . csv )", "label": 0}, {"idx": "cosqa-train-3388", "doc": "how to replace boolean by 1 and 0 in python with if", "code": "def boolean(flag):\n    \"\"\"\n    Convert string in boolean\n    \"\"\"\n    s = flag.lower()\n    if s in ('1', 'yes', 'true'):\n        return True\n    elif s in ('0', 'no', 'false'):\n        return False\n    raise ValueError('Unknown flag %r' % s)", "code_tokens": "def boolean ( flag ) : s = flag . lower ( ) if s in ( '1' , 'yes' , 'true' ) : return True elif s in ( '0' , 'no' , 'false' ) : return False raise ValueError ( 'Unknown flag %r' % s )", "docstring_tokens": "Convert string in boolean", "label": 1}, {"idx": "cosqa-train-3389", "doc": "python serial device not configured", "code": "def autoscan():\n    \"\"\"autoscan will check all of the serial ports to see if they have\n       a matching VID:PID for a MicroPython board.\n    \"\"\"\n    for port in serial.tools.list_ports.comports():\n        if is_micropython_usb_device(port):\n            connect_serial(port[0])", "code_tokens": "def autoscan ( ) : for port in serial . tools . list_ports . comports ( ) : if is_micropython_usb_device ( port ) : connect_serial ( port [ 0 ] )", "docstring_tokens": "autoscan will check all of the serial ports to see if they have a matching VID : PID for a MicroPython board .", "label": 0}, {"idx": "cosqa-train-3390", "doc": "how to replace decimal points in a float with space in python", "code": "def format_float(value): # not used\n    \"\"\"Modified form of the 'g' format specifier.\n    \"\"\"\n    string = \"{:g}\".format(value).replace(\"e+\", \"e\")\n    string = re.sub(\"e(-?)0*(\\d+)\", r\"e\\1\\2\", string)\n    return string", "code_tokens": "def format_float ( value ) : # not used string = \"{:g}\" . format ( value ) . replace ( \"e+\" , \"e\" ) string = re . sub ( \"e(-?)0*(\\d+)\" , r\"e\\1\\2\" , string ) return string", "docstring_tokens": "Modified form of the g format specifier .", "label": 0}, {"idx": "cosqa-train-3391", "doc": "python series remove if not null", "code": "def remove_series(self, series):\n        \"\"\"Removes a :py:class:`.Series` from the chart.\n\n        :param Series series: The :py:class:`.Series` to remove.\n        :raises ValueError: if you try to remove the last\\\n        :py:class:`.Series`.\"\"\"\n\n        if len(self.all_series()) == 1:\n            raise ValueError(\"Cannot remove last series from %s\" % str(self))\n        self._all_series.remove(series)\n        series._chart = None", "code_tokens": "def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( \"Cannot remove last series from %s\" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None", "docstring_tokens": "Removes a : py : class : . Series from the chart .", "label": 1}, {"idx": "cosqa-train-3392", "doc": "how to replace na values in python", "code": "def _replace_nan(a, val):\n    \"\"\"\n    replace nan in a by val, and returns the replaced array and the nan\n    position\n    \"\"\"\n    mask = isnull(a)\n    return where_method(val, mask, a), mask", "code_tokens": "def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask", "docstring_tokens": "replace nan in a by val and returns the replaced array and the nan position", "label": 0}, {"idx": "cosqa-train-3393", "doc": "python session set get", "code": "def _session_set(self, key, value):\n        \"\"\"\n        Saves a value to session.\n        \"\"\"\n\n        self.session[self._session_key(key)] = value", "code_tokens": "def _session_set ( self , key , value ) : self . session [ self . _session_key ( key ) ] = value", "docstring_tokens": "Saves a value to session .", "label": 1}, {"idx": "cosqa-train-3394", "doc": "how to reset the input in python", "code": "def internal_reset(self):\n        \"\"\"\n        internal state reset.\n        used e.g. in unittests\n        \"\"\"\n        log.critical(\"PIA internal_reset()\")\n        self.empty_key_toggle = True\n        self.current_input_char = None\n        self.input_repead = 0", "code_tokens": "def internal_reset ( self ) : log . critical ( \"PIA internal_reset()\" ) self . empty_key_toggle = True self . current_input_char = None self . input_repead = 0", "docstring_tokens": "internal state reset . used e . g . in unittests", "label": 0}, {"idx": "cosqa-train-3395", "doc": "python set (round function to 4 significant numbers", "code": "def get_rounded(self, digits):\n        \"\"\" Return a vector with the elements rounded to the given number of digits. \"\"\"\n        result = self.copy()\n        result.round(digits)\n        return result", "code_tokens": "def get_rounded ( self , digits ) : result = self . copy ( ) result . round ( digits ) return result", "docstring_tokens": "Return a vector with the elements rounded to the given number of digits .", "label": 1}, {"idx": "cosqa-train-3396", "doc": "how to retrive data in nameobject in python", "code": "def get_member(thing_obj, member_string):\n    \"\"\"Get a member from an object by (string) name\"\"\"\n    mems = {x[0]: x[1] for x in inspect.getmembers(thing_obj)}\n    if member_string in mems:\n        return mems[member_string]", "code_tokens": "def get_member ( thing_obj , member_string ) : mems = { x [ 0 ] : x [ 1 ] for x in inspect . getmembers ( thing_obj ) } if member_string in mems : return mems [ member_string ]", "docstring_tokens": "Get a member from an object by ( string ) name", "label": 0}, {"idx": "cosqa-train-3397", "doc": "python set a service to a variable", "code": "def _replace_service_arg(self, name, index, args):\n        \"\"\" Replace index in list with service \"\"\"\n        args[index] = self.get_instantiated_service(name)", "code_tokens": "def _replace_service_arg ( self , name , index , args ) : args [ index ] = self . get_instantiated_service ( name )", "docstring_tokens": "Replace index in list with service", "label": 0}, {"idx": "cosqa-train-3398", "doc": "how to return bool values in definitons python", "code": "def isbinary(*args):\n    \"\"\"Checks if value can be part of binary/bitwise operations.\"\"\"\n    return all(map(lambda c: isnumber(c) or isbool(c), args))", "code_tokens": "def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )", "docstring_tokens": "Checks if value can be part of binary / bitwise operations .", "label": 0}, {"idx": "cosqa-train-3399", "doc": "python set a thread safe flag", "code": "def _synced(method, self, args, kwargs):\n    \"\"\"Underlying synchronized wrapper.\"\"\"\n    with self._lock:\n        return method(*args, **kwargs)", "code_tokens": "def _synced ( method , self , args , kwargs ) : with self . _lock : return method ( * args , * * kwargs )", "docstring_tokens": "Underlying synchronized wrapper .", "label": 0}, {"idx": "cosqa-train-3400", "doc": "how to return dots in python", "code": "def _dotify(cls, data):\n    \"\"\"Add dots.\"\"\"\n    return ''.join(char if char in cls.PRINTABLE_DATA else '.' for char in data)", "code_tokens": "def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )", "docstring_tokens": "Add dots .", "label": 0}, {"idx": "cosqa-train-3401", "doc": "python set check if element exist", "code": "def is_set(self, key):\n        \"\"\"Return True if variable is a set\"\"\"\n        data = self.model.get_data()\n        return isinstance(data[key], set)", "code_tokens": "def is_set ( self , key ) : data = self . model . get_data ( ) return isinstance ( data [ key ] , set )", "docstring_tokens": "Return True if variable is a set", "label": 0}, {"idx": "cosqa-train-3402", "doc": "how to return only rows that aren't zero python data frame", "code": "def dropna(self):\n        \"\"\"Returns MultiIndex without any rows containing null values according to Baloo's convention.\n\n        Returns\n        -------\n        MultiIndex\n            MultiIndex with no null values.\n\n        \"\"\"\n        not_nas = [v.notna() for v in self.values]\n        and_filter = reduce(lambda x, y: x & y, not_nas)\n\n        return self[and_filter]", "code_tokens": "def dropna ( self ) : not_nas = [ v . notna ( ) for v in self . values ] and_filter = reduce ( lambda x , y : x & y , not_nas ) return self [ and_filter ]", "docstring_tokens": "Returns MultiIndex without any rows containing null values according to Baloo s convention .", "label": 0}, {"idx": "cosqa-train-3403", "doc": "python set default encoding ansi", "code": "def getdefaultencoding():\n    \"\"\"Return IPython's guess for the default encoding for bytes as text.\n\n    Asks for stdin.encoding first, to match the calling Terminal, but that\n    is often None for subprocesses.  Fall back on locale.getpreferredencoding()\n    which should be a sensible platform default (that respects LANG environment),\n    and finally to sys.getdefaultencoding() which is the most conservative option,\n    and usually ASCII.\n    \"\"\"\n    enc = get_stream_enc(sys.stdin)\n    if not enc or enc=='ascii':\n        try:\n            # There are reports of getpreferredencoding raising errors\n            # in some cases, which may well be fixed, but let's be conservative here.\n            enc = locale.getpreferredencoding()\n        except Exception:\n            pass\n    return enc or sys.getdefaultencoding()", "code_tokens": "def getdefaultencoding ( ) : enc = get_stream_enc ( sys . stdin ) if not enc or enc == 'ascii' : try : # There are reports of getpreferredencoding raising errors # in some cases, which may well be fixed, but let's be conservative here. enc = locale . getpreferredencoding ( ) except Exception : pass return enc or sys . getdefaultencoding ( )", "docstring_tokens": "Return IPython s guess for the default encoding for bytes as text .", "label": 1}, {"idx": "cosqa-train-3404", "doc": "how to round down float values python array", "code": "def round_array(array_in):\n    \"\"\"\n    arr_out = round_array(array_in)\n\n    Rounds an array and recasts it to int. Also works on scalars.\n    \"\"\"\n    if isinstance(array_in, ndarray):\n        return np.round(array_in).astype(int)\n    else:\n        return int(np.round(array_in))", "code_tokens": "def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )", "docstring_tokens": "arr_out = round_array ( array_in )", "label": 0}, {"idx": "cosqa-train-3405", "doc": "python set default logging opptions", "code": "def reset_default_logger():\n    \"\"\"\n    Resets the internal default logger to the initial configuration\n    \"\"\"\n    global logger\n    global _loglevel\n    global _logfile\n    global _formatter\n    _loglevel = logging.DEBUG\n    _logfile = None\n    _formatter = None\n    logger = setup_logger(name=LOGZERO_DEFAULT_LOGGER, logfile=_logfile, level=_loglevel, formatter=_formatter)", "code_tokens": "def reset_default_logger ( ) : global logger global _loglevel global _logfile global _formatter _loglevel = logging . DEBUG _logfile = None _formatter = None logger = setup_logger ( name = LOGZERO_DEFAULT_LOGGER , logfile = _logfile , level = _loglevel , formatter = _formatter )", "docstring_tokens": "Resets the internal default logger to the initial configuration", "label": 0}, {"idx": "cosqa-train-3406", "doc": "how to run multiple processes in python", "code": "def parallel(processes, threads):\n    \"\"\"\n    execute jobs in processes using N threads\n    \"\"\"\n    pool = multithread(threads)\n    pool.map(run_process, processes)\n    pool.close()\n    pool.join()", "code_tokens": "def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )", "docstring_tokens": "execute jobs in processes using N threads", "label": 0}, {"idx": "cosqa-train-3407", "doc": "python set delete element", "code": "def discard(self, element):\n        \"\"\"Remove element from the RangeSet if it is a member.\n\n        If the element is not a member, do nothing.\n        \"\"\"\n        try:\n            i = int(element)\n            set.discard(self, i)\n        except ValueError:\n            pass", "code_tokens": "def discard ( self , element ) : try : i = int ( element ) set . discard ( self , i ) except ValueError : pass", "docstring_tokens": "Remove element from the RangeSet if it is a member .", "label": 0}, {"idx": "cosqa-train-3408", "doc": "how to run python in conjection with java", "code": "def test_python_java_rt():\n    \"\"\" Run Python test cases against Java runtime classes. \"\"\"\n    sub_env = {'PYTHONPATH': _build_dir()}\n\n    log.info('Executing Python unit tests (against Java runtime classes)...')\n    return jpyutil._execute_python_scripts(python_java_rt_tests,\n                                           env=sub_env)", "code_tokens": "def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )", "docstring_tokens": "Run Python test cases against Java runtime classes .", "label": 1}, {"idx": "cosqa-train-3409", "doc": "python set domain name", "code": "def _config_win32_domain(self, domain):\n        \"\"\"Configure a Domain registry entry.\"\"\"\n        # we call str() on domain to convert it from unicode to ascii\n        self.domain = dns.name.from_text(str(domain))", "code_tokens": "def _config_win32_domain ( self , domain ) : # we call str() on domain to convert it from unicode to ascii self . domain = dns . name . from_text ( str ( domain ) )", "docstring_tokens": "Configure a Domain registry entry .", "label": 1}, {"idx": "cosqa-train-3410", "doc": "how to save a figure as a pdf python", "code": "def save_pdf(path):\n  \"\"\"\n  Saves a pdf of the current matplotlib figure.\n\n  :param path: str, filepath to save to\n  \"\"\"\n\n  pp = PdfPages(path)\n  pp.savefig(pyplot.gcf())\n  pp.close()", "code_tokens": "def save_pdf ( path ) : pp = PdfPages ( path ) pp . savefig ( pyplot . gcf ( ) ) pp . close ( )", "docstring_tokens": "Saves a pdf of the current matplotlib figure .", "label": 0}, {"idx": "cosqa-train-3411", "doc": "python set effective uid", "code": "def generate_id():\n    \"\"\"Generate new UUID\"\"\"\n    # TODO: Use six.string_type to Py3 compat\n    try:\n        return unicode(uuid1()).replace(u\"-\", u\"\")\n    except NameError:\n        return str(uuid1()).replace(u\"-\", u\"\")", "code_tokens": "def generate_id ( ) : # TODO: Use six.string_type to Py3 compat try : return unicode ( uuid1 ( ) ) . replace ( u\"-\" , u\"\" ) except NameError : return str ( uuid1 ( ) ) . replace ( u\"-\" , u\"\" )", "docstring_tokens": "Generate new UUID", "label": 0}, {"idx": "cosqa-train-3412", "doc": "how to save html string as html file python", "code": "def _save_file(self, filename, contents):\n        \"\"\"write the html file contents to disk\"\"\"\n        with open(filename, 'w') as f:\n            f.write(contents)", "code_tokens": "def _save_file ( self , filename , contents ) : with open ( filename , 'w' ) as f : f . write ( contents )", "docstring_tokens": "write the html file contents to disk", "label": 0}, {"idx": "cosqa-train-3413", "doc": "python set element exist", "code": "def is_set(self, key):\n        \"\"\"Return True if variable is a set\"\"\"\n        data = self.model.get_data()\n        return isinstance(data[key], set)", "code_tokens": "def is_set ( self , key ) : data = self . model . get_data ( ) return isinstance ( data [ key ] , set )", "docstring_tokens": "Return True if variable is a set", "label": 0}, {"idx": "cosqa-train-3414", "doc": "how to see all methods attributes python", "code": "def get_all_attributes(klass_or_instance):\n    \"\"\"Get all attribute members (attribute, property style method).\n    \"\"\"\n    pairs = list()\n    for attr, value in inspect.getmembers(\n            klass_or_instance, lambda x: not inspect.isroutine(x)):\n        if not (attr.startswith(\"__\") or attr.endswith(\"__\")):\n            pairs.append((attr, value))\n    return pairs", "code_tokens": "def get_all_attributes ( klass_or_instance ) : pairs = list ( ) for attr , value in inspect . getmembers ( klass_or_instance , lambda x : not inspect . isroutine ( x ) ) : if not ( attr . startswith ( \"__\" ) or attr . endswith ( \"__\" ) ) : pairs . append ( ( attr , value ) ) return pairs", "docstring_tokens": "Get all attribute members ( attribute property style method ) .", "label": 0}, {"idx": "cosqa-train-3415", "doc": "python set of lists mutable", "code": "def unique_everseen(seq):\n    \"\"\"Solution found here : http://stackoverflow.com/questions/480214/how-do-you-remove-duplicates-from-a-list-in-python-whilst-preserving-order\"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def unique_everseen ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "Solution found here : http : // stackoverflow . com / questions / 480214 / how - do - you - remove - duplicates - from - a - list - in - python - whilst - preserving - order", "label": 0}, {"idx": "cosqa-train-3416", "doc": "how to see column names in python of a datframes", "code": "def get_obj_cols(df):\n    \"\"\"\n    Returns names of 'object' columns in the DataFrame.\n    \"\"\"\n    obj_cols = []\n    for idx, dt in enumerate(df.dtypes):\n        if dt == 'object' or is_category(dt):\n            obj_cols.append(df.columns.values[idx])\n\n    return obj_cols", "code_tokens": "def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols", "docstring_tokens": "Returns names of object columns in the DataFrame .", "label": 0}, {"idx": "cosqa-train-3417", "doc": "python set property by introspection", "code": "def traverse_setter(obj, attribute, value):\n    \"\"\"\n    Traverses the object and sets the supplied attribute on the\n    object. Supports Dimensioned and DimensionedPlot types.\n    \"\"\"\n    obj.traverse(lambda x: setattr(x, attribute, value))", "code_tokens": "def traverse_setter ( obj , attribute , value ) : obj . traverse ( lambda x : setattr ( x , attribute , value ) )", "docstring_tokens": "Traverses the object and sets the supplied attribute on the object . Supports Dimensioned and DimensionedPlot types .", "label": 0}, {"idx": "cosqa-train-3418", "doc": "how to see if a variable is valid in python", "code": "def is_valid_varname(varname):\n    \"\"\" Checks syntax and validity of a variable name \"\"\"\n    if not isinstance(varname, six.string_types):\n        return False\n    match_obj = re.match(varname_regex, varname)\n    valid_syntax = match_obj is not None\n    valid_name = not keyword.iskeyword(varname)\n    isvalid = valid_syntax and valid_name\n    return isvalid", "code_tokens": "def is_valid_varname ( varname ) : if not isinstance ( varname , six . string_types ) : return False match_obj = re . match ( varname_regex , varname ) valid_syntax = match_obj is not None valid_name = not keyword . iskeyword ( varname ) isvalid = valid_syntax and valid_name return isvalid", "docstring_tokens": "Checks syntax and validity of a variable name", "label": 0}, {"idx": "cosqa-train-3419", "doc": "python set range of axis", "code": "def setAutoRangeOn(self, axisNumber):\n        \"\"\" Sets the auto-range of the axis on.\n\n            :param axisNumber: 0 (X-axis), 1 (Y-axis), 2, (Both X and Y axes).\n        \"\"\"\n        setXYAxesAutoRangeOn(self, self.xAxisRangeCti, self.yAxisRangeCti, axisNumber)", "code_tokens": "def setAutoRangeOn ( self , axisNumber ) : setXYAxesAutoRangeOn ( self , self . xAxisRangeCti , self . yAxisRangeCti , axisNumber )", "docstring_tokens": "Sets the auto - range of the axis on .", "label": 0}, {"idx": "cosqa-train-3420", "doc": "how to see the unique value in a list in python", "code": "def unique_element(ll):\n    \"\"\" returns unique elements from a list preserving the original order \"\"\"\n    seen = {}\n    result = []\n    for item in ll:\n        if item in seen:\n            continue\n        seen[item] = 1\n        result.append(item)\n    return result", "code_tokens": "def unique_element ( ll ) : seen = { } result = [ ] for item in ll : if item in seen : continue seen [ item ] = 1 result . append ( item ) return result", "docstring_tokens": "returns unique elements from a list preserving the original order", "label": 1}, {"idx": "cosqa-train-3421", "doc": "python set rate limit", "code": "def wait_on_rate_limit(self, value):\n        \"\"\"Enable or disable automatic rate-limit handling.\"\"\"\n        check_type(value, bool, may_be_none=False)\n        self._wait_on_rate_limit = value", "code_tokens": "def wait_on_rate_limit ( self , value ) : check_type ( value , bool , may_be_none = False ) self . _wait_on_rate_limit = value", "docstring_tokens": "Enable or disable automatic rate - limit handling .", "label": 1}, {"idx": "cosqa-train-3422", "doc": "how to select last row in python", "code": "def get_last(self, table=None):\n        \"\"\"Just the last entry.\"\"\"\n        if table is None: table = self.main_table\n        query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table\n        return self.own_cursor.execute(query).fetchone()", "code_tokens": "def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )", "docstring_tokens": "Just the last entry .", "label": 0}, {"idx": "cosqa-train-3423", "doc": "python set remove element", "code": "def discard(self, element):\n        \"\"\"Remove element from the RangeSet if it is a member.\n\n        If the element is not a member, do nothing.\n        \"\"\"\n        try:\n            i = int(element)\n            set.discard(self, i)\n        except ValueError:\n            pass", "code_tokens": "def discard ( self , element ) : try : i = int ( element ) set . discard ( self , i ) except ValueError : pass", "docstring_tokens": "Remove element from the RangeSet if it is a member .", "label": 1}, {"idx": "cosqa-train-3424", "doc": "how to send a file over ftp python", "code": "def _send_file(self, filename):\n        \"\"\"\n        Sends a file via FTP.\n        \"\"\"\n        # pylint: disable=E1101\n        ftp = ftplib.FTP(host=self.host)\n        ftp.login(user=self.user, passwd=self.password)\n        ftp.set_pasv(True)\n        ftp.storbinary(\"STOR %s\" % os.path.basename(filename),\n            file(filename, 'rb'))", "code_tokens": "def _send_file ( self , filename ) : # pylint: disable=E1101 ftp = ftplib . FTP ( host = self . host ) ftp . login ( user = self . user , passwd = self . password ) ftp . set_pasv ( True ) ftp . storbinary ( \"STOR %s\" % os . path . basename ( filename ) , file ( filename , 'rb' ) )", "docstring_tokens": "Sends a file via FTP .", "label": 0}, {"idx": "cosqa-train-3425", "doc": "python set request header flask", "code": "def get_trace_id_from_flask():\n    \"\"\"Get trace_id from flask request headers.\n\n    :rtype: str\n    :returns: TraceID in HTTP request headers.\n    \"\"\"\n    if flask is None or not flask.request:\n        return None\n\n    header = flask.request.headers.get(_FLASK_TRACE_HEADER)\n\n    if header is None:\n        return None\n\n    trace_id = header.split(\"/\", 1)[0]\n\n    return trace_id", "code_tokens": "def get_trace_id_from_flask ( ) : if flask is None or not flask . request : return None header = flask . request . headers . get ( _FLASK_TRACE_HEADER ) if header is None : return None trace_id = header . split ( \"/\" , 1 ) [ 0 ] return trace_id", "docstring_tokens": "Get trace_id from flask request headers .", "label": 0}, {"idx": "cosqa-train-3426", "doc": "how to send a photo by python telegram bot", "code": "def send_photo(self, photo: str, caption: str=None, reply: Message=None, on_success: callable=None,\n                   reply_markup: botapi.ReplyMarkup=None):\n        \"\"\"\n        Send photo to this peer.\n        :param photo: File path to photo to send.\n        :param caption: Caption for photo\n        :param reply: Message object or message_id to reply to.\n        :param on_success: Callback to call when call is complete.\n\n        :type reply: int or Message\n        \"\"\"\n        self.twx.send_photo(peer=self, photo=photo, caption=caption, reply=reply, reply_markup=reply_markup,\n                            on_success=on_success)", "code_tokens": "def send_photo ( self , photo : str , caption : str = None , reply : Message = None , on_success : callable = None , reply_markup : botapi . ReplyMarkup = None ) : self . twx . send_photo ( peer = self , photo = photo , caption = caption , reply = reply , reply_markup = reply_markup , on_success = on_success )", "docstring_tokens": "Send photo to this peer . : param photo : File path to photo to send . : param caption : Caption for photo : param reply : Message object or message_id to reply to . : param on_success : Callback to call when call is complete .", "label": 0}, {"idx": "cosqa-train-3427", "doc": "how to set an xml parser to ignor errors python", "code": "def _check_for_errors(etree: ET.ElementTree):\n    \"\"\"Check AniDB response XML tree for errors.\"\"\"\n    if etree.getroot().tag == 'error':\n        raise APIError(etree.getroot().text)", "code_tokens": "def _check_for_errors ( etree : ET . ElementTree ) : if etree . getroot ( ) . tag == 'error' : raise APIError ( etree . getroot ( ) . text )", "docstring_tokens": "Check AniDB response XML tree for errors .", "label": 0}, {"idx": "cosqa-train-3428", "doc": "python set weekend as workday", "code": "def previous_friday(dt):\n    \"\"\"\n    If holiday falls on Saturday or Sunday, use previous Friday instead.\n    \"\"\"\n    if dt.weekday() == 5:\n        return dt - timedelta(1)\n    elif dt.weekday() == 6:\n        return dt - timedelta(2)\n    return dt", "code_tokens": "def previous_friday ( dt ) : if dt . weekday ( ) == 5 : return dt - timedelta ( 1 ) elif dt . weekday ( ) == 6 : return dt - timedelta ( 2 ) return dt", "docstring_tokens": "If holiday falls on Saturday or Sunday use previous Friday instead .", "label": 0}, {"idx": "cosqa-train-3429", "doc": "how to set author in python", "code": "def save_model(self, request, obj, form, change):\n        \"\"\"\n        Set currently authenticated user as the author of the gallery.\n        \"\"\"\n        obj.author = request.user\n        obj.save()", "code_tokens": "def save_model ( self , request , obj , form , change ) : obj . author = request . user obj . save ( )", "docstring_tokens": "Set currently authenticated user as the author of the gallery .", "label": 0}, {"idx": "cosqa-train-3430", "doc": "python set window position", "code": "def set_position(self, x, y, width, height):\n        \"\"\"Set window top-left corner position and size\"\"\"\n        SetWindowPos(self._hwnd, None, x, y, width, height, ctypes.c_uint(0))", "code_tokens": "def set_position ( self , x , y , width , height ) : SetWindowPos ( self . _hwnd , None , x , y , width , height , ctypes . c_uint ( 0 ) )", "docstring_tokens": "Set window top - left corner position and size", "label": 1}, {"idx": "cosqa-train-3431", "doc": "how to set constraint in python for input", "code": "def set_constraint_bound(self, name, value):\n        \"\"\"Set the upper bound of a constraint.\"\"\"\n        index = self._get_constraint_index(name)\n        self.upper_bounds[index] = value\n        self._reset_solution()", "code_tokens": "def set_constraint_bound ( self , name , value ) : index = self . _get_constraint_index ( name ) self . upper_bounds [ index ] = value self . _reset_solution ( )", "docstring_tokens": "Set the upper bound of a constraint .", "label": 0}, {"idx": "cosqa-train-3432", "doc": "python set y axis to log", "code": "def log_y_cb(self, w, val):\n        \"\"\"Toggle linear/log scale for Y-axis.\"\"\"\n        self.tab_plot.logy = val\n        self.plot_two_columns()", "code_tokens": "def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )", "docstring_tokens": "Toggle linear / log scale for Y - axis .", "label": 0}, {"idx": "cosqa-train-3433", "doc": "how to set precision of a number to 2 decimal places in python", "code": "def round_to_int(number, precision):\n    \"\"\"Round a number to a precision\"\"\"\n    precision = int(precision)\n    rounded = (int(number) + precision / 2) // precision * precision\n    return rounded", "code_tokens": "def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded", "docstring_tokens": "Round a number to a precision", "label": 1}, {"idx": "cosqa-train-3434", "doc": "python set yaxis log", "code": "def log_y_cb(self, w, val):\n        \"\"\"Toggle linear/log scale for Y-axis.\"\"\"\n        self.tab_plot.logy = val\n        self.plot_two_columns()", "code_tokens": "def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )", "docstring_tokens": "Toggle linear / log scale for Y - axis .", "label": 1}, {"idx": "cosqa-train-3435", "doc": "how to set text for a subplot of figure in python", "code": "def set_axis_options(self, row, column, text):\n        \"\"\"Set additionnal options as plain text.\"\"\"\n\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_axis_options(text)", "code_tokens": "def set_axis_options ( self , row , column , text ) : subplot = self . get_subplot_at ( row , column ) subplot . set_axis_options ( text )", "docstring_tokens": "Set additionnal options as plain text .", "label": 0}, {"idx": "cosqa-train-3436", "doc": "python setdefault short circuit", "code": "def set_default(self, key, value):\n        \"\"\"Set the default value for this key.\n        Default only used when no value is provided by the user via\n        arg, config or env.\n        \"\"\"\n        k = self._real_key(key.lower())\n        self._defaults[k] = value", "code_tokens": "def set_default ( self , key , value ) : k = self . _real_key ( key . lower ( ) ) self . _defaults [ k ] = value", "docstring_tokens": "Set the default value for this key . Default only used when no value is provided by the user via arg config or env .", "label": 0}, {"idx": "cosqa-train-3437", "doc": "how to shape a 300 to a 500 array in python", "code": "def batchify(data, batch_size):\n    \"\"\"Reshape data into (num_example, batch_size)\"\"\"\n    nbatch = data.shape[0] // batch_size\n    data = data[:nbatch * batch_size]\n    data = data.reshape((batch_size, nbatch)).T\n    return data", "code_tokens": "def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data", "docstring_tokens": "Reshape data into ( num_example batch_size )", "label": 0}, {"idx": "cosqa-train-3438", "doc": "python shell code color", "code": "def stringc(text, color):\n    \"\"\"\n    Return a string with terminal colors.\n    \"\"\"\n    if has_colors:\n        text = str(text)\n\n        return \"\\033[\"+codeCodes[color]+\"m\"+text+\"\\033[0m\"\n    else:\n        return text", "code_tokens": "def stringc ( text , color ) : if has_colors : text = str ( text ) return \"\\033[\" + codeCodes [ color ] + \"m\" + text + \"\\033[0m\" else : return text", "docstring_tokens": "Return a string with terminal colors .", "label": 0}, {"idx": "cosqa-train-3439", "doc": "how to show pixel coordinates of image in python", "code": "def extent(self):\n        \"\"\"Helper for matplotlib imshow\"\"\"\n        return (\n            self.intervals[1].pix1 - 0.5,\n            self.intervals[1].pix2 - 0.5,\n            self.intervals[0].pix1 - 0.5,\n            self.intervals[0].pix2 - 0.5,\n        )", "code_tokens": "def extent ( self ) : return ( self . intervals [ 1 ] . pix1 - 0.5 , self . intervals [ 1 ] . pix2 - 0.5 , self . intervals [ 0 ] . pix1 - 0.5 , self . intervals [ 0 ] . pix2 - 0.5 , )", "docstring_tokens": "Helper for matplotlib imshow", "label": 0}, {"idx": "cosqa-train-3440", "doc": "python shortcut for comments", "code": "def _match_space_at_line(line):\n    \"\"\"Return a re.match object if an empty comment was found on line.\"\"\"\n    regex = re.compile(r\"^{0}$\".format(_MDL_COMMENT))\n    return regex.match(line)", "code_tokens": "def _match_space_at_line ( line ) : regex = re . compile ( r\"^{0}$\" . format ( _MDL_COMMENT ) ) return regex . match ( line )", "docstring_tokens": "Return a re . match object if an empty comment was found on line .", "label": 0}, {"idx": "cosqa-train-3441", "doc": "how to slice iterables in python", "code": "def chunks(iterable, chunk):\n    \"\"\"Yield successive n-sized chunks from an iterable.\"\"\"\n    for i in range(0, len(iterable), chunk):\n        yield iterable[i:i + chunk]", "code_tokens": "def chunks ( iterable , chunk ) : for i in range ( 0 , len ( iterable ) , chunk ) : yield iterable [ i : i + chunk ]", "docstring_tokens": "Yield successive n - sized chunks from an iterable .", "label": 0}, {"idx": "cosqa-train-3442", "doc": "python show all variables memory", "code": "def _print_memory(self, memory):\n        \"\"\"Print memory.\n        \"\"\"\n        for addr, value in memory.items():\n            print(\"    0x%08x : 0x%08x (%d)\" % (addr, value, value))", "code_tokens": "def _print_memory ( self , memory ) : for addr , value in memory . items ( ) : print ( \"    0x%08x : 0x%08x (%d)\" % ( addr , value , value ) )", "docstring_tokens": "Print memory .", "label": 1}, {"idx": "cosqa-train-3443", "doc": "how to slice without slice function python", "code": "def Slice(a, begin, size):\n    \"\"\"\n    Slicing op.\n    \"\"\"\n    return np.copy(a)[[slice(*tpl) for tpl in zip(begin, begin+size)]],", "code_tokens": "def Slice ( a , begin , size ) : return np . copy ( a ) [ [ slice ( * tpl ) for tpl in zip ( begin , begin + size ) ] ] ,", "docstring_tokens": "Slicing op .", "label": 0}, {"idx": "cosqa-train-3444", "doc": "python similarity between two word list counter", "code": "def basic_word_sim(word1, word2):\n    \"\"\"\n    Simple measure of similarity: Number of letters in common / max length\n    \"\"\"\n    return sum([1 for c in word1 if c in word2]) / max(len(word1), len(word2))", "code_tokens": "def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )", "docstring_tokens": "Simple measure of similarity : Number of letters in common / max length", "label": 1}, {"idx": "cosqa-train-3445", "doc": "how to sort a list by last name in python", "code": "def sort_by_name(self):\n        \"\"\"Sort list elements by name.\"\"\"\n        super(JSSObjectList, self).sort(key=lambda k: k.name)", "code_tokens": "def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )", "docstring_tokens": "Sort list elements by name .", "label": 1}, {"idx": "cosqa-train-3446", "doc": "python simple timed cache", "code": "def cached_query(qs, timeout=None):\n    \"\"\" Auto cached queryset and generate results.\n    \"\"\"\n    cache_key = generate_cache_key(qs)\n    return get_cached(cache_key, list, args=(qs,), timeout=None)", "code_tokens": "def cached_query ( qs , timeout = None ) : cache_key = generate_cache_key ( qs ) return get_cached ( cache_key , list , args = ( qs , ) , timeout = None )", "docstring_tokens": "Auto cached queryset and generate results .", "label": 0}, {"idx": "cosqa-train-3447", "doc": "how to sort a list of filenames in python", "code": "def sort_filenames(filenames):\n    \"\"\"\n    sort a list of files by filename only, ignoring the directory names\n    \"\"\"\n    basenames = [os.path.basename(x) for x in filenames]\n    indexes = [i[0] for i in sorted(enumerate(basenames), key=lambda x:x[1])]\n    return [filenames[x] for x in indexes]", "code_tokens": "def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "docstring_tokens": "sort a list of files by filename only ignoring the directory names", "label": 0}, {"idx": "cosqa-train-3448", "doc": "python sinc interpolate with extrapolate", "code": "def lin_interp(x, rangeX, rangeY):\n    \"\"\"\n    Interpolate linearly variable x in rangeX onto rangeY.\n    \"\"\"\n    s = (x - rangeX[0]) / mag(rangeX[1] - rangeX[0])\n    y = rangeY[0] * (1 - s) + rangeY[1] * s\n    return y", "code_tokens": "def lin_interp ( x , rangeX , rangeY ) : s = ( x - rangeX [ 0 ] ) / mag ( rangeX [ 1 ] - rangeX [ 0 ] ) y = rangeY [ 0 ] * ( 1 - s ) + rangeY [ 1 ] * s return y", "docstring_tokens": "Interpolate linearly variable x in rangeX onto rangeY .", "label": 1}, {"idx": "cosqa-train-3449", "doc": "how to sort a list of objects in python", "code": "def csort(objs, key):\n    \"\"\"Order-preserving sorting function.\"\"\"\n    idxs = dict((obj, i) for (i, obj) in enumerate(objs))\n    return sorted(objs, key=lambda obj: (key(obj), idxs[obj]))", "code_tokens": "def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )", "docstring_tokens": "Order - preserving sorting function .", "label": 0}, {"idx": "cosqa-train-3450", "doc": "python slice not continus", "code": "def is_full_slice(obj, l):\n    \"\"\"\n    We have a full length slice.\n    \"\"\"\n    return (isinstance(obj, slice) and obj.start == 0 and obj.stop == l and\n            obj.step is None)", "code_tokens": "def is_full_slice ( obj , l ) : return ( isinstance ( obj , slice ) and obj . start == 0 and obj . stop == l and obj . step is None )", "docstring_tokens": "We have a full length slice .", "label": 0}, {"idx": "cosqa-train-3451", "doc": "how to sort files by name python", "code": "def sort_filenames(filenames):\n    \"\"\"\n    sort a list of files by filename only, ignoring the directory names\n    \"\"\"\n    basenames = [os.path.basename(x) for x in filenames]\n    indexes = [i[0] for i in sorted(enumerate(basenames), key=lambda x:x[1])]\n    return [filenames[x] for x in indexes]", "code_tokens": "def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "docstring_tokens": "sort a list of files by filename only ignoring the directory names", "label": 0}, {"idx": "cosqa-train-3452", "doc": "python slice start end step", "code": "def is_full_slice(obj, l):\n    \"\"\"\n    We have a full length slice.\n    \"\"\"\n    return (isinstance(obj, slice) and obj.start == 0 and obj.stop == l and\n            obj.step is None)", "code_tokens": "def is_full_slice ( obj , l ) : return ( isinstance ( obj , slice ) and obj . start == 0 and obj . stop == l and obj . step is None )", "docstring_tokens": "We have a full length slice .", "label": 0}, {"idx": "cosqa-train-3453", "doc": "how to specify seed for python random", "code": "def generate_seed(seed):\n    \"\"\"Generate seed for random number generator\"\"\"\n    if seed is None:\n        random.seed()\n        seed = random.randint(0, sys.maxsize)\n    random.seed(a=seed)\n\n    return seed", "code_tokens": "def generate_seed ( seed ) : if seed is None : random . seed ( ) seed = random . randint ( 0 , sys . maxsize ) random . seed ( a = seed ) return seed", "docstring_tokens": "Generate seed for random number generator", "label": 1}, {"idx": "cosqa-train-3454", "doc": "python slice string get last", "code": "def fsliceafter(astr, sub):\n    \"\"\"Return the slice after at sub in string astr\"\"\"\n    findex = astr.find(sub)\n    return astr[findex + len(sub):]", "code_tokens": "def fsliceafter ( astr , sub ) : findex = astr . find ( sub ) return astr [ findex + len ( sub ) : ]", "docstring_tokens": "Return the slice after at sub in string astr", "label": 0}, {"idx": "cosqa-train-3455", "doc": "how to specify stringfield validators errors in python", "code": "def validate_type(self, type_):\n        \"\"\"Take an str/unicode `type_` and raise a ValueError if it's not \n        a valid type for the object.\n        \n        A valid type for a field is a value from the types_set attribute of \n        that field's class. \n        \n        \"\"\"\n        if type_ is not None and type_ not in self.types_set:\n            raise ValueError('Invalid type for %s:%s' % (self.__class__, type_))", "code_tokens": "def validate_type ( self , type_ ) : if type_ is not None and type_ not in self . types_set : raise ValueError ( 'Invalid type for %s:%s' % ( self . __class__ , type_ ) )", "docstring_tokens": "Take an str / unicode type_ and raise a ValueError if it s not a valid type for the object . A valid type for a field is a value from the types_set attribute of that field s class .", "label": 0}, {"idx": "cosqa-train-3456", "doc": "python smooth array window", "code": "def movingaverage(arr, window):\n    \"\"\"\n    Calculates the moving average (\"rolling mean\") of an array\n    of a certain window size.\n    \"\"\"\n    m = np.ones(int(window)) / int(window)\n    return scipy.ndimage.convolve1d(arr, m, axis=0, mode='reflect')", "code_tokens": "def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )", "docstring_tokens": "Calculates the moving average ( rolling mean ) of an array of a certain window size .", "label": 0}, {"idx": "cosqa-train-3457", "doc": "how to specify the legend to be outside of a figure in python", "code": "def mpl_outside_legend(ax, **kwargs):\n    \"\"\" Places a legend box outside a matplotlib Axes instance. \"\"\"\n    box = ax.get_position()\n    ax.set_position([box.x0, box.y0, box.width * 0.75, box.height])\n    # Put a legend to the right of the current axis\n    ax.legend(loc='upper left', bbox_to_anchor=(1, 1), **kwargs)", "code_tokens": "def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )", "docstring_tokens": "Places a legend box outside a matplotlib Axes instance .", "label": 0}, {"idx": "cosqa-train-3458", "doc": "python smooth the array", "code": "def smooth_array(array, amount=1):\n    \"\"\"\n\n    Returns the nearest-neighbor (+/- amount) smoothed array.\n    This does not modify the array or slice off the funny end points.\n\n    \"\"\"\n    if amount==0: return array\n\n    # we have to store the old values in a temp array to keep the\n    # smoothing from affecting the smoothing\n    new_array = _n.array(array)\n\n    for n in range(len(array)):\n        new_array[n] = smooth(array, n, amount)\n\n    return new_array", "code_tokens": "def smooth_array ( array , amount = 1 ) : if amount == 0 : return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n . array ( array ) for n in range ( len ( array ) ) : new_array [ n ] = smooth ( array , n , amount ) return new_array", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-3459", "doc": "how to splice a string dynamically in python", "code": "def split(s):\n  \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"\n  l = [_split(x) for x in _SPLIT_RE.split(s)]\n  return [item for sublist in l for item in sublist]", "code_tokens": "def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Uses dynamic programming to infer the location of spaces in a string without spaces .", "label": 0}, {"idx": "cosqa-train-3460", "doc": "python socket address still in use after restarting server", "code": "def pick_unused_port(self):\n    \"\"\" Pick an unused port. There is a slight chance that this wont work. \"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.bind(('127.0.0.1', 0))\n    _, port = s.getsockname()\n    s.close()\n    return port", "code_tokens": "def pick_unused_port ( self ) : s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . bind ( ( '127.0.0.1' , 0 ) ) _ , port = s . getsockname ( ) s . close ( ) return port", "docstring_tokens": "Pick an unused port . There is a slight chance that this wont work .", "label": 0}, {"idx": "cosqa-train-3461", "doc": "how to split a string and recognize spaces python", "code": "def split(s):\n  \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"\n  l = [_split(x) for x in _SPLIT_RE.split(s)]\n  return [item for sublist in l for item in sublist]", "code_tokens": "def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Uses dynamic programming to infer the location of spaces in a string without spaces .", "label": 0}, {"idx": "cosqa-train-3462", "doc": "python socket io flask", "code": "def run(context, port):\n    \"\"\" Run the Webserver/SocketIO and app\n    \"\"\"\n    global ctx\n    ctx = context\n    app.run(port=port)", "code_tokens": "def run ( context , port ) : global ctx ctx = context app . run ( port = port )", "docstring_tokens": "Run the Webserver / SocketIO and app", "label": 0}, {"idx": "cosqa-train-3463", "doc": "how to split string by number of characters in python", "code": "def _split_str(s, n):\n    \"\"\"\n    split string into list of strings by specified number.\n    \"\"\"\n    length = len(s)\n    return [s[i:i + n] for i in range(0, length, n)]", "code_tokens": "def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]", "docstring_tokens": "split string into list of strings by specified number .", "label": 0}, {"idx": "cosqa-train-3464", "doc": "python socketio sid room userid", "code": "def enter_room(self, sid, room, namespace=None):\n        \"\"\"Enter a room.\n\n        The only difference with the :func:`socketio.Server.enter_room` method\n        is that when the ``namespace`` argument is not given the namespace\n        associated with the class is used.\n        \"\"\"\n        return self.server.enter_room(sid, room,\n                                      namespace=namespace or self.namespace)", "code_tokens": "def enter_room ( self , sid , room , namespace = None ) : return self . server . enter_room ( sid , room , namespace = namespace or self . namespace )", "docstring_tokens": "Enter a room .", "label": 0}, {"idx": "cosqa-train-3465", "doc": "how to stop the consol window from closing in python", "code": "def end(self):\n        \"\"\"End of the Glances server session.\"\"\"\n        if not self.args.disable_autodiscover:\n            self.autodiscover_client.close()\n        self.server.end()", "code_tokens": "def end ( self ) : if not self . args . disable_autodiscover : self . autodiscover_client . close ( ) self . server . end ( )", "docstring_tokens": "End of the Glances server session .", "label": 0}, {"idx": "cosqa-train-3466", "doc": "python sort array return indices", "code": "def argsort_indices(a, axis=-1):\n    \"\"\"Like argsort, but returns an index suitable for sorting the\n    the original array even if that array is multidimensional\n    \"\"\"\n    a = np.asarray(a)\n    ind = list(np.ix_(*[np.arange(d) for d in a.shape]))\n    ind[axis] = a.argsort(axis)\n    return tuple(ind)", "code_tokens": "def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )", "docstring_tokens": "Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional", "label": 0}, {"idx": "cosqa-train-3467", "doc": "how to strip caracter from srings in list in python", "code": "def delistify(x):\n    \"\"\" A basic slug version of a given parameter list. \"\"\"\n    if isinstance(x, list):\n        x = [e.replace(\"'\", \"\") for e in x]\n        return '-'.join(sorted(x))\n    return x", "code_tokens": "def delistify ( x ) : if isinstance ( x , list ) : x = [ e . replace ( \"'\" , \"\" ) for e in x ] return '-' . join ( sorted ( x ) ) return x", "docstring_tokens": "A basic slug version of a given parameter list .", "label": 0}, {"idx": "cosqa-train-3468", "doc": "python sort custom key", "code": "def transcript_sort_key(transcript):\n    \"\"\"\n    Key function used to sort transcripts. Taking the negative of\n    protein sequence length and nucleotide sequence length so that\n    the transcripts with longest sequences come first in the list. This couldn't\n    be accomplished with `reverse=True` since we're also sorting by\n    transcript name (which places TP53-001 before TP53-002).\n    \"\"\"\n    return (\n        -len(transcript.protein_sequence),\n        -len(transcript.sequence),\n        transcript.name\n    )", "code_tokens": "def transcript_sort_key ( transcript ) : return ( - len ( transcript . protein_sequence ) , - len ( transcript . sequence ) , transcript . name )", "docstring_tokens": "Key function used to sort transcripts . Taking the negative of protein sequence length and nucleotide sequence length so that the transcripts with longest sequences come first in the list . This couldn t be accomplished with reverse = True since we re also sorting by transcript name ( which places TP53 - 001 before TP53 - 002 ) .", "label": 0}, {"idx": "cosqa-train-3469", "doc": "how to substitute variables into sympy python", "code": "def access_to_sympy(self, var_name, access):\n        \"\"\"\n        Transform a (multidimensional) variable access to a flattend sympy expression.\n\n        Also works with flat array accesses.\n        \"\"\"\n        base_sizes = self.variables[var_name][1]\n\n        expr = sympy.Number(0)\n\n        for dimension, a in enumerate(access):\n            base_size = reduce(operator.mul, base_sizes[dimension+1:], sympy.Integer(1))\n\n            expr += base_size*a\n\n        return expr", "code_tokens": "def access_to_sympy ( self , var_name , access ) : base_sizes = self . variables [ var_name ] [ 1 ] expr = sympy . Number ( 0 ) for dimension , a in enumerate ( access ) : base_size = reduce ( operator . mul , base_sizes [ dimension + 1 : ] , sympy . Integer ( 1 ) ) expr += base_size * a return expr", "docstring_tokens": "Transform a ( multidimensional ) variable access to a flattend sympy expression .", "label": 0}, {"idx": "cosqa-train-3470", "doc": "python sort dict iterator", "code": "def _dict_values_sorted_by_key(dictionary):\n    # This should be a yield from instead.\n    \"\"\"Internal helper to return the values of a dictionary, sorted by key.\n    \"\"\"\n    for _, value in sorted(dictionary.iteritems(), key=operator.itemgetter(0)):\n        yield value", "code_tokens": "def _dict_values_sorted_by_key ( dictionary ) : # This should be a yield from instead. for _ , value in sorted ( dictionary . iteritems ( ) , key = operator . itemgetter ( 0 ) ) : yield value", "docstring_tokens": "Internal helper to return the values of a dictionary sorted by key .", "label": 0}, {"idx": "cosqa-train-3471", "doc": "how to sum specific column in python", "code": "def query_sum(queryset, field):\n    \"\"\"\n    Let the DBMS perform a sum on a queryset\n    \"\"\"\n    return queryset.aggregate(s=models.functions.Coalesce(models.Sum(field), 0))['s']", "code_tokens": "def query_sum ( queryset , field ) : return queryset . aggregate ( s = models . functions . Coalesce ( models . Sum ( field ) , 0 ) ) [ 's' ]", "docstring_tokens": "Let the DBMS perform a sum on a queryset", "label": 0}, {"idx": "cosqa-train-3472", "doc": "python sort filenames numerically", "code": "def sort_filenames(filenames):\n    \"\"\"\n    sort a list of files by filename only, ignoring the directory names\n    \"\"\"\n    basenames = [os.path.basename(x) for x in filenames]\n    indexes = [i[0] for i in sorted(enumerate(basenames), key=lambda x:x[1])]\n    return [filenames[x] for x in indexes]", "code_tokens": "def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "docstring_tokens": "sort a list of files by filename only ignoring the directory names", "label": 0}, {"idx": "cosqa-train-3473", "doc": "how to supress the output of executing shell script in python", "code": "def disown(cmd):\n    \"\"\"Call a system command in the background,\n       disown it and hide it's output.\"\"\"\n    subprocess.Popen(cmd,\n                     stdout=subprocess.DEVNULL,\n                     stderr=subprocess.DEVNULL)", "code_tokens": "def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "docstring_tokens": "Call a system command in the background disown it and hide it s output .", "label": 0}, {"idx": "cosqa-train-3474", "doc": "python sort for files but not folders", "code": "def sort_filenames(filenames):\n    \"\"\"\n    sort a list of files by filename only, ignoring the directory names\n    \"\"\"\n    basenames = [os.path.basename(x) for x in filenames]\n    indexes = [i[0] for i in sorted(enumerate(basenames), key=lambda x:x[1])]\n    return [filenames[x] for x in indexes]", "code_tokens": "def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "docstring_tokens": "sort a list of files by filename only ignoring the directory names", "label": 0}, {"idx": "cosqa-train-3475", "doc": "how to swap lower case with uppercase in python", "code": "def to_capitalized_camel_case(snake_case_string):\n    \"\"\"\n    Convert a string from snake case to camel case with the first letter capitalized. For example, \"some_var\"\n    would become \"SomeVar\".\n\n    :param snake_case_string: Snake-cased string to convert to camel case.\n    :returns: Camel-cased version of snake_case_string.\n    \"\"\"\n    parts = snake_case_string.split('_')\n    return ''.join([i.title() for i in parts])", "code_tokens": "def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )", "docstring_tokens": "Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar .", "label": 0}, {"idx": "cosqa-train-3476", "doc": "python sort list of names by last name", "code": "def sort_by_name(self):\n        \"\"\"Sort list elements by name.\"\"\"\n        super(JSSObjectList, self).sort(key=lambda k: k.name)", "code_tokens": "def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )", "docstring_tokens": "Sort list elements by name .", "label": 0}, {"idx": "cosqa-train-3477", "doc": "how to take the inverse of a matrix in python", "code": "def inh(table):\n    \"\"\"\n    inverse hyperbolic sine transformation\n    \"\"\"\n    t = []\n    for i in table:\n        t.append(np.ndarray.tolist(np.arcsinh(i)))\n    return t", "code_tokens": "def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "docstring_tokens": "inverse hyperbolic sine transformation", "label": 0}, {"idx": "cosqa-train-3478", "doc": "python source is not defined", "code": "def get_py_source(file):\n    \"\"\"\n    Retrieves and returns the source code for any Python\n    files requested by the UI via the host agent\n\n    @param file [String] The fully qualified path to a file\n    \"\"\"\n    try:\n        response = None\n        pysource = \"\"\n\n        if regexp_py.search(file) is None:\n            response = {\"error\": \"Only Python source files are allowed. (*.py)\"}\n        else:\n            with open(file, 'r') as pyfile:\n                pysource = pyfile.read()\n\n            response = {\"data\": pysource}\n\n    except Exception as e:\n        response = {\"error\": str(e)}\n    finally:\n        return response", "code_tokens": "def get_py_source ( file ) : try : response = None pysource = \"\" if regexp_py . search ( file ) is None : response = { \"error\" : \"Only Python source files are allowed. (*.py)\" } else : with open ( file , 'r' ) as pyfile : pysource = pyfile . read ( ) response = { \"data\" : pysource } except Exception as e : response = { \"error\" : str ( e ) } finally : return response", "docstring_tokens": "Retrieves and returns the source code for any Python files requested by the UI via the host agent", "label": 0}, {"idx": "cosqa-train-3479", "doc": "how to take the squareroot without squareroot function in python", "code": "def _root_mean_square_error(y, y_pred, w):\n    \"\"\"Calculate the root mean square error.\"\"\"\n    return np.sqrt(np.average(((y_pred - y) ** 2), weights=w))", "code_tokens": "def _root_mean_square_error ( y , y_pred , w ) : return np . sqrt ( np . average ( ( ( y_pred - y ) ** 2 ) , weights = w ) )", "docstring_tokens": "Calculate the root mean square error .", "label": 0}, {"idx": "cosqa-train-3480", "doc": "python source, target replace", "code": "def replace(scope, strings, source, dest):\n    \"\"\"\n    Returns a copy of the given string (or list of strings) in which all\n    occurrences of the given source are replaced by the given dest.\n\n    :type  strings: string\n    :param strings: A string, or a list of strings.\n    :type  source: string\n    :param source: What to replace.\n    :type  dest: string\n    :param dest: What to replace it with.\n    :rtype:  string\n    :return: The resulting string, or list of strings.\n    \"\"\"\n    return [s.replace(source[0], dest[0]) for s in strings]", "code_tokens": "def replace ( scope , strings , source , dest ) : return [ s . replace ( source [ 0 ] , dest [ 0 ] ) for s in strings ]", "docstring_tokens": "Returns a copy of the given string ( or list of strings ) in which all occurrences of the given source are replaced by the given dest .", "label": 0}, {"idx": "cosqa-train-3481", "doc": "how to tale a 2 d matrix as input in python", "code": "def im2mat(I):\n    \"\"\"Converts and image to matrix (one pixel per line)\"\"\"\n    return I.reshape((I.shape[0] * I.shape[1], I.shape[2]))", "code_tokens": "def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )", "docstring_tokens": "Converts and image to matrix ( one pixel per line )", "label": 0}, {"idx": "cosqa-train-3482", "doc": "python sparse array numpy dask", "code": "def toArray(self):\n        \"\"\"\n        Returns a copy of this SparseVector as a 1-dimensional NumPy array.\n        \"\"\"\n        arr = np.zeros((self.size,), dtype=np.float64)\n        arr[self.indices] = self.values\n        return arr", "code_tokens": "def toArray ( self ) : arr = np . zeros ( ( self . size , ) , dtype = np . float64 ) arr [ self . indices ] = self . values return arr", "docstring_tokens": "Returns a copy of this SparseVector as a 1 - dimensional NumPy array .", "label": 0}, {"idx": "cosqa-train-3483", "doc": "how to tell a character is not ascii in python", "code": "def unicode_is_ascii(u_string):\n    \"\"\"Determine if unicode string only contains ASCII characters.\n\n    :param str u_string: unicode string to check. Must be unicode\n        and not Python 2 `str`.\n    :rtype: bool\n    \"\"\"\n    assert isinstance(u_string, str)\n    try:\n        u_string.encode('ascii')\n        return True\n    except UnicodeEncodeError:\n        return False", "code_tokens": "def unicode_is_ascii ( u_string ) : assert isinstance ( u_string , str ) try : u_string . encode ( 'ascii' ) return True except UnicodeEncodeError : return False", "docstring_tokens": "Determine if unicode string only contains ASCII characters .", "label": 0}, {"idx": "cosqa-train-3484", "doc": "python specify next line", "code": "def step_next_line(self):\n        \"\"\"Sets cursor as beginning of next line.\"\"\"\n        self._eol.append(self.position)\n        self._lineno += 1\n        self._col_offset = 0", "code_tokens": "def step_next_line ( self ) : self . _eol . append ( self . position ) self . _lineno += 1 self . _col_offset = 0", "docstring_tokens": "Sets cursor as beginning of next line .", "label": 0}, {"idx": "cosqa-train-3485", "doc": "how to tell data type string python", "code": "def datatype(dbtype, description, cursor):\n    \"\"\"Google AppEngine Helper to convert a data type into a string.\"\"\"\n    dt = cursor.db.introspection.get_field_type(dbtype, description)\n    if type(dt) is tuple:\n        return dt[0]\n    else:\n        return dt", "code_tokens": "def datatype ( dbtype , description , cursor ) : dt = cursor . db . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt", "docstring_tokens": "Google AppEngine Helper to convert a data type into a string .", "label": 0}, {"idx": "cosqa-train-3486", "doc": "python sphinx not in path", "code": "def read_sphinx_environment(pth):\n    \"\"\"Read the sphinx environment.pickle file at path `pth`.\"\"\"\n\n    with open(pth, 'rb') as fo:\n        env = pickle.load(fo)\n    return env", "code_tokens": "def read_sphinx_environment ( pth ) : with open ( pth , 'rb' ) as fo : env = pickle . load ( fo ) return env", "docstring_tokens": "Read the sphinx environment . pickle file at path pth .", "label": 0}, {"idx": "cosqa-train-3487", "doc": "how to tell if file is image python", "code": "def _is_image_sequenced(image):\n    \"\"\"Determine if the image is a sequenced image.\"\"\"\n    try:\n        image.seek(1)\n        image.seek(0)\n        result = True\n    except EOFError:\n        result = False\n\n    return result", "code_tokens": "def _is_image_sequenced ( image ) : try : image . seek ( 1 ) image . seek ( 0 ) result = True except EOFError : result = False return result", "docstring_tokens": "Determine if the image is a sequenced image .", "label": 0}, {"idx": "cosqa-train-3488", "doc": "python split array into chunks by two variables", "code": "def consecutive(data, stepsize=1):\n    \"\"\"Converts array into chunks with consecutive elements of given step size.\n    http://stackoverflow.com/questions/7352684/how-to-find-the-groups-of-consecutive-elements-from-an-array-in-numpy\n    \"\"\"\n    return np.split(data, np.where(np.diff(data) != stepsize)[0] + 1)", "code_tokens": "def consecutive ( data , stepsize = 1 ) : return np . split ( data , np . where ( np . diff ( data ) != stepsize ) [ 0 ] + 1 )", "docstring_tokens": "Converts array into chunks with consecutive elements of given step size . http : // stackoverflow . com / questions / 7352684 / how - to - find - the - groups - of - consecutive - elements - from - an - array - in - numpy", "label": 1}, {"idx": "cosqa-train-3489", "doc": "how to tell python to move down a line", "code": "def go_to_line(self, line):\n        \"\"\"\n        Moves the text cursor to given line.\n\n        :param line: Line to go to.\n        :type line: int\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        cursor = self.textCursor()\n        cursor.setPosition(self.document().findBlockByNumber(line - 1).position())\n        self.setTextCursor(cursor)\n        return True", "code_tokens": "def go_to_line ( self , line ) : cursor = self . textCursor ( ) cursor . setPosition ( self . document ( ) . findBlockByNumber ( line - 1 ) . position ( ) ) self . setTextCursor ( cursor ) return True", "docstring_tokens": "Moves the text cursor to given line .", "label": 0}, {"idx": "cosqa-train-3490", "doc": "python split sentences into list", "code": "def split_into_sentences(s):\n  \"\"\"Split text into list of sentences.\"\"\"\n  s = re.sub(r\"\\s+\", \" \", s)\n  s = re.sub(r\"[\\\\.\\\\?\\\\!]\", \"\\n\", s)\n  return s.split(\"\\n\")", "code_tokens": "def split_into_sentences ( s ) : s = re . sub ( r\"\\s+\" , \" \" , s ) s = re . sub ( r\"[\\\\.\\\\?\\\\!]\" , \"\\n\" , s ) return s . split ( \"\\n\" )", "docstring_tokens": "Split text into list of sentences .", "label": 0}, {"idx": "cosqa-train-3491", "doc": "how to test a image is valid in python", "code": "def is_image_file_valid(file_path_name):\n    \"\"\"\n    Indicate whether the specified image file is valid or not.\n\n\n    @param file_path_name: absolute path and file name of an image.\n\n\n    @return: ``True`` if the image file is valid, ``False`` if the file is\n        truncated or does not correspond to a supported image.\n    \"\"\"\n    # Image.verify is only implemented for PNG images, and it only verifies\n    # the CRC checksum in the image.  The only way to check from within\n    # Pillow is to load the image in a try/except and check the error.  If\n    # as much info as possible is from the image is needed,\n    # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it\n    # will attempt to parse as much as possible.\n    try:\n        with Image.open(file_path_name) as image:\n            image.load()\n    except IOError:\n        return False\n\n    return True", "code_tokens": "def is_image_file_valid ( file_path_name ) : # Image.verify is only implemented for PNG images, and it only verifies # the CRC checksum in the image.  The only way to check from within # Pillow is to load the image in a try/except and check the error.  If # as much info as possible is from the image is needed, # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it # will attempt to parse as much as possible. try : with Image . open ( file_path_name ) as image : image . load ( ) except IOError : return False return True", "docstring_tokens": "Indicate whether the specified image file is valid or not .", "label": 0}, {"idx": "cosqa-train-3492", "doc": "python split string based on comma into list and remove new line", "code": "def split_multiline(value):\n    \"\"\"Split a multiline string into a list, excluding blank lines.\"\"\"\n    return [element for element in (line.strip() for line in value.split('\\n'))\n            if element]", "code_tokens": "def split_multiline ( value ) : return [ element for element in ( line . strip ( ) for line in value . split ( '\\n' ) ) if element ]", "docstring_tokens": "Split a multiline string into a list excluding blank lines .", "label": 1}, {"idx": "cosqa-train-3493", "doc": "how to test if a dictionary has a key ? in python", "code": "def __contains__ (self, key):\n        \"\"\"Check lowercase key item.\"\"\"\n        assert isinstance(key, basestring)\n        return dict.__contains__(self, key.lower())", "code_tokens": "def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "docstring_tokens": "Check lowercase key item .", "label": 0}, {"idx": "cosqa-train-3494", "doc": "python splitlines filter empty line", "code": "def cleanLines(source, lineSep=os.linesep):\n    \"\"\"\n    :param source: some iterable source (list, file, etc)\n    :param lineSep: string of separators (chars) that must be removed\n    :return: list of non empty lines with removed separators\n    \"\"\"\n    stripped = (line.strip(lineSep) for line in source)\n    return (line for line in stripped if len(line) != 0)", "code_tokens": "def cleanLines ( source , lineSep = os . linesep ) : stripped = ( line . strip ( lineSep ) for line in source ) return ( line for line in stripped if len ( line ) != 0 )", "docstring_tokens": ": param source : some iterable source ( list file etc ) : param lineSep : string of separators ( chars ) that must be removed : return : list of non empty lines with removed separators", "label": 0}, {"idx": "cosqa-train-3495", "doc": "how to tokenize in python without split", "code": "def tokenize(string):\n    \"\"\"Match and yield all the tokens of the input string.\"\"\"\n    for match in TOKENS_REGEX.finditer(string):\n        yield Token(match.lastgroup, match.group().strip(), match.span())", "code_tokens": "def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "docstring_tokens": "Match and yield all the tokens of the input string .", "label": 0}, {"idx": "cosqa-train-3496", "doc": "python spreadstring on multiple lines", "code": "def reindent(s, numspaces):\n    \"\"\" reinidents a string (s) by the given number of spaces (numspaces) \"\"\"\n    leading_space = numspaces * ' '\n    lines = [leading_space + line.strip()for line in s.splitlines()]\n    return '\\n'.join(lines)", "code_tokens": "def reindent ( s , numspaces ) : leading_space = numspaces * ' ' lines = [ leading_space + line . strip ( ) for line in s . splitlines ( ) ] return '\\n' . join ( lines )", "docstring_tokens": "reinidents a string ( s ) by the given number of spaces ( numspaces )", "label": 0}, {"idx": "cosqa-train-3497", "doc": "how to track the number of times a function is called python", "code": "def wrap_count(method):\n    \"\"\"\n    Returns number of wraps around given method.\n    \"\"\"\n    number = 0\n    while hasattr(method, '__aspects_orig'):\n        number += 1\n        method = method.__aspects_orig\n    return number", "code_tokens": "def wrap_count ( method ) : number = 0 while hasattr ( method , '__aspects_orig' ) : number += 1 method = method . __aspects_orig return number", "docstring_tokens": "Returns number of wraps around given method .", "label": 0}, {"idx": "cosqa-train-3498", "doc": "python spyder how to restart the kernel", "code": "def restart(self, reset=False):\n        \"\"\"\n        Quit and Restart Spyder application.\n\n        If reset True it allows to reset spyder on restart.\n        \"\"\"\n        # Get start path to use in restart script\n        spyder_start_directory = get_module_path('spyder')\n        restart_script = osp.join(spyder_start_directory, 'app', 'restart.py')\n\n        # Get any initial argument passed when spyder was started\n        # Note: Variables defined in bootstrap.py and spyder/app/start.py\n        env = os.environ.copy()\n        bootstrap_args = env.pop('SPYDER_BOOTSTRAP_ARGS', None)\n        spyder_args = env.pop('SPYDER_ARGS')\n\n        # Get current process and python running spyder\n        pid = os.getpid()\n        python = sys.executable\n\n        # Check if started with bootstrap.py\n        if bootstrap_args is not None:\n            spyder_args = bootstrap_args\n            is_bootstrap = True\n        else:\n            is_bootstrap = False\n\n        # Pass variables as environment variables (str) to restarter subprocess\n        env['SPYDER_ARGS'] = spyder_args\n        env['SPYDER_PID'] = str(pid)\n        env['SPYDER_IS_BOOTSTRAP'] = str(is_bootstrap)\n        env['SPYDER_RESET'] = str(reset)\n\n        if DEV:\n            if os.name == 'nt':\n                env['PYTHONPATH'] = ';'.join(sys.path)\n            else:\n                env['PYTHONPATH'] = ':'.join(sys.path)\n\n        # Build the command and popen arguments depending on the OS\n        if os.name == 'nt':\n            # Hide flashing command prompt\n            startupinfo = subprocess.STARTUPINFO()\n            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n            shell = False\n        else:\n            startupinfo = None\n            shell = True\n\n        command = '\"{0}\" \"{1}\"'\n        command = command.format(python, restart_script)\n\n        try:\n            if self.closing(True):\n                subprocess.Popen(command, shell=shell, env=env,\n                                 startupinfo=startupinfo)\n                self.console.quit()\n        except Exception as error:\n            # If there is an error with subprocess, Spyder should not quit and\n            # the error can be inspected in the internal console\n            print(error)  # spyder: test-skip\n            print(command)", "code_tokens": "def restart ( self , reset = False ) : # Get start path to use in restart script\n spyder_start_directory = get_module_path ( 'spyder' ) restart_script = osp . join ( spyder_start_directory , 'app' , 'restart.py' ) # Get any initial argument passed when spyder was started\n # Note: Variables defined in bootstrap.py and spyder/app/start.py\n env = os . environ . copy ( ) bootstrap_args = env . pop ( 'SPYDER_BOOTSTRAP_ARGS' , None ) spyder_args = env . pop ( 'SPYDER_ARGS' ) # Get current process and python running spyder\n pid = os . getpid ( ) python = sys . executable # Check if started with bootstrap.py\n if bootstrap_args is not None : spyder_args = bootstrap_args is_bootstrap = True else : is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess\n env [ 'SPYDER_ARGS' ] = spyder_args env [ 'SPYDER_PID' ] = str ( pid ) env [ 'SPYDER_IS_BOOTSTRAP' ] = str ( is_bootstrap ) env [ 'SPYDER_RESET' ] = str ( reset ) if DEV : if os . name == 'nt' : env [ 'PYTHONPATH' ] = ';' . join ( sys . path ) else : env [ 'PYTHONPATH' ] = ':' . join ( sys . path ) # Build the command and popen arguments depending on the OS\n if os . name == 'nt' : # Hide flashing command prompt\n startupinfo = subprocess . STARTUPINFO ( ) startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW shell = False else : startupinfo = None shell = True command = '\"{0}\" \"{1}\"' command = command . format ( python , restart_script ) try : if self . closing ( True ) : subprocess . Popen ( command , shell = shell , env = env , startupinfo = startupinfo ) self . console . quit ( ) except Exception as error : # If there is an error with subprocess, Spyder should not quit and\n # the error can be inspected in the internal console\n print ( error ) # spyder: test-skip\n print ( command )", "docstring_tokens": "Quit and Restart Spyder application . If reset True it allows to reset spyder on restart .", "label": 1}, {"idx": "cosqa-train-3499", "doc": "how to transfer a list to string inpython", "code": "def list_i2str(ilist):\n    \"\"\"\n    Convert an integer list into a string list.\n    \"\"\"\n    slist = []\n    for el in ilist:\n        slist.append(str(el))\n    return slist", "code_tokens": "def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist", "docstring_tokens": "Convert an integer list into a string list .", "label": 0}, {"idx": "cosqa-train-3500", "doc": "python spyder kenerl died restarting", "code": "def restart(self, reset=False):\n        \"\"\"\n        Quit and Restart Spyder application.\n\n        If reset True it allows to reset spyder on restart.\n        \"\"\"\n        # Get start path to use in restart script\n        spyder_start_directory = get_module_path('spyder')\n        restart_script = osp.join(spyder_start_directory, 'app', 'restart.py')\n\n        # Get any initial argument passed when spyder was started\n        # Note: Variables defined in bootstrap.py and spyder/app/start.py\n        env = os.environ.copy()\n        bootstrap_args = env.pop('SPYDER_BOOTSTRAP_ARGS', None)\n        spyder_args = env.pop('SPYDER_ARGS')\n\n        # Get current process and python running spyder\n        pid = os.getpid()\n        python = sys.executable\n\n        # Check if started with bootstrap.py\n        if bootstrap_args is not None:\n            spyder_args = bootstrap_args\n            is_bootstrap = True\n        else:\n            is_bootstrap = False\n\n        # Pass variables as environment variables (str) to restarter subprocess\n        env['SPYDER_ARGS'] = spyder_args\n        env['SPYDER_PID'] = str(pid)\n        env['SPYDER_IS_BOOTSTRAP'] = str(is_bootstrap)\n        env['SPYDER_RESET'] = str(reset)\n\n        if DEV:\n            if os.name == 'nt':\n                env['PYTHONPATH'] = ';'.join(sys.path)\n            else:\n                env['PYTHONPATH'] = ':'.join(sys.path)\n\n        # Build the command and popen arguments depending on the OS\n        if os.name == 'nt':\n            # Hide flashing command prompt\n            startupinfo = subprocess.STARTUPINFO()\n            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n            shell = False\n        else:\n            startupinfo = None\n            shell = True\n\n        command = '\"{0}\" \"{1}\"'\n        command = command.format(python, restart_script)\n\n        try:\n            if self.closing(True):\n                subprocess.Popen(command, shell=shell, env=env,\n                                 startupinfo=startupinfo)\n                self.console.quit()\n        except Exception as error:\n            # If there is an error with subprocess, Spyder should not quit and\n            # the error can be inspected in the internal console\n            print(error)  # spyder: test-skip\n            print(command)", "code_tokens": "def restart ( self , reset = False ) : # Get start path to use in restart script\n spyder_start_directory = get_module_path ( 'spyder' ) restart_script = osp . join ( spyder_start_directory , 'app' , 'restart.py' ) # Get any initial argument passed when spyder was started\n # Note: Variables defined in bootstrap.py and spyder/app/start.py\n env = os . environ . copy ( ) bootstrap_args = env . pop ( 'SPYDER_BOOTSTRAP_ARGS' , None ) spyder_args = env . pop ( 'SPYDER_ARGS' ) # Get current process and python running spyder\n pid = os . getpid ( ) python = sys . executable # Check if started with bootstrap.py\n if bootstrap_args is not None : spyder_args = bootstrap_args is_bootstrap = True else : is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess\n env [ 'SPYDER_ARGS' ] = spyder_args env [ 'SPYDER_PID' ] = str ( pid ) env [ 'SPYDER_IS_BOOTSTRAP' ] = str ( is_bootstrap ) env [ 'SPYDER_RESET' ] = str ( reset ) if DEV : if os . name == 'nt' : env [ 'PYTHONPATH' ] = ';' . join ( sys . path ) else : env [ 'PYTHONPATH' ] = ':' . join ( sys . path ) # Build the command and popen arguments depending on the OS\n if os . name == 'nt' : # Hide flashing command prompt\n startupinfo = subprocess . STARTUPINFO ( ) startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW shell = False else : startupinfo = None shell = True command = '\"{0}\" \"{1}\"' command = command . format ( python , restart_script ) try : if self . closing ( True ) : subprocess . Popen ( command , shell = shell , env = env , startupinfo = startupinfo ) self . console . quit ( ) except Exception as error : # If there is an error with subprocess, Spyder should not quit and\n # the error can be inspected in the internal console\n print ( error ) # spyder: test-skip\n print ( command )", "docstring_tokens": "Quit and Restart Spyder application . If reset True it allows to reset spyder on restart .", "label": 0}, {"idx": "cosqa-train-3501", "doc": "how to traverse all elements of a 1d numpy array in python", "code": "def length(self):\n        \"\"\"Array of vector lengths\"\"\"\n        return np.sqrt(np.sum(self**2, axis=1)).view(np.ndarray)", "code_tokens": "def length ( self ) : return np . sqrt ( np . sum ( self ** 2 , axis = 1 ) ) . view ( np . ndarray )", "docstring_tokens": "Array of vector lengths", "label": 1}, {"idx": "cosqa-train-3502", "doc": "python sql results to dict", "code": "def _bindingsToDict(self, bindings):\n        \"\"\"\n        Given a binding from the sparql query result,\n        create a dict of plain text\n        \"\"\"\n        myDict = {}\n        for key, val in bindings.iteritems():\n            myDict[key.toPython().replace('?', '')] = val.toPython()\n        return myDict", "code_tokens": "def _bindingsToDict ( self , bindings ) : myDict = { } for key , val in bindings . iteritems ( ) : myDict [ key . toPython ( ) . replace ( '?' , '' ) ] = val . toPython ( ) return myDict", "docstring_tokens": "Given a binding from the sparql query result create a dict of plain text", "label": 0}, {"idx": "cosqa-train-3503", "doc": "python sqlalchemy how to insert multiple records", "code": "def insert_many(self, items):\n    \"\"\"\n    Insert many items at once into a temporary table.\n\n    \"\"\"\n    return SessionContext.session.execute(\n        self.insert(values=[\n            to_dict(item, self.c)\n            for item in items\n        ]),\n    ).rowcount", "code_tokens": "def insert_many ( self , items ) : return SessionContext . session . execute ( self . insert ( values = [ to_dict ( item , self . c ) for item in items ] ) , ) . rowcount", "docstring_tokens": "Insert many items at once into a temporary table .", "label": 1}, {"idx": "cosqa-train-3504", "doc": "how to type in a string in python", "code": "def visit_Str(self, node):\n        \"\"\" Set the pythonic string type. \"\"\"\n        self.result[node] = self.builder.NamedType(pytype_to_ctype(str))", "code_tokens": "def visit_Str ( self , node ) : self . result [ node ] = self . builder . NamedType ( pytype_to_ctype ( str ) )", "docstring_tokens": "Set the pythonic string type .", "label": 0}, {"idx": "cosqa-train-3505", "doc": "python sqlalchemy ow to get size of resultset", "code": "def get_count(self, query):\n        \"\"\"\n        Returns a number of query results. This is faster than .count() on the query\n        \"\"\"\n        count_q = query.statement.with_only_columns(\n            [func.count()]).order_by(None)\n        count = query.session.execute(count_q).scalar()\n        return count", "code_tokens": "def get_count ( self , query ) : count_q = query . statement . with_only_columns ( [ func . count ( ) ] ) . order_by ( None ) count = query . session . execute ( count_q ) . scalar ( ) return count", "docstring_tokens": "Returns a number of query results . This is faster than . count () on the query", "label": 0}, {"idx": "cosqa-train-3506", "doc": "how to undo a migration\\ in python", "code": "def downgrade(directory, sql, tag, x_arg, revision):\n    \"\"\"Revert to a previous version\"\"\"\n    _downgrade(directory, revision, sql, tag, x_arg)", "code_tokens": "def downgrade ( directory , sql , tag , x_arg , revision ) : _downgrade ( directory , revision , sql , tag , x_arg )", "docstring_tokens": "Revert to a previous version", "label": 0}, {"idx": "cosqa-train-3507", "doc": "python sqlalchemy session drop table", "code": "def unlock(self):\n    \"\"\"Closes the session to the database.\"\"\"\n    if not hasattr(self, 'session'):\n      raise RuntimeError('Error detected! The session that you want to close does not exist any more!')\n    logger.debug(\"Closed database session of '%s'\" % self._database)\n    self.session.close()\n    del self.session", "code_tokens": "def unlock ( self ) : if not hasattr ( self , 'session' ) : raise RuntimeError ( 'Error detected! The session that you want to close does not exist any more!' ) logger . debug ( \"Closed database session of '%s'\" % self . _database ) self . session . close ( ) del self . session", "docstring_tokens": "Closes the session to the database .", "label": 0}, {"idx": "cosqa-train-3508", "doc": "how to use compiles c++ libraries in python", "code": "def cpp_prog_builder(build_context, target):\n    \"\"\"Build a C++ binary executable\"\"\"\n    yprint(build_context.conf, 'Build CppProg', target)\n    workspace_dir = build_context.get_workspace('CppProg', target.name)\n    build_cpp(build_context, target, target.compiler_config, workspace_dir)", "code_tokens": "def cpp_prog_builder ( build_context , target ) : yprint ( build_context . conf , 'Build CppProg' , target ) workspace_dir = build_context . get_workspace ( 'CppProg' , target . name ) build_cpp ( build_context , target , target . compiler_config , workspace_dir )", "docstring_tokens": "Build a C ++ binary executable", "label": 0}, {"idx": "cosqa-train-3509", "doc": "python sqlite check columnexists", "code": "def column_exists(cr, table, column):\n    \"\"\" Check whether a certain column exists \"\"\"\n    cr.execute(\n        'SELECT count(attname) FROM pg_attribute '\n        'WHERE attrelid = '\n        '( SELECT oid FROM pg_class WHERE relname = %s ) '\n        'AND attname = %s',\n        (table, column))\n    return cr.fetchone()[0] == 1", "code_tokens": "def column_exists ( cr , table , column ) : cr . execute ( 'SELECT count(attname) FROM pg_attribute ' 'WHERE attrelid = ' '( SELECT oid FROM pg_class WHERE relname = %s ) ' 'AND attname = %s' , ( table , column ) ) return cr . fetchone ( ) [ 0 ] == 1", "docstring_tokens": "Check whether a certain column exists", "label": 0}, {"idx": "cosqa-train-3510", "doc": "how to use conda env in python code", "code": "def create_conda_env(sandbox_dir, env_name, dependencies, options=()):\n    \"\"\"\n    Create a conda environment inside the current sandbox for the given list of dependencies and options.\n\n    Parameters\n    ----------\n    sandbox_dir : str\n    env_name : str\n    dependencies : list\n        List of conda specs\n    options\n        List of additional options to pass to conda.  Things like [\"-c\", \"conda-forge\"]\n\n    Returns\n    -------\n    (env_dir, env_name)\n    \"\"\"\n\n    env_dir = os.path.join(sandbox_dir, env_name)\n    cmdline = [\"conda\", \"create\", \"--yes\", \"--copy\", \"--quiet\", \"-p\", env_dir] + list(options) + dependencies\n\n    log.info(\"Creating conda environment: \")\n    log.info(\"  command line: %s\", cmdline)\n    subprocess.check_call(cmdline, stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n    log.debug(\"Environment created\")\n\n    return env_dir, env_name", "code_tokens": "def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ \"conda\" , \"create\" , \"--yes\" , \"--copy\" , \"--quiet\" , \"-p\" , env_dir ] + list ( options ) + dependencies log . info ( \"Creating conda environment: \" ) log . info ( \"  command line: %s\" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( \"Environment created\" ) return env_dir , env_name", "docstring_tokens": "Create a conda environment inside the current sandbox for the given list of dependencies and options .", "label": 1}, {"idx": "cosqa-train-3511", "doc": "python sqlite select into dictionary", "code": "def sqliteRowsToDicts(sqliteRows):\n    \"\"\"\n    Unpacks sqlite rows as returned by fetchall\n    into an array of simple dicts.\n\n    :param sqliteRows: array of rows returned from fetchall DB call\n    :return:  array of dicts, keyed by the column names.\n    \"\"\"\n    return map(lambda r: dict(zip(r.keys(), r)), sqliteRows)", "code_tokens": "def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )", "docstring_tokens": "Unpacks sqlite rows as returned by fetchall into an array of simple dicts .", "label": 0}, {"idx": "cosqa-train-3512", "doc": "how to use custom hash function python dictionary", "code": "def dict_hash(dct):\n    \"\"\"Return a hash of the contents of a dictionary\"\"\"\n    dct_s = json.dumps(dct, sort_keys=True)\n\n    try:\n        m = md5(dct_s)\n    except TypeError:\n        m = md5(dct_s.encode())\n\n    return m.hexdigest()", "code_tokens": "def dict_hash ( dct ) : dct_s = json . dumps ( dct , sort_keys = True ) try : m = md5 ( dct_s ) except TypeError : m = md5 ( dct_s . encode ( ) ) return m . hexdigest ( )", "docstring_tokens": "Return a hash of the contents of a dictionary", "label": 0}, {"idx": "cosqa-train-3513", "doc": "python sqlite3 cursor description column type", "code": "def get_type_len(self):\n        \"\"\"Retrieve the type and length for a data record.\"\"\"\n        # Check types and set type/len\n        self.get_sql()\n        return self.type, self.len, self.len_decimal", "code_tokens": "def get_type_len ( self ) : # Check types and set type/len self . get_sql ( ) return self . type , self . len , self . len_decimal", "docstring_tokens": "Retrieve the type and length for a data record .", "label": 0}, {"idx": "cosqa-train-3514", "doc": "how to use fileinput to replace lines in a file python", "code": "def replace_all(filepath, searchExp, replaceExp):\n    \"\"\"\n    Replace all the ocurrences (in a file) of a string with another value.\n    \"\"\"\n    for line in fileinput.input(filepath, inplace=1):\n        if searchExp in line:\n            line = line.replace(searchExp, replaceExp)\n        sys.stdout.write(line)", "code_tokens": "def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )", "docstring_tokens": "Replace all the ocurrences ( in a file ) of a string with another value .", "label": 0}, {"idx": "cosqa-train-3515", "doc": "python sqlite3 list all table name in database", "code": "def get_table_names(connection):\n\t\"\"\"\n\tReturn a list of the table names in the database.\n\t\"\"\"\n\tcursor = connection.cursor()\n\tcursor.execute(\"SELECT name FROM sqlite_master WHERE type == 'table'\")\n\treturn [name for (name,) in cursor]", "code_tokens": "def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( \"SELECT name FROM sqlite_master WHERE type == 'table'\" ) return [ name for ( name , ) in cursor ]", "docstring_tokens": "Return a list of the table names in the database .", "label": 0}, {"idx": "cosqa-train-3516", "doc": "how to use how to put elements of a list into a string on python", "code": "def list_i2str(ilist):\n    \"\"\"\n    Convert an integer list into a string list.\n    \"\"\"\n    slist = []\n    for el in ilist:\n        slist.append(str(el))\n    return slist", "code_tokens": "def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist", "docstring_tokens": "Convert an integer list into a string list .", "label": 0}, {"idx": "cosqa-train-3517", "doc": "python sshclient to check if directory exists on server", "code": "def exists(self, filepath):\n        \"\"\"Determines if the specified file/folder exists, even if it\n        is on a remote server.\"\"\"\n        if self.is_ssh(filepath):\n            self._check_ftp()\n            remotepath = self._get_remote(filepath)\n            try:\n                self.ftp.stat(remotepath)\n            except IOError as e:\n                if e.errno == errno.ENOENT:\n                    return False\n            else:\n                return True\n        else:\n            return os.path.exists(filepath)", "code_tokens": "def exists ( self , filepath ) : if self . is_ssh ( filepath ) : self . _check_ftp ( ) remotepath = self . _get_remote ( filepath ) try : self . ftp . stat ( remotepath ) except IOError as e : if e . errno == errno . ENOENT : return False else : return True else : return os . path . exists ( filepath )", "docstring_tokens": "Determines if the specified file / folder exists even if it is on a remote server .", "label": 0}, {"idx": "cosqa-train-3518", "doc": "how to use isinstance python 3 for tuple", "code": "def ensure_tuple(obj):\n    \"\"\"Try and make the given argument into a tuple.\"\"\"\n    if obj is None:\n        return tuple()\n    if isinstance(obj, Iterable) and not isinstance(obj, six.string_types):\n        return tuple(obj)\n    return obj,", "code_tokens": "def ensure_tuple ( obj ) : if obj is None : return tuple ( ) if isinstance ( obj , Iterable ) and not isinstance ( obj , six . string_types ) : return tuple ( obj ) return obj ,", "docstring_tokens": "Try and make the given argument into a tuple .", "label": 0}, {"idx": "cosqa-train-3519", "doc": "python stack a list of figurea", "code": "def strip_figures(figure):\n\t\"\"\"\n\tStrips a figure into multiple figures with a trace on each of them\n\n\tParameters:\n\t-----------\n\t\tfigure : Figure\n\t\t\tPlotly Figure\n\t\"\"\"\n\tfig=[]\n\tfor trace in figure['data']:\n\t\tfig.append(dict(data=[trace],layout=figure['layout']))\n\treturn fig", "code_tokens": "def strip_figures ( figure ) : fig = [ ] for trace in figure [ 'data' ] : fig . append ( dict ( data = [ trace ] , layout = figure [ 'layout' ] ) ) return fig", "docstring_tokens": "Strips a figure into multiple figures with a trace on each of them", "label": 1}, {"idx": "cosqa-train-3520", "doc": "how to use list comprehension to return booleans in python", "code": "def All(sequence):\n  \"\"\"\n  :param sequence: Any sequence whose elements can be evaluated as booleans.\n  :returns: true if all elements of the sequence satisfy True and x.\n  \"\"\"\n  return bool(reduce(lambda x, y: x and y, sequence, True))", "code_tokens": "def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )", "docstring_tokens": ": param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x .", "label": 0}, {"idx": "cosqa-train-3521", "doc": "python standard deviation not accept float number", "code": "def weighted_std(values, weights):\n    \"\"\" Calculate standard deviation weighted by errors \"\"\"\n    average = np.average(values, weights=weights)\n    variance = np.average((values-average)**2, weights=weights)\n    return np.sqrt(variance)", "code_tokens": "def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )", "docstring_tokens": "Calculate standard deviation weighted by errors", "label": 1}, {"idx": "cosqa-train-3522", "doc": "how to use min and max functions in python", "code": "def calculate_bounding_box(data):\n    \"\"\"\n    Returns a 2 x m array indicating the min and max along each\n    dimension.\n    \"\"\"\n    mins = data.min(0)\n    maxes = data.max(0)\n    return mins, maxes", "code_tokens": "def calculate_bounding_box ( data ) : mins = data . min ( 0 ) maxes = data . max ( 0 ) return mins , maxes", "docstring_tokens": "Returns a 2 x m array indicating the min and max along each dimension .", "label": 0}, {"idx": "cosqa-train-3523", "doc": "python static funciton in c", "code": "def is_static(*p):\n    \"\"\" A static value (does not change at runtime)\n    which is known at compile time\n    \"\"\"\n    return all(is_CONST(x) or\n               is_number(x) or\n               is_const(x)\n               for x in p)", "code_tokens": "def is_static ( * p ) : return all ( is_CONST ( x ) or is_number ( x ) or is_const ( x ) for x in p )", "docstring_tokens": "A static value ( does not change at runtime ) which is known at compile time", "label": 0}, {"idx": "cosqa-train-3524", "doc": "how to use nodes in for loop networkx python", "code": "def _create_complete_graph(node_ids):\n    \"\"\"Create a complete graph from the list of node ids.\n\n    Args:\n        node_ids: a list of node ids\n\n    Returns:\n        An undirected graph (as a networkx.Graph)\n    \"\"\"\n    g = nx.Graph()\n    g.add_nodes_from(node_ids)\n    for (i, j) in combinations(node_ids, 2):\n        g.add_edge(i, j)\n    return g", "code_tokens": "def _create_complete_graph ( node_ids ) : g = nx . Graph ( ) g . add_nodes_from ( node_ids ) for ( i , j ) in combinations ( node_ids , 2 ) : g . add_edge ( i , j ) return g", "docstring_tokens": "Create a complete graph from the list of node ids .", "label": 0}, {"idx": "cosqa-train-3525", "doc": "python static function calls", "code": "def static_method(cls, f):\n        \"\"\"Decorator which dynamically binds static methods to the model for later use.\"\"\"\n        setattr(cls, f.__name__, staticmethod(f))\n        return f", "code_tokens": "def static_method ( cls , f ) : setattr ( cls , f . __name__ , staticmethod ( f ) ) return f", "docstring_tokens": "Decorator which dynamically binds static methods to the model for later use .", "label": 0}, {"idx": "cosqa-train-3526", "doc": "how to use python 3 interactive mode", "code": "def isInteractive():\n    \"\"\"\n    A basic check of if the program is running in interactive mode\n    \"\"\"\n    if sys.stdout.isatty() and os.name != 'nt':\n        #Hopefully everything but ms supports '\\r'\n        try:\n            import threading\n        except ImportError:\n            return False\n        else:\n            return True\n    else:\n        return False", "code_tokens": "def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\\r' try : import threading except ImportError : return False else : return True else : return False", "docstring_tokens": "A basic check of if the program is running in interactive mode", "label": 1}, {"idx": "cosqa-train-3527", "doc": "python static text full path name", "code": "def glr_path_static():\n    \"\"\"Returns path to packaged static files\"\"\"\n    return os.path.abspath(os.path.join(os.path.dirname(__file__), '_static'))", "code_tokens": "def glr_path_static ( ) : return os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '_static' ) )", "docstring_tokens": "Returns path to packaged static files", "label": 0}, {"idx": "cosqa-train-3528", "doc": "how to use python to connect redis", "code": "def __connect():\n    \"\"\"\n    Connect to a redis instance.\n    \"\"\"\n    global redis_instance\n    if use_tcp_socket:\n        redis_instance = redis.StrictRedis(host=hostname, port=port)\n    else:\n        redis_instance = redis.StrictRedis(unix_socket_path=unix_socket)", "code_tokens": "def __connect ( ) : global redis_instance if use_tcp_socket : redis_instance = redis . StrictRedis ( host = hostname , port = port ) else : redis_instance = redis . StrictRedis ( unix_socket_path = unix_socket )", "docstring_tokens": "Connect to a redis instance .", "label": 0}, {"idx": "cosqa-train-3529", "doc": "python staticmethod good or bad", "code": "def _update_staticmethod(self, oldsm, newsm):\n        \"\"\"Update a staticmethod update.\"\"\"\n        # While we can't modify the staticmethod object itself (it has no\n        # mutable attributes), we *can* extract the underlying function\n        # (by calling __get__(), which returns it) and update it in-place.\n        # We don't have the class available to pass to __get__() but any\n        # object except None will do.\n        self._update(None, None, oldsm.__get__(0), newsm.__get__(0))", "code_tokens": "def _update_staticmethod ( self , oldsm , newsm ) : # While we can't modify the staticmethod object itself (it has no # mutable attributes), we *can* extract the underlying function # (by calling __get__(), which returns it) and update it in-place. # We don't have the class available to pass to __get__() but any # object except None will do. self . _update ( None , None , oldsm . __get__ ( 0 ) , newsm . __get__ ( 0 ) )", "docstring_tokens": "Update a staticmethod update .", "label": 0}, {"idx": "cosqa-train-3530", "doc": "how to validate an impput python", "code": "def image_format(value):\n    \"\"\"\n    Confirms that the uploaded image is of supported format.\n\n    Args:\n        value (File): The file with an `image` property containing the image\n\n    Raises:\n        django.forms.ValidationError\n\n    \"\"\"\n\n    if value.image.format.upper() not in constants.ALLOWED_IMAGE_FORMATS:\n        raise ValidationError(MESSAGE_INVALID_IMAGE_FORMAT)", "code_tokens": "def image_format ( value ) : if value . image . format . upper ( ) not in constants . ALLOWED_IMAGE_FORMATS : raise ValidationError ( MESSAGE_INVALID_IMAGE_FORMAT )", "docstring_tokens": "Confirms that the uploaded image is of supported format .", "label": 1}, {"idx": "cosqa-train-3531", "doc": "python staticmethod magic methods", "code": "def _update_staticmethod(self, oldsm, newsm):\n        \"\"\"Update a staticmethod update.\"\"\"\n        # While we can't modify the staticmethod object itself (it has no\n        # mutable attributes), we *can* extract the underlying function\n        # (by calling __get__(), which returns it) and update it in-place.\n        # We don't have the class available to pass to __get__() but any\n        # object except None will do.\n        self._update(None, None, oldsm.__get__(0), newsm.__get__(0))", "code_tokens": "def _update_staticmethod ( self , oldsm , newsm ) : # While we can't modify the staticmethod object itself (it has no # mutable attributes), we *can* extract the underlying function # (by calling __get__(), which returns it) and update it in-place. # We don't have the class available to pass to __get__() but any # object except None will do. self . _update ( None , None , oldsm . __get__ ( 0 ) , newsm . __get__ ( 0 ) )", "docstring_tokens": "Update a staticmethod update .", "label": 0}, {"idx": "cosqa-train-3532", "doc": "how to vectorize a function in python", "code": "def apply(f, obj, *args, **kwargs):\n    \"\"\"Apply a function in parallel to each element of the input\"\"\"\n    return vectorize(f)(obj, *args, **kwargs)", "code_tokens": "def apply ( f , obj , * args , * * kwargs ) : return vectorize ( f ) ( obj , * args , * * kwargs )", "docstring_tokens": "Apply a function in parallel to each element of the input", "label": 0}, {"idx": "cosqa-train-3533", "doc": "python std deviation of list", "code": "def standard_deviation(numbers):\n    \"\"\"Return standard deviation.\"\"\"\n    numbers = list(numbers)\n    if not numbers:\n        return 0\n    mean = sum(numbers) / len(numbers)\n    return (sum((n - mean) ** 2 for n in numbers) /\n            len(numbers)) ** .5", "code_tokens": "def standard_deviation ( numbers ) : numbers = list ( numbers ) if not numbers : return 0 mean = sum ( numbers ) / len ( numbers ) return ( sum ( ( n - mean ) ** 2 for n in numbers ) / len ( numbers ) ) ** .5", "docstring_tokens": "Return standard deviation .", "label": 1}, {"idx": "cosqa-train-3534", "doc": "how to vectorize python", "code": "def norm_vec(vector):\n    \"\"\"Normalize the length of a vector to one\"\"\"\n    assert len(vector) == 3\n    v = np.array(vector)\n    return v/np.sqrt(np.sum(v**2))", "code_tokens": "def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )", "docstring_tokens": "Normalize the length of a vector to one", "label": 0}, {"idx": "cosqa-train-3535", "doc": "python stop restarting kernel", "code": "async def restart(request):\n    \"\"\"\n    Returns OK, then waits approximately 1 second and restarts container\n    \"\"\"\n    def wait_and_restart():\n        log.info('Restarting server')\n        sleep(1)\n        os.system('kill 1')\n    Thread(target=wait_and_restart).start()\n    return web.json_response({\"message\": \"restarting\"})", "code_tokens": "async def restart ( request ) : def wait_and_restart ( ) : log . info ( 'Restarting server' ) sleep ( 1 ) os . system ( 'kill 1' ) Thread ( target = wait_and_restart ) . start ( ) return web . json_response ( { \"message\" : \"restarting\" } )", "docstring_tokens": "Returns OK then waits approximately 1 second and restarts container", "label": 0}, {"idx": "cosqa-train-3536", "doc": "python store datetime in json", "code": "def parse_json_date(value):\n    \"\"\"\n    Parses an ISO8601 formatted datetime from a string value\n    \"\"\"\n    if not value:\n        return None\n\n    return datetime.datetime.strptime(value, JSON_DATETIME_FORMAT).replace(tzinfo=pytz.UTC)", "code_tokens": "def parse_json_date ( value ) : if not value : return None return datetime . datetime . strptime ( value , JSON_DATETIME_FORMAT ) . replace ( tzinfo = pytz . UTC )", "docstring_tokens": "Parses an ISO8601 formatted datetime from a string value", "label": 0}, {"idx": "cosqa-train-3537", "doc": "how to view response headers python request", "code": "def fetch_header(self):\n        \"\"\"Make a header request to the endpoint.\"\"\"\n        query = self.query().add_query_parameter(req='header')\n        return self._parse_messages(self.get_query(query).content)[0]", "code_tokens": "def fetch_header ( self ) : query = self . query ( ) . add_query_parameter ( req = 'header' ) return self . _parse_messages ( self . get_query ( query ) . content ) [ 0 ]", "docstring_tokens": "Make a header request to the endpoint .", "label": 1}, {"idx": "cosqa-train-3538", "doc": "python strftime returning string format not datetime", "code": "def dt2str(dt, flagSeconds=True):\n    \"\"\"Converts datetime object to str if not yet an str.\"\"\"\n    if isinstance(dt, str):\n        return dt\n    return dt.strftime(_FMTS if flagSeconds else _FMT)", "code_tokens": "def dt2str ( dt , flagSeconds = True ) : if isinstance ( dt , str ) : return dt return dt . strftime ( _FMTS if flagSeconds else _FMT )", "docstring_tokens": "Converts datetime object to str if not yet an str .", "label": 0}, {"idx": "cosqa-train-3539", "doc": "how to write a callback function python", "code": "def add_device_callback(self, callback):\n        \"\"\"Register a callback to be invoked when a new device appears.\"\"\"\n        _LOGGER.debug('Added new callback %s ', callback)\n        self._cb_new_device.append(callback)", "code_tokens": "def add_device_callback ( self , callback ) : _LOGGER . debug ( 'Added new callback %s ' , callback ) self . _cb_new_device . append ( callback )", "docstring_tokens": "Register a callback to be invoked when a new device appears .", "label": 1}, {"idx": "cosqa-train-3540", "doc": "python string contains one of a list of strings", "code": "def any_contains_any(strings, candidates):\n    \"\"\"Whether any of the strings contains any of the candidates.\"\"\"\n    for string in strings:\n        for c in candidates:\n            if c in string:\n                return True", "code_tokens": "def any_contains_any ( strings , candidates ) : for string in strings : for c in candidates : if c in string : return True", "docstring_tokens": "Whether any of the strings contains any of the candidates .", "label": 0}, {"idx": "cosqa-train-3541", "doc": "how to write a code in python to load a json file into snowflake", "code": "def load(cls, fname):\n        \"\"\"\n        Loads the flow from a JSON file.\n\n        :param fname: the file to load\n        :type fname: str\n        :return: the flow\n        :rtype: Flow\n        \"\"\"\n        with open(fname) as f:\n            content = f.readlines()\n        return Flow.from_json(''.join(content))", "code_tokens": "def load ( cls , fname ) : with open ( fname ) as f : content = f . readlines ( ) return Flow . from_json ( '' . join ( content ) )", "docstring_tokens": "Loads the flow from a JSON file .", "label": 0}, {"idx": "cosqa-train-3542", "doc": "python string format *args", "code": "def safe_format(s, **kwargs):\n  \"\"\"\n  :type s str\n  \"\"\"\n  return string.Formatter().vformat(s, (), defaultdict(str, **kwargs))", "code_tokens": "def safe_format ( s , * * kwargs ) : return string . Formatter ( ) . vformat ( s , ( ) , defaultdict ( str , * * kwargs ) )", "docstring_tokens": ": type s str", "label": 0}, {"idx": "cosqa-train-3543", "doc": "how to write all output into a file python", "code": "def build_output(self, fout):\n        \"\"\"Squash self.out into string.\n\n        Join every line in self.out with a new line and write the\n        result to the output file.\n        \"\"\"\n        fout.write('\\n'.join([s for s in self.out]))", "code_tokens": "def build_output ( self , fout ) : fout . write ( '\\n' . join ( [ s for s in self . out ] ) )", "docstring_tokens": "Squash self . out into string .", "label": 0}, {"idx": "cosqa-train-3544", "doc": "python string format line wrap", "code": "def format_line(data, linestyle):\n    \"\"\"Formats a list of elements using the given line style\"\"\"\n    return linestyle.begin + linestyle.sep.join(data) + linestyle.end", "code_tokens": "def format_line ( data , linestyle ) : return linestyle . begin + linestyle . sep . join ( data ) + linestyle . end", "docstring_tokens": "Formats a list of elements using the given line style", "label": 1}, {"idx": "cosqa-train-3545", "doc": "how to write config files in python", "code": "def _write_config(config, cfg_file):\n    \"\"\"\n    Write a config object to the settings.cfg file.\n\n    :param config: A ConfigParser object to write to the settings.cfg file.\n    \"\"\"\n    directory = os.path.dirname(cfg_file)\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n    with open(cfg_file, \"w+\") as output_file:\n        config.write(output_file)", "code_tokens": "def _write_config ( config , cfg_file ) : directory = os . path . dirname ( cfg_file ) if not os . path . exists ( directory ) : os . makedirs ( directory ) with open ( cfg_file , \"w+\" ) as output_file : config . write ( output_file )", "docstring_tokens": "Write a config object to the settings . cfg file .", "label": 0}, {"idx": "cosqa-train-3546", "doc": "python string format variable precision", "code": "def _strvar(a, prec='{:G}'):\n    r\"\"\"Return variable as a string to print, with given precision.\"\"\"\n    return ' '.join([prec.format(i) for i in np.atleast_1d(a)])", "code_tokens": "def _strvar ( a , prec = '{:G}' ) : return ' ' . join ( [ prec . format ( i ) for i in np . atleast_1d ( a ) ] )", "docstring_tokens": "r Return variable as a string to print with given precision .", "label": 0}, {"idx": "cosqa-train-3547", "doc": "how to write entropy syntax in python", "code": "def entropy(string):\n    \"\"\"Compute entropy on the string\"\"\"\n    p, lns = Counter(string), float(len(string))\n    return -sum(count/lns * math.log(count/lns, 2) for count in p.values())", "code_tokens": "def entropy ( string ) : p , lns = Counter ( string ) , float ( len ( string ) ) return - sum ( count / lns * math . log ( count / lns , 2 ) for count in p . values ( ) )", "docstring_tokens": "Compute entropy on the string", "label": 0}, {"idx": "cosqa-train-3548", "doc": "python string match multiple strings", "code": "def match(string, patterns):\n    \"\"\"Given a string return true if it matches the supplied list of\n    patterns.\n\n    Parameters\n    ----------\n    string : str\n        The string to be matched.\n    patterns : None or [pattern, ...]\n        The series of regular expressions to attempt to match.\n    \"\"\"\n    if patterns is None:\n        return True\n    else:\n        return any(re.match(pattern, string)\n                   for pattern in patterns)", "code_tokens": "def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )", "docstring_tokens": "Given a string return true if it matches the supplied list of patterns .", "label": 0}, {"idx": "cosqa-train-3549", "doc": "how to write print stetements into a file in python", "code": "def dump_stmt_strings(stmts, fname):\n    \"\"\"Save printed statements in a file.\n\n    Parameters\n    ----------\n    stmts_in : list[indra.statements.Statement]\n        A list of statements to save in a text file.\n    fname : Optional[str]\n        The name of a text file to save the printed statements into.\n    \"\"\"\n    with open(fname, 'wb') as fh:\n        for st in stmts:\n            fh.write(('%s\\n' % st).encode('utf-8'))", "code_tokens": "def dump_stmt_strings ( stmts , fname ) : with open ( fname , 'wb' ) as fh : for st in stmts : fh . write ( ( '%s\\n' % st ) . encode ( 'utf-8' ) )", "docstring_tokens": "Save printed statements in a file .", "label": 0}, {"idx": "cosqa-train-3550", "doc": "python string of list of string", "code": "def validate_stringlist(s):\n    \"\"\"Validate a list of strings\n\n    Parameters\n    ----------\n    val: iterable of strings\n\n    Returns\n    -------\n    list\n        list of str\n\n    Raises\n    ------\n    ValueError\"\"\"\n    if isinstance(s, six.string_types):\n        return [six.text_type(v.strip()) for v in s.split(',') if v.strip()]\n    else:\n        try:\n            return list(map(validate_str, s))\n        except TypeError as e:\n            raise ValueError(e.message)", "code_tokens": "def validate_stringlist ( s ) : if isinstance ( s , six . string_types ) : return [ six . text_type ( v . strip ( ) ) for v in s . split ( ',' ) if v . strip ( ) ] else : try : return list ( map ( validate_str , s ) ) except TypeError as e : raise ValueError ( e . message )", "docstring_tokens": "Validate a list of strings", "label": 0}, {"idx": "cosqa-train-3551", "doc": "how to write single line in two lines in python", "code": "def write_line(self, line, count=1):\n        \"\"\"writes the line and count newlines after the line\"\"\"\n        self.write(line)\n        self.write_newlines(count)", "code_tokens": "def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )", "docstring_tokens": "writes the line and count newlines after the line", "label": 0}, {"idx": "cosqa-train-3552", "doc": "python string slice overwrite", "code": "def make_strslice(lineno, s, lower, upper):\n    \"\"\" Wrapper: returns String Slice node\n    \"\"\"\n    return symbols.STRSLICE.make_node(lineno, s, lower, upper)", "code_tokens": "def make_strslice ( lineno , s , lower , upper ) : return symbols . STRSLICE . make_node ( lineno , s , lower , upper )", "docstring_tokens": "Wrapper : returns String Slice node", "label": 0}, {"idx": "cosqa-train-3553", "doc": "how we get data at the runtime of django api in python", "code": "def filedata(self):\n        \"\"\"Property providing access to the :class:`.FileDataAPI`\"\"\"\n        if self._filedata_api is None:\n            self._filedata_api = self.get_filedata_api()\n        return self._filedata_api", "code_tokens": "def filedata ( self ) : if self . _filedata_api is None : self . _filedata_api = self . get_filedata_api ( ) return self . _filedata_api", "docstring_tokens": "Property providing access to the : class : . FileDataAPI", "label": 0}, {"idx": "cosqa-train-3554", "doc": "python string to list with commas, but strings habve commas", "code": "def _str_to_list(s):\n    \"\"\"Converts a comma separated string to a list\"\"\"\n    _list = s.split(\",\")\n    return list(map(lambda i: i.lstrip(), _list))", "code_tokens": "def _str_to_list ( s ) : _list = s . split ( \",\" ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )", "docstring_tokens": "Converts a comma separated string to a list", "label": 0}, {"idx": "cosqa-train-3555", "doc": "howt to make character jump up in python", "code": "def backward_char(self, e): # (C-b)\n        u\"\"\"Move back a character. \"\"\"\n        self.l_buffer.backward_char(self.argument_reset)\n        self.finalize()", "code_tokens": "def backward_char ( self , e ) : # (C-b)\n self . l_buffer . backward_char ( self . argument_reset ) self . finalize ( )", "docstring_tokens": "u Move back a character .", "label": 0}, {"idx": "cosqa-train-3556", "doc": "python string value of enum", "code": "def EnumValueName(self, enum, value):\n    \"\"\"Returns the string name of an enum value.\n\n    This is just a small helper method to simplify a common operation.\n\n    Args:\n      enum: string name of the Enum.\n      value: int, value of the enum.\n\n    Returns:\n      string name of the enum value.\n\n    Raises:\n      KeyError if either the Enum doesn't exist or the value is not a valid\n        value for the enum.\n    \"\"\"\n    return self.enum_types_by_name[enum].values_by_number[value].name", "code_tokens": "def EnumValueName ( self , enum , value ) : return self . enum_types_by_name [ enum ] . values_by_number [ value ] . name", "docstring_tokens": "Returns the string name of an enum value .", "label": 1}, {"idx": "cosqa-train-3557", "doc": "html table python coler nth line", "code": "def top(n, width=WIDTH, style=STYLE):\n    \"\"\"Prints the top row of a table\"\"\"\n    return hrule(n, width, linestyle=STYLES[style].top)", "code_tokens": "def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )", "docstring_tokens": "Prints the top row of a table", "label": 0}, {"idx": "cosqa-train-3558", "doc": "python string with no quotes", "code": "def _repr_strip(mystring):\n    \"\"\"\n    Returns the string without any initial or final quotes.\n    \"\"\"\n    r = repr(mystring)\n    if r.startswith(\"'\") and r.endswith(\"'\"):\n        return r[1:-1]\n    else:\n        return r", "code_tokens": "def _repr_strip ( mystring ) : r = repr ( mystring ) if r . startswith ( \"'\" ) and r . endswith ( \"'\" ) : return r [ 1 : - 1 ] else : return r", "docstring_tokens": "Returns the string without any initial or final quotes .", "label": 0}, {"idx": "cosqa-train-3559", "doc": "html to text converter python", "code": "def html_to_text(content):\n    \"\"\" Converts html content to plain text \"\"\"\n    text = None\n    h2t = html2text.HTML2Text()\n    h2t.ignore_links = False\n    text = h2t.handle(content)\n    return text", "code_tokens": "def html_to_text ( content ) : text = None h2t = html2text . HTML2Text ( ) h2t . ignore_links = False text = h2t . handle ( content ) return text", "docstring_tokens": "Converts html content to plain text", "label": 0}, {"idx": "cosqa-train-3560", "doc": "python strip all lines of whitespace", "code": "def text_remove_empty_lines(text):\n    \"\"\"\n    Whitespace normalization:\n\n      - Strip empty lines\n      - Strip trailing whitespace\n    \"\"\"\n    lines = [ line.rstrip()  for line in text.splitlines()  if line.strip() ]\n    return \"\\n\".join(lines)", "code_tokens": "def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return \"\\n\" . join ( lines )", "docstring_tokens": "Whitespace normalization :", "label": 0}, {"idx": "cosqa-train-3561", "doc": "human readable string of object python", "code": "def pretty(obj, verbose=False, max_width=79, newline='\\n'):\n    \"\"\"\n    Pretty print the object's representation.\n    \"\"\"\n    stream = StringIO()\n    printer = RepresentationPrinter(stream, verbose, max_width, newline)\n    printer.pretty(obj)\n    printer.flush()\n    return stream.getvalue()", "code_tokens": "def pretty ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : stream = StringIO ( ) printer = RepresentationPrinter ( stream , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) return stream . getvalue ( )", "docstring_tokens": "Pretty print the object s representation .", "label": 0}, {"idx": "cosqa-train-3562", "doc": "python strip blank space from list", "code": "def strip_spaces(value, sep=None, join=True):\n    \"\"\"Cleans trailing whitespaces and replaces also multiple whitespaces with a single space.\"\"\"\n    value = value.strip()\n    value = [v.strip() for v in value.split(sep)]\n    join_sep = sep or ' '\n    return join_sep.join(value) if join else value", "code_tokens": "def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value", "docstring_tokens": "Cleans trailing whitespaces and replaces also multiple whitespaces with a single space .", "label": 0}, {"idx": "cosqa-train-3563", "doc": "icacls python change file permissions", "code": "def chmod(scope, filename, mode):\n    \"\"\"\n    Changes the permissions of the given file (or list of files)\n    to the given mode. You probably want to use an octal representation\n    for the integer, e.g. \"chmod(myfile, 0644)\".\n\n    :type  filename: string\n    :param filename: A filename.\n    :type  mode: int\n    :param mode: The access permissions.\n    \"\"\"\n    for file in filename:\n        os.chmod(file, mode[0])\n    return True", "code_tokens": "def chmod ( scope , filename , mode ) : for file in filename : os . chmod ( file , mode [ 0 ] ) return True", "docstring_tokens": "Changes the permissions of the given file ( or list of files ) to the given mode . You probably want to use an octal representation for the integer e . g . chmod ( myfile 0644 ) .", "label": 0}, {"idx": "cosqa-train-3564", "doc": "python strip trailing new lines from file", "code": "def lines(input):\n    \"\"\"Remove comments and empty lines\"\"\"\n    for raw_line in input:\n        line = raw_line.strip()\n        if line and not line.startswith('#'):\n            yield strip_comments(line)", "code_tokens": "def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )", "docstring_tokens": "Remove comments and empty lines", "label": 0}, {"idx": "cosqa-train-3565", "doc": "identifying shapes in an image python", "code": "def get_shape(img):\n    \"\"\"Return the shape of img.\n\n    Paramerers\n    -----------\n    img:\n\n    Returns\n    -------\n    shape: tuple\n    \"\"\"\n    if hasattr(img, 'shape'):\n        shape = img.shape\n    else:\n        shape = img.get_data().shape\n    return shape", "code_tokens": "def get_shape ( img ) : if hasattr ( img , 'shape' ) : shape = img . shape else : shape = img . get_data ( ) . shape return shape", "docstring_tokens": "Return the shape of img .", "label": 1}, {"idx": "cosqa-train-3566", "doc": "python subplot not able to set xticklabels", "code": "def show_xticklabels(self, row, column):\n        \"\"\"Show the x-axis tick labels for a subplot.\n\n        :param row,column: specify the subplot.\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.show_xticklabels()", "code_tokens": "def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "docstring_tokens": "Show the x - axis tick labels for a subplot .", "label": 1}, {"idx": "cosqa-train-3567", "doc": "if all elements is true python", "code": "def All(sequence):\n  \"\"\"\n  :param sequence: Any sequence whose elements can be evaluated as booleans.\n  :returns: true if all elements of the sequence satisfy True and x.\n  \"\"\"\n  return bool(reduce(lambda x, y: x and y, sequence, True))", "code_tokens": "def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )", "docstring_tokens": ": param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x .", "label": 0}, {"idx": "cosqa-train-3568", "doc": "if all letters are in a string how to return in python", "code": "def return_letters_from_string(text):\n    \"\"\"Get letters from string only.\"\"\"\n    out = \"\"\n    for letter in text:\n        if letter.isalpha():\n            out += letter\n    return out", "code_tokens": "def return_letters_from_string ( text ) : out = \"\" for letter in text : if letter . isalpha ( ) : out += letter return out", "docstring_tokens": "Get letters from string only .", "label": 0}, {"idx": "cosqa-train-3569", "doc": "python subplot y axis label", "code": "def show_yticklabels(self, row, column):\n        \"\"\"Show the y-axis tick labels for a subplot.\n\n        :param row,column: specify the subplot.\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.show_yticklabels()", "code_tokens": "def show_yticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_yticklabels ( )", "docstring_tokens": "Show the y - axis tick labels for a subplot .", "label": 0}, {"idx": "cosqa-train-3570", "doc": "if file exists then replace python", "code": "def _replace_file(path, content):\n  \"\"\"Writes a file if it doesn't already exist with the same content.\n\n  This is useful because cargo uses timestamps to decide whether to compile things.\"\"\"\n  if os.path.exists(path):\n    with open(path, 'r') as f:\n      if content == f.read():\n        print(\"Not overwriting {} because it is unchanged\".format(path), file=sys.stderr)\n        return\n\n  with open(path, 'w') as f:\n    f.write(content)", "code_tokens": "def _replace_file ( path , content ) : if os . path . exists ( path ) : with open ( path , 'r' ) as f : if content == f . read ( ) : print ( \"Not overwriting {} because it is unchanged\" . format ( path ) , file = sys . stderr ) return with open ( path , 'w' ) as f : f . write ( content )", "docstring_tokens": "Writes a file if it doesn t already exist with the same content .", "label": 0}, {"idx": "cosqa-train-3571", "doc": "python subprocess send input directly to", "code": "def correspond(text):\n    \"\"\"Communicate with the child process without closing stdin.\"\"\"\n    subproc.stdin.write(text)\n    subproc.stdin.flush()\n    return drain()", "code_tokens": "def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )", "docstring_tokens": "Communicate with the child process without closing stdin .", "label": 0}, {"idx": "cosqa-train-3572", "doc": "if number is float boolean python", "code": "def numberp(v):\n    \"\"\"Return true iff 'v' is a number.\"\"\"\n    return (not(isinstance(v, bool)) and\n            (isinstance(v, int) or isinstance(v, float)))", "code_tokens": "def numberp ( v ) : return ( not ( isinstance ( v , bool ) ) and ( isinstance ( v , int ) or isinstance ( v , float ) ) )", "docstring_tokens": "Return true iff v is a number .", "label": 0}, {"idx": "cosqa-train-3573", "doc": "python subprocess suppress output to dev null", "code": "def disown(cmd):\n    \"\"\"Call a system command in the background,\n       disown it and hide it's output.\"\"\"\n    subprocess.Popen(cmd,\n                     stdout=subprocess.DEVNULL,\n                     stderr=subprocess.DEVNULL)", "code_tokens": "def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "docstring_tokens": "Call a system command in the background disown it and hide it s output .", "label": 0}, {"idx": "cosqa-train-3574", "doc": "if type is float in python", "code": "def is_float(value):\n    \"\"\"must be a float\"\"\"\n    return isinstance(value, float) or isinstance(value, int) or isinstance(value, np.float64), float(value)", "code_tokens": "def is_float ( value ) : return isinstance ( value , float ) or isinstance ( value , int ) or isinstance ( value , np . float64 ) , float ( value )", "docstring_tokens": "must be a float", "label": 0}, {"idx": "cosqa-train-3575", "doc": "python sum a field in an object", "code": "def query_sum(queryset, field):\n    \"\"\"\n    Let the DBMS perform a sum on a queryset\n    \"\"\"\n    return queryset.aggregate(s=models.functions.Coalesce(models.Sum(field), 0))['s']", "code_tokens": "def query_sum ( queryset , field ) : return queryset . aggregate ( s = models . functions . Coalesce ( models . Sum ( field ) , 0 ) ) [ 's' ]", "docstring_tokens": "Let the DBMS perform a sum on a queryset", "label": 0}, {"idx": "cosqa-train-3576", "doc": "illegal target for variable annotation python", "code": "def replace_variable_node(node, annotation):\n    \"\"\"Replace a node annotated by `nni.variable`.\n    node: the AST node to replace\n    annotation: annotation string\n    \"\"\"\n    assert type(node) is ast.Assign, 'nni.variable is not annotating assignment expression'\n    assert len(node.targets) == 1, 'Annotated assignment has more than one left-hand value'\n    name, expr = parse_nni_variable(annotation)\n    assert test_variable_equal(node.targets[0], name), 'Annotated variable has wrong name'\n    node.value = expr\n    return node", "code_tokens": "def replace_variable_node ( node , annotation ) : assert type ( node ) is ast . Assign , 'nni.variable is not annotating assignment expression' assert len ( node . targets ) == 1 , 'Annotated assignment has more than one left-hand value' name , expr = parse_nni_variable ( annotation ) assert test_variable_equal ( node . targets [ 0 ] , name ) , 'Annotated variable has wrong name' node . value = expr return node", "docstring_tokens": "Replace a node annotated by nni . variable . node : the AST node to replace annotation : annotation string", "label": 0}, {"idx": "cosqa-train-3577", "doc": "python swap rows in a matrix", "code": "def _swap_rows(self, i, j):\n        \"\"\"Swap i and j rows\n\n        As the side effect, determinant flips.\n\n        \"\"\"\n\n        L = np.eye(3, dtype='intc')\n        L[i, i] = 0\n        L[j, j] = 0\n        L[i, j] = 1\n        L[j, i] = 1\n        self._L.append(L.copy())\n        self._A = np.dot(L, self._A)", "code_tokens": "def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )", "docstring_tokens": "Swap i and j rows", "label": 0}, {"idx": "cosqa-train-3578", "doc": "image data preprocessing in python", "code": "def transformer(data, label):\n    \"\"\" data preparation \"\"\"\n    data = mx.image.imresize(data, IMAGE_SIZE, IMAGE_SIZE)\n    data = mx.nd.transpose(data, (2, 0, 1))\n    data = data.astype(np.float32) / 128.0 - 1\n    return data, label", "code_tokens": "def transformer ( data , label ) : data = mx . image . imresize ( data , IMAGE_SIZE , IMAGE_SIZE ) data = mx . nd . transpose ( data , ( 2 , 0 , 1 ) ) data = data . astype ( np . float32 ) / 128.0 - 1 return data , label", "docstring_tokens": "data preparation", "label": 1}, {"idx": "cosqa-train-3579", "doc": "python switching places in list with duplicates", "code": "def purge_duplicates(list_in):\n    \"\"\"Remove duplicates from list while preserving order.\n\n    Parameters\n    ----------\n    list_in: Iterable\n\n    Returns\n    -------\n    list\n        List of first occurences in order\n    \"\"\"\n    _list = []\n    for item in list_in:\n        if item not in _list:\n            _list.append(item)\n    return _list", "code_tokens": "def purge_duplicates ( list_in ) : _list = [ ] for item in list_in : if item not in _list : _list . append ( item ) return _list", "docstring_tokens": "Remove duplicates from list while preserving order .", "label": 1}, {"idx": "cosqa-train-3580", "doc": "image scale function in python", "code": "def resetScale(self):\n        \"\"\"Resets the scale on this image. Correctly aligns time scale, undoes manual scaling\"\"\"\n        self.img.scale(1./self.imgScale[0], 1./self.imgScale[1])\n        self.imgScale = (1.,1.)", "code_tokens": "def resetScale ( self ) : self . img . scale ( 1. / self . imgScale [ 0 ] , 1. / self . imgScale [ 1 ] ) self . imgScale = ( 1. , 1. )", "docstring_tokens": "Resets the scale on this image . Correctly aligns time scale undoes manual scaling", "label": 0}, {"idx": "cosqa-train-3581", "doc": "python sys args nammed", "code": "def aug_sysargv(cmdstr):\n    \"\"\" DEBUG FUNC modify argv to look like you ran a command \"\"\"\n    import shlex\n    argv = shlex.split(cmdstr)\n    sys.argv.extend(argv)", "code_tokens": "def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )", "docstring_tokens": "DEBUG FUNC modify argv to look like you ran a command", "label": 0}, {"idx": "cosqa-train-3582", "doc": "implement hash function in python", "code": "def get_point_hash(self, point):\n        \"\"\"\n        return geohash for given point with self.precision\n        :param point: GeoPoint instance\n        :return: string\n        \"\"\"\n        return geohash.encode(point.latitude, point.longitude, self.precision)", "code_tokens": "def get_point_hash ( self , point ) : return geohash . encode ( point . latitude , point . longitude , self . precision )", "docstring_tokens": "return geohash for given point with self . precision : param point : GeoPoint instance : return : string", "label": 0}, {"idx": "cosqa-train-3583", "doc": "python sysarg pass variables", "code": "def aug_sysargv(cmdstr):\n    \"\"\" DEBUG FUNC modify argv to look like you ran a command \"\"\"\n    import shlex\n    argv = shlex.split(cmdstr)\n    sys.argv.extend(argv)", "code_tokens": "def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )", "docstring_tokens": "DEBUG FUNC modify argv to look like you ran a command", "label": 0}, {"idx": "cosqa-train-3584", "doc": "in python how to check if 3 sets are equal", "code": "def __eq__(self, anotherset):\n        \"\"\"Tests on itemlist equality\"\"\"\n        if not isinstance(anotherset, LR0ItemSet):\n            raise TypeError\n        if len(self.itemlist) != len(anotherset.itemlist):\n            return False\n        for element in self.itemlist:\n            if element not in anotherset.itemlist:\n                return False\n        return True", "code_tokens": "def __eq__ ( self , anotherset ) : if not isinstance ( anotherset , LR0ItemSet ) : raise TypeError if len ( self . itemlist ) != len ( anotherset . itemlist ) : return False for element in self . itemlist : if element not in anotherset . itemlist : return False return True", "docstring_tokens": "Tests on itemlist equality", "label": 0}, {"idx": "cosqa-train-3585", "doc": "python table printer answer", "code": "def paint(self, tbl):\n        \"\"\"\n        Paint the table on terminal\n        Currently only print out basic string format\n        \"\"\"\n        if not isinstance(tbl, Table):\n            logging.error(\"unable to paint table: invalid object\")\n            return False\n\n        self.term.stream.write(self.term.clear)\n\n        self.term.stream.write(str(tbl))\n        return True", "code_tokens": "def paint ( self , tbl ) : if not isinstance ( tbl , Table ) : logging . error ( \"unable to paint table: invalid object\" ) return False self . term . stream . write ( self . term . clear ) self . term . stream . write ( str ( tbl ) ) return True", "docstring_tokens": "Paint the table on terminal Currently only print out basic string format", "label": 0}, {"idx": "cosqa-train-3586", "doc": "in python how to check the number is int or char", "code": "def check_int(integer):\n    \"\"\"\n    Check if number is integer or not.\n\n    :param integer: Number as str\n    :return: Boolean\n    \"\"\"\n    if not isinstance(integer, str):\n        return False\n    if integer[0] in ('-', '+'):\n        return integer[1:].isdigit()\n    return integer.isdigit()", "code_tokens": "def check_int ( integer ) : if not isinstance ( integer , str ) : return False if integer [ 0 ] in ( '-' , '+' ) : return integer [ 1 : ] . isdigit ( ) return integer . isdigit ( )", "docstring_tokens": "Check if number is integer or not .", "label": 0}, {"idx": "cosqa-train-3587", "doc": "python take seconds from a timedelta", "code": "def timedelta2millisecond(td):\n    \"\"\"Get milliseconds from a timedelta.\"\"\"\n    milliseconds = td.days * 24 * 60 * 60 * 1000\n    milliseconds += td.seconds * 1000\n    milliseconds += td.microseconds / 1000\n    return milliseconds", "code_tokens": "def timedelta2millisecond ( td ) : milliseconds = td . days * 24 * 60 * 60 * 1000 milliseconds += td . seconds * 1000 milliseconds += td . microseconds / 1000 return milliseconds", "docstring_tokens": "Get milliseconds from a timedelta .", "label": 1}, {"idx": "cosqa-train-3588", "doc": "in python is a a string or a number", "code": "def get_truetype(value):\n    \"\"\"Convert a string to a pythonized parameter.\"\"\"\n    if value in [\"true\", \"True\", \"y\", \"Y\", \"yes\"]:\n        return True\n    if value in [\"false\", \"False\", \"n\", \"N\", \"no\"]:\n        return False\n    if value.isdigit():\n        return int(value)\n    return str(value)", "code_tokens": "def get_truetype ( value ) : if value in [ \"true\" , \"True\" , \"y\" , \"Y\" , \"yes\" ] : return True if value in [ \"false\" , \"False\" , \"n\" , \"N\" , \"no\" ] : return False if value . isdigit ( ) : return int ( value ) return str ( value )", "docstring_tokens": "Convert a string to a pythonized parameter .", "label": 0}, {"idx": "cosqa-train-3589", "doc": "python taking a strind of sentences into seperate lists", "code": "def split(s):\n  \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"\n  l = [_split(x) for x in _SPLIT_RE.split(s)]\n  return [item for sublist in l for item in sublist]", "code_tokens": "def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Uses dynamic programming to infer the location of spaces in a string without spaces .", "label": 0}, {"idx": "cosqa-train-3590", "doc": "python tell if a line intersects a surface", "code": "def line_line_collide(line1, line2):\n    \"\"\"Determine if two line segments meet.\n\n    This is a helper for :func:`convex_hull_collide` in the\n    special case that the two convex hulls are actually\n    just line segments. (Even in this case, this is only\n    problematic if both segments are on a single line.)\n\n    Args:\n        line1 (numpy.ndarray): ``2 x 2`` array of start and end nodes.\n        line2 (numpy.ndarray): ``2 x 2`` array of start and end nodes.\n\n    Returns:\n        bool: Indicating if the line segments collide.\n    \"\"\"\n    s, t, success = segment_intersection(\n        line1[:, 0], line1[:, 1], line2[:, 0], line2[:, 1]\n    )\n    if success:\n        return _helpers.in_interval(s, 0.0, 1.0) and _helpers.in_interval(\n            t, 0.0, 1.0\n        )\n\n    else:\n        disjoint, _ = parallel_lines_parameters(\n            line1[:, 0], line1[:, 1], line2[:, 0], line2[:, 1]\n        )\n        return not disjoint", "code_tokens": "def line_line_collide ( line1 , line2 ) : s , t , success = segment_intersection ( line1 [ : , 0 ] , line1 [ : , 1 ] , line2 [ : , 0 ] , line2 [ : , 1 ] ) if success : return _helpers . in_interval ( s , 0.0 , 1.0 ) and _helpers . in_interval ( t , 0.0 , 1.0 ) else : disjoint , _ = parallel_lines_parameters ( line1 [ : , 0 ] , line1 [ : , 1 ] , line2 [ : , 0 ] , line2 [ : , 1 ] ) return not disjoint", "docstring_tokens": "Determine if two line segments meet .", "label": 1}, {"idx": "cosqa-train-3591", "doc": "in python pad with zero", "code": "def zero_pad(m, n=1):\n    \"\"\"Pad a matrix with zeros, on all sides.\"\"\"\n    return np.pad(m, (n, n), mode='constant', constant_values=[0])", "code_tokens": "def zero_pad ( m , n = 1 ) : return np . pad ( m , ( n , n ) , mode = 'constant' , constant_values = [ 0 ] )", "docstring_tokens": "Pad a matrix with zeros on all sides .", "label": 0}, {"idx": "cosqa-train-3592", "doc": "python temporarily diable logging", "code": "def logger(message, level=10):\n    \"\"\"Handle logging.\"\"\"\n    logging.getLogger(__name__).log(level, str(message))", "code_tokens": "def logger ( message , level = 10 ) : logging . getLogger ( __name__ ) . log ( level , str ( message ) )", "docstring_tokens": "Handle logging .", "label": 1}, {"idx": "cosqa-train-3593", "doc": "in python shell command how to go to next", "code": "def do_next(self, args):\n        \"\"\"Step over the next statement\n        \"\"\"\n        self._do_print_from_last_cmd = True\n        self._interp.step_over()\n        return True", "code_tokens": "def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "docstring_tokens": "Step over the next statement", "label": 0}, {"idx": "cosqa-train-3594", "doc": "python tensorflow dataset length", "code": "def _get_example_length(example):\n  \"\"\"Returns the maximum length between the example inputs and targets.\"\"\"\n  length = tf.maximum(tf.shape(example[0])[0], tf.shape(example[1])[0])\n  return length", "code_tokens": "def _get_example_length ( example ) : length = tf . maximum ( tf . shape ( example [ 0 ] ) [ 0 ] , tf . shape ( example [ 1 ] ) [ 0 ] ) return length", "docstring_tokens": "Returns the maximum length between the example inputs and targets .", "label": 1}, {"idx": "cosqa-train-3595", "doc": "in python write a program that averages length of the words in a sentence", "code": "def get_average_length_of_string(strings):\n    \"\"\"Computes average length of words\n\n    :param strings: list of words\n    :return: Average length of word on list\n    \"\"\"\n    if not strings:\n        return 0\n\n    return sum(len(word) for word in strings) / len(strings)", "code_tokens": "def get_average_length_of_string ( strings ) : if not strings : return 0 return sum ( len ( word ) for word in strings ) / len ( strings )", "docstring_tokens": "Computes average length of words", "label": 0}, {"idx": "cosqa-train-3596", "doc": "python tensors of dimensions 2x3", "code": "def flatten4d3d(x):\n  \"\"\"Flatten a 4d-tensor into a 3d-tensor by joining width and height.\"\"\"\n  xshape = shape_list(x)\n  result = tf.reshape(x, [xshape[0], xshape[1] * xshape[2], xshape[3]])\n  return result", "code_tokens": "def flatten4d3d ( x ) : xshape = shape_list ( x ) result = tf . reshape ( x , [ xshape [ 0 ] , xshape [ 1 ] * xshape [ 2 ] , xshape [ 3 ] ] ) return result", "docstring_tokens": "Flatten a 4d - tensor into a 3d - tensor by joining width and height .", "label": 1}, {"idx": "cosqa-train-3597", "doc": "increment the given date if it is saturday or sunday python", "code": "def previous_friday(dt):\n    \"\"\"\n    If holiday falls on Saturday or Sunday, use previous Friday instead.\n    \"\"\"\n    if dt.weekday() == 5:\n        return dt - timedelta(1)\n    elif dt.weekday() == 6:\n        return dt - timedelta(2)\n    return dt", "code_tokens": "def previous_friday ( dt ) : if dt . weekday ( ) == 5 : return dt - timedelta ( 1 ) elif dt . weekday ( ) == 6 : return dt - timedelta ( 2 ) return dt", "docstring_tokens": "If holiday falls on Saturday or Sunday use previous Friday instead .", "label": 0}, {"idx": "cosqa-train-3598", "doc": "python test array for complex type", "code": "def is_complex(dtype):\n  \"\"\"Returns whether this is a complex floating point type.\"\"\"\n  dtype = tf.as_dtype(dtype)\n  if hasattr(dtype, 'is_complex'):\n    return dtype.is_complex\n  return np.issubdtype(np.dtype(dtype), np.complex)", "code_tokens": "def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )", "docstring_tokens": "Returns whether this is a complex floating point type .", "label": 0}, {"idx": "cosqa-train-3599", "doc": "indententition in python is spaces", "code": "def get_indent(text):\n    \"\"\"Get indent of text.\n\n    https://stackoverflow.com/questions/2268532/grab-a-lines-whitespace-\n    indention-with-python\n    \"\"\"\n    indent = ''\n\n    ret = re.match(r'(\\s*)', text)\n    if ret:\n        indent = ret.group(1)\n\n    return indent", "code_tokens": "def get_indent ( text ) : indent = '' ret = re . match ( r'(\\s*)' , text ) if ret : indent = ret . group ( 1 ) return indent", "docstring_tokens": "Get indent of text . https : // stackoverflow . com / questions / 2268532 / grab - a - lines - whitespace - indention - with - python", "label": 0}, {"idx": "cosqa-train-3600", "doc": "python test assert type", "code": "def _assert_is_type(name, value, value_type):\n    \"\"\"Assert that a value must be a given type.\"\"\"\n    if not isinstance(value, value_type):\n        if type(value_type) is tuple:\n            types = ', '.join(t.__name__ for t in value_type)\n            raise ValueError('{0} must be one of ({1})'.format(name, types))\n        else:\n            raise ValueError('{0} must be {1}'\n                             .format(name, value_type.__name__))", "code_tokens": "def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )", "docstring_tokens": "Assert that a value must be a given type .", "label": 0}, {"idx": "cosqa-train-3601", "doc": "index matching tuple, python", "code": "def tuple_search(t, i, v):\n    \"\"\"\n    Search tuple array by index and value\n    :param t: tuple array\n    :param i: index of the value in each tuple\n    :param v: value\n    :return: the first tuple in the array with the specific index / value\n    \"\"\"\n    for e in t:\n        if e[i] == v:\n            return e\n    return None", "code_tokens": "def tuple_search ( t , i , v ) : for e in t : if e [ i ] == v : return e return None", "docstring_tokens": "Search tuple array by index and value : param t : tuple array : param i : index of the value in each tuple : param v : value : return : the first tuple in the array with the specific index / value", "label": 1}, {"idx": "cosqa-train-3602", "doc": "python test if an object is iterable", "code": "def is_lazy_iterable(obj):\n    \"\"\"\n    Returns whether *obj* is iterable lazily, such as generators, range objects, etc.\n    \"\"\"\n    return isinstance(obj,\n        (types.GeneratorType, collections.MappingView, six.moves.range, enumerate))", "code_tokens": "def is_lazy_iterable ( obj ) : return isinstance ( obj , ( types . GeneratorType , collections . MappingView , six . moves . range , enumerate ) )", "docstring_tokens": "Returns whether * obj * is iterable lazily such as generators range objects etc .", "label": 0}, {"idx": "cosqa-train-3603", "doc": "index of a elemtn in a list in python", "code": "def is_in(self, search_list, pair):\n        \"\"\"\n        If pair is in search_list, return the index. Otherwise return -1\n        \"\"\"\n        index = -1\n        for nr, i in enumerate(search_list):\n            if(np.all(i == pair)):\n                return nr\n        return index", "code_tokens": "def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index", "docstring_tokens": "If pair is in search_list return the index . Otherwise return - 1", "label": 0}, {"idx": "cosqa-train-3604", "doc": "python test if file is read only", "code": "def is_readable(filename):\n    \"\"\"Check if file is a regular file and is readable.\"\"\"\n    return os.path.isfile(filename) and os.access(filename, os.R_OK)", "code_tokens": "def is_readable ( filename ) : return os . path . isfile ( filename ) and os . access ( filename , os . R_OK )", "docstring_tokens": "Check if file is a regular file and is readable .", "label": 0}, {"idx": "cosqa-train-3605", "doc": "index of minimum element in array in python", "code": "def find_nearest_index(arr, value):\n    \"\"\"For a given value, the function finds the nearest value\n    in the array and returns its index.\"\"\"\n    arr = np.array(arr)\n    index = (abs(arr-value)).argmin()\n    return index", "code_tokens": "def find_nearest_index ( arr , value ) : arr = np . array ( arr ) index = ( abs ( arr - value ) ) . argmin ( ) return index", "docstring_tokens": "For a given value the function finds the nearest value in the array and returns its index .", "label": 0}, {"idx": "cosqa-train-3606", "doc": "python test if string prefix", "code": "def starts_with_prefix_in_list(text, prefixes):\n    \"\"\"\n    Return True if the given string starts with one of the prefixes in the given list, otherwise\n    return False.\n\n    Arguments:\n        text (str): Text to check for prefixes.\n        prefixes (list): List of prefixes to check for.\n\n    Returns:\n        bool: True if the given text starts with any of the given prefixes, otherwise False.\n    \"\"\"\n    for prefix in prefixes:\n        if text.startswith(prefix):\n            return True\n    return False", "code_tokens": "def starts_with_prefix_in_list ( text , prefixes ) : for prefix in prefixes : if text . startswith ( prefix ) : return True return False", "docstring_tokens": "Return True if the given string starts with one of the prefixes in the given list otherwise return False .", "label": 0}, {"idx": "cosqa-train-3607", "doc": "indices of a matrix python", "code": "def index(m, val):\n    \"\"\"\n    Return the indices of all the ``val`` in ``m``\n    \"\"\"\n    mm = np.array(m)\n    idx_tuple = np.where(mm == val)\n    idx = idx_tuple[0].tolist()\n\n    return idx", "code_tokens": "def index ( m , val ) : mm = np . array ( m ) idx_tuple = np . where ( mm == val ) idx = idx_tuple [ 0 ] . tolist ( ) return idx", "docstring_tokens": "Return the indices of all the val in m", "label": 0}, {"idx": "cosqa-train-3608", "doc": "python testing requests mock", "code": "def requests_post(url, data=None, json=None, **kwargs):\n    \"\"\"Requests-mock requests.post wrapper.\"\"\"\n    return requests_request('post', url, data=data, json=json, **kwargs)", "code_tokens": "def requests_post ( url , data = None , json = None , * * kwargs ) : return requests_request ( 'post' , url , data = data , json = json , * * kwargs )", "docstring_tokens": "Requests - mock requests . post wrapper .", "label": 0}, {"idx": "cosqa-train-3609", "doc": "inner join equivalent python", "code": "def merge(left, right, how='inner', key=None, left_key=None, right_key=None,\n          left_as='left', right_as='right'):\n    \"\"\" Performs a join using the union join function. \"\"\"\n    return join(left, right, how, key, left_key, right_key,\n                join_fn=make_union_join(left_as, right_as))", "code_tokens": "def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "docstring_tokens": "Performs a join using the union join function .", "label": 0}, {"idx": "cosqa-train-3610", "doc": "python texture rendering using pyopengl", "code": "def _genTex2D(self):\n        \"\"\"Generate an empty texture in OpenGL\"\"\"\n        for face in range(6):\n            gl.glTexImage2D(self.target0 + face, 0, self.internal_fmt, self.width, self.height, 0,\n                            self.pixel_fmt, gl.GL_UNSIGNED_BYTE, 0)", "code_tokens": "def _genTex2D ( self ) : for face in range ( 6 ) : gl . glTexImage2D ( self . target0 + face , 0 , self . internal_fmt , self . width , self . height , 0 , self . pixel_fmt , gl . GL_UNSIGNED_BYTE , 0 )", "docstring_tokens": "Generate an empty texture in OpenGL", "label": 0}, {"idx": "cosqa-train-3611", "doc": "inserting an image as a background in python", "code": "def copy_image_on_background(image, color=WHITE):\n    \"\"\"\n    Create a new image by copying the image on a *color* background.\n\n    Args:\n        image (PIL.Image.Image): Image to copy\n        color (tuple): Background color usually WHITE or BLACK\n\n    Returns:\n        PIL.Image.Image\n\n    \"\"\"\n    background = Image.new(\"RGB\", image.size, color)\n    background.paste(image, mask=image.split()[3])\n    return background", "code_tokens": "def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( \"RGB\" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background", "docstring_tokens": "Create a new image by copying the image on a * color * background .", "label": 0}, {"idx": "cosqa-train-3612", "doc": "python that finds 25th, 50th and 75th percentiles", "code": "def ci(a, which=95, axis=None):\n    \"\"\"Return a percentile range from an array of values.\"\"\"\n    p = 50 - which / 2, 50 + which / 2\n    return percentiles(a, p, axis)", "code_tokens": "def ci ( a , which = 95 , axis = None ) : p = 50 - which / 2 , 50 + which / 2 return percentiles ( a , p , axis )", "docstring_tokens": "Return a percentile range from an array of values .", "label": 0}, {"idx": "cosqa-train-3613", "doc": "int to string function python", "code": "def int2str(num, radix=10, alphabet=BASE85):\n    \"\"\"helper function for quick base conversions from integers to strings\"\"\"\n    return NumConv(radix, alphabet).int2str(num)", "code_tokens": "def int2str ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . int2str ( num )", "docstring_tokens": "helper function for quick base conversions from integers to strings", "label": 1}, {"idx": "cosqa-train-3614", "doc": "python the event loop is already running", "code": "def run(self):\n        \"\"\"Run the event loop.\"\"\"\n        self.signal_init()\n        self.listen_init()\n        self.logger.info('starting')\n        self.loop.start()", "code_tokens": "def run ( self ) : self . signal_init ( ) self . listen_init ( ) self . logger . info ( 'starting' ) self . loop . start ( )", "docstring_tokens": "Run the event loop .", "label": 1}, {"idx": "cosqa-train-3615", "doc": "integer into date, python", "code": "def int_to_date(date):\n    \"\"\"\n    Convert an int of form yyyymmdd to a python date object.\n    \"\"\"\n\n    year = date // 10**4\n    month = date % 10**4 // 10**2\n    day = date % 10**2\n\n    return datetime.date(year, month, day)", "code_tokens": "def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )", "docstring_tokens": "Convert an int of form yyyymmdd to a python date object .", "label": 0}, {"idx": "cosqa-train-3616", "doc": "python the last day of the quarter", "code": "def previous_quarter(d):\n    \"\"\"\n    Retrieve the previous quarter for dt\n    \"\"\"\n    from django_toolkit.datetime_util import quarter as datetime_quarter\n    return quarter( (datetime_quarter(datetime(d.year, d.month, d.day))[0] + timedelta(days=-1)).date() )", "code_tokens": "def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )", "docstring_tokens": "Retrieve the previous quarter for dt", "label": 0}, {"idx": "cosqa-train-3617", "doc": "interpolate 2d matrix python", "code": "def _linearInterpolationTransformMatrix(matrix1, matrix2, value):\n    \"\"\" Linear, 'oldstyle' interpolation of the transform matrix.\"\"\"\n    return tuple(_interpolateValue(matrix1[i], matrix2[i], value) for i in range(len(matrix1)))", "code_tokens": "def _linearInterpolationTransformMatrix ( matrix1 , matrix2 , value ) : return tuple ( _interpolateValue ( matrix1 [ i ] , matrix2 [ i ] , value ) for i in range ( len ( matrix1 ) ) )", "docstring_tokens": "Linear oldstyle interpolation of the transform matrix .", "label": 0}, {"idx": "cosqa-train-3618", "doc": "python thread running before start called", "code": "def start(self):\n        \"\"\"Start the receiver.\n        \"\"\"\n        if not self._is_running:\n            self._do_run = True\n            self._thread.start()\n        return self", "code_tokens": "def start ( self ) : if not self . _is_running : self . _do_run = True self . _thread . start ( ) return self", "docstring_tokens": "Start the receiver .", "label": 0}, {"idx": "cosqa-train-3619", "doc": "invalid character in identifier except python", "code": "def is_valid_uid(uid):\n    \"\"\"\n    :return: True if it is a valid DHIS2 UID, False if not\n    \"\"\"\n    pattern = r'^[A-Za-z][A-Za-z0-9]{10}$'\n    if not isinstance(uid, string_types):\n        return False\n    return bool(re.compile(pattern).match(uid))", "code_tokens": "def is_valid_uid ( uid ) : pattern = r'^[A-Za-z][A-Za-z0-9]{10}$' if not isinstance ( uid , string_types ) : return False return bool ( re . compile ( pattern ) . match ( uid ) )", "docstring_tokens": ": return : True if it is a valid DHIS2 UID False if not", "label": 0}, {"idx": "cosqa-train-3620", "doc": "python thread safe lock", "code": "def _synced(method, self, args, kwargs):\n    \"\"\"Underlying synchronized wrapper.\"\"\"\n    with self._lock:\n        return method(*args, **kwargs)", "code_tokens": "def _synced ( method , self , args , kwargs ) : with self . _lock : return method ( * args , * * kwargs )", "docstring_tokens": "Underlying synchronized wrapper .", "label": 0}, {"idx": "cosqa-train-3621", "doc": "invalid shape (3, 454, 1810) for image data python", "code": "def _check_color_dim(val):\n    \"\"\"Ensure val is Nx(n_col), usually Nx3\"\"\"\n    val = np.atleast_2d(val)\n    if val.shape[1] not in (3, 4):\n        raise RuntimeError('Value must have second dimension of size 3 or 4')\n    return val, val.shape[1]", "code_tokens": "def _check_color_dim ( val ) : val = np . atleast_2d ( val ) if val . shape [ 1 ] not in ( 3 , 4 ) : raise RuntimeError ( 'Value must have second dimension of size 3 or 4' ) return val , val . shape [ 1 ]", "docstring_tokens": "Ensure val is Nx ( n_col ) usually Nx3", "label": 1}, {"idx": "cosqa-train-3622", "doc": "python threading hangs on join", "code": "def join(self):\n\t\t\"\"\"Note that the Executor must be close()'d elsewhere,\n\t\tor join() will never return.\n\t\t\"\"\"\n\t\tself.inputfeeder_thread.join()\n\t\tself.pool.join()\n\t\tself.resulttracker_thread.join()\n\t\tself.failuretracker_thread.join()", "code_tokens": "def join ( self ) : self . inputfeeder_thread . join ( ) self . pool . join ( ) self . resulttracker_thread . join ( ) self . failuretracker_thread . join ( )", "docstring_tokens": "Note that the Executor must be close () d elsewhere or join () will never return .", "label": 0}, {"idx": "cosqa-train-3623", "doc": "invalid syntax for a while loop in python 3 idle", "code": "def seconds(num):\n    \"\"\"\n    Pause for this many seconds\n    \"\"\"\n    now = pytime.time()\n    end = now + num\n    until(end)", "code_tokens": "def seconds ( num ) : now = pytime . time ( ) end = now + num until ( end )", "docstring_tokens": "Pause for this many seconds", "label": 0}, {"idx": "cosqa-train-3624", "doc": "python time format to minutes", "code": "def format_time(time):\n    \"\"\" Formats the given time into HH:MM:SS \"\"\"\n    h, r = divmod(time / 1000, 3600)\n    m, s = divmod(r, 60)\n\n    return \"%02d:%02d:%02d\" % (h, m, s)", "code_tokens": "def format_time ( time ) : h , r = divmod ( time / 1000 , 3600 ) m , s = divmod ( r , 60 ) return \"%02d:%02d:%02d\" % ( h , m , s )", "docstring_tokens": "Formats the given time into HH : MM : SS", "label": 0}, {"idx": "cosqa-train-3625", "doc": "invert key value in dictionary python", "code": "def invertDictMapping(d):\n    \"\"\" Invert mapping of dictionary (i.e. map values to list of keys) \"\"\"\n    inv_map = {}\n    for k, v in d.items():\n        inv_map[v] = inv_map.get(v, [])\n        inv_map[v].append(k)\n    return inv_map", "code_tokens": "def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map", "docstring_tokens": "Invert mapping of dictionary ( i . e . map values to list of keys )", "label": 0}, {"idx": "cosqa-train-3626", "doc": "python timestamp string for filename", "code": "def fileModifiedTimestamp(fname):\n    \"\"\"return \"YYYY-MM-DD\" when the file was modified.\"\"\"\n    modifiedTime=os.path.getmtime(fname)\n    stamp=time.strftime('%Y-%m-%d', time.localtime(modifiedTime))\n    return stamp", "code_tokens": "def fileModifiedTimestamp ( fname ) : modifiedTime = os . path . getmtime ( fname ) stamp = time . strftime ( '%Y-%m-%d' , time . localtime ( modifiedTime ) ) return stamp", "docstring_tokens": "return YYYY - MM - DD when the file was modified .", "label": 0}, {"idx": "cosqa-train-3627", "doc": "ironpython engine set std output", "code": "def start(self):\n        \"\"\"Activate the TypingStream on stdout\"\"\"\n        self.streams.append(sys.stdout)\n        sys.stdout = self.stream", "code_tokens": "def start ( self ) : self . streams . append ( sys . stdout ) sys . stdout = self . stream", "docstring_tokens": "Activate the TypingStream on stdout", "label": 0}, {"idx": "cosqa-train-3628", "doc": "python timezone localize astimezone", "code": "def localize(dt):\n    \"\"\"Localize a datetime object to local time.\"\"\"\n    if dt.tzinfo is UTC:\n        return (dt + LOCAL_UTC_OFFSET).replace(tzinfo=None)\n    # No TZ info so not going to assume anything, return as-is.\n    return dt", "code_tokens": "def localize ( dt ) : if dt . tzinfo is UTC : return ( dt + LOCAL_UTC_OFFSET ) . replace ( tzinfo = None ) # No TZ info so not going to assume anything, return as-is. return dt", "docstring_tokens": "Localize a datetime object to local time .", "label": 0}, {"idx": "cosqa-train-3629", "doc": "is an array the same as a list in python", "code": "def as_tuple(self, value):\n        \"\"\"Utility function which converts lists to tuples.\"\"\"\n        if isinstance(value, list):\n            value = tuple(value)\n        return value", "code_tokens": "def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value", "docstring_tokens": "Utility function which converts lists to tuples .", "label": 0}, {"idx": "cosqa-train-3630", "doc": "python timezone offset uct", "code": "def current_offset(local_tz=None):\n    \"\"\"\n    Returns current utcoffset for a timezone. Uses\n    DEFAULT_LOCAL_TZ by default. That value can be\n    changed at runtime using the func below.\n    \"\"\"\n    if local_tz is None:\n        local_tz = DEFAULT_LOCAL_TZ\n    dt = local_tz.localize(datetime.now())\n    return dt.utcoffset()", "code_tokens": "def current_offset ( local_tz = None ) : if local_tz is None : local_tz = DEFAULT_LOCAL_TZ dt = local_tz . localize ( datetime . now ( ) ) return dt . utcoffset ( )", "docstring_tokens": "Returns current utcoffset for a timezone . Uses DEFAULT_LOCAL_TZ by default . That value can be changed at runtime using the func below .", "label": 0}, {"idx": "cosqa-train-3631", "doc": "is an object in python hashable", "code": "def __hash__(self):\n        \"\"\"Return ``hash(self)``.\"\"\"\n        return hash((type(self), self.domain, self.range, self.partition))", "code_tokens": "def __hash__ ( self ) : return hash ( ( type ( self ) , self . domain , self . range , self . partition ) )", "docstring_tokens": "Return hash ( self ) .", "label": 0}, {"idx": "cosqa-train-3632", "doc": "python tk text widget current cursor", "code": "def set_cursor_position(self, position):\n        \"\"\"Set cursor position\"\"\"\n        position = self.get_position(position)\n        cursor = self.textCursor()\n        cursor.setPosition(position)\n        self.setTextCursor(cursor)\n        self.ensureCursorVisible()", "code_tokens": "def set_cursor_position ( self , position ) : position = self . get_position ( position ) cursor = self . textCursor ( ) cursor . setPosition ( position ) self . setTextCursor ( cursor ) self . ensureCursorVisible ( )", "docstring_tokens": "Set cursor position", "label": 0}, {"idx": "cosqa-train-3633", "doc": "is ther a way to lowercase a string in a list in python", "code": "def downcaseTokens(s,l,t):\n    \"\"\"Helper parse action to convert tokens to lower case.\"\"\"\n    return [ tt.lower() for tt in map(_ustr,t) ]", "code_tokens": "def downcaseTokens ( s , l , t ) : return [ tt . lower ( ) for tt in map ( _ustr , t ) ]", "docstring_tokens": "Helper parse action to convert tokens to lower case .", "label": 0}, {"idx": "cosqa-train-3634", "doc": "python tkinter canvas scroll", "code": "def _set_scroll_v(self, *args):\n        \"\"\"Scroll both categories Canvas and scrolling container\"\"\"\n        self._canvas_categories.yview(*args)\n        self._canvas_scroll.yview(*args)", "code_tokens": "def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "docstring_tokens": "Scroll both categories Canvas and scrolling container", "label": 0}, {"idx": "cosqa-train-3635", "doc": "is there a python function to plot a gaussian", "code": "def gaussian_variogram_model(m, d):\n    \"\"\"Gaussian model, m is [psill, range, nugget]\"\"\"\n    psill = float(m[0])\n    range_ = float(m[1])\n    nugget = float(m[2])\n    return psill * (1. - np.exp(-d**2./(range_*4./7.)**2.)) + nugget", "code_tokens": "def gaussian_variogram_model ( m , d ) : psill = float ( m [ 0 ] ) range_ = float ( m [ 1 ] ) nugget = float ( m [ 2 ] ) return psill * ( 1. - np . exp ( - d ** 2. / ( range_ * 4. / 7. ) ** 2. ) ) + nugget", "docstring_tokens": "Gaussian model m is [ psill range nugget ]", "label": 0}, {"idx": "cosqa-train-3636", "doc": "python tkinter draw and clear", "code": "def clear_timeline(self):\n        \"\"\"\n        Clear the contents of the TimeLine Canvas\n\n        Does not modify the actual markers dictionary and thus after\n        redrawing all markers are visible again.\n        \"\"\"\n        self._timeline.delete(tk.ALL)\n        self._canvas_ticks.delete(tk.ALL)", "code_tokens": "def clear_timeline ( self ) : self . _timeline . delete ( tk . ALL ) self . _canvas_ticks . delete ( tk . ALL )", "docstring_tokens": "Clear the contents of the TimeLine Canvas", "label": 0}, {"idx": "cosqa-train-3637", "doc": "is there any predefined function to delete the duplicates in a list in python", "code": "def remove_list_duplicates(lista, unique=False):\n    \"\"\"\n    Remove duplicated elements in a list.\n    Args:\n        lista: List with elements to clean duplicates.\n    \"\"\"\n    result = []\n    allready = []\n\n    for elem in lista:\n        if elem not in result:\n            result.append(elem)\n        else:\n            allready.append(elem)\n\n    if unique:\n        for elem in allready:\n            result = list(filter((elem).__ne__, result))\n\n    return result", "code_tokens": "def remove_list_duplicates ( lista , unique = False ) : result = [ ] allready = [ ] for elem in lista : if elem not in result : result . append ( elem ) else : allready . append ( elem ) if unique : for elem in allready : result = list ( filter ( ( elem ) . __ne__ , result ) ) return result", "docstring_tokens": "Remove duplicated elements in a list . Args : lista : List with elements to clean duplicates .", "label": 0}, {"idx": "cosqa-train-3638", "doc": "python tkinter how to make a scrollbar update", "code": "def yview(self, *args):\n        \"\"\"Update inplace widgets position when doing vertical scroll\"\"\"\n        self.after_idle(self.__updateWnds)\n        ttk.Treeview.yview(self, *args)", "code_tokens": "def yview ( self , * args ) : self . after_idle ( self . __updateWnds ) ttk . Treeview . yview ( self , * args )", "docstring_tokens": "Update inplace widgets position when doing vertical scroll", "label": 0}, {"idx": "cosqa-train-3639", "doc": "iso timestamp format python", "code": "async def iso(self, source):\n        \"\"\"Convert to timestamp.\"\"\"\n        from datetime import datetime\n        unix_timestamp = int(source)\n        return datetime.fromtimestamp(unix_timestamp).isoformat()", "code_tokens": "async def iso ( self , source ) : from datetime import datetime unix_timestamp = int ( source ) return datetime . fromtimestamp ( unix_timestamp ) . isoformat ( )", "docstring_tokens": "Convert to timestamp .", "label": 0}, {"idx": "cosqa-train-3640", "doc": "python to check if file is empty or not", "code": "def file_empty(fp):\n    \"\"\"Determine if a file is empty or not.\"\"\"\n    # for python 2 we need to use a homemade peek()\n    if six.PY2:\n        contents = fp.read()\n        fp.seek(0)\n        return not bool(contents)\n\n    else:\n        return not fp.peek()", "code_tokens": "def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )", "docstring_tokens": "Determine if a file is empty or not .", "label": 0}, {"idx": "cosqa-train-3641", "doc": "issues running interact function in python", "code": "def isInteractive():\n    \"\"\"\n    A basic check of if the program is running in interactive mode\n    \"\"\"\n    if sys.stdout.isatty() and os.name != 'nt':\n        #Hopefully everything but ms supports '\\r'\n        try:\n            import threading\n        except ImportError:\n            return False\n        else:\n            return True\n    else:\n        return False", "code_tokens": "def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\\r' try : import threading except ImportError : return False else : return True else : return False", "docstring_tokens": "A basic check of if the program is running in interactive mode", "label": 0}, {"idx": "cosqa-train-3642", "doc": "python to scala convertor", "code": "def get_python_dict(scala_map):\n    \"\"\"Return a dict from entries in a scala.collection.immutable.Map\"\"\"\n    python_dict = {}\n    keys = get_python_list(scala_map.keys().toList())\n    for key in keys:\n        python_dict[key] = scala_map.apply(key)\n    return python_dict", "code_tokens": "def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict", "docstring_tokens": "Return a dict from entries in a scala . collection . immutable . Map", "label": 0}, {"idx": "cosqa-train-3643", "doc": "iterate folder in current folder python", "code": "def listfolderpath(p):\n    \"\"\"\n    generator of list folder in the path.\n    folders only\n    \"\"\"\n    for entry in scandir.scandir(p):\n        if entry.is_dir():\n            yield entry.path", "code_tokens": "def listfolderpath ( p ) : for entry in scandir . scandir ( p ) : if entry . is_dir ( ) : yield entry . path", "docstring_tokens": "generator of list folder in the path . folders only", "label": 1}, {"idx": "cosqa-train-3644", "doc": "python to see if file is not empty", "code": "def file_empty(fp):\n    \"\"\"Determine if a file is empty or not.\"\"\"\n    # for python 2 we need to use a homemade peek()\n    if six.PY2:\n        contents = fp.read()\n        fp.seek(0)\n        return not bool(contents)\n\n    else:\n        return not fp.peek()", "code_tokens": "def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )", "docstring_tokens": "Determine if a file is empty or not .", "label": 1}, {"idx": "cosqa-train-3645", "doc": "jinja set template value based on python variable", "code": "def render_template(env, filename, values=None):\n    \"\"\"\n    Render a jinja template\n    \"\"\"\n    if not values:\n        values = {}\n    tmpl = env.get_template(filename)\n    return tmpl.render(values)", "code_tokens": "def render_template ( env , filename , values = None ) : if not values : values = { } tmpl = env . get_template ( filename ) return tmpl . render ( values )", "docstring_tokens": "Render a jinja template", "label": 0}, {"idx": "cosqa-train-3646", "doc": "python tokenize an input file", "code": "def listified_tokenizer(source):\n    \"\"\"Tokenizes *source* and returns the tokens as a list of lists.\"\"\"\n    io_obj = io.StringIO(source)\n    return [list(a) for a in tokenize.generate_tokens(io_obj.readline)]", "code_tokens": "def listified_tokenizer ( source ) : io_obj = io . StringIO ( source ) return [ list ( a ) for a in tokenize . generate_tokens ( io_obj . readline ) ]", "docstring_tokens": "Tokenizes * source * and returns the tokens as a list of lists .", "label": 1}, {"idx": "cosqa-train-3647", "doc": "jinja2 insert page break python", "code": "def rstjinja(app, docname, source):\n    \"\"\"\n    Render our pages as a jinja template for fancy templating goodness.\n    \"\"\"\n    # Make sure we're outputting HTML\n    if app.builder.format != 'html':\n        return\n    src = source[0]\n    rendered = app.builder.templates.render_string(\n        src, app.config.html_context\n    )\n    source[0] = rendered", "code_tokens": "def rstjinja ( app , docname , source ) : # Make sure we're outputting HTML if app . builder . format != 'html' : return src = source [ 0 ] rendered = app . builder . templates . render_string ( src , app . config . html_context ) source [ 0 ] = rendered", "docstring_tokens": "Render our pages as a jinja template for fancy templating goodness .", "label": 0}, {"idx": "cosqa-train-3648", "doc": "jow to write contents of a variable into a file python", "code": "def save_notebook(work_notebook, write_file):\n    \"\"\"Saves the Jupyter work_notebook to write_file\"\"\"\n    with open(write_file, 'w') as out_nb:\n        json.dump(work_notebook, out_nb, indent=2)", "code_tokens": "def save_notebook ( work_notebook , write_file ) : with open ( write_file , 'w' ) as out_nb : json . dump ( work_notebook , out_nb , indent = 2 )", "docstring_tokens": "Saves the Jupyter work_notebook to write_file", "label": 0}, {"idx": "cosqa-train-3649", "doc": "python train 3d convnet diffent shape", "code": "def conv3x3(in_channels, out_channels, stride=1):\n    \"\"\"\n    3x3 convolution with padding.\n    Original code has had bias turned off, because Batch Norm would remove the bias either way\n    \"\"\"\n    return nn.Conv2d(in_channels, out_channels, kernel_size=3, stride=stride, padding=1, bias=False)", "code_tokens": "def conv3x3 ( in_channels , out_channels , stride = 1 ) : return nn . Conv2d ( in_channels , out_channels , kernel_size = 3 , stride = stride , padding = 1 , bias = False )", "docstring_tokens": "3x3 convolution with padding . Original code has had bias turned off because Batch Norm would remove the bias either way", "label": 0}, {"idx": "cosqa-train-3650", "doc": "json string of dictionaty to dictionary type in python", "code": "def _unjsonify(x, isattributes=False):\n    \"\"\"Convert JSON string to an ordered defaultdict.\"\"\"\n    if isattributes:\n        obj = json.loads(x)\n        return dict_class(obj)\n    return json.loads(x)", "code_tokens": "def _unjsonify ( x , isattributes = False ) : if isattributes : obj = json . loads ( x ) return dict_class ( obj ) return json . loads ( x )", "docstring_tokens": "Convert JSON string to an ordered defaultdict .", "label": 0}, {"idx": "cosqa-train-3651", "doc": "python transfer character to lowercase", "code": "def camel_to_(s):\n    \"\"\"\n    Convert CamelCase to camel_case\n    \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', s)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def camel_to_ ( s ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , s ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert CamelCase to camel_case", "label": 0}, {"idx": "cosqa-train-3652", "doc": "json to protobuf in python", "code": "def toJson(protoObject, indent=None):\n    \"\"\"\n    Serialises a protobuf object as json\n    \"\"\"\n    # Using the internal method because this way we can reformat the JSON\n    js = json_format.MessageToDict(protoObject, False)\n    return json.dumps(js, indent=indent)", "code_tokens": "def toJson ( protoObject , indent = None ) : # Using the internal method because this way we can reformat the JSON js = json_format . MessageToDict ( protoObject , False ) return json . dumps ( js , indent = indent )", "docstring_tokens": "Serialises a protobuf object as json", "label": 0}, {"idx": "cosqa-train-3653", "doc": "python transform time using timezone", "code": "def normalize_time(timestamp):\n    \"\"\"Normalize time in arbitrary timezone to UTC naive object.\"\"\"\n    offset = timestamp.utcoffset()\n    if offset is None:\n        return timestamp\n    return timestamp.replace(tzinfo=None) - offset", "code_tokens": "def normalize_time ( timestamp ) : offset = timestamp . utcoffset ( ) if offset is None : return timestamp return timestamp . replace ( tzinfo = None ) - offset", "docstring_tokens": "Normalize time in arbitrary timezone to UTC naive object .", "label": 1}, {"idx": "cosqa-train-3654", "doc": "judge two vector anticlockwise python", "code": "def angle_v2_rad(vec_a, vec_b):\n    \"\"\"Returns angle between vec_a and vec_b in range [0, PI].  This does not\n    distinguish if a is left of or right of b.\n    \"\"\"\n    # cos(x) = A * B / |A| * |B|\n    return math.acos(vec_a.dot(vec_b) / (vec_a.length() * vec_b.length()))", "code_tokens": "def angle_v2_rad ( vec_a , vec_b ) : # cos(x) = A * B / |A| * |B| return math . acos ( vec_a . dot ( vec_b ) / ( vec_a . length ( ) * vec_b . length ( ) ) )", "docstring_tokens": "Returns angle between vec_a and vec_b in range [ 0 PI ] . This does not distinguish if a is left of or right of b .", "label": 0}, {"idx": "cosqa-train-3655", "doc": "python try cast int list", "code": "def toListInt(value):\n        \"\"\"\n        Convert a value to list of ints, if possible.\n        \"\"\"\n        if TypeConverters._can_convert_to_list(value):\n            value = TypeConverters.toList(value)\n            if all(map(lambda v: TypeConverters._is_integer(v), value)):\n                return [int(v) for v in value]\n        raise TypeError(\"Could not convert %s to list of ints\" % value)", "code_tokens": "def toListInt ( value ) : if TypeConverters . _can_convert_to_list ( value ) : value = TypeConverters . toList ( value ) if all ( map ( lambda v : TypeConverters . _is_integer ( v ) , value ) ) : return [ int ( v ) for v in value ] raise TypeError ( \"Could not convert %s to list of ints\" % value )", "docstring_tokens": "Convert a value to list of ints if possible .", "label": 0}, {"idx": "cosqa-train-3656", "doc": "jump to next one loop python", "code": "def do_next(self, args):\n        \"\"\"Step over the next statement\n        \"\"\"\n        self._do_print_from_last_cmd = True\n        self._interp.step_over()\n        return True", "code_tokens": "def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "docstring_tokens": "Step over the next statement", "label": 0}, {"idx": "cosqa-train-3657", "doc": "python try catch reverse dns lookup socket", "code": "def cmd_dns_lookup_reverse(ip_address, verbose):\n    \"\"\"Perform a reverse lookup of a given IP address.\n\n    Example:\n\n    \\b\n    $ $ habu.dns.lookup.reverse 8.8.8.8\n    {\n        \"hostname\": \"google-public-dns-a.google.com\"\n    }\n    \"\"\"\n    if verbose:\n        logging.basicConfig(level=logging.INFO, format='%(message)s')\n        print(\"Looking up %s...\" % ip_address, file=sys.stderr)\n\n    answer = lookup_reverse(ip_address)\n\n    if answer:\n        print(json.dumps(answer, indent=4))\n    else:\n        print(\"[X] %s is not valid IPv4/IPV6 address\" % ip_address)\n\n    return True", "code_tokens": "def cmd_dns_lookup_reverse ( ip_address , verbose ) : if verbose : logging . basicConfig ( level = logging . INFO , format = '%(message)s' ) print ( \"Looking up %s...\" % ip_address , file = sys . stderr ) answer = lookup_reverse ( ip_address ) if answer : print ( json . dumps ( answer , indent = 4 ) ) else : print ( \"[X] %s is not valid IPv4/IPV6 address\" % ip_address ) return True", "docstring_tokens": "Perform a reverse lookup of a given IP address .", "label": 0}, {"idx": "cosqa-train-3658", "doc": "kill python program linux so finally block called", "code": "def stop_process(self):\n        \"\"\"\n        Stops the child process.\n        \"\"\"\n        self._process.terminate()\n        if not self._process.waitForFinished(100):\n            self._process.kill()", "code_tokens": "def stop_process ( self ) : self . _process . terminate ( ) if not self . _process . waitForFinished ( 100 ) : self . _process . kill ( )", "docstring_tokens": "Stops the child process .", "label": 0}, {"idx": "cosqa-train-3659", "doc": "python ttk treeview with scrollbar", "code": "def yview(self, *args):\n        \"\"\"Update inplace widgets position when doing vertical scroll\"\"\"\n        self.after_idle(self.__updateWnds)\n        ttk.Treeview.yview(self, *args)", "code_tokens": "def yview ( self , * args ) : self . after_idle ( self . __updateWnds ) ttk . Treeview . yview ( self , * args )", "docstring_tokens": "Update inplace widgets position when doing vertical scroll", "label": 0}, {"idx": "cosqa-train-3660", "doc": "killing python multiprocessing process", "code": "def stop(self):\n        \"\"\"\n        Stop this server so that the calling process can exit\n        \"\"\"\n        # unsetup_fuse()\n        self.fuse_process.teardown()\n        for uuid in self.processes:\n            self.processes[uuid].terminate()", "code_tokens": "def stop ( self ) : # unsetup_fuse() self . fuse_process . teardown ( ) for uuid in self . processes : self . processes [ uuid ] . terminate ( )", "docstring_tokens": "Stop this server so that the calling process can exit", "label": 0}, {"idx": "cosqa-train-3661", "doc": "python turn dict into yaml", "code": "def yaml_to_param(obj, name):\n\t\"\"\"\n\tReturn the top-level element of a document sub-tree containing the\n\tYAML serialization of a Python object.\n\t\"\"\"\n\treturn from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))", "code_tokens": "def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "docstring_tokens": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object .", "label": 0}, {"idx": "cosqa-train-3662", "doc": "know all methods in an object in python", "code": "def get_methods(*objs):\n    \"\"\" Return the names of all callable attributes of an object\"\"\"\n    return set(\n        attr\n        for obj in objs\n        for attr in dir(obj)\n        if not attr.startswith('_') and callable(getattr(obj, attr))\n    )", "code_tokens": "def get_methods ( * objs ) : return set ( attr for obj in objs for attr in dir ( obj ) if not attr . startswith ( '_' ) and callable ( getattr ( obj , attr ) ) )", "docstring_tokens": "Return the names of all callable attributes of an object", "label": 0}, {"idx": "cosqa-train-3663", "doc": "python turtle how to change position", "code": "def forward(self, step):\n        \"\"\"Move the turtle forward.\n\n        :param step: Integer. Distance to move forward.\n        \"\"\"\n        x = self.pos_x + math.cos(math.radians(self.rotation)) * step\n        y = self.pos_y + math.sin(math.radians(self.rotation)) * step\n        prev_brush_state = self.brush_on\n        self.brush_on = True\n        self.move(x, y)\n        self.brush_on = prev_brush_state", "code_tokens": "def forward ( self , step ) : x = self . pos_x + math . cos ( math . radians ( self . rotation ) ) * step y = self . pos_y + math . sin ( math . radians ( self . rotation ) ) * step prev_brush_state = self . brush_on self . brush_on = True self . move ( x , y ) self . brush_on = prev_brush_state", "docstring_tokens": "Move the turtle forward .", "label": 0}, {"idx": "cosqa-train-3664", "doc": "l2 norm of matrix python", "code": "def l2_norm(arr):\n    \"\"\"\n    The l2 norm of an array is is defined as: sqrt(||x||), where ||x|| is the\n    dot product of the vector.\n    \"\"\"\n    arr = np.asarray(arr)\n    return np.sqrt(np.dot(arr.ravel().squeeze(), arr.ravel().squeeze()))", "code_tokens": "def l2_norm ( arr ) : arr = np . asarray ( arr ) return np . sqrt ( np . dot ( arr . ravel ( ) . squeeze ( ) , arr . ravel ( ) . squeeze ( ) ) )", "docstring_tokens": "The l2 norm of an array is is defined as : sqrt ( ||x|| ) where ||x|| is the dot product of the vector .", "label": 0}, {"idx": "cosqa-train-3665", "doc": "python typehint with default", "code": "def default_strlen(strlen=None):\n    \"\"\"Sets the default string length for lstring and ilwd:char, if they are\n    treated as strings. Default is 50.\n    \"\"\"\n    if strlen is not None:\n        _default_types_status['default_strlen'] = strlen\n        # update the typeDicts as needed\n        lstring_as_obj(_default_types_status['lstring_as_obj'])\n        ilwd_as_int(_default_types_status['ilwd_as_int'])\n    return _default_types_status['default_strlen']", "code_tokens": "def default_strlen ( strlen = None ) : if strlen is not None : _default_types_status [ 'default_strlen' ] = strlen # update the typeDicts as needed lstring_as_obj ( _default_types_status [ 'lstring_as_obj' ] ) ilwd_as_int ( _default_types_status [ 'ilwd_as_int' ] ) return _default_types_status [ 'default_strlen' ]", "docstring_tokens": "Sets the default string length for lstring and ilwd : char if they are treated as strings . Default is 50 .", "label": 0}, {"idx": "cosqa-train-3666", "doc": "lambda python global variable scope", "code": "def set_global(node: Node, key: str, value: Any):\n    \"\"\"Adds passed value to node's globals\"\"\"\n    node.node_globals[key] = value", "code_tokens": "def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "docstring_tokens": "Adds passed value to node s globals", "label": 0}, {"idx": "cosqa-train-3667", "doc": "python uid not found 996", "code": "def generate_id():\n    \"\"\"Generate new UUID\"\"\"\n    # TODO: Use six.string_type to Py3 compat\n    try:\n        return unicode(uuid1()).replace(u\"-\", u\"\")\n    except NameError:\n        return str(uuid1()).replace(u\"-\", u\"\")", "code_tokens": "def generate_id ( ) : # TODO: Use six.string_type to Py3 compat try : return unicode ( uuid1 ( ) ) . replace ( u\"-\" , u\"\" ) except NameError : return str ( uuid1 ( ) ) . replace ( u\"-\" , u\"\" )", "docstring_tokens": "Generate new UUID", "label": 0}, {"idx": "cosqa-train-3668", "doc": "last page redirects on first page python scrapping", "code": "def end_index(self):\n        \"\"\"\n        Returns the 1-based index of the last object on this page,\n        relative to total objects found (hits).\n        \"\"\"\n        return ((self.number - 1) * self.paginator.per_page +\n            len(self.object_list))", "code_tokens": "def end_index ( self ) : return ( ( self . number - 1 ) * self . paginator . per_page + len ( self . object_list ) )", "docstring_tokens": "Returns the 1 - based index of the last object on this page relative to total objects found ( hits ) .", "label": 0}, {"idx": "cosqa-train-3669", "doc": "python underline transform to camel", "code": "def to_pascal_case(s):\n    \"\"\"Transform underscore separated string to pascal case\n\n    \"\"\"\n    return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())", "code_tokens": "def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )", "docstring_tokens": "Transform underscore separated string to pascal case", "label": 0}, {"idx": "cosqa-train-3670", "doc": "left mouse click code in python", "code": "def onLeftDown(self, event=None):\n        \"\"\" left button down: report x,y coords, start zooming mode\"\"\"\n        if event is None:\n            return\n        self.cursor_mode_action('leftdown', event=event)\n        self.ForwardEvent(event=event.guiEvent)", "code_tokens": "def onLeftDown ( self , event = None ) : if event is None : return self . cursor_mode_action ( 'leftdown' , event = event ) self . ForwardEvent ( event = event . guiEvent )", "docstring_tokens": "left button down : report x y coords start zooming mode", "label": 0}, {"idx": "cosqa-train-3671", "doc": "python unhashable type define hash", "code": "def omnihash(obj):\n    \"\"\" recursively hash unhashable objects \"\"\"\n    if isinstance(obj, set):\n        return hash(frozenset(omnihash(e) for e in obj))\n    elif isinstance(obj, (tuple, list)):\n        return hash(tuple(omnihash(e) for e in obj))\n    elif isinstance(obj, dict):\n        return hash(frozenset((k, omnihash(v)) for k, v in obj.items()))\n    else:\n        return hash(obj)", "code_tokens": "def omnihash ( obj ) : if isinstance ( obj , set ) : return hash ( frozenset ( omnihash ( e ) for e in obj ) ) elif isinstance ( obj , ( tuple , list ) ) : return hash ( tuple ( omnihash ( e ) for e in obj ) ) elif isinstance ( obj , dict ) : return hash ( frozenset ( ( k , omnihash ( v ) ) for k , v in obj . items ( ) ) ) else : return hash ( obj )", "docstring_tokens": "recursively hash unhashable objects", "label": 0}, {"idx": "cosqa-train-3672", "doc": "lenght of a vector in python", "code": "def norm_vec(vector):\n    \"\"\"Normalize the length of a vector to one\"\"\"\n    assert len(vector) == 3\n    v = np.array(vector)\n    return v/np.sqrt(np.sum(v**2))", "code_tokens": "def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )", "docstring_tokens": "Normalize the length of a vector to one", "label": 0}, {"idx": "cosqa-train-3673", "doc": "python unit test current environment", "code": "def test(ctx, all=False, verbose=False):\n    \"\"\"Run the tests.\"\"\"\n    cmd = 'tox' if all else 'py.test'\n    if verbose:\n        cmd += ' -v'\n    return ctx.run(cmd, pty=True).return_code", "code_tokens": "def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code", "docstring_tokens": "Run the tests .", "label": 0}, {"idx": "cosqa-train-3674", "doc": "line feed in python text files", "code": "def txt_line_iterator(path):\n  \"\"\"Iterate through lines of file.\"\"\"\n  with tf.gfile.Open(path) as f:\n    for line in f:\n      yield line.strip()", "code_tokens": "def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )", "docstring_tokens": "Iterate through lines of file .", "label": 0}, {"idx": "cosqa-train-3675", "doc": "python unittest code coverage report", "code": "def cover(session):\n    \"\"\"Run the final coverage report.\n    This outputs the coverage report aggregating coverage from the unit\n    test runs (not system test runs), and then erases coverage data.\n    \"\"\"\n    session.interpreter = 'python3.6'\n    session.install('coverage', 'pytest-cov')\n    session.run('coverage', 'report', '--show-missing', '--fail-under=100')\n    session.run('coverage', 'erase')", "code_tokens": "def cover ( session ) : session . interpreter = 'python3.6' session . install ( 'coverage' , 'pytest-cov' ) session . run ( 'coverage' , 'report' , '--show-missing' , '--fail-under=100' ) session . run ( 'coverage' , 'erase' )", "docstring_tokens": "Run the final coverage report . This outputs the coverage report aggregating coverage from the unit test runs ( not system test runs ) and then erases coverage data .", "label": 0}, {"idx": "cosqa-train-3676", "doc": "line match return the line python", "code": "def find_one(line, lookup):\n        \"\"\"\n        regexp search with one value to return.\n\n        :param line: Line\n        :param lookup: regexp\n        :return: Match group or False\n        \"\"\"\n        match = re.search(lookup, line)\n        if match:\n            if match.group(1):\n                return match.group(1)\n        return False", "code_tokens": "def find_one ( line , lookup ) : match = re . search ( lookup , line ) if match : if match . group ( 1 ) : return match . group ( 1 ) return False", "docstring_tokens": "regexp search with one value to return .", "label": 0}, {"idx": "cosqa-train-3677", "doc": "python unittest destroy object", "code": "def teardown_test(self, context):\n        \"\"\"\n        Tears down the Django test\n        \"\"\"\n        context.test.tearDownClass()\n        context.test._post_teardown(run=True)\n        del context.test", "code_tokens": "def teardown_test ( self , context ) : context . test . tearDownClass ( ) context . test . _post_teardown ( run = True ) del context . test", "docstring_tokens": "Tears down the Django test", "label": 0}, {"idx": "cosqa-train-3678", "doc": "linear regression logarithmic scale python", "code": "def glog(x,l = 2):\n    \"\"\"\n    Generalised logarithm\n\n    :param x: number\n    :param p: number added befor logarithm \n\n    \"\"\"\n    return np.log((x+np.sqrt(x**2+l**2))/2)/np.log(l)", "code_tokens": "def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )", "docstring_tokens": "Generalised logarithm", "label": 0}, {"idx": "cosqa-train-3679", "doc": "python unsupported operand types for", "code": "def __init__(self,operand,operator,**args):\n        \"\"\"\n        Accepts a NumberGenerator operand, an operator, and\n        optional arguments to be provided to the operator when calling\n        it on the operand.\n        \"\"\"\n        # Note that it's currently not possible to set\n        # parameters in the superclass when creating an instance,\n        # because **args is used by this class itself.\n        super(UnaryOperator,self).__init__()\n\n        self.operand=operand\n        self.operator=operator\n        self.args=args", "code_tokens": "def __init__ ( self , operand , operator , * * args ) : # Note that it's currently not possible to set # parameters in the superclass when creating an instance, # because **args is used by this class itself. super ( UnaryOperator , self ) . __init__ ( ) self . operand = operand self . operator = operator self . args = args", "docstring_tokens": "Accepts a NumberGenerator operand an operator and optional arguments to be provided to the operator when calling it on the operand .", "label": 0}, {"idx": "cosqa-train-3680", "doc": "linux python ioctl sioart", "code": "def _ioctl (self, func, args):\n        \"\"\"Call ioctl() with given parameters.\"\"\"\n        import fcntl\n        return fcntl.ioctl(self.sockfd.fileno(), func, args)", "code_tokens": "def _ioctl ( self , func , args ) : import fcntl return fcntl . ioctl ( self . sockfd . fileno ( ) , func , args )", "docstring_tokens": "Call ioctl () with given parameters .", "label": 0}, {"idx": "cosqa-train-3681", "doc": "python update dict only if the key not exists", "code": "def dict_update_newkeys(dict_, dict2):\n    \"\"\" Like dict.update, but does not overwrite items \"\"\"\n    for key, val in six.iteritems(dict2):\n        if key not in dict_:\n            dict_[key] = val", "code_tokens": "def dict_update_newkeys ( dict_ , dict2 ) : for key , val in six . iteritems ( dict2 ) : if key not in dict_ : dict_ [ key ] = val", "docstring_tokens": "Like dict . update but does not overwrite items", "label": 0}, {"idx": "cosqa-train-3682", "doc": "list sqlite table in python", "code": "def get_tablenames(cur):\n    \"\"\" Conveinience: \"\"\"\n    cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n    tablename_list_ = cur.fetchall()\n    tablename_list = [str(tablename[0]) for tablename in tablename_list_ ]\n    return tablename_list", "code_tokens": "def get_tablenames ( cur ) : cur . execute ( \"SELECT name FROM sqlite_master WHERE type='table'\" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list", "docstring_tokens": "Conveinience :", "label": 1}, {"idx": "cosqa-train-3683", "doc": "python update index after removing an item dictionary", "code": "def _remove_from_index(index, obj):\n    \"\"\"Removes object ``obj`` from the ``index``.\"\"\"\n    try:\n        index.value_map[indexed_value(index, obj)].remove(obj.id)\n    except KeyError:\n        pass", "code_tokens": "def _remove_from_index ( index , obj ) : try : index . value_map [ indexed_value ( index , obj ) ] . remove ( obj . id ) except KeyError : pass", "docstring_tokens": "Removes object obj from the index .", "label": 0}, {"idx": "cosqa-train-3684", "doc": "lmdb python get all keys", "code": "def keys(self, index=None):\n        \"\"\"Returns a list of keys in the database\n        \"\"\"\n        with self._lmdb.begin() as txn:\n            return [key.decode() for key, _ in txn.cursor()]", "code_tokens": "def keys ( self , index = None ) : with self . _lmdb . begin ( ) as txn : return [ key . decode ( ) for key , _ in txn . cursor ( ) ]", "docstring_tokens": "Returns a list of keys in the database", "label": 0}, {"idx": "cosqa-train-3685", "doc": "python upper and lower bound", "code": "def make_bound(lower, upper, lineno):\n    \"\"\" Wrapper: Creates an array bound\n    \"\"\"\n    return symbols.BOUND.make_node(lower, upper, lineno)", "code_tokens": "def make_bound ( lower , upper , lineno ) : return symbols . BOUND . make_node ( lower , upper , lineno )", "docstring_tokens": "Wrapper : Creates an array bound", "label": 1}, {"idx": "cosqa-train-3686", "doc": "load image using python", "code": "def load_image(fname):\n    \"\"\" read an image from file - PIL doesnt close nicely \"\"\"\n    with open(fname, \"rb\") as f:\n        i = Image.open(fname)\n        #i.load()\n        return i", "code_tokens": "def load_image ( fname ) : with open ( fname , \"rb\" ) as f : i = Image . open ( fname ) #i.load() return i", "docstring_tokens": "read an image from file - PIL doesnt close nicely", "label": 0}, {"idx": "cosqa-train-3687", "doc": "python url decode dict", "code": "def get_dict_to_encoded_url(data):\n    \"\"\"\n    Converts a dict to an encoded URL.\n    Example: given  data = {'a': 1, 'b': 2}, it returns 'a=1&b=2'\n    \"\"\"\n    unicode_data = dict([(k, smart_str(v)) for k, v in data.items()])\n    encoded = urllib.urlencode(unicode_data)\n    return encoded", "code_tokens": "def get_dict_to_encoded_url ( data ) : unicode_data = dict ( [ ( k , smart_str ( v ) ) for k , v in data . items ( ) ] ) encoded = urllib . urlencode ( unicode_data ) return encoded", "docstring_tokens": "Converts a dict to an encoded URL . Example : given data = { a : 1 b : 2 } it returns a = 1&b = 2", "label": 1}, {"idx": "cosqa-train-3688", "doc": "load in pickled python file", "code": "def load(self, filename='classifier.dump'):\n        \"\"\"\n        Unpickles the classifier used\n        \"\"\"\n        ifile = open(filename, 'r+')\n        self.classifier = pickle.load(ifile)\n        ifile.close()", "code_tokens": "def load ( self , filename = 'classifier.dump' ) : ifile = open ( filename , 'r+' ) self . classifier = pickle . load ( ifile ) ifile . close ( )", "docstring_tokens": "Unpickles the classifier used", "label": 1}, {"idx": "cosqa-train-3689", "doc": "python urllib2 unable to get boundary for multipart", "code": "def get_body_size(params, boundary):\n    \"\"\"Returns the number of bytes that the multipart/form-data encoding\n    of ``params`` will be.\"\"\"\n    size = sum(p.get_size(boundary) for p in MultipartParam.from_params(params))\n    return size + len(boundary) + 6", "code_tokens": "def get_body_size ( params , boundary ) : size = sum ( p . get_size ( boundary ) for p in MultipartParam . from_params ( params ) ) return size + len ( boundary ) + 6", "docstring_tokens": "Returns the number of bytes that the multipart / form - data encoding of params will be .", "label": 0}, {"idx": "cosqa-train-3690", "doc": "load rds data into python", "code": "def load_graph_from_rdf(fname):\n    \"\"\" reads an RDF file into a graph \"\"\"\n    print(\"reading RDF from \" + fname + \"....\")\n    store = Graph()\n    store.parse(fname, format=\"n3\")\n    print(\"Loaded \" + str(len(store)) + \" tuples\")\n    return store", "code_tokens": "def load_graph_from_rdf ( fname ) : print ( \"reading RDF from \" + fname + \"....\" ) store = Graph ( ) store . parse ( fname , format = \"n3\" ) print ( \"Loaded \" + str ( len ( store ) ) + \" tuples\" ) return store", "docstring_tokens": "reads an RDF file into a graph", "label": 1}, {"idx": "cosqa-train-3691", "doc": "python usb device object", "code": "def __init__(self, usb):\n    \"\"\"Constructs a FastbootCommands instance.\n\n    Arguments:\n      usb: UsbHandle instance.\n    \"\"\"\n    self._usb = usb\n    self._protocol = self.protocol_handler(usb)", "code_tokens": "def __init__ ( self , usb ) : self . _usb = usb self . _protocol = self . protocol_handler ( usb )", "docstring_tokens": "Constructs a FastbootCommands instance .", "label": 0}, {"idx": "cosqa-train-3692", "doc": "loading a json url in python", "code": "def get_jsonparsed_data(url):\n    \"\"\"Receive the content of ``url``, parse it as JSON and return the\n       object.\n    \"\"\"\n    response = urlopen(url)\n    data = response.read().decode('utf-8')\n    return json.loads(data)", "code_tokens": "def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )", "docstring_tokens": "Receive the content of url parse it as JSON and return the object .", "label": 0}, {"idx": "cosqa-train-3693", "doc": "python use function return as if condition", "code": "def _if(ctx, logical_test, value_if_true=0, value_if_false=False):\n    \"\"\"\n    Returns one value if the condition evaluates to TRUE, and another value if it evaluates to FALSE\n    \"\"\"\n    return value_if_true if conversions.to_boolean(logical_test, ctx) else value_if_false", "code_tokens": "def _if ( ctx , logical_test , value_if_true = 0 , value_if_false = False ) : return value_if_true if conversions . to_boolean ( logical_test , ctx ) else value_if_false", "docstring_tokens": "Returns one value if the condition evaluates to TRUE and another value if it evaluates to FALSE", "label": 0}, {"idx": "cosqa-train-3694", "doc": "locate the index of a substring in a string python", "code": "def _find(string, sub_string, start_index):\n    \"\"\"Return index of sub_string in string.\n\n    Raise TokenError if sub_string is not found.\n    \"\"\"\n    result = string.find(sub_string, start_index)\n    if result == -1:\n        raise TokenError(\"expected '{0}'\".format(sub_string))\n    return result", "code_tokens": "def _find ( string , sub_string , start_index ) : result = string . find ( sub_string , start_index ) if result == - 1 : raise TokenError ( \"expected '{0}'\" . format ( sub_string ) ) return result", "docstring_tokens": "Return index of sub_string in string .", "label": 0}, {"idx": "cosqa-train-3695", "doc": "python ustr to normal string", "code": "def b2u(string):\n    \"\"\" bytes to unicode \"\"\"\n    if (isinstance(string, bytes) or\n        (PY2 and isinstance(string, str))):\n        return string.decode('utf-8')\n    return string", "code_tokens": "def b2u ( string ) : if ( isinstance ( string , bytes ) or ( PY2 and isinstance ( string , str ) ) ) : return string . decode ( 'utf-8' ) return string", "docstring_tokens": "bytes to unicode", "label": 0}, {"idx": "cosqa-train-3696", "doc": "log gamma function python", "code": "def glog(x,l = 2):\n    \"\"\"\n    Generalised logarithm\n\n    :param x: number\n    :param p: number added befor logarithm \n\n    \"\"\"\n    return np.log((x+np.sqrt(x**2+l**2))/2)/np.log(l)", "code_tokens": "def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )", "docstring_tokens": "Generalised logarithm", "label": 1}, {"idx": "cosqa-train-3697", "doc": "python uuid no dashes", "code": "def human_uuid():\n    \"\"\"Returns a good UUID for using as a human readable string.\"\"\"\n    return base64.b32encode(\n        hashlib.sha1(uuid.uuid4().bytes).digest()).lower().strip('=')", "code_tokens": "def human_uuid ( ) : return base64 . b32encode ( hashlib . sha1 ( uuid . uuid4 ( ) . bytes ) . digest ( ) ) . lower ( ) . strip ( '=' )", "docstring_tokens": "Returns a good UUID for using as a human readable string .", "label": 0}, {"idx": "cosqa-train-3698", "doc": "log normal random distribution in python", "code": "def ln_norm(x, mu, sigma=1.0):\n    \"\"\" Natural log of scipy norm function truncated at zero \"\"\"\n    return np.log(stats.norm(loc=mu, scale=sigma).pdf(x))", "code_tokens": "def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )", "docstring_tokens": "Natural log of scipy norm function truncated at zero", "label": 0}, {"idx": "cosqa-train-3699", "doc": "python value else default", "code": "def safe_int(val, default=None):\n    \"\"\"\n    Returns int() of val if val is not convertable to int use default\n    instead\n\n    :param val:\n    :param default:\n    \"\"\"\n\n    try:\n        val = int(val)\n    except (ValueError, TypeError):\n        val = default\n\n    return val", "code_tokens": "def safe_int ( val , default = None ) : try : val = int ( val ) except ( ValueError , TypeError ) : val = default return val", "docstring_tokens": "Returns int () of val if val is not convertable to int use default instead", "label": 0}, {"idx": "cosqa-train-3700", "doc": "log normalize distribution python", "code": "def normal_log_q(self,z):\n        \"\"\"\n        The unnormalized log posterior components for mean-field normal family (the quantity we want to approximate)\n        RAO-BLACKWELLIZED!\n        \"\"\"             \n        means, scale = self.get_means_and_scales()\n        return ss.norm.logpdf(z,loc=means,scale=scale)", "code_tokens": "def normal_log_q ( self , z ) : means , scale = self . get_means_and_scales ( ) return ss . norm . logpdf ( z , loc = means , scale = scale )", "docstring_tokens": "The unnormalized log posterior components for mean - field normal family ( the quantity we want to approximate ) RAO - BLACKWELLIZED!", "label": 0}, {"idx": "cosqa-train-3701", "doc": "python value on gaussian function", "code": "def gaussian_variogram_model(m, d):\n    \"\"\"Gaussian model, m is [psill, range, nugget]\"\"\"\n    psill = float(m[0])\n    range_ = float(m[1])\n    nugget = float(m[2])\n    return psill * (1. - np.exp(-d**2./(range_*4./7.)**2.)) + nugget", "code_tokens": "def gaussian_variogram_model ( m , d ) : psill = float ( m [ 0 ] ) range_ = float ( m [ 1 ] ) nugget = float ( m [ 2 ] ) return psill * ( 1. - np . exp ( - d ** 2. / ( range_ * 4. / 7. ) ** 2. ) ) + nugget", "docstring_tokens": "Gaussian model m is [ psill range nugget ]", "label": 1}, {"idx": "cosqa-train-3702", "doc": "log server rfc python", "code": "def process_request(self, request, response):\n        \"\"\"Logs the basic endpoint requested\"\"\"\n        self.logger.info('Requested: {0} {1} {2}'.format(request.method, request.relative_uri, request.content_type))", "code_tokens": "def process_request ( self , request , response ) : self . logger . info ( 'Requested: {0} {1} {2}' . format ( request . method , request . relative_uri , request . content_type ) )", "docstring_tokens": "Logs the basic endpoint requested", "label": 0}, {"idx": "cosqa-train-3703", "doc": "python values to bins", "code": "def val_to_bin(edges, x):\n    \"\"\"Convert axis coordinate to bin index.\"\"\"\n    ibin = np.digitize(np.array(x, ndmin=1), edges) - 1\n    return ibin", "code_tokens": "def val_to_bin ( edges , x ) : ibin = np . digitize ( np . array ( x , ndmin = 1 ) , edges ) - 1 return ibin", "docstring_tokens": "Convert axis coordinate to bin index .", "label": 0}, {"idx": "cosqa-train-3704", "doc": "logarithm neperien with python", "code": "def log_loss(preds, labels):\n    \"\"\"Logarithmic loss with non-necessarily-binary labels.\"\"\"\n    log_likelihood = np.sum(labels * np.log(preds)) / len(preds)\n    return -log_likelihood", "code_tokens": "def log_loss ( preds , labels ) : log_likelihood = np . sum ( labels * np . log ( preds ) ) / len ( preds ) return - log_likelihood", "docstring_tokens": "Logarithmic loss with non - necessarily - binary labels .", "label": 0}, {"idx": "cosqa-train-3705", "doc": "python vector inner product", "code": "def dot_v3(v, w):\n    \"\"\"Return the dotproduct of two vectors.\"\"\"\n\n    return sum([x * y for x, y in zip(v, w)])", "code_tokens": "def dot_v3 ( v , w ) : return sum ( [ x * y for x , y in zip ( v , w ) ] )", "docstring_tokens": "Return the dotproduct of two vectors .", "label": 0}, {"idx": "cosqa-train-3706", "doc": "logging python close log file", "code": "def close_log(log, verbose=True):\n    \"\"\"Close log\n\n    This method closes and active logging.Logger instance.\n\n    Parameters\n    ----------\n    log : logging.Logger\n        Logging instance\n\n    \"\"\"\n\n    if verbose:\n        print('Closing log file:', log.name)\n\n    # Send closing message.\n    log.info('The log file has been closed.')\n\n    # Remove all handlers from log.\n    [log.removeHandler(handler) for handler in log.handlers]", "code_tokens": "def close_log ( log , verbose = True ) : if verbose : print ( 'Closing log file:' , log . name ) # Send closing message. log . info ( 'The log file has been closed.' ) # Remove all handlers from log. [ log . removeHandler ( handler ) for handler in log . handlers ]", "docstring_tokens": "Close log", "label": 1}, {"idx": "cosqa-train-3707", "doc": "python vector normalize stackoverflow", "code": "def v_normalize(v):\n    \"\"\"\n    Normalizes the given vector.\n    \n    The vector given may have any number of dimensions.\n    \"\"\"\n    vmag = v_magnitude(v)\n    return [ v[i]/vmag  for i in range(len(v)) ]", "code_tokens": "def v_normalize ( v ) : vmag = v_magnitude ( v ) return [ v [ i ] / vmag for i in range ( len ( v ) ) ]", "docstring_tokens": "Normalizes the given vector . The vector given may have any number of dimensions .", "label": 0}, {"idx": "cosqa-train-3708", "doc": "mac file permission denied python", "code": "def chmod_add_excute(filename):\n        \"\"\"\n        Adds execute permission to file.\n        :param filename:\n        :return:\n        \"\"\"\n        st = os.stat(filename)\n        os.chmod(filename, st.st_mode | stat.S_IEXEC)", "code_tokens": "def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "docstring_tokens": "Adds execute permission to file . : param filename : : return :", "label": 1}, {"idx": "cosqa-train-3709", "doc": "python vector normalize vectors", "code": "def v_normalize(v):\n    \"\"\"\n    Normalizes the given vector.\n    \n    The vector given may have any number of dimensions.\n    \"\"\"\n    vmag = v_magnitude(v)\n    return [ v[i]/vmag  for i in range(len(v)) ]", "code_tokens": "def v_normalize ( v ) : vmag = v_magnitude ( v ) return [ v [ i ] / vmag for i in range ( len ( v ) ) ]", "docstring_tokens": "Normalizes the given vector . The vector given may have any number of dimensions .", "label": 0}, {"idx": "cosqa-train-3710", "doc": "make map function for iteration through python", "code": "def map(cls, iterable, func, *a, **kw):\n    \"\"\"\n    Iterable-first replacement of Python's built-in `map()` function.\n    \"\"\"\n\n    return cls(func(x, *a, **kw) for x in iterable)", "code_tokens": "def map ( cls , iterable , func , * a , * * kw ) : return cls ( func ( x , * a , * * kw ) for x in iterable )", "docstring_tokens": "Iterable - first replacement of Python s built - in map () function .", "label": 0}, {"idx": "cosqa-train-3711", "doc": "python vlc media player detect finished playing", "code": "def OnTogglePlay(self, event):\n        \"\"\"Toggles the video status between play and hold\"\"\"\n\n        if self.player.get_state() == vlc.State.Playing:\n            self.player.pause()\n        else:\n            self.player.play()\n\n        event.Skip()", "code_tokens": "def OnTogglePlay ( self , event ) : if self . player . get_state ( ) == vlc . State . Playing : self . player . pause ( ) else : self . player . play ( ) event . Skip ( )", "docstring_tokens": "Toggles the video status between play and hold", "label": 0}, {"idx": "cosqa-train-3712", "doc": "make nan values zero in python", "code": "def clean_with_zeros(self,x):\n        \"\"\" set nan and inf rows from x to zero\"\"\"\n        x[~np.any(np.isnan(x) | np.isinf(x),axis=1)] = 0\n        return x", "code_tokens": "def clean_with_zeros ( self , x ) : x [ ~ np . any ( np . isnan ( x ) | np . isinf ( x ) , axis = 1 ) ] = 0 return x", "docstring_tokens": "set nan and inf rows from x to zero", "label": 0}, {"idx": "cosqa-train-3713", "doc": "python weighted average of moving window", "code": "def movingaverage(arr, window):\n    \"\"\"\n    Calculates the moving average (\"rolling mean\") of an array\n    of a certain window size.\n    \"\"\"\n    m = np.ones(int(window)) / int(window)\n    return scipy.ndimage.convolve1d(arr, m, axis=0, mode='reflect')", "code_tokens": "def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )", "docstring_tokens": "Calculates the moving average ( rolling mean ) of an array of a certain window size .", "label": 0}, {"idx": "cosqa-train-3714", "doc": "make python dictionary from list of strings", "code": "def list_string_to_dict(string):\n    \"\"\"Inputs ``['a', 'b', 'c']``, returns ``{'a': 0, 'b': 1, 'c': 2}``.\"\"\"\n    dictionary = {}\n    for idx, c in enumerate(string):\n        dictionary.update({c: idx})\n    return dictionary", "code_tokens": "def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary", "docstring_tokens": "Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } .", "label": 0}, {"idx": "cosqa-train-3715", "doc": "python win32api get handle to process", "code": "def get_process_handle(self):\n        \"\"\"\n        @rtype:  L{ProcessHandle}\n        @return: Process handle received from the system.\n            Returns C{None} if the handle is not available.\n        \"\"\"\n        # The handle doesn't need to be closed.\n        # See http://msdn.microsoft.com/en-us/library/ms681423(VS.85).aspx\n        hProcess = self.raw.u.CreateProcessInfo.hProcess\n        if hProcess in (0, win32.NULL, win32.INVALID_HANDLE_VALUE):\n            hProcess = None\n        else:\n            hProcess = ProcessHandle(hProcess, False, win32.PROCESS_ALL_ACCESS)\n        return hProcess", "code_tokens": "def get_process_handle ( self ) : # The handle doesn't need to be closed. # See http://msdn.microsoft.com/en-us/library/ms681423(VS.85).aspx hProcess = self . raw . u . CreateProcessInfo . hProcess if hProcess in ( 0 , win32 . NULL , win32 . INVALID_HANDLE_VALUE ) : hProcess = None else : hProcess = ProcessHandle ( hProcess , False , win32 . PROCESS_ALL_ACCESS ) return hProcess", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-3716", "doc": "make regex for a string in python", "code": "def make_regex(separator):\n    \"\"\"Utility function to create regexp for matching escaped separators\n    in strings.\n\n    \"\"\"\n    return re.compile(r'(?:' + re.escape(separator) + r')?((?:[^' +\n                      re.escape(separator) + r'\\\\]|\\\\.)+)')", "code_tokens": "def make_regex ( separator ) : return re . compile ( r'(?:' + re . escape ( separator ) + r')?((?:[^' + re . escape ( separator ) + r'\\\\]|\\\\.)+)' )", "docstring_tokens": "Utility function to create regexp for matching escaped separators in strings .", "label": 1}, {"idx": "cosqa-train-3717", "doc": "python win32api get mouse position", "code": "def _position():\n    \"\"\"Returns the current xy coordinates of the mouse cursor as a two-integer\n    tuple by calling the GetCursorPos() win32 function.\n\n    Returns:\n      (x, y) tuple of the current xy coordinates of the mouse cursor.\n    \"\"\"\n\n    cursor = POINT()\n    ctypes.windll.user32.GetCursorPos(ctypes.byref(cursor))\n    return (cursor.x, cursor.y)", "code_tokens": "def _position ( ) : cursor = POINT ( ) ctypes . windll . user32 . GetCursorPos ( ctypes . byref ( cursor ) ) return ( cursor . x , cursor . y )", "docstring_tokens": "Returns the current xy coordinates of the mouse cursor as a two - integer tuple by calling the GetCursorPos () win32 function .", "label": 0}, {"idx": "cosqa-train-3718", "doc": "make text comment in python", "code": "def comment (self, s, **args):\n        \"\"\"Write DOT comment.\"\"\"\n        self.write(u\"// \")\n        self.writeln(s=s, **args)", "code_tokens": "def comment ( self , s , * * args ) : self . write ( u\"// \" ) self . writeln ( s = s , * * args )", "docstring_tokens": "Write DOT comment .", "label": 0}, {"idx": "cosqa-train-3719", "doc": "python windows kill process by pid", "code": "def kill_process_children(pid):\n    \"\"\"Find and kill child processes of a process.\n\n    :param pid: PID of parent process (process ID)\n    :return: Nothing\n    \"\"\"\n    if sys.platform == \"darwin\":\n        kill_process_children_osx(pid)\n    elif sys.platform == \"linux\":\n        kill_process_children_unix(pid)\n    else:\n        pass", "code_tokens": "def kill_process_children ( pid ) : if sys . platform == \"darwin\" : kill_process_children_osx ( pid ) elif sys . platform == \"linux\" : kill_process_children_unix ( pid ) else : pass", "docstring_tokens": "Find and kill child processes of a process .", "label": 0}, {"idx": "cosqa-train-3720", "doc": "make values as strings in a list in python", "code": "def vectorize(values):\n    \"\"\"\n    Takes a value or list of values and returns a single result, joined by \",\"\n    if necessary.\n    \"\"\"\n    if isinstance(values, list):\n        return ','.join(str(v) for v in values)\n    return values", "code_tokens": "def vectorize ( values ) : if isinstance ( values , list ) : return ',' . join ( str ( v ) for v in values ) return values", "docstring_tokens": "Takes a value or list of values and returns a single result joined by if necessary .", "label": 1}, {"idx": "cosqa-train-3721", "doc": "python windows programming closing parent process without closing child", "code": "def _psutil_kill_pid(pid):\n    \"\"\"\n    http://stackoverflow.com/questions/1230669/subprocess-deleting-child-processes-in-windows\n    \"\"\"\n    try:\n        parent = Process(pid)\n        for child in parent.children(recursive=True):\n            child.kill()\n        parent.kill()\n    except NoSuchProcess:\n        return", "code_tokens": "def _psutil_kill_pid ( pid ) : try : parent = Process ( pid ) for child in parent . children ( recursive = True ) : child . kill ( ) parent . kill ( ) except NoSuchProcess : return", "docstring_tokens": "http : // stackoverflow . com / questions / 1230669 / subprocess - deleting - child - processes - in - windows", "label": 1}, {"idx": "cosqa-train-3722", "doc": "managing file caching python", "code": "def is_cached(file_name):\n\t\"\"\"\n\tCheck if a given file is available in the cache or not\n\t\"\"\"\n\n\tgml_file_path = join(join(expanduser('~'), OCTOGRID_DIRECTORY), file_name)\n\n\treturn isfile(gml_file_path)", "code_tokens": "def is_cached ( file_name ) : gml_file_path = join ( join ( expanduser ( '~' ) , OCTOGRID_DIRECTORY ) , file_name ) return isfile ( gml_file_path )", "docstring_tokens": "Check if a given file is available in the cache or not", "label": 1}, {"idx": "cosqa-train-3723", "doc": "manually close request connection python", "code": "def close(self):\n        \"\"\"Closes this response.\"\"\"\n        if self._connection:\n            self._connection.close()\n        self._response.close()", "code_tokens": "def close ( self ) : if self . _connection : self . _connection . close ( ) self . _response . close ( )", "docstring_tokens": "Closes this response .", "label": 0}, {"idx": "cosqa-train-3724", "doc": "python wrap function with try catch dynamically", "code": "def retry_call(func, cleanup=lambda: None, retries=0, trap=()):\n\t\"\"\"\n\tGiven a callable func, trap the indicated exceptions\n\tfor up to 'retries' times, invoking cleanup on the\n\texception. On the final attempt, allow any exceptions\n\tto propagate.\n\t\"\"\"\n\tattempts = count() if retries == float('inf') else range(retries)\n\tfor attempt in attempts:\n\t\ttry:\n\t\t\treturn func()\n\t\texcept trap:\n\t\t\tcleanup()\n\n\treturn func()", "code_tokens": "def retry_call ( func , cleanup = lambda : None , retries = 0 , trap = ( ) ) : attempts = count ( ) if retries == float ( 'inf' ) else range ( retries ) for attempt in attempts : try : return func ( ) except trap : cleanup ( ) return func ( )", "docstring_tokens": "Given a callable func trap the indicated exceptions for up to retries times invoking cleanup on the exception . On the final attempt allow any exceptions to propagate .", "label": 0}, {"idx": "cosqa-train-3725", "doc": "map accept multiple integer in the same line python", "code": "def reduce_json(data):\n    \"\"\"Reduce a JSON object\"\"\"\n    return reduce(lambda x, y: int(x) + int(y), data.values())", "code_tokens": "def reduce_json ( data ) : return reduce ( lambda x , y : int ( x ) + int ( y ) , data . values ( ) )", "docstring_tokens": "Reduce a JSON object", "label": 0}, {"idx": "cosqa-train-3726", "doc": "python wrapper function cast", "code": "def convert_value(bind, value):\n    \"\"\" Type casting. \"\"\"\n    type_name = get_type(bind)\n    try:\n        return typecast.cast(type_name, value)\n    except typecast.ConverterError:\n        return value", "code_tokens": "def convert_value ( bind , value ) : type_name = get_type ( bind ) try : return typecast . cast ( type_name , value ) except typecast . ConverterError : return value", "docstring_tokens": "Type casting .", "label": 1}, {"idx": "cosqa-train-3727", "doc": "map pool python chunksize", "code": "def chop(seq, size):\n    \"\"\"Chop a sequence into chunks of the given size.\"\"\"\n    chunk = lambda i: seq[i:i+size]\n    return map(chunk,xrange(0,len(seq),size))", "code_tokens": "def chop ( seq , size ) : chunk = lambda i : seq [ i : i + size ] return map ( chunk , xrange ( 0 , len ( seq ) , size ) )", "docstring_tokens": "Chop a sequence into chunks of the given size .", "label": 0}, {"idx": "cosqa-train-3728", "doc": "python write a string to a file", "code": "def write_str2file(pathname, astr):\n    \"\"\"writes a string to file\"\"\"\n    fname = pathname\n    fhandle = open(fname, 'wb')\n    fhandle.write(astr)\n    fhandle.close()", "code_tokens": "def write_str2file ( pathname , astr ) : fname = pathname fhandle = open ( fname , 'wb' ) fhandle . write ( astr ) fhandle . close ( )", "docstring_tokens": "writes a string to file", "label": 0}, {"idx": "cosqa-train-3729", "doc": "matching diconary value with key python", "code": "def get_key_by_value(dictionary, search_value):\n    \"\"\"\n    searchs a value in a dicionary and returns the key of the first occurrence\n\n    :param dictionary: dictionary to search in\n    :param search_value: value to search for\n    \"\"\"\n    for key, value in dictionary.iteritems():\n        if value == search_value:\n            return ugettext(key)", "code_tokens": "def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )", "docstring_tokens": "searchs a value in a dicionary and returns the key of the first occurrence", "label": 0}, {"idx": "cosqa-train-3730", "doc": "python write csv to matrix", "code": "def csv_matrix_print(classes, table):\n    \"\"\"\n    Return matrix as csv data.\n\n    :param classes: classes list\n    :type classes:list\n    :param table: table\n    :type table:dict\n    :return:\n    \"\"\"\n    result = \"\"\n    classes.sort()\n    for i in classes:\n        for j in classes:\n            result += str(table[i][j]) + \",\"\n        result = result[:-1] + \"\\n\"\n    return result[:-1]", "code_tokens": "def csv_matrix_print ( classes , table ) : result = \"\" classes . sort ( ) for i in classes : for j in classes : result += str ( table [ i ] [ j ] ) + \",\" result = result [ : - 1 ] + \"\\n\" return result [ : - 1 ]", "docstring_tokens": "Return matrix as csv data .", "label": 0}, {"idx": "cosqa-train-3731", "doc": "matrix inverse in python symbolic", "code": "def MatrixInverse(a, adj):\n    \"\"\"\n    Matrix inversion op.\n    \"\"\"\n    return np.linalg.inv(a if not adj else _adjoint(a)),", "code_tokens": "def MatrixInverse ( a , adj ) : return np . linalg . inv ( a if not adj else _adjoint ( a ) ) ,", "docstring_tokens": "Matrix inversion op .", "label": 0}, {"idx": "cosqa-train-3732", "doc": "python write file ansi", "code": "def _write_color_ansi (fp, text, color):\n    \"\"\"Colorize text with given color.\"\"\"\n    fp.write(esc_ansicolor(color))\n    fp.write(text)\n    fp.write(AnsiReset)", "code_tokens": "def _write_color_ansi ( fp , text , color ) : fp . write ( esc_ansicolor ( color ) ) fp . write ( text ) fp . write ( AnsiReset )", "docstring_tokens": "Colorize text with given color .", "label": 0}, {"idx": "cosqa-train-3733", "doc": "max length of a line of code in python", "code": "def indentsize(line):\n    \"\"\"Return the indent size, in spaces, at the start of a line of text.\"\"\"\n    expline = string.expandtabs(line)\n    return len(expline) - len(string.lstrip(expline))", "code_tokens": "def indentsize ( line ) : expline = string . expandtabs ( line ) return len ( expline ) - len ( string . lstrip ( expline ) )", "docstring_tokens": "Return the indent size in spaces at the start of a line of text .", "label": 0}, {"idx": "cosqa-train-3734", "doc": "python write one line last line", "code": "def write_line(self, line, count=1):\n        \"\"\"writes the line and count newlines after the line\"\"\"\n        self.write(line)\n        self.write_newlines(count)", "code_tokens": "def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )", "docstring_tokens": "writes the line and count newlines after the line", "label": 1}, {"idx": "cosqa-train-3735", "doc": "micropython howto print traceback message", "code": "def _show_traceback(method):\n    \"\"\"decorator for showing tracebacks in IPython\"\"\"\n    def m(self, *args, **kwargs):\n        try:\n            return(method(self, *args, **kwargs))\n        except Exception as e:\n            ip = get_ipython()\n            if ip is None:\n                self.log.warning(\"Exception in widget method %s: %s\", method, e, exc_info=True)\n            else:\n                ip.showtraceback()\n    return m", "code_tokens": "def _show_traceback ( method ) : def m ( self , * args , * * kwargs ) : try : return ( method ( self , * args , * * kwargs ) ) except Exception as e : ip = get_ipython ( ) if ip is None : self . log . warning ( \"Exception in widget method %s: %s\" , method , e , exc_info = True ) else : ip . showtraceback ( ) return m", "docstring_tokens": "decorator for showing tracebacks in IPython", "label": 0}, {"idx": "cosqa-train-3736", "doc": "python write pid file", "code": "def _write_pidfile(pidfile):\n    \"\"\" Write file with current process ID.\n    \"\"\"\n    pid = str(os.getpid())\n    handle = open(pidfile, 'w')\n    try:\n        handle.write(\"%s\\n\" % pid)\n    finally:\n        handle.close()", "code_tokens": "def _write_pidfile ( pidfile ) : pid = str ( os . getpid ( ) ) handle = open ( pidfile , 'w' ) try : handle . write ( \"%s\\n\" % pid ) finally : handle . close ( )", "docstring_tokens": "Write file with current process ID .", "label": 0}, {"idx": "cosqa-train-3737", "doc": "min max of random integers python", "code": "def random_color(_min=MIN_COLOR, _max=MAX_COLOR):\n    \"\"\"Returns a random color between min and max.\"\"\"\n    return color(random.randint(_min, _max))", "code_tokens": "def random_color ( _min = MIN_COLOR , _max = MAX_COLOR ) : return color ( random . randint ( _min , _max ) )", "docstring_tokens": "Returns a random color between min and max .", "label": 1}, {"idx": "cosqa-train-3738", "doc": "python write to subprocess stdin", "code": "def correspond(text):\n    \"\"\"Communicate with the child process without closing stdin.\"\"\"\n    subproc.stdin.write(text)\n    subproc.stdin.flush()\n    return drain()", "code_tokens": "def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )", "docstring_tokens": "Communicate with the child process without closing stdin .", "label": 0}, {"idx": "cosqa-train-3739", "doc": "min of array function in python", "code": "def SegmentMin(a, ids):\n    \"\"\"\n    Segmented min op.\n    \"\"\"\n    func = lambda idxs: np.amin(a[idxs], axis=0)\n    return seg_map(func, a, ids),", "code_tokens": "def SegmentMin ( a , ids ) : func = lambda idxs : np . amin ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,", "docstring_tokens": "Segmented min op .", "label": 0}, {"idx": "cosqa-train-3740", "doc": "python writing a chart to another file", "code": "def save_dot(self, fd):\n        \"\"\" Saves a representation of the case in the Graphviz DOT language.\n        \"\"\"\n        from pylon.io import DotWriter\n        DotWriter(self).write(fd)", "code_tokens": "def save_dot ( self , fd ) : from pylon . io import DotWriter DotWriter ( self ) . write ( fd )", "docstring_tokens": "Saves a representation of the case in the Graphviz DOT language .", "label": 0}, {"idx": "cosqa-train-3741", "doc": "mitmproxy add upstream proxy in python", "code": "def _prepare_proxy(self, conn):\n        \"\"\"\n        Establish tunnel connection early, because otherwise httplib\n        would improperly set Host: header to proxy's IP:port.\n        \"\"\"\n        conn.set_tunnel(self._proxy_host, self.port, self.proxy_headers)\n        conn.connect()", "code_tokens": "def _prepare_proxy ( self , conn ) : conn . set_tunnel ( self . _proxy_host , self . port , self . proxy_headers ) conn . connect ( )", "docstring_tokens": "Establish tunnel connection early because otherwise httplib would improperly set Host : header to proxy s IP : port .", "label": 0}, {"idx": "cosqa-train-3742", "doc": "python xml delete all elements containing", "code": "def cleanup_nodes(doc):\n    \"\"\"\n    Remove text nodes containing only whitespace\n    \"\"\"\n    for node in doc.documentElement.childNodes:\n        if node.nodeType == Node.TEXT_NODE and node.nodeValue.isspace():\n            doc.documentElement.removeChild(node)\n    return doc", "code_tokens": "def cleanup_nodes ( doc ) : for node in doc . documentElement . childNodes : if node . nodeType == Node . TEXT_NODE and node . nodeValue . isspace ( ) : doc . documentElement . removeChild ( node ) return doc", "docstring_tokens": "Remove text nodes containing only whitespace", "label": 1}, {"idx": "cosqa-train-3743", "doc": "mock a function wrapper python", "code": "def mock_decorator(*args, **kwargs):\n    \"\"\"Mocked decorator, needed in the case we need to mock a decorator\"\"\"\n    def _called_decorator(dec_func):\n        @wraps(dec_func)\n        def _decorator(*args, **kwargs):\n            return dec_func()\n        return _decorator\n    return _called_decorator", "code_tokens": "def mock_decorator ( * args , * * kwargs ) : def _called_decorator ( dec_func ) : @ wraps ( dec_func ) def _decorator ( * args , * * kwargs ) : return dec_func ( ) return _decorator return _called_decorator", "docstring_tokens": "Mocked decorator needed in the case we need to mock a decorator", "label": 0}, {"idx": "cosqa-train-3744", "doc": "python xml get each child text", "code": "def __get_xml_text(root):\n    \"\"\" Return the text for the given root node (xml.dom.minidom). \"\"\"\n    txt = \"\"\n    for e in root.childNodes:\n        if (e.nodeType == e.TEXT_NODE):\n            txt += e.data\n    return txt", "code_tokens": "def __get_xml_text ( root ) : txt = \"\" for e in root . childNodes : if ( e . nodeType == e . TEXT_NODE ) : txt += e . data return txt", "docstring_tokens": "Return the text for the given root node ( xml . dom . minidom ) .", "label": 0}, {"idx": "cosqa-train-3745", "doc": "model accuracy calculation python", "code": "def cat_acc(y_true, y_pred):\n    \"\"\"Categorical accuracy\n    \"\"\"\n    return np.mean(y_true.argmax(axis=1) == y_pred.argmax(axis=1))", "code_tokens": "def cat_acc ( y_true , y_pred ) : return np . mean ( y_true . argmax ( axis = 1 ) == y_pred . argmax ( axis = 1 ) )", "docstring_tokens": "Categorical accuracy", "label": 0}, {"idx": "cosqa-train-3746", "doc": "python xrange start at 1", "code": "def _xxrange(self, start, end, step_count):\n        \"\"\"Generate n values between start and end.\"\"\"\n        _step = (end - start) / float(step_count)\n        return (start + (i * _step) for i in xrange(int(step_count)))", "code_tokens": "def _xxrange ( self , start , end , step_count ) : _step = ( end - start ) / float ( step_count ) return ( start + ( i * _step ) for i in xrange ( int ( step_count ) ) )", "docstring_tokens": "Generate n values between start and end .", "label": 0}, {"idx": "cosqa-train-3747", "doc": "mogrify in python and bulk update in python", "code": "def forceupdate(self, *args, **kw):\n        \"\"\"Like a bulk :meth:`forceput`.\"\"\"\n        self._update(False, self._ON_DUP_OVERWRITE, *args, **kw)", "code_tokens": "def forceupdate ( self , * args , * * kw ) : self . _update ( False , self . _ON_DUP_OVERWRITE , * args , * * kw )", "docstring_tokens": "Like a bulk : meth : forceput .", "label": 0}, {"idx": "cosqa-train-3748", "doc": "python yaml read data from file", "code": "def load_yaml(filepath):\n    \"\"\"Convenience function for loading yaml-encoded data from disk.\"\"\"\n    with open(filepath) as f:\n        txt = f.read()\n    return yaml.load(txt)", "code_tokens": "def load_yaml ( filepath ) : with open ( filepath ) as f : txt = f . read ( ) return yaml . load ( txt )", "docstring_tokens": "Convenience function for loading yaml - encoded data from disk .", "label": 1}, {"idx": "cosqa-train-3749", "doc": "month from a datetime in python", "code": "def start_of_month(val):\n    \"\"\"\n    Return a new datetime.datetime object with values that represent\n    a start of a month.\n    :param val: Date to ...\n    :type val: datetime.datetime | datetime.date\n    :rtype: datetime.datetime\n    \"\"\"\n    if type(val) == date:\n        val = datetime.fromordinal(val.toordinal())\n    return start_of_day(val).replace(day=1)", "code_tokens": "def start_of_month ( val ) : if type ( val ) == date : val = datetime . fromordinal ( val . toordinal ( ) ) return start_of_day ( val ) . replace ( day = 1 )", "docstring_tokens": "Return a new datetime . datetime object with values that represent a start of a month . : param val : Date to ... : type val : datetime . datetime | datetime . date : rtype : datetime . datetime", "label": 0}, {"idx": "cosqa-train-3750", "doc": "python yield certain amount", "code": "def chunks(iterable, chunk):\n    \"\"\"Yield successive n-sized chunks from an iterable.\"\"\"\n    for i in range(0, len(iterable), chunk):\n        yield iterable[i:i + chunk]", "code_tokens": "def chunks ( iterable , chunk ) : for i in range ( 0 , len ( iterable ) , chunk ) : yield iterable [ i : i + chunk ]", "docstring_tokens": "Yield successive n - sized chunks from an iterable .", "label": 0}, {"idx": "cosqa-train-3751", "doc": "most common value for a key of a dictionary of lists python", "code": "def most_common(items):\n    \"\"\"\n    Wanted functionality from Counters (new in Python 2.7).\n    \"\"\"\n    counts = {}\n    for i in items:\n        counts.setdefault(i, 0)\n        counts[i] += 1\n    return max(six.iteritems(counts), key=operator.itemgetter(1))", "code_tokens": "def most_common ( items ) : counts = { } for i in items : counts . setdefault ( i , 0 ) counts [ i ] += 1 return max ( six . iteritems ( counts ) , key = operator . itemgetter ( 1 ) )", "docstring_tokens": "Wanted functionality from Counters ( new in Python 2 . 7 ) .", "label": 0}, {"idx": "cosqa-train-3752", "doc": "python zmq non blocking", "code": "def _run_asyncio(loop, zmq_context):\n    \"\"\"\n    Run asyncio (should be called in a thread) and close the loop and the zmq context when the thread ends\n    :param loop:\n    :param zmq_context:\n    :return:\n    \"\"\"\n    try:\n        asyncio.set_event_loop(loop)\n        loop.run_forever()\n    except:\n        pass\n    finally:\n        loop.close()\n        zmq_context.destroy(1000)", "code_tokens": "def _run_asyncio ( loop , zmq_context ) : try : asyncio . set_event_loop ( loop ) loop . run_forever ( ) except : pass finally : loop . close ( ) zmq_context . destroy ( 1000 )", "docstring_tokens": "Run asyncio ( should be called in a thread ) and close the loop and the zmq context when the thread ends : param loop : : param zmq_context : : return :", "label": 0}, {"idx": "cosqa-train-3753", "doc": "most common values in all the keys of the dictionary python", "code": "def most_common(items):\n    \"\"\"\n    Wanted functionality from Counters (new in Python 2.7).\n    \"\"\"\n    counts = {}\n    for i in items:\n        counts.setdefault(i, 0)\n        counts[i] += 1\n    return max(six.iteritems(counts), key=operator.itemgetter(1))", "code_tokens": "def most_common ( items ) : counts = { } for i in items : counts . setdefault ( i , 0 ) counts [ i ] += 1 return max ( six . iteritems ( counts ) , key = operator . itemgetter ( 1 ) )", "docstring_tokens": "Wanted functionality from Counters ( new in Python 2 . 7 ) .", "label": 0}, {"idx": "cosqa-train-3754", "doc": "python, check iterable type", "code": "def _is_iterable(item):\n    \"\"\" Checks if an item is iterable (list, tuple, generator), but not string \"\"\"\n    return isinstance(item, collections.Iterable) and not isinstance(item, six.string_types)", "code_tokens": "def _is_iterable ( item ) : return isinstance ( item , collections . Iterable ) and not isinstance ( item , six . string_types )", "docstring_tokens": "Checks if an item is iterable ( list tuple generator ) but not string", "label": 0}, {"idx": "cosqa-train-3755", "doc": "mouse cursor marker and python and x, y coordinates", "code": "def _position():\n    \"\"\"Returns the current xy coordinates of the mouse cursor as a two-integer\n    tuple by calling the GetCursorPos() win32 function.\n\n    Returns:\n      (x, y) tuple of the current xy coordinates of the mouse cursor.\n    \"\"\"\n\n    cursor = POINT()\n    ctypes.windll.user32.GetCursorPos(ctypes.byref(cursor))\n    return (cursor.x, cursor.y)", "code_tokens": "def _position ( ) : cursor = POINT ( ) ctypes . windll . user32 . GetCursorPos ( ctypes . byref ( cursor ) ) return ( cursor . x , cursor . y )", "docstring_tokens": "Returns the current xy coordinates of the mouse cursor as a two - integer tuple by calling the GetCursorPos () win32 function .", "label": 0}, {"idx": "cosqa-train-3756", "doc": "python, extract date only from datetime data frame", "code": "def _parse(self, date_str, format='%Y-%m-%d'):\n        \"\"\"\n        helper function for parsing FRED date string into datetime\n        \"\"\"\n        rv = pd.to_datetime(date_str, format=format)\n        if hasattr(rv, 'to_pydatetime'):\n            rv = rv.to_pydatetime()\n        return rv", "code_tokens": "def _parse ( self , date_str , format = '%Y-%m-%d' ) : rv = pd . to_datetime ( date_str , format = format ) if hasattr ( rv , 'to_pydatetime' ) : rv = rv . to_pydatetime ( ) return rv", "docstring_tokens": "helper function for parsing FRED date string into datetime", "label": 0}, {"idx": "cosqa-train-3757", "doc": "multiline string wrapping python", "code": "def normalize_text(text, line_len=80, indent=\"\"):\n    \"\"\"Wrap the text on the given line length.\"\"\"\n    return \"\\n\".join(\n        textwrap.wrap(\n            text, width=line_len, initial_indent=indent, subsequent_indent=indent\n        )\n    )", "code_tokens": "def normalize_text ( text , line_len = 80 , indent = \"\" ) : return \"\\n\" . join ( textwrap . wrap ( text , width = line_len , initial_indent = indent , subsequent_indent = indent ) )", "docstring_tokens": "Wrap the text on the given line length .", "label": 0}, {"idx": "cosqa-train-3758", "doc": "python, get current thread id", "code": "def threadid(self):\n        \"\"\"\n        Current thread ident. If current thread is main thread then it returns ``None``.\n\n        :type: int or None\n        \"\"\"\n        current = self.thread.ident\n        main = get_main_thread()\n        if main is None:\n            return current\n        else:\n            return current if current != main.ident else None", "code_tokens": "def threadid ( self ) : current = self . thread . ident main = get_main_thread ( ) if main is None : return current else : return current if current != main . ident else None", "docstring_tokens": "Current thread ident . If current thread is main thread then it returns None .", "label": 0}, {"idx": "cosqa-train-3759", "doc": "multiple variables in except python", "code": "def format_vars(args):\n    \"\"\"Format the given vars in the form: 'flag=value'\"\"\"\n    variables = []\n    for key, value in args.items():\n        if value:\n            variables += ['{0}={1}'.format(key, value)]\n    return variables", "code_tokens": "def format_vars ( args ) : variables = [ ] for key , value in args . items ( ) : if value : variables += [ '{0}={1}' . format ( key , value ) ] return variables", "docstring_tokens": "Format the given vars in the form : flag = value", "label": 0}, {"idx": "cosqa-train-3760", "doc": "python2 can i delete test dir", "code": "def remove_examples_all():\n    \"\"\"remove arduino/examples/all directory.\n\n    :rtype: None\n\n    \"\"\"\n    d = examples_all_dir()\n    if d.exists():\n        log.debug('remove %s', d)\n        d.rmtree()\n    else:\n        log.debug('nothing to remove: %s', d)", "code_tokens": "def remove_examples_all ( ) : d = examples_all_dir ( ) if d . exists ( ) : log . debug ( 'remove %s' , d ) d . rmtree ( ) else : log . debug ( 'nothing to remove: %s' , d )", "docstring_tokens": "remove arduino / examples / all directory .", "label": 0}, {"idx": "cosqa-train-3761", "doc": "multiply a tesnor by rotation matrix python", "code": "def transform_from_rot_trans(R, t):\n    \"\"\"Transforation matrix from rotation matrix and translation vector.\"\"\"\n    R = R.reshape(3, 3)\n    t = t.reshape(3, 1)\n    return np.vstack((np.hstack([R, t]), [0, 0, 0, 1]))", "code_tokens": "def transform_from_rot_trans ( R , t ) : R = R . reshape ( 3 , 3 ) t = t . reshape ( 3 , 1 ) return np . vstack ( ( np . hstack ( [ R , t ] ) , [ 0 , 0 , 0 , 1 ] ) )", "docstring_tokens": "Transforation matrix from rotation matrix and translation vector .", "label": 0}, {"idx": "cosqa-train-3762", "doc": "python3 checking for list or tuple", "code": "def is_iter_non_string(obj):\n    \"\"\"test if object is a list or tuple\"\"\"\n    if isinstance(obj, list) or isinstance(obj, tuple):\n        return True\n    return False", "code_tokens": "def is_iter_non_string ( obj ) : if isinstance ( obj , list ) or isinstance ( obj , tuple ) : return True return False", "docstring_tokens": "test if object is a list or tuple", "label": 0}, {"idx": "cosqa-train-3763", "doc": "multivariate normal distribution in python", "code": "def norm(x, mu, sigma=1.0):\n    \"\"\" Scipy norm function \"\"\"\n    return stats.norm(loc=mu, scale=sigma).pdf(x)", "code_tokens": "def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )", "docstring_tokens": "Scipy norm function", "label": 0}, {"idx": "cosqa-train-3764", "doc": "python3 create vtk array with 3d array", "code": "def trans_from_matrix(matrix):\n    \"\"\" Convert a vtk matrix to a numpy.ndarray \"\"\"\n    t = np.zeros((4, 4))\n    for i in range(4):\n        for j in range(4):\n            t[i, j] = matrix.GetElement(i, j)\n    return t", "code_tokens": "def trans_from_matrix ( matrix ) : t = np . zeros ( ( 4 , 4 ) ) for i in range ( 4 ) : for j in range ( 4 ) : t [ i , j ] = matrix . GetElement ( i , j ) return t", "docstring_tokens": "Convert a vtk matrix to a numpy . ndarray", "label": 0}, {"idx": "cosqa-train-3765", "doc": "mutiple conditionals in lambda python", "code": "def All(sequence):\n  \"\"\"\n  :param sequence: Any sequence whose elements can be evaluated as booleans.\n  :returns: true if all elements of the sequence satisfy True and x.\n  \"\"\"\n  return bool(reduce(lambda x, y: x and y, sequence, True))", "code_tokens": "def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )", "docstring_tokens": ": param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x .", "label": 0}, {"idx": "cosqa-train-3766", "doc": "python3 determine content type by file extention name", "code": "def get_file_extension_type(filename):\n    \"\"\"\n    Return the group associated to the file\n    :param filename:\n    :return: str\n    \"\"\"\n    ext = get_file_extension(filename)\n    if ext:\n        for name, group in EXTENSIONS.items():\n            if ext in group:\n                return name\n    return \"OTHER\"", "code_tokens": "def get_file_extension_type ( filename ) : ext = get_file_extension ( filename ) if ext : for name , group in EXTENSIONS . items ( ) : if ext in group : return name return \"OTHER\"", "docstring_tokens": "Return the group associated to the file : param filename : : return : str", "label": 1}, {"idx": "cosqa-train-3767", "doc": "name 'cuda' is not defined python", "code": "def inspect_cuda():\n    \"\"\" Return cuda device information and nvcc/cuda setup \"\"\"\n    nvcc_settings = nvcc_compiler_settings()\n    sysconfig.get_config_vars()\n    nvcc_compiler = ccompiler.new_compiler()\n    sysconfig.customize_compiler(nvcc_compiler)\n    customize_compiler_for_nvcc(nvcc_compiler, nvcc_settings)\n\n    output = inspect_cuda_version_and_devices(nvcc_compiler, nvcc_settings)\n\n    return json.loads(output), nvcc_settings", "code_tokens": "def inspect_cuda ( ) : nvcc_settings = nvcc_compiler_settings ( ) sysconfig . get_config_vars ( ) nvcc_compiler = ccompiler . new_compiler ( ) sysconfig . customize_compiler ( nvcc_compiler ) customize_compiler_for_nvcc ( nvcc_compiler , nvcc_settings ) output = inspect_cuda_version_and_devices ( nvcc_compiler , nvcc_settings ) return json . loads ( output ) , nvcc_settings", "docstring_tokens": "Return cuda device information and nvcc / cuda setup", "label": 0}, {"idx": "cosqa-train-3768", "doc": "python3 dict object has no attribute iteritems", "code": "def iteritems(data, **kwargs):\n    \"\"\"Iterate over dict items.\"\"\"\n    return iter(data.items(**kwargs)) if IS_PY3 else data.iteritems(**kwargs)", "code_tokens": "def iteritems ( data , * * kwargs ) : return iter ( data . items ( * * kwargs ) ) if IS_PY3 else data . iteritems ( * * kwargs )", "docstring_tokens": "Iterate over dict items .", "label": 0}, {"idx": "cosqa-train-3769", "doc": "ndarray python to string", "code": "def _array2cstr(arr):\n    \"\"\" Serializes a numpy array to a compressed base64 string \"\"\"\n    out = StringIO()\n    np.save(out, arr)\n    return b64encode(out.getvalue())", "code_tokens": "def _array2cstr ( arr ) : out = StringIO ( ) np . save ( out , arr ) return b64encode ( out . getvalue ( ) )", "docstring_tokens": "Serializes a numpy array to a compressed base64 string", "label": 0}, {"idx": "cosqa-train-3770", "doc": "python3 flask static js", "code": "def default_static_path():\n    \"\"\"\n        Return the path to the javascript bundle\n    \"\"\"\n    fdir = os.path.dirname(__file__)\n    return os.path.abspath(os.path.join(fdir, '../assets/'))", "code_tokens": "def default_static_path ( ) : fdir = os . path . dirname ( __file__ ) return os . path . abspath ( os . path . join ( fdir , '../assets/' ) )", "docstring_tokens": "Return the path to the javascript bundle", "label": 0}, {"idx": "cosqa-train-3771", "doc": "no attribute 'capitalize' python", "code": "def list_add_capitalize(l):\n    \"\"\"\n    @type l: list\n    @return: list\n    \"\"\"\n    nl = []\n\n    for i in l:\n        nl.append(i)\n\n        if hasattr(i, \"capitalize\"):\n            nl.append(i.capitalize())\n\n    return list(set(nl))", "code_tokens": "def list_add_capitalize ( l ) : nl = [ ] for i in l : nl . append ( i ) if hasattr ( i , \"capitalize\" ) : nl . append ( i . capitalize ( ) ) return list ( set ( nl ) )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-3772", "doc": "python3 genrator random int with specific length", "code": "def random_id(size=8, chars=string.ascii_letters + string.digits):\n\t\"\"\"Generates a random string of given size from the given chars.\n\n\t@param size:  The size of the random string.\n\t@param chars: Constituent pool of characters to draw random characters from.\n\t@type size:   number\n\t@type chars:  string\n\t@rtype:       string\n\t@return:      The string of random characters.\n\t\"\"\"\n\treturn ''.join(random.choice(chars) for _ in range(size))", "code_tokens": "def random_id ( size = 8 , chars = string . ascii_letters + string . digits ) : return '' . join ( random . choice ( chars ) for _ in range ( size ) )", "docstring_tokens": "Generates a random string of given size from the given chars .", "label": 0}, {"idx": "cosqa-train-3773", "doc": "normal distribution 0,1 in python", "code": "def ln_norm(x, mu, sigma=1.0):\n    \"\"\" Natural log of scipy norm function truncated at zero \"\"\"\n    return np.log(stats.norm(loc=mu, scale=sigma).pdf(x))", "code_tokens": "def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )", "docstring_tokens": "Natural log of scipy norm function truncated at zero", "label": 0}, {"idx": "cosqa-train-3774", "doc": "python3 get current thread id", "code": "def threadid(self):\n        \"\"\"\n        Current thread ident. If current thread is main thread then it returns ``None``.\n\n        :type: int or None\n        \"\"\"\n        current = self.thread.ident\n        main = get_main_thread()\n        if main is None:\n            return current\n        else:\n            return current if current != main.ident else None", "code_tokens": "def threadid ( self ) : current = self . thread . ident main = get_main_thread ( ) if main is None : return current else : return current if current != main . ident else None", "docstring_tokens": "Current thread ident . If current thread is main thread then it returns None .", "label": 0}, {"idx": "cosqa-train-3775", "doc": "normal distribution between 0 and 1 python", "code": "def ln_norm(x, mu, sigma=1.0):\n    \"\"\" Natural log of scipy norm function truncated at zero \"\"\"\n    return np.log(stats.norm(loc=mu, scale=sigma).pdf(x))", "code_tokens": "def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )", "docstring_tokens": "Natural log of scipy norm function truncated at zero", "label": 0}, {"idx": "cosqa-train-3776", "doc": "python3 has no attribute 'setdefaultencoding'", "code": "def get_best_encoding(stream):\n    \"\"\"Returns the default stream encoding if not found.\"\"\"\n    rv = getattr(stream, 'encoding', None) or sys.getdefaultencoding()\n    if is_ascii_encoding(rv):\n        return 'utf-8'\n    return rv", "code_tokens": "def get_best_encoding ( stream ) : rv = getattr ( stream , 'encoding' , None ) or sys . getdefaultencoding ( ) if is_ascii_encoding ( rv ) : return 'utf-8' return rv", "docstring_tokens": "Returns the default stream encoding if not found .", "label": 0}, {"idx": "cosqa-train-3777", "doc": "normalise each row of matrix in python", "code": "def normalize(X):\n    \"\"\" equivalent to scipy.preprocessing.normalize on sparse matrices\n    , but lets avoid another depedency just for a small utility function \"\"\"\n    X = coo_matrix(X)\n    X.data = X.data / sqrt(bincount(X.row, X.data ** 2))[X.row]\n    return X", "code_tokens": "def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X", "docstring_tokens": "equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function", "label": 0}, {"idx": "cosqa-train-3778", "doc": "python3 how to check root permission", "code": "def require_root(fn):\n    \"\"\"\n    Decorator to make sure, that user is root.\n    \"\"\"\n    @wraps(fn)\n    def xex(*args, **kwargs):\n        assert os.geteuid() == 0, \\\n            \"You have to be root to run function '%s'.\" % fn.__name__\n        return fn(*args, **kwargs)\n\n    return xex", "code_tokens": "def require_root ( fn ) : @ wraps ( fn ) def xex ( * args , * * kwargs ) : assert os . geteuid ( ) == 0 , \"You have to be root to run function '%s'.\" % fn . __name__ return fn ( * args , * * kwargs ) return xex", "docstring_tokens": "Decorator to make sure that user is root .", "label": 0}, {"idx": "cosqa-train-3779", "doc": "python3 measure memory of an object", "code": "def m(name='', **kwargs):\n    \"\"\"\n    Print out memory usage at this point in time\n\n    http://docs.python.org/2/library/resource.html\n    http://stackoverflow.com/a/15448600/5006\n    http://stackoverflow.com/questions/110259/which-python-memory-profiler-is-recommended\n    \"\"\"\n    with Reflect.context(**kwargs) as r:\n        kwargs[\"name\"] = name\n        instance = M_CLASS(r, stream, **kwargs)\n        instance()", "code_tokens": "def m ( name = '' , * * kwargs ) : with Reflect . context ( * * kwargs ) as r : kwargs [ \"name\" ] = name instance = M_CLASS ( r , stream , * * kwargs ) instance ( )", "docstring_tokens": "Print out memory usage at this point in time", "label": 0}, {"idx": "cosqa-train-3780", "doc": "normalize data from datafram python", "code": "def normalize(df, style = 'mean'):\n    \"\"\" Returns a normalized version of a DataFrame or Series\n    Parameters:\n    df - DataFrame or Series\n        The data to normalize\n    style - function or string, default 'mean'\n        The style to use when computing the norms. Takes 'mean' or 'minmax' to\n        do mean or min-max normalization respectively. User-defined functions that take\n        a pandas Series as input and return a normalized pandas Series are also accepted\n    \"\"\"\n    if style == 'mean':\n        df_mean,df_std = df.mean(),df.std()\n        return (df-df_mean)/df_std\n    elif style == 'minmax':\n        col_min,col_max = df.min(),df.max()\n        return (df-col_min)/(col_max-col_min)\n    else:\n        return style(df)", "code_tokens": "def normalize ( df , style = 'mean' ) : if style == 'mean' : df_mean , df_std = df . mean ( ) , df . std ( ) return ( df - df_mean ) / df_std elif style == 'minmax' : col_min , col_max = df . min ( ) , df . max ( ) return ( df - col_min ) / ( col_max - col_min ) else : return style ( df )", "docstring_tokens": "Returns a normalized version of a DataFrame or Series Parameters : df - DataFrame or Series The data to normalize style - function or string default mean The style to use when computing the norms . Takes mean or minmax to do mean or min - max normalization respectively . User - defined functions that take a pandas Series as input and return a normalized pandas Series are also accepted", "label": 0}, {"idx": "cosqa-train-3781", "doc": "python3 must construct a qapplication before a qwidget", "code": "def get_qapp():\n    \"\"\"Return an instance of QApplication. Creates one if neccessary.\n\n    :returns: a QApplication instance\n    :rtype: QApplication\n    :raises: None\n    \"\"\"\n    global app\n    app = QtGui.QApplication.instance()\n    if app is None:\n        app = QtGui.QApplication([], QtGui.QApplication.GuiClient)\n    return app", "code_tokens": "def get_qapp ( ) : global app app = QtGui . QApplication . instance ( ) if app is None : app = QtGui . QApplication ( [ ] , QtGui . QApplication . GuiClient ) return app", "docstring_tokens": "Return an instance of QApplication . Creates one if neccessary .", "label": 0}, {"idx": "cosqa-train-3782", "doc": "normalize the array columnwise python", "code": "def normalize(X):\n    \"\"\" equivalent to scipy.preprocessing.normalize on sparse matrices\n    , but lets avoid another depedency just for a small utility function \"\"\"\n    X = coo_matrix(X)\n    X.data = X.data / sqrt(bincount(X.row, X.data ** 2))[X.row]\n    return X", "code_tokens": "def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X", "docstring_tokens": "equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function", "label": 0}, {"idx": "cosqa-train-3783", "doc": "python3 pymysql column name", "code": "def column_names(self, table):\n      \"\"\"An iterable of column names, for a particular table or\n      view.\"\"\"\n\n      table_info = self.execute(\n        u'PRAGMA table_info(%s)' % quote(table))\n      return (column['name'] for column in table_info)", "code_tokens": "def column_names ( self , table ) : table_info = self . execute ( u'PRAGMA table_info(%s)' % quote ( table ) ) return ( column [ 'name' ] for column in table_info )", "docstring_tokens": "An iterable of column names for a particular table or view .", "label": 1}, {"idx": "cosqa-train-3784", "doc": "normalized one dimentional array in python", "code": "def _normalize_abmn(abmn):\n    \"\"\"return a normalized version of abmn\n    \"\"\"\n    abmn_2d = np.atleast_2d(abmn)\n    abmn_normalized = np.hstack((\n        np.sort(abmn_2d[:, 0:2], axis=1),\n        np.sort(abmn_2d[:, 2:4], axis=1),\n    ))\n    return abmn_normalized", "code_tokens": "def _normalize_abmn ( abmn ) : abmn_2d = np . atleast_2d ( abmn ) abmn_normalized = np . hstack ( ( np . sort ( abmn_2d [ : , 0 : 2 ] , axis = 1 ) , np . sort ( abmn_2d [ : , 2 : 4 ] , axis = 1 ) , ) ) return abmn_normalized", "docstring_tokens": "return a normalized version of abmn", "label": 0}, {"idx": "cosqa-train-3785", "doc": "python3 stdin read bytes line by line", "code": "def get_iter_string_reader(stdin):\n    \"\"\" return an iterator that returns a chunk of a string every time it is\n    called.  notice that even though bufsize_type might be line buffered, we're\n    not doing any line buffering here.  that's because our StreamBufferer\n    handles all buffering.  we just need to return a reasonable-sized chunk. \"\"\"\n    bufsize = 1024\n    iter_str = (stdin[i:i + bufsize] for i in range(0, len(stdin), bufsize))\n    return get_iter_chunk_reader(iter_str)", "code_tokens": "def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )", "docstring_tokens": "return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk .", "label": 1}, {"idx": "cosqa-train-3786", "doc": "number of non white space characters python", "code": "def _count_leading_whitespace(text):\n  \"\"\"Returns the number of characters at the beginning of text that are whitespace.\"\"\"\n  idx = 0\n  for idx, char in enumerate(text):\n    if not char.isspace():\n      return idx\n  return idx + 1", "code_tokens": "def _count_leading_whitespace ( text ) : idx = 0 for idx , char in enumerate ( text ) : if not char . isspace ( ) : return idx return idx + 1", "docstring_tokens": "Returns the number of characters at the beginning of text that are whitespace .", "label": 1}, {"idx": "cosqa-train-3787", "doc": "python3 str object not callable", "code": "def __str__(self):\n        \"\"\"Executes self.function to convert LazyString instance to a real\n        str.\"\"\"\n        if not hasattr(self, '_str'):\n            self._str=self.function(*self.args, **self.kwargs)\n        return self._str", "code_tokens": "def __str__ ( self ) : if not hasattr ( self , '_str' ) : self . _str = self . function ( * self . args , * * self . kwargs ) return self . _str", "docstring_tokens": "Executes self . function to convert LazyString instance to a real str .", "label": 0}, {"idx": "cosqa-train-3788", "doc": "number of objects in python", "code": "def get_size(objects):\n    \"\"\"Compute the total size of all elements in objects.\"\"\"\n    res = 0\n    for o in objects:\n        try:\n            res += _getsizeof(o)\n        except AttributeError:\n            print(\"IGNORING: type=%s; o=%s\" % (str(type(o)), str(o)))\n    return res", "code_tokens": "def get_size ( objects ) : res = 0 for o in objects : try : res += _getsizeof ( o ) except AttributeError : print ( \"IGNORING: type=%s; o=%s\" % ( str ( type ( o ) ) , str ( o ) ) ) return res", "docstring_tokens": "Compute the total size of all elements in objects .", "label": 0}, {"idx": "cosqa-train-3789", "doc": "python3 string default encoding", "code": "def to_string(s, encoding='utf-8'):\n    \"\"\"\n    Accept unicode(py2) or bytes(py3)\n\n    Returns:\n        py2 type: str\n        py3 type: str\n    \"\"\"\n    if six.PY2:\n        return s.encode(encoding)\n    if isinstance(s, bytes):\n        return s.decode(encoding)\n    return s", "code_tokens": "def to_string ( s , encoding = 'utf-8' ) : if six . PY2 : return s . encode ( encoding ) if isinstance ( s , bytes ) : return s . decode ( encoding ) return s", "docstring_tokens": "Accept unicode ( py2 ) or bytes ( py3 )", "label": 0}, {"idx": "cosqa-train-3790", "doc": "python3 string to bytes encode decode", "code": "def to_bytes(value):\n    \"\"\" str to bytes (py3k) \"\"\"\n    vtype = type(value)\n\n    if vtype == bytes or vtype == type(None):\n        return value\n\n    try:\n        return vtype.encode(value)\n    except UnicodeEncodeError:\n        pass\n    return value", "code_tokens": "def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value", "docstring_tokens": "str to bytes ( py3k )", "label": 1}, {"idx": "cosqa-train-3791", "doc": "pythonic way to create a multiline string", "code": "def format_line(data, linestyle):\n    \"\"\"Formats a list of elements using the given line style\"\"\"\n    return linestyle.begin + linestyle.sep.join(data) + linestyle.end", "code_tokens": "def format_line ( data , linestyle ) : return linestyle . begin + linestyle . sep . join ( data ) + linestyle . end", "docstring_tokens": "Formats a list of elements using the given line style", "label": 0}, {"idx": "cosqa-train-3792", "doc": "oauth2 to access twitter python", "code": "def get_tweepy_auth(twitter_api_key,\n                    twitter_api_secret,\n                    twitter_access_token,\n                    twitter_access_token_secret):\n    \"\"\"Make a tweepy auth object\"\"\"\n    auth = tweepy.OAuthHandler(twitter_api_key, twitter_api_secret)\n    auth.set_access_token(twitter_access_token, twitter_access_token_secret)\n    return auth", "code_tokens": "def get_tweepy_auth ( twitter_api_key , twitter_api_secret , twitter_access_token , twitter_access_token_secret ) : auth = tweepy . OAuthHandler ( twitter_api_key , twitter_api_secret ) auth . set_access_token ( twitter_access_token , twitter_access_token_secret ) return auth", "docstring_tokens": "Make a tweepy auth object", "label": 0}, {"idx": "cosqa-train-3793", "doc": "query string contents python", "code": "def urlencoded(body, charset='ascii', **kwargs):\n    \"\"\"Converts query strings into native Python objects\"\"\"\n    return parse_query_string(text(body, charset=charset), False)", "code_tokens": "def urlencoded ( body , charset = 'ascii' , * * kwargs ) : return parse_query_string ( text ( body , charset = charset ) , False )", "docstring_tokens": "Converts query strings into native Python objects", "label": 0}, {"idx": "cosqa-train-3794", "doc": "online python to html5 convuter", "code": "def aloha_to_html(html_source):\n    \"\"\"Converts HTML5 from Aloha to a more structured HTML5\"\"\"\n    xml = aloha_to_etree(html_source)\n    return etree.tostring(xml, pretty_print=True)", "code_tokens": "def aloha_to_html ( html_source ) : xml = aloha_to_etree ( html_source ) return etree . tostring ( xml , pretty_print = True )", "docstring_tokens": "Converts HTML5 from Aloha to a more structured HTML5", "label": 0}, {"idx": "cosqa-train-3795", "doc": "quit interactive mode python", "code": "def exit(self):\n        \"\"\"Handle interactive exit.\n\n        This method calls the ask_exit callback.\"\"\"\n        if self.confirm_exit:\n            if self.ask_yes_no('Do you really want to exit ([y]/n)?','y'):\n                self.ask_exit()\n        else:\n            self.ask_exit()", "code_tokens": "def exit ( self ) : if self . confirm_exit : if self . ask_yes_no ( 'Do you really want to exit ([y]/n)?' , 'y' ) : self . ask_exit ( ) else : self . ask_exit ( )", "docstring_tokens": "Handle interactive exit .", "label": 0}, {"idx": "cosqa-train-3796", "doc": "only accept certain input python 3", "code": "def _stdin_(p):\n    \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"\n    _v = sys.version[0]\n    return input(p) if _v is '3' else raw_input(p)", "code_tokens": "def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "docstring_tokens": "Takes input from user . Works for Python 2 and 3 .", "label": 0}, {"idx": "cosqa-train-3797", "doc": "quitting the existing python session", "code": "def __del__(self):\n        \"\"\"Cleanup the session if it was created here\"\"\"\n        if self._cleanup_session:\n            self._session.loop.run_until_complete(self._session.close())", "code_tokens": "def __del__ ( self ) : if self . _cleanup_session : self . _session . loop . run_until_complete ( self . _session . close ( ) )", "docstring_tokens": "Cleanup the session if it was created here", "label": 0}, {"idx": "cosqa-train-3798", "doc": "only get hours minutes and seconds datetime python", "code": "def get_just_date(self):\n        \"\"\"Parses just date from date-time\n\n        :return: Just day, month and year (setting hours to 00:00:00)\n        \"\"\"\n        return datetime.datetime(\n            self.date_time.year,\n            self.date_time.month,\n            self.date_time.day\n        )", "code_tokens": "def get_just_date ( self ) : return datetime . datetime ( self . date_time . year , self . date_time . month , self . date_time . day )", "docstring_tokens": "Parses just date from date - time", "label": 0}, {"idx": "cosqa-train-3799", "doc": "r prexfix in python strings", "code": "def format_screen(strng):\n    \"\"\"Format a string for screen printing.\n\n    This removes some latex-type format codes.\"\"\"\n    # Paragraph continue\n    par_re = re.compile(r'\\\\$',re.MULTILINE)\n    strng = par_re.sub('',strng)\n    return strng", "code_tokens": "def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng", "docstring_tokens": "Format a string for screen printing .", "label": 0}, {"idx": "cosqa-train-3800", "doc": "open a file with specified character encoding python", "code": "def open_with_encoding(filename, encoding, mode='r'):\n    \"\"\"Return opened file with a specific encoding.\"\"\"\n    return io.open(filename, mode=mode, encoding=encoding,\n                   newline='')", "code_tokens": "def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )", "docstring_tokens": "Return opened file with a specific encoding .", "label": 0}, {"idx": "cosqa-train-3801", "doc": "random lower case letter python", "code": "def to_camel_case(snake_case_name):\n    \"\"\"\n    Converts snake_cased_names to CamelCaseNames.\n\n    :param snake_case_name: The name you'd like to convert from.\n    :type snake_case_name: string\n\n    :returns: A converted string\n    :rtype: string\n    \"\"\"\n    bits = snake_case_name.split('_')\n    return ''.join([bit.capitalize() for bit in bits])", "code_tokens": "def to_camel_case ( snake_case_name ) : bits = snake_case_name . split ( '_' ) return '' . join ( [ bit . capitalize ( ) for bit in bits ] )", "docstring_tokens": "Converts snake_cased_names to CamelCaseNames .", "label": 0}, {"idx": "cosqa-train-3802", "doc": "open image from image path in python", "code": "def load_image(fname):\n    \"\"\" read an image from file - PIL doesnt close nicely \"\"\"\n    with open(fname, \"rb\") as f:\n        i = Image.open(fname)\n        #i.load()\n        return i", "code_tokens": "def load_image ( fname ) : with open ( fname , \"rb\" ) as f : i = Image . open ( fname ) #i.load() return i", "docstring_tokens": "read an image from file - PIL doesnt close nicely", "label": 1}, {"idx": "cosqa-train-3803", "doc": "random pick in set python", "code": "def random_choice(sequence):\n    \"\"\" Same as :meth:`random.choice`, but also supports :class:`set` type to be passed as sequence. \"\"\"\n    return random.choice(tuple(sequence) if isinstance(sequence, set) else sequence)", "code_tokens": "def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )", "docstring_tokens": "Same as : meth : random . choice but also supports : class : set type to be passed as sequence .", "label": 1}, {"idx": "cosqa-train-3804", "doc": "open serial port windows python", "code": "def do_serial(self, p):\n\t\t\"\"\"Set the serial port, e.g.: /dev/tty.usbserial-A4001ib8\"\"\"\n\t\ttry:\n\t\t\tself.serial.port = p\n\t\t\tself.serial.open()\n\t\t\tprint 'Opening serial port: %s' % p\n\t\texcept Exception, e:\n\t\t\tprint 'Unable to open serial port: %s' % p", "code_tokens": "def do_serial ( self , p ) : try : self . serial . port = p self . serial . open ( ) print 'Opening serial port: %s' % p except Exception , e : print 'Unable to open serial port: %s' % p", "docstring_tokens": "Set the serial port e . g . : / dev / tty . usbserial - A4001ib8", "label": 0}, {"idx": "cosqa-train-3805", "doc": "range of array python last index", "code": "def other_ind(self):\n        \"\"\"last row or column of square A\"\"\"\n        return np.full(self.n_min, self.size - 1, dtype=np.int)", "code_tokens": "def other_ind ( self ) : return np . full ( self . n_min , self . size - 1 , dtype = np . int )", "docstring_tokens": "last row or column of square A", "label": 0}, {"idx": "cosqa-train-3806", "doc": "opencv python normalize intensity of 2d image", "code": "def min_max_normalize(img):\n    \"\"\"Centre and normalize a given array.\n\n    Parameters:\n    ----------\n    img: np.ndarray\n\n    \"\"\"\n\n    min_img = img.min()\n    max_img = img.max()\n\n    return (img - min_img) / (max_img - min_img)", "code_tokens": "def min_max_normalize ( img ) : min_img = img . min ( ) max_img = img . max ( ) return ( img - min_img ) / ( max_img - min_img )", "docstring_tokens": "Centre and normalize a given array .", "label": 0}, {"idx": "cosqa-train-3807", "doc": "rdd custom reducebykey function python", "code": "def __getitem__(self, key):\n        \"\"\"Returns a new PRDD of elements from that key.\"\"\"\n        return self.from_rdd(self._rdd.map(lambda x: x[key]))", "code_tokens": "def __getitem__ ( self , key ) : return self . from_rdd ( self . _rdd . map ( lambda x : x [ key ] ) )", "docstring_tokens": "Returns a new PRDD of elements from that key .", "label": 0}, {"idx": "cosqa-train-3808", "doc": "opencv python normalize intensity of imageon", "code": "def min_max_normalize(img):\n    \"\"\"Centre and normalize a given array.\n\n    Parameters:\n    ----------\n    img: np.ndarray\n\n    \"\"\"\n\n    min_img = img.min()\n    max_img = img.max()\n\n    return (img - min_img) / (max_img - min_img)", "code_tokens": "def min_max_normalize ( img ) : min_img = img . min ( ) max_img = img . max ( ) return ( img - min_img ) / ( max_img - min_img )", "docstring_tokens": "Centre and normalize a given array .", "label": 0}, {"idx": "cosqa-train-3809", "doc": "read a file and encode to base64 python", "code": "def load_file_to_base64_str(f_path):\n    \"\"\"Loads the content of a file into a base64 string.\n\n    Args:\n        f_path: full path to the file including the file name.\n\n    Returns:\n        A base64 string representing the content of the file in utf-8 encoding.\n    \"\"\"\n    path = abs_path(f_path)\n    with io.open(path, 'rb') as f:\n        f_bytes = f.read()\n        base64_str = base64.b64encode(f_bytes).decode(\"utf-8\")\n        return base64_str", "code_tokens": "def load_file_to_base64_str ( f_path ) : path = abs_path ( f_path ) with io . open ( path , 'rb' ) as f : f_bytes = f . read ( ) base64_str = base64 . b64encode ( f_bytes ) . decode ( \"utf-8\" ) return base64_str", "docstring_tokens": "Loads the content of a file into a base64 string .", "label": 0}, {"idx": "cosqa-train-3810", "doc": "opencv python read image from url", "code": "def url_to_image(url, flag=cv2.IMREAD_COLOR):\n    \"\"\" download the image, convert it to a NumPy array, and then read\n    it into OpenCV format \"\"\"\n    resp = urlopen(url)\n    image = np.asarray(bytearray(resp.read()), dtype=\"uint8\")\n    image = cv2.imdecode(image, flag)\n    return image", "code_tokens": "def url_to_image ( url , flag = cv2 . IMREAD_COLOR ) : resp = urlopen ( url ) image = np . asarray ( bytearray ( resp . read ( ) ) , dtype = \"uint8\" ) image = cv2 . imdecode ( image , flag ) return image", "docstring_tokens": "download the image convert it to a NumPy array and then read it into OpenCV format", "label": 0}, {"idx": "cosqa-train-3811", "doc": "read area of screen in python", "code": "def visible_area(self):\n        \"\"\"\n        Calculated like in the official client.\n        Returns (top_left, bottom_right).\n        \"\"\"\n        # looks like zeach has a nice big screen\n        half_viewport = Vec(1920, 1080) / 2 / self.scale\n        top_left = self.world.center - half_viewport\n        bottom_right = self.world.center + half_viewport\n        return top_left, bottom_right", "code_tokens": "def visible_area ( self ) : # looks like zeach has a nice big screen half_viewport = Vec ( 1920 , 1080 ) / 2 / self . scale top_left = self . world . center - half_viewport bottom_right = self . world . center + half_viewport return top_left , bottom_right", "docstring_tokens": "Calculated like in the official client . Returns ( top_left bottom_right ) .", "label": 0}, {"idx": "cosqa-train-3812", "doc": "opencv rotate image python 90 degree", "code": "def rotate_img(im, deg, mode=cv2.BORDER_CONSTANT, interpolation=cv2.INTER_AREA):\n    \"\"\" Rotates an image by deg degrees\n\n    Arguments:\n        deg (float): degree to rotate.\n    \"\"\"\n    r,c,*_ = im.shape\n    M = cv2.getRotationMatrix2D((c//2,r//2),deg,1)\n    return cv2.warpAffine(im,M,(c,r), borderMode=mode, flags=cv2.WARP_FILL_OUTLIERS+interpolation)", "code_tokens": "def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )", "docstring_tokens": "Rotates an image by deg degrees", "label": 1}, {"idx": "cosqa-train-3813", "doc": "read from a file using numpy in python 3", "code": "def read_numpy(fd, byte_order, dtype, count):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    return numpy.fromfile(fd, byte_order+dtype[-1], count)", "code_tokens": "def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 0}, {"idx": "cosqa-train-3814", "doc": "read from text file python username and password", "code": "def read_credentials(fname):\n    \"\"\"\n    read a simple text file from a private location to get\n    username and password\n    \"\"\"\n    with open(fname, 'r') as f:\n        username = f.readline().strip('\\n')\n        password = f.readline().strip('\\n')\n    return username, password", "code_tokens": "def read_credentials ( fname ) : with open ( fname , 'r' ) as f : username = f . readline ( ) . strip ( '\\n' ) password = f . readline ( ) . strip ( '\\n' ) return username , password", "docstring_tokens": "read a simple text file from a private location to get username and password", "label": 0}, {"idx": "cosqa-train-3815", "doc": "optimize gaussian from curve fit python", "code": "def fit_gaussian(x, y, yerr, p0):\n    \"\"\" Fit a Gaussian to the data \"\"\"\n    try:\n        popt, pcov = curve_fit(gaussian, x, y, sigma=yerr, p0=p0, absolute_sigma=True)\n    except RuntimeError:\n        return [0],[0]\n    return popt, pcov", "code_tokens": "def fit_gaussian ( x , y , yerr , p0 ) : try : popt , pcov = curve_fit ( gaussian , x , y , sigma = yerr , p0 = p0 , absolute_sigma = True ) except RuntimeError : return [ 0 ] , [ 0 ] return popt , pcov", "docstring_tokens": "Fit a Gaussian to the data", "label": 0}, {"idx": "cosqa-train-3816", "doc": "read last line of the file in python", "code": "def last(self):\n        \"\"\"Get the last object in file.\"\"\"\n        # End of file\n        self.__file.seek(0, 2)\n\n        # Get the last struct\n        data = self.get(self.length - 1)\n\n        return data", "code_tokens": "def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data", "docstring_tokens": "Get the last object in file .", "label": 0}, {"idx": "cosqa-train-3817", "doc": "padding image into a fix size python", "code": "def resize_image_with_crop_or_pad(img, target_height, target_width):\n    \"\"\"\n    Crops and/or pads an image to a target width and height.\n\n    Resizes an image to a target width and height by either cropping the image or padding it with zeros.\n\n    NO CENTER CROP. NO CENTER PAD. (Just fill bottom right or crop bottom right)\n\n    :param img: Numpy array representing the image.\n    :param target_height: Target height.\n    :param target_width: Target width.\n    :return: The cropped and padded image.\n    \"\"\"\n    h, w = target_height, target_width\n    max_h, max_w, c = img.shape\n\n    # crop\n    img = crop_center(img, min(max_h, h), min(max_w, w))\n\n    # pad\n    padded_img = np.zeros(shape=(h, w, c), dtype=img.dtype)\n    padded_img[:img.shape[0], :img.shape[1], :img.shape[2]] = img\n\n    return padded_img", "code_tokens": "def resize_image_with_crop_or_pad ( img , target_height , target_width ) : h , w = target_height , target_width max_h , max_w , c = img . shape # crop img = crop_center ( img , min ( max_h , h ) , min ( max_w , w ) ) # pad padded_img = np . zeros ( shape = ( h , w , c ) , dtype = img . dtype ) padded_img [ : img . shape [ 0 ] , : img . shape [ 1 ] , : img . shape [ 2 ] ] = img return padded_img", "docstring_tokens": "Crops and / or pads an image to a target width and height .", "label": 0}, {"idx": "cosqa-train-3818", "doc": "read multiple json objects from a json file python", "code": "def load_from_file(cls, file_path: str):\n        \"\"\" Read and reconstruct the data from a JSON file. \"\"\"\n        with open(file_path, \"r\") as f:\n            data = json.load(f)\n            item = cls.decode(data=data)\n        return item", "code_tokens": "def load_from_file ( cls , file_path : str ) : with open ( file_path , \"r\" ) as f : data = json . load ( f ) item = cls . decode ( data = data ) return item", "docstring_tokens": "Read and reconstruct the data from a JSON file .", "label": 0}, {"idx": "cosqa-train-3819", "doc": "padding image on all sides python", "code": "def __call__(self, img):\n        \"\"\"\n        Args:\n            img (PIL Image): Image to be padded.\n\n        Returns:\n            PIL Image: Padded image.\n        \"\"\"\n        return F.pad(img, self.padding, self.fill, self.padding_mode)", "code_tokens": "def __call__ ( self , img ) : return F . pad ( img , self . padding , self . fill , self . padding_mode )", "docstring_tokens": "Args : img ( PIL Image ) : Image to be padded .", "label": 0}, {"idx": "cosqa-train-3820", "doc": "read not advancing to next character python", "code": "def rAsciiLine(ifile):\n    \"\"\"Returns the next non-blank line in an ASCII file.\"\"\"\n\n    _line = ifile.readline().strip()\n    while len(_line) == 0:\n        _line = ifile.readline().strip()\n    return _line", "code_tokens": "def rAsciiLine ( ifile ) : _line = ifile . readline ( ) . strip ( ) while len ( _line ) == 0 : _line = ifile . readline ( ) . strip ( ) return _line", "docstring_tokens": "Returns the next non - blank line in an ASCII file .", "label": 0}, {"idx": "cosqa-train-3821", "doc": "parsing sql queries with python", "code": "def filter_query(s):\n    \"\"\"\n    Filters given query with the below regex\n    and returns lists of quoted and unquoted strings\n    \"\"\"\n    matches = re.findall(r'(?:\"([^\"]*)\")|([^\"]*)', s)\n    result_quoted = [t[0].strip() for t in matches if t[0]]\n    result_unquoted = [t[1].strip() for t in matches if t[1]]\n    return result_quoted, result_unquoted", "code_tokens": "def filter_query ( s ) : matches = re . findall ( r'(?:\"([^\"]*)\")|([^\"]*)' , s ) result_quoted = [ t [ 0 ] . strip ( ) for t in matches if t [ 0 ] ] result_unquoted = [ t [ 1 ] . strip ( ) for t in matches if t [ 1 ] ] return result_quoted , result_unquoted", "docstring_tokens": "Filters given query with the below regex and returns lists of quoted and unquoted strings", "label": 0}, {"idx": "cosqa-train-3822", "doc": "read text file using lambda python", "code": "def lambda_from_file(python_file):\n    \"\"\"\n    Reads a python file and returns a awslambda.Code object\n    :param python_file:\n    :return:\n    \"\"\"\n    lambda_function = []\n    with open(python_file, 'r') as f:\n        lambda_function.extend(f.read().splitlines())\n\n    return awslambda.Code(ZipFile=(Join('\\n', lambda_function)))", "code_tokens": "def lambda_from_file ( python_file ) : lambda_function = [ ] with open ( python_file , 'r' ) as f : lambda_function . extend ( f . read ( ) . splitlines ( ) ) return awslambda . Code ( ZipFile = ( Join ( '\\n' , lambda_function ) ) )", "docstring_tokens": "Reads a python file and returns a awslambda . Code object : param python_file : : return :", "label": 0}, {"idx": "cosqa-train-3823", "doc": "pass a list to format python", "code": "def list_formatter(handler, item, value):\n    \"\"\"Format list.\"\"\"\n    return u', '.join(str(v) for v in value)", "code_tokens": "def list_formatter ( handler , item , value ) : return u', ' . join ( str ( v ) for v in value )", "docstring_tokens": "Format list .", "label": 0}, {"idx": "cosqa-train-3824", "doc": "read until end of file in python", "code": "def eof(fd):\n    \"\"\"Determine if end-of-file is reached for file fd.\"\"\"\n    b = fd.read(1)\n    end = len(b) == 0\n    if not end:\n        curpos = fd.tell()\n        fd.seek(curpos - 1)\n    return end", "code_tokens": "def eof ( fd ) : b = fd . read ( 1 ) end = len ( b ) == 0 if not end : curpos = fd . tell ( ) fd . seek ( curpos - 1 ) return end", "docstring_tokens": "Determine if end - of - file is reached for file fd .", "label": 0}, {"idx": "cosqa-train-3825", "doc": "pass python instance method to a function", "code": "def Proxy(f):\n  \"\"\"A helper to create a proxy method in a class.\"\"\"\n\n  def Wrapped(self, *args):\n    return getattr(self, f)(*args)\n\n  return Wrapped", "code_tokens": "def Proxy ( f ) : def Wrapped ( self , * args ) : return getattr ( self , f ) ( * args ) return Wrapped", "docstring_tokens": "A helper to create a proxy method in a class .", "label": 0}, {"idx": "cosqa-train-3826", "doc": "read very small numbers in 16bit python", "code": "def read_large_int(self, bits, signed=True):\n        \"\"\"Reads a n-bits long integer value.\"\"\"\n        return int.from_bytes(\n            self.read(bits // 8), byteorder='little', signed=signed)", "code_tokens": "def read_large_int ( self , bits , signed = True ) : return int . from_bytes ( self . read ( bits // 8 ) , byteorder = 'little' , signed = signed )", "docstring_tokens": "Reads a n - bits long integer value .", "label": 0}, {"idx": "cosqa-train-3827", "doc": "passing a default in python", "code": "def arg_default(*args, **kwargs):\n    \"\"\"Return default argument value as given by argparse's add_argument().\n\n    The argument is passed through a mocked-up argument parser. This way, we\n    get default parameters even if the feature is called directly and not\n    through the CLI.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(*args, **kwargs)\n    args = vars(parser.parse_args([]))\n    _, default = args.popitem()\n    return default", "code_tokens": "def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default", "docstring_tokens": "Return default argument value as given by argparse s add_argument () .", "label": 0}, {"idx": "cosqa-train-3828", "doc": "read wave files python", "code": "def readwav(filename):\n    \"\"\"Read a WAV file and returns the data and sample rate\n\n    ::\n\n        from spectrum.io import readwav\n        readwav()\n\n    \"\"\"\n    from scipy.io.wavfile import read as readwav\n    samplerate, signal = readwav(filename)\n    return signal, samplerate", "code_tokens": "def readwav ( filename ) : from scipy . io . wavfile import read as readwav samplerate , signal = readwav ( filename ) return signal , samplerate", "docstring_tokens": "Read a WAV file and returns the data and sample rate", "label": 0}, {"idx": "cosqa-train-3829", "doc": "passing post data from a form template in python flask", "code": "def parse_form(self, req, name, field):\n        \"\"\"Pull a form value from the request.\"\"\"\n        return get_value(req.body_arguments, name, field)", "code_tokens": "def parse_form ( self , req , name , field ) : return get_value ( req . body_arguments , name , field )", "docstring_tokens": "Pull a form value from the request .", "label": 0}, {"idx": "cosqa-train-3830", "doc": "reading a specified amount of bytes from a file python", "code": "def get_starting_chunk(filename, length=1024):\n    \"\"\"\n    :param filename: File to open and get the first little chunk of.\n    :param length: Number of bytes to read, default 1024.\n    :returns: Starting chunk of bytes.\n    \"\"\"\n    # Ensure we open the file in binary mode\n    with open(filename, 'rb') as f:\n        chunk = f.read(length)\n        return chunk", "code_tokens": "def get_starting_chunk ( filename , length = 1024 ) : # Ensure we open the file in binary mode with open ( filename , 'rb' ) as f : chunk = f . read ( length ) return chunk", "docstring_tokens": ": param filename : File to open and get the first little chunk of . : param length : Number of bytes to read default 1024 . : returns : Starting chunk of bytes .", "label": 0}, {"idx": "cosqa-train-3831", "doc": "password checking in python using regular expression", "code": "def is_password_valid(password):\n    \"\"\"\n    Check if a password is valid\n    \"\"\"\n    pattern = re.compile(r\"^.{4,75}$\")\n    return bool(pattern.match(password))", "code_tokens": "def is_password_valid ( password ) : pattern = re . compile ( r\"^.{4,75}$\" ) return bool ( pattern . match ( password ) )", "docstring_tokens": "Check if a password is valid", "label": 0}, {"idx": "cosqa-train-3832", "doc": "reading a text from stdin in python", "code": "def standard_input():\n    \"\"\"Generator that yields lines from standard input.\"\"\"\n    with click.get_text_stream(\"stdin\") as stdin:\n        while stdin.readable():\n            line = stdin.readline()\n            if line:\n                yield line.strip().encode(\"utf-8\")", "code_tokens": "def standard_input ( ) : with click . get_text_stream ( \"stdin\" ) as stdin : while stdin . readable ( ) : line = stdin . readline ( ) if line : yield line . strip ( ) . encode ( \"utf-8\" )", "docstring_tokens": "Generator that yields lines from standard input .", "label": 0}, {"idx": "cosqa-train-3833", "doc": "password validation using regex python", "code": "def is_password_valid(password):\n    \"\"\"\n    Check if a password is valid\n    \"\"\"\n    pattern = re.compile(r\"^.{4,75}$\")\n    return bool(pattern.match(password))", "code_tokens": "def is_password_valid ( password ) : pattern = re . compile ( r\"^.{4,75}$\" ) return bool ( pattern . match ( password ) )", "docstring_tokens": "Check if a password is valid", "label": 0}, {"idx": "cosqa-train-3834", "doc": "reading text from a url in python", "code": "def url_read_text(url, verbose=True):\n    r\"\"\"\n    Directly reads text data from url\n    \"\"\"\n    data = url_read(url, verbose)\n    text = data.decode('utf8')\n    return text", "code_tokens": "def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text", "docstring_tokens": "r Directly reads text data from url", "label": 1}, {"idx": "cosqa-train-3835", "doc": "pdfminer python slice page", "code": "def resources(self):\n        \"\"\"Retrieve contents of each page of PDF\"\"\"\n        return [self.pdf.getPage(i) for i in range(self.pdf.getNumPages())]", "code_tokens": "def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "docstring_tokens": "Retrieve contents of each page of PDF", "label": 0}, {"idx": "cosqa-train-3836", "doc": "record mouse position with python", "code": "def mouse_move_event(self, event):\n        \"\"\"\n        Forward mouse cursor position events to the example\n        \"\"\"\n        self.example.mouse_position_event(event.x(), event.y())", "code_tokens": "def mouse_move_event ( self , event ) : self . example . mouse_position_event ( event . x ( ) , event . y ( ) )", "docstring_tokens": "Forward mouse cursor position events to the example", "label": 0}, {"idx": "cosqa-train-3837", "doc": "pearson correlation python numpy", "code": "def cor(y_true, y_pred):\n    \"\"\"Compute Pearson correlation coefficient.\n    \"\"\"\n    y_true, y_pred = _mask_nan(y_true, y_pred)\n    return np.corrcoef(y_true, y_pred)[0, 1]", "code_tokens": "def cor ( y_true , y_pred ) : y_true , y_pred = _mask_nan ( y_true , y_pred ) return np . corrcoef ( y_true , y_pred ) [ 0 , 1 ]", "docstring_tokens": "Compute Pearson correlation coefficient .", "label": 1}, {"idx": "cosqa-train-3838", "doc": "recursively flattening nested lists python", "code": "def flat_list(lst):\n    \"\"\"This function flatten given nested list.\n    Argument:\n        nested list\n    Returns:\n        flat list\n    \"\"\"\n    if isinstance(lst, list):\n        for item in lst:\n            for i in flat_list(item):\n                yield i\n    else:\n        yield lst", "code_tokens": "def flat_list ( lst ) : if isinstance ( lst , list ) : for item in lst : for i in flat_list ( item ) : yield i else : yield lst", "docstring_tokens": "This function flatten given nested list . Argument : nested list Returns : flat list", "label": 0}, {"idx": "cosqa-train-3839", "doc": "plot the magnitude of the fft including frequnecy in python", "code": "def log_magnitude_spectrum(frames):\n    \"\"\"Compute the log of the magnitude spectrum of frames\"\"\"\n    return N.log(N.abs(N.fft.rfft(frames)).clip(1e-5, N.inf))", "code_tokens": "def log_magnitude_spectrum ( frames ) : return N . log ( N . abs ( N . fft . rfft ( frames ) ) . clip ( 1e-5 , N . inf ) )", "docstring_tokens": "Compute the log of the magnitude spectrum of frames", "label": 0}, {"idx": "cosqa-train-3840", "doc": "redis get keys python", "code": "def get(self, key):  \n        \"\"\" get a set of keys from redis \"\"\"\n        res = self.connection.get(key)\n        print(res)\n        return res", "code_tokens": "def get ( self , key ) : res = self . connection . get ( key ) print ( res ) return res", "docstring_tokens": "get a set of keys from redis", "label": 1}, {"idx": "cosqa-train-3841", "doc": "redis python how to release a connection back to pool", "code": "def _ReturnConnection(self):\n\t\t\"\"\"\n\t\tReturns a connection back to the pool\n\t\t\n\t\t@author: Nick Verbeck\n\t\t@since: 9/7/2008\n\t\t\"\"\"\n\t\tif self.conn is not None:\n\t\t\tif self.connInfo.commitOnEnd is True or self.commitOnEnd is True:\n\t\t\t\tself.conn.Commit()\n\t\t\t\t\t\n\t\t\tPool().returnConnection(self.conn)\n\t\t\tself.conn = None", "code_tokens": "def _ReturnConnection ( self ) : if self . conn is not None : if self . connInfo . commitOnEnd is True or self . commitOnEnd is True : self . conn . Commit ( ) Pool ( ) . returnConnection ( self . conn ) self . conn = None", "docstring_tokens": "Returns a connection back to the pool", "label": 0}, {"idx": "cosqa-train-3842", "doc": "pop several key from dictionnary python", "code": "def multi_pop(d, *args):\n    \"\"\" pops multiple keys off a dict like object \"\"\"\n    retval = {}\n    for key in args:\n        if key in d:\n            retval[key] = d.pop(key)\n    return retval", "code_tokens": "def multi_pop ( d , * args ) : retval = { } for key in args : if key in d : retval [ key ] = d . pop ( key ) return retval", "docstring_tokens": "pops multiple keys off a dict like object", "label": 0}, {"idx": "cosqa-train-3843", "doc": "redis python uri example", "code": "def from_url(url, db=None, **kwargs):\n    \"\"\"\n    Returns an active Redis client generated from the given database URL.\n\n    Will attempt to extract the database id from the path url fragment, if\n    none is provided.\n    \"\"\"\n    from redis.client import Redis\n    return Redis.from_url(url, db, **kwargs)", "code_tokens": "def from_url ( url , db = None , * * kwargs ) : from redis . client import Redis return Redis . from_url ( url , db , * * kwargs )", "docstring_tokens": "Returns an active Redis client generated from the given database URL .", "label": 1}, {"idx": "cosqa-train-3844", "doc": "posixpath to str python", "code": "def __unixify(self, s):\n        \"\"\" stupid windows. converts the backslash to forwardslash for consistency \"\"\"\n        return os.path.normpath(s).replace(os.sep, \"/\")", "code_tokens": "def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , \"/\" )", "docstring_tokens": "stupid windows . converts the backslash to forwardslash for consistency", "label": 0}, {"idx": "cosqa-train-3845", "doc": "prefix notation parsing in python", "code": "def parse_prefix(identifier):\n    \"\"\"\n    Parse identifier such as a|c|le|d|li|re|or|AT4G00480.1 and return\n    tuple of prefix string (separated at '|') and suffix (AGI identifier)\n    \"\"\"\n    pf, id = (), identifier\n    if \"|\" in identifier:\n        pf, id = tuple(identifier.split('|')[:-1]), identifier.split('|')[-1]\n\n    return pf, id", "code_tokens": "def parse_prefix ( identifier ) : pf , id = ( ) , identifier if \"|\" in identifier : pf , id = tuple ( identifier . split ( '|' ) [ : - 1 ] ) , identifier . split ( '|' ) [ - 1 ] return pf , id", "docstring_tokens": "Parse identifier such as a|c|le|d|li|re|or|AT4G00480 . 1 and return tuple of prefix string ( separated at | ) and suffix ( AGI identifier )", "label": 1}, {"idx": "cosqa-train-3846", "doc": "reduce image sizes using python", "code": "def resize_by_area(img, size):\n  \"\"\"image resize function used by quite a few image problems.\"\"\"\n  return tf.to_int64(\n      tf.image.resize_images(img, [size, size], tf.image.ResizeMethod.AREA))", "code_tokens": "def resize_by_area ( img , size ) : return tf . to_int64 ( tf . image . resize_images ( img , [ size , size ] , tf . image . ResizeMethod . AREA ) )", "docstring_tokens": "image resize function used by quite a few image problems .", "label": 0}, {"idx": "cosqa-train-3847", "doc": "preserve ordering yaml load python", "code": "def ordered_yaml_dump(data, stream=None, Dumper=None, **kwds):\n    \"\"\"Dumps the stream from an OrderedDict.\n    Taken from\n\n    http://stackoverflow.com/questions/5121931/in-python-how-can-you-load-yaml-\n    mappings-as-ordereddicts\"\"\"\n    Dumper = Dumper or yaml.Dumper\n\n    class OrderedDumper(Dumper):\n        pass\n\n    def _dict_representer(dumper, data):\n        return dumper.represent_mapping(\n            yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,\n            data.items())\n    OrderedDumper.add_representer(OrderedDict, _dict_representer)\n    return yaml.dump(data, stream, OrderedDumper, **kwds)", "code_tokens": "def ordered_yaml_dump ( data , stream = None , Dumper = None , * * kwds ) : Dumper = Dumper or yaml . Dumper class OrderedDumper ( Dumper ) : pass def _dict_representer ( dumper , data ) : return dumper . represent_mapping ( yaml . resolver . BaseResolver . DEFAULT_MAPPING_TAG , data . items ( ) ) OrderedDumper . add_representer ( OrderedDict , _dict_representer ) return yaml . dump ( data , stream , OrderedDumper , * * kwds )", "docstring_tokens": "Dumps the stream from an OrderedDict . Taken from", "label": 0}, {"idx": "cosqa-train-3848", "doc": "regex in python remove comments", "code": "def lines(input):\n    \"\"\"Remove comments and empty lines\"\"\"\n    for raw_line in input:\n        line = raw_line.strip()\n        if line and not line.startswith('#'):\n            yield strip_comments(line)", "code_tokens": "def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )", "docstring_tokens": "Remove comments and empty lines", "label": 0}, {"idx": "cosqa-train-3849", "doc": "pretty format python dictionary", "code": "def pretty_dict_str(d, indent=2):\n    \"\"\"shows JSON indented representation of d\"\"\"\n    b = StringIO()\n    write_pretty_dict_str(b, d, indent=indent)\n    return b.getvalue()", "code_tokens": "def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )", "docstring_tokens": "shows JSON indented representation of d", "label": 0}, {"idx": "cosqa-train-3850", "doc": "relational table to python dict", "code": "def to_dict(self):\n        \"\"\"Serialize representation of the table for local caching.\"\"\"\n        return {'schema': self.schema, 'name': self.name, 'columns': [col.to_dict() for col in self._columns],\n                'foreign_keys': self.foreign_keys.to_dict(), 'ref_keys': self.ref_keys.to_dict()}", "code_tokens": "def to_dict ( self ) : return { 'schema' : self . schema , 'name' : self . name , 'columns' : [ col . to_dict ( ) for col in self . _columns ] , 'foreign_keys' : self . foreign_keys . to_dict ( ) , 'ref_keys' : self . ref_keys . to_dict ( ) }", "docstring_tokens": "Serialize representation of the table for local caching .", "label": 0}, {"idx": "cosqa-train-3851", "doc": "print a file to a printer command in python", "code": "def replace_print(fileobj=sys.stderr):\n  \"\"\"Sys.out replacer, by default with stderr.\n\n  Use it like this:\n  with replace_print_with(fileobj):\n    print \"hello\"  # writes to the file\n  print \"done\"  # prints to stdout\n\n  Args:\n    fileobj: a file object to replace stdout.\n\n  Yields:\n    The printer.\n  \"\"\"\n  printer = _Printer(fileobj)\n\n  previous_stdout = sys.stdout\n  sys.stdout = printer\n  try:\n    yield printer\n  finally:\n    sys.stdout = previous_stdout", "code_tokens": "def replace_print ( fileobj = sys . stderr ) : printer = _Printer ( fileobj ) previous_stdout = sys . stdout sys . stdout = printer try : yield printer finally : sys . stdout = previous_stdout", "docstring_tokens": "Sys . out replacer by default with stderr .", "label": 0}, {"idx": "cosqa-train-3852", "doc": "remove a value from all keys in a dictionary python", "code": "def _delete_keys(dct, keys):\n    \"\"\"Returns a copy of dct without `keys` keys\n    \"\"\"\n    c = deepcopy(dct)\n    assert isinstance(keys, list)\n    for k in keys:\n        c.pop(k)\n    return c", "code_tokens": "def _delete_keys ( dct , keys ) : c = deepcopy ( dct ) assert isinstance ( keys , list ) for k in keys : c . pop ( k ) return c", "docstring_tokens": "Returns a copy of dct without keys keys", "label": 1}, {"idx": "cosqa-train-3853", "doc": "print alll variables in object python", "code": "def var_dump(*obs):\n\t\"\"\"\n\t  shows structured information of a object, list, tuple etc\n\t\"\"\"\n\ti = 0\n\tfor x in obs:\n\t\t\n\t\tstr = var_dump_output(x, 0, '  ', '\\n', True)\n\t\tprint (str.strip())\n\t\t\n\t\t#dump(x, 0, i, '', object)\n\t\ti += 1", "code_tokens": "def var_dump ( * obs ) : i = 0 for x in obs : str = var_dump_output ( x , 0 , '  ' , '\\n' , True ) print ( str . strip ( ) ) #dump(x, 0, i, '', object) i += 1", "docstring_tokens": "shows structured information of a object list tuple etc", "label": 0}, {"idx": "cosqa-train-3854", "doc": "remove after last underscore python", "code": "def camelcase_underscore(name):\n    \"\"\" Convert camelcase names to underscore \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def camelcase_underscore ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert camelcase names to underscore", "label": 0}, {"idx": "cosqa-train-3855", "doc": "print first value of a series python", "code": "def first(series, order_by=None):\n    \"\"\"\n    Returns the first value of a series.\n\n    Args:\n        series (pandas.Series): column to summarize.\n\n    Kwargs:\n        order_by: a pandas.Series or list of series (can be symbolic) to order\n            the input series by before summarization.\n    \"\"\"\n\n    if order_by is not None:\n        series = order_series_by(series, order_by)\n    first_s = series.iloc[0]\n    return first_s", "code_tokens": "def first ( series , order_by = None ) : if order_by is not None : series = order_series_by ( series , order_by ) first_s = series . iloc [ 0 ] return first_s", "docstring_tokens": "Returns the first value of a series .", "label": 0}, {"idx": "cosqa-train-3856", "doc": "remove all letters in string python", "code": "def clean(self, text):\n        \"\"\"Remove all unwanted characters from text.\"\"\"\n        return ''.join([c for c in text if c in self.alphabet])", "code_tokens": "def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )", "docstring_tokens": "Remove all unwanted characters from text .", "label": 0}, {"idx": "cosqa-train-3857", "doc": "print in python foreground coloyr", "code": "def cprint(string, fg=None, bg=None, end='\\n', target=sys.stdout):\n    \"\"\"Print a colored string to the target handle.\n\n    fg and bg specify foreground- and background colors, respectively. The\n    remaining keyword arguments are the same as for Python's built-in print\n    function. Colors are returned to their defaults before the function\n    returns.\n\n    \"\"\"\n    _color_manager.set_color(fg, bg)\n    target.write(string + end)\n    target.flush()  # Needed for Python 3.x\n    _color_manager.set_defaults()", "code_tokens": "def cprint ( string , fg = None , bg = None , end = '\\n' , target = sys . stdout ) : _color_manager . set_color ( fg , bg ) target . write ( string + end ) target . flush ( ) # Needed for Python 3.x _color_manager . set_defaults ( )", "docstring_tokens": "Print a colored string to the target handle .", "label": 1}, {"idx": "cosqa-train-3858", "doc": "remove all punctuations in python string", "code": "def _clean_str(self, s):\n        \"\"\" Returns a lowercase string with punctuation and bad chars removed\n        :param s: string to clean\n        \"\"\"\n        return s.translate(str.maketrans('', '', punctuation)).replace('\\u200b', \" \").strip().lower()", "code_tokens": "def _clean_str ( self , s ) : return s . translate ( str . maketrans ( '' , '' , punctuation ) ) . replace ( '\\u200b' , \" \" ) . strip ( ) . lower ( )", "docstring_tokens": "Returns a lowercase string with punctuation and bad chars removed : param s : string to clean", "label": 0}, {"idx": "cosqa-train-3859", "doc": "print text with color python", "code": "def printc(cls, txt, color=colors.red):\n        \"\"\"Print in color.\"\"\"\n        print(cls.color_txt(txt, color))", "code_tokens": "def printc ( cls , txt , color = colors . red ) : print ( cls . color_txt ( txt , color ) )", "docstring_tokens": "Print in color .", "label": 0}, {"idx": "cosqa-train-3860", "doc": "remove comma from list python", "code": "def __normalize_list(self, msg):\n        \"\"\"Split message to list by commas and trim whitespace.\"\"\"\n        if isinstance(msg, list):\n            msg = \"\".join(msg)\n        return list(map(lambda x: x.strip(), msg.split(\",\")))", "code_tokens": "def __normalize_list ( self , msg ) : if isinstance ( msg , list ) : msg = \"\" . join ( msg ) return list ( map ( lambda x : x . strip ( ) , msg . split ( \",\" ) ) )", "docstring_tokens": "Split message to list by commas and trim whitespace .", "label": 1}, {"idx": "cosqa-train-3861", "doc": "print value inside tensor python", "code": "def Print(x, data, message, **kwargs):  # pylint: disable=invalid-name\n  \"\"\"Call tf.Print.\n\n  Args:\n    x: a Tensor.\n    data: a list of Tensor\n    message: a string\n    **kwargs: keyword arguments to tf.Print\n  Returns:\n    a Tensor which is identical in value to x\n  \"\"\"\n  return PrintOperation(x, data, message, **kwargs).outputs[0]", "code_tokens": "def Print ( x , data , message , * * kwargs ) : # pylint: disable=invalid-name return PrintOperation ( x , data , message , * * kwargs ) . outputs [ 0 ]", "docstring_tokens": "Call tf . Print .", "label": 0}, {"idx": "cosqa-train-3862", "doc": "remove duplicates in python list (using sets)", "code": "def remove_dups(seq):\n    \"\"\"remove duplicates from a sequence, preserving order\"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "remove duplicates from a sequence preserving order", "label": 0}, {"idx": "cosqa-train-3863", "doc": "printing table in python from csv file", "code": "def csvpretty(csvfile: csvfile=sys.stdin):\n    \"\"\" Pretty print a CSV file. \"\"\"\n    shellish.tabulate(csv.reader(csvfile))", "code_tokens": "def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )", "docstring_tokens": "Pretty print a CSV file .", "label": 0}, {"idx": "cosqa-train-3864", "doc": "remove files in current directory with filename containing specific letters python", "code": "def clean_py_files(path):\n    \"\"\"\n    Removes all .py files.\n\n    :param path: the path\n    :return: None\n    \"\"\"\n\n    for dirname, subdirlist, filelist in os.walk(path):\n\n        for f in filelist:\n            if f.endswith('py'):\n                os.remove(os.path.join(dirname, f))", "code_tokens": "def clean_py_files ( path ) : for dirname , subdirlist , filelist in os . walk ( path ) : for f in filelist : if f . endswith ( 'py' ) : os . remove ( os . path . join ( dirname , f ) )", "docstring_tokens": "Removes all . py files .", "label": 0}, {"idx": "cosqa-train-3865", "doc": "protobuf deserialize bytes python", "code": "def loadb(b):\n    \"\"\"Deserialize ``b`` (instance of ``bytes``) to a Python object.\"\"\"\n    assert isinstance(b, (bytes, bytearray))\n    return std_json.loads(b.decode('utf-8'))", "code_tokens": "def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )", "docstring_tokens": "Deserialize b ( instance of bytes ) to a Python object .", "label": 0}, {"idx": "cosqa-train-3866", "doc": "remove forward whitespace python", "code": "def clean_whitespace(statement):\n    \"\"\"\n    Remove any consecutive whitespace characters from the statement text.\n    \"\"\"\n    import re\n\n    # Replace linebreaks and tabs with spaces\n    statement.text = statement.text.replace('\\n', ' ').replace('\\r', ' ').replace('\\t', ' ')\n\n    # Remove any leeding or trailing whitespace\n    statement.text = statement.text.strip()\n\n    # Remove consecutive spaces\n    statement.text = re.sub(' +', ' ', statement.text)\n\n    return statement", "code_tokens": "def clean_whitespace ( statement ) : import re # Replace linebreaks and tabs with spaces statement . text = statement . text . replace ( '\\n' , ' ' ) . replace ( '\\r' , ' ' ) . replace ( '\\t' , ' ' ) # Remove any leeding or trailing whitespace statement . text = statement . text . strip ( ) # Remove consecutive spaces statement . text = re . sub ( ' +' , ' ' , statement . text ) return statement", "docstring_tokens": "Remove any consecutive whitespace characters from the statement text .", "label": 0}, {"idx": "cosqa-train-3867", "doc": "protobuf msg to python object", "code": "def _to_base_type(self, msg):\n    \"\"\"Convert a Message value to a Model instance (entity).\"\"\"\n    ent = _message_to_entity(msg, self._modelclass)\n    ent.blob_ = self._protocol_impl.encode_message(msg)\n    return ent", "code_tokens": "def _to_base_type ( self , msg ) : ent = _message_to_entity ( msg , self . _modelclass ) ent . blob_ = self . _protocol_impl . encode_message ( msg ) return ent", "docstring_tokens": "Convert a Message value to a Model instance ( entity ) .", "label": 0}, {"idx": "cosqa-train-3868", "doc": "remove item from list python pop", "code": "def pop(self, index=-1):\n\t\t\"\"\"Remove and return the item at index.\"\"\"\n\t\tvalue = self._list.pop(index)\n\t\tdel self._dict[value]\n\t\treturn value", "code_tokens": "def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value", "docstring_tokens": "Remove and return the item at index .", "label": 0}, {"idx": "cosqa-train-3869", "doc": "protobuf python struct to json", "code": "def toJson(protoObject, indent=None):\n    \"\"\"\n    Serialises a protobuf object as json\n    \"\"\"\n    # Using the internal method because this way we can reformat the JSON\n    js = json_format.MessageToDict(protoObject, False)\n    return json.dumps(js, indent=indent)", "code_tokens": "def toJson ( protoObject , indent = None ) : # Using the internal method because this way we can reformat the JSON js = json_format . MessageToDict ( protoObject , False ) return json . dumps ( js , indent = indent )", "docstring_tokens": "Serialises a protobuf object as json", "label": 0}, {"idx": "cosqa-train-3870", "doc": "remove keys from a python dictionary that have a certain value", "code": "def filter_dict(d, keys):\n    \"\"\"\n    Creates a new dict from an existing dict that only has the given keys\n    \"\"\"\n    return {k: v for k, v in d.items() if k in keys}", "code_tokens": "def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "docstring_tokens": "Creates a new dict from an existing dict that only has the given keys", "label": 1}, {"idx": "cosqa-train-3871", "doc": "python 'datetime' has no attribute 'today'", "code": "def created_today(self):\n        \"\"\"Return True if created today.\"\"\"\n        if self.datetime.date() == datetime.today().date():\n            return True\n        return False", "code_tokens": "def created_today ( self ) : if self . datetime . date ( ) == datetime . today ( ) . date ( ) : return True return False", "docstring_tokens": "Return True if created today .", "label": 0}, {"idx": "cosqa-train-3872", "doc": "remove letters from word in python", "code": "def _clean_str(self, s):\n        \"\"\" Returns a lowercase string with punctuation and bad chars removed\n        :param s: string to clean\n        \"\"\"\n        return s.translate(str.maketrans('', '', punctuation)).replace('\\u200b', \" \").strip().lower()", "code_tokens": "def _clean_str ( self , s ) : return s . translate ( str . maketrans ( '' , '' , punctuation ) ) . replace ( '\\u200b' , \" \" ) . strip ( ) . lower ( )", "docstring_tokens": "Returns a lowercase string with punctuation and bad chars removed : param s : string to clean", "label": 0}, {"idx": "cosqa-train-3873", "doc": "python 2 rounding up", "code": "def py3round(number):\n    \"\"\"Unified rounding in all python versions.\"\"\"\n    if abs(round(number) - number) == 0.5:\n        return int(2.0 * round(number / 2.0))\n\n    return int(round(number))", "code_tokens": "def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )", "docstring_tokens": "Unified rounding in all python versions .", "label": 0}, {"idx": "cosqa-train-3874", "doc": "remove list function python iteratively", "code": "def purge_duplicates(list_in):\n    \"\"\"Remove duplicates from list while preserving order.\n\n    Parameters\n    ----------\n    list_in: Iterable\n\n    Returns\n    -------\n    list\n        List of first occurences in order\n    \"\"\"\n    _list = []\n    for item in list_in:\n        if item not in _list:\n            _list.append(item)\n    return _list", "code_tokens": "def purge_duplicates ( list_in ) : _list = [ ] for item in list_in : if item not in _list : _list . append ( item ) return _list", "docstring_tokens": "Remove duplicates from list while preserving order .", "label": 1}, {"idx": "cosqa-train-3875", "doc": "python 3 check if object is an string", "code": "def is_string(obj):\n    \"\"\"Is this a string.\n\n    :param object obj:\n    :rtype: bool\n    \"\"\"\n    if PYTHON3:\n        str_type = (bytes, str)\n    else:\n        str_type = (bytes, str, unicode)\n    return isinstance(obj, str_type)", "code_tokens": "def is_string ( obj ) : if PYTHON3 : str_type = ( bytes , str ) else : str_type = ( bytes , str , unicode ) return isinstance ( obj , str_type )", "docstring_tokens": "Is this a string .", "label": 1}, {"idx": "cosqa-train-3876", "doc": "remove namespace from xml in python", "code": "def strip_xml_namespace(root):\n    \"\"\"Strip out namespace data from an ElementTree.\n\n    This function is recursive and will traverse all\n    subnodes to the root element\n\n    @param root: the root element\n\n    @return: the same root element, minus namespace\n    \"\"\"\n    try:\n        root.tag = root.tag.split('}')[1]\n    except IndexError:\n        pass\n\n    for element in root.getchildren():\n        strip_xml_namespace(element)", "code_tokens": "def strip_xml_namespace ( root ) : try : root . tag = root . tag . split ( '}' ) [ 1 ] except IndexError : pass for element in root . getchildren ( ) : strip_xml_namespace ( element )", "docstring_tokens": "Strip out namespace data from an ElementTree .", "label": 1}, {"idx": "cosqa-train-3877", "doc": "python 3 filter object", "code": "def filter_(stream_spec, filter_name, *args, **kwargs):\n    \"\"\"Alternate name for ``filter``, so as to not collide with the\n    built-in python ``filter`` operator.\n    \"\"\"\n    return filter(stream_spec, filter_name, *args, **kwargs)", "code_tokens": "def filter_ ( stream_spec , filter_name , * args , * * kwargs ) : return filter ( stream_spec , filter_name , * args , * * kwargs )", "docstring_tokens": "Alternate name for filter so as to not collide with the built - in python filter operator .", "label": 1}, {"idx": "cosqa-train-3878", "doc": "remove new line whitespace in python", "code": "def clean(s):\n  \"\"\"Removes trailing whitespace on each line.\"\"\"\n  lines = [l.rstrip() for l in s.split('\\n')]\n  return '\\n'.join(lines)", "code_tokens": "def clean ( s ) : lines = [ l . rstrip ( ) for l in s . split ( '\\n' ) ] return '\\n' . join ( lines )", "docstring_tokens": "Removes trailing whitespace on each line .", "label": 0}, {"idx": "cosqa-train-3879", "doc": "python 3 get the sunday of that day", "code": "def first_sunday(self, year, month):\n        \"\"\"Get the first sunday of a month.\"\"\"\n        date = datetime(year, month, 1, 0)\n        days_until_sunday = 6 - date.weekday()\n\n        return date + timedelta(days=days_until_sunday)", "code_tokens": "def first_sunday ( self , year , month ) : date = datetime ( year , month , 1 , 0 ) days_until_sunday = 6 - date . weekday ( ) return date + timedelta ( days = days_until_sunday )", "docstring_tokens": "Get the first sunday of a month .", "label": 1}, {"idx": "cosqa-train-3880", "doc": "remove none value from dictonary python\\", "code": "def nonull_dict(self):\n        \"\"\"Like dict, but does not hold any null values.\n\n        :return:\n\n        \"\"\"\n        return {k: v for k, v in six.iteritems(self.dict) if v and k != '_codes'}", "code_tokens": "def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }", "docstring_tokens": "Like dict but does not hold any null values .", "label": 0}, {"idx": "cosqa-train-3881", "doc": "python 3 hex to signed int", "code": "def bin_to_int(string):\n    \"\"\"Convert a one element byte string to signed int for python 2 support.\"\"\"\n    if isinstance(string, str):\n        return struct.unpack(\"b\", string)[0]\n    else:\n        return struct.unpack(\"b\", bytes([string]))[0]", "code_tokens": "def bin_to_int ( string ) : if isinstance ( string , str ) : return struct . unpack ( \"b\" , string ) [ 0 ] else : return struct . unpack ( \"b\" , bytes ( [ string ] ) ) [ 0 ]", "docstring_tokens": "Convert a one element byte string to signed int for python 2 support .", "label": 1}, {"idx": "cosqa-train-3882", "doc": "remove repeated objects python", "code": "def _removeTags(tags, objects):\n    \"\"\" Removes tags from objects \"\"\"\n    for t in tags:\n        for o in objects:\n            o.tags.remove(t)\n\n    return True", "code_tokens": "def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True", "docstring_tokens": "Removes tags from objects", "label": 0}, {"idx": "cosqa-train-3883", "doc": "python 3 how to calculate execution time of function", "code": "def time_func(func, name, *args, **kwargs):\n    \"\"\" call a func with args and kwargs, print name of func and how\n    long it took. \"\"\"\n    tic = time.time()\n    out = func(*args, **kwargs)\n    toc = time.time()\n    print('%s took %0.2f seconds' % (name, toc - tic))\n    return out", "code_tokens": "def time_func ( func , name , * args , * * kwargs ) : tic = time . time ( ) out = func ( * args , * * kwargs ) toc = time . time ( ) print ( '%s took %0.2f seconds' % ( name , toc - tic ) ) return out", "docstring_tokens": "call a func with args and kwargs print name of func and how long it took .", "label": 0}, {"idx": "cosqa-train-3884", "doc": "remove rows with duplicated index names python data frame", "code": "def get_unique_indices(df, axis=1):\n    \"\"\"\n\n    :param df:\n    :param axis:\n    :return:\n    \"\"\"\n    return dict(zip(df.columns.names, dif.columns.levels))", "code_tokens": "def get_unique_indices ( df , axis = 1 ) : return dict ( zip ( df . columns . names , dif . columns . levels ) )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-3885", "doc": "python 3 how to load dynamically loaded extension", "code": "def register_extension_class(ext, base, *args, **kwargs):\n    \"\"\"Instantiate the given extension class and register as a public attribute of the given base.\n\n    README: The expected protocol here is to instantiate the given extension and pass the base\n    object as the first positional argument, then unpack args and kwargs as additional arguments to\n    the extension's constructor.\n    \"\"\"\n    ext_instance = ext.plugin(base, *args, **kwargs)\n    setattr(base, ext.name.lstrip('_'), ext_instance)", "code_tokens": "def register_extension_class ( ext , base , * args , * * kwargs ) : ext_instance = ext . plugin ( base , * args , * * kwargs ) setattr ( base , ext . name . lstrip ( '_' ) , ext_instance )", "docstring_tokens": "Instantiate the given extension class and register as a public attribute of the given base .", "label": 0}, {"idx": "cosqa-train-3886", "doc": "remove space after word python", "code": "def lowstrip(term):\n    \"\"\"Convert to lowercase and strip spaces\"\"\"\n    term = re.sub('\\s+', ' ', term)\n    term = term.lower()\n    return term", "code_tokens": "def lowstrip ( term ) : term = re . sub ( '\\s+' , ' ' , term ) term = term . lower ( ) return term", "docstring_tokens": "Convert to lowercase and strip spaces", "label": 0}, {"idx": "cosqa-train-3887", "doc": "python 3 if type is str", "code": "def validate_string(option, value):\n    \"\"\"Validates that 'value' is an instance of `basestring` for Python 2\n    or `str` for Python 3.\n    \"\"\"\n    if isinstance(value, string_type):\n        return value\n    raise TypeError(\"Wrong type for %s, value must be \"\n                    \"an instance of %s\" % (option, string_type.__name__))", "code_tokens": "def validate_string ( option , value ) : if isinstance ( value , string_type ) : return value raise TypeError ( \"Wrong type for %s, value must be \" \"an instance of %s\" % ( option , string_type . __name__ ) )", "docstring_tokens": "Validates that value is an instance of basestring for Python 2 or str for Python 3 .", "label": 0}, {"idx": "cosqa-train-3888", "doc": "remove variable from globals python", "code": "def clear_global(self):\n        \"\"\"Clear only any cached global data.\n\n        \"\"\"\n        vname = self.varname\n        logger.debug(f'global clearning {vname}')\n        if vname in globals():\n            logger.debug('removing global instance var: {}'.format(vname))\n            del globals()[vname]", "code_tokens": "def clear_global ( self ) : vname = self . varname logger . debug ( f'global clearning {vname}' ) if vname in globals ( ) : logger . debug ( 'removing global instance var: {}' . format ( vname ) ) del globals ( ) [ vname ]", "docstring_tokens": "Clear only any cached global data .", "label": 0}, {"idx": "cosqa-train-3889", "doc": "python 3 input function", "code": "def _stdin_(p):\n    \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"\n    _v = sys.version[0]\n    return input(p) if _v is '3' else raw_input(p)", "code_tokens": "def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "docstring_tokens": "Takes input from user . Works for Python 2 and 3 .", "label": 0}, {"idx": "cosqa-train-3890", "doc": "removing image in pdf with python", "code": "def save_image(pdf_path, img_path, page_num):\n    \"\"\"\n\n    Creates images for a page of the input pdf document and saves it\n    at img_path.\n\n    :param pdf_path: path to pdf to create images for.\n    :param img_path: path where to save the images.\n    :param page_num: page number to create image from in the pdf file.\n    :return:\n    \"\"\"\n    pdf_img = Image(filename=\"{}[{}]\".format(pdf_path, page_num))\n    with pdf_img.convert(\"png\") as converted:\n        # Set white background.\n        converted.background_color = Color(\"white\")\n        converted.alpha_channel = \"remove\"\n        converted.save(filename=img_path)", "code_tokens": "def save_image ( pdf_path , img_path , page_num ) : pdf_img = Image ( filename = \"{}[{}]\" . format ( pdf_path , page_num ) ) with pdf_img . convert ( \"png\" ) as converted : # Set white background. converted . background_color = Color ( \"white\" ) converted . alpha_channel = \"remove\" converted . save ( filename = img_path )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-3891", "doc": "python 3 join or fstring", "code": "def _py2_and_3_joiner(sep, joinable):\n    \"\"\"\n    Allow '\\n'.join(...) statements to work in Py2 and Py3.\n    :param sep:\n    :param joinable:\n    :return:\n    \"\"\"\n    if ISPY3:\n        sep = bytes(sep, DEFAULT_ENCODING)\n    joined = sep.join(joinable)\n    return joined.decode(DEFAULT_ENCODING) if ISPY3 else joined", "code_tokens": "def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "docstring_tokens": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return :", "label": 0}, {"idx": "cosqa-train-3892", "doc": "removing punctuation from a text python", "code": "def remove_punctuation(text, exceptions=[]):\n    \"\"\"\n    Return a string with punctuation removed.\n\n    Parameters:\n        text (str): The text to remove punctuation from.\n        exceptions (list): List of symbols to keep in the given text.\n\n    Return:\n        str: The input text without the punctuation.\n    \"\"\"\n\n    all_but = [\n        r'\\w',\n        r'\\s'\n    ]\n\n    all_but.extend(exceptions)\n\n    pattern = '[^{}]'.format(''.join(all_but))\n\n    return re.sub(pattern, '', text)", "code_tokens": "def remove_punctuation ( text , exceptions = [ ] ) : all_but = [ r'\\w' , r'\\s' ] all_but . extend ( exceptions ) pattern = '[^{}]' . format ( '' . join ( all_but ) ) return re . sub ( pattern , '' , text )", "docstring_tokens": "Return a string with punctuation removed .", "label": 0}, {"idx": "cosqa-train-3893", "doc": "python 3 listbox scrollbar scroll set", "code": "def __init__(self, master=None, compound=tk.RIGHT, autohidescrollbar=True, **kwargs):\n        \"\"\"\n        Create a Listbox with a vertical scrollbar.\n\n        :param master: master widget\n        :type master: widget\n        :param compound: side for the Scrollbar to be on (:obj:`tk.LEFT` or :obj:`tk.RIGHT`)\n        :type compound: str\n        :param autohidescrollbar: whether to use an :class:`~ttkwidgets.AutoHideScrollbar` or a :class:`ttk.Scrollbar`\n        :type autohidescrollbar: bool\n        :param kwargs: keyword arguments passed on to the :class:`tk.Listbox` initializer\n        \"\"\"\n        ttk.Frame.__init__(self, master)\n        self.columnconfigure(1, weight=1)\n        self.rowconfigure(0, weight=1)\n        self.listbox = tk.Listbox(self, **kwargs)\n        if autohidescrollbar:\n            self.scrollbar = AutoHideScrollbar(self, orient=tk.VERTICAL, command=self.listbox.yview)\n        else:\n            self.scrollbar = ttk.Scrollbar(self, orient=tk.VERTICAL, command=self.listbox.yview)\n        self.config_listbox(yscrollcommand=self.scrollbar.set)\n        if compound is not tk.LEFT and compound is not tk.RIGHT:\n            raise ValueError(\"Invalid compound value passed: {0}\".format(compound))\n        self.__compound = compound\n        self._grid_widgets()", "code_tokens": "def __init__ ( self , master = None , compound = tk . RIGHT , autohidescrollbar = True , * * kwargs ) : ttk . Frame . __init__ ( self , master ) self . columnconfigure ( 1 , weight = 1 ) self . rowconfigure ( 0 , weight = 1 ) self . listbox = tk . Listbox ( self , * * kwargs ) if autohidescrollbar : self . scrollbar = AutoHideScrollbar ( self , orient = tk . VERTICAL , command = self . listbox . yview ) else : self . scrollbar = ttk . Scrollbar ( self , orient = tk . VERTICAL , command = self . listbox . yview ) self . config_listbox ( yscrollcommand = self . scrollbar . set ) if compound is not tk . LEFT and compound is not tk . RIGHT : raise ValueError ( \"Invalid compound value passed: {0}\" . format ( compound ) ) self . __compound = compound self . _grid_widgets ( )", "docstring_tokens": "Create a Listbox with a vertical scrollbar .", "label": 0}, {"idx": "cosqa-train-3894", "doc": "render a grayscale image python", "code": "def draw_image(self, ax, image):\n        \"\"\"Process a matplotlib image object and call renderer.draw_image\"\"\"\n        self.renderer.draw_image(imdata=utils.image_to_base64(image),\n                                 extent=image.get_extent(),\n                                 coordinates=\"data\",\n                                 style={\"alpha\": image.get_alpha(),\n                                        \"zorder\": image.get_zorder()},\n                                 mplobj=image)", "code_tokens": "def draw_image ( self , ax , image ) : self . renderer . draw_image ( imdata = utils . image_to_base64 ( image ) , extent = image . get_extent ( ) , coordinates = \"data\" , style = { \"alpha\" : image . get_alpha ( ) , \"zorder\" : image . get_zorder ( ) } , mplobj = image )", "docstring_tokens": "Process a matplotlib image object and call renderer . draw_image", "label": 0}, {"idx": "cosqa-train-3895", "doc": "python 3 localize timezone", "code": "def localize(dt):\n    \"\"\"Localize a datetime object to local time.\"\"\"\n    if dt.tzinfo is UTC:\n        return (dt + LOCAL_UTC_OFFSET).replace(tzinfo=None)\n    # No TZ info so not going to assume anything, return as-is.\n    return dt", "code_tokens": "def localize ( dt ) : if dt . tzinfo is UTC : return ( dt + LOCAL_UTC_OFFSET ) . replace ( tzinfo = None ) # No TZ info so not going to assume anything, return as-is. return dt", "docstring_tokens": "Localize a datetime object to local time .", "label": 1}, {"idx": "cosqa-train-3896", "doc": "replace empty cells in datframe as nans in python", "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True):\n    \"\"\"Clean a pandas dataframe by:\n        1. Filling empty values with Nan\n        2. Dropping columns with all empty values\n\n    Args:\n        df: Pandas DataFrame\n        fill_nan (bool): If any empty values (strings, None, etc) should be replaced with NaN\n        drop_empty_columns (bool): If columns whose values are all empty should be dropped\n\n    Returns:\n        DataFrame: cleaned DataFrame\n\n    \"\"\"\n    if fill_nan:\n        df = df.fillna(value=np.nan)\n    if drop_empty_columns:\n        df = df.dropna(axis=1, how='all')\n    return df.sort_index()", "code_tokens": "def clean_df ( df , fill_nan = True , drop_empty_columns = True ) : if fill_nan : df = df . fillna ( value = np . nan ) if drop_empty_columns : df = df . dropna ( axis = 1 , how = 'all' ) return df . sort_index ( )", "docstring_tokens": "Clean a pandas dataframe by : 1 . Filling empty values with Nan 2 . Dropping columns with all empty values", "label": 0}, {"idx": "cosqa-train-3897", "doc": "python 3 queue see all elements of a queue", "code": "def pop_all(self):\n        \"\"\"\n        NON-BLOCKING POP ALL IN QUEUE, IF ANY\n        \"\"\"\n        with self.lock:\n            output = list(self.queue)\n            self.queue.clear()\n\n        return output", "code_tokens": "def pop_all ( self ) : with self . lock : output = list ( self . queue ) self . queue . clear ( ) return output", "docstring_tokens": "NON - BLOCKING POP ALL IN QUEUE IF ANY", "label": 0}, {"idx": "cosqa-train-3898", "doc": "replace none value with blank string in python 3", "code": "def join(mapping, bind, values):\n    \"\"\" Merge all the strings. Put space between them. \"\"\"\n    return [' '.join([six.text_type(v) for v in values if v is not None])]", "code_tokens": "def join ( mapping , bind , values ) : return [ ' ' . join ( [ six . text_type ( v ) for v in values if v is not None ] ) ]", "docstring_tokens": "Merge all the strings . Put space between them .", "label": 0}, {"idx": "cosqa-train-3899", "doc": "python 3 recursivity how to clear the memory", "code": "def invalidate_cache(cpu, address, size):\n        \"\"\" remove decoded instruction from instruction cache \"\"\"\n        cache = cpu.instruction_cache\n        for offset in range(size):\n            if address + offset in cache:\n                del cache[address + offset]", "code_tokens": "def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]", "docstring_tokens": "remove decoded instruction from instruction cache", "label": 1}, {"idx": "cosqa-train-3900", "doc": "replace paragraphs docx python", "code": "def _replace_docstring_header(paragraph):\n    \"\"\"Process NumPy-like function docstrings.\"\"\"\n\n    # Replace Markdown headers in docstrings with light headers in bold.\n    paragraph = re.sub(_docstring_header_pattern,\n                       r'*\\1*',\n                       paragraph,\n                       )\n\n    paragraph = re.sub(_docstring_parameters_pattern,\n                       r'\\n* `\\1` (\\2)\\n',\n                       paragraph,\n                       )\n\n    return paragraph", "code_tokens": "def _replace_docstring_header ( paragraph ) : # Replace Markdown headers in docstrings with light headers in bold. paragraph = re . sub ( _docstring_header_pattern , r'*\\1*' , paragraph , ) paragraph = re . sub ( _docstring_parameters_pattern , r'\\n* `\\1` (\\2)\\n' , paragraph , ) return paragraph", "docstring_tokens": "Process NumPy - like function docstrings .", "label": 0}, {"idx": "cosqa-train-3901", "doc": "python 3 remove all letters from start of a string that are not", "code": "def _to_lower_alpha_only(s):\n    \"\"\"Return a lowercased string with non alphabetic chars removed.\n\n    White spaces are not to be removed.\"\"\"\n    s = re.sub(r'\\n', ' ',  s.lower())\n    return re.sub(r'[^a-z\\s]', '', s)", "code_tokens": "def _to_lower_alpha_only ( s ) : s = re . sub ( r'\\n' , ' ' , s . lower ( ) ) return re . sub ( r'[^a-z\\s]' , '' , s )", "docstring_tokens": "Return a lowercased string with non alphabetic chars removed .", "label": 0}, {"idx": "cosqa-train-3902", "doc": "replace raise function with keyword python", "code": "def raise_(exception=ABSENT, *args, **kwargs):\n    \"\"\"Raise (or re-raises) an exception.\n\n    :param exception: Exception object to raise, or an exception class.\n                      In the latter case, remaining arguments are passed\n                      to the exception's constructor.\n                      If omitted, the currently handled exception is re-raised.\n    \"\"\"\n    if exception is ABSENT:\n        raise\n    else:\n        if inspect.isclass(exception):\n            raise exception(*args, **kwargs)\n        else:\n            if args or kwargs:\n                raise TypeError(\"can't pass arguments along with \"\n                                \"exception object to raise_()\")\n            raise exception", "code_tokens": "def raise_ ( exception = ABSENT , * args , * * kwargs ) : if exception is ABSENT : raise else : if inspect . isclass ( exception ) : raise exception ( * args , * * kwargs ) else : if args or kwargs : raise TypeError ( \"can't pass arguments along with \" \"exception object to raise_()\" ) raise exception", "docstring_tokens": "Raise ( or re - raises ) an exception .", "label": 0}, {"idx": "cosqa-train-3903", "doc": "python 3 send text message", "code": "async def _send_plain_text(self, request: Request, stack: Stack):\n        \"\"\"\n        Sends plain text using `_send_text()`.\n        \"\"\"\n\n        await self._send_text(request, stack, None)", "code_tokens": "async def _send_plain_text ( self , request : Request , stack : Stack ) : await self . _send_text ( request , stack , None )", "docstring_tokens": "Sends plain text using _send_text () .", "label": 1}, {"idx": "cosqa-train-3904", "doc": "replace vowels in python with an underscore", "code": "def underscore(text):\n    \"\"\"Converts text that may be camelcased into an underscored format\"\"\"\n    return UNDERSCORE[1].sub(r'\\1_\\2', UNDERSCORE[0].sub(r'\\1_\\2', text)).lower()", "code_tokens": "def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\\1_\\2' , UNDERSCORE [ 0 ] . sub ( r'\\1_\\2' , text ) ) . lower ( )", "docstring_tokens": "Converts text that may be camelcased into an underscored format", "label": 0}, {"idx": "cosqa-train-3905", "doc": "python 3 traceback object tb", "code": "def from_traceback(cls, tb):\n        \"\"\" Construct a Bytecode from the given traceback \"\"\"\n        while tb.tb_next:\n            tb = tb.tb_next\n        return cls(tb.tb_frame.f_code, current_offset=tb.tb_lasti)", "code_tokens": "def from_traceback ( cls , tb ) : while tb . tb_next : tb = tb . tb_next return cls ( tb . tb_frame . f_code , current_offset = tb . tb_lasti )", "docstring_tokens": "Construct a Bytecode from the given traceback", "label": 0}, {"idx": "cosqa-train-3906", "doc": "replacing letters with underscores python", "code": "def camel_to_underscore(string):\n    \"\"\"Convert camelcase to lowercase and underscore.\n\n    Recipe from http://stackoverflow.com/a/1176023\n\n    Args:\n        string (str): The string to convert.\n\n    Returns:\n        str: The converted string.\n    \"\"\"\n    string = FIRST_CAP_RE.sub(r'\\1_\\2', string)\n    return ALL_CAP_RE.sub(r'\\1_\\2', string).lower()", "code_tokens": "def camel_to_underscore ( string ) : string = FIRST_CAP_RE . sub ( r'\\1_\\2' , string ) return ALL_CAP_RE . sub ( r'\\1_\\2' , string ) . lower ( )", "docstring_tokens": "Convert camelcase to lowercase and underscore .", "label": 0}, {"idx": "cosqa-train-3907", "doc": "python 35 multiprocessing pool object", "code": "def compute(args):\n    x, y, params = args\n    \"\"\"Callable function for the multiprocessing pool.\"\"\"\n    return x, y, mandelbrot(x, y, params)", "code_tokens": "def compute ( args ) : x , y , params = args return x , y , mandelbrot ( x , y , params )", "docstring_tokens": "Callable function for the multiprocessing pool .", "label": 0}, {"idx": "cosqa-train-3908", "doc": "requests python mime type", "code": "def python_mime(fn):\n    \"\"\"\n    Decorator, which adds correct MIME type for python source to the decorated\n    bottle API function.\n    \"\"\"\n    @wraps(fn)\n    def python_mime_decorator(*args, **kwargs):\n        response.content_type = \"text/x-python\"\n\n        return fn(*args, **kwargs)\n\n    return python_mime_decorator", "code_tokens": "def python_mime ( fn ) : @ wraps ( fn ) def python_mime_decorator ( * args , * * kwargs ) : response . content_type = \"text/x-python\" return fn ( * args , * * kwargs ) return python_mime_decorator", "docstring_tokens": "Decorator which adds correct MIME type for python source to the decorated bottle API function .", "label": 0}, {"idx": "cosqa-train-3909", "doc": "python 3d coordinate data structure", "code": "def list(self):\n        \"\"\"position in 3d space\"\"\"\n        return [self._pos3d.x, self._pos3d.y, self._pos3d.z]", "code_tokens": "def list ( self ) : return [ self . _pos3d . x , self . _pos3d . y , self . _pos3d . z ]", "docstring_tokens": "position in 3d space", "label": 0}, {"idx": "cosqa-train-3910", "doc": "resize 3 dimensional image zoom out numpy python", "code": "def _scale_shape(dshape, scale = (1,1,1)):\n    \"\"\"returns the shape after scaling (should be the same as ndimage.zoom\"\"\"\n    nshape = np.round(np.array(dshape) * np.array(scale))\n    return tuple(nshape.astype(np.int))", "code_tokens": "def _scale_shape ( dshape , scale = ( 1 , 1 , 1 ) ) : nshape = np . round ( np . array ( dshape ) * np . array ( scale ) ) return tuple ( nshape . astype ( np . int ) )", "docstring_tokens": "returns the shape after scaling ( should be the same as ndimage . zoom", "label": 0}, {"idx": "cosqa-train-3911", "doc": "python access a dict by key with default", "code": "def get_value(key, obj, default=missing):\n    \"\"\"Helper for pulling a keyed value off various types of objects\"\"\"\n    if isinstance(key, int):\n        return _get_value_for_key(key, obj, default)\n    return _get_value_for_keys(key.split('.'), obj, default)", "code_tokens": "def get_value ( key , obj , default = missing ) : if isinstance ( key , int ) : return _get_value_for_key ( key , obj , default ) return _get_value_for_keys ( key . split ( '.' ) , obj , default )", "docstring_tokens": "Helper for pulling a keyed value off various types of objects", "label": 0}, {"idx": "cosqa-train-3912", "doc": "retreieve column name for minimum value in row python", "code": "def index(self, value):\n\t\t\"\"\"\n\t\tReturn the smallest index of the row(s) with this column\n\t\tequal to value.\n\t\t\"\"\"\n\t\tfor i in xrange(len(self.parentNode)):\n\t\t\tif getattr(self.parentNode[i], self.Name) == value:\n\t\t\t\treturn i\n\t\traise ValueError(value)", "code_tokens": "def index ( self , value ) : for i in xrange ( len ( self . parentNode ) ) : if getattr ( self . parentNode [ i ] , self . Name ) == value : return i raise ValueError ( value )", "docstring_tokens": "Return the smallest index of the row ( s ) with this column equal to value .", "label": 0}, {"idx": "cosqa-train-3913", "doc": "python add 2 weeks onto date", "code": "def weekly(date=datetime.date.today()):\n    \"\"\"\n    Weeks start are fixes at Monday for now.\n    \"\"\"\n    return date - datetime.timedelta(days=date.weekday())", "code_tokens": "def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )", "docstring_tokens": "Weeks start are fixes at Monday for now .", "label": 0}, {"idx": "cosqa-train-3914", "doc": "retrieving data from apis with python", "code": "def get_package_info(package):\n    \"\"\"Gets the PyPI information for a given package.\"\"\"\n    url = 'https://pypi.python.org/pypi/{}/json'.format(package)\n    r = requests.get(url)\n    r.raise_for_status()\n    return r.json()", "code_tokens": "def get_package_info ( package ) : url = 'https://pypi.python.org/pypi/{}/json' . format ( package ) r = requests . get ( url ) r . raise_for_status ( ) return r . json ( )", "docstring_tokens": "Gets the PyPI information for a given package .", "label": 0}, {"idx": "cosqa-train-3915", "doc": "python add a default to dictionary", "code": "def setdefault(obj, field, default):\n    \"\"\"Set an object's field to default if it doesn't have a value\"\"\"\n    setattr(obj, field, getattr(obj, field, default))", "code_tokens": "def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )", "docstring_tokens": "Set an object s field to default if it doesn t have a value", "label": 0}, {"idx": "cosqa-train-3916", "doc": "return float from string python", "code": "def energy_string_to_float( string ):\n    \"\"\"\n    Convert a string of a calculation energy, e.g. '-1.2345 eV' to a float.\n\n    Args:\n        string (str): The string to convert.\n  \n    Return\n        (float) \n    \"\"\"\n    energy_re = re.compile( \"(-?\\d+\\.\\d+)\" )\n    return float( energy_re.match( string ).group(0) )", "code_tokens": "def energy_string_to_float ( string ) : energy_re = re . compile ( \"(-?\\d+\\.\\d+)\" ) return float ( energy_re . match ( string ) . group ( 0 ) )", "docstring_tokens": "Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float .", "label": 0}, {"idx": "cosqa-train-3917", "doc": "python add a variable to self", "code": "def _add(self, codeobj):\n        \"\"\"Add a child (variable) to this object.\"\"\"\n        assert isinstance(codeobj, CodeVariable)\n        self.variables.append(codeobj)", "code_tokens": "def _add ( self , codeobj ) : assert isinstance ( codeobj , CodeVariable ) self . variables . append ( codeobj )", "docstring_tokens": "Add a child ( variable ) to this object .", "label": 0}, {"idx": "cosqa-train-3918", "doc": "return hash key as a list python", "code": "def keys(self):\n        \"\"\"Return a list of all keys in the dictionary.\n\n        Returns:\n            list of str: [key1,key2,...,keyN]\n        \"\"\"\n        all_keys = [k.decode('utf-8') for k,v in self.rdb.hgetall(self.session_hash).items()]\n        return all_keys", "code_tokens": "def keys ( self ) : all_keys = [ k . decode ( 'utf-8' ) for k , v in self . rdb . hgetall ( self . session_hash ) . items ( ) ] return all_keys", "docstring_tokens": "Return a list of all keys in the dictionary .", "label": 1}, {"idx": "cosqa-train-3919", "doc": "python add attributes mock", "code": "def mock_add_spec(self, spec, spec_set=False):\n        \"\"\"Add a spec to a mock. `spec` can either be an object or a\n        list of strings. Only attributes on the `spec` can be fetched as\n        attributes from the mock.\n\n        If `spec_set` is True then only attributes on the spec can be set.\"\"\"\n        self._mock_add_spec(spec, spec_set)\n        self._mock_set_magics()", "code_tokens": "def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )", "docstring_tokens": "Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock .", "label": 0}, {"idx": "cosqa-train-3920", "doc": "return just key of counter object python", "code": "def make_key(observer):\n        \"\"\"Construct a unique, hashable, immutable key for an observer.\"\"\"\n\n        if hasattr(observer, \"__self__\"):\n            inst = observer.__self__\n            method_name = observer.__name__\n            key = (id(inst), method_name)\n        else:\n            key = id(observer)\n        return key", "code_tokens": "def make_key ( observer ) : if hasattr ( observer , \"__self__\" ) : inst = observer . __self__ method_name = observer . __name__ key = ( id ( inst ) , method_name ) else : key = id ( observer ) return key", "docstring_tokens": "Construct a unique hashable immutable key for an observer .", "label": 0}, {"idx": "cosqa-train-3921", "doc": "python add attributes to existing dict object", "code": "def update_dict(obj, dict, attributes):\n    \"\"\"Update dict with fields from obj.attributes.\n\n    :param obj: the object updated into dict\n    :param dict: the result dictionary\n    :param attributes: a list of attributes belonging to obj\n    \"\"\"\n    for attribute in attributes:\n        if hasattr(obj, attribute) and getattr(obj, attribute) is not None:\n            dict[attribute] = getattr(obj, attribute)", "code_tokens": "def update_dict ( obj , dict , attributes ) : for attribute in attributes : if hasattr ( obj , attribute ) and getattr ( obj , attribute ) is not None : dict [ attribute ] = getattr ( obj , attribute )", "docstring_tokens": "Update dict with fields from obj . attributes .", "label": 0}, {"idx": "cosqa-train-3922", "doc": "return number of non whitespace characters in string python", "code": "def _count_leading_whitespace(text):\n  \"\"\"Returns the number of characters at the beginning of text that are whitespace.\"\"\"\n  idx = 0\n  for idx, char in enumerate(text):\n    if not char.isspace():\n      return idx\n  return idx + 1", "code_tokens": "def _count_leading_whitespace ( text ) : idx = 0 for idx , char in enumerate ( text ) : if not char . isspace ( ) : return idx return idx + 1", "docstring_tokens": "Returns the number of characters at the beginning of text that are whitespace .", "label": 0}, {"idx": "cosqa-train-3923", "doc": "python add behavier to call method on an object", "code": "def get_attr(self, method_name):\n        \"\"\"Get attribute from the target object\"\"\"\n        return self.attrs.get(method_name) or self.get_callable_attr(method_name)", "code_tokens": "def get_attr ( self , method_name ) : return self . attrs . get ( method_name ) or self . get_callable_attr ( method_name )", "docstring_tokens": "Get attribute from the target object", "label": 0}, {"idx": "cosqa-train-3924", "doc": "return rows with one field not null in python", "code": "def selectnotnone(table, field, complement=False):\n    \"\"\"Select rows where the given field is not `None`.\"\"\"\n\n    return select(table, field, lambda v: v is not None,\n                  complement=complement)", "code_tokens": "def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )", "docstring_tokens": "Select rows where the given field is not None .", "label": 1}, {"idx": "cosqa-train-3925", "doc": "python add blank column to dataframae", "code": "def add_blank_row(self, label):\n        \"\"\"\n        Add a blank row with only an index value to self.df.\n        This is done inplace.\n        \"\"\"\n        col_labels = self.df.columns\n        blank_item = pd.Series({}, index=col_labels, name=label)\n        # use .loc to add in place (append won't do that)\n        self.df.loc[blank_item.name] = blank_item\n        return self.df", "code_tokens": "def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df", "docstring_tokens": "Add a blank row with only an index value to self . df . This is done inplace .", "label": 0}, {"idx": "cosqa-train-3926", "doc": "return the identifier of a variable python", "code": "def get_attribute_name_id(attr):\n    \"\"\"\n    Return the attribute name identifier\n    \"\"\"\n    return attr.value.id if isinstance(attr.value, ast.Name) else None", "code_tokens": "def get_attribute_name_id ( attr ) : return attr . value . id if isinstance ( attr . value , ast . Name ) else None", "docstring_tokens": "Return the attribute name identifier", "label": 0}, {"idx": "cosqa-train-3927", "doc": "python add dynamic property to object", "code": "def set_property(self, key, value):\n        \"\"\"\n        Update only one property in the dict\n        \"\"\"\n        self.properties[key] = value\n        self.sync_properties()", "code_tokens": "def set_property ( self , key , value ) : self . properties [ key ] = value self . sync_properties ( )", "docstring_tokens": "Update only one property in the dict", "label": 0}, {"idx": "cosqa-train-3928", "doc": "reverse dimension of a matrix in python", "code": "def _shape(self):\n        \"\"\"Return the tensor shape of the matrix operator\"\"\"\n        return tuple(reversed(self.output_dims())) + tuple(\n            reversed(self.input_dims()))", "code_tokens": "def _shape ( self ) : return tuple ( reversed ( self . output_dims ( ) ) ) + tuple ( reversed ( self . input_dims ( ) ) )", "docstring_tokens": "Return the tensor shape of the matrix operator", "label": 0}, {"idx": "cosqa-train-3929", "doc": "python add json to request", "code": "def set_json_item(key, value):\n    \"\"\" manipulate json data on the fly\n    \"\"\"\n    data = get_json()\n    data[key] = value\n\n    request = get_request()\n    request[\"BODY\"] = json.dumps(data)", "code_tokens": "def set_json_item ( key , value ) : data = get_json ( ) data [ key ] = value request = get_request ( ) request [ \"BODY\" ] = json . dumps ( data )", "docstring_tokens": "manipulate json data on the fly", "label": 1}, {"idx": "cosqa-train-3930", "doc": "rewriting array pointer in c language with python ctypes", "code": "def cfloat64_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes double pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_double)):\n        return np.fromiter(cptr, dtype=np.float64, count=length)\n    else:\n        raise RuntimeError('Expected double pointer')", "code_tokens": "def cfloat64_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_double ) ) : return np . fromiter ( cptr , dtype = np . float64 , count = length ) else : raise RuntimeError ( 'Expected double pointer' )", "docstring_tokens": "Convert a ctypes double pointer array to a numpy array .", "label": 0}, {"idx": "cosqa-train-3931", "doc": "python add parser as subparser", "code": "def sub(name, func,**kwarg):\n    \"\"\" Add subparser\n\n    \"\"\"\n    sp = subparsers.add_parser(name, **kwarg)\n    sp.set_defaults(func=func)\n    sp.arg = sp.add_argument\n    return sp", "code_tokens": "def sub ( name , func , * * kwarg ) : sp = subparsers . add_parser ( name , * * kwarg ) sp . set_defaults ( func = func ) sp . arg = sp . add_argument return sp", "docstring_tokens": "Add subparser", "label": 0}, {"idx": "cosqa-train-3932", "doc": "python add text to an image and save", "code": "def add_text_to_image(fname, txt, opFilename):\n    \"\"\" convert an image by adding text \"\"\"\n    ft = ImageFont.load(\"T://user//dev//src//python//_AS_LIB//timR24.pil\")\n    #wh = ft.getsize(txt)\n    print(\"Adding text \", txt, \" to \", fname, \" pixels wide to file \" , opFilename)\n    im = Image.open(fname)\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), txt, fill=(0, 0, 0), font=ft)\n    del draw  \n    im.save(opFilename)", "code_tokens": "def add_text_to_image ( fname , txt , opFilename ) : ft = ImageFont . load ( \"T://user//dev//src//python//_AS_LIB//timR24.pil\" ) #wh = ft.getsize(txt) print ( \"Adding text \" , txt , \" to \" , fname , \" pixels wide to file \" , opFilename ) im = Image . open ( fname ) draw = ImageDraw . Draw ( im ) draw . text ( ( 0 , 0 ) , txt , fill = ( 0 , 0 , 0 ) , font = ft ) del draw im . save ( opFilename )", "docstring_tokens": "convert an image by adding text", "label": 0}, {"idx": "cosqa-train-3933", "doc": "roc auc curve in python", "code": "def roc_auc(y_true, y_score):\n    \"\"\"\n    Returns are under the ROC curve\n    \"\"\"\n    notnull = ~np.isnan(y_true)\n    fpr, tpr, thresholds = sklearn.metrics.roc_curve(y_true[notnull], y_score[notnull])\n    return sklearn.metrics.auc(fpr, tpr)", "code_tokens": "def roc_auc ( y_true , y_score ) : notnull = ~ np . isnan ( y_true ) fpr , tpr , thresholds = sklearn . metrics . roc_curve ( y_true [ notnull ] , y_score [ notnull ] ) return sklearn . metrics . auc ( fpr , tpr )", "docstring_tokens": "Returns are under the ROC curve", "label": 1}, {"idx": "cosqa-train-3934", "doc": "python and how to create a datetime from a date", "code": "def _datetime_to_date(arg):\n    \"\"\"\n    convert datetime/str to date\n    :param arg:\n    :return:\n    \"\"\"\n    _arg = parse(arg)\n    if isinstance(_arg, datetime.datetime):\n        _arg = _arg.date()\n    return _arg", "code_tokens": "def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "docstring_tokens": "convert datetime / str to date : param arg : : return :", "label": 0}, {"idx": "cosqa-train-3935", "doc": "rotate an array to its left in python", "code": "def rotateImage(image, angle):\n    \"\"\"\n        rotates a 2d array to a multiple of 90 deg.\n        0 = default\n        1 = 90 deg. cw\n        2 = 180 deg.\n        3 = 90 deg. ccw\n    \"\"\"\n    image = [list(row) for row in image]\n\n    for n in range(angle % 4):\n        image = list(zip(*image[::-1]))\n\n    return image", "code_tokens": "def rotateImage ( image , angle ) : image = [ list ( row ) for row in image ] for n in range ( angle % 4 ) : image = list ( zip ( * image [ : : - 1 ] ) ) return image", "docstring_tokens": "rotates a 2d array to a multiple of 90 deg . 0 = default 1 = 90 deg . cw 2 = 180 deg . 3 = 90 deg . ccw", "label": 0}, {"idx": "cosqa-train-3936", "doc": "python angle between two vectors", "code": "def vec_angle(a, b):\n    \"\"\"\n    Calculate angle between two vectors\n    \"\"\"\n    cosang = np.dot(a, b)\n    sinang = fast_norm(np.cross(a, b))\n    return np.arctan2(sinang, cosang)", "code_tokens": "def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )", "docstring_tokens": "Calculate angle between two vectors", "label": 0}, {"idx": "cosqa-train-3937", "doc": "rotate matrix in place python", "code": "def similarity_transformation(rot, mat):\n    \"\"\" R x M x R^-1 \"\"\"\n    return np.dot(rot, np.dot(mat, np.linalg.inv(rot)))", "code_tokens": "def similarity_transformation ( rot , mat ) : return np . dot ( rot , np . dot ( mat , np . linalg . inv ( rot ) ) )", "docstring_tokens": "R x M x R^ - 1", "label": 0}, {"idx": "cosqa-train-3938", "doc": "python api paged responses", "code": "def _iter_response(self, url, params=None):\n        \"\"\"Return an enumerable that iterates through a multi-page API request\"\"\"\n        if params is None:\n            params = {}\n        params['page_number'] = 1\n\n        # Last page lists itself as next page\n        while True:\n            response = self._request(url, params)\n\n            for item in response['result_data']:\n                yield item\n\n            # Last page lists itself as next page\n            if response['service_meta']['next_page_number'] == params['page_number']:\n                break\n\n            params['page_number'] += 1", "code_tokens": "def _iter_response ( self , url , params = None ) : if params is None : params = { } params [ 'page_number' ] = 1 # Last page lists itself as next page while True : response = self . _request ( url , params ) for item in response [ 'result_data' ] : yield item # Last page lists itself as next page if response [ 'service_meta' ] [ 'next_page_number' ] == params [ 'page_number' ] : break params [ 'page_number' ] += 1", "docstring_tokens": "Return an enumerable that iterates through a multi - page API request", "label": 0}, {"idx": "cosqa-train-3939", "doc": "round to significant figures in python", "code": "def round_figures(x, n):\n    \"\"\"Returns x rounded to n significant figures.\"\"\"\n    return round(x, int(n - math.ceil(math.log10(abs(x)))))", "code_tokens": "def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )", "docstring_tokens": "Returns x rounded to n significant figures .", "label": 1}, {"idx": "cosqa-train-3940", "doc": "python api requestion bearer token", "code": "def fetch_token(self, **kwargs):\n        \"\"\"Exchange a code (and 'state' token) for a bearer token\"\"\"\n        return super(AsanaOAuth2Session, self).fetch_token(self.token_url, client_secret=self.client_secret, **kwargs)", "code_tokens": "def fetch_token ( self , * * kwargs ) : return super ( AsanaOAuth2Session , self ) . fetch_token ( self . token_url , client_secret = self . client_secret , * * kwargs )", "docstring_tokens": "Exchange a code ( and state token ) for a bearer token", "label": 0}, {"idx": "cosqa-train-3941", "doc": "run flake8 python powershell", "code": "def lint(args):\n    \"\"\"Run lint checks using flake8.\"\"\"\n    application = get_current_application()\n    if not args:\n        args = [application.name, 'tests']\n    args = ['flake8'] + list(args)\n    run.main(args, standalone_mode=False)", "code_tokens": "def lint ( args ) : application = get_current_application ( ) if not args : args = [ application . name , 'tests' ] args = [ 'flake8' ] + list ( args ) run . main ( args , standalone_mode = False )", "docstring_tokens": "Run lint checks using flake8 .", "label": 0}, {"idx": "cosqa-train-3942", "doc": "python api to get definitions for words", "code": "def contains_extractor(document):\n    \"\"\"A basic document feature extractor that returns a dict of words that the\n    document contains.\"\"\"\n    tokens = _get_document_tokens(document)\n    features = dict((u'contains({0})'.format(w), True) for w in tokens)\n    return features", "code_tokens": "def contains_extractor ( document ) : tokens = _get_document_tokens ( document ) features = dict ( ( u'contains({0})' . format ( w ) , True ) for w in tokens ) return features", "docstring_tokens": "A basic document feature extractor that returns a dict of words that the document contains .", "label": 0}, {"idx": "cosqa-train-3943", "doc": "run python file supervisorctl", "code": "def _handle_shell(self,cfg_file,*args,**options):\n        \"\"\"Command 'supervisord shell' runs the interactive command shell.\"\"\"\n        args = (\"--interactive\",) + args\n        return supervisorctl.main((\"-c\",cfg_file) + args)", "code_tokens": "def _handle_shell ( self , cfg_file , * args , * * options ) : args = ( \"--interactive\" , ) + args return supervisorctl . main ( ( \"-c\" , cfg_file ) + args )", "docstring_tokens": "Command supervisord shell runs the interactive command shell .", "label": 0}, {"idx": "cosqa-train-3944", "doc": "python apply function on colulmn", "code": "def interpolate(table, field, fmt, **kwargs):\n    \"\"\"\n    Convenience function to interpolate all values in the given `field` using\n    the `fmt` string.\n\n    The ``where`` keyword argument can be given with a callable or expression\n    which is evaluated on each row and which should return True if the\n    conversion should be applied on that row, else False.\n\n    \"\"\"\n\n    conv = lambda v: fmt % v\n    return convert(table, field, conv, **kwargs)", "code_tokens": "def interpolate ( table , field , fmt , * * kwargs ) : conv = lambda v : fmt % v return convert ( table , field , conv , * * kwargs )", "docstring_tokens": "Convenience function to interpolate all values in the given field using the fmt string .", "label": 0}, {"idx": "cosqa-train-3945", "doc": "run the command at background and return the result python", "code": "def execute_in_background(self):\n        \"\"\"Executes a (shell) command in the background\n\n        :return: the process' pid\n        \"\"\"\n        # http://stackoverflow.com/questions/1605520\n        args = shlex.split(self.cmd)\n        p = Popen(args)\n        return p.pid", "code_tokens": "def execute_in_background ( self ) : # http://stackoverflow.com/questions/1605520 args = shlex . split ( self . cmd ) p = Popen ( args ) return p . pid", "docstring_tokens": "Executes a ( shell ) command in the background", "label": 1}, {"idx": "cosqa-train-3946", "doc": "python apply function to an array parallel", "code": "def apply(f, obj, *args, **kwargs):\n    \"\"\"Apply a function in parallel to each element of the input\"\"\"\n    return vectorize(f)(obj, *args, **kwargs)", "code_tokens": "def apply ( f , obj , * args , * * kwargs ) : return vectorize ( f ) ( obj , * args , * * kwargs )", "docstring_tokens": "Apply a function in parallel to each element of the input", "label": 0}, {"idx": "cosqa-train-3947", "doc": "running a bash script in python", "code": "def bash(filename):\n    \"\"\"Runs a bash script in the local directory\"\"\"\n    sys.stdout.flush()\n    subprocess.call(\"bash {}\".format(filename), shell=True)", "code_tokens": "def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( \"bash {}\" . format ( filename ) , shell = True )", "docstring_tokens": "Runs a bash script in the local directory", "label": 0}, {"idx": "cosqa-train-3948", "doc": "python apply lisp function", "code": "def to_lisp(o, keywordize_keys: bool = True):\n    \"\"\"Recursively convert Python collections into Lisp collections.\"\"\"\n    if not isinstance(o, (dict, frozenset, list, set, tuple)):\n        return o\n    else:  # pragma: no cover\n        return _to_lisp_backup(o, keywordize_keys=keywordize_keys)", "code_tokens": "def to_lisp ( o , keywordize_keys : bool = True ) : if not isinstance ( o , ( dict , frozenset , list , set , tuple ) ) : return o else : # pragma: no cover return _to_lisp_backup ( o , keywordize_keys = keywordize_keys )", "docstring_tokens": "Recursively convert Python collections into Lisp collections .", "label": 0}, {"idx": "cosqa-train-3949", "doc": "running average of 2d array python", "code": "def movingaverage(arr, window):\n    \"\"\"\n    Calculates the moving average (\"rolling mean\") of an array\n    of a certain window size.\n    \"\"\"\n    m = np.ones(int(window)) / int(window)\n    return scipy.ndimage.convolve1d(arr, m, axis=0, mode='reflect')", "code_tokens": "def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )", "docstring_tokens": "Calculates the moving average ( rolling mean ) of an array of a certain window size .", "label": 0}, {"idx": "cosqa-train-3950", "doc": "python apply rotation matrix to image", "code": "def rotateImage(img, angle):\n    \"\"\"\n\n    querries scipy.ndimage.rotate routine\n    :param img: image to be rotated\n    :param angle: angle to be rotated (radian)\n    :return: rotated image\n    \"\"\"\n    imgR = scipy.ndimage.rotate(img, angle, reshape=False)\n    return imgR", "code_tokens": "def rotateImage ( img , angle ) : imgR = scipy . ndimage . rotate ( img , angle , reshape = False ) return imgR", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-3951", "doc": "running jar dependancy in python", "code": "def version_jar(self):\n\t\t\"\"\"\n\t\tSpecial case of version() when the executable is a JAR file.\n\t\t\"\"\"\n\t\tcmd = config.get_command('java')\n\t\tcmd.append('-jar')\n\t\tcmd += self.cmd\n\t\tself.version(cmd=cmd, path=self.cmd[0])", "code_tokens": "def version_jar ( self ) : cmd = config . get_command ( 'java' ) cmd . append ( '-jar' ) cmd += self . cmd self . version ( cmd = cmd , path = self . cmd [ 0 ] )", "docstring_tokens": "Special case of version () when the executable is a JAR file .", "label": 0}, {"idx": "cosqa-train-3952", "doc": "python applying functions to tables", "code": "def make_table_map(table, headers):\n    \"\"\"Create a function to map from rows with the structure of the headers to the structure of the table.\"\"\"\n\n    header_parts = {}\n    for i, h in enumerate(headers):\n        header_parts[h] = 'row[{}]'.format(i)\n\n    body_code = 'lambda row: [{}]'.format(','.join(header_parts.get(c.name, 'None') for c in table.columns))\n    header_code = 'lambda row: [{}]'.format(\n        ','.join(header_parts.get(c.name, \"'{}'\".format(c.name)) for c in table.columns))\n\n    return eval(header_code), eval(body_code)", "code_tokens": "def make_table_map ( table , headers ) : header_parts = { } for i , h in enumerate ( headers ) : header_parts [ h ] = 'row[{}]' . format ( i ) body_code = 'lambda row: [{}]' . format ( ',' . join ( header_parts . get ( c . name , 'None' ) for c in table . columns ) ) header_code = 'lambda row: [{}]' . format ( ',' . join ( header_parts . get ( c . name , \"'{}'\" . format ( c . name ) ) for c in table . columns ) ) return eval ( header_code ) , eval ( body_code )", "docstring_tokens": "Create a function to map from rows with the structure of the headers to the structure of the table .", "label": 1}, {"idx": "cosqa-train-3953", "doc": "running python unit tests command line", "code": "def test(*args):\n    \"\"\"\n    Run unit tests.\n    \"\"\"\n    subprocess.call([\"py.test-2.7\"] + list(args))\n    subprocess.call([\"py.test-3.4\"] + list(args))", "code_tokens": "def test ( * args ) : subprocess . call ( [ \"py.test-2.7\" ] + list ( args ) ) subprocess . call ( [ \"py.test-3.4\" ] + list ( args ) )", "docstring_tokens": "Run unit tests .", "label": 0}, {"idx": "cosqa-train-3954", "doc": "running python unit tests from command line", "code": "def test(*args):\n    \"\"\"\n    Run unit tests.\n    \"\"\"\n    subprocess.call([\"py.test-2.7\"] + list(args))\n    subprocess.call([\"py.test-3.4\"] + list(args))", "code_tokens": "def test ( * args ) : subprocess . call ( [ \"py.test-2.7\" ] + list ( args ) ) subprocess . call ( [ \"py.test-3.4\" ] + list ( args ) )", "docstring_tokens": "Run unit tests .", "label": 0}, {"idx": "cosqa-train-3955", "doc": "python arg parse valid values", "code": "def email_type(arg):\n\t\"\"\"An argparse type representing an email address.\"\"\"\n\tif not is_valid_email_address(arg):\n\t\traise argparse.ArgumentTypeError(\"{0} is not a valid email address\".format(repr(arg)))\n\treturn arg", "code_tokens": "def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( \"{0} is not a valid email address\" . format ( repr ( arg ) ) ) return arg", "docstring_tokens": "An argparse type representing an email address .", "label": 0}, {"idx": "cosqa-train-3956", "doc": "sagemaker put files to s3 python", "code": "def download_file(bucket_name, path, target, sagemaker_session):\n    \"\"\"Download a Single File from S3 into a local path\n\n    Args:\n        bucket_name (str): S3 bucket name\n        path (str): file path within the bucket\n        target (str): destination directory for the downloaded file.\n        sagemaker_session (:class:`sagemaker.session.Session`): a sagemaker session to interact with S3.\n    \"\"\"\n    path = path.lstrip('/')\n    boto_session = sagemaker_session.boto_session\n\n    s3 = boto_session.resource('s3')\n    bucket = s3.Bucket(bucket_name)\n    bucket.download_file(path, target)", "code_tokens": "def download_file ( bucket_name , path , target , sagemaker_session ) : path = path . lstrip ( '/' ) boto_session = sagemaker_session . boto_session s3 = boto_session . resource ( 's3' ) bucket = s3 . Bucket ( bucket_name ) bucket . download_file ( path , target )", "docstring_tokens": "Download a Single File from S3 into a local path", "label": 1}, {"idx": "cosqa-train-3957", "doc": "python argparse change usage", "code": "def add_arguments(parser):\n    \"\"\"\n    adds arguments for the swap urls command\n    \"\"\"\n    parser.add_argument('-o', '--old-environment', help='Old environment name', required=True)\n    parser.add_argument('-n', '--new-environment', help='New environment name', required=True)", "code_tokens": "def add_arguments ( parser ) : parser . add_argument ( '-o' , '--old-environment' , help = 'Old environment name' , required = True ) parser . add_argument ( '-n' , '--new-environment' , help = 'New environment name' , required = True )", "docstring_tokens": "adds arguments for the swap urls command", "label": 0}, {"idx": "cosqa-train-3958", "doc": "save array as column in python", "code": "def adapt_array(arr):\n    \"\"\"\n    Adapts a Numpy array into an ARRAY string to put into the database.\n\n    Parameters\n    ----------\n    arr: array\n        The Numpy array to be adapted into an ARRAY type that can be inserted into a SQL file.\n\n    Returns\n    -------\n    ARRAY\n            The adapted array object\n\n    \"\"\"\n    out = io.BytesIO()\n    np.save(out, arr), out.seek(0)\n    return buffer(out.read())", "code_tokens": "def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) , out . seek ( 0 ) return buffer ( out . read ( ) )", "docstring_tokens": "Adapts a Numpy array into an ARRAY string to put into the database .", "label": 0}, {"idx": "cosqa-train-3959", "doc": "python argparse json file", "code": "def main(args=sys.argv):\n    \"\"\"\n    main entry point for the jardiff CLI\n    \"\"\"\n\n    parser = create_optparser(args[0])\n    return cli(parser.parse_args(args[1:]))", "code_tokens": "def main ( args = sys . argv ) : parser = create_optparser ( args [ 0 ] ) return cli ( parser . parse_args ( args [ 1 : ] ) )", "docstring_tokens": "main entry point for the jardiff CLI", "label": 0}, {"idx": "cosqa-train-3960", "doc": "save as json file in python", "code": "def save(self, fname):\n        \"\"\" Saves the dictionary in json format\n        :param fname: file to save to\n        \"\"\"\n        with open(fname, 'wb') as f:\n            json.dump(self, f)", "code_tokens": "def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )", "docstring_tokens": "Saves the dictionary in json format : param fname : file to save to", "label": 0}, {"idx": "cosqa-train-3961", "doc": "python argparse make subparser repeatable", "code": "def set_subparsers_args(self, *args, **kwargs):\n        \"\"\"\n        Sets args and kwargs that are passed when creating a subparsers group\n        in an argparse.ArgumentParser i.e. when calling\n        argparser.ArgumentParser.add_subparsers\n        \"\"\"\n        self.subparsers_args = args\n        self.subparsers_kwargs = kwargs", "code_tokens": "def set_subparsers_args ( self , * args , * * kwargs ) : self . subparsers_args = args self . subparsers_kwargs = kwargs", "docstring_tokens": "Sets args and kwargs that are passed when creating a subparsers group in an argparse . ArgumentParser i . e . when calling argparser . ArgumentParser . add_subparsers", "label": 0}, {"idx": "cosqa-train-3962", "doc": "save json dict to file in python", "code": "def save(self, fname):\n        \"\"\" Saves the dictionary in json format\n        :param fname: file to save to\n        \"\"\"\n        with open(fname, 'wb') as f:\n            json.dump(self, f)", "code_tokens": "def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )", "docstring_tokens": "Saves the dictionary in json format : param fname : file to save to", "label": 0}, {"idx": "cosqa-train-3963", "doc": "python array \\ list what kind of variaable", "code": "def ensure_iterable(inst):\n    \"\"\"\n    Wraps scalars or string types as a list, or returns the iterable instance.\n    \"\"\"\n    if isinstance(inst, string_types):\n        return [inst]\n    elif not isinstance(inst, collections.Iterable):\n        return [inst]\n    else:\n        return inst", "code_tokens": "def ensure_iterable ( inst ) : if isinstance ( inst , string_types ) : return [ inst ] elif not isinstance ( inst , collections . Iterable ) : return [ inst ] else : return inst", "docstring_tokens": "Wraps scalars or string types as a list or returns the iterable instance .", "label": 0}, {"idx": "cosqa-train-3964", "doc": "save rds file in python rpy2", "code": "def sav_to_pandas_rpy2(input_file):\n    \"\"\"\n    SPSS .sav files to Pandas DataFrame through Rpy2\n\n    :param input_file: string\n\n    :return:\n    \"\"\"\n    import pandas.rpy.common as com\n\n    w = com.robj.r('foreign::read.spss(\"%s\", to.data.frame=TRUE)' % input_file)\n    return com.convert_robj(w)", "code_tokens": "def sav_to_pandas_rpy2 ( input_file ) : import pandas . rpy . common as com w = com . robj . r ( 'foreign::read.spss(\"%s\", to.data.frame=TRUE)' % input_file ) return com . convert_robj ( w )", "docstring_tokens": "SPSS . sav files to Pandas DataFrame through Rpy2", "label": 1}, {"idx": "cosqa-train-3965", "doc": "python array get last n element", "code": "def tail(self, n=10):\n        \"\"\"\n        Get an SArray that contains the last n elements in the SArray.\n\n        Parameters\n        ----------\n        n : int\n            The number of elements to fetch\n\n        Returns\n        -------\n        out : SArray\n            A new SArray which contains the last n rows of the current SArray.\n        \"\"\"\n        with cython_context():\n            return SArray(_proxy=self.__proxy__.tail(n))", "code_tokens": "def tail ( self , n = 10 ) : with cython_context ( ) : return SArray ( _proxy = self . __proxy__ . tail ( n ) )", "docstring_tokens": "Get an SArray that contains the last n elements in the SArray .", "label": 0}, {"idx": "cosqa-train-3966", "doc": "saving file on ftp using python", "code": "def write(url, content, **args):\n    \"\"\"Put an object into a ftps URL.\"\"\"\n    with FTPSResource(url, **args) as resource:\n        resource.write(content)", "code_tokens": "def write ( url , content , * * args ) : with FTPSResource ( url , * * args ) as resource : resource . write ( content )", "docstring_tokens": "Put an object into a ftps URL .", "label": 0}, {"idx": "cosqa-train-3967", "doc": "python array to nparray", "code": "def dump_nparray(self, obj, class_name=numpy_ndarray_class_name):\n        \"\"\"\n        ``numpy.ndarray`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: self._json_convert(obj.tolist())}", "code_tokens": "def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { \"$\" + class_name : self . _json_convert ( obj . tolist ( ) ) }", "docstring_tokens": "numpy . ndarray dumper .", "label": 0}, {"idx": "cosqa-train-3968", "doc": "second most recent file python", "code": "def newest_file(file_iterable):\n  \"\"\"\n  Returns the name of the newest file given an iterable of file names.\n\n  \"\"\"\n  return max(file_iterable, key=lambda fname: os.path.getmtime(fname))", "code_tokens": "def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )", "docstring_tokens": "Returns the name of the newest file given an iterable of file names .", "label": 0}, {"idx": "cosqa-train-3969", "doc": "python arrow now minus four days", "code": "def get_seconds_until_next_day(now=None):\n    \"\"\"\n    Returns the number of seconds until the next day (utc midnight). This is the long-term rate limit used by Strava.\n    :param now: A (utc) timestamp\n    :type now: arrow.arrow.Arrow\n    :return: the number of seconds until next day, as int\n    \"\"\"\n    if now is None:\n        now = arrow.utcnow()\n    return (now.ceil('day') - now).seconds", "code_tokens": "def get_seconds_until_next_day ( now = None ) : if now is None : now = arrow . utcnow ( ) return ( now . ceil ( 'day' ) - now ) . seconds", "docstring_tokens": "Returns the number of seconds until the next day ( utc midnight ) . This is the long - term rate limit used by Strava . : param now : A ( utc ) timestamp : type now : arrow . arrow . Arrow : return : the number of seconds until next day as int", "label": 0}, {"idx": "cosqa-train-3970", "doc": "select a dimension of tensor python", "code": "def unfolding(tens, i):\n    \"\"\"Compute the i-th unfolding of a tensor.\"\"\"\n    return reshape(tens.full(), (np.prod(tens.n[0:(i+1)]), -1))", "code_tokens": "def unfolding ( tens , i ) : return reshape ( tens . full ( ) , ( np . prod ( tens . n [ 0 : ( i + 1 ) ] ) , - 1 ) )", "docstring_tokens": "Compute the i - th unfolding of a tensor .", "label": 0}, {"idx": "cosqa-train-3971", "doc": "python assert all equal", "code": "def expect_all(a, b):\n    \"\"\"\\\n    Asserts that two iterables contain the same values.\n    \"\"\"\n    assert all(_a == _b for _a, _b in zip_longest(a, b))", "code_tokens": "def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )", "docstring_tokens": "\\ Asserts that two iterables contain the same values .", "label": 0}, {"idx": "cosqa-train-3972", "doc": "send termination call for python", "code": "def cli_command_quit(self, msg):\n        \"\"\"\\\n        kills the child and exits\n        \"\"\"\n        if self.state == State.RUNNING and self.sprocess and self.sprocess.proc:\n            self.sprocess.proc.kill()\n        else:\n            sys.exit(0)", "code_tokens": "def cli_command_quit ( self , msg ) : if self . state == State . RUNNING and self . sprocess and self . sprocess . proc : self . sprocess . proc . kill ( ) else : sys . exit ( 0 )", "docstring_tokens": "\\ kills the child and exits", "label": 0}, {"idx": "cosqa-train-3973", "doc": "python assert list any", "code": "def assert_exactly_one_true(bool_list):\n    \"\"\"This method asserts that only one value of the provided list is True.\n\n    :param bool_list: List of booleans to check\n    :return: True if only one value is True, False otherwise\n    \"\"\"\n    assert isinstance(bool_list, list)\n    counter = 0\n    for item in bool_list:\n        if item:\n            counter += 1\n    return counter == 1", "code_tokens": "def assert_exactly_one_true ( bool_list ) : assert isinstance ( bool_list , list ) counter = 0 for item in bool_list : if item : counter += 1 return counter == 1", "docstring_tokens": "This method asserts that only one value of the provided list is True .", "label": 0}, {"idx": "cosqa-train-3974", "doc": "send value in html back to python jinja2", "code": "def rstjinja(app, docname, source):\n    \"\"\"\n    Render our pages as a jinja template for fancy templating goodness.\n    \"\"\"\n    # Make sure we're outputting HTML\n    if app.builder.format != 'html':\n        return\n    src = source[0]\n    rendered = app.builder.templates.render_string(\n        src, app.config.html_context\n    )\n    source[0] = rendered", "code_tokens": "def rstjinja ( app , docname , source ) : # Make sure we're outputting HTML if app . builder . format != 'html' : return src = source [ 0 ] rendered = app . builder . templates . render_string ( src , app . config . html_context ) source [ 0 ] = rendered", "docstring_tokens": "Render our pages as a jinja template for fancy templating goodness .", "label": 1}, {"idx": "cosqa-train-3975", "doc": "python assert not raised", "code": "def assert_is_not(expected, actual, message=None, extra=None):\n    \"\"\"Raises an AssertionError if expected is actual.\"\"\"\n    assert expected is not actual, _assert_fail_message(\n        message, expected, actual, \"is\", extra\n    )", "code_tokens": "def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , \"is\" , extra )", "docstring_tokens": "Raises an AssertionError if expected is actual .", "label": 0}, {"idx": "cosqa-train-3976", "doc": "sending muultiple emails in python", "code": "async def repeat(ctx, times: int, content='repeating...'):\n    \"\"\"Repeats a message multiple times.\"\"\"\n    for i in range(times):\n        await ctx.send(content)", "code_tokens": "async def repeat ( ctx , times : int , content = 'repeating...' ) : for i in range ( times ) : await ctx . send ( content )", "docstring_tokens": "Repeats a message multiple times .", "label": 0}, {"idx": "cosqa-train-3977", "doc": "python assert two lists have same size", "code": "def expect_all(a, b):\n    \"\"\"\\\n    Asserts that two iterables contain the same values.\n    \"\"\"\n    assert all(_a == _b for _a, _b in zip_longest(a, b))", "code_tokens": "def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )", "docstring_tokens": "\\ Asserts that two iterables contain the same values .", "label": 0}, {"idx": "cosqa-train-3978", "doc": "sentinel loops python max and min numbers", "code": "def _digits(minval, maxval):\n    \"\"\"Digits needed to comforatbly display values in [minval, maxval]\"\"\"\n    if minval == maxval:\n        return 3\n    else:\n        return min(10, max(2, int(1 + abs(np.log10(maxval - minval)))))", "code_tokens": "def _digits ( minval , maxval ) : if minval == maxval : return 3 else : return min ( 10 , max ( 2 , int ( 1 + abs ( np . log10 ( maxval - minval ) ) ) ) )", "docstring_tokens": "Digits needed to comforatbly display values in [ minval maxval ]", "label": 0}, {"idx": "cosqa-train-3979", "doc": "python async call back on loop close", "code": "async def wait_and_quit(loop):\n\t\"\"\"Wait until all task are executed.\"\"\"\n\tfrom pylp.lib.tasks import running\n\tif running:\n\t\tawait asyncio.wait(map(lambda runner: runner.future, running))", "code_tokens": "async def wait_and_quit ( loop ) : from pylp . lib . tasks import running if running : await asyncio . wait ( map ( lambda runner : runner . future , running ) )", "docstring_tokens": "Wait until all task are executed .", "label": 0}, {"idx": "cosqa-train-3980", "doc": "separate a tsv in python", "code": "def generate_split_tsv_lines(fn, header):\n    \"\"\"Returns dicts with header-keys and psm statistic values\"\"\"\n    for line in generate_tsv_psms_line(fn):\n        yield {x: y for (x, y) in zip(header, line.strip().split('\\t'))}", "code_tokens": "def generate_split_tsv_lines ( fn , header ) : for line in generate_tsv_psms_line ( fn ) : yield { x : y for ( x , y ) in zip ( header , line . strip ( ) . split ( '\\t' ) ) }", "docstring_tokens": "Returns dicts with header - keys and psm statistic values", "label": 0}, {"idx": "cosqa-train-3981", "doc": "python async there is no current event loop in thread", "code": "def asynchronous(function, event):\n    \"\"\"\n    Runs the function asynchronously taking care of exceptions.\n    \"\"\"\n    thread = Thread(target=synchronous, args=(function, event))\n    thread.daemon = True\n    thread.start()", "code_tokens": "def asynchronous ( function , event ) : thread = Thread ( target = synchronous , args = ( function , event ) ) thread . daemon = True thread . start ( )", "docstring_tokens": "Runs the function asynchronously taking care of exceptions .", "label": 0}, {"idx": "cosqa-train-3982", "doc": "set copy clipboard to variable python", "code": "def paste(xsel=False):\n    \"\"\"Returns system clipboard contents.\"\"\"\n    selection = \"primary\" if xsel else \"clipboard\"\n    try:\n        return subprocess.Popen([\"xclip\", \"-selection\", selection, \"-o\"], stdout=subprocess.PIPE).communicate()[0].decode(\"utf-8\")\n    except OSError as why:\n        raise XclipNotFound", "code_tokens": "def paste ( xsel = False ) : selection = \"primary\" if xsel else \"clipboard\" try : return subprocess . Popen ( [ \"xclip\" , \"-selection\" , selection , \"-o\" ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] . decode ( \"utf-8\" ) except OSError as why : raise XclipNotFound", "docstring_tokens": "Returns system clipboard contents .", "label": 0}, {"idx": "cosqa-train-3983", "doc": "python asyncio wrap function", "code": "def StringIO(*args, **kwargs):\n    \"\"\"StringIO constructor shim for the async wrapper.\"\"\"\n    raw = sync_io.StringIO(*args, **kwargs)\n    return AsyncStringIOWrapper(raw)", "code_tokens": "def StringIO ( * args , * * kwargs ) : raw = sync_io . StringIO ( * args , * * kwargs ) return AsyncStringIOWrapper ( raw )", "docstring_tokens": "StringIO constructor shim for the async wrapper .", "label": 0}, {"idx": "cosqa-train-3984", "doc": "set form field width bootstrap flask python", "code": "def add_form_widget_attr(field, attr_name, attr_value, replace=0):\n    \"\"\"\n    Adds widget attributes to a bound form field.\n\n    This is helpful if you would like to add a certain class to all your forms\n    (i.e. `form-control` to all form fields when you are using Bootstrap)::\n\n        {% load libs_tags %}\n        {% for field in form.fields %}\n            {% add_form_widget_attr field 'class' 'form-control' as field_ %}\n            {{ field_ }}\n        {% endfor %}\n\n    The tag will check if the attr already exists and only append your value.\n    If you would like to replace existing attrs, set `replace=1`::\n\n        {% add_form_widget_attr field 'class' 'form-control' replace=1 as\n          field_ %}\n\n\n    \"\"\"\n    if not replace:\n        attr = field.field.widget.attrs.get(attr_name, '')\n        attr += force_text(attr_value)\n        field.field.widget.attrs[attr_name] = attr\n        return field\n    else:\n        field.field.widget.attrs[attr_name] = attr_value\n        return field", "code_tokens": "def add_form_widget_attr ( field , attr_name , attr_value , replace = 0 ) : if not replace : attr = field . field . widget . attrs . get ( attr_name , '' ) attr += force_text ( attr_value ) field . field . widget . attrs [ attr_name ] = attr return field else : field . field . widget . attrs [ attr_name ] = attr_value return field", "docstring_tokens": "Adds widget attributes to a bound form field .", "label": 1}, {"idx": "cosqa-train-3985", "doc": "python atexit register unload", "code": "def exit(exit_code=0):\n  r\"\"\"A function to support exiting from exit hooks.\n\n  Could also be used to exit from the calling scripts in a thread safe manner.\n  \"\"\"\n  core.processExitHooks()\n\n  if state.isExitHooked and not hasattr(sys, 'exitfunc'): # The function is called from the exit hook\n    sys.stderr.flush()\n    sys.stdout.flush()\n    os._exit(exit_code) #pylint: disable=W0212\n\n  sys.exit(exit_code)", "code_tokens": "def exit ( exit_code = 0 ) : core . processExitHooks ( ) if state . isExitHooked and not hasattr ( sys , 'exitfunc' ) : # The function is called from the exit hook sys . stderr . flush ( ) sys . stdout . flush ( ) os . _exit ( exit_code ) #pylint: disable=W0212 sys . exit ( exit_code )", "docstring_tokens": "r A function to support exiting from exit hooks .", "label": 0}, {"idx": "cosqa-train-3986", "doc": "set is immutable in python so how are we able to add new elemt", "code": "def add(self, value):\n        \"\"\"Add the element *value* to the set.\"\"\"\n        if value not in self._set:\n            self._set.add(value)\n            self._list.add(value)", "code_tokens": "def add ( self , value ) : if value not in self . _set : self . _set . add ( value ) self . _list . add ( value )", "docstring_tokens": "Add the element * value * to the set .", "label": 0}, {"idx": "cosqa-train-3987", "doc": "python auto code reload", "code": "def clear_globals_reload_modules(self):\n        \"\"\"Clears globals and reloads modules\"\"\"\n\n        self.code_array.clear_globals()\n        self.code_array.reload_modules()\n\n        # Clear result cache\n        self.code_array.result_cache.clear()", "code_tokens": "def clear_globals_reload_modules ( self ) : self . code_array . clear_globals ( ) self . code_array . reload_modules ( ) # Clear result cache self . code_array . result_cache . clear ( )", "docstring_tokens": "Clears globals and reloads modules", "label": 0}, {"idx": "cosqa-train-3988", "doc": "set logarithmic scale python", "code": "def filter_symlog(y, base=10.0):\n    \"\"\"Symmetrical logarithmic scale.\n\n    Optional arguments:\n\n    *base*:\n        The base of the logarithm.\n    \"\"\"\n    log_base = np.log(base)\n    sign = np.sign(y)\n    logs = np.log(np.abs(y) / log_base)\n    return sign * logs", "code_tokens": "def filter_symlog ( y , base = 10.0 ) : log_base = np . log ( base ) sign = np . sign ( y ) logs = np . log ( np . abs ( y ) / log_base ) return sign * logs", "docstring_tokens": "Symmetrical logarithmic scale .", "label": 0}, {"idx": "cosqa-train-3989", "doc": "python auto form fill", "code": "def fill_form(form, data):\n    \"\"\"Prefill form with data.\n\n    :param form: The form to fill.\n    :param data: The data to insert in the form.\n    :returns: A pre-filled form.\n    \"\"\"\n    for (key, value) in data.items():\n        if hasattr(form, key):\n            if isinstance(value, dict):\n                fill_form(getattr(form, key), value)\n            else:\n                getattr(form, key).data = value\n    return form", "code_tokens": "def fill_form ( form , data ) : for ( key , value ) in data . items ( ) : if hasattr ( form , key ) : if isinstance ( value , dict ) : fill_form ( getattr ( form , key ) , value ) else : getattr ( form , key ) . data = value return form", "docstring_tokens": "Prefill form with data .", "label": 0}, {"idx": "cosqa-train-3990", "doc": "set range in the constructor python", "code": "def __init__(self, interval, key):\n    \"\"\"Constructor. See class docstring for parameter details.\"\"\"\n    self.interval = interval\n    self.key = key", "code_tokens": "def __init__ ( self , interval , key ) : self . interval = interval self . key = key", "docstring_tokens": "Constructor . See class docstring for parameter details .", "label": 0}, {"idx": "cosqa-train-3991", "doc": "python automatically open excel file after running", "code": "def _openpyxl_read_xl(xl_path: str):\n    \"\"\" Use openpyxl to read an Excel file. \"\"\"\n    try:\n        wb = load_workbook(filename=xl_path, read_only=True)\n    except:\n        raise\n    else:\n        return wb", "code_tokens": "def _openpyxl_read_xl ( xl_path : str ) : try : wb = load_workbook ( filename = xl_path , read_only = True ) except : raise else : return wb", "docstring_tokens": "Use openpyxl to read an Excel file .", "label": 0}, {"idx": "cosqa-train-3992", "doc": "setting a breakpoint with pdb, python", "code": "def user_return(self, frame, return_value):\n        \"\"\"This function is called when a return trap is set here.\"\"\"\n        pdb.Pdb.user_return(self, frame, return_value)", "code_tokens": "def user_return ( self , frame , return_value ) : pdb . Pdb . user_return ( self , frame , return_value )", "docstring_tokens": "This function is called when a return trap is set here .", "label": 0}, {"idx": "cosqa-train-3993", "doc": "python average if not 0", "code": "def average(arr):\n  \"\"\"average of the values, must have more than 0 entries.\n\n  :param arr: list of numbers\n  :type arr: number[] a number array\n  :return: average\n  :rtype: float\n\n  \"\"\"\n  if len(arr) == 0:\n    sys.stderr.write(\"ERROR: no content in array to take average\\n\")\n    sys.exit()\n  if len(arr) == 1:  return arr[0]\n  return float(sum(arr))/float(len(arr))", "code_tokens": "def average ( arr ) : if len ( arr ) == 0 : sys . stderr . write ( \"ERROR: no content in array to take average\\n\" ) sys . exit ( ) if len ( arr ) == 1 : return arr [ 0 ] return float ( sum ( arr ) ) / float ( len ( arr ) )", "docstring_tokens": "average of the values must have more than 0 entries .", "label": 1}, {"idx": "cosqa-train-3994", "doc": "setting window height in python", "code": "def setwinsize(self, rows, cols):\n        \"\"\"Set the terminal window size of the child tty.\n        \"\"\"\n        self._winsize = (rows, cols)\n        self.pty.set_size(cols, rows)", "code_tokens": "def setwinsize ( self , rows , cols ) : self . _winsize = ( rows , cols ) self . pty . set_size ( cols , rows )", "docstring_tokens": "Set the terminal window size of the child tty .", "label": 0}, {"idx": "cosqa-train-3995", "doc": "python aws delete object", "code": "def delete(gandi, resource):\n    \"\"\"Delete DNSSEC key.\n    \"\"\"\n\n    result = gandi.dnssec.delete(resource)\n    gandi.echo('Delete successful.')\n\n    return result", "code_tokens": "def delete ( gandi , resource ) : result = gandi . dnssec . delete ( resource ) gandi . echo ( 'Delete successful.' ) return result", "docstring_tokens": "Delete DNSSEC key .", "label": 0}, {"idx": "cosqa-train-3996", "doc": "should yaml be used for config files for python", "code": "def _parse_config(config_file_path):\n    \"\"\" Parse Config File from yaml file. \"\"\"\n    config_file = open(config_file_path, 'r')\n    config = yaml.load(config_file)\n    config_file.close()\n    return config", "code_tokens": "def _parse_config ( config_file_path ) : config_file = open ( config_file_path , 'r' ) config = yaml . load ( config_file ) config_file . close ( ) return config", "docstring_tokens": "Parse Config File from yaml file .", "label": 0}, {"idx": "cosqa-train-3997", "doc": "python aws lambda third party", "code": "def create_aws_lambda(ctx, bucket, region_name, aws_access_key_id, aws_secret_access_key):\n    \"\"\"Creates an AWS Chalice project for deployment to AWS Lambda.\"\"\"\n    from canari.commands.create_aws_lambda import create_aws_lambda\n    create_aws_lambda(ctx.project, bucket, region_name, aws_access_key_id, aws_secret_access_key)", "code_tokens": "def create_aws_lambda ( ctx , bucket , region_name , aws_access_key_id , aws_secret_access_key ) : from canari . commands . create_aws_lambda import create_aws_lambda create_aws_lambda ( ctx . project , bucket , region_name , aws_access_key_id , aws_secret_access_key )", "docstring_tokens": "Creates an AWS Chalice project for deployment to AWS Lambda .", "label": 0}, {"idx": "cosqa-train-3998", "doc": "show confusion matrix python scikitlearn", "code": "def confusion_matrix(self):\n        \"\"\"Confusion matrix plot\n        \"\"\"\n        return plot.confusion_matrix(self.y_true, self.y_pred,\n                                     self.target_names, ax=_gen_ax())", "code_tokens": "def confusion_matrix ( self ) : return plot . confusion_matrix ( self . y_true , self . y_pred , self . target_names , ax = _gen_ax ( ) )", "docstring_tokens": "Confusion matrix plot", "label": 0}, {"idx": "cosqa-train-3999", "doc": "python b' covert string", "code": "def s2b(s):\n    \"\"\"\n    String to binary.\n    \"\"\"\n    ret = []\n    for c in s:\n        ret.append(bin(ord(c))[2:].zfill(8))\n    return \"\".join(ret)", "code_tokens": "def s2b ( s ) : ret = [ ] for c in s : ret . append ( bin ( ord ( c ) ) [ 2 : ] . zfill ( 8 ) ) return \"\" . join ( ret )", "docstring_tokens": "String to binary .", "label": 0}]