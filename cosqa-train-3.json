[{"idx": "cosqa-train-8000", "doc": "python3 get column name of min value in row", "code": "def index(self, value):\n\t\t\"\"\"\n\t\tReturn the smallest index of the row(s) with this column\n\t\tequal to value.\n\t\t\"\"\"\n\t\tfor i in xrange(len(self.parentNode)):\n\t\t\tif getattr(self.parentNode[i], self.Name) == value:\n\t\t\t\treturn i\n\t\traise ValueError(value)", "code_tokens": "def index ( self , value ) : for i in xrange ( len ( self . parentNode ) ) : if getattr ( self . parentNode [ i ] , self . Name ) == value : return i raise ValueError ( value )", "docstring_tokens": "Return the smallest index of the row ( s ) with this column equal to value .", "label": 1}, {"idx": "cosqa-train-8001", "doc": "number of python element a lsit can contain", "code": "def __len__(self):\n        \"\"\" This will equal 124 for the V1 database. \"\"\"\n        length = 0\n        for typ, siz, _ in self.format:\n            length += siz\n        return length", "code_tokens": "def __len__ ( self ) : length = 0 for typ , siz , _ in self . format : length += siz return length", "docstring_tokens": "This will equal 124 for the V1 database .", "label": 1}, {"idx": "cosqa-train-8002", "doc": "python3 get path relative to parent", "code": "def grandparent_path(self):\n        \"\"\" return grandparent's path string \"\"\"\n        return os.path.basename(os.path.join(self.path, '../..'))", "code_tokens": "def grandparent_path ( self ) : return os . path . basename ( os . path . join ( self . path , '../..' ) )", "docstring_tokens": "return grandparent s path string", "label": 1}, {"idx": "cosqa-train-8003", "doc": "object has no attribute update dict python", "code": "def update_dict(obj, dict, attributes):\n    \"\"\"Update dict with fields from obj.attributes.\n\n    :param obj: the object updated into dict\n    :param dict: the result dictionary\n    :param attributes: a list of attributes belonging to obj\n    \"\"\"\n    for attribute in attributes:\n        if hasattr(obj, attribute) and getattr(obj, attribute) is not None:\n            dict[attribute] = getattr(obj, attribute)", "code_tokens": "def update_dict ( obj , dict , attributes ) : for attribute in attributes : if hasattr ( obj , attribute ) and getattr ( obj , attribute ) is not None : dict [ attribute ] = getattr ( obj , attribute )", "docstring_tokens": "Update dict with fields from obj . attributes .", "label": 1}, {"idx": "cosqa-train-8004", "doc": "python3 how to check dependency", "code": "def check(modname):\n    \"\"\"Check if required dependency is installed\"\"\"\n    for dependency in DEPENDENCIES:\n        if dependency.modname == modname:\n            return dependency.check()\n    else:\n        raise RuntimeError(\"Unkwown dependency %s\" % modname)", "code_tokens": "def check ( modname ) : for dependency in DEPENDENCIES : if dependency . modname == modname : return dependency . check ( ) else : raise RuntimeError ( \"Unkwown dependency %s\" % modname )", "docstring_tokens": "Check if required dependency is installed", "label": 1}, {"idx": "cosqa-train-8005", "doc": "obtain mask in python image", "code": "def _rgbtomask(self, obj):\n        \"\"\"Convert RGB arrays from mask canvas object back to boolean mask.\"\"\"\n        dat = obj.get_image().get_data()  # RGB arrays\n        return dat.sum(axis=2).astype(np.bool)", "code_tokens": "def _rgbtomask ( self , obj ) : dat = obj . get_image ( ) . get_data ( ) # RGB arrays return dat . sum ( axis = 2 ) . astype ( np . bool )", "docstring_tokens": "Convert RGB arrays from mask canvas object back to boolean mask .", "label": 0}, {"idx": "cosqa-train-8006", "doc": "python3 how to encoce to base64", "code": "def toBase64(s):\n    \"\"\"Represent string / bytes s as base64, omitting newlines\"\"\"\n    if isinstance(s, str):\n        s = s.encode(\"utf-8\")\n    return binascii.b2a_base64(s)[:-1]", "code_tokens": "def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( \"utf-8\" ) return binascii . b2a_base64 ( s ) [ : - 1 ]", "docstring_tokens": "Represent string / bytes s as base64 omitting newlines", "label": 1}, {"idx": "cosqa-train-8007", "doc": "once a file is open, how do you remove it from memory python", "code": "def delete(filething):\n    \"\"\"Remove tags from a file.\n\n    Args:\n        filething (filething)\n    Raises:\n        mutagen.MutagenError\n    \"\"\"\n\n    f = FLAC(filething)\n    filething.fileobj.seek(0)\n    f.delete(filething)", "code_tokens": "def delete ( filething ) : f = FLAC ( filething ) filething . fileobj . seek ( 0 ) f . delete ( filething )", "docstring_tokens": "Remove tags from a file .", "label": 0}, {"idx": "cosqa-train-8008", "doc": "python3 return a key based on", "code": "def get_from_human_key(self, key):\n        \"\"\"Return the key (aka database value) of a human key (aka Python identifier).\"\"\"\n        if key in self._identifier_map:\n            return self._identifier_map[key]\n        raise KeyError(key)", "code_tokens": "def get_from_human_key ( self , key ) : if key in self . _identifier_map : return self . _identifier_map [ key ] raise KeyError ( key )", "docstring_tokens": "Return the key ( aka database value ) of a human key ( aka Python identifier ) .", "label": 1}, {"idx": "cosqa-train-8009", "doc": "open a close image python", "code": "def cio_close(cio):\n    \"\"\"Wraps openjpeg library function cio_close.\n    \"\"\"\n    OPENJPEG.opj_cio_close.argtypes = [ctypes.POINTER(CioType)]\n    OPENJPEG.opj_cio_close(cio)", "code_tokens": "def cio_close ( cio ) : OPENJPEG . opj_cio_close . argtypes = [ ctypes . POINTER ( CioType ) ] OPENJPEG . opj_cio_close ( cio )", "docstring_tokens": "Wraps openjpeg library function cio_close .", "label": 0}, {"idx": "cosqa-train-8010", "doc": "python3 set default value for input", "code": "def input_int_default(question=\"\", default=0):\n    \"\"\"A function that works for both, Python 2.x and Python 3.x.\n       It asks the user for input and returns it as a string.\n    \"\"\"\n    answer = input_string(question)\n    if answer == \"\" or answer == \"yes\":\n        return default\n    else:\n        return int(answer)", "code_tokens": "def input_int_default ( question = \"\" , default = 0 ) : answer = input_string ( question ) if answer == \"\" or answer == \"yes\" : return default else : return int ( answer )", "docstring_tokens": "A function that works for both Python 2 . x and Python 3 . x . It asks the user for input and returns it as a string .", "label": 1}, {"idx": "cosqa-train-8011", "doc": "open a serial port in python", "code": "def do_serial(self, p):\n\t\t\"\"\"Set the serial port, e.g.: /dev/tty.usbserial-A4001ib8\"\"\"\n\t\ttry:\n\t\t\tself.serial.port = p\n\t\t\tself.serial.open()\n\t\t\tprint 'Opening serial port: %s' % p\n\t\texcept Exception, e:\n\t\t\tprint 'Unable to open serial port: %s' % p", "code_tokens": "def do_serial ( self , p ) : try : self . serial . port = p self . serial . open ( ) print 'Opening serial port: %s' % p except Exception , e : print 'Unable to open serial port: %s' % p", "docstring_tokens": "Set the serial port e . g . : / dev / tty . usbserial - A4001ib8", "label": 0}, {"idx": "cosqa-train-8012", "doc": "python3 test isinstance date", "code": "def is_timestamp(instance):\n    \"\"\"Validates data is a timestamp\"\"\"\n    if not isinstance(instance, (int, str)):\n        return True\n    return datetime.fromtimestamp(int(instance))", "code_tokens": "def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )", "docstring_tokens": "Validates data is a timestamp", "label": 0}, {"idx": "cosqa-train-8013", "doc": "opencv3 python bgr to grayscale", "code": "def gray2bgr(img):\n    \"\"\"Convert a grayscale image to BGR image.\n\n    Args:\n        img (ndarray or str): The input image.\n\n    Returns:\n        ndarray: The converted BGR image.\n    \"\"\"\n    img = img[..., None] if img.ndim == 2 else img\n    out_img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n    return out_img", "code_tokens": "def gray2bgr ( img ) : img = img [ ... , None ] if img . ndim == 2 else img out_img = cv2 . cvtColor ( img , cv2 . COLOR_GRAY2BGR ) return out_img", "docstring_tokens": "Convert a grayscale image to BGR image .", "label": 1}, {"idx": "cosqa-train-8014", "doc": "python3 urllib bypass sslv3 handshake failure", "code": "def inject_into_urllib3():\n    \"\"\"\n    Monkey-patch urllib3 with SecureTransport-backed SSL-support.\n    \"\"\"\n    util.ssl_.SSLContext = SecureTransportContext\n    util.HAS_SNI = HAS_SNI\n    util.ssl_.HAS_SNI = HAS_SNI\n    util.IS_SECURETRANSPORT = True\n    util.ssl_.IS_SECURETRANSPORT = True", "code_tokens": "def inject_into_urllib3 ( ) : util . ssl_ . SSLContext = SecureTransportContext util . HAS_SNI = HAS_SNI util . ssl_ . HAS_SNI = HAS_SNI util . IS_SECURETRANSPORT = True util . ssl_ . IS_SECURETRANSPORT = True", "docstring_tokens": "Monkey - patch urllib3 with SecureTransport - backed SSL - support .", "label": 0}, {"idx": "cosqa-train-8015", "doc": "optimize path through grid python", "code": "def find_path(self, start, end, grid):\n        \"\"\"\n        find a path from start to end node on grid using the A* algorithm\n        :param start: start node\n        :param end: end node\n        :param grid: grid that stores all possible steps/tiles as 2D-list\n        :return:\n        \"\"\"\n        start.g = 0\n        start.f = 0\n        return super(AStarFinder, self).find_path(start, end, grid)", "code_tokens": "def find_path ( self , start , end , grid ) : start . g = 0 start . f = 0 return super ( AStarFinder , self ) . find_path ( start , end , grid )", "docstring_tokens": "find a path from start to end node on grid using the A * algorithm : param start : start node : param end : end node : param grid : grid that stores all possible steps / tiles as 2D - list : return :", "label": 1}, {"idx": "cosqa-train-8016", "doc": "python3 urllib remove query string", "code": "def strip_querystring(url):\n    \"\"\"Remove the querystring from the end of a URL.\"\"\"\n    p = six.moves.urllib.parse.urlparse(url)\n    return p.scheme + \"://\" + p.netloc + p.path", "code_tokens": "def strip_querystring ( url ) : p = six . moves . urllib . parse . urlparse ( url ) return p . scheme + \"://\" + p . netloc + p . path", "docstring_tokens": "Remove the querystring from the end of a URL .", "label": 0}, {"idx": "cosqa-train-8017", "doc": "os python time updated or accessed", "code": "def _uptime_syllable():\n    \"\"\"Returns uptime in seconds or None, on Syllable.\"\"\"\n    global __boottime\n    try:\n        __boottime = os.stat('/dev/pty/mst/pty0').st_mtime\n        return time.time() - __boottime\n    except (NameError, OSError):\n        return None", "code_tokens": "def _uptime_syllable ( ) : global __boottime try : __boottime = os . stat ( '/dev/pty/mst/pty0' ) . st_mtime return time . time ( ) - __boottime except ( NameError , OSError ) : return None", "docstring_tokens": "Returns uptime in seconds or None on Syllable .", "label": 1}, {"idx": "cosqa-train-8018", "doc": "quickest way to read pickle python", "code": "def unpickle(pickle_file):\n    \"\"\"Unpickle a python object from the given path.\"\"\"\n    pickle = None\n    with open(pickle_file, \"rb\") as pickle_f:\n        pickle = dill.load(pickle_f)\n    if not pickle:\n        LOG.error(\"Could not load python object from file\")\n    return pickle", "code_tokens": "def unpickle ( pickle_file ) : pickle = None with open ( pickle_file , \"rb\" ) as pickle_f : pickle = dill . load ( pickle_f ) if not pickle : LOG . error ( \"Could not load python object from file\" ) return pickle", "docstring_tokens": "Unpickle a python object from the given path .", "label": 1}, {"idx": "cosqa-train-8019", "doc": "ow to check if object has no attribvute python", "code": "def hasattrs(object, *names):\n    \"\"\"\n    Takes in an object and a variable length amount of named attributes,\n    and checks to see if the object has each property. If any of the\n    attributes are missing, this returns false.\n\n    :param object: an object that may or may not contain the listed attributes\n    :param names: a variable amount of attribute names to check for\n    :return: True if the object contains each named attribute, false otherwise\n    \"\"\"\n    for name in names:\n        if not hasattr(object, name):\n            return False\n    return True", "code_tokens": "def hasattrs ( object , * names ) : for name in names : if not hasattr ( object , name ) : return False return True", "docstring_tokens": "Takes in an object and a variable length amount of named attributes and checks to see if the object has each property . If any of the attributes are missing this returns false .", "label": 1}, {"idx": "cosqa-train-8020", "doc": "qwidget won't show if parent set in constructor in python", "code": "def parent_widget(self):\n        \"\"\" Reimplemented to only return GraphicsItems \"\"\"\n        parent = self.parent()\n        if parent is not None and isinstance(parent, QtGraphicsItem):\n            return parent.widget", "code_tokens": "def parent_widget ( self ) : parent = self . parent ( ) if parent is not None and isinstance ( parent , QtGraphicsItem ) : return parent . widget", "docstring_tokens": "Reimplemented to only return GraphicsItems", "label": 0}, {"idx": "cosqa-train-8021", "doc": "ow to save keras model python", "code": "def save_keras_definition(keras_model, path):\n    \"\"\"\n    Save a Keras model definition to JSON with given path\n    \"\"\"\n    model_json = keras_model.to_json()\n    with open(path, \"w\") as json_file:\n        json_file.write(model_json)", "code_tokens": "def save_keras_definition ( keras_model , path ) : model_json = keras_model . to_json ( ) with open ( path , \"w\" ) as json_file : json_file . write ( model_json )", "docstring_tokens": "Save a Keras model definition to JSON with given path", "label": 1}, {"idx": "cosqa-train-8022", "doc": "pad an image python", "code": "def __call__(self, img):\n        \"\"\"\n        Args:\n            img (PIL Image): Image to be padded.\n\n        Returns:\n            PIL Image: Padded image.\n        \"\"\"\n        return F.pad(img, self.padding, self.fill, self.padding_mode)", "code_tokens": "def __call__ ( self , img ) : return F . pad ( img , self . padding , self . fill , self . padding_mode )", "docstring_tokens": "Args : img ( PIL Image ) : Image to be padded .", "label": 1}, {"idx": "cosqa-train-8023", "doc": "raise errpr in a function python", "code": "def raise_os_error(_errno, path=None):\n    \"\"\"\n    Helper for raising the correct exception under Python 3 while still\n    being able to raise the same common exception class in Python 2.7.\n    \"\"\"\n\n    msg = \"%s: '%s'\" % (strerror(_errno), path) if path else strerror(_errno)\n    raise OSError(_errno, msg)", "code_tokens": "def raise_os_error ( _errno , path = None ) : msg = \"%s: '%s'\" % ( strerror ( _errno ) , path ) if path else strerror ( _errno ) raise OSError ( _errno , msg )", "docstring_tokens": "Helper for raising the correct exception under Python 3 while still being able to raise the same common exception class in Python 2 . 7 .", "label": 1}, {"idx": "cosqa-train-8024", "doc": "paragraph spacing code python", "code": "def indent(block, spaces):\n    \"\"\" indents paragraphs of text for rst formatting \"\"\"\n    new_block = ''\n    for line in block.split('\\n'):\n        new_block += spaces + line + '\\n'\n    return new_block", "code_tokens": "def indent ( block , spaces ) : new_block = '' for line in block . split ( '\\n' ) : new_block += spaces + line + '\\n' return new_block", "docstring_tokens": "indents paragraphs of text for rst formatting", "label": 1}, {"idx": "cosqa-train-8025", "doc": "random float between 1 and 15 python", "code": "def money(min=0, max=10):\n    \"\"\"Return a str of decimal with two digits after a decimal mark.\"\"\"\n    value = random.choice(range(min * 100, max * 100))\n    return \"%1.2f\" % (float(value) / 100)", "code_tokens": "def money ( min = 0 , max = 10 ) : value = random . choice ( range ( min * 100 , max * 100 ) ) return \"%1.2f\" % ( float ( value ) / 100 )", "docstring_tokens": "Return a str of decimal with two digits after a decimal mark .", "label": 0}, {"idx": "cosqa-train-8026", "doc": "parsefromstring from protobuf on python", "code": "def message_from_string(s, *args, **kws):\n    \"\"\"Parse a string into a Message object model.\n\n    Optional _class and strict are passed to the Parser constructor.\n    \"\"\"\n    from future.backports.email.parser import Parser\n    return Parser(*args, **kws).parsestr(s)", "code_tokens": "def message_from_string ( s , * args , * * kws ) : from future . backports . email . parser import Parser return Parser ( * args , * * kws ) . parsestr ( s )", "docstring_tokens": "Parse a string into a Message object model .", "label": 1}, {"idx": "cosqa-train-8027", "doc": "partial method python name", "code": "def __getattr__(self, name):\n        \"\"\"Return wrapper to named api method.\"\"\"\n        return functools.partial(self._obj.request, self._api_prefix + name)", "code_tokens": "def __getattr__ ( self , name ) : return functools . partial ( self . _obj . request , self . _api_prefix + name )", "docstring_tokens": "Return wrapper to named api method .", "label": 1}, {"idx": "cosqa-train-8028", "doc": "random points on python for positions", "code": "def _rndPointDisposition(dx, dy):\n        \"\"\"Return random disposition point.\"\"\"\n        x = int(random.uniform(-dx, dx))\n        y = int(random.uniform(-dy, dy))\n        return (x, y)", "code_tokens": "def _rndPointDisposition ( dx , dy ) : x = int ( random . uniform ( - dx , dx ) ) y = int ( random . uniform ( - dy , dy ) ) return ( x , y )", "docstring_tokens": "Return random disposition point .", "label": 1}, {"idx": "cosqa-train-8029", "doc": "pass in integers with python *args", "code": "def minus(*args):\n    \"\"\"Also, converts either to ints or to floats.\"\"\"\n    if len(args) == 1:\n        return -to_numeric(args[0])\n    return to_numeric(args[0]) - to_numeric(args[1])", "code_tokens": "def minus ( * args ) : if len ( args ) == 1 : return - to_numeric ( args [ 0 ] ) return to_numeric ( args [ 0 ] ) - to_numeric ( args [ 1 ] )", "docstring_tokens": "Also converts either to ints or to floats .", "label": 0}, {"idx": "cosqa-train-8030", "doc": "random variable min max python", "code": "def random_color(_min=MIN_COLOR, _max=MAX_COLOR):\n    \"\"\"Returns a random color between min and max.\"\"\"\n    return color(random.randint(_min, _max))", "code_tokens": "def random_color ( _min = MIN_COLOR , _max = MAX_COLOR ) : return color ( random . randint ( _min , _max ) )", "docstring_tokens": "Returns a random color between min and max .", "label": 1}, {"idx": "cosqa-train-8031", "doc": "pass list of strings in python to java", "code": "def string_list_to_array(l):\n    \"\"\"\n    Turns a Python unicode string list into a Java String array.\n\n    :param l: the string list\n    :type: list\n    :rtype: java string array\n    :return: JB_Object\n    \"\"\"\n    result = javabridge.get_env().make_object_array(len(l), javabridge.get_env().find_class(\"java/lang/String\"))\n    for i in range(len(l)):\n        javabridge.get_env().set_object_array_element(result, i, javabridge.get_env().new_string_utf(l[i]))\n    return result", "code_tokens": "def string_list_to_array ( l ) : result = javabridge . get_env ( ) . make_object_array ( len ( l ) , javabridge . get_env ( ) . find_class ( \"java/lang/String\" ) ) for i in range ( len ( l ) ) : javabridge . get_env ( ) . set_object_array_element ( result , i , javabridge . get_env ( ) . new_string_utf ( l [ i ] ) ) return result", "docstring_tokens": "Turns a Python unicode string list into a Java String array .", "label": 0}, {"idx": "cosqa-train-8032", "doc": "re python to remove non ascii from df", "code": "def _remove_nonascii(self, df):\n    \"\"\"Make copy and remove non-ascii characters from it.\"\"\"\n\n    df_copy = df.copy(deep=True)\n    for col in df_copy.columns:\n      if (df_copy[col].dtype == np.dtype('O')):\n        df_copy[col] = df[col].apply(\n          lambda x: re.sub(r'[^\\x00-\\x7f]', r'', x) if isinstance(x, six.string_types) else x)\n\n    return df_copy", "code_tokens": "def _remove_nonascii ( self , df ) : df_copy = df . copy ( deep = True ) for col in df_copy . columns : if ( df_copy [ col ] . dtype == np . dtype ( 'O' ) ) : df_copy [ col ] = df [ col ] . apply ( lambda x : re . sub ( r'[^\\x00-\\x7f]' , r'' , x ) if isinstance ( x , six . string_types ) else x ) return df_copy", "docstring_tokens": "Make copy and remove non - ascii characters from it .", "label": 0}, {"idx": "cosqa-train-8033", "doc": "passing a range of values python years", "code": "def from_years_range(start_year, end_year):\n        \"\"\"Transform a range of years (two ints) to a DateRange object.\"\"\"\n        start = datetime.date(start_year, 1 , 1)\n        end = datetime.date(end_year, 12 , 31)\n        return DateRange(start, end)", "code_tokens": "def from_years_range ( start_year , end_year ) : start = datetime . date ( start_year , 1 , 1 ) end = datetime . date ( end_year , 12 , 31 ) return DateRange ( start , end )", "docstring_tokens": "Transform a range of years ( two ints ) to a DateRange object .", "label": 1}, {"idx": "cosqa-train-8034", "doc": "read a file and tokenize in python", "code": "def listified_tokenizer(source):\n    \"\"\"Tokenizes *source* and returns the tokens as a list of lists.\"\"\"\n    io_obj = io.StringIO(source)\n    return [list(a) for a in tokenize.generate_tokens(io_obj.readline)]", "code_tokens": "def listified_tokenizer ( source ) : io_obj = io . StringIO ( source ) return [ list ( a ) for a in tokenize . generate_tokens ( io_obj . readline ) ]", "docstring_tokens": "Tokenizes * source * and returns the tokens as a list of lists .", "label": 1}, {"idx": "cosqa-train-8035", "doc": "passing float in json python", "code": "def __get_float(section, name):\n    \"\"\"Get the forecasted float from json section.\"\"\"\n    try:\n        return float(section[name])\n    except (ValueError, TypeError, KeyError):\n        return float(0)", "code_tokens": "def __get_float ( section , name ) : try : return float ( section [ name ] ) except ( ValueError , TypeError , KeyError ) : return float ( 0 )", "docstring_tokens": "Get the forecasted float from json section .", "label": 1}, {"idx": "cosqa-train-8036", "doc": "read byte file specific endianess python", "code": "def read_string(buff, byteorder='big'):\n    \"\"\"Read a string from a file-like object.\"\"\"\n    length = read_numeric(USHORT, buff, byteorder)\n    return buff.read(length).decode('utf-8')", "code_tokens": "def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )", "docstring_tokens": "Read a string from a file - like object .", "label": 0}, {"idx": "cosqa-train-8037", "doc": "passing multiple iterators to map in python", "code": "def imapchain(*a, **kwa):\n    \"\"\" Like map but also chains the results. \"\"\"\n\n    imap_results = map( *a, **kwa )\n    return itertools.chain( *imap_results )", "code_tokens": "def imapchain ( * a , * * kwa ) : imap_results = map ( * a , * * kwa ) return itertools . chain ( * imap_results )", "docstring_tokens": "Like map but also chains the results .", "label": 1}, {"idx": "cosqa-train-8038", "doc": "read json file with multiple objects python", "code": "def _read_json_file(self, json_file):\n        \"\"\" Helper function to read JSON file as OrderedDict \"\"\"\n\n        self.log.debug(\"Reading '%s' JSON file...\" % json_file)\n\n        with open(json_file, 'r') as f:\n            return json.load(f, object_pairs_hook=OrderedDict)", "code_tokens": "def _read_json_file ( self , json_file ) : self . log . debug ( \"Reading '%s' JSON file...\" % json_file ) with open ( json_file , 'r' ) as f : return json . load ( f , object_pairs_hook = OrderedDict )", "docstring_tokens": "Helper function to read JSON file as OrderedDict", "label": 1}, {"idx": "cosqa-train-8039", "doc": "password genorator python greater than characters", "code": "def GeneratePassphrase(length=20):\n  \"\"\"Create a 20 char passphrase with easily typeable chars.\"\"\"\n  valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  valid_chars += \"0123456789 ,-_&$#\"\n  return \"\".join(random.choice(valid_chars) for i in range(length))", "code_tokens": "def GeneratePassphrase ( length = 20 ) : valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" valid_chars += \"0123456789 ,-_&$#\" return \"\" . join ( random . choice ( valid_chars ) for i in range ( length ) )", "docstring_tokens": "Create a 20 char passphrase with easily typeable chars .", "label": 0}, {"idx": "cosqa-train-8040", "doc": "read text file in python, utf8", "code": "def read_utf8(fh, byteorder, dtype, count, offsetsize):\n    \"\"\"Read tag data from file and return as unicode string.\"\"\"\n    return fh.read(count).decode('utf-8')", "code_tokens": "def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )", "docstring_tokens": "Read tag data from file and return as unicode string .", "label": 0}, {"idx": "cosqa-train-8041", "doc": "penalized logistic regression python", "code": "def survival(value=t, lam=lam, f=failure):\n    \"\"\"Exponential survival likelihood, accounting for censoring\"\"\"\n    return sum(f * log(lam) - lam * value)", "code_tokens": "def survival ( value = t , lam = lam , f = failure ) : return sum ( f * log ( lam ) - lam * value )", "docstring_tokens": "Exponential survival likelihood accounting for censoring", "label": 0}, {"idx": "cosqa-train-8042", "doc": "reading binary data with python numpy", "code": "def read_numpy(fh, byteorder, dtype, count, offsetsize):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    dtype = 'b' if dtype[-1] == 's' else byteorder+dtype[-1]\n    return fh.read_array(dtype, count)", "code_tokens": "def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 1}, {"idx": "cosqa-train-8043", "doc": "pick a random elemnt within array python", "code": "def downsample(array, k):\n    \"\"\"Choose k random elements of array.\"\"\"\n    length = array.shape[0]\n    indices = random.sample(xrange(length), k)\n    return array[indices]", "code_tokens": "def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]", "docstring_tokens": "Choose k random elements of array .", "label": 0}, {"idx": "cosqa-train-8044", "doc": "reading data from url in python", "code": "def get(url):\n    \"\"\"Recieving the JSON file from uulm\"\"\"\n    response = urllib.request.urlopen(url)\n    data = response.read()\n    data = data.decode(\"utf-8\")\n    data = json.loads(data)\n    return data", "code_tokens": "def get ( url ) : response = urllib . request . urlopen ( url ) data = response . read ( ) data = data . decode ( \"utf-8\" ) data = json . loads ( data ) return data", "docstring_tokens": "Recieving the JSON file from uulm", "label": 0}, {"idx": "cosqa-train-8045", "doc": "pick random element of set python", "code": "def random_choice(sequence):\n    \"\"\" Same as :meth:`random.choice`, but also supports :class:`set` type to be passed as sequence. \"\"\"\n    return random.choice(tuple(sequence) if isinstance(sequence, set) else sequence)", "code_tokens": "def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )", "docstring_tokens": "Same as : meth : random . choice but also supports : class : set type to be passed as sequence .", "label": 1}, {"idx": "cosqa-train-8046", "doc": "real part of fft python", "code": "def stft_magnitude(signal, fft_length,\n                   hop_length=None,\n                   window_length=None):\n  \"\"\"Calculate the short-time Fourier transform magnitude.\n\n  Args:\n    signal: 1D np.array of the input time-domain signal.\n    fft_length: Size of the FFT to apply.\n    hop_length: Advance (in samples) between each frame passed to FFT.\n    window_length: Length of each block of samples to pass to FFT.\n\n  Returns:\n    2D np.array where each row contains the magnitudes of the fft_length/2+1\n    unique values of the FFT for the corresponding frame of input samples.\n  \"\"\"\n  frames = frame(signal, window_length, hop_length)\n  # Apply frame window to each frame. We use a periodic Hann (cosine of period\n  # window_length) instead of the symmetric Hann of np.hanning (period\n  # window_length-1).\n  window = periodic_hann(window_length)\n  windowed_frames = frames * window\n  return np.abs(np.fft.rfft(windowed_frames, int(fft_length)))", "code_tokens": "def stft_magnitude ( signal , fft_length , hop_length = None , window_length = None ) : frames = frame ( signal , window_length , hop_length ) # Apply frame window to each frame. We use a periodic Hann (cosine of period # window_length) instead of the symmetric Hann of np.hanning (period # window_length-1). window = periodic_hann ( window_length ) windowed_frames = frames * window return np . abs ( np . fft . rfft ( windowed_frames , int ( fft_length ) ) )", "docstring_tokens": "Calculate the short - time Fourier transform magnitude .", "label": 1}, {"idx": "cosqa-train-8047", "doc": "play and pause audio in python", "code": "def pause(self):\n        \"\"\"Pause the music\"\"\"\n        mixer.music.pause()\n        self.pause_time = self.get_time()\n        self.paused = True", "code_tokens": "def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True", "docstring_tokens": "Pause the music", "label": 0}, {"idx": "cosqa-train-8048", "doc": "real time python yield", "code": "def connected_socket(address, timeout=3):\n    \"\"\" yields a connected socket \"\"\"\n    sock = socket.create_connection(address, timeout)\n    yield sock\n    sock.close()", "code_tokens": "def connected_socket ( address , timeout = 3 ) : sock = socket . create_connection ( address , timeout ) yield sock sock . close ( )", "docstring_tokens": "yields a connected socket", "label": 0}, {"idx": "cosqa-train-8049", "doc": "play audio with animation python", "code": "def makeAnimation(self):\n        \"\"\"Use pymovie to render (visual+audio)+text overlays.\n        \"\"\"\n        aclip=mpy.AudioFileClip(\"sound.wav\")\n        self.iS=self.iS.set_audio(aclip)\n        self.iS.write_videofile(\"mixedVideo.webm\",15,audio=True)\n        print(\"wrote \"+\"mixedVideo.webm\")", "code_tokens": "def makeAnimation ( self ) : aclip = mpy . AudioFileClip ( \"sound.wav\" ) self . iS = self . iS . set_audio ( aclip ) self . iS . write_videofile ( \"mixedVideo.webm\" , 15 , audio = True ) print ( \"wrote \" + \"mixedVideo.webm\" )", "docstring_tokens": "Use pymovie to render ( visual + audio ) + text overlays .", "label": 0}, {"idx": "cosqa-train-8050", "doc": "rect positions topright topleft center python", "code": "def getTopRight(self):\n        \"\"\"\n        Retrieves a tuple with the x,y coordinates of the upper right point of the ellipse. \n        Requires the radius and the coordinates to be numbers\n        \"\"\"\n        return (float(self.get_cx()) + float(self.get_rx()), float(self.get_cy()) + float(self.get_ry()))", "code_tokens": "def getTopRight ( self ) : return ( float ( self . get_cx ( ) ) + float ( self . get_rx ( ) ) , float ( self . get_cy ( ) ) + float ( self . get_ry ( ) ) )", "docstring_tokens": "Retrieves a tuple with the x y coordinates of the upper right point of the ellipse . Requires the radius and the coordinates to be numbers", "label": 1}, {"idx": "cosqa-train-8051", "doc": "plot histogram python custom bins", "code": "def _histplot_op(ax, data, **kwargs):\n    \"\"\"Add a histogram for the data to the axes.\"\"\"\n    bins = get_bins(data)\n    ax.hist(data, bins=bins, align=\"left\", density=True, **kwargs)\n    return ax", "code_tokens": "def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "docstring_tokens": "Add a histogram for the data to the axes .", "label": 0}, {"idx": "cosqa-train-8052", "doc": "recursive dfs goal python", "code": "def dfs_recursive(graph, node, seen):\n    \"\"\"DFS, detect connected component, recursive implementation\n\n    :param graph: directed graph in listlist or listdict format\n    :param int node: to start graph exploration\n    :param boolean-table seen: will be set true for the connected component\n          containing node.\n    :complexity: `O(|V|+|E|)`\n    \"\"\"\n    seen[node] = True\n    for neighbor in graph[node]:\n        if not seen[neighbor]:\n            dfs_recursive(graph, neighbor, seen)", "code_tokens": "def dfs_recursive ( graph , node , seen ) : seen [ node ] = True for neighbor in graph [ node ] : if not seen [ neighbor ] : dfs_recursive ( graph , neighbor , seen )", "docstring_tokens": "DFS detect connected component recursive implementation", "label": 1}, {"idx": "cosqa-train-8053", "doc": "plot lognormal function in python", "code": "def lognorm(x, mu, sigma=1.0):\n    \"\"\" Log-normal function from scipy \"\"\"\n    return stats.lognorm(sigma, scale=mu).pdf(x)", "code_tokens": "def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )", "docstring_tokens": "Log - normal function from scipy", "label": 1}, {"idx": "cosqa-train-8054", "doc": "redis python get list length", "code": "def llen(self, name):\n        \"\"\"\n        Returns the length of the list.\n\n        :param name: str     the name of the redis key\n        :return: Future()\n        \"\"\"\n        with self.pipe as pipe:\n            return pipe.llen(self.redis_key(name))", "code_tokens": "def llen ( self , name ) : with self . pipe as pipe : return pipe . llen ( self . redis_key ( name ) )", "docstring_tokens": "Returns the length of the list .", "label": 1}, {"idx": "cosqa-train-8055", "doc": "plot remove axis python", "code": "def axes_off(ax):\n    \"\"\"Get rid of all axis ticks, lines, etc.\n    \"\"\"\n    ax.set_frame_on(False)\n    ax.axes.get_yaxis().set_visible(False)\n    ax.axes.get_xaxis().set_visible(False)", "code_tokens": "def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )", "docstring_tokens": "Get rid of all axis ticks lines etc .", "label": 1}, {"idx": "cosqa-train-8056", "doc": "regex password validation python", "code": "def is_password_valid(password):\n    \"\"\"\n    Check if a password is valid\n    \"\"\"\n    pattern = re.compile(r\"^.{4,75}$\")\n    return bool(pattern.match(password))", "code_tokens": "def is_password_valid ( password ) : pattern = re . compile ( r\"^.{4,75}$\" ) return bool ( pattern . match ( password ) )", "docstring_tokens": "Check if a password is valid", "label": 0}, {"idx": "cosqa-train-8057", "doc": "plot standard deviation of a column in python", "code": "def mad(v):\n    \"\"\"MAD -- Median absolute deviation. More robust than standard deviation.\n    \"\"\"\n    return np.median(np.abs(v - np.median(v)))", "code_tokens": "def mad ( v ) : return np . median ( np . abs ( v - np . median ( v ) ) )", "docstring_tokens": "MAD -- Median absolute deviation . More robust than standard deviation .", "label": 1}, {"idx": "cosqa-train-8058", "doc": "remove a file in a particular folder in python", "code": "def remover(file_path):\n    \"\"\"Delete a file or directory path only if it exists.\"\"\"\n    if os.path.isfile(file_path):\n        os.remove(file_path)\n        return True\n    elif os.path.isdir(file_path):\n        shutil.rmtree(file_path)\n        return True\n    else:\n        return False", "code_tokens": "def remover ( file_path ) : if os . path . isfile ( file_path ) : os . remove ( file_path ) return True elif os . path . isdir ( file_path ) : shutil . rmtree ( file_path ) return True else : return False", "docstring_tokens": "Delete a file or directory path only if it exists .", "label": 1}, {"idx": "cosqa-train-8059", "doc": "plotting a lognormal distribution in python", "code": "def lognorm(x, mu, sigma=1.0):\n    \"\"\" Log-normal function from scipy \"\"\"\n    return stats.lognorm(sigma, scale=mu).pdf(x)", "code_tokens": "def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )", "docstring_tokens": "Log - normal function from scipy", "label": 0}, {"idx": "cosqa-train-8060", "doc": "remove all spaces within string python", "code": "def unpunctuate(s, *, char_blacklist=string.punctuation):\n    \"\"\" Remove punctuation from string s. \"\"\"\n    # remove punctuation\n    s = \"\".join(c for c in s if c not in char_blacklist)\n    # remove consecutive spaces\n    return \" \".join(filter(None, s.split(\" \")))", "code_tokens": "def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = \"\" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return \" \" . join ( filter ( None , s . split ( \" \" ) ) )", "docstring_tokens": "Remove punctuation from string s .", "label": 1}, {"idx": "cosqa-train-8061", "doc": "ply python expression evaluator", "code": "def build(self, **kwargs):\n        \"\"\"Build the lexer.\"\"\"\n        self.lexer = ply.lex.lex(object=self, **kwargs)", "code_tokens": "def build ( self , * * kwargs ) : self . lexer = ply . lex . lex ( object = self , * * kwargs )", "docstring_tokens": "Build the lexer .", "label": 1}, {"idx": "cosqa-train-8062", "doc": "remove all underscores from string python", "code": "def normalise_string(string):\n    \"\"\" Strips trailing whitespace from string, lowercases it and replaces\n        spaces with underscores\n    \"\"\"\n    string = (string.strip()).lower()\n    return re.sub(r'\\W+', '_', string)", "code_tokens": "def normalise_string ( string ) : string = ( string . strip ( ) ) . lower ( ) return re . sub ( r'\\W+' , '_' , string )", "docstring_tokens": "Strips trailing whitespace from string lowercases it and replaces spaces with underscores", "label": 1}, {"idx": "cosqa-train-8063", "doc": "polar to cartesian image python", "code": "def cart2pol(x, y):\n    \"\"\"Cartesian to Polar coordinates conversion.\"\"\"\n    theta = np.arctan2(y, x)\n    rho = np.hypot(x, y)\n    return theta, rho", "code_tokens": "def cart2pol ( x , y ) : theta = np . arctan2 ( y , x ) rho = np . hypot ( x , y ) return theta , rho", "docstring_tokens": "Cartesian to Polar coordinates conversion .", "label": 0}, {"idx": "cosqa-train-8064", "doc": "remove b' from base64 python3", "code": "def toBase64(s):\n    \"\"\"Represent string / bytes s as base64, omitting newlines\"\"\"\n    if isinstance(s, str):\n        s = s.encode(\"utf-8\")\n    return binascii.b2a_base64(s)[:-1]", "code_tokens": "def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( \"utf-8\" ) return binascii . b2a_base64 ( s ) [ : - 1 ]", "docstring_tokens": "Represent string / bytes s as base64 omitting newlines", "label": 1}, {"idx": "cosqa-train-8065", "doc": "pop a key value pair dict python", "code": "def multi_pop(d, *args):\n    \"\"\" pops multiple keys off a dict like object \"\"\"\n    retval = {}\n    for key in args:\n        if key in d:\n            retval[key] = d.pop(key)\n    return retval", "code_tokens": "def multi_pop ( d , * args ) : retval = { } for key in args : if key in d : retval [ key ] = d . pop ( key ) return retval", "docstring_tokens": "pops multiple keys off a dict like object", "label": 1}, {"idx": "cosqa-train-8066", "doc": "remove characters from data frame column python", "code": "def _remove_nonascii(self, df):\n    \"\"\"Make copy and remove non-ascii characters from it.\"\"\"\n\n    df_copy = df.copy(deep=True)\n    for col in df_copy.columns:\n      if (df_copy[col].dtype == np.dtype('O')):\n        df_copy[col] = df[col].apply(\n          lambda x: re.sub(r'[^\\x00-\\x7f]', r'', x) if isinstance(x, six.string_types) else x)\n\n    return df_copy", "code_tokens": "def _remove_nonascii ( self , df ) : df_copy = df . copy ( deep = True ) for col in df_copy . columns : if ( df_copy [ col ] . dtype == np . dtype ( 'O' ) ) : df_copy [ col ] = df [ col ] . apply ( lambda x : re . sub ( r'[^\\x00-\\x7f]' , r'' , x ) if isinstance ( x , six . string_types ) else x ) return df_copy", "docstring_tokens": "Make copy and remove non - ascii characters from it .", "label": 0}, {"idx": "cosqa-train-8067", "doc": "pretty print columns python", "code": "def _get_printable_columns(columns, row):\n    \"\"\"Return only the part of the row which should be printed.\n    \"\"\"\n    if not columns:\n        return row\n\n    # Extract the column values, in the order specified.\n    return tuple(row[c] for c in columns)", "code_tokens": "def _get_printable_columns ( columns , row ) : if not columns : return row # Extract the column values, in the order specified. return tuple ( row [ c ] for c in columns )", "docstring_tokens": "Return only the part of the row which should be printed .", "label": 1}, {"idx": "cosqa-train-8068", "doc": "remove commas from list in python", "code": "def strip_spaces(value, sep=None, join=True):\n    \"\"\"Cleans trailing whitespaces and replaces also multiple whitespaces with a single space.\"\"\"\n    value = value.strip()\n    value = [v.strip() for v in value.split(sep)]\n    join_sep = sep or ' '\n    return join_sep.join(value) if join else value", "code_tokens": "def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value", "docstring_tokens": "Cleans trailing whitespaces and replaces also multiple whitespaces with a single space .", "label": 0}, {"idx": "cosqa-train-8069", "doc": "prevent sorted function in python to not remove duplicates", "code": "def purge_duplicates(list_in):\n    \"\"\"Remove duplicates from list while preserving order.\n\n    Parameters\n    ----------\n    list_in: Iterable\n\n    Returns\n    -------\n    list\n        List of first occurences in order\n    \"\"\"\n    _list = []\n    for item in list_in:\n        if item not in _list:\n            _list.append(item)\n    return _list", "code_tokens": "def purge_duplicates ( list_in ) : _list = [ ] for item in list_in : if item not in _list : _list . append ( item ) return _list", "docstring_tokens": "Remove duplicates from list while preserving order .", "label": 1}, {"idx": "cosqa-train-8070", "doc": "remove comments in json file using python", "code": "def parse_json(filename):\n    \"\"\" Parse a JSON file\n        First remove comments and then use the json module package\n        Comments look like :\n            // ...\n        or\n            /*\n            ...\n            */\n    \"\"\"\n    # Regular expression for comments\n    comment_re = re.compile(\n        '(^)?[^\\S\\n]*/(?:\\*(.*?)\\*/[^\\S\\n]*|/[^\\n]*)($)?',\n        re.DOTALL | re.MULTILINE\n    )\n\n    with open(filename) as f:\n        content = ''.join(f.readlines())\n\n        ## Looking for comments\n        match = comment_re.search(content)\n        while match:\n            # single line comment\n            content = content[:match.start()] + content[match.end():]\n            match = comment_re.search(content)\n\n        # Return json file\n        return json.loads(content)", "code_tokens": "def parse_json ( filename ) : # Regular expression for comments comment_re = re . compile ( '(^)?[^\\S\\n]*/(?:\\*(.*?)\\*/[^\\S\\n]*|/[^\\n]*)($)?' , re . DOTALL | re . MULTILINE ) with open ( filename ) as f : content = '' . join ( f . readlines ( ) ) ## Looking for comments match = comment_re . search ( content ) while match : # single line comment content = content [ : match . start ( ) ] + content [ match . end ( ) : ] match = comment_re . search ( content ) # Return json file return json . loads ( content )", "docstring_tokens": "Parse a JSON file First remove comments and then use the json module package Comments look like : // ... or / * ... * /", "label": 1}, {"idx": "cosqa-train-8071", "doc": "print all first lines from file python", "code": "def head(filename, n=10):\n    \"\"\" prints the top `n` lines of a file \"\"\"\n    with freader(filename) as fr:\n        for _ in range(n):\n            print(fr.readline().strip())", "code_tokens": "def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )", "docstring_tokens": "prints the top n lines of a file", "label": 0}, {"idx": "cosqa-train-8072", "doc": "remove duplicate elements from a list python", "code": "def dedup_list(l):\n    \"\"\"Given a list (l) will removing duplicates from the list,\n       preserving the original order of the list. Assumes that\n       the list entrie are hashable.\"\"\"\n    dedup = set()\n    return [ x for x in l if not (x in dedup or dedup.add(x))]", "code_tokens": "def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]", "docstring_tokens": "Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable .", "label": 0}, {"idx": "cosqa-train-8073", "doc": "print dictionary python without quotes", "code": "def _attrprint(d, delimiter=', '):\n    \"\"\"Print a dictionary of attributes in the DOT format\"\"\"\n    return delimiter.join(('\"%s\"=\"%s\"' % item) for item in sorted(d.items()))", "code_tokens": "def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '\"%s\"=\"%s\"' % item ) for item in sorted ( d . items ( ) ) )", "docstring_tokens": "Print a dictionary of attributes in the DOT format", "label": 1}, {"idx": "cosqa-train-8074", "doc": "remove duplicated records in python", "code": "def _remove_duplicate_files(xs):\n    \"\"\"Remove files specified multiple times in a list.\n    \"\"\"\n    seen = set([])\n    out = []\n    for x in xs:\n        if x[\"path\"] not in seen:\n            out.append(x)\n            seen.add(x[\"path\"])\n    return out", "code_tokens": "def _remove_duplicate_files ( xs ) : seen = set ( [ ] ) out = [ ] for x in xs : if x [ \"path\" ] not in seen : out . append ( x ) seen . add ( x [ \"path\" ] ) return out", "docstring_tokens": "Remove files specified multiple times in a list .", "label": 1}, {"idx": "cosqa-train-8075", "doc": "print protobuf contents python", "code": "def toJson(protoObject, indent=None):\n    \"\"\"\n    Serialises a protobuf object as json\n    \"\"\"\n    # Using the internal method because this way we can reformat the JSON\n    js = json_format.MessageToDict(protoObject, False)\n    return json.dumps(js, indent=indent)", "code_tokens": "def toJson ( protoObject , indent = None ) : # Using the internal method because this way we can reformat the JSON js = json_format . MessageToDict ( protoObject , False ) return json . dumps ( js , indent = indent )", "docstring_tokens": "Serialises a protobuf object as json", "label": 0}, {"idx": "cosqa-train-8076", "doc": "remove file in the path in python", "code": "def file_remove(self, path, filename):\n        \"\"\"Check if filename exists and remove\n        \"\"\"\n        if os.path.isfile(path + filename):\n            os.remove(path + filename)", "code_tokens": "def file_remove ( self , path , filename ) : if os . path . isfile ( path + filename ) : os . remove ( path + filename )", "docstring_tokens": "Check if filename exists and remove", "label": 0}, {"idx": "cosqa-train-8077", "doc": "print text in color python", "code": "def printc(cls, txt, color=colors.red):\n        \"\"\"Print in color.\"\"\"\n        print(cls.color_txt(txt, color))", "code_tokens": "def printc ( cls , txt , color = colors . red ) : print ( cls . color_txt ( txt , color ) )", "docstring_tokens": "Print in color .", "label": 0}, {"idx": "cosqa-train-8078", "doc": "remove if 0 from series python", "code": "def __convert_none_to_zero(self, ts):\n        \"\"\"\n        Convert None values to 0 so the data works with Matplotlib\n        :param ts:\n        :return: a list with 0s where Nones existed\n        \"\"\"\n\n        if not ts:\n            return ts\n\n        ts_clean = [val if val else 0 for val in ts]\n\n        return ts_clean", "code_tokens": "def __convert_none_to_zero ( self , ts ) : if not ts : return ts ts_clean = [ val if val else 0 for val in ts ] return ts_clean", "docstring_tokens": "Convert None values to 0 so the data works with Matplotlib : param ts : : return : a list with 0s where Nones existed", "label": 1}, {"idx": "cosqa-train-8079", "doc": "print without starting new line python", "code": "def raw_print(*args, **kw):\n    \"\"\"Raw print to sys.__stdout__, otherwise identical interface to print().\"\"\"\n\n    print(*args, sep=kw.get('sep', ' '), end=kw.get('end', '\\n'),\n          file=sys.__stdout__)\n    sys.__stdout__.flush()", "code_tokens": "def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )", "docstring_tokens": "Raw print to sys . __stdout__ otherwise identical interface to print () .", "label": 0}, {"idx": "cosqa-train-8080", "doc": "remove in between spaces in string python", "code": "def strip_spaces(x):\n    \"\"\"\n    Strips spaces\n    :param x:\n    :return:\n    \"\"\"\n    x = x.replace(b' ', b'')\n    x = x.replace(b'\\t', b'')\n    return x", "code_tokens": "def strip_spaces ( x ) : x = x . replace ( b' ' , b'' ) x = x . replace ( b'\\t' , b'' ) return x", "docstring_tokens": "Strips spaces : param x : : return :", "label": 1}, {"idx": "cosqa-train-8081", "doc": "printing attributes of object in python", "code": "def _repr(obj):\n    \"\"\"Show the received object as precise as possible.\"\"\"\n    vals = \", \".join(\"{}={!r}\".format(\n        name, getattr(obj, name)) for name in obj._attribs)\n    if vals:\n        t = \"{}(name={}, {})\".format(obj.__class__.__name__, obj.name, vals)\n    else:\n        t = \"{}(name={})\".format(obj.__class__.__name__, obj.name)\n    return t", "code_tokens": "def _repr ( obj ) : vals = \", \" . join ( \"{}={!r}\" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = \"{}(name={}, {})\" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = \"{}(name={})\" . format ( obj . __class__ . __name__ , obj . name ) return t", "docstring_tokens": "Show the received object as precise as possible .", "label": 0}, {"idx": "cosqa-train-8082", "doc": "remove item from series python", "code": "def remove_series(self, series):\n        \"\"\"Removes a :py:class:`.Series` from the chart.\n\n        :param Series series: The :py:class:`.Series` to remove.\n        :raises ValueError: if you try to remove the last\\\n        :py:class:`.Series`.\"\"\"\n\n        if len(self.all_series()) == 1:\n            raise ValueError(\"Cannot remove last series from %s\" % str(self))\n        self._all_series.remove(series)\n        series._chart = None", "code_tokens": "def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( \"Cannot remove last series from %s\" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None", "docstring_tokens": "Removes a : py : class : . Series from the chart .", "label": 1}, {"idx": "cosqa-train-8083", "doc": "printing text in the center python", "code": "def info(txt):\n    \"\"\"Print, emphasized 'neutral', the given 'txt' message\"\"\"\n\n    print(\"%s# %s%s%s\" % (PR_EMPH_CC, get_time_stamp(), txt, PR_NC))\n    sys.stdout.flush()", "code_tokens": "def info ( txt ) : print ( \"%s# %s%s%s\" % ( PR_EMPH_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "docstring_tokens": "Print emphasized neutral the given txt message", "label": 0}, {"idx": "cosqa-train-8084", "doc": "remove line separators from text python", "code": "def strip_line(line, sep=os.linesep):\n    \"\"\"\n    Removes occurrence of character (sep) from a line of text\n    \"\"\"\n\n    try:\n        return line.strip(sep)\n    except TypeError:\n        return line.decode('utf-8').strip(sep)", "code_tokens": "def strip_line ( line , sep = os . linesep ) : try : return line . strip ( sep ) except TypeError : return line . decode ( 'utf-8' ) . strip ( sep )", "docstring_tokens": "Removes occurrence of character ( sep ) from a line of text", "label": 1}, {"idx": "cosqa-train-8085", "doc": "probabilities under function in python", "code": "def EvalBinomialPmf(k, n, p):\n    \"\"\"Evaluates the binomial pmf.\n\n    Returns the probabily of k successes in n trials with probability p.\n    \"\"\"\n    return scipy.stats.binom.pmf(k, n, p)", "code_tokens": "def EvalBinomialPmf ( k , n , p ) : return scipy . stats . binom . pmf ( k , n , p )", "docstring_tokens": "Evaluates the binomial pmf .", "label": 1}, {"idx": "cosqa-train-8086", "doc": "remove lines from doc using python", "code": "def lines(input):\n    \"\"\"Remove comments and empty lines\"\"\"\n    for raw_line in input:\n        line = raw_line.strip()\n        if line and not line.startswith('#'):\n            yield strip_comments(line)", "code_tokens": "def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )", "docstring_tokens": "Remove comments and empty lines", "label": 0}, {"idx": "cosqa-train-8087", "doc": "programmatically accessing docstrings in python", "code": "def format_docstring(*args, **kwargs):\n    \"\"\"\n    Decorator for clean docstring formatting\n    \"\"\"\n    def decorator(func):\n        func.__doc__ = getdoc(func).format(*args, **kwargs)\n        return func\n    return decorator", "code_tokens": "def format_docstring ( * args , * * kwargs ) : def decorator ( func ) : func . __doc__ = getdoc ( func ) . format ( * args , * * kwargs ) return func return decorator", "docstring_tokens": "Decorator for clean docstring formatting", "label": 0}, {"idx": "cosqa-train-8088", "doc": "remove multiples from set python", "code": "def unique(transactions):\n    \"\"\" Remove any duplicate entries. \"\"\"\n    seen = set()\n    # TODO: Handle comments\n    return [x for x in transactions if not (x in seen or seen.add(x))]", "code_tokens": "def unique ( transactions ) : seen = set ( ) # TODO: Handle comments return [ x for x in transactions if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Remove any duplicate entries .", "label": 1}, {"idx": "cosqa-train-8089", "doc": "programming the sigmoid activation function python", "code": "def softplus(attrs, inputs, proto_obj):\n    \"\"\"Applies the sofplus activation function element-wise to the input.\"\"\"\n    new_attrs = translation_utils._add_extra_attributes(attrs, {'act_type' : 'softrelu'})\n    return 'Activation', new_attrs, inputs", "code_tokens": "def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs", "docstring_tokens": "Applies the sofplus activation function element - wise to the input .", "label": 1}, {"idx": "cosqa-train-8090", "doc": "pull multiple values to make table python", "code": "def _tab(content):\n    \"\"\"\n    Helper funcation that converts text-based get response\n    to tab separated values for additional manipulation.\n    \"\"\"\n    response = _data_frame(content).to_csv(index=False,sep='\\t')\n    return response", "code_tokens": "def _tab ( content ) : response = _data_frame ( content ) . to_csv ( index = False , sep = '\\t' ) return response", "docstring_tokens": "Helper funcation that converts text - based get response to tab separated values for additional manipulation .", "label": 1}, {"idx": "cosqa-train-8091", "doc": "remove paritcular character for sentence in python", "code": "def unapostrophe(text):\n    \"\"\"Strip apostrophe and 's' from the end of a string.\"\"\"\n    text = re.sub(r'[%s]s?$' % ''.join(APOSTROPHES), '', text)\n    return text", "code_tokens": "def unapostrophe ( text ) : text = re . sub ( r'[%s]s?$' % '' . join ( APOSTROPHES ) , '' , text ) return text", "docstring_tokens": "Strip apostrophe and s from the end of a string .", "label": 0}, {"idx": "cosqa-train-8092", "doc": "pybool to c++ python 3", "code": "def convertToBool():\n    \"\"\" Convert a byte value to boolean (0 or 1) if\n    the global flag strictBool is True\n    \"\"\"\n    if not OPTIONS.strictBool.value:\n        return []\n\n    REQUIRES.add('strictbool.asm')\n\n    result = []\n    result.append('pop af')\n    result.append('call __NORMALIZE_BOOLEAN')\n    result.append('push af')\n\n    return result", "code_tokens": "def convertToBool ( ) : if not OPTIONS . strictBool . value : return [ ] REQUIRES . add ( 'strictbool.asm' ) result = [ ] result . append ( 'pop af' ) result . append ( 'call __NORMALIZE_BOOLEAN' ) result . append ( 'push af' ) return result", "docstring_tokens": "Convert a byte value to boolean ( 0 or 1 ) if the global flag strictBool is True", "label": 1}, {"idx": "cosqa-train-8093", "doc": "remove pixel in python opencv", "code": "def screen_cv2(self):\n        \"\"\"cv2 Image of current window screen\"\"\"\n        pil_image = self.screen.convert('RGB')\n        cv2_image = np.array(pil_image)\n        pil_image.close()\n        # Convert RGB to BGR \n        cv2_image = cv2_image[:, :, ::-1]\n        return cv2_image", "code_tokens": "def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR \n cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image", "docstring_tokens": "cv2 Image of current window screen", "label": 0}, {"idx": "cosqa-train-8094", "doc": "pyhon read from mongo to python object", "code": "def _obj_cursor_to_dictionary(self, cursor):\n        \"\"\"Handle conversion of pymongo cursor into a JSON object formatted for UI consumption\n\n        :param dict cursor: a mongo document that should be converted to primitive types for the client code\n        :returns: a primitive dictionary\n        :rtype: dict\n        \"\"\"\n        if not cursor:\n            return cursor\n\n        cursor = json.loads(json.dumps(cursor, cls=BSONEncoder))\n\n        if cursor.get(\"_id\"):\n            cursor[\"id\"] = cursor.get(\"_id\")\n            del cursor[\"_id\"]\n\n        return cursor", "code_tokens": "def _obj_cursor_to_dictionary ( self , cursor ) : if not cursor : return cursor cursor = json . loads ( json . dumps ( cursor , cls = BSONEncoder ) ) if cursor . get ( \"_id\" ) : cursor [ \"id\" ] = cursor . get ( \"_id\" ) del cursor [ \"_id\" ] return cursor", "docstring_tokens": "Handle conversion of pymongo cursor into a JSON object formatted for UI consumption", "label": 1}, {"idx": "cosqa-train-8095", "doc": "remove spaces in text python", "code": "def normalize_value(text):\n    \"\"\"\n    This removes newlines and multiple spaces from a string.\n    \"\"\"\n    result = text.replace('\\n', ' ')\n    result = re.subn('[ ]{2,}', ' ', result)[0]\n    return result", "code_tokens": "def normalize_value ( text ) : result = text . replace ( '\\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result", "docstring_tokens": "This removes newlines and multiple spaces from a string .", "label": 1}, {"idx": "cosqa-train-8096", "doc": "python '\\x' plus a int", "code": "def add_0x(string):\n    \"\"\"Add 0x to string at start.\n    \"\"\"\n    if isinstance(string, bytes):\n        string = string.decode('utf-8')\n    return '0x' + str(string)", "code_tokens": "def add_0x ( string ) : if isinstance ( string , bytes ) : string = string . decode ( 'utf-8' ) return '0x' + str ( string )", "docstring_tokens": "Add 0x to string at start .", "label": 0}, {"idx": "cosqa-train-8097", "doc": "remove strings that have a word from stopwords in them nltk python", "code": "def wordify(text):\n    \"\"\"Generate a list of words given text, removing punctuation.\n\n    Parameters\n    ----------\n    text : unicode\n        A piece of english text.\n\n    Returns\n    -------\n    words : list\n        List of words.\n    \"\"\"\n    stopset = set(nltk.corpus.stopwords.words('english'))\n    tokens = nltk.WordPunctTokenizer().tokenize(text)\n    return [w for w in tokens if w not in stopset]", "code_tokens": "def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]", "docstring_tokens": "Generate a list of words given text removing punctuation .", "label": 0}, {"idx": "cosqa-train-8098", "doc": "python 'nonetype' object is not iterable", "code": "def is_iterable(obj):\n    \"\"\"\n    Are we being asked to look up a list of things, instead of a single thing?\n    We check for the `__iter__` attribute so that this can cover types that\n    don't have to be known by this module, such as NumPy arrays.\n\n    Strings, however, should be considered as atomic values to look up, not\n    iterables. The same goes for tuples, since they are immutable and therefore\n    valid entries.\n\n    We don't need to check for the Python 2 `unicode` type, because it doesn't\n    have an `__iter__` attribute anyway.\n    \"\"\"\n    return (\n        hasattr(obj, \"__iter__\")\n        and not isinstance(obj, str)\n        and not isinstance(obj, tuple)\n    )", "code_tokens": "def is_iterable ( obj ) : return ( hasattr ( obj , \"__iter__\" ) and not isinstance ( obj , str ) and not isinstance ( obj , tuple ) )", "docstring_tokens": "Are we being asked to look up a list of things instead of a single thing? We check for the __iter__ attribute so that this can cover types that don t have to be known by this module such as NumPy arrays .", "label": 1}, {"idx": "cosqa-train-8099", "doc": "removing all the elements of a list python", "code": "def unique(seq):\n    \"\"\"Return the unique elements of a collection even if those elements are\n       unhashable and unsortable, like dicts and sets\"\"\"\n    cleaned = []\n    for each in seq:\n        if each not in cleaned:\n            cleaned.append(each)\n    return cleaned", "code_tokens": "def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned", "docstring_tokens": "Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets", "label": 0}, {"idx": "cosqa-train-8100", "doc": "removing noise from audio python", "code": "def synthesize(self, duration):\n        \"\"\"\n        Synthesize white noise\n\n        Args:\n            duration (numpy.timedelta64): The duration of the synthesized sound\n        \"\"\"\n        sr = self.samplerate.samples_per_second\n        seconds = duration / Seconds(1)\n        samples = np.random.uniform(low=-1., high=1., size=int(sr * seconds))\n        return AudioSamples(samples, self.samplerate)", "code_tokens": "def synthesize ( self , duration ) : sr = self . samplerate . samples_per_second seconds = duration / Seconds ( 1 ) samples = np . random . uniform ( low = - 1. , high = 1. , size = int ( sr * seconds ) ) return AudioSamples ( samples , self . samplerate )", "docstring_tokens": "Synthesize white noise", "label": 0}, {"idx": "cosqa-train-8101", "doc": "python 2 logging rotatingfilehandler", "code": "def timed_rotating_file_handler(name, logname, filename, when='h',\n                                interval=1, backupCount=0,\n                                encoding=None, delay=False, utc=False):\n    \"\"\"\n    A Bark logging handler logging output to a named file.  At\n    intervals specified by the 'when', the file will be rotated, under\n    control of 'backupCount'.\n\n    Similar to logging.handlers.TimedRotatingFileHandler.\n    \"\"\"\n\n    return wrap_log_handler(logging.handlers.TimedRotatingFileHandler(\n        filename, when=when, interval=interval, backupCount=backupCount,\n        encoding=encoding, delay=delay, utc=utc))", "code_tokens": "def timed_rotating_file_handler ( name , logname , filename , when = 'h' , interval = 1 , backupCount = 0 , encoding = None , delay = False , utc = False ) : return wrap_log_handler ( logging . handlers . TimedRotatingFileHandler ( filename , when = when , interval = interval , backupCount = backupCount , encoding = encoding , delay = delay , utc = utc ) )", "docstring_tokens": "A Bark logging handler logging output to a named file . At intervals specified by the when the file will be rotated under control of backupCount .", "label": 1}, {"idx": "cosqa-train-8102", "doc": "replace a list of strings from a text python", "code": "def replace_list(items, match, replacement):\n    \"\"\"Replaces occurrences of a match string in a given list of strings and returns\n    a list of new strings. The match string can be a regex expression.\n\n    Args:\n        items (list):       the list of strings to modify.\n        match (str):        the search expression.\n        replacement (str):  the string to replace with.\n    \"\"\"\n    return [replace(item, match, replacement) for item in items]", "code_tokens": "def replace_list ( items , match , replacement ) : return [ replace ( item , match , replacement ) for item in items ]", "docstring_tokens": "Replaces occurrences of a match string in a given list of strings and returns a list of new strings . The match string can be a regex expression .", "label": 1}, {"idx": "cosqa-train-8103", "doc": "replace a pattern with regex function python", "code": "def fmt_subst(regex, subst):\n    \"\"\"Replace regex with string.\"\"\"\n    return lambda text: re.sub(regex, subst, text) if text else text", "code_tokens": "def fmt_subst ( regex , subst ) : return lambda text : re . sub ( regex , subst , text ) if text else text", "docstring_tokens": "Replace regex with string .", "label": 0}, {"idx": "cosqa-train-8104", "doc": "python 2d array min axis", "code": "def Min(a, axis, keep_dims):\n    \"\"\"\n    Min reduction op.\n    \"\"\"\n    return np.amin(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis),\n                   keepdims=keep_dims),", "code_tokens": "def Min ( a , axis , keep_dims ) : return np . amin ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "docstring_tokens": "Min reduction op .", "label": 0}, {"idx": "cosqa-train-8105", "doc": "replace all char value by space in list in python", "code": "def delistify(x):\n    \"\"\" A basic slug version of a given parameter list. \"\"\"\n    if isinstance(x, list):\n        x = [e.replace(\"'\", \"\") for e in x]\n        return '-'.join(sorted(x))\n    return x", "code_tokens": "def delistify ( x ) : if isinstance ( x , list ) : x = [ e . replace ( \"'\" , \"\" ) for e in x ] return '-' . join ( sorted ( x ) ) return x", "docstring_tokens": "A basic slug version of a given parameter list .", "label": 0}, {"idx": "cosqa-train-8106", "doc": "python 3 a list of widgets with scroll bar", "code": "def __grid_widgets(self):\n        \"\"\"Places all the child widgets in the appropriate positions.\"\"\"\n        scrollbar_column = 0 if self.__compound is tk.LEFT else 2\n        self._canvas.grid(row=0, column=1, sticky=\"nswe\")\n        self._scrollbar.grid(row=0, column=scrollbar_column, sticky=\"ns\")", "code_tokens": "def __grid_widgets ( self ) : scrollbar_column = 0 if self . __compound is tk . LEFT else 2 self . _canvas . grid ( row = 0 , column = 1 , sticky = \"nswe\" ) self . _scrollbar . grid ( row = 0 , column = scrollbar_column , sticky = \"ns\" )", "docstring_tokens": "Places all the child widgets in the appropriate positions .", "label": 1}, {"idx": "cosqa-train-8107", "doc": "replace all instaces of substring python", "code": "def replace(s, replace):\n    \"\"\"Replace multiple values in a string\"\"\"\n    for r in replace:\n        s = s.replace(*r)\n    return s", "code_tokens": "def replace ( s , replace ) : for r in replace : s = s . replace ( * r ) return s", "docstring_tokens": "Replace multiple values in a string", "label": 0}, {"idx": "cosqa-train-8108", "doc": "python 3 assert two lists are equal", "code": "def expect_all(a, b):\n    \"\"\"\\\n    Asserts that two iterables contain the same values.\n    \"\"\"\n    assert all(_a == _b for _a, _b in zip_longest(a, b))", "code_tokens": "def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )", "docstring_tokens": "\\ Asserts that two iterables contain the same values .", "label": 0}, {"idx": "cosqa-train-8109", "doc": "replace comments with a space python", "code": "def _comment(string):\n    \"\"\"return string as a comment\"\"\"\n    lines = [line.strip() for line in string.splitlines()]\n    return \"# \" + (\"%s# \" % linesep).join(lines)", "code_tokens": "def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return \"# \" + ( \"%s# \" % linesep ) . join ( lines )", "docstring_tokens": "return string as a comment", "label": 1}, {"idx": "cosqa-train-8110", "doc": "python 3 create a set with a custom key", "code": "def _get_set(self, key, operation, create=False):\n        \"\"\"\n        Get (and maybe create) a set by name.\n        \"\"\"\n        return self._get_by_type(key, operation, create, b'set', set())", "code_tokens": "def _get_set ( self , key , operation , create = False ) : return self . _get_by_type ( key , operation , create , b'set' , set ( ) )", "docstring_tokens": "Get ( and maybe create ) a set by name .", "label": 1}, {"idx": "cosqa-train-8111", "doc": "replace items in dictionary in python", "code": "def replace_all(text, dic):\n    \"\"\"Takes a string and dictionary. replaces all occurrences of i with j\"\"\"\n\n    for i, j in dic.iteritems():\n        text = text.replace(i, j)\n    return text", "code_tokens": "def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text", "docstring_tokens": "Takes a string and dictionary . replaces all occurrences of i with j", "label": 1}, {"idx": "cosqa-train-8112", "doc": "python 3 file get extension", "code": "def get_abi3_suffix():\n    \"\"\"Return the file extension for an abi3-compliant Extension()\"\"\"\n    for suffix, _, _ in (s for s in imp.get_suffixes() if s[2] == imp.C_EXTENSION):\n        if '.abi3' in suffix:  # Unix\n            return suffix\n        elif suffix == '.pyd':  # Windows\n            return suffix", "code_tokens": "def get_abi3_suffix ( ) : for suffix , _ , _ in ( s for s in imp . get_suffixes ( ) if s [ 2 ] == imp . C_EXTENSION ) : if '.abi3' in suffix : # Unix return suffix elif suffix == '.pyd' : # Windows return suffix", "docstring_tokens": "Return the file extension for an abi3 - compliant Extension ()", "label": 1}, {"idx": "cosqa-train-8113", "doc": "replace new line in a string with space in python", "code": "def replaceNewlines(string, newlineChar):\n\t\"\"\"There's probably a way to do this with string functions but I was lazy.\n\t\tReplace all instances of \\r or \\n in a string with something else.\"\"\"\n\tif newlineChar in string:\n\t\tsegments = string.split(newlineChar)\n\t\tstring = \"\"\n\t\tfor segment in segments:\n\t\t\tstring += segment\n\treturn string", "code_tokens": "def replaceNewlines ( string , newlineChar ) : if newlineChar in string : segments = string . split ( newlineChar ) string = \"\" for segment in segments : string += segment return string", "docstring_tokens": "There s probably a way to do this with string functions but I was lazy . Replace all instances of \\ r or \\ n in a string with something else .", "label": 1}, {"idx": "cosqa-train-8114", "doc": "python 3 get mouse clock coords", "code": "def mouse_get_pos():\n    \"\"\"\n\n    :return:\n    \"\"\"\n    p = POINT()\n    AUTO_IT.AU3_MouseGetPos(ctypes.byref(p))\n    return p.x, p.y", "code_tokens": "def mouse_get_pos ( ) : p = POINT ( ) AUTO_IT . AU3_MouseGetPos ( ctypes . byref ( p ) ) return p . x , p . y", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-8115", "doc": "replacing values of a column using functions python", "code": "def replace(table, field, a, b, **kwargs):\n    \"\"\"\n    Convenience function to replace all occurrences of `a` with `b` under the\n    given field. See also :func:`convert`.\n\n    The ``where`` keyword argument can be given with a callable or expression\n    which is evaluated on each row and which should return True if the\n    conversion should be applied on that row, else False.\n\n    \"\"\"\n\n    return convert(table, field, {a: b}, **kwargs)", "code_tokens": "def replace ( table , field , a , b , * * kwargs ) : return convert ( table , field , { a : b } , * * kwargs )", "docstring_tokens": "Convenience function to replace all occurrences of a with b under the given field . See also : func : convert .", "label": 1}, {"idx": "cosqa-train-8116", "doc": "python 3 how to remove a list from a list]", "code": "def rm_empty_indices(*args):\n    \"\"\"\n    Remove unwanted list indices. First argument is the list\n    of indices to remove. Other elements are the lists\n    to trim.\n    \"\"\"\n    rm_inds = args[0]\n\n    if not rm_inds:\n        return args[1:]\n\n    keep_inds = [i for i in range(len(args[1])) if i not in rm_inds]\n\n    return [[a[i] for i in keep_inds] for a in args[1:]]", "code_tokens": "def rm_empty_indices ( * args ) : rm_inds = args [ 0 ] if not rm_inds : return args [ 1 : ] keep_inds = [ i for i in range ( len ( args [ 1 ] ) ) if i not in rm_inds ] return [ [ a [ i ] for i in keep_inds ] for a in args [ 1 : ] ]", "docstring_tokens": "Remove unwanted list indices . First argument is the list of indices to remove . Other elements are the lists to trim .", "label": 0}, {"idx": "cosqa-train-8117", "doc": "request flask python form exist", "code": "def submit_the_only_form(self):\n    \"\"\"\n    Look for a form on the page and submit it.\n\n    Asserts if more than one form exists.\n    \"\"\"\n    form = ElementSelector(world.browser, str('//form'))\n    assert form, \"Cannot find a form on the page.\"\n    form.submit()", "code_tokens": "def submit_the_only_form ( self ) : form = ElementSelector ( world . browser , str ( '//form' ) ) assert form , \"Cannot find a form on the page.\" form . submit ( )", "docstring_tokens": "Look for a form on the page and submit it .", "label": 0}, {"idx": "cosqa-train-8118", "doc": "python 3 inspect function signature", "code": "def get_args(method_or_func):\n    \"\"\"Returns method or function arguments.\"\"\"\n    try:\n        # Python 3.0+\n        args = list(inspect.signature(method_or_func).parameters.keys())\n    except AttributeError:\n        # Python 2.7\n        args = inspect.getargspec(method_or_func).args\n    return args", "code_tokens": "def get_args ( method_or_func ) : try : # Python 3.0+ args = list ( inspect . signature ( method_or_func ) . parameters . keys ( ) ) except AttributeError : # Python 2.7 args = inspect . getargspec ( method_or_func ) . args return args", "docstring_tokens": "Returns method or function arguments .", "label": 1}, {"idx": "cosqa-train-8119", "doc": "requests status code 409 python avoid", "code": "def raise_for_not_ok_status(response):\n    \"\"\"\n    Raises a `requests.exceptions.HTTPError` if the response has a non-200\n    status code.\n    \"\"\"\n    if response.code != OK:\n        raise HTTPError('Non-200 response code (%s) for url: %s' % (\n            response.code, uridecode(response.request.absoluteURI)))\n\n    return response", "code_tokens": "def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response", "docstring_tokens": "Raises a requests . exceptions . HTTPError if the response has a non - 200 status code .", "label": 1}, {"idx": "cosqa-train-8120", "doc": "python 3 remove leading trailing quote", "code": "def _repr_strip(mystring):\n    \"\"\"\n    Returns the string without any initial or final quotes.\n    \"\"\"\n    r = repr(mystring)\n    if r.startswith(\"'\") and r.endswith(\"'\"):\n        return r[1:-1]\n    else:\n        return r", "code_tokens": "def _repr_strip ( mystring ) : r = repr ( mystring ) if r . startswith ( \"'\" ) and r . endswith ( \"'\" ) : return r [ 1 : - 1 ] else : return r", "docstring_tokens": "Returns the string without any initial or final quotes .", "label": 0}, {"idx": "cosqa-train-8121", "doc": "reset logging handler at end of iteration python", "code": "def new_iteration(self, prefix):\n        \"\"\"When inside a loop logger, created a new iteration\n        \"\"\"\n        # Flush data for the current iteration\n        self.flush()\n\n        # Fix prefix\n        self.prefix[-1] = prefix\n        self.reset_formatter()", "code_tokens": "def new_iteration ( self , prefix ) : # Flush data for the current iteration self . flush ( ) # Fix prefix self . prefix [ - 1 ] = prefix self . reset_formatter ( )", "docstring_tokens": "When inside a loop logger created a new iteration", "label": 0}, {"idx": "cosqa-train-8122", "doc": "python 3 tkinter open file dialog", "code": "def askopenfilename(**kwargs):\n    \"\"\"Return file name(s) from Tkinter's file open dialog.\"\"\"\n    try:\n        from Tkinter import Tk\n        import tkFileDialog as filedialog\n    except ImportError:\n        from tkinter import Tk, filedialog\n    root = Tk()\n    root.withdraw()\n    root.update()\n    filenames = filedialog.askopenfilename(**kwargs)\n    root.destroy()\n    return filenames", "code_tokens": "def askopenfilename ( * * kwargs ) : try : from Tkinter import Tk import tkFileDialog as filedialog except ImportError : from tkinter import Tk , filedialog root = Tk ( ) root . withdraw ( ) root . update ( ) filenames = filedialog . askopenfilename ( * * kwargs ) root . destroy ( ) return filenames", "docstring_tokens": "Return file name ( s ) from Tkinter s file open dialog .", "label": 1}, {"idx": "cosqa-train-8123", "doc": "reshape data long in python", "code": "def batchify(data, batch_size):\n    \"\"\"Reshape data into (num_example, batch_size)\"\"\"\n    nbatch = data.shape[0] // batch_size\n    data = data[:nbatch * batch_size]\n    data = data.reshape((batch_size, nbatch)).T\n    return data", "code_tokens": "def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data", "docstring_tokens": "Reshape data into ( num_example batch_size )", "label": 1}, {"idx": "cosqa-train-8124", "doc": "python 3 what do { represent", "code": "def serialisasi(self):\n        \"\"\"Mengembalikan hasil serialisasi objek Makna ini.\n\n        :returns: Dictionary hasil serialisasi\n        :rtype: dict\n        \"\"\"\n\n        return {\n            \"kelas\": self.kelas,\n            \"submakna\": self.submakna,\n            \"info\": self.info,\n            \"contoh\": self.contoh\n        }", "code_tokens": "def serialisasi ( self ) : return { \"kelas\" : self . kelas , \"submakna\" : self . submakna , \"info\" : self . info , \"contoh\" : self . contoh }", "docstring_tokens": "Mengembalikan hasil serialisasi objek Makna ini .", "label": 0}, {"idx": "cosqa-train-8125", "doc": "resize an image python pil", "code": "def resize(self, size):\n        \"\"\"Return a new Image instance with the given size.\"\"\"\n        return Image(self.pil_image.resize(size, PIL.Image.ANTIALIAS))", "code_tokens": "def resize ( self , size ) : return Image ( self . pil_image . resize ( size , PIL . Image . ANTIALIAS ) )", "docstring_tokens": "Return a new Image instance with the given size .", "label": 1}, {"idx": "cosqa-train-8126", "doc": "python 3x3 matrix divided by 1x3", "code": "def cross_product_matrix(vec):\n    \"\"\"Returns a 3x3 cross-product matrix from a 3-element vector.\"\"\"\n    return np.array([[0, -vec[2], vec[1]],\n                     [vec[2], 0, -vec[0]],\n                     [-vec[1], vec[0], 0]])", "code_tokens": "def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )", "docstring_tokens": "Returns a 3x3 cross - product matrix from a 3 - element vector .", "label": 0}, {"idx": "cosqa-train-8127", "doc": "response status code url doesn exists python", "code": "def raise_for_not_ok_status(response):\n    \"\"\"\n    Raises a `requests.exceptions.HTTPError` if the response has a non-200\n    status code.\n    \"\"\"\n    if response.code != OK:\n        raise HTTPError('Non-200 response code (%s) for url: %s' % (\n            response.code, uridecode(response.request.absoluteURI)))\n\n    return response", "code_tokens": "def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response", "docstring_tokens": "Raises a requests . exceptions . HTTPError if the response has a non - 200 status code .", "label": 0}, {"idx": "cosqa-train-8128", "doc": "python access s3 data sagemaker", "code": "def s3(ctx, bucket_name, data_file, region):\n    \"\"\"Use the S3 SWAG backend.\"\"\"\n    if not ctx.data_file:\n        ctx.data_file = data_file\n\n    if not ctx.bucket_name:\n        ctx.bucket_name = bucket_name\n\n    if not ctx.region:\n        ctx.region = region\n\n    ctx.type = 's3'", "code_tokens": "def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'", "docstring_tokens": "Use the S3 SWAG backend .", "label": 1}, {"idx": "cosqa-train-8129", "doc": "response time capture in log for python", "code": "def process_request(self, request, response):\n        \"\"\"Logs the basic endpoint requested\"\"\"\n        self.logger.info('Requested: {0} {1} {2}'.format(request.method, request.relative_uri, request.content_type))", "code_tokens": "def process_request ( self , request , response ) : self . logger . info ( 'Requested: {0} {1} {2}' . format ( request . method , request . relative_uri , request . content_type ) )", "docstring_tokens": "Logs the basic endpoint requested", "label": 1}, {"idx": "cosqa-train-8130", "doc": "python add attributes to objects", "code": "def populate_obj(obj, attrs):\n    \"\"\"Populates an object's attributes using the provided dict\n    \"\"\"\n    for k, v in attrs.iteritems():\n        setattr(obj, k, v)", "code_tokens": "def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "docstring_tokens": "Populates an object s attributes using the provided dict", "label": 0}, {"idx": "cosqa-train-8131", "doc": "return a tuple of items from a function python", "code": "def filter_regex(names, regex):\n    \"\"\"\n    Return a tuple of strings that match the regular expression pattern.\n    \"\"\"\n    return tuple(name for name in names\n                 if regex.search(name) is not None)", "code_tokens": "def filter_regex ( names , regex ) : return tuple ( name for name in names if regex . search ( name ) is not None )", "docstring_tokens": "Return a tuple of strings that match the regular expression pattern .", "label": 1}, {"idx": "cosqa-train-8132", "doc": "python add counts to confusion matrix", "code": "def accuracy(conf_matrix):\n  \"\"\"\n  Given a confusion matrix, returns the accuracy.\n  Accuracy Definition: http://research.ics.aalto.fi/events/eyechallenge2005/evaluation.shtml\n  \"\"\"\n  total, correct = 0.0, 0.0\n  for true_response, guess_dict in conf_matrix.items():\n    for guess, count in guess_dict.items():\n      if true_response == guess:\n        correct += count\n      total += count\n  return correct/total", "code_tokens": "def accuracy ( conf_matrix ) : total , correct = 0.0 , 0.0 for true_response , guess_dict in conf_matrix . items ( ) : for guess , count in guess_dict . items ( ) : if true_response == guess : correct += count total += count return correct / total", "docstring_tokens": "Given a confusion matrix returns the accuracy . Accuracy Definition : http : // research . ics . aalto . fi / events / eyechallenge2005 / evaluation . shtml", "label": 0}, {"idx": "cosqa-train-8133", "doc": "return array as iterable python", "code": "def _npiter(arr):\n    \"\"\"Wrapper for iterating numpy array\"\"\"\n    for a in np.nditer(arr, flags=[\"refs_ok\"]):\n        c = a.item()\n        if c is not None:\n            yield c", "code_tokens": "def _npiter ( arr ) : for a in np . nditer ( arr , flags = [ \"refs_ok\" ] ) : c = a . item ( ) if c is not None : yield c", "docstring_tokens": "Wrapper for iterating numpy array", "label": 1}, {"idx": "cosqa-train-8134", "doc": "python add execute permission to file", "code": "def chmod_add_excute(filename):\n        \"\"\"\n        Adds execute permission to file.\n        :param filename:\n        :return:\n        \"\"\"\n        st = os.stat(filename)\n        os.chmod(filename, st.st_mode | stat.S_IEXEC)", "code_tokens": "def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "docstring_tokens": "Adds execute permission to file . : param filename : : return :", "label": 1}, {"idx": "cosqa-train-8135", "doc": "return the original value of a max result python", "code": "def max(self):\n        \"\"\"\n        Returns the maximum value of the domain.\n\n        :rtype: `float` or `np.inf`\n        \"\"\"\n        return int(self._max) if not np.isinf(self._max) else self._max", "code_tokens": "def max ( self ) : return int ( self . _max ) if not np . isinf ( self . _max ) else self . _max", "docstring_tokens": "Returns the maximum value of the domain .", "label": 1}, {"idx": "cosqa-train-8136", "doc": "python add random noise", "code": "def add_noise(Y, sigma):\n    \"\"\"Adds noise to Y\"\"\"\n    return Y + np.random.normal(0, sigma, Y.shape)", "code_tokens": "def add_noise ( Y , sigma ) : return Y + np . random . normal ( 0 , sigma , Y . shape )", "docstring_tokens": "Adds noise to Y", "label": 0}, {"idx": "cosqa-train-8137", "doc": "return unique substrings given a number python", "code": "def make_unique_ngrams(s, n):\n    \"\"\"Make a set of unique n-grams from a string.\"\"\"\n    return set(s[i:i + n] for i in range(len(s) - n + 1))", "code_tokens": "def make_unique_ngrams ( s , n ) : return set ( s [ i : i + n ] for i in range ( len ( s ) - n + 1 ) )", "docstring_tokens": "Make a set of unique n - grams from a string .", "label": 1}, {"idx": "cosqa-train-8138", "doc": "python add to existing code", "code": "def generic_add(a, b):\n    \"\"\"Simple function to add two numbers\"\"\"\n    logger.debug('Called generic_add({}, {})'.format(a, b))\n    return a + b", "code_tokens": "def generic_add ( a , b ) : logger . debug ( 'Called generic_add({}, {})' . format ( a , b ) ) return a + b", "docstring_tokens": "Simple function to add two numbers", "label": 1}, {"idx": "cosqa-train-8139", "doc": "returning multiple local variables from a function python", "code": "def getvariable(name):\n    \"\"\"Get the value of a local variable somewhere in the call stack.\"\"\"\n    import inspect\n    fr = inspect.currentframe()\n    try:\n        while fr:\n            fr = fr.f_back\n            vars = fr.f_locals\n            if name in vars:\n                return vars[name]\n    except:\n        pass\n    return None", "code_tokens": "def getvariable ( name ) : import inspect fr = inspect . currentframe ( ) try : while fr : fr = fr . f_back vars = fr . f_locals if name in vars : return vars [ name ] except : pass return None", "docstring_tokens": "Get the value of a local variable somewhere in the call stack .", "label": 1}, {"idx": "cosqa-train-8140", "doc": "python add to two values", "code": "def __add__(self, other):\n        \"\"\"Handle the `+` operator.\"\"\"\n        return self._handle_type(other)(self.value + other.value)", "code_tokens": "def __add__ ( self , other ) : return self . _handle_type ( other ) ( self . value + other . value )", "docstring_tokens": "Handle the + operator .", "label": 1}, {"idx": "cosqa-train-8141", "doc": "reverse lines of a text file python", "code": "def reversed_lines(path):\n    \"\"\"Generate the lines of file in reverse order.\"\"\"\n    with open(path, 'r') as handle:\n        part = ''\n        for block in reversed_blocks(handle):\n            for c in reversed(block):\n                if c == '\\n' and part:\n                    yield part[::-1]\n                    part = ''\n                part += c\n        if part: yield part[::-1]", "code_tokens": "def reversed_lines ( path ) : with open ( path , 'r' ) as handle : part = '' for block in reversed_blocks ( handle ) : for c in reversed ( block ) : if c == '\\n' and part : yield part [ : : - 1 ] part = '' part += c if part : yield part [ : : - 1 ]", "docstring_tokens": "Generate the lines of file in reverse order .", "label": 1}, {"idx": "cosqa-train-8142", "doc": "python advance file handler to next line manually", "code": "def align_file_position(f, size):\n    \"\"\" Align the position in the file to the next block of specified size \"\"\"\n    align = (size - 1) - (f.tell() % size)\n    f.seek(align, 1)", "code_tokens": "def align_file_position ( f , size ) : align = ( size - 1 ) - ( f . tell ( ) % size ) f . seek ( align , 1 )", "docstring_tokens": "Align the position in the file to the next block of specified size", "label": 0}, {"idx": "cosqa-train-8143", "doc": "rgb to hsv python", "code": "def hex_to_hsv(color):\n    \"\"\"\n    Converts from hex to hsv\n\n    Parameters:\n    -----------\n            color : string\n                    Color representation on color\n\n    Example:\n            hex_to_hsv('#ff9933')\n    \"\"\"\n    color = normalize(color)\n    color = color[1:]\n    # color=tuple(ord(c)/255.0 for c in color.decode('hex'))\n    color = (int(color[0:2], base=16) / 255.0, int(color[2:4],\n                                                   base=16) / 255.0, int(color[4:6], base=16) / 255.0)\n    return colorsys.rgb_to_hsv(*color)", "code_tokens": "def hex_to_hsv ( color ) : color = normalize ( color ) color = color [ 1 : ] # color=tuple(ord(c)/255.0 for c in color.decode('hex')) color = ( int ( color [ 0 : 2 ] , base = 16 ) / 255.0 , int ( color [ 2 : 4 ] , base = 16 ) / 255.0 , int ( color [ 4 : 6 ] , base = 16 ) / 255.0 ) return colorsys . rgb_to_hsv ( * color )", "docstring_tokens": "Converts from hex to hsv", "label": 0}, {"idx": "cosqa-train-8144", "doc": "python advance to next line", "code": "def advance_one_line(self):\n    \"\"\"Advances to next line.\"\"\"\n\n    current_line = self._current_token.line_number\n    while current_line == self._current_token.line_number:\n      self._current_token = ConfigParser.Token(*next(self._token_generator))", "code_tokens": "def advance_one_line ( self ) : current_line = self . _current_token . line_number while current_line == self . _current_token . line_number : self . _current_token = ConfigParser . Token ( * next ( self . _token_generator ) )", "docstring_tokens": "Advances to next line .", "label": 1}, {"idx": "cosqa-train-8145", "doc": "rotate an image in opencv python", "code": "def rotate_img(im, deg, mode=cv2.BORDER_CONSTANT, interpolation=cv2.INTER_AREA):\n    \"\"\" Rotates an image by deg degrees\n\n    Arguments:\n        deg (float): degree to rotate.\n    \"\"\"\n    r,c,*_ = im.shape\n    M = cv2.getRotationMatrix2D((c//2,r//2),deg,1)\n    return cv2.warpAffine(im,M,(c,r), borderMode=mode, flags=cv2.WARP_FILL_OUTLIERS+interpolation)", "code_tokens": "def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )", "docstring_tokens": "Rotates an image by deg degrees", "label": 0}, {"idx": "cosqa-train-8146", "doc": "python algorithm for greatest common divisor", "code": "def _gcd_array(X):\n    \"\"\"\n    Return the largest real value h such that all elements in x are integer\n    multiples of h.\n    \"\"\"\n    greatest_common_divisor = 0.0\n    for x in X:\n        greatest_common_divisor = _gcd(greatest_common_divisor, x)\n\n    return greatest_common_divisor", "code_tokens": "def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor", "docstring_tokens": "Return the largest real value h such that all elements in x are integer multiples of h .", "label": 0}, {"idx": "cosqa-train-8147", "doc": "rotate image python ndimage", "code": "def rotateImage(img, angle):\n    \"\"\"\n\n    querries scipy.ndimage.rotate routine\n    :param img: image to be rotated\n    :param angle: angle to be rotated (radian)\n    :return: rotated image\n    \"\"\"\n    imgR = scipy.ndimage.rotate(img, angle, reshape=False)\n    return imgR", "code_tokens": "def rotateImage ( img , angle ) : imgR = scipy . ndimage . rotate ( img , angle , reshape = False ) return imgR", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-8148", "doc": "python all sequences of length", "code": "def chunk_sequence(sequence, chunk_length):\n    \"\"\"Yield successive n-sized chunks from l.\"\"\"\n    for index in range(0, len(sequence), chunk_length):\n        yield sequence[index:index + chunk_length]", "code_tokens": "def chunk_sequence ( sequence , chunk_length ) : for index in range ( 0 , len ( sequence ) , chunk_length ) : yield sequence [ index : index + chunk_length ]", "docstring_tokens": "Yield successive n - sized chunks from l .", "label": 0}, {"idx": "cosqa-train-8149", "doc": "round datetime to nearest minute python", "code": "def __round_time(self, dt):\n    \"\"\"Round a datetime object to a multiple of a timedelta\n    dt : datetime.datetime object, default now.\n    \"\"\"\n    round_to = self._resolution.total_seconds()\n    seconds  = (dt - dt.min).seconds\n    rounding = (seconds + round_to / 2) // round_to * round_to\n    return dt + timedelta(0, rounding - seconds, -dt.microsecond)", "code_tokens": "def __round_time ( self , dt ) : round_to = self . _resolution . total_seconds ( ) seconds = ( dt - dt . min ) . seconds rounding = ( seconds + round_to / 2 ) // round_to * round_to return dt + timedelta ( 0 , rounding - seconds , - dt . microsecond )", "docstring_tokens": "Round a datetime object to a multiple of a timedelta dt : datetime . datetime object default now .", "label": 1}, {"idx": "cosqa-train-8150", "doc": "python all values out of a tuple", "code": "def compose_all(tups):\n  \"\"\"Compose all given tuples together.\"\"\"\n  from . import ast  # I weep for humanity\n  return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))", "code_tokens": "def compose_all ( tups ) : from . import ast # I weep for humanity return functools . reduce ( lambda x , y : x . compose ( y ) , map ( ast . make_tuple , tups ) , ast . make_tuple ( { } ) )", "docstring_tokens": "Compose all given tuples together .", "label": 1}, {"idx": "cosqa-train-8151", "doc": "round times to quarter hour, python", "code": "def _round_half_hour(record):\n    \"\"\"\n    Round a time DOWN to half nearest half-hour.\n    \"\"\"\n    k = record.datetime + timedelta(minutes=-(record.datetime.minute % 30))\n    return datetime(k.year, k.month, k.day, k.hour, k.minute, 0)", "code_tokens": "def _round_half_hour ( record ) : k = record . datetime + timedelta ( minutes = - ( record . datetime . minute % 30 ) ) return datetime ( k . year , k . month , k . day , k . hour , k . minute , 0 )", "docstring_tokens": "Round a time DOWN to half nearest half - hour .", "label": 0}, {"idx": "cosqa-train-8152", "doc": "python alterternative to pyaudio for microphone", "code": "def calc_volume(self, sample: np.ndarray):\n        \"\"\"Find the RMS of the audio\"\"\"\n        return sqrt(np.mean(np.square(sample)))", "code_tokens": "def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )", "docstring_tokens": "Find the RMS of the audio", "label": 0}, {"idx": "cosqa-train-8153", "doc": "round to 1 sig digit python", "code": "def round_sig(x, sig):\n    \"\"\"Round the number to the specified number of significant figures\"\"\"\n    return round(x, sig - int(floor(log10(abs(x)))) - 1)", "code_tokens": "def round_sig ( x , sig ) : return round ( x , sig - int ( floor ( log10 ( abs ( x ) ) ) ) - 1 )", "docstring_tokens": "Round the number to the specified number of significant figures", "label": 0}, {"idx": "cosqa-train-8154", "doc": "python and how to code float strings", "code": "def covstr(s):\n  \"\"\" convert string to int or float. \"\"\"\n  try:\n    ret = int(s)\n  except ValueError:\n    ret = float(s)\n  return ret", "code_tokens": "def covstr ( s ) : try : ret = int ( s ) except ValueError : ret = float ( s ) return ret", "docstring_tokens": "convert string to int or float .", "label": 1}, {"idx": "cosqa-train-8155", "doc": "round to significant figures python", "code": "def round_figures(x, n):\n    \"\"\"Returns x rounded to n significant figures.\"\"\"\n    return round(x, int(n - math.ceil(math.log10(abs(x)))))", "code_tokens": "def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )", "docstring_tokens": "Returns x rounded to n significant figures .", "label": 0}, {"idx": "cosqa-train-8156", "doc": "python and return closest indices of value for interpolation", "code": "def index_nearest(value, array):\n    \"\"\"\n    expects a _n.array\n    returns the global minimum of (value-array)^2\n    \"\"\"\n\n    a = (array-value)**2\n    return index(a.min(), a)", "code_tokens": "def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )", "docstring_tokens": "expects a _n . array returns the global minimum of ( value - array ) ^2", "label": 1}, {"idx": "cosqa-train-8157", "doc": "round to to decimals python", "code": "def round_to_n(x, n):\n    \"\"\"\n    Round to sig figs\n    \"\"\"\n    return round(x, -int(np.floor(np.log10(x))) + (n - 1))", "code_tokens": "def round_to_n ( x , n ) : return round ( x , - int ( np . floor ( np . log10 ( x ) ) ) + ( n - 1 ) )", "docstring_tokens": "Round to sig figs", "label": 0}, {"idx": "cosqa-train-8158", "doc": "python angle from three points", "code": "def angle(x, y):\n    \"\"\"Return the angle between vectors a and b in degrees.\"\"\"\n    return arccos(dot(x, y)/(norm(x)*norm(y)))*180./pi", "code_tokens": "def angle ( x , y ) : return arccos ( dot ( x , y ) / ( norm ( x ) * norm ( y ) ) ) * 180. / pi", "docstring_tokens": "Return the angle between vectors a and b in degrees .", "label": 1}, {"idx": "cosqa-train-8159", "doc": "run a function at set interval python", "code": "def set(self, f):\n        \"\"\"Call a function after a delay, unless another function is set\n        in the meantime.\"\"\"\n        self.stop()\n        self._create_timer(f)\n        self.start()", "code_tokens": "def set ( self , f ) : self . stop ( ) self . _create_timer ( f ) self . start ( )", "docstring_tokens": "Call a function after a delay unless another function is set in the meantime .", "label": 1}, {"idx": "cosqa-train-8160", "doc": "python append flatten list", "code": "def flatten(lis):\n    \"\"\"Given a list, possibly nested to any level, return it flattened.\"\"\"\n    new_lis = []\n    for item in lis:\n        if isinstance(item, collections.Sequence) and not isinstance(item, basestring):\n            new_lis.extend(flatten(item))\n        else:\n            new_lis.append(item)\n    return new_lis", "code_tokens": "def flatten ( lis ) : new_lis = [ ] for item in lis : if isinstance ( item , collections . Sequence ) and not isinstance ( item , basestring ) : new_lis . extend ( flatten ( item ) ) else : new_lis . append ( item ) return new_lis", "docstring_tokens": "Given a list possibly nested to any level return it flattened .", "label": 1}, {"idx": "cosqa-train-8161", "doc": "run compiled python code", "code": "def get_code(module):\n    \"\"\"\n    Compile and return a Module's code object.\n    \"\"\"\n    fp = open(module.path)\n    try:\n        return compile(fp.read(), str(module.name), 'exec')\n    finally:\n        fp.close()", "code_tokens": "def get_code ( module ) : fp = open ( module . path ) try : return compile ( fp . read ( ) , str ( module . name ) , 'exec' ) finally : fp . close ( )", "docstring_tokens": "Compile and return a Module s code object .", "label": 1}, {"idx": "cosqa-train-8162", "doc": "python apply dict to fuction", "code": "def dictapply(d, fn):\n    \"\"\"\n    apply a function to all non-dict values in a dictionary\n    \"\"\"\n    for k, v in d.items():\n        if isinstance(v, dict):\n            v = dictapply(v, fn)\n        else:\n            d[k] = fn(v)\n    return d", "code_tokens": "def dictapply ( d , fn ) : for k , v in d . items ( ) : if isinstance ( v , dict ) : v = dictapply ( v , fn ) else : d [ k ] = fn ( v ) return d", "docstring_tokens": "apply a function to all non - dict values in a dictionary", "label": 0}, {"idx": "cosqa-train-8163", "doc": "run mutliple sql queries in python", "code": "def store_many(self, sql, values):\n        \"\"\"Abstraction over executemany method\"\"\"\n        cursor = self.get_cursor()\n        cursor.executemany(sql, values)\n        self.conn.commit()", "code_tokens": "def store_many ( self , sql , values ) : cursor = self . get_cursor ( ) cursor . executemany ( sql , values ) self . conn . commit ( )", "docstring_tokens": "Abstraction over executemany method", "label": 0}, {"idx": "cosqa-train-8164", "doc": "python apply function change self", "code": "def apply(self, node):\n        \"\"\" Apply transformation and return if an update happened. \"\"\"\n        new_node = self.run(node)\n        return self.update, new_node", "code_tokens": "def apply ( self , node ) : new_node = self . run ( node ) return self . update , new_node", "docstring_tokens": "Apply transformation and return if an update happened .", "label": 1}, {"idx": "cosqa-train-8165", "doc": "run python with web intergace", "code": "def web(host, port):\n    \"\"\"Start web application\"\"\"\n    from .webserver.web import get_app\n    get_app().run(host=host, port=port)", "code_tokens": "def web ( host , port ) : from . webserver . web import get_app get_app ( ) . run ( host = host , port = port )", "docstring_tokens": "Start web application", "label": 1}, {"idx": "cosqa-train-8166", "doc": "python apply function to iterator", "code": "def find_all(self, string, callback):\n\t\t\"\"\"\n\t\tWrapper on iter method, callback gets an iterator result\n\t\t\"\"\"\n\t\tfor index, output in self.iter(string):\n\t\t\tcallback(index, output)", "code_tokens": "def find_all ( self , string , callback ) : for index , output in self . iter ( string ) : callback ( index , output )", "docstring_tokens": "Wrapper on iter method callback gets an iterator result", "label": 1}, {"idx": "cosqa-train-8167", "doc": "save jpg python bigger size", "code": "def resize_image(self, data, size):\n        \"\"\" Resizes the given image to fit inside a box of the given size. \"\"\"\n        from machina.core.compat import PILImage as Image\n        image = Image.open(BytesIO(data))\n\n        # Resize!\n        image.thumbnail(size, Image.ANTIALIAS)\n\n        string = BytesIO()\n        image.save(string, format='PNG')\n        return string.getvalue()", "code_tokens": "def resize_image ( self , data , size ) : from machina . core . compat import PILImage as Image image = Image . open ( BytesIO ( data ) ) # Resize! image . thumbnail ( size , Image . ANTIALIAS ) string = BytesIO ( ) image . save ( string , format = 'PNG' ) return string . getvalue ( )", "docstring_tokens": "Resizes the given image to fit inside a box of the given size .", "label": 0}, {"idx": "cosqa-train-8168", "doc": "python apply multiple functions to same input", "code": "def compose(func_list):\n    \"\"\"\n    composion of preprocessing functions\n    \"\"\"\n\n    def f(G, bim):\n        for func in func_list:\n            G, bim = func(G, bim)\n        return G, bim\n\n    return f", "code_tokens": "def compose ( func_list ) : def f ( G , bim ) : for func in func_list : G , bim = func ( G , bim ) return G , bim return f", "docstring_tokens": "composion of preprocessing functions", "label": 0}, {"idx": "cosqa-train-8169", "doc": "save product of funtion python", "code": "def multiply(traj):\n    \"\"\"Sophisticated simulation of multiplication\"\"\"\n    z=traj.x*traj.y\n    traj.f_add_result('z',z=z, comment='I am the product of two reals!')", "code_tokens": "def multiply ( traj ) : z = traj . x * traj . y traj . f_add_result ( 'z' , z = z , comment = 'I am the product of two reals!' )", "docstring_tokens": "Sophisticated simulation of multiplication", "label": 1}, {"idx": "cosqa-train-8170", "doc": "python arg parse checking if arguement is", "code": "def email_type(arg):\n\t\"\"\"An argparse type representing an email address.\"\"\"\n\tif not is_valid_email_address(arg):\n\t\traise argparse.ArgumentTypeError(\"{0} is not a valid email address\".format(repr(arg)))\n\treturn arg", "code_tokens": "def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( \"{0} is not a valid email address\" . format ( repr ( arg ) ) ) return arg", "docstring_tokens": "An argparse type representing an email address .", "label": 0}, {"idx": "cosqa-train-8171", "doc": "save python object as yaml", "code": "def Dump(obj):\n  \"\"\"Stringifies a Python object into its YAML representation.\n\n  Args:\n    obj: A Python object to convert to YAML.\n\n  Returns:\n    A YAML representation of the given object.\n  \"\"\"\n  text = yaml.safe_dump(obj, default_flow_style=False, allow_unicode=True)\n\n  if compatibility.PY2:\n    text = text.decode(\"utf-8\")\n\n  return text", "code_tokens": "def Dump ( obj ) : text = yaml . safe_dump ( obj , default_flow_style = False , allow_unicode = True ) if compatibility . PY2 : text = text . decode ( \"utf-8\" ) return text", "docstring_tokens": "Stringifies a Python object into its YAML representation .", "label": 1}, {"idx": "cosqa-train-8172", "doc": "python argparse config file", "code": "def parser():\n\n    \"\"\"Return a parser for setting one or more configuration paths\"\"\"\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-c', '--config_paths', default=[], action='append',\n                        help='path to a configuration directory')\n    return parser", "code_tokens": "def parser ( ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( '-c' , '--config_paths' , default = [ ] , action = 'append' , help = 'path to a configuration directory' ) return parser", "docstring_tokens": "Return a parser for setting one or more configuration paths", "label": 0}, {"idx": "cosqa-train-8173", "doc": "save python session to server", "code": "def save_session(self, sid, session, namespace=None):\n        \"\"\"Store the user session for a client.\n\n        The only difference with the :func:`socketio.Server.save_session`\n        method is that when the ``namespace`` argument is not given the\n        namespace associated with the class is used.\n        \"\"\"\n        return self.server.save_session(\n            sid, session, namespace=namespace or self.namespace)", "code_tokens": "def save_session ( self , sid , session , namespace = None ) : return self . server . save_session ( sid , session , namespace = namespace or self . namespace )", "docstring_tokens": "Store the user session for a client .", "label": 0}, {"idx": "cosqa-train-8174", "doc": "python argparse default parser for subparser", "code": "def set_subparsers_args(self, *args, **kwargs):\n        \"\"\"\n        Sets args and kwargs that are passed when creating a subparsers group\n        in an argparse.ArgumentParser i.e. when calling\n        argparser.ArgumentParser.add_subparsers\n        \"\"\"\n        self.subparsers_args = args\n        self.subparsers_kwargs = kwargs", "code_tokens": "def set_subparsers_args ( self , * args , * * kwargs ) : self . subparsers_args = args self . subparsers_kwargs = kwargs", "docstring_tokens": "Sets args and kwargs that are passed when creating a subparsers group in an argparse . ArgumentParser i . e . when calling argparser . ArgumentParser . add_subparsers", "label": 1}, {"idx": "cosqa-train-8175", "doc": "saved a python script and is now empty", "code": "def on_pause(self):\n        \"\"\"Sync the database with the current state of the game.\"\"\"\n        self.engine.commit()\n        self.strings.save()\n        self.funcs.save()\n        self.config.write()", "code_tokens": "def on_pause ( self ) : self . engine . commit ( ) self . strings . save ( ) self . funcs . save ( ) self . config . write ( )", "docstring_tokens": "Sync the database with the current state of the game .", "label": 1}, {"idx": "cosqa-train-8176", "doc": "python argparse group order", "code": "def createArgumentParser(description):\n    \"\"\"\n    Create an argument parser\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description=description,\n        formatter_class=SortedHelpFormatter)\n    return parser", "code_tokens": "def createArgumentParser ( description ) : parser = argparse . ArgumentParser ( description = description , formatter_class = SortedHelpFormatter ) return parser", "docstring_tokens": "Create an argument parser", "label": 1}, {"idx": "cosqa-train-8177", "doc": "scalar 1d array python", "code": "def is_scalar(value):\n    \"\"\"Test if the given value is a scalar.\n\n    This function also works with memory mapped array values, in contrast to the numpy is_scalar method.\n\n    Args:\n        value: the value to test for being a scalar value\n\n    Returns:\n        boolean: if the given value is a scalar or not\n    \"\"\"\n    return np.isscalar(value) or (isinstance(value, np.ndarray) and (len(np.squeeze(value).shape) == 0))", "code_tokens": "def is_scalar ( value ) : return np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and ( len ( np . squeeze ( value ) . shape ) == 0 ) )", "docstring_tokens": "Test if the given value is a scalar .", "label": 1}, {"idx": "cosqa-train-8178", "doc": "python argparse loading a json file", "code": "def main(args=sys.argv):\n    \"\"\"\n    main entry point for the jardiff CLI\n    \"\"\"\n\n    parser = create_optparser(args[0])\n    return cli(parser.parse_args(args[1:]))", "code_tokens": "def main ( args = sys . argv ) : parser = create_optparser ( args [ 0 ] ) return cli ( parser . parse_args ( args [ 1 : ] ) )", "docstring_tokens": "main entry point for the jardiff CLI", "label": 1}, {"idx": "cosqa-train-8179", "doc": "select only not null values python", "code": "def selectnotnone(table, field, complement=False):\n    \"\"\"Select rows where the given field is not `None`.\"\"\"\n\n    return select(table, field, lambda v: v is not None,\n                  complement=complement)", "code_tokens": "def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )", "docstring_tokens": "Select rows where the given field is not None .", "label": 0}, {"idx": "cosqa-train-8180", "doc": "python argparse not taking arguements", "code": "def parse_command_args():\n    \"\"\"Command line parser.\"\"\"\n    parser = argparse.ArgumentParser(description='Register PB devices.')\n    parser.add_argument('num_pb', type=int,\n                        help='Number of PBs devices to register.')\n    return parser.parse_args()", "code_tokens": "def parse_command_args ( ) : parser = argparse . ArgumentParser ( description = 'Register PB devices.' ) parser . add_argument ( 'num_pb' , type = int , help = 'Number of PBs devices to register.' ) return parser . parse_args ( )", "docstring_tokens": "Command line parser .", "label": 0}, {"idx": "cosqa-train-8181", "doc": "select rows if a field is null in python", "code": "def selectnone(table, field, complement=False):\n    \"\"\"Select rows where the given field is `None`.\"\"\"\n\n    return select(table, field, lambda v: v is None, complement=complement)", "code_tokens": "def selectnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is None , complement = complement )", "docstring_tokens": "Select rows where the given field is None .", "label": 1}, {"idx": "cosqa-train-8182", "doc": "python argparse subparser callback", "code": "def set_subparsers_args(self, *args, **kwargs):\n        \"\"\"\n        Sets args and kwargs that are passed when creating a subparsers group\n        in an argparse.ArgumentParser i.e. when calling\n        argparser.ArgumentParser.add_subparsers\n        \"\"\"\n        self.subparsers_args = args\n        self.subparsers_kwargs = kwargs", "code_tokens": "def set_subparsers_args ( self , * args , * * kwargs ) : self . subparsers_args = args self . subparsers_kwargs = kwargs", "docstring_tokens": "Sets args and kwargs that are passed when creating a subparsers group in an argparse . ArgumentParser i . e . when calling argparser . ArgumentParser . add_subparsers", "label": 0}, {"idx": "cosqa-train-8183", "doc": "select specifi coluns in a df in python", "code": "def select_if(df, fun):\n    \"\"\"Selects columns where fun(ction) is true\n    Args:\n        fun: a function that will be applied to columns\n    \"\"\"\n\n    def _filter_f(col):\n        try:\n            return fun(df[col])\n        except:\n            return False\n\n    cols = list(filter(_filter_f, df.columns))\n    return df[cols]", "code_tokens": "def select_if ( df , fun ) : def _filter_f ( col ) : try : return fun ( df [ col ] ) except : return False cols = list ( filter ( _filter_f , df . columns ) ) return df [ cols ]", "docstring_tokens": "Selects columns where fun ( ction ) is true Args : fun : a function that will be applied to columns", "label": 0}, {"idx": "cosqa-train-8184", "doc": "python argparse validation regex", "code": "def email_type(arg):\n\t\"\"\"An argparse type representing an email address.\"\"\"\n\tif not is_valid_email_address(arg):\n\t\traise argparse.ArgumentTypeError(\"{0} is not a valid email address\".format(repr(arg)))\n\treturn arg", "code_tokens": "def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( \"{0} is not a valid email address\" . format ( repr ( arg ) ) ) return arg", "docstring_tokens": "An argparse type representing an email address .", "label": 0}, {"idx": "cosqa-train-8185", "doc": "select the index of a python list except for the first item", "code": "def bisect_index(a, x):\n    \"\"\" Find the leftmost index of an element in a list using binary search.\n\n    Parameters\n    ----------\n    a: list\n        A sorted list.\n    x: arbitrary\n        The element.\n\n    Returns\n    -------\n    int\n        The index.\n\n    \"\"\"\n    i = bisect.bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    raise ValueError", "code_tokens": "def bisect_index ( a , x ) : i = bisect . bisect_left ( a , x ) if i != len ( a ) and a [ i ] == x : return i raise ValueError", "docstring_tokens": "Find the leftmost index of an element in a list using binary search .", "label": 1}, {"idx": "cosqa-train-8186", "doc": "python argparse verify directory exists", "code": "def is_valid_folder(parser, arg):\n    \"\"\"Check if arg is a valid file that already exists on the file system.\"\"\"\n    arg = os.path.abspath(arg)\n    if not os.path.isdir(arg):\n        parser.error(\"The folder %s does not exist!\" % arg)\n    else:\n        return arg", "code_tokens": "def is_valid_folder ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . isdir ( arg ) : parser . error ( \"The folder %s does not exist!\" % arg ) else : return arg", "docstring_tokens": "Check if arg is a valid file that already exists on the file system .", "label": 0}, {"idx": "cosqa-train-8187", "doc": "send http request with authorization python", "code": "def auth_request(self, url, headers, body):\n        \"\"\"Perform auth request for token.\"\"\"\n\n        return self.req.post(url, headers, body=body)", "code_tokens": "def auth_request ( self , url , headers , body ) : return self . req . post ( url , headers , body = body )", "docstring_tokens": "Perform auth request for token .", "label": 1}, {"idx": "cosqa-train-8188", "doc": "python array all indices except", "code": "def pairwise_indices(self):\n        \"\"\"ndarray containing tuples of pairwise indices.\"\"\"\n        return np.array([sig.pairwise_indices for sig in self.values]).T", "code_tokens": "def pairwise_indices ( self ) : return np . array ( [ sig . pairwise_indices for sig in self . values ] ) . T", "docstring_tokens": "ndarray containing tuples of pairwise indices .", "label": 1}, {"idx": "cosqa-train-8189", "doc": "send mouse movement directx python", "code": "def mouseMoveEvent(self, event):\n        \"\"\" Handle the mouse move event for a drag operation.\n\n        \"\"\"\n        self.declaration.mouse_move_event(event)\n        super(QtGraphicsView, self).mouseMoveEvent(event)", "code_tokens": "def mouseMoveEvent ( self , event ) : self . declaration . mouse_move_event ( event ) super ( QtGraphicsView , self ) . mouseMoveEvent ( event )", "docstring_tokens": "Handle the mouse move event for a drag operation .", "label": 1}, {"idx": "cosqa-train-8190", "doc": "python array easy way", "code": "def dump_nparray(self, obj, class_name=numpy_ndarray_class_name):\n        \"\"\"\n        ``numpy.ndarray`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: self._json_convert(obj.tolist())}", "code_tokens": "def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { \"$\" + class_name : self . _json_convert ( obj . tolist ( ) ) }", "docstring_tokens": "numpy . ndarray dumper .", "label": 1}, {"idx": "cosqa-train-8191", "doc": "separate channels from wav file python", "code": "def data_from_file(file):\n    \"\"\"Return (first channel data, sample frequency, sample width) from a .wav\n    file.\"\"\"\n    fp = wave.open(file, 'r')\n    data = fp.readframes(fp.getnframes())\n    channels = fp.getnchannels()\n    freq = fp.getframerate()\n    bits = fp.getsampwidth()\n\n    # Unpack bytes -- warning currently only tested with 16 bit wavefiles. 32\n    # bit not supported.\n    data = struct.unpack(('%sh' % fp.getnframes()) * channels, data)\n\n    # Only use first channel\n    channel1 = []\n    n = 0\n    for d in data:\n        if n % channels == 0:\n            channel1.append(d)\n        n += 1\n    fp.close()\n    return (channel1, freq, bits)", "code_tokens": "def data_from_file ( file ) : fp = wave . open ( file , 'r' ) data = fp . readframes ( fp . getnframes ( ) ) channels = fp . getnchannels ( ) freq = fp . getframerate ( ) bits = fp . getsampwidth ( ) # Unpack bytes -- warning currently only tested with 16 bit wavefiles. 32 # bit not supported. data = struct . unpack ( ( '%sh' % fp . getnframes ( ) ) * channels , data ) # Only use first channel channel1 = [ ] n = 0 for d in data : if n % channels == 0 : channel1 . append ( d ) n += 1 fp . close ( ) return ( channel1 , freq , bits )", "docstring_tokens": "Return ( first channel data sample frequency sample width ) from a . wav file .", "label": 1}, {"idx": "cosqa-train-8192", "doc": "python array to a diagnoal matrix", "code": "def Diag(a):\n    \"\"\"\n    Diag op.\n    \"\"\"\n    r = np.zeros(2 * a.shape, dtype=a.dtype)\n    for idx, v in np.ndenumerate(a):\n        r[2 * idx] = v\n    return r,", "code_tokens": "def Diag ( a ) : r = np . zeros ( 2 * a . shape , dtype = a . dtype ) for idx , v in np . ndenumerate ( a ) : r [ 2 * idx ] = v return r ,", "docstring_tokens": "Diag op .", "label": 1}, {"idx": "cosqa-train-8193", "doc": "separate list by spaces python", "code": "def split_strings_in_list_retain_spaces(orig_list):\n    \"\"\"\n    Function to split every line in a list, and retain spaces for a rejoin\n    :param orig_list: Original list\n    :return:\n        A List with split lines\n\n    \"\"\"\n    temp_list = list()\n    for line in orig_list:\n        line_split = __re.split(r'(\\s+)', line)\n        temp_list.append(line_split)\n\n    return temp_list", "code_tokens": "def split_strings_in_list_retain_spaces ( orig_list ) : temp_list = list ( ) for line in orig_list : line_split = __re . split ( r'(\\s+)' , line ) temp_list . append ( line_split ) return temp_list", "docstring_tokens": "Function to split every line in a list and retain spaces for a rejoin : param orig_list : Original list : return : A List with split lines", "label": 0}, {"idx": "cosqa-train-8194", "doc": "python array to scalar", "code": "def is_scalar(value):\n    \"\"\"Test if the given value is a scalar.\n\n    This function also works with memory mapped array values, in contrast to the numpy is_scalar method.\n\n    Args:\n        value: the value to test for being a scalar value\n\n    Returns:\n        boolean: if the given value is a scalar or not\n    \"\"\"\n    return np.isscalar(value) or (isinstance(value, np.ndarray) and (len(np.squeeze(value).shape) == 0))", "code_tokens": "def is_scalar ( value ) : return np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and ( len ( np . squeeze ( value ) . shape ) == 0 ) )", "docstring_tokens": "Test if the given value is a scalar .", "label": 0}, {"idx": "cosqa-train-8195", "doc": "set axis subplot python", "code": "def set_axis_options(self, row, column, text):\n        \"\"\"Set additionnal options as plain text.\"\"\"\n\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_axis_options(text)", "code_tokens": "def set_axis_options ( self , row , column , text ) : subplot = self . get_subplot_at ( row , column ) subplot . set_axis_options ( text )", "docstring_tokens": "Set additionnal options as plain text .", "label": 1}, {"idx": "cosqa-train-8196", "doc": "python assert data type check if array type", "code": "def _assert_is_type(name, value, value_type):\n    \"\"\"Assert that a value must be a given type.\"\"\"\n    if not isinstance(value, value_type):\n        if type(value_type) is tuple:\n            types = ', '.join(t.__name__ for t in value_type)\n            raise ValueError('{0} must be one of ({1})'.format(name, types))\n        else:\n            raise ValueError('{0} must be {1}'\n                             .format(name, value_type.__name__))", "code_tokens": "def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )", "docstring_tokens": "Assert that a value must be a given type .", "label": 1}, {"idx": "cosqa-train-8197", "doc": "set cursor position in python", "code": "def _go_to_line(editor, line):\n    \"\"\"\n    Move cursor to this line in the current buffer.\n    \"\"\"\n    b = editor.application.current_buffer\n    b.cursor_position = b.document.translate_row_col_to_index(max(0, int(line) - 1), 0)", "code_tokens": "def _go_to_line ( editor , line ) : b = editor . application . current_buffer b . cursor_position = b . document . translate_row_col_to_index ( max ( 0 , int ( line ) - 1 ) , 0 )", "docstring_tokens": "Move cursor to this line in the current buffer .", "label": 1}, {"idx": "cosqa-train-8198", "doc": "python assert emit custom type", "code": "def _assert_is_type(name, value, value_type):\n    \"\"\"Assert that a value must be a given type.\"\"\"\n    if not isinstance(value, value_type):\n        if type(value_type) is tuple:\n            types = ', '.join(t.__name__ for t in value_type)\n            raise ValueError('{0} must be one of ({1})'.format(name, types))\n        else:\n            raise ValueError('{0} must be {1}'\n                             .format(name, value_type.__name__))", "code_tokens": "def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )", "docstring_tokens": "Assert that a value must be a given type .", "label": 0}, {"idx": "cosqa-train-8199", "doc": "set default in python dict", "code": "def setdefaults(dct, defaults):\n    \"\"\"Given a target dct and a dict of {key:default value} pairs,\n    calls setdefault for all of those pairs.\"\"\"\n    for key in defaults:\n        dct.setdefault(key, defaults[key])\n\n    return dct", "code_tokens": "def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct", "docstring_tokens": "Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs .", "label": 1}, {"idx": "cosqa-train-8200", "doc": "python assert match any", "code": "def rex_assert(self, rex, byte=False):\n        \"\"\"\n        If `rex` expression is not found then raise `DataNotFound` exception.\n        \"\"\"\n\n        self.rex_search(rex, byte=byte)", "code_tokens": "def rex_assert ( self , rex , byte = False ) : self . rex_search ( rex , byte = byte )", "docstring_tokens": "If rex expression is not found then raise DataNotFound exception .", "label": 0}, {"idx": "cosqa-train-8201", "doc": "set of unique objects python", "code": "def _init_unique_sets(self):\n        \"\"\"Initialise sets used for uniqueness checking.\"\"\"\n\n        ks = dict()\n        for t in self._unique_checks:\n            key = t[0]\n            ks[key] = set() # empty set\n        return ks", "code_tokens": "def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks", "docstring_tokens": "Initialise sets used for uniqueness checking .", "label": 1}, {"idx": "cosqa-train-8202", "doc": "python assert object has attribute", "code": "def contains(self, element):\n        \"\"\"\n        Ensures :attr:`subject` contains *other*.\n        \"\"\"\n        self._run(unittest_case.assertIn, (element, self._subject))\n        return ChainInspector(self._subject)", "code_tokens": "def contains ( self , element ) : self . _run ( unittest_case . assertIn , ( element , self . _subject ) ) return ChainInspector ( self . _subject )", "docstring_tokens": "Ensures : attr : subject contains * other * .", "label": 1}, {"idx": "cosqa-train-8203", "doc": "set proxy using command prompt for python", "code": "def setup(self, proxystr='', prompting=True):\n        \"\"\"\n        Sets the proxy handler given the option passed on the command\n        line.  If an empty string is passed it looks at the HTTP_PROXY\n        environment variable.\n        \"\"\"\n        self.prompting = prompting\n        proxy = self.get_proxy(proxystr)\n        if proxy:\n            proxy_support = urllib2.ProxyHandler({\"http\": proxy, \"ftp\": proxy})\n            opener = urllib2.build_opener(proxy_support, urllib2.CacheFTPHandler)\n            urllib2.install_opener(opener)", "code_tokens": "def setup ( self , proxystr = '' , prompting = True ) : self . prompting = prompting proxy = self . get_proxy ( proxystr ) if proxy : proxy_support = urllib2 . ProxyHandler ( { \"http\" : proxy , \"ftp\" : proxy } ) opener = urllib2 . build_opener ( proxy_support , urllib2 . CacheFTPHandler ) urllib2 . install_opener ( opener )", "docstring_tokens": "Sets the proxy handler given the option passed on the command line . If an empty string is passed it looks at the HTTP_PROXY environment variable .", "label": 1}, {"idx": "cosqa-train-8204", "doc": "python assert on items in list", "code": "def assert_list(self, putative_list, expected_type=string_types, key_arg=None):\n    \"\"\"\n    :API: public\n    \"\"\"\n    return assert_list(putative_list, expected_type, key_arg=key_arg,\n                       raise_type=lambda msg: TargetDefinitionException(self, msg))", "code_tokens": "def assert_list ( self , putative_list , expected_type = string_types , key_arg = None ) : return assert_list ( putative_list , expected_type , key_arg = key_arg , raise_type = lambda msg : TargetDefinitionException ( self , msg ) )", "docstring_tokens": ": API : public", "label": 1}, {"idx": "cosqa-train-8205", "doc": "set width of qwidget in python", "code": "def resize(self, width, height):\n        \"\"\"\n        Pyqt specific resize callback.\n        \"\"\"\n        if not self.fbo:\n            return\n\n        # pyqt reports sizes in actual buffer size\n        self.width = width // self.widget.devicePixelRatio()\n        self.height = height // self.widget.devicePixelRatio()\n        self.buffer_width = width\n        self.buffer_height = height\n\n        super().resize(width, height)", "code_tokens": "def resize ( self , width , height ) : if not self . fbo : return # pyqt reports sizes in actual buffer size self . width = width // self . widget . devicePixelRatio ( ) self . height = height // self . widget . devicePixelRatio ( ) self . buffer_width = width self . buffer_height = height super ( ) . resize ( width , height )", "docstring_tokens": "Pyqt specific resize callback .", "label": 1}, {"idx": "cosqa-train-8206", "doc": "python assert that one in a list of string is in another string", "code": "def assert_in(obj, seq, message=None, extra=None):\n    \"\"\"Raises an AssertionError if obj is not in seq.\"\"\"\n    assert obj in seq, _assert_fail_message(message, obj, seq, \"is not in\", extra)", "code_tokens": "def assert_in ( obj , seq , message = None , extra = None ) : assert obj in seq , _assert_fail_message ( message , obj , seq , \"is not in\" , extra )", "docstring_tokens": "Raises an AssertionError if obj is not in seq .", "label": 0}, {"idx": "cosqa-train-8207", "doc": "set width of table output in python", "code": "def get_table_width(table):\n    \"\"\"\n    Gets the width of the table that would be printed.\n    :rtype: ``int``\n    \"\"\"\n    columns = transpose_table(prepare_rows(table))\n    widths = [max(len(cell) for cell in column) for column in columns]\n    return len('+' + '|'.join('-' * (w + 2) for w in widths) + '+')", "code_tokens": "def get_table_width ( table ) : columns = transpose_table ( prepare_rows ( table ) ) widths = [ max ( len ( cell ) for cell in column ) for column in columns ] return len ( '+' + '|' . join ( '-' * ( w + 2 ) for w in widths ) + '+' )", "docstring_tokens": "Gets the width of the table that would be printed . : rtype : int", "label": 1}, {"idx": "cosqa-train-8208", "doc": "python assert type of variable", "code": "def assert_is_instance(value, types, message=None, extra=None):\n    \"\"\"Raises an AssertionError if value is not an instance of type(s).\"\"\"\n    assert isinstance(value, types), _assert_fail_message(\n        message, value, types, \"is not an instance of\", extra\n    )", "code_tokens": "def assert_is_instance ( value , types , message = None , extra = None ) : assert isinstance ( value , types ) , _assert_fail_message ( message , value , types , \"is not an instance of\" , extra )", "docstring_tokens": "Raises an AssertionError if value is not an instance of type ( s ) .", "label": 0}, {"idx": "cosqa-train-8209", "doc": "set window coordinates python", "code": "def set_position(self, x, y, width, height):\n        \"\"\"Set window top-left corner position and size\"\"\"\n        SetWindowPos(self._hwnd, None, x, y, width, height, ctypes.c_uint(0))", "code_tokens": "def set_position ( self , x , y , width , height ) : SetWindowPos ( self . _hwnd , None , x , y , width , height , ctypes . c_uint ( 0 ) )", "docstring_tokens": "Set window top - left corner position and size", "label": 1}, {"idx": "cosqa-train-8210", "doc": "python assertassert no description", "code": "def assert_is_not(expected, actual, message=None, extra=None):\n    \"\"\"Raises an AssertionError if expected is actual.\"\"\"\n    assert expected is not actual, _assert_fail_message(\n        message, expected, actual, \"is\", extra\n    )", "code_tokens": "def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , \"is\" , extra )", "docstring_tokens": "Raises an AssertionError if expected is actual .", "label": 1}, {"idx": "cosqa-train-8211", "doc": "set ylim on log axis python", "code": "def log_y_cb(self, w, val):\n        \"\"\"Toggle linear/log scale for Y-axis.\"\"\"\n        self.tab_plot.logy = val\n        self.plot_two_columns()", "code_tokens": "def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )", "docstring_tokens": "Toggle linear / log scale for Y - axis .", "label": 0}, {"idx": "cosqa-train-8212", "doc": "python async callbacks with as", "code": "def delegate(self, fn, *args, **kwargs):\n        \"\"\"Return the given operation as an asyncio future.\"\"\"\n        callback = functools.partial(fn, *args, **kwargs)\n        coro = self.loop.run_in_executor(self.subexecutor, callback)\n        return asyncio.ensure_future(coro)", "code_tokens": "def delegate ( self , fn , * args , * * kwargs ) : callback = functools . partial ( fn , * args , * * kwargs ) coro = self . loop . run_in_executor ( self . subexecutor , callback ) return asyncio . ensure_future ( coro )", "docstring_tokens": "Return the given operation as an asyncio future .", "label": 1}, {"idx": "cosqa-train-8213", "doc": "setting axis limits on python", "code": "def _set_axis_limits(self, which, lims, d, scale, reverse=False):\n        \"\"\"Private method for setting axis limits.\n\n        Sets the axis limits on each axis for an individual plot.\n\n        Args:\n            which (str): The indicator of which part of the plots\n                to adjust. This currently handles `x` and `y`.\n            lims (len-2 list of floats): The limits for the axis.\n            d (float): Amount to increment by between the limits.\n            scale (str): Scale of the axis. Either `log` or `lin`.\n            reverse (bool, optional): If True, reverse the axis tick marks. Default is False.\n\n        \"\"\"\n        setattr(self.limits, which + 'lims', lims)\n        setattr(self.limits, 'd' + which, d)\n        setattr(self.limits, which + 'scale', scale)\n\n        if reverse:\n            setattr(self.limits, 'reverse_' + which + '_axis', True)\n        return", "code_tokens": "def _set_axis_limits ( self , which , lims , d , scale , reverse = False ) : setattr ( self . limits , which + 'lims' , lims ) setattr ( self . limits , 'd' + which , d ) setattr ( self . limits , which + 'scale' , scale ) if reverse : setattr ( self . limits , 'reverse_' + which + '_axis' , True ) return", "docstring_tokens": "Private method for setting axis limits .", "label": 1}, {"idx": "cosqa-train-8214", "doc": "python async function as paremeter", "code": "def run_task(func):\n    \"\"\"\n    Decorator to wrap an async function in an event loop.\n    Use for main sync interface methods.\n    \"\"\"\n\n    def _wrapped(*a, **k):\n        loop = asyncio.get_event_loop()\n        return loop.run_until_complete(func(*a, **k))\n\n    return _wrapped", "code_tokens": "def run_task ( func ) : def _wrapped ( * a , * * k ) : loop = asyncio . get_event_loop ( ) return loop . run_until_complete ( func ( * a , * * k ) ) return _wrapped", "docstring_tokens": "Decorator to wrap an async function in an event loop . Use for main sync interface methods .", "label": 1}, {"idx": "cosqa-train-8215", "doc": "setting memory limit in python", "code": "def set_mem_per_proc(self, mem_mb):\n        \"\"\"Set the memory per process in megabytes\"\"\"\n        super().set_mem_per_proc(mem_mb)\n        self.qparams[\"mem_per_cpu\"] = self.mem_per_proc", "code_tokens": "def set_mem_per_proc ( self , mem_mb ) : super ( ) . set_mem_per_proc ( mem_mb ) self . qparams [ \"mem_per_cpu\" ] = self . mem_per_proc", "docstring_tokens": "Set the memory per process in megabytes", "label": 1}, {"idx": "cosqa-train-8216", "doc": "python async input from gui", "code": "async def async_input(prompt):\n    \"\"\"\n    Python's ``input()`` is blocking, which means the event loop we set\n    above can't be running while we're blocking there. This method will\n    let the loop run while we wait for input.\n    \"\"\"\n    print(prompt, end='', flush=True)\n    return (await loop.run_in_executor(None, sys.stdin.readline)).rstrip()", "code_tokens": "async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "docstring_tokens": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input .", "label": 1}, {"idx": "cosqa-train-8217", "doc": "setting the default python interprter", "code": "def safe_repr(obj):\n    \"\"\"\n    Try to get ``__name__`` first, ``__class__.__name__`` second\n    and finally, if we can't get anything acceptable, fallback\n    to user a ``repr()`` call.\n    \"\"\"\n    name = getattr(obj, '__name__', getattr(obj.__class__, '__name__'))\n    if name == 'ndict':\n        name = 'dict'\n    return name or repr(obj)", "code_tokens": "def safe_repr ( obj ) : name = getattr ( obj , '__name__' , getattr ( obj . __class__ , '__name__' ) ) if name == 'ndict' : name = 'dict' return name or repr ( obj )", "docstring_tokens": "Try to get __name__ first __class__ . __name__ second and finally if we can t get anything acceptable fallback to user a repr () call .", "label": 1}, {"idx": "cosqa-train-8218", "doc": "python async map multiple args", "code": "async def smap(source, func, *more_sources):\n    \"\"\"Apply a given function to the elements of one or several\n    asynchronous sequences.\n\n    Each element is used as a positional argument, using the same order as\n    their respective sources. The generation continues until the shortest\n    sequence is exhausted. The function is treated synchronously.\n\n    Note: if more than one sequence is provided, they're awaited concurrently\n    so that their waiting times don't add up.\n    \"\"\"\n    if more_sources:\n        source = zip(source, *more_sources)\n    async with streamcontext(source) as streamer:\n        async for item in streamer:\n            yield func(*item) if more_sources else func(item)", "code_tokens": "async def smap ( source , func , * more_sources ) : if more_sources : source = zip ( source , * more_sources ) async with streamcontext ( source ) as streamer : async for item in streamer : yield func ( * item ) if more_sources else func ( item )", "docstring_tokens": "Apply a given function to the elements of one or several asynchronous sequences .", "label": 1}, {"idx": "cosqa-train-8219", "doc": "shape of 2d array python", "code": "def out_shape_from_array(arr):\n    \"\"\"Get the output shape from an array.\"\"\"\n    arr = np.asarray(arr)\n    if arr.ndim == 1:\n        return arr.shape\n    else:\n        return (arr.shape[1],)", "code_tokens": "def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "docstring_tokens": "Get the output shape from an array .", "label": 0}, {"idx": "cosqa-train-8220", "doc": "python asyncio task check if is done or cancel", "code": "async def wait_and_quit(loop):\n\t\"\"\"Wait until all task are executed.\"\"\"\n\tfrom pylp.lib.tasks import running\n\tif running:\n\t\tawait asyncio.wait(map(lambda runner: runner.future, running))", "code_tokens": "async def wait_and_quit ( loop ) : from pylp . lib . tasks import running if running : await asyncio . wait ( map ( lambda runner : runner . future , running ) )", "docstring_tokens": "Wait until all task are executed .", "label": 1}, {"idx": "cosqa-train-8221", "doc": "shifting file pointer to beginning of the file in python", "code": "def align_file_position(f, size):\n    \"\"\" Align the position in the file to the next block of specified size \"\"\"\n    align = (size - 1) - (f.tell() % size)\n    f.seek(align, 1)", "code_tokens": "def align_file_position ( f , size ) : align = ( size - 1 ) - ( f . tell ( ) % size ) f . seek ( align , 1 )", "docstring_tokens": "Align the position in the file to the next block of specified size", "label": 1}, {"idx": "cosqa-train-8222", "doc": "python attributeerror how to fix", "code": "def safe_setattr(obj, name, value):\n    \"\"\"Attempt to setattr but catch AttributeErrors.\"\"\"\n    try:\n        setattr(obj, name, value)\n        return True\n    except AttributeError:\n        return False", "code_tokens": "def safe_setattr ( obj , name , value ) : try : setattr ( obj , name , value ) return True except AttributeError : return False", "docstring_tokens": "Attempt to setattr but catch AttributeErrors .", "label": 1}, {"idx": "cosqa-train-8223", "doc": "shortcut for making arrays python", "code": "def torecarray(*args, **kwargs):\n    \"\"\"\n    Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.\n\n    \"\"\"\n\n    import numpy as np\n    return toarray(*args, **kwargs).view(np.recarray)", "code_tokens": "def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )", "docstring_tokens": "Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) .", "label": 1}, {"idx": "cosqa-train-8224", "doc": "python autogen proxy list", "code": "def load(self):\n        \"\"\"Load proxy list from configured proxy source\"\"\"\n        self._list = self._source.load()\n        self._list_iter = itertools.cycle(self._list)", "code_tokens": "def load ( self ) : self . _list = self . _source . load ( ) self . _list_iter = itertools . cycle ( self . _list )", "docstring_tokens": "Load proxy list from configured proxy source", "label": 0}, {"idx": "cosqa-train-8225", "doc": "shortest run of values in array python", "code": "def longest_run_1d(arr):\n    \"\"\"Return the length of the longest consecutive run of identical values.\n\n    Parameters\n    ----------\n    arr : bool array\n      Input array\n\n    Returns\n    -------\n    int\n      Length of longest run.\n    \"\"\"\n    v, rl = rle_1d(arr)[:2]\n    return np.where(v, rl, 0).max()", "code_tokens": "def longest_run_1d ( arr ) : v , rl = rle_1d ( arr ) [ : 2 ] return np . where ( v , rl , 0 ) . max ( )", "docstring_tokens": "Return the length of the longest consecutive run of identical values .", "label": 1}, {"idx": "cosqa-train-8226", "doc": "python average function on 2d array", "code": "def average_gradient(data, *kwargs):\n    \"\"\" Compute average gradient norm of an image\n    \"\"\"\n    return np.average(np.array(np.gradient(data))**2)", "code_tokens": "def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )", "docstring_tokens": "Compute average gradient norm of an image", "label": 1}, {"idx": "cosqa-train-8227", "doc": "shortest string in an array python", "code": "def longest_run_1d(arr):\n    \"\"\"Return the length of the longest consecutive run of identical values.\n\n    Parameters\n    ----------\n    arr : bool array\n      Input array\n\n    Returns\n    -------\n    int\n      Length of longest run.\n    \"\"\"\n    v, rl = rle_1d(arr)[:2]\n    return np.where(v, rl, 0).max()", "code_tokens": "def longest_run_1d ( arr ) : v , rl = rle_1d ( arr ) [ : 2 ] return np . where ( v , rl , 0 ) . max ( )", "docstring_tokens": "Return the length of the longest consecutive run of identical values .", "label": 0}, {"idx": "cosqa-train-8228", "doc": "python aws rds if an identifier points to an rds instance or an rds cluster", "code": "def list_rds(region, filter_by_kwargs):\n    \"\"\"List all RDS thingys.\"\"\"\n    conn = boto.rds.connect_to_region(region)\n    instances = conn.get_all_dbinstances()\n    return lookup(instances, filter_by=filter_by_kwargs)", "code_tokens": "def list_rds ( region , filter_by_kwargs ) : conn = boto . rds . connect_to_region ( region ) instances = conn . get_all_dbinstances ( ) return lookup ( instances , filter_by = filter_by_kwargs )", "docstring_tokens": "List all RDS thingys .", "label": 0}, {"idx": "cosqa-train-8229", "doc": "should use enum in python", "code": "def __init__(self, enumtype, index, key):\n        \"\"\" Set up a new instance. \"\"\"\n        self._enumtype = enumtype\n        self._index = index\n        self._key = key", "code_tokens": "def __init__ ( self , enumtype , index , key ) : self . _enumtype = enumtype self . _index = index self . _key = key", "docstring_tokens": "Set up a new instance .", "label": 0}, {"idx": "cosqa-train-8230", "doc": "python axis labels on subplot", "code": "def show_xticklabels(self, row, column):\n        \"\"\"Show the x-axis tick labels for a subplot.\n\n        :param row,column: specify the subplot.\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.show_xticklabels()", "code_tokens": "def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "docstring_tokens": "Show the x - axis tick labels for a subplot .", "label": 0}, {"idx": "cosqa-train-8231", "doc": "show legend in python plot", "code": "def finish_plot():\n    \"\"\"Helper for plotting.\"\"\"\n    plt.legend()\n    plt.grid(color='0.7')\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.show()", "code_tokens": "def finish_plot ( ) : plt . legend ( ) plt . grid ( color = '0.7' ) plt . xlabel ( 'x' ) plt . ylabel ( 'y' ) plt . show ( )", "docstring_tokens": "Helper for plotting .", "label": 0}, {"idx": "cosqa-train-8232", "doc": "python base64 encode bytes for json", "code": "def _bytes_to_json(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\"\"\"\n    if isinstance(value, bytes):\n        value = base64.standard_b64encode(value).decode(\"ascii\")\n    return value", "code_tokens": "def _bytes_to_json ( value ) : if isinstance ( value , bytes ) : value = base64 . standard_b64encode ( value ) . decode ( \"ascii\" ) return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 0}, {"idx": "cosqa-train-8233", "doc": "signed binary represenation of a int python", "code": "def bin_to_int(string):\n    \"\"\"Convert a one element byte string to signed int for python 2 support.\"\"\"\n    if isinstance(string, str):\n        return struct.unpack(\"b\", string)[0]\n    else:\n        return struct.unpack(\"b\", bytes([string]))[0]", "code_tokens": "def bin_to_int ( string ) : if isinstance ( string , str ) : return struct . unpack ( \"b\" , string ) [ 0 ] else : return struct . unpack ( \"b\" , bytes ( [ string ] ) ) [ 0 ]", "docstring_tokens": "Convert a one element byte string to signed int for python 2 support .", "label": 0}, {"idx": "cosqa-train-8234", "doc": "python blueprint route expression", "code": "def get_url(self, routename, **kargs):\n        \"\"\" Return a string that matches a named route \"\"\"\n        return '/' + self.routes.build(routename, **kargs).split(';', 1)[1]", "code_tokens": "def get_url ( self , routename , * * kargs ) : return '/' + self . routes . build ( routename , * * kargs ) . split ( ';' , 1 ) [ 1 ]", "docstring_tokens": "Return a string that matches a named route", "label": 1}, {"idx": "cosqa-train-8235", "doc": "skip formula column in python file read", "code": "def _skip_frame(self):\n        \"\"\"Skip the next time frame\"\"\"\n        for line in self._f:\n            if line == 'ITEM: ATOMS\\n':\n                break\n        for i in range(self.num_atoms):\n            next(self._f)", "code_tokens": "def _skip_frame ( self ) : for line in self . _f : if line == 'ITEM: ATOMS\\n' : break for i in range ( self . num_atoms ) : next ( self . _f )", "docstring_tokens": "Skip the next time frame", "label": 0}, {"idx": "cosqa-train-8236", "doc": "python bootstrapping confidence interval", "code": "def mean_cl_boot(series, n_samples=1000, confidence_interval=0.95,\n                 random_state=None):\n    \"\"\"\n    Bootstrapped mean with confidence limits\n    \"\"\"\n    return bootstrap_statistics(series, np.mean,\n                                n_samples=n_samples,\n                                confidence_interval=confidence_interval,\n                                random_state=random_state)", "code_tokens": "def mean_cl_boot ( series , n_samples = 1000 , confidence_interval = 0.95 , random_state = None ) : return bootstrap_statistics ( series , np . mean , n_samples = n_samples , confidence_interval = confidence_interval , random_state = random_state )", "docstring_tokens": "Bootstrapped mean with confidence limits", "label": 0}, {"idx": "cosqa-train-8237", "doc": "sleep the code some time in python", "code": "def test3():\n    \"\"\"Test the multiprocess\n    \"\"\"\n    import time\n    \n    p = MVisionProcess()\n    p.start()\n    time.sleep(5)\n    p.stop()", "code_tokens": "def test3 ( ) : import time p = MVisionProcess ( ) p . start ( ) time . sleep ( 5 ) p . stop ( )", "docstring_tokens": "Test the multiprocess", "label": 1}, {"idx": "cosqa-train-8238", "doc": "python boto3 how to delete file", "code": "def remove_file_from_s3(awsclient, bucket, key):\n    \"\"\"Remove a file from an AWS S3 bucket.\n\n    :param awsclient:\n    :param bucket:\n    :param key:\n    :return:\n    \"\"\"\n    client_s3 = awsclient.get_client('s3')\n    response = client_s3.delete_object(Bucket=bucket, Key=key)", "code_tokens": "def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )", "docstring_tokens": "Remove a file from an AWS S3 bucket .", "label": 1}, {"idx": "cosqa-train-8239", "doc": "slice a column from a table in python", "code": "def getcolslice(self, blc, trc, inc=[], startrow=0, nrow=-1, rowincr=1):\n        \"\"\"Get a slice from a table column holding arrays.\n        (see :func:`table.getcolslice`)\"\"\"\n        return self._table.getcolslice(self._column, blc, trc, inc, startrow, nrow, rowincr)", "code_tokens": "def getcolslice ( self , blc , trc , inc = [ ] , startrow = 0 , nrow = - 1 , rowincr = 1 ) : return self . _table . getcolslice ( self . _column , blc , trc , inc , startrow , nrow , rowincr )", "docstring_tokens": "Get a slice from a table column holding arrays . ( see : func : table . getcolslice )", "label": 1}, {"idx": "cosqa-train-8240", "doc": "python bottle auto reload", "code": "def start():\n    \"\"\"Starts the web server.\"\"\"\n    global app\n    bottle.run(app, host=conf.WebHost, port=conf.WebPort,\n               debug=conf.WebAutoReload, reloader=conf.WebAutoReload,\n               quiet=conf.WebQuiet)", "code_tokens": "def start ( ) : global app bottle . run ( app , host = conf . WebHost , port = conf . WebPort , debug = conf . WebAutoReload , reloader = conf . WebAutoReload , quiet = conf . WebQuiet )", "docstring_tokens": "Starts the web server .", "label": 0}, {"idx": "cosqa-train-8241", "doc": "slplit string in words in python then pass to compare", "code": "def split(s):\n  \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"\n  l = [_split(x) for x in _SPLIT_RE.split(s)]\n  return [item for sublist in l for item in sublist]", "code_tokens": "def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Uses dynamic programming to infer the location of spaces in a string without spaces .", "label": 1}, {"idx": "cosqa-train-8242", "doc": "python bound method return string", "code": "def get_http_method(self, method):\n        \"\"\"Gets the http method that will be called from the requests library\"\"\"\n        return self.http_methods[method](self.url, **self.http_method_args)", "code_tokens": "def get_http_method ( self , method ) : return self . http_methods [ method ] ( self . url , * * self . http_method_args )", "docstring_tokens": "Gets the http method that will be called from the requests library", "label": 1}, {"idx": "cosqa-train-8243", "doc": "sort a array in python", "code": "def arglexsort(arrays):\n    \"\"\"\n    Returns the indices of the lexicographical sorting\n    order of the supplied arrays.\n    \"\"\"\n    dtypes = ','.join(array.dtype.str for array in arrays)\n    recarray = np.empty(len(arrays[0]), dtype=dtypes)\n    for i, array in enumerate(arrays):\n        recarray['f%s' % i] = array\n    return recarray.argsort()", "code_tokens": "def arglexsort ( arrays ) : dtypes = ',' . join ( array . dtype . str for array in arrays ) recarray = np . empty ( len ( arrays [ 0 ] ) , dtype = dtypes ) for i , array in enumerate ( arrays ) : recarray [ 'f%s' % i ] = array return recarray . argsort ( )", "docstring_tokens": "Returns the indices of the lexicographical sorting order of the supplied arrays .", "label": 1}, {"idx": "cosqa-train-8244", "doc": "python boxplot data frame", "code": "def compute_boxplot(self, series):\n        \"\"\"\n        Compute boxplot for given pandas Series.\n        \"\"\"\n        from matplotlib.cbook import boxplot_stats\n        series = series[series.notnull()]\n        if len(series.values) == 0:\n            return {}\n        elif not is_numeric_dtype(series):\n            return self.non_numeric_stats(series)\n        stats = boxplot_stats(list(series.values))[0]\n        stats['count'] = len(series.values)\n        stats['fliers'] = \"|\".join(map(str, stats['fliers']))\n        return stats", "code_tokens": "def compute_boxplot ( self , series ) : from matplotlib . cbook import boxplot_stats series = series [ series . notnull ( ) ] if len ( series . values ) == 0 : return { } elif not is_numeric_dtype ( series ) : return self . non_numeric_stats ( series ) stats = boxplot_stats ( list ( series . values ) ) [ 0 ] stats [ 'count' ] = len ( series . values ) stats [ 'fliers' ] = \"|\" . join ( map ( str , stats [ 'fliers' ] ) ) return stats", "docstring_tokens": "Compute boxplot for given pandas Series .", "label": 1}, {"idx": "cosqa-train-8245", "doc": "sort object python oberride compare", "code": "def __sort_up(self):\n\n        \"\"\"Sort the updatable objects according to ascending order\"\"\"\n        if self.__do_need_sort_up:\n            self.__up_objects.sort(key=cmp_to_key(self.__up_cmp))\n            self.__do_need_sort_up = False", "code_tokens": "def __sort_up ( self ) : if self . __do_need_sort_up : self . __up_objects . sort ( key = cmp_to_key ( self . __up_cmp ) ) self . __do_need_sort_up = False", "docstring_tokens": "Sort the updatable objects according to ascending order", "label": 1}, {"idx": "cosqa-train-8246", "doc": "python bugzilla bypass ssl cert checking", "code": "def disable_cert_validation():\n    \"\"\"Context manager to temporarily disable certificate validation in the standard SSL\n    library.\n\n    Note: This should not be used in production code but is sometimes useful for\n    troubleshooting certificate validation issues.\n\n    By design, the standard SSL library does not provide a way to disable verification\n    of the server side certificate. However, a patch to disable validation is described\n    by the library developers. This context manager allows applying the patch for\n    specific sections of code.\n\n    \"\"\"\n    current_context = ssl._create_default_https_context\n    ssl._create_default_https_context = ssl._create_unverified_context\n    try:\n        yield\n    finally:\n        ssl._create_default_https_context = current_context", "code_tokens": "def disable_cert_validation ( ) : current_context = ssl . _create_default_https_context ssl . _create_default_https_context = ssl . _create_unverified_context try : yield finally : ssl . _create_default_https_context = current_context", "docstring_tokens": "Context manager to temporarily disable certificate validation in the standard SSL library .", "label": 1}, {"idx": "cosqa-train-8247", "doc": "sort with array and give index python", "code": "def unsort_vector(data, indices_of_increasing):\n    \"\"\"Upermutate 1-D data that is sorted by indices_of_increasing.\"\"\"\n    return numpy.array([data[indices_of_increasing.index(i)] for i in range(len(data))])", "code_tokens": "def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )", "docstring_tokens": "Upermutate 1 - D data that is sorted by indices_of_increasing .", "label": 1}, {"idx": "cosqa-train-8248", "doc": "python builtin array 2d", "code": "def poke_array(self, store, name, elemtype, elements, container, visited, _stack):\n        \"\"\"abstract method\"\"\"\n        raise NotImplementedError", "code_tokens": "def poke_array ( self , store , name , elemtype , elements , container , visited , _stack ) : raise NotImplementedError", "docstring_tokens": "abstract method", "label": 1}, {"idx": "cosqa-train-8249", "doc": "split a list into smaller lists of n size python", "code": "def chunked(l, n):\n    \"\"\"Chunk one big list into few small lists.\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunked ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Chunk one big list into few small lists .", "label": 1}, {"idx": "cosqa-train-8250", "doc": "python bulk index helpers example", "code": "def update_index(index):\n    \"\"\"Re-index every document in a named index.\"\"\"\n    logger.info(\"Updating search index: '%s'\", index)\n    client = get_client()\n    responses = []\n    for model in get_index_models(index):\n        logger.info(\"Updating search index model: '%s'\", model.search_doc_type)\n        objects = model.objects.get_search_queryset(index).iterator()\n        actions = bulk_actions(objects, index=index, action=\"index\")\n        response = helpers.bulk(client, actions, chunk_size=get_setting(\"chunk_size\"))\n        responses.append(response)\n    return responses", "code_tokens": "def update_index ( index ) : logger . info ( \"Updating search index: '%s'\" , index ) client = get_client ( ) responses = [ ] for model in get_index_models ( index ) : logger . info ( \"Updating search index model: '%s'\" , model . search_doc_type ) objects = model . objects . get_search_queryset ( index ) . iterator ( ) actions = bulk_actions ( objects , index = index , action = \"index\" ) response = helpers . bulk ( client , actions , chunk_size = get_setting ( \"chunk_size\" ) ) responses . append ( response ) return responses", "docstring_tokens": "Re - index every document in a named index .", "label": 1}, {"idx": "cosqa-train-8251", "doc": "split string into list of words python", "code": "def split_into_words(s):\n  \"\"\"Split a sentence into list of words.\"\"\"\n  s = re.sub(r\"\\W+\", \" \", s)\n  s = re.sub(r\"[_0-9]+\", \" \", s)\n  return s.split()", "code_tokens": "def split_into_words ( s ) : s = re . sub ( r\"\\W+\" , \" \" , s ) s = re . sub ( r\"[_0-9]+\" , \" \" , s ) return s . split ( )", "docstring_tokens": "Split a sentence into list of words .", "label": 1}, {"idx": "cosqa-train-8252", "doc": "python bytes to human readable size", "code": "def fmt_sz(intval):\n    \"\"\" Format a byte sized value.\n    \"\"\"\n    try:\n        return fmt.human_size(intval)\n    except (ValueError, TypeError):\n        return \"N/A\".rjust(len(fmt.human_size(0)))", "code_tokens": "def fmt_sz ( intval ) : try : return fmt . human_size ( intval ) except ( ValueError , TypeError ) : return \"N/A\" . rjust ( len ( fmt . human_size ( 0 ) ) )", "docstring_tokens": "Format a byte sized value .", "label": 1}, {"idx": "cosqa-train-8253", "doc": "split string into n substrings python", "code": "def _split_str(s, n):\n    \"\"\"\n    split string into list of strings by specified number.\n    \"\"\"\n    length = len(s)\n    return [s[i:i + n] for i in range(0, length, n)]", "code_tokens": "def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]", "docstring_tokens": "split string into list of strings by specified number .", "label": 0}, {"idx": "cosqa-train-8254", "doc": "python c dll unload", "code": "def cleanup_lib(self):\n        \"\"\" unload the previously loaded shared library \"\"\"\n        if not self.using_openmp:\n            #this if statement is necessary because shared libraries that use\n            #OpenMP will core dump when unloaded, this is a well-known issue with OpenMP\n            logging.debug('unloading shared library')\n            _ctypes.dlclose(self.lib._handle)", "code_tokens": "def cleanup_lib ( self ) : if not self . using_openmp : #this if statement is necessary because shared libraries that use #OpenMP will core dump when unloaded, this is a well-known issue with OpenMP logging . debug ( 'unloading shared library' ) _ctypes . dlclose ( self . lib . _handle )", "docstring_tokens": "unload the previously loaded shared library", "label": 1}, {"idx": "cosqa-train-8255", "doc": "split the provided string into specified number of substrings python", "code": "def _split_str(s, n):\n    \"\"\"\n    split string into list of strings by specified number.\n    \"\"\"\n    length = len(s)\n    return [s[i:i + n] for i in range(0, length, n)]", "code_tokens": "def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]", "docstring_tokens": "split string into list of strings by specified number .", "label": 0}, {"idx": "cosqa-train-8256", "doc": "python cache value in function", "code": "def _get_memoized_value(func, args, kwargs):\n    \"\"\"Used internally by memoize decorator to get/store function results\"\"\"\n    key = (repr(args), repr(kwargs))\n\n    if not key in func._cache_dict:\n        ret = func(*args, **kwargs)\n        func._cache_dict[key] = ret\n\n    return func._cache_dict[key]", "code_tokens": "def _get_memoized_value ( func , args , kwargs ) : key = ( repr ( args ) , repr ( kwargs ) ) if not key in func . _cache_dict : ret = func ( * args , * * kwargs ) func . _cache_dict [ key ] = ret return func . _cache_dict [ key ]", "docstring_tokens": "Used internally by memoize decorator to get / store function results", "label": 0}, {"idx": "cosqa-train-8257", "doc": "sqlalchemy row delete python", "code": "def locked_delete(self):\n        \"\"\"Delete credentials from the SQLAlchemy datastore.\"\"\"\n        filters = {self.key_name: self.key_value}\n        self.session.query(self.model_class).filter_by(**filters).delete()", "code_tokens": "def locked_delete ( self ) : filters = { self . key_name : self . key_value } self . session . query ( self . model_class ) . filter_by ( * * filters ) . delete ( )", "docstring_tokens": "Delete credentials from the SQLAlchemy datastore .", "label": 1}, {"idx": "cosqa-train-8258", "doc": "python calc normal of 3d points", "code": "def triangle_normal(a, b, c):\n    \"\"\"Return a vector orthogonal to the given triangle\n\n       Arguments:\n         a, b, c  --  three 3D numpy vectors\n    \"\"\"\n    normal = np.cross(a - c, b - c)\n    norm = np.linalg.norm(normal)\n    return normal/norm", "code_tokens": "def triangle_normal ( a , b , c ) : normal = np . cross ( a - c , b - c ) norm = np . linalg . norm ( normal ) return normal / norm", "docstring_tokens": "Return a vector orthogonal to the given triangle", "label": 1}, {"idx": "cosqa-train-8259", "doc": "ssl handshake failed failed python fix", "code": "def _shutdown_transport(self):\n        \"\"\"Unwrap a Python 2.6 SSL socket, so we can call shutdown()\"\"\"\n        if self.sock is not None:\n            try:\n                unwrap = self.sock.unwrap\n            except AttributeError:\n                return\n            try:\n                self.sock = unwrap()\n            except ValueError:\n                # Failure within SSL might mean unwrap exists but socket is not\n                # deemed wrapped\n                pass", "code_tokens": "def _shutdown_transport ( self ) : if self . sock is not None : try : unwrap = self . sock . unwrap except AttributeError : return try : self . sock = unwrap ( ) except ValueError : # Failure within SSL might mean unwrap exists but socket is not # deemed wrapped pass", "docstring_tokens": "Unwrap a Python 2 . 6 SSL socket so we can call shutdown ()", "label": 1}, {"idx": "cosqa-train-8260", "doc": "python calculate area of triangle given points", "code": "def get_tri_area(pts):\n    \"\"\"\n    Given a list of coords for 3 points,\n    Compute the area of this triangle.\n\n    Args:\n        pts: [a, b, c] three points\n    \"\"\"\n    a, b, c = pts[0], pts[1], pts[2]\n    v1 = np.array(b) - np.array(a)\n    v2 = np.array(c) - np.array(a)\n    area_tri = abs(sp.linalg.norm(sp.cross(v1, v2)) / 2)\n    return area_tri", "code_tokens": "def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri", "docstring_tokens": "Given a list of coords for 3 points Compute the area of this triangle .", "label": 1}, {"idx": "cosqa-train-8261", "doc": "stack 2d lists python", "code": "def column_stack_2d(data):\n    \"\"\"Perform column-stacking on a list of 2d data blocks.\"\"\"\n    return list(list(itt.chain.from_iterable(_)) for _ in zip(*data))", "code_tokens": "def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )", "docstring_tokens": "Perform column - stacking on a list of 2d data blocks .", "label": 1}, {"idx": "cosqa-train-8262", "doc": "stack overflow python requests exceeded 30 redirects", "code": "def post_ratelimited(protocol, session, url, headers, data, allow_redirects=False, stream=False):\n    \"\"\"\n    There are two error-handling policies implemented here: a fail-fast policy intended for stand-alone scripts which\n    fails on all responses except HTTP 200. The other policy is intended for long-running tasks that need to respect\n    rate-limiting errors from the server and paper over outages of up to 1 hour.\n\n    Wrap POST requests in a try-catch loop with a lot of error handling logic and some basic rate-limiting. If a request\n    fails, and some conditions are met, the loop waits in increasing intervals, up to 1 hour, before trying again. The\n    reason for this is that servers often malfunction for short periods of time, either because of ongoing data\n    migrations or other maintenance tasks, misconfigurations or heavy load, or because the connecting user has hit a\n    throttling policy limit.\n\n    If the loop exited early, consumers of this package that don't implement their own rate-limiting code could quickly\n    swamp such a server with new requests. That would only make things worse. Instead, it's better if the request loop\n    waits patiently until the server is functioning again.\n\n    If the connecting user has hit a throttling policy, then the server will start to malfunction in many interesting\n    ways, but never actually tell the user what is happening. There is no way to distinguish this situation from other\n    malfunctions. The only cure is to stop making requests.\n\n    The contract on sessions here is to return the session that ends up being used, or retiring the session if we\n    intend to raise an exception. We give up on max_wait timeout, not number of retries.\n\n    An additional resource on handling throttling policies and client back off strategies:\n        https://msdn.microsoft.com/en-us/library/office/jj945066(v=exchg.150).aspx#bk_ThrottlingBatch\n    \"\"\"\n    thread_id = get_ident()\n    wait = 10  # seconds\n    retry = 0\n    redirects = 0\n    # In Python 2, we want this to be a 'str' object so logging doesn't break (all formatting arguments are 'str').\n    # We activated 'unicode_literals' at the top of this file, so it would be a 'unicode' object unless we convert\n    # to 'str' explicitly. This is a no-op for Python 3.\n    log_msg = str('''\\\nRetry: %(retry)s\nWaited: %(wait)s\nTimeout: %(timeout)s\nSession: %(session_id)s\nThread: %(thread_id)s\nAuth type: %(auth)s\nURL: %(url)s\nHTTP adapter: %(adapter)s\nAllow redirects: %(allow_redirects)s\nStreaming: %(stream)s\nResponse time: %(response_time)s\nStatus code: %(status_code)s\nRequest headers: %(request_headers)s\nResponse headers: %(response_headers)s\nRequest data: %(xml_request)s\nResponse data: %(xml_response)s\n''')\n    log_vals = dict(\n        retry=retry,\n        wait=wait,\n        timeout=protocol.TIMEOUT,\n        session_id=session.session_id,\n        thread_id=thread_id,\n        auth=session.auth,\n        url=url,\n        adapter=session.get_adapter(url),\n        allow_redirects=allow_redirects,\n        stream=stream,\n        response_time=None,\n        status_code=None,\n        request_headers=headers,\n        response_headers=None,\n        xml_request=data,\n        xml_response=None,\n    )\n    try:\n        while True:\n            _back_off_if_needed(protocol.credentials.back_off_until)\n            log.debug('Session %s thread %s: retry %s timeout %s POST\\'ing to %s after %ss wait', session.session_id,\n                      thread_id, retry, protocol.TIMEOUT, url, wait)\n            d_start = time_func()\n            # Always create a dummy response for logging purposes, in case we fail in the following\n            r = DummyResponse(url=url, headers={}, request_headers=headers)\n            try:\n                r = session.post(url=url, headers=headers, data=data, allow_redirects=False, timeout=protocol.TIMEOUT,\n                                 stream=stream)\n            except CONNECTION_ERRORS as e:\n                log.debug('Session %s thread %s: connection error POST\\'ing to %s', session.session_id, thread_id, url)\n                r = DummyResponse(url=url, headers={'TimeoutException': e}, request_headers=headers)\n            finally:\n                log_vals.update(\n                    retry=retry,\n                    wait=wait,\n                    session_id=session.session_id,\n                    url=str(r.url),\n                    response_time=time_func() - d_start,\n                    status_code=r.status_code,\n                    request_headers=r.request.headers,\n                    response_headers=r.headers,\n                    xml_response='[STREAMING]' if stream else r.content,\n                )\n            log.debug(log_msg, log_vals)\n            if _may_retry_on_error(r, protocol, wait):\n                log.info(\"Session %s thread %s: Connection error on URL %s (code %s). Cool down %s secs\",\n                         session.session_id, thread_id, r.url, r.status_code, wait)\n                time.sleep(wait)  # Increase delay for every retry\n                retry += 1\n                wait *= 2\n                session = protocol.renew_session(session)\n                continue\n            if r.status_code in (301, 302):\n                if stream:\n                    r.close()\n                url, redirects = _redirect_or_fail(r, redirects, allow_redirects)\n                continue\n            break\n    except (RateLimitError, RedirectError) as e:\n        log.warning(e.value)\n        protocol.retire_session(session)\n        raise\n    except Exception as e:\n        # Let higher layers handle this. Add full context for better debugging.\n        log.error(str('%s: %s\\n%s'), e.__class__.__name__, str(e), log_msg % log_vals)\n        protocol.retire_session(session)\n        raise\n    if r.status_code == 500 and r.content and is_xml(r.content):\n        # Some genius at Microsoft thinks it's OK to send a valid SOAP response as an HTTP 500\n        log.debug('Got status code %s but trying to parse content anyway', r.status_code)\n    elif r.status_code != 200:\n        protocol.retire_session(session)\n        try:\n            _raise_response_errors(r, protocol, log_msg, log_vals)  # Always raises an exception\n        finally:\n            if stream:\n                r.close()\n    log.debug('Session %s thread %s: Useful response from %s', session.session_id, thread_id, url)\n    return r, session", "code_tokens": "def post_ratelimited ( protocol , session , url , headers , data , allow_redirects = False , stream = False ) : thread_id = get_ident ( ) wait = 10 # seconds retry = 0 redirects = 0 # In Python 2, we want this to be a 'str' object so logging doesn't break (all formatting arguments are 'str'). # We activated 'unicode_literals' at the top of this file, so it would be a 'unicode' object unless we convert # to 'str' explicitly. This is a no-op for Python 3. log_msg = str ( '''\\\nRetry: %(retry)s\nWaited: %(wait)s\nTimeout: %(timeout)s\nSession: %(session_id)s\nThread: %(thread_id)s\nAuth type: %(auth)s\nURL: %(url)s\nHTTP adapter: %(adapter)s\nAllow redirects: %(allow_redirects)s\nStreaming: %(stream)s\nResponse time: %(response_time)s\nStatus code: %(status_code)s\nRequest headers: %(request_headers)s\nResponse headers: %(response_headers)s\nRequest data: %(xml_request)s\nResponse data: %(xml_response)s\n''' ) log_vals = dict ( retry = retry , wait = wait , timeout = protocol . TIMEOUT , session_id = session . session_id , thread_id = thread_id , auth = session . auth , url = url , adapter = session . get_adapter ( url ) , allow_redirects = allow_redirects , stream = stream , response_time = None , status_code = None , request_headers = headers , response_headers = None , xml_request = data , xml_response = None , ) try : while True : _back_off_if_needed ( protocol . credentials . back_off_until ) log . debug ( 'Session %s thread %s: retry %s timeout %s POST\\'ing to %s after %ss wait' , session . session_id , thread_id , retry , protocol . TIMEOUT , url , wait ) d_start = time_func ( ) # Always create a dummy response for logging purposes, in case we fail in the following r = DummyResponse ( url = url , headers = { } , request_headers = headers ) try : r = session . post ( url = url , headers = headers , data = data , allow_redirects = False , timeout = protocol . TIMEOUT , stream = stream ) except CONNECTION_ERRORS as e : log . debug ( 'Session %s thread %s: connection error POST\\'ing to %s' , session . session_id , thread_id , url ) r = DummyResponse ( url = url , headers = { 'TimeoutException' : e } , request_headers = headers ) finally : log_vals . update ( retry = retry , wait = wait , session_id = session . session_id , url = str ( r . url ) , response_time = time_func ( ) - d_start , status_code = r . status_code , request_headers = r . request . headers , response_headers = r . headers , xml_response = '[STREAMING]' if stream else r . content , ) log . debug ( log_msg , log_vals ) if _may_retry_on_error ( r , protocol , wait ) : log . info ( \"Session %s thread %s: Connection error on URL %s (code %s). Cool down %s secs\" , session . session_id , thread_id , r . url , r . status_code , wait ) time . sleep ( wait ) # Increase delay for every retry retry += 1 wait *= 2 session = protocol . renew_session ( session ) continue if r . status_code in ( 301 , 302 ) : if stream : r . close ( ) url , redirects = _redirect_or_fail ( r , redirects , allow_redirects ) continue break except ( RateLimitError , RedirectError ) as e : log . warning ( e . value ) protocol . retire_session ( session ) raise except Exception as e : # Let higher layers handle this. Add full context for better debugging. log . error ( str ( '%s: %s\\n%s' ) , e . __class__ . __name__ , str ( e ) , log_msg % log_vals ) protocol . retire_session ( session ) raise if r . status_code == 500 and r . content and is_xml ( r . content ) : # Some genius at Microsoft thinks it's OK to send a valid SOAP response as an HTTP 500 log . debug ( 'Got status code %s but trying to parse content anyway' , r . status_code ) elif r . status_code != 200 : protocol . retire_session ( session ) try : _raise_response_errors ( r , protocol , log_msg , log_vals ) # Always raises an exception finally : if stream : r . close ( ) log . debug ( 'Session %s thread %s: Useful response from %s' , session . session_id , thread_id , url ) return r , session", "docstring_tokens": "There are two error - handling policies implemented here : a fail - fast policy intended for stand - alone scripts which fails on all responses except HTTP 200 . The other policy is intended for long - running tasks that need to respect rate - limiting errors from the server and paper over outages of up to 1 hour .", "label": 0}, {"idx": "cosqa-train-8263", "doc": "python calculate fft frequency amplitude phase", "code": "def fft_freqs(n_fft, fs):\n    \"\"\"Return frequencies for DFT\n\n    Parameters\n    ----------\n    n_fft : int\n        Number of points in the FFT.\n    fs : float\n        The sampling rate.\n    \"\"\"\n    return np.arange(0, (n_fft // 2 + 1)) / float(n_fft) * float(fs)", "code_tokens": "def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )", "docstring_tokens": "Return frequencies for DFT", "label": 1}, {"idx": "cosqa-train-8264", "doc": "stackoverflow how to get previous end of month date in python", "code": "def get_previous_month(self):\n        \"\"\"Returns date range for the previous full month.\"\"\"\n        end = utils.get_month_start() - relativedelta(days=1)\n        end = utils.to_datetime(end)\n        start = utils.get_month_start(end)\n        return start, end", "code_tokens": "def get_previous_month ( self ) : end = utils . get_month_start ( ) - relativedelta ( days = 1 ) end = utils . to_datetime ( end ) start = utils . get_month_start ( end ) return start , end", "docstring_tokens": "Returns date range for the previous full month .", "label": 1}, {"idx": "cosqa-train-8265", "doc": "python calculate hue from rgb", "code": "def _hue(color, **kwargs):\n    \"\"\" Get hue value of HSL color.\n    \"\"\"\n    h = colorsys.rgb_to_hls(*[x / 255.0 for x in color.value[:3]])[0]\n    return NumberValue(h * 360.0)", "code_tokens": "def _hue ( color , * * kwargs ) : h = colorsys . rgb_to_hls ( * [ x / 255.0 for x in color . value [ : 3 ] ] ) [ 0 ] return NumberValue ( h * 360.0 )", "docstring_tokens": "Get hue value of HSL color .", "label": 0}, {"idx": "cosqa-train-8266", "doc": "standard deviation of numeric columns python", "code": "def weighted_std(values, weights):\n    \"\"\" Calculate standard deviation weighted by errors \"\"\"\n    average = np.average(values, weights=weights)\n    variance = np.average((values-average)**2, weights=weights)\n    return np.sqrt(variance)", "code_tokens": "def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )", "docstring_tokens": "Calculate standard deviation weighted by errors", "label": 0}, {"idx": "cosqa-train-8267", "doc": "python calculate time complexity", "code": "def estimate_complexity(self, x,y,z,n):\n        \"\"\" \n        calculates a rough guess of runtime based on product of parameters \n        \"\"\"\n        num_calculations = x * y * z * n\n        run_time = num_calculations / 100000  # a 2014 PC does about 100k calcs in a second (guess based on prior logs)\n        return self.show_time_as_short_string(run_time)", "code_tokens": "def estimate_complexity ( self , x , y , z , n ) : num_calculations = x * y * z * n run_time = num_calculations / 100000 # a 2014 PC does about 100k calcs in a second (guess based on prior logs) return self . show_time_as_short_string ( run_time )", "docstring_tokens": "calculates a rough guess of runtime based on product of parameters", "label": 1}, {"idx": "cosqa-train-8268", "doc": "staticmethod object is not callable python", "code": "def _update_staticmethod(self, oldsm, newsm):\n        \"\"\"Update a staticmethod update.\"\"\"\n        # While we can't modify the staticmethod object itself (it has no\n        # mutable attributes), we *can* extract the underlying function\n        # (by calling __get__(), which returns it) and update it in-place.\n        # We don't have the class available to pass to __get__() but any\n        # object except None will do.\n        self._update(None, None, oldsm.__get__(0), newsm.__get__(0))", "code_tokens": "def _update_staticmethod ( self , oldsm , newsm ) : # While we can't modify the staticmethod object itself (it has no # mutable attributes), we *can* extract the underlying function # (by calling __get__(), which returns it) and update it in-place. # We don't have the class available to pass to __get__() but any # object except None will do. self . _update ( None , None , oldsm . __get__ ( 0 ) , newsm . __get__ ( 0 ) )", "docstring_tokens": "Update a staticmethod update .", "label": 0}, {"idx": "cosqa-train-8269", "doc": "python call coroutine manually", "code": "def submit(self, fn, *args, **kwargs):\n        \"\"\"Submit an operation\"\"\"\n        corofn = asyncio.coroutine(lambda: fn(*args, **kwargs))\n        return run_coroutine_threadsafe(corofn(), self.loop)", "code_tokens": "def submit ( self , fn , * args , * * kwargs ) : corofn = asyncio . coroutine ( lambda : fn ( * args , * * kwargs ) ) return run_coroutine_threadsafe ( corofn ( ) , self . loop )", "docstring_tokens": "Submit an operation", "label": 0}, {"idx": "cosqa-train-8270", "doc": "stop watch current time python", "code": "def stop(self):\n\t\t\"\"\" Stops the video stream and resets the clock. \"\"\"\n\n\t\tlogger.debug(\"Stopping playback\")\n\t\t# Stop the clock\n\t\tself.clock.stop()\n\t\t# Set plauyer status to ready\n\t\tself.status = READY", "code_tokens": "def stop ( self ) : logger . debug ( \"Stopping playback\" ) # Stop the clock self . clock . stop ( ) # Set plauyer status to ready self . status = READY", "docstring_tokens": "Stops the video stream and resets the clock .", "label": 0}, {"idx": "cosqa-train-8271", "doc": "python calling async code from asynchronous function", "code": "async def _thread_coro(self, *args):\n        \"\"\" Coroutine called by MapAsync. It's wrapping the call of\n        run_in_executor to run the synchronous function as thread \"\"\"\n        return await self._loop.run_in_executor(\n            self._executor, self._function, *args)", "code_tokens": "async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "docstring_tokens": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread", "label": 0}, {"idx": "cosqa-train-8272", "doc": "store credentials in python script", "code": "def get_login_credentials(args):\n  \"\"\"\n    Gets the login credentials from the user, if not specified while invoking\n    the script.\n    @param args: arguments provided to the script.\n    \"\"\"\n  if not args.username:\n    args.username = raw_input(\"Enter Username: \")\n  if not args.password:\n    args.password = getpass.getpass(\"Enter Password: \")", "code_tokens": "def get_login_credentials ( args ) : if not args . username : args . username = raw_input ( \"Enter Username: \" ) if not args . password : args . password = getpass . getpass ( \"Enter Password: \" )", "docstring_tokens": "Gets the login credentials from the user if not specified while invoking the script .", "label": 1}, {"idx": "cosqa-train-8273", "doc": "python can i exit from function", "code": "def fail(message=None, exit_status=None):\n    \"\"\"Prints the specified message and exits the program with the specified\n    exit status.\n\n    \"\"\"\n    print('Error:', message, file=sys.stderr)\n    sys.exit(exit_status or 1)", "code_tokens": "def fail ( message = None , exit_status = None ) : print ( 'Error:' , message , file = sys . stderr ) sys . exit ( exit_status or 1 )", "docstring_tokens": "Prints the specified message and exits the program with the specified exit status .", "label": 0}, {"idx": "cosqa-train-8274", "doc": "store ndarray in json format python", "code": "def deserialize_ndarray_npy(d):\n    \"\"\"\n    Deserializes a JSONified :obj:`numpy.ndarray` that was created using numpy's\n    :obj:`save` function.\n\n    Args:\n        d (:obj:`dict`): A dictionary representation of an :obj:`ndarray` object, created\n            using :obj:`numpy.save`.\n\n    Returns:\n        An :obj:`ndarray` object.\n    \"\"\"\n    with io.BytesIO() as f:\n        f.write(json.loads(d['npy']).encode('latin-1'))\n        f.seek(0)\n        return np.load(f)", "code_tokens": "def deserialize_ndarray_npy ( d ) : with io . BytesIO ( ) as f : f . write ( json . loads ( d [ 'npy' ] ) . encode ( 'latin-1' ) ) f . seek ( 0 ) return np . load ( f )", "docstring_tokens": "Deserializes a JSONified : obj : numpy . ndarray that was created using numpy s : obj : save function .", "label": 0}, {"idx": "cosqa-train-8275", "doc": "python capitalize every word except of", "code": "def mixedcase(path):\n    \"\"\"Removes underscores and capitalizes the neighbouring character\"\"\"\n    words = path.split('_')\n    return words[0] + ''.join(word.title() for word in words[1:])", "code_tokens": "def mixedcase ( path ) : words = path . split ( '_' ) return words [ 0 ] + '' . join ( word . title ( ) for word in words [ 1 : ] )", "docstring_tokens": "Removes underscores and capitalizes the neighbouring character", "label": 0}, {"idx": "cosqa-train-8276", "doc": "stream python function output to external", "code": "def getFunction(self):\n        \"\"\"Called by remote workers. Useful to populate main module globals()\n        for interactive shells. Retrieves the serialized function.\"\"\"\n        return functionFactory(\n            self.code,\n            self.name,\n            self.defaults,\n            self.globals,\n            self.imports,\n        )", "code_tokens": "def getFunction ( self ) : return functionFactory ( self . code , self . name , self . defaults , self . globals , self . imports , )", "docstring_tokens": "Called by remote workers . Useful to populate main module globals () for interactive shells . Retrieves the serialized function .", "label": 0}, {"idx": "cosqa-train-8277", "doc": "python capture file name with suffix", "code": "def add_suffix(fullname, suffix):\n    \"\"\" Add suffix to a full file name\"\"\"\n    name, ext = os.path.splitext(fullname)\n    return name + '_' + suffix + ext", "code_tokens": "def add_suffix ( fullname , suffix ) : name , ext = os . path . splitext ( fullname ) return name + '_' + suffix + ext", "docstring_tokens": "Add suffix to a full file name", "label": 1}, {"idx": "cosqa-train-8278", "doc": "string append boolean python", "code": "def _encode_bool(name, value, dummy0, dummy1):\n    \"\"\"Encode a python boolean (True/False).\"\"\"\n    return b\"\\x08\" + name + (value and b\"\\x01\" or b\"\\x00\")", "code_tokens": "def _encode_bool ( name , value , dummy0 , dummy1 ) : return b\"\\x08\" + name + ( value and b\"\\x01\" or b\"\\x00\" )", "docstring_tokens": "Encode a python boolean ( True / False ) .", "label": 1}, {"idx": "cosqa-train-8279", "doc": "python cartesian meshgrid to polar coordinate", "code": "def angle_to_cartesian(lon, lat):\n    \"\"\"Convert spherical coordinates to cartesian unit vectors.\"\"\"\n    theta = np.array(np.pi / 2. - lat)\n    return np.vstack((np.sin(theta) * np.cos(lon),\n                      np.sin(theta) * np.sin(lon),\n                      np.cos(theta))).T", "code_tokens": "def angle_to_cartesian ( lon , lat ) : theta = np . array ( np . pi / 2. - lat ) return np . vstack ( ( np . sin ( theta ) * np . cos ( lon ) , np . sin ( theta ) * np . sin ( lon ) , np . cos ( theta ) ) ) . T", "docstring_tokens": "Convert spherical coordinates to cartesian unit vectors .", "label": 0}, {"idx": "cosqa-train-8280", "doc": "string categorical to one hot python", "code": "def one_hot2string(arr, vocab):\n    \"\"\"Convert a one-hot encoded array back to string\n    \"\"\"\n    tokens = one_hot2token(arr)\n    indexToLetter = _get_index_dict(vocab)\n\n    return [''.join([indexToLetter[x] for x in row]) for row in tokens]", "code_tokens": "def one_hot2string ( arr , vocab ) : tokens = one_hot2token ( arr ) indexToLetter = _get_index_dict ( vocab ) return [ '' . join ( [ indexToLetter [ x ] for x in row ] ) for row in tokens ]", "docstring_tokens": "Convert a one - hot encoded array back to string", "label": 0}, {"idx": "cosqa-train-8281", "doc": "python cartesian product of lists", "code": "def cartesian_product(arrays, flat=True, copy=False):\n    \"\"\"\n    Efficient cartesian product of a list of 1D arrays returning the\n    expanded array views for each dimensions. By default arrays are\n    flattened, which may be controlled with the flat flag. The array\n    views can be turned into regular arrays with the copy flag.\n    \"\"\"\n    arrays = np.broadcast_arrays(*np.ix_(*arrays))\n    if flat:\n        return tuple(arr.flatten() if copy else arr.flat for arr in arrays)\n    return tuple(arr.copy() if copy else arr for arr in arrays)", "code_tokens": "def cartesian_product ( arrays , flat = True , copy = False ) : arrays = np . broadcast_arrays ( * np . ix_ ( * arrays ) ) if flat : return tuple ( arr . flatten ( ) if copy else arr . flat for arr in arrays ) return tuple ( arr . copy ( ) if copy else arr for arr in arrays )", "docstring_tokens": "Efficient cartesian product of a list of 1D arrays returning the expanded array views for each dimensions . By default arrays are flattened which may be controlled with the flat flag . The array views can be turned into regular arrays with the copy flag .", "label": 1}, {"idx": "cosqa-train-8282", "doc": "string extract title titanic python", "code": "def get_title(soup):\n  \"\"\"Given a soup, pick out a title\"\"\"\n  if soup.title:\n    return soup.title.string\n  if soup.h1:\n    return soup.h1.string\n  return ''", "code_tokens": "def get_title ( soup ) : if soup . title : return soup . title . string if soup . h1 : return soup . h1 . string return ''", "docstring_tokens": "Given a soup pick out a title", "label": 1}, {"idx": "cosqa-train-8283", "doc": "python cartesian to polar transformation", "code": "def cart2pol(x, y):\n    \"\"\"Cartesian to Polar coordinates conversion.\"\"\"\n    theta = np.arctan2(y, x)\n    rho = np.hypot(x, y)\n    return theta, rho", "code_tokens": "def cart2pol ( x , y ) : theta = np . arctan2 ( y , x ) rho = np . hypot ( x , y ) return theta , rho", "docstring_tokens": "Cartesian to Polar coordinates conversion .", "label": 0}, {"idx": "cosqa-train-8284", "doc": "string must be number try in python", "code": "def covstr(s):\n  \"\"\" convert string to int or float. \"\"\"\n  try:\n    ret = int(s)\n  except ValueError:\n    ret = float(s)\n  return ret", "code_tokens": "def covstr ( s ) : try : ret = int ( s ) except ValueError : ret = float ( s ) return ret", "docstring_tokens": "convert string to int or float .", "label": 1}, {"idx": "cosqa-train-8285", "doc": "python cartopy latitude longitude", "code": "def get_lons_from_cartesian(x__, y__):\n    \"\"\"Get longitudes from cartesian coordinates.\n    \"\"\"\n    return rad2deg(arccos(x__ / sqrt(x__ ** 2 + y__ ** 2))) * sign(y__)", "code_tokens": "def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )", "docstring_tokens": "Get longitudes from cartesian coordinates .", "label": 1}, {"idx": "cosqa-train-8286", "doc": "string remove white spaces python", "code": "def text_cleanup(data, key, last_type):\n    \"\"\" I strip extra whitespace off multi-line strings if they are ready to be stripped!\"\"\"\n    if key in data and last_type == STRING_TYPE:\n        data[key] = data[key].strip()\n    return data", "code_tokens": "def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data", "docstring_tokens": "I strip extra whitespace off multi - line strings if they are ready to be stripped!", "label": 1}, {"idx": "cosqa-train-8287", "doc": "python cdll load dll windows", "code": "def load(self, name):\n        \"\"\"Loads and returns foreign library.\"\"\"\n        name = ctypes.util.find_library(name)\n        return ctypes.cdll.LoadLibrary(name)", "code_tokens": "def load ( self , name ) : name = ctypes . util . find_library ( name ) return ctypes . cdll . LoadLibrary ( name )", "docstring_tokens": "Loads and returns foreign library .", "label": 1}, {"idx": "cosqa-train-8288", "doc": "string to bytes in python3", "code": "def to_bytes(s, encoding=\"utf-8\"):\n    \"\"\"Convert a string to bytes.\"\"\"\n    if isinstance(s, six.binary_type):\n        return s\n    if six.PY3:\n        return bytes(s, encoding)\n    return s.encode(encoding)", "code_tokens": "def to_bytes ( s , encoding = \"utf-8\" ) : if isinstance ( s , six . binary_type ) : return s if six . PY3 : return bytes ( s , encoding ) return s . encode ( encoding )", "docstring_tokens": "Convert a string to bytes .", "label": 0}, {"idx": "cosqa-train-8289", "doc": "python chang size of image resampling resolution", "code": "def pad_image(arr, max_size=400):\n    \"\"\"Pads an image to a square then resamples to max_size\"\"\"\n    dim = np.max(arr.shape)\n    img = np.zeros((dim, dim, 3), dtype=arr.dtype)\n    xl = (dim - arr.shape[0]) // 2\n    yl = (dim - arr.shape[1]) // 2\n    img[xl:arr.shape[0]+xl, yl:arr.shape[1]+yl, :] = arr\n    return resample_image(img, max_size=max_size)", "code_tokens": "def pad_image ( arr , max_size = 400 ) : dim = np . max ( arr . shape ) img = np . zeros ( ( dim , dim , 3 ) , dtype = arr . dtype ) xl = ( dim - arr . shape [ 0 ] ) // 2 yl = ( dim - arr . shape [ 1 ] ) // 2 img [ xl : arr . shape [ 0 ] + xl , yl : arr . shape [ 1 ] + yl , : ] = arr return resample_image ( img , max_size = max_size )", "docstring_tokens": "Pads an image to a square then resamples to max_size", "label": 1}, {"idx": "cosqa-train-8290", "doc": "string to datetime python pd", "code": "def _parse(self, date_str, format='%Y-%m-%d'):\n        \"\"\"\n        helper function for parsing FRED date string into datetime\n        \"\"\"\n        rv = pd.to_datetime(date_str, format=format)\n        if hasattr(rv, 'to_pydatetime'):\n            rv = rv.to_pydatetime()\n        return rv", "code_tokens": "def _parse ( self , date_str , format = '%Y-%m-%d' ) : rv = pd . to_datetime ( date_str , format = format ) if hasattr ( rv , 'to_pydatetime' ) : rv = rv . to_pydatetime ( ) return rv", "docstring_tokens": "helper function for parsing FRED date string into datetime", "label": 0}, {"idx": "cosqa-train-8291", "doc": "python change date into string", "code": "def QA_util_datetime_to_strdate(dt):\n    \"\"\"\n    :param dt:  pythone datetime.datetime\n    :return:  1999-02-01 string type\n    \"\"\"\n    strdate = \"%04d-%02d-%02d\" % (dt.year, dt.month, dt.day)\n    return strdate", "code_tokens": "def QA_util_datetime_to_strdate ( dt ) : strdate = \"%04d-%02d-%02d\" % ( dt . year , dt . month , dt . day ) return strdate", "docstring_tokens": ": param dt : pythone datetime . datetime : return : 1999 - 02 - 01 string type", "label": 1}, {"idx": "cosqa-train-8292", "doc": "strip dangerous tags python beautifulsoup", "code": "def do_striptags(value):\n    \"\"\"Strip SGML/XML tags and replace adjacent whitespace by one space.\n    \"\"\"\n    if hasattr(value, '__html__'):\n        value = value.__html__()\n    return Markup(unicode(value)).striptags()", "code_tokens": "def do_striptags ( value ) : if hasattr ( value , '__html__' ) : value = value . __html__ ( ) return Markup ( unicode ( value ) ) . striptags ( )", "docstring_tokens": "Strip SGML / XML tags and replace adjacent whitespace by one space .", "label": 0}, {"idx": "cosqa-train-8293", "doc": "python change format for date string", "code": "def inc_date(date_obj, num, date_fmt):\n    \"\"\"Increment the date by a certain number and return date object.\n    as the specific string format.\n    \"\"\"\n    return (date_obj + timedelta(days=num)).strftime(date_fmt)", "code_tokens": "def inc_date ( date_obj , num , date_fmt ) : return ( date_obj + timedelta ( days = num ) ) . strftime ( date_fmt )", "docstring_tokens": "Increment the date by a certain number and return date object . as the specific string format .", "label": 0}, {"idx": "cosqa-train-8294", "doc": "strip whitespace python without line breaks", "code": "def text_remove_empty_lines(text):\n    \"\"\"\n    Whitespace normalization:\n\n      - Strip empty lines\n      - Strip trailing whitespace\n    \"\"\"\n    lines = [ line.rstrip()  for line in text.splitlines()  if line.strip() ]\n    return \"\\n\".join(lines)", "code_tokens": "def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return \"\\n\" . join ( lines )", "docstring_tokens": "Whitespace normalization :", "label": 0}, {"idx": "cosqa-train-8295", "doc": "python change from camel case to snake case", "code": "def convert_camel_case_to_snake_case(name):\n    \"\"\"Convert CamelCase to snake_case.\"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def convert_camel_case_to_snake_case ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert CamelCase to snake_case .", "label": 1}, {"idx": "cosqa-train-8296", "doc": "strptime python timezone aware", "code": "def _strptime(self, time_str):\n        \"\"\"Convert an ISO 8601 formatted string in UTC into a\n        timezone-aware datetime object.\"\"\"\n        if time_str:\n            # Parse UTC string into naive datetime, then add timezone\n            dt = datetime.strptime(time_str, __timeformat__)\n            return dt.replace(tzinfo=UTC())\n        return None", "code_tokens": "def _strptime ( self , time_str ) : if time_str : # Parse UTC string into naive datetime, then add timezone dt = datetime . strptime ( time_str , __timeformat__ ) return dt . replace ( tzinfo = UTC ( ) ) return None", "docstring_tokens": "Convert an ISO 8601 formatted string in UTC into a timezone - aware datetime object .", "label": 1}, {"idx": "cosqa-train-8297", "doc": "python change int to iteratable", "code": "def is_iterable_of_int(l):\n    r\"\"\" Checks if l is iterable and contains only integral types \"\"\"\n    if not is_iterable(l):\n        return False\n\n    return all(is_int(value) for value in l)", "code_tokens": "def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )", "docstring_tokens": "r Checks if l is iterable and contains only integral types", "label": 1}, {"idx": "cosqa-train-8298", "doc": "supress python logging prints", "code": "def pylog(self, *args, **kwargs):\n        \"\"\"Display all available logging information.\"\"\"\n        printerr(self.name, args, kwargs, traceback.format_exc())", "code_tokens": "def pylog ( self , * args , * * kwargs ) : printerr ( self . name , args , kwargs , traceback . format_exc ( ) )", "docstring_tokens": "Display all available logging information .", "label": 1}, {"idx": "cosqa-train-8299", "doc": "python change mtime of a file", "code": "def set_time(filename, mod_time):\n\t\"\"\"\n\tSet the modified time of a file\n\t\"\"\"\n\tlog.debug('Setting modified time to %s', mod_time)\n\tmtime = calendar.timegm(mod_time.utctimetuple())\n\t# utctimetuple discards microseconds, so restore it (for consistency)\n\tmtime += mod_time.microsecond / 1000000\n\tatime = os.stat(filename).st_atime\n\tos.utime(filename, (atime, mtime))", "code_tokens": "def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)\n mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )", "docstring_tokens": "Set the modified time of a file", "label": 1}, {"idx": "cosqa-train-8300", "doc": "svd matrix completion python", "code": "def _svd(cls, matrix, num_concepts=5):\n        \"\"\"\n        Perform singular value decomposition for dimensionality reduction of the input matrix.\n        \"\"\"\n        u, s, v = svds(matrix, k=num_concepts)\n        return u, s, v", "code_tokens": "def _svd ( cls , matrix , num_concepts = 5 ) : u , s , v = svds ( matrix , k = num_concepts ) return u , s , v", "docstring_tokens": "Perform singular value decomposition for dimensionality reduction of the input matrix .", "label": 1}, {"idx": "cosqa-train-8301", "doc": "python change object from read only to write", "code": "def writer_acquire(self):\n        \"\"\"Acquire the lock to write\"\"\"\n\n        self._order_mutex.acquire()\n        self._access_mutex.acquire()\n        self._order_mutex.release()", "code_tokens": "def writer_acquire ( self ) : self . _order_mutex . acquire ( ) self . _access_mutex . acquire ( ) self . _order_mutex . release ( )", "docstring_tokens": "Acquire the lock to write", "label": 0}, {"idx": "cosqa-train-8302", "doc": "sys stdout write encode in python 2", "code": "def imp_print(self, text, end):\n\t\t\"\"\"Directly send utf8 bytes to stdout\"\"\"\n\t\tsys.stdout.write((text + end).encode(\"utf-8\"))", "code_tokens": "def imp_print ( self , text , end ) : sys . stdout . write ( ( text + end ) . encode ( \"utf-8\" ) )", "docstring_tokens": "Directly send utf8 bytes to stdout", "label": 1}, {"idx": "cosqa-train-8303", "doc": "python change permissions linux", "code": "def set_executable(filename):\n    \"\"\"Set the exectuable bit on the given filename\"\"\"\n    st = os.stat(filename)\n    os.chmod(filename, st.st_mode | stat.S_IEXEC)", "code_tokens": "def set_executable ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "docstring_tokens": "Set the exectuable bit on the given filename", "label": 1}, {"idx": "cosqa-train-8304", "doc": "table read from h5py python", "code": "def h5ToDict(h5, readH5pyDataset=True):\n    \"\"\" Read a hdf5 file into a dictionary \"\"\"\n    h = h5py.File(h5, \"r\")\n    ret = unwrapArray(h, recursive=True, readH5pyDataset=readH5pyDataset)\n    if readH5pyDataset: h.close()\n    return ret", "code_tokens": "def h5ToDict ( h5 , readH5pyDataset = True ) : h = h5py . File ( h5 , \"r\" ) ret = unwrapArray ( h , recursive = True , readH5pyDataset = readH5pyDataset ) if readH5pyDataset : h . close ( ) return ret", "docstring_tokens": "Read a hdf5 file into a dictionary", "label": 1}, {"idx": "cosqa-train-8305", "doc": "python change timezone of datetime", "code": "def datetime_to_timezone(date, tz=\"UTC\"):\n    \"\"\" convert naive datetime to timezone-aware datetime \"\"\"\n    if not date.tzinfo:\n        date = date.replace(tzinfo=timezone(get_timezone()))\n    return date.astimezone(timezone(tz))", "code_tokens": "def datetime_to_timezone ( date , tz = \"UTC\" ) : if not date . tzinfo : date = date . replace ( tzinfo = timezone ( get_timezone ( ) ) ) return date . astimezone ( timezone ( tz ) )", "docstring_tokens": "convert naive datetime to timezone - aware datetime", "label": 0}, {"idx": "cosqa-train-8306", "doc": "tablewidget cell width python", "code": "def get_table_width(table):\n    \"\"\"\n    Gets the width of the table that would be printed.\n    :rtype: ``int``\n    \"\"\"\n    columns = transpose_table(prepare_rows(table))\n    widths = [max(len(cell) for cell in column) for column in columns]\n    return len('+' + '|'.join('-' * (w + 2) for w in widths) + '+')", "code_tokens": "def get_table_width ( table ) : columns = transpose_table ( prepare_rows ( table ) ) widths = [ max ( len ( cell ) for cell in column ) for column in columns ] return len ( '+' + '|' . join ( '-' * ( w + 2 ) for w in widths ) + '+' )", "docstring_tokens": "Gets the width of the table that would be printed . : rtype : int", "label": 1}, {"idx": "cosqa-train-8307", "doc": "python check a file is image", "code": "def is_image_file_valid(file_path_name):\n    \"\"\"\n    Indicate whether the specified image file is valid or not.\n\n\n    @param file_path_name: absolute path and file name of an image.\n\n\n    @return: ``True`` if the image file is valid, ``False`` if the file is\n        truncated or does not correspond to a supported image.\n    \"\"\"\n    # Image.verify is only implemented for PNG images, and it only verifies\n    # the CRC checksum in the image.  The only way to check from within\n    # Pillow is to load the image in a try/except and check the error.  If\n    # as much info as possible is from the image is needed,\n    # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it\n    # will attempt to parse as much as possible.\n    try:\n        with Image.open(file_path_name) as image:\n            image.load()\n    except IOError:\n        return False\n\n    return True", "code_tokens": "def is_image_file_valid ( file_path_name ) : # Image.verify is only implemented for PNG images, and it only verifies # the CRC checksum in the image.  The only way to check from within # Pillow is to load the image in a try/except and check the error.  If # as much info as possible is from the image is needed, # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it # will attempt to parse as much as possible. try : with Image . open ( file_path_name ) as image : image . load ( ) except IOError : return False return True", "docstring_tokens": "Indicate whether the specified image file is valid or not .", "label": 0}, {"idx": "cosqa-train-8308", "doc": "taking boolean values in python", "code": "def strToBool(val):\n    \"\"\"\n    Helper function to turn a string representation of \"true\" into\n    boolean True.\n    \"\"\"\n    if isinstance(val, str):\n        val = val.lower()\n\n    return val in ['true', 'on', 'yes', True]", "code_tokens": "def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]", "docstring_tokens": "Helper function to turn a string representation of true into boolean True .", "label": 0}, {"idx": "cosqa-train-8309", "doc": "python check df index type", "code": "def _validate_pos(df):\n    \"\"\"Validates the returned positional object\n    \"\"\"\n    assert isinstance(df, pd.DataFrame)\n    assert [\"seqname\", \"position\", \"strand\"] == df.columns.tolist()\n    assert df.position.dtype == np.dtype(\"int64\")\n    assert df.strand.dtype == np.dtype(\"O\")\n    assert df.seqname.dtype == np.dtype(\"O\")\n    return df", "code_tokens": "def _validate_pos ( df ) : assert isinstance ( df , pd . DataFrame ) assert [ \"seqname\" , \"position\" , \"strand\" ] == df . columns . tolist ( ) assert df . position . dtype == np . dtype ( \"int64\" ) assert df . strand . dtype == np . dtype ( \"O\" ) assert df . seqname . dtype == np . dtype ( \"O\" ) return df", "docstring_tokens": "Validates the returned positional object", "label": 1}, {"idx": "cosqa-train-8310", "doc": "tell python to go to line", "code": "def go_to_line(self, line):\n        \"\"\"\n        Moves the text cursor to given line.\n\n        :param line: Line to go to.\n        :type line: int\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        cursor = self.textCursor()\n        cursor.setPosition(self.document().findBlockByNumber(line - 1).position())\n        self.setTextCursor(cursor)\n        return True", "code_tokens": "def go_to_line ( self , line ) : cursor = self . textCursor ( ) cursor . setPosition ( self . document ( ) . findBlockByNumber ( line - 1 ) . position ( ) ) self . setTextCursor ( cursor ) return True", "docstring_tokens": "Moves the text cursor to given line .", "label": 1}, {"idx": "cosqa-train-8311", "doc": "python check dict key type", "code": "def _check_key(self, key):\n        \"\"\"\n        Ensures well-formedness of a key.\n        \"\"\"\n        if not len(key) == 2:\n            raise TypeError('invalid key: %r' % key)\n        elif key[1] not in TYPES:\n            raise TypeError('invalid datatype: %s' % key[1])", "code_tokens": "def _check_key ( self , key ) : if not len ( key ) == 2 : raise TypeError ( 'invalid key: %r' % key ) elif key [ 1 ] not in TYPES : raise TypeError ( 'invalid datatype: %s' % key [ 1 ] )", "docstring_tokens": "Ensures well - formedness of a key .", "label": 1}, {"idx": "cosqa-train-8312", "doc": "tell python to treat decimals as floating decimal points", "code": "def get_decimal_quantum(precision):\n    \"\"\"Return minimal quantum of a number, as defined by precision.\"\"\"\n    assert isinstance(precision, (int, decimal.Decimal))\n    return decimal.Decimal(10) ** (-precision)", "code_tokens": "def get_decimal_quantum ( precision ) : assert isinstance ( precision , ( int , decimal . Decimal ) ) return decimal . Decimal ( 10 ) ** ( - precision )", "docstring_tokens": "Return minimal quantum of a number as defined by precision .", "label": 1}, {"idx": "cosqa-train-8313", "doc": "python check element attributes", "code": "def required_attributes(element, *attributes):\n    \"\"\"Check element for required attributes. Raise ``NotValidXmlException`` on error.\n\n    :param element: ElementTree element\n    :param attributes: list of attributes names to check\n    :raises NotValidXmlException: if some argument is missing\n    \"\"\"\n    if not reduce(lambda still_valid, param: still_valid and param in element.attrib, attributes, True):\n        raise NotValidXmlException(msg_err_missing_attributes(element.tag, *attributes))", "code_tokens": "def required_attributes ( element , * attributes ) : if not reduce ( lambda still_valid , param : still_valid and param in element . attrib , attributes , True ) : raise NotValidXmlException ( msg_err_missing_attributes ( element . tag , * attributes ) )", "docstring_tokens": "Check element for required attributes . Raise NotValidXmlException on error .", "label": 1}, {"idx": "cosqa-train-8314", "doc": "tensorflow for python 2 and python 3", "code": "def tf2():\n  \"\"\"Provide the root module of a TF-2.0 API for use within TensorBoard.\n\n  Returns:\n    The root module of a TF-2.0 API, if available.\n\n  Raises:\n    ImportError: if a TF-2.0 API is not available.\n  \"\"\"\n  # Import the `tf` compat API from this file and check if it's already TF 2.0.\n  if tf.__version__.startswith('2.'):\n    return tf\n  elif hasattr(tf, 'compat') and hasattr(tf.compat, 'v2'):\n    # As a fallback, try `tensorflow.compat.v2` if it's defined.\n    return tf.compat.v2\n  raise ImportError('cannot import tensorflow 2.0 API')", "code_tokens": "def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )", "docstring_tokens": "Provide the root module of a TF - 2 . 0 API for use within TensorBoard .", "label": 1}, {"idx": "cosqa-train-8315", "doc": "python check element type in array", "code": "def _valid_other_type(x, types):\n    \"\"\"\n    Do all elements of x have a type from types?\n    \"\"\"\n    return all(any(isinstance(el, t) for t in types) for el in np.ravel(x))", "code_tokens": "def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )", "docstring_tokens": "Do all elements of x have a type from types?", "label": 1}, {"idx": "cosqa-train-8316", "doc": "tensorflow python gpu slow", "code": "def afx_small():\n  \"\"\"Small transformer model with small batch size for fast step times.\"\"\"\n  hparams = transformer.transformer_tpu()\n  hparams.filter_size = 1024\n  hparams.num_heads = 4\n  hparams.num_hidden_layers = 3\n  hparams.batch_size = 512\n  return hparams", "code_tokens": "def afx_small ( ) : hparams = transformer . transformer_tpu ( ) hparams . filter_size = 1024 hparams . num_heads = 4 hparams . num_hidden_layers = 3 hparams . batch_size = 512 return hparams", "docstring_tokens": "Small transformer model with small batch size for fast step times .", "label": 0}, {"idx": "cosqa-train-8317", "doc": "python check existance of config", "code": "def _is_already_configured(configuration_details):\n    \"\"\"Returns `True` when alias already in shell config.\"\"\"\n    path = Path(configuration_details.path).expanduser()\n    with path.open('r') as shell_config:\n        return configuration_details.content in shell_config.read()", "code_tokens": "def _is_already_configured ( configuration_details ) : path = Path ( configuration_details . path ) . expanduser ( ) with path . open ( 'r' ) as shell_config : return configuration_details . content in shell_config . read ( )", "docstring_tokens": "Returns True when alias already in shell config .", "label": 1}, {"idx": "cosqa-train-8318", "doc": "tensorflow python not found", "code": "def tf2():\n  \"\"\"Provide the root module of a TF-2.0 API for use within TensorBoard.\n\n  Returns:\n    The root module of a TF-2.0 API, if available.\n\n  Raises:\n    ImportError: if a TF-2.0 API is not available.\n  \"\"\"\n  # Import the `tf` compat API from this file and check if it's already TF 2.0.\n  if tf.__version__.startswith('2.'):\n    return tf\n  elif hasattr(tf, 'compat') and hasattr(tf.compat, 'v2'):\n    # As a fallback, try `tensorflow.compat.v2` if it's defined.\n    return tf.compat.v2\n  raise ImportError('cannot import tensorflow 2.0 API')", "code_tokens": "def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )", "docstring_tokens": "Provide the root module of a TF - 2 . 0 API for use within TensorBoard .", "label": 1}, {"idx": "cosqa-train-8319", "doc": "python check file exists with try and write in same file", "code": "def _replace_file(path, content):\n  \"\"\"Writes a file if it doesn't already exist with the same content.\n\n  This is useful because cargo uses timestamps to decide whether to compile things.\"\"\"\n  if os.path.exists(path):\n    with open(path, 'r') as f:\n      if content == f.read():\n        print(\"Not overwriting {} because it is unchanged\".format(path), file=sys.stderr)\n        return\n\n  with open(path, 'w') as f:\n    f.write(content)", "code_tokens": "def _replace_file ( path , content ) : if os . path . exists ( path ) : with open ( path , 'r' ) as f : if content == f . read ( ) : print ( \"Not overwriting {} because it is unchanged\" . format ( path ) , file = sys . stderr ) return with open ( path , 'w' ) as f : f . write ( content )", "docstring_tokens": "Writes a file if it doesn t already exist with the same content .", "label": 1}, {"idx": "cosqa-train-8320", "doc": "test if something is an instance method python", "code": "def is_function(self):\n        \"\"\"return True if callback is a vanilla plain jane function\"\"\"\n        if self.is_instance() or self.is_class(): return False\n        return isinstance(self.callback, (Callable, classmethod))", "code_tokens": "def is_function ( self ) : if self . is_instance ( ) or self . is_class ( ) : return False return isinstance ( self . callback , ( Callable , classmethod ) )", "docstring_tokens": "return True if callback is a vanilla plain jane function", "label": 0}, {"idx": "cosqa-train-8321", "doc": "python check for empty float", "code": "def clean_float(v):\n    \"\"\"Remove commas from a float\"\"\"\n\n    if v is None or not str(v).strip():\n        return None\n\n    return float(str(v).replace(',', ''))", "code_tokens": "def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )", "docstring_tokens": "Remove commas from a float", "label": 0}, {"idx": "cosqa-train-8322", "doc": "test if two images are the same python", "code": "def is_same_shape(self, other_im, check_channels=False):\n        \"\"\" Checks if two images have the same height and width (and optionally channels).\n\n        Parameters\n        ----------\n        other_im : :obj:`Image`\n            image to compare\n        check_channels : bool\n            whether or not to check equality of the channels\n\n        Returns\n        -------\n        bool\n            True if the images are the same shape, False otherwise\n        \"\"\"\n        if self.height == other_im.height and self.width == other_im.width:\n            if check_channels and self.channels != other_im.channels:\n                return False\n            return True\n        return False", "code_tokens": "def is_same_shape ( self , other_im , check_channels = False ) : if self . height == other_im . height and self . width == other_im . width : if check_channels and self . channels != other_im . channels : return False return True return False", "docstring_tokens": "Checks if two images have the same height and width ( and optionally channels ) .", "label": 0}, {"idx": "cosqa-train-8323", "doc": "python check for presence of argumetn", "code": "def _is_one_arg_pos_call(call):\n    \"\"\"Is this a call with exactly 1 argument,\n    where that argument is positional?\n    \"\"\"\n    return isinstance(call, astroid.Call) and len(call.args) == 1 and not call.keywords", "code_tokens": "def _is_one_arg_pos_call ( call ) : return isinstance ( call , astroid . Call ) and len ( call . args ) == 1 and not call . keywords", "docstring_tokens": "Is this a call with exactly 1 argument where that argument is positional?", "label": 0}, {"idx": "cosqa-train-8324", "doc": "thread hangs on join even though tasks are finished python3", "code": "def wait_and_join(self, task):\n        \"\"\" Given a task, waits for it until it finishes\n        :param task: Task\n        :return:\n        \"\"\"\n        while not task.has_started:\n            time.sleep(self._polling_time)\n        task.thread.join()", "code_tokens": "def wait_and_join ( self , task ) : while not task . has_started : time . sleep ( self . _polling_time ) task . thread . join ( )", "docstring_tokens": "Given a task waits for it until it finishes : param task : Task : return :", "label": 1}, {"idx": "cosqa-train-8325", "doc": "python check git status for modified files", "code": "def is_changed():\n    \"\"\" Checks if current project has any noncommited changes. \"\"\"\n    executed, changed_lines = execute_git('status --porcelain', output=False)\n    merge_not_finished = mod_path.exists('.git/MERGE_HEAD')\n    return changed_lines.strip() or merge_not_finished", "code_tokens": "def is_changed ( ) : executed , changed_lines = execute_git ( 'status --porcelain' , output = False ) merge_not_finished = mod_path . exists ( '.git/MERGE_HEAD' ) return changed_lines . strip ( ) or merge_not_finished", "docstring_tokens": "Checks if current project has any noncommited changes .", "label": 1}, {"idx": "cosqa-train-8326", "doc": "tkinter python clear canvas", "code": "def clear_timeline(self):\n        \"\"\"\n        Clear the contents of the TimeLine Canvas\n\n        Does not modify the actual markers dictionary and thus after\n        redrawing all markers are visible again.\n        \"\"\"\n        self._timeline.delete(tk.ALL)\n        self._canvas_ticks.delete(tk.ALL)", "code_tokens": "def clear_timeline ( self ) : self . _timeline . delete ( tk . ALL ) self . _canvas_ticks . delete ( tk . ALL )", "docstring_tokens": "Clear the contents of the TimeLine Canvas", "label": 0}, {"idx": "cosqa-train-8327", "doc": "python check if a folder exist , if not create it", "code": "def ensure_dir_exists(directory):\n    \"\"\"Se asegura de que un directorio exista.\"\"\"\n    if directory and not os.path.exists(directory):\n        os.makedirs(directory)", "code_tokens": "def ensure_dir_exists ( directory ) : if directory and not os . path . exists ( directory ) : os . makedirs ( directory )", "docstring_tokens": "Se asegura de que un directorio exista .", "label": 0}, {"idx": "cosqa-train-8328", "doc": "to insert a blank column in a data frame in python", "code": "def add_blank_row(self, label):\n        \"\"\"\n        Add a blank row with only an index value to self.df.\n        This is done inplace.\n        \"\"\"\n        col_labels = self.df.columns\n        blank_item = pd.Series({}, index=col_labels, name=label)\n        # use .loc to add in place (append won't do that)\n        self.df.loc[blank_item.name] = blank_item\n        return self.df", "code_tokens": "def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df", "docstring_tokens": "Add a blank row with only an index value to self . df . This is done inplace .", "label": 1}, {"idx": "cosqa-train-8329", "doc": "python check if a list is null", "code": "def is_nullable_list(val, vtype):\n    \"\"\"Return True if list contains either values of type `vtype` or None.\"\"\"\n    return (isinstance(val, list) and\n            any(isinstance(v, vtype) for v in val) and\n            all((isinstance(v, vtype) or v is None) for v in val))", "code_tokens": "def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )", "docstring_tokens": "Return True if list contains either values of type vtype or None .", "label": 1}, {"idx": "cosqa-train-8330", "doc": "tokenize in python to get sentences", "code": "def listified_tokenizer(source):\n    \"\"\"Tokenizes *source* and returns the tokens as a list of lists.\"\"\"\n    io_obj = io.StringIO(source)\n    return [list(a) for a in tokenize.generate_tokens(io_obj.readline)]", "code_tokens": "def listified_tokenizer ( source ) : io_obj = io . StringIO ( source ) return [ list ( a ) for a in tokenize . generate_tokens ( io_obj . readline ) ]", "docstring_tokens": "Tokenizes * source * and returns the tokens as a list of lists .", "label": 0}, {"idx": "cosqa-train-8331", "doc": "python check if a url is valid", "code": "def url_syntax_check(url):  # pragma: no cover\n    \"\"\"\n    Check the syntax of the given URL.\n\n    :param url: The URL to check the syntax for.\n    :type url: str\n\n    :return: The syntax validity.\n    :rtype: bool\n\n    .. warning::\n        If an empty or a non-string :code:`url` is given, we return :code:`None`.\n    \"\"\"\n\n    if url and isinstance(url, str):\n        # The given URL is not empty nor None.\n        # and\n        # * The given URL is a string.\n\n        # We silently load the configuration.\n        load_config(True)\n\n        return Check(url).is_url_valid()\n\n    # We return None, there is nothing to check.\n    return None", "code_tokens": "def url_syntax_check ( url ) : # pragma: no cover if url and isinstance ( url , str ) : # The given URL is not empty nor None. # and # * The given URL is a string. # We silently load the configuration. load_config ( True ) return Check ( url ) . is_url_valid ( ) # We return None, there is nothing to check. return None", "docstring_tokens": "Check the syntax of the given URL .", "label": 1}, {"idx": "cosqa-train-8332", "doc": "topic distributions of documents python", "code": "def print_ldamodel_topic_words(topic_word_distrib, vocab, n_top=10, row_labels=DEFAULT_TOPIC_NAME_FMT):\n    \"\"\"Print `n_top` values from a LDA model's topic-word distributions.\"\"\"\n    print_ldamodel_distribution(topic_word_distrib, row_labels=row_labels, val_labels=vocab,\n                                top_n=n_top)", "code_tokens": "def print_ldamodel_topic_words ( topic_word_distrib , vocab , n_top = 10 , row_labels = DEFAULT_TOPIC_NAME_FMT ) : print_ldamodel_distribution ( topic_word_distrib , row_labels = row_labels , val_labels = vocab , top_n = n_top )", "docstring_tokens": "Print n_top values from a LDA model s topic - word distributions .", "label": 1}, {"idx": "cosqa-train-8333", "doc": "python check if a variable is iterable", "code": "def is_iterable_but_not_string(obj):\n    \"\"\"\n    Determine whether or not obj is iterable but not a string (eg, a list, set, tuple etc).\n    \"\"\"\n    return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)", "code_tokens": "def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )", "docstring_tokens": "Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) .", "label": 1}, {"idx": "cosqa-train-8334", "doc": "trailing zero for decimals in python", "code": "def drop_trailing_zeros(num):\n    \"\"\"\n    Drops the trailing zeros in a float that is printed.\n    \"\"\"\n    txt = '%f' %(num)\n    txt = txt.rstrip('0')\n    if txt.endswith('.'):\n        txt = txt[:-1]\n    return txt", "code_tokens": "def drop_trailing_zeros ( num ) : txt = '%f' % ( num ) txt = txt . rstrip ( '0' ) if txt . endswith ( '.' ) : txt = txt [ : - 1 ] return txt", "docstring_tokens": "Drops the trailing zeros in a float that is printed .", "label": 0}, {"idx": "cosqa-train-8335", "doc": "python check if all elements of list are same", "code": "def _check_elements_equal(lst):\n    \"\"\"\n    Returns true if all of the elements in the list are equal.\n    \"\"\"\n    assert isinstance(lst, list), \"Input value must be a list.\"\n    return not lst or lst.count(lst[0]) == len(lst)", "code_tokens": "def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , \"Input value must be a list.\" return not lst or lst . count ( lst [ 0 ] ) == len ( lst )", "docstring_tokens": "Returns true if all of the elements in the list are equal .", "label": 0}, {"idx": "cosqa-train-8336", "doc": "transform array to string python", "code": "def bitsToString(arr):\n  \"\"\"Returns a string representing a numpy array of 0's and 1's\"\"\"\n  s = array('c','.'*len(arr))\n  for i in xrange(len(arr)):\n    if arr[i] == 1:\n      s[i]='*'\n  return s", "code_tokens": "def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s", "docstring_tokens": "Returns a string representing a numpy array of 0 s and 1 s", "label": 1}, {"idx": "cosqa-train-8337", "doc": "python check if binary file", "code": "def is_binary(filename):\n    \"\"\" Returns True if the file is binary\n\n    \"\"\"\n    with open(filename, 'rb') as fp:\n        data = fp.read(1024)\n        if not data:\n            return False\n        if b'\\0' in data:\n            return True\n        return False", "code_tokens": "def is_binary ( filename ) : with open ( filename , 'rb' ) as fp : data = fp . read ( 1024 ) if not data : return False if b'\\0' in data : return True return False", "docstring_tokens": "Returns True if the file is binary", "label": 1}, {"idx": "cosqa-train-8338", "doc": "transform to html text python", "code": "def html_to_text(content):\n    \"\"\" Converts html content to plain text \"\"\"\n    text = None\n    h2t = html2text.HTML2Text()\n    h2t.ignore_links = False\n    text = h2t.handle(content)\n    return text", "code_tokens": "def html_to_text ( content ) : text = None h2t = html2text . HTML2Text ( ) h2t . ignore_links = False text = h2t . handle ( content ) return text", "docstring_tokens": "Converts html content to plain text", "label": 0}, {"idx": "cosqa-train-8339", "doc": "python check if byte or str", "code": "def isstring(value):\n    \"\"\"Report whether the given value is a byte or unicode string.\"\"\"\n    classes = (str, bytes) if pyutils.PY3 else basestring  # noqa: F821\n    return isinstance(value, classes)", "code_tokens": "def isstring ( value ) : classes = ( str , bytes ) if pyutils . PY3 else basestring # noqa: F821 return isinstance ( value , classes )", "docstring_tokens": "Report whether the given value is a byte or unicode string .", "label": 1}, {"idx": "cosqa-train-8340", "doc": "transform values of column to log10 in python", "code": "def log_normalize(data):\n    \"\"\"Perform log transform log(x + 1).\n    \n    Parameters\n    ----------\n    data : array_like\n    \n    \"\"\"\n    if sp.issparse(data):\n        data = data.copy()\n        data.data = np.log2(data.data + 1)\n        return data\n\n    return np.log2(data.astype(np.float64) + 1)", "code_tokens": "def log_normalize ( data ) : if sp . issparse ( data ) : data = data . copy ( ) data . data = np . log2 ( data . data + 1 ) return data return np . log2 ( data . astype ( np . float64 ) + 1 )", "docstring_tokens": "Perform log transform log ( x + 1 ) . Parameters ---------- data : array_like", "label": 1}, {"idx": "cosqa-train-8341", "doc": "python check if collection", "code": "def is_collection(obj):\n    \"\"\"Tests if an object is a collection.\"\"\"\n\n    col = getattr(obj, '__getitem__', False)\n    val = False if (not col) else True\n\n    if isinstance(obj, basestring):\n        val = False\n\n    return val", "code_tokens": "def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val", "docstring_tokens": "Tests if an object is a collection .", "label": 0}, {"idx": "cosqa-train-8342", "doc": "translate python 2 to 3", "code": "def command_py2to3(args):\n    \"\"\"\n    Apply '2to3' tool (Python2 to Python3 conversion tool) to Python sources.\n    \"\"\"\n    from lib2to3.main import main\n    sys.exit(main(\"lib2to3.fixes\", args=args.sources))", "code_tokens": "def command_py2to3 ( args ) : from lib2to3 . main import main sys . exit ( main ( \"lib2to3.fixes\" , args = args . sources ) )", "docstring_tokens": "Apply 2to3 tool ( Python2 to Python3 conversion tool ) to Python sources .", "label": 1}, {"idx": "cosqa-train-8343", "doc": "python check if function is string", "code": "def str_check(*args, func=None):\n    \"\"\"Check if arguments are str type.\"\"\"\n    func = func or inspect.stack()[2][3]\n    for var in args:\n        if not isinstance(var, (str, collections.UserString, collections.abc.Sequence)):\n            name = type(var).__name__\n            raise StringError(\n                f'Function {func} expected str, {name} got instead.')", "code_tokens": "def str_check ( * args , func = None ) : func = func or inspect . stack ( ) [ 2 ] [ 3 ] for var in args : if not isinstance ( var , ( str , collections . UserString , collections . abc . Sequence ) ) : name = type ( var ) . __name__ raise StringError ( f'Function {func} expected str, {name} got instead.' )", "docstring_tokens": "Check if arguments are str type .", "label": 1}, {"idx": "cosqa-train-8344", "doc": "traversal in tree in python", "code": "def walk_tree(root):\n    \"\"\"Pre-order depth-first\"\"\"\n    yield root\n\n    for child in root.children:\n        for el in walk_tree(child):\n            yield el", "code_tokens": "def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el", "docstring_tokens": "Pre - order depth - first", "label": 1}, {"idx": "cosqa-train-8345", "doc": "python check if http server is open", "code": "def is_http_running_on(port):\n  \"\"\" Check if an http server runs on a given port.\n\n  Args:\n    The port to check.\n  Returns:\n    True if it is used by an http server. False otherwise.\n  \"\"\"\n  try:\n    conn = httplib.HTTPConnection('127.0.0.1:' + str(port))\n    conn.connect()\n    conn.close()\n    return True\n  except Exception:\n    return False", "code_tokens": "def is_http_running_on ( port ) : try : conn = httplib . HTTPConnection ( '127.0.0.1:' + str ( port ) ) conn . connect ( ) conn . close ( ) return True except Exception : return False", "docstring_tokens": "Check if an http server runs on a given port .", "label": 0}, {"idx": "cosqa-train-8346", "doc": "traverse each branch of tree in python", "code": "def walk_tree(root):\n    \"\"\"Pre-order depth-first\"\"\"\n    yield root\n\n    for child in root.children:\n        for el in walk_tree(child):\n            yield el", "code_tokens": "def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el", "docstring_tokens": "Pre - order depth - first", "label": 1}, {"idx": "cosqa-train-8347", "doc": "python check if input is int", "code": "def is_int_type(val):\n    \"\"\"Return True if `val` is of integer type.\"\"\"\n    try:               # Python 2\n        return isinstance(val, (int, long))\n    except NameError:  # Python 3\n        return isinstance(val, int)", "code_tokens": "def is_int_type ( val ) : try : # Python 2 return isinstance ( val , ( int , long ) ) except NameError : # Python 3 return isinstance ( val , int )", "docstring_tokens": "Return True if val is of integer type .", "label": 1}, {"idx": "cosqa-train-8348", "doc": "truncate seconds from a timestamp in python code", "code": "def RoundToSeconds(cls, timestamp):\n    \"\"\"Takes a timestamp value and rounds it to a second precision.\"\"\"\n    leftovers = timestamp % definitions.MICROSECONDS_PER_SECOND\n    scrubbed = timestamp - leftovers\n    rounded = round(float(leftovers) / definitions.MICROSECONDS_PER_SECOND)\n\n    return int(scrubbed + rounded * definitions.MICROSECONDS_PER_SECOND)", "code_tokens": "def RoundToSeconds ( cls , timestamp ) : leftovers = timestamp % definitions . MICROSECONDS_PER_SECOND scrubbed = timestamp - leftovers rounded = round ( float ( leftovers ) / definitions . MICROSECONDS_PER_SECOND ) return int ( scrubbed + rounded * definitions . MICROSECONDS_PER_SECOND )", "docstring_tokens": "Takes a timestamp value and rounds it to a second precision .", "label": 1}, {"idx": "cosqa-train-8349", "doc": "python check if key is in the dictionary", "code": "def __contains__(self, key):\n        \"\"\"\n        Invoked when determining whether a specific key is in the dictionary\n        using `key in d`.\n\n        The key is looked up case-insensitively.\n        \"\"\"\n        k = self._real_key(key)\n        return k in self._data", "code_tokens": "def __contains__ ( self , key ) : k = self . _real_key ( key ) return k in self . _data", "docstring_tokens": "Invoked when determining whether a specific key is in the dictionary using key in d .", "label": 0}, {"idx": "cosqa-train-8350", "doc": "ttk python change disabled color of scrollbar", "code": "def set_scrollbars_cb(self, w, tf):\n        \"\"\"This callback is invoked when the user checks the 'Use Scrollbars'\n        box in the preferences pane.\"\"\"\n        scrollbars = 'on' if tf else 'off'\n        self.t_.set(scrollbars=scrollbars)", "code_tokens": "def set_scrollbars_cb ( self , w , tf ) : scrollbars = 'on' if tf else 'off' self . t_ . set ( scrollbars = scrollbars )", "docstring_tokens": "This callback is invoked when the user checks the Use Scrollbars box in the preferences pane .", "label": 1}, {"idx": "cosqa-train-8351", "doc": "python check if object is a numpy array", "code": "def is_integer_array(val):\n    \"\"\"\n    Checks whether a variable is a numpy integer array.\n\n    Parameters\n    ----------\n    val\n        The variable to check.\n\n    Returns\n    -------\n    bool\n        True if the variable is a numpy integer array. Otherwise False.\n\n    \"\"\"\n    return is_np_array(val) and issubclass(val.dtype.type, np.integer)", "code_tokens": "def is_integer_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . integer )", "docstring_tokens": "Checks whether a variable is a numpy integer array .", "label": 0}, {"idx": "cosqa-train-8352", "doc": "tuple are hashable python", "code": "def hash_iterable(it):\n\t\"\"\"Perform a O(1) memory hash of an iterable of arbitrary length.\n\n\thash(tuple(it)) creates a temporary tuple containing all values from it\n\twhich could be a problem if it is large.\n\n\tSee discussion at:\n\thttps://groups.google.com/forum/#!msg/python-ideas/XcuC01a8SYs/e-doB9TbDwAJ\n\t\"\"\"\n\thash_value = hash(type(it))\n\tfor value in it:\n\t\thash_value = hash((hash_value, value))\n\treturn hash_value", "code_tokens": "def hash_iterable ( it ) : hash_value = hash ( type ( it ) ) for value in it : hash_value = hash ( ( hash_value , value ) ) return hash_value", "docstring_tokens": "Perform a O ( 1 ) memory hash of an iterable of arbitrary length .", "label": 0}, {"idx": "cosqa-train-8353", "doc": "python check if root", "code": "def require_root(fn):\n    \"\"\"\n    Decorator to make sure, that user is root.\n    \"\"\"\n    @wraps(fn)\n    def xex(*args, **kwargs):\n        assert os.geteuid() == 0, \\\n            \"You have to be root to run function '%s'.\" % fn.__name__\n        return fn(*args, **kwargs)\n\n    return xex", "code_tokens": "def require_root ( fn ) : @ wraps ( fn ) def xex ( * args , * * kwargs ) : assert os . geteuid ( ) == 0 , \"You have to be root to run function '%s'.\" % fn . __name__ return fn ( * args , * * kwargs ) return xex", "docstring_tokens": "Decorator to make sure that user is root .", "label": 1}, {"idx": "cosqa-train-8354", "doc": "turn a json into list python", "code": "def from_json_list(cls, api_client, data):\n        \"\"\"Convert a list of JSON values to a list of models\n        \"\"\"\n        return [cls.from_json(api_client, item) for item in data]", "code_tokens": "def from_json_list ( cls , api_client , data ) : return [ cls . from_json ( api_client , item ) for item in data ]", "docstring_tokens": "Convert a list of JSON values to a list of models", "label": 1}, {"idx": "cosqa-train-8355", "doc": "python check if two numpy arrays are equal", "code": "def all_equal(arg1,arg2):\n    \"\"\"\n    Return a single boolean for arg1==arg2, even for numpy arrays\n    using element-wise comparison.\n\n    Uses all(arg1==arg2) for sequences, and arg1==arg2 otherwise.\n\n    If both objects have an '_infinitely_iterable' attribute, they are\n    not be zipped together and are compared directly instead.\n    \"\"\"\n    if all(hasattr(el, '_infinitely_iterable') for el in [arg1,arg2]):\n        return arg1==arg2\n    try:\n        return all(a1 == a2 for a1, a2 in zip(arg1, arg2))\n    except TypeError:\n        return arg1==arg2", "code_tokens": "def all_equal ( arg1 , arg2 ) : if all ( hasattr ( el , '_infinitely_iterable' ) for el in [ arg1 , arg2 ] ) : return arg1 == arg2 try : return all ( a1 == a2 for a1 , a2 in zip ( arg1 , arg2 ) ) except TypeError : return arg1 == arg2", "docstring_tokens": "Return a single boolean for arg1 == arg2 even for numpy arrays using element - wise comparison .", "label": 1}, {"idx": "cosqa-train-8356", "doc": "turn string elements seperated by commas into list python", "code": "def string_to_list(string, sep=\",\", filter_empty=False):\n    \"\"\"Transforma una string con elementos separados por `sep` en una lista.\"\"\"\n    return [value.strip() for value in string.split(sep)\n            if (not filter_empty or value)]", "code_tokens": "def string_to_list ( string , sep = \",\" , filter_empty = False ) : return [ value . strip ( ) for value in string . split ( sep ) if ( not filter_empty or value ) ]", "docstring_tokens": "Transforma una string con elementos separados por sep en una lista .", "label": 1}, {"idx": "cosqa-train-8357", "doc": "python check if user session ending", "code": "def is_closed(self):\n        \"\"\" Check if session was closed. \"\"\"\n        return (self.state == SESSION_STATE.CLOSED \n                or self.state == SESSION_STATE.CLOSING)", "code_tokens": "def is_closed ( self ) : return ( self . state == SESSION_STATE . CLOSED or self . state == SESSION_STATE . CLOSING )", "docstring_tokens": "Check if session was closed .", "label": 0}, {"idx": "cosqa-train-8358", "doc": "turn xml to dict python", "code": "def xml_str_to_dict(s):\n    \"\"\" Transforms an XML string it to python-zimbra dict format\n\n    For format, see:\n      https://github.com/Zimbra-Community/python-zimbra/blob/master/README.md\n\n    :param: a string, containing XML\n    :returns: a dict, with python-zimbra format\n    \"\"\"\n    xml = minidom.parseString(s)\n    return pythonzimbra.tools.xmlserializer.dom_to_dict(xml.firstChild)", "code_tokens": "def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )", "docstring_tokens": "Transforms an XML string it to python - zimbra dict format", "label": 1}, {"idx": "cosqa-train-8359", "doc": "python check if value defined in namespace", "code": "def _lookup_enum_in_ns(namespace, value):\n    \"\"\"Return the attribute of namespace corresponding to value.\"\"\"\n    for attribute in dir(namespace):\n        if getattr(namespace, attribute) == value:\n            return attribute", "code_tokens": "def _lookup_enum_in_ns ( namespace , value ) : for attribute in dir ( namespace ) : if getattr ( namespace , attribute ) == value : return attribute", "docstring_tokens": "Return the attribute of namespace corresponding to value .", "label": 1}, {"idx": "cosqa-train-8360", "doc": "turning a list into a dictionary python", "code": "def list2dict(lst):\n    \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"\n\n    dic = {}\n    for k,v in lst: dic[k] = v\n    return dic", "code_tokens": "def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic", "docstring_tokens": "Takes a list of ( key value ) pairs and turns it into a dict .", "label": 0}, {"idx": "cosqa-train-8361", "doc": "python check if value is of type timestamp", "code": "def dt_to_ts(value):\n    \"\"\" If value is a datetime, convert to timestamp \"\"\"\n    if not isinstance(value, datetime):\n        return value\n    return calendar.timegm(value.utctimetuple()) + value.microsecond / 1000000.0", "code_tokens": "def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0", "docstring_tokens": "If value is a datetime convert to timestamp", "label": 1}, {"idx": "cosqa-train-8362", "doc": "type bytes in python to str", "code": "def bytes_to_str(s, encoding='utf-8'):\n    \"\"\"Returns a str if a bytes object is given.\"\"\"\n    if six.PY3 and isinstance(s, bytes):\n        return s.decode(encoding)\n    return s", "code_tokens": "def bytes_to_str ( s , encoding = 'utf-8' ) : if six . PY3 and isinstance ( s , bytes ) : return s . decode ( encoding ) return s", "docstring_tokens": "Returns a str if a bytes object is given .", "label": 1}, {"idx": "cosqa-train-8363", "doc": "python check if variable exists in locals", "code": "def getvariable(name):\n    \"\"\"Get the value of a local variable somewhere in the call stack.\"\"\"\n    import inspect\n    fr = inspect.currentframe()\n    try:\n        while fr:\n            fr = fr.f_back\n            vars = fr.f_locals\n            if name in vars:\n                return vars[name]\n    except:\n        pass\n    return None", "code_tokens": "def getvariable ( name ) : import inspect fr = inspect . currentframe ( ) try : while fr : fr = fr . f_back vars = fr . f_locals if name in vars : return vars [ name ] except : pass return None", "docstring_tokens": "Get the value of a local variable somewhere in the call stack .", "label": 1}, {"idx": "cosqa-train-8364", "doc": "type cast string to bool python", "code": "def FromString(self, string):\n    \"\"\"Parse a bool from a string.\"\"\"\n    if string.lower() in (\"false\", \"no\", \"n\"):\n      return False\n\n    if string.lower() in (\"true\", \"yes\", \"y\"):\n      return True\n\n    raise TypeValueError(\"%s is not recognized as a boolean value.\" % string)", "code_tokens": "def FromString ( self , string ) : if string . lower ( ) in ( \"false\" , \"no\" , \"n\" ) : return False if string . lower ( ) in ( \"true\" , \"yes\" , \"y\" ) : return True raise TypeValueError ( \"%s is not recognized as a boolean value.\" % string )", "docstring_tokens": "Parse a bool from a string .", "label": 1}, {"idx": "cosqa-train-8365", "doc": "type not equal to string python", "code": "def validate_string(option, value):\n    \"\"\"Validates that 'value' is an instance of `basestring` for Python 2\n    or `str` for Python 3.\n    \"\"\"\n    if isinstance(value, string_type):\n        return value\n    raise TypeError(\"Wrong type for %s, value must be \"\n                    \"an instance of %s\" % (option, string_type.__name__))", "code_tokens": "def validate_string ( option , value ) : if isinstance ( value , string_type ) : return value raise TypeError ( \"Wrong type for %s, value must be \" \"an instance of %s\" % ( option , string_type . __name__ ) )", "docstring_tokens": "Validates that value is an instance of basestring for Python 2 or str for Python 3 .", "label": 1}, {"idx": "cosqa-train-8366", "doc": "python check if you can open file", "code": "def is_readable(filename):\n    \"\"\"Check if file is a regular file and is readable.\"\"\"\n    return os.path.isfile(filename) and os.access(filename, os.R_OK)", "code_tokens": "def is_readable ( filename ) : return os . path . isfile ( filename ) and os . access ( filename , os . R_OK )", "docstring_tokens": "Check if file is a regular file and is readable .", "label": 0}, {"idx": "cosqa-train-8367", "doc": "type symbol sympy python", "code": "def symbol_pos_int(*args, **kwargs):\n    \"\"\"Create a sympy.Symbol with positive and integer assumptions.\"\"\"\n    kwargs.update({'positive': True,\n                   'integer': True})\n    return sympy.Symbol(*args, **kwargs)", "code_tokens": "def symbol_pos_int ( * args , * * kwargs ) : kwargs . update ( { 'positive' : True , 'integer' : True } ) return sympy . Symbol ( * args , * * kwargs )", "docstring_tokens": "Create a sympy . Symbol with positive and integer assumptions .", "label": 1}, {"idx": "cosqa-train-8368", "doc": "python check image valid", "code": "def is_image_file_valid(file_path_name):\n    \"\"\"\n    Indicate whether the specified image file is valid or not.\n\n\n    @param file_path_name: absolute path and file name of an image.\n\n\n    @return: ``True`` if the image file is valid, ``False`` if the file is\n        truncated or does not correspond to a supported image.\n    \"\"\"\n    # Image.verify is only implemented for PNG images, and it only verifies\n    # the CRC checksum in the image.  The only way to check from within\n    # Pillow is to load the image in a try/except and check the error.  If\n    # as much info as possible is from the image is needed,\n    # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it\n    # will attempt to parse as much as possible.\n    try:\n        with Image.open(file_path_name) as image:\n            image.load()\n    except IOError:\n        return False\n\n    return True", "code_tokens": "def is_image_file_valid ( file_path_name ) : # Image.verify is only implemented for PNG images, and it only verifies # the CRC checksum in the image.  The only way to check from within # Pillow is to load the image in a try/except and check the error.  If # as much info as possible is from the image is needed, # ``ImageFile.LOAD_TRUNCATED_IMAGES=True`` needs to bet set and it # will attempt to parse as much as possible. try : with Image . open ( file_path_name ) as image : image . load ( ) except IOError : return False return True", "docstring_tokens": "Indicate whether the specified image file is valid or not .", "label": 1}, {"idx": "cosqa-train-8369", "doc": "ubuntu max python memory", "code": "def peak_memory_usage():\n    \"\"\"Return peak memory usage in MB\"\"\"\n    if sys.platform.startswith('win'):\n        p = psutil.Process()\n        return p.memory_info().peak_wset / 1024 / 1024\n\n    mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss\n    factor_mb = 1 / 1024\n    if sys.platform == 'darwin':\n        factor_mb = 1 / (1024 * 1024)\n    return mem * factor_mb", "code_tokens": "def peak_memory_usage ( ) : if sys . platform . startswith ( 'win' ) : p = psutil . Process ( ) return p . memory_info ( ) . peak_wset / 1024 / 1024 mem = resource . getrusage ( resource . RUSAGE_SELF ) . ru_maxrss factor_mb = 1 / 1024 if sys . platform == 'darwin' : factor_mb = 1 / ( 1024 * 1024 ) return mem * factor_mb", "docstring_tokens": "Return peak memory usage in MB", "label": 0}, {"idx": "cosqa-train-8370", "doc": "python check individual arg in mock call list", "code": "def assert_any_call(self, *args, **kwargs):\n        \"\"\"assert the mock has been called with the specified arguments.\n\n        The assert passes if the mock has *ever* been called, unlike\n        `assert_called_with` and `assert_called_once_with` that only pass if\n        the call is the most recent one.\"\"\"\n        kall = call(*args, **kwargs)\n        if kall not in self.call_args_list:\n            expected_string = self._format_mock_call_signature(args, kwargs)\n            raise AssertionError(\n                '%s call not found' % expected_string\n            )", "code_tokens": "def assert_any_call ( self , * args , * * kwargs ) : kall = call ( * args , * * kwargs ) if kall not in self . call_args_list : expected_string = self . _format_mock_call_signature ( args , kwargs ) raise AssertionError ( '%s call not found' % expected_string )", "docstring_tokens": "assert the mock has been called with the specified arguments .", "label": 0}, {"idx": "cosqa-train-8371", "doc": "underscore case is recommended in python", "code": "def camel_case_from_underscores(string):\n    \"\"\"generate a CamelCase string from an underscore_string.\"\"\"\n    components = string.split('_')\n    string = ''\n    for component in components:\n        string += component[0].upper() + component[1:]\n    return string", "code_tokens": "def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "docstring_tokens": "generate a CamelCase string from an underscore_string .", "label": 1}, {"idx": "cosqa-train-8372", "doc": "python check is a column doesn't exist", "code": "def column_exists(cr, table, column):\n    \"\"\" Check whether a certain column exists \"\"\"\n    cr.execute(\n        'SELECT count(attname) FROM pg_attribute '\n        'WHERE attrelid = '\n        '( SELECT oid FROM pg_class WHERE relname = %s ) '\n        'AND attname = %s',\n        (table, column))\n    return cr.fetchone()[0] == 1", "code_tokens": "def column_exists ( cr , table , column ) : cr . execute ( 'SELECT count(attname) FROM pg_attribute ' 'WHERE attrelid = ' '( SELECT oid FROM pg_class WHERE relname = %s ) ' 'AND attname = %s' , ( table , column ) ) return cr . fetchone ( ) [ 0 ] == 1", "docstring_tokens": "Check whether a certain column exists", "label": 0}, {"idx": "cosqa-train-8373", "doc": "unhashable type list for set in python", "code": "def unique(iterable):\n    \"\"\" Returns a list copy in which each item occurs only once (in-order).\n    \"\"\"\n    seen = set()\n    return [x for x in iterable if x not in seen and not seen.add(x)]", "code_tokens": "def unique ( iterable ) : seen = set ( ) return [ x for x in iterable if x not in seen and not seen . add ( x ) ]", "docstring_tokens": "Returns a list copy in which each item occurs only once ( in - order ) .", "label": 1}, {"idx": "cosqa-train-8374", "doc": "python check is json", "code": "def is_json_file(filename, show_warnings = False):\n    \"\"\"Check configuration file type is JSON\n    Return a boolean indicating wheather the file is JSON format or not\n    \"\"\"\n    try:\n        config_dict = load_config(filename, file_type = \"json\")\n        is_json = True\n    except:\n        is_json = False\n    return(is_json)", "code_tokens": "def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = \"json\" ) is_json = True except : is_json = False return ( is_json )", "docstring_tokens": "Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not", "label": 0}, {"idx": "cosqa-train-8375", "doc": "unorderable types python str to int", "code": "def _from_bytes(bytes, byteorder=\"big\", signed=False):\n    \"\"\"This is the same functionality as ``int.from_bytes`` in python 3\"\"\"\n    return int.from_bytes(bytes, byteorder=byteorder, signed=signed)", "code_tokens": "def _from_bytes ( bytes , byteorder = \"big\" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )", "docstring_tokens": "This is the same functionality as int . from_bytes in python 3", "label": 1}, {"idx": "cosqa-train-8376", "doc": "python check is object is defined", "code": "def is_defined(self, objtxt, force_import=False):\n        \"\"\"Return True if object is defined\"\"\"\n        return self.interpreter.is_defined(objtxt, force_import)", "code_tokens": "def is_defined ( self , objtxt , force_import = False ) : return self . interpreter . is_defined ( objtxt , force_import )", "docstring_tokens": "Return True if object is defined", "label": 1}, {"idx": "cosqa-train-8377", "doc": "unsupported locale setting python", "code": "def set_locale(request):\n    \"\"\"Return locale from GET lang param or automatically.\"\"\"\n    return request.query.get('lang', app.ps.babel.select_locale_by_request(request))", "code_tokens": "def set_locale ( request ) : return request . query . get ( 'lang' , app . ps . babel . select_locale_by_request ( request ) )", "docstring_tokens": "Return locale from GET lang param or automatically .", "label": 0}, {"idx": "cosqa-train-8378", "doc": "python check namedtuple type", "code": "def isnamedtuple(obj):\n    \"\"\"Heuristic check if an object is a namedtuple.\"\"\"\n    return isinstance(obj, tuple) \\\n           and hasattr(obj, \"_fields\") \\\n           and hasattr(obj, \"_asdict\") \\\n           and callable(obj._asdict)", "code_tokens": "def isnamedtuple ( obj ) : return isinstance ( obj , tuple ) and hasattr ( obj , \"_fields\" ) and hasattr ( obj , \"_asdict\" ) and callable ( obj . _asdict )", "docstring_tokens": "Heuristic check if an object is a namedtuple .", "label": 1}, {"idx": "cosqa-train-8379", "doc": "urlretrieve use file name python", "code": "def get_file_name(url):\n  \"\"\"Returns file name of file at given url.\"\"\"\n  return os.path.basename(urllib.parse.urlparse(url).path) or 'unknown_name'", "code_tokens": "def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'", "docstring_tokens": "Returns file name of file at given url .", "label": 0}, {"idx": "cosqa-train-8380", "doc": "python check number of connections of mysql", "code": "def getConnectionStats(self):\n        \"\"\"Returns dictionary with number of connections for each database.\n        \n        @return: Dictionary of database connection statistics.\n        \n        \"\"\"\n        cur = self._conn.cursor()\n        cur.execute(\"\"\"SELECT datname,numbackends FROM pg_stat_database;\"\"\")\n        rows = cur.fetchall()\n        if rows:\n            return dict(rows)\n        else:\n            return {}", "code_tokens": "def getConnectionStats ( self ) : cur = self . _conn . cursor ( ) cur . execute ( \"\"\"SELECT datname,numbackends FROM pg_stat_database;\"\"\" ) rows = cur . fetchall ( ) if rows : return dict ( rows ) else : return { }", "docstring_tokens": "Returns dictionary with number of connections for each database .", "label": 1}, {"idx": "cosqa-train-8381", "doc": "use python select poll on windows", "code": "def _stdin_ready_posix():\n    \"\"\"Return True if there's something to read on stdin (posix version).\"\"\"\n    infds, outfds, erfds = select.select([sys.stdin],[],[],0)\n    return bool(infds)", "code_tokens": "def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )", "docstring_tokens": "Return True if there s something to read on stdin ( posix version ) .", "label": 0}, {"idx": "cosqa-train-8382", "doc": "python check object count peewee model object", "code": "def _check_model(obj, models=None):\n    \"\"\"Checks object if it's a peewee model and unique.\"\"\"\n    return isinstance(obj, type) and issubclass(obj, pw.Model) and hasattr(obj, '_meta')", "code_tokens": "def _check_model ( obj , models = None ) : return isinstance ( obj , type ) and issubclass ( obj , pw . Model ) and hasattr ( obj , '_meta' )", "docstring_tokens": "Checks object if it s a peewee model and unique .", "label": 0}, {"idx": "cosqa-train-8383", "doc": "use python to change volume", "code": "def setVolume(self, volume):\n        \"\"\"Changes volume\"\"\"\n        val = float(val)\n        cmd = \"volume %s\" % val\n        self._execute(cmd)", "code_tokens": "def setVolume ( self , volume ) : val = float ( val ) cmd = \"volume %s\" % val self . _execute ( cmd )", "docstring_tokens": "Changes volume", "label": 1}, {"idx": "cosqa-train-8384", "doc": "python check size of file in kb", "code": "def get_file_size(filename):\n    \"\"\"\n    Get the file size of a given file\n\n    :param filename: string: pathname of a file\n    :return: human readable filesize\n    \"\"\"\n    if os.path.isfile(filename):\n        return convert_size(os.path.getsize(filename))\n    return None", "code_tokens": "def get_file_size ( filename ) : if os . path . isfile ( filename ) : return convert_size ( os . path . getsize ( filename ) ) return None", "docstring_tokens": "Get the file size of a given file", "label": 0}, {"idx": "cosqa-train-8385", "doc": "use python to list every even number in a function using *args", "code": "def pool_args(function, sequence, kwargs):\n    \"\"\"Return a single iterator of n elements of lists of length 3, given a sequence of len n.\"\"\"\n    return zip(itertools.repeat(function), sequence, itertools.repeat(kwargs))", "code_tokens": "def pool_args ( function , sequence , kwargs ) : return zip ( itertools . repeat ( function ) , sequence , itertools . repeat ( kwargs ) )", "docstring_tokens": "Return a single iterator of n elements of lists of length 3 given a sequence of len n .", "label": 0}, {"idx": "cosqa-train-8386", "doc": "python check stdin is not empty example", "code": "def stdin_readable():\n    \"\"\"Determine whether stdin has any data to read.\"\"\"\n    if not WINDOWS:\n        try:\n            return bool(select([sys.stdin], [], [], 0)[0])\n        except Exception:\n            logger.log_exc()\n    try:\n        return not sys.stdin.isatty()\n    except Exception:\n        logger.log_exc()\n    return False", "code_tokens": "def stdin_readable ( ) : if not WINDOWS : try : return bool ( select ( [ sys . stdin ] , [ ] , [ ] , 0 ) [ 0 ] ) except Exception : logger . log_exc ( ) try : return not sys . stdin . isatty ( ) except Exception : logger . log_exc ( ) return False", "docstring_tokens": "Determine whether stdin has any data to read .", "label": 1}, {"idx": "cosqa-train-8387", "doc": "use python to server a directory over http", "code": "def serve_dtool_directory(directory, port):\n    \"\"\"Serve the datasets in a directory over HTTP.\"\"\"\n    os.chdir(directory)\n    server_address = (\"localhost\", port)\n    httpd = DtoolHTTPServer(server_address, DtoolHTTPRequestHandler)\n    httpd.serve_forever()", "code_tokens": "def serve_dtool_directory ( directory , port ) : os . chdir ( directory ) server_address = ( \"localhost\" , port ) httpd = DtoolHTTPServer ( server_address , DtoolHTTPRequestHandler ) httpd . serve_forever ( )", "docstring_tokens": "Serve the datasets in a directory over HTTP .", "label": 1}, {"idx": "cosqa-train-8388", "doc": "python check string contains array of string", "code": "def all_strings(arr):\n        \"\"\"\n        Ensures that the argument is a list that either is empty or contains only strings\n        :param arr: list\n        :return:\n        \"\"\"\n        if not isinstance([], list):\n            raise TypeError(\"non-list value found where list is expected\")\n        return all(isinstance(x, str) for x in arr)", "code_tokens": "def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( \"non-list value found where list is expected\" ) return all ( isinstance ( x , str ) for x in arr )", "docstring_tokens": "Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return :", "label": 1}, {"idx": "cosqa-train-8389", "doc": "using an integer as a month in python", "code": "def calculate_month(birth_date):\n    \"\"\"\n    Calculates and returns a month number basing on PESEL standard.\n    \"\"\"\n    year = int(birth_date.strftime('%Y'))\n    month = int(birth_date.strftime('%m')) + ((int(year / 100) - 14) % 5) * 20\n\n    return month", "code_tokens": "def calculate_month ( birth_date ) : year = int ( birth_date . strftime ( '%Y' ) ) month = int ( birth_date . strftime ( '%m' ) ) + ( ( int ( year / 100 ) - 14 ) % 5 ) * 20 return month", "docstring_tokens": "Calculates and returns a month number basing on PESEL standard .", "label": 0}, {"idx": "cosqa-train-8390", "doc": "python check string is empty or null", "code": "def is_valid_variable_name(string_to_check):\n    \"\"\"\n    Returns whether the provided name is a valid variable name in Python\n\n    :param string_to_check: the string to be checked\n    :return: True or False\n    \"\"\"\n\n    try:\n\n        parse('{} = None'.format(string_to_check))\n        return True\n\n    except (SyntaxError, ValueError, TypeError):\n\n        return False", "code_tokens": "def is_valid_variable_name ( string_to_check ) : try : parse ( '{} = None' . format ( string_to_check ) ) return True except ( SyntaxError , ValueError , TypeError ) : return False", "docstring_tokens": "Returns whether the provided name is a valid variable name in Python", "label": 0}, {"idx": "cosqa-train-8391", "doc": "using aparser from python shell", "code": "def build_parser():\n    \"\"\"Build argument parsers.\"\"\"\n\n    parser = argparse.ArgumentParser(\"Release packages to pypi\")\n    parser.add_argument('--check', '-c', action=\"store_true\", help=\"Do a dry run without uploading\")\n    parser.add_argument('component', help=\"The component to release as component-version\")\n    return parser", "code_tokens": "def build_parser ( ) : parser = argparse . ArgumentParser ( \"Release packages to pypi\" ) parser . add_argument ( '--check' , '-c' , action = \"store_true\" , help = \"Do a dry run without uploading\" ) parser . add_argument ( 'component' , help = \"The component to release as component-version\" ) return parser", "docstring_tokens": "Build argument parsers .", "label": 1}, {"idx": "cosqa-train-8392", "doc": "python check string is file path", "code": "def is_file(path):\n    \"\"\"Determine if a Path or string is a file on the file system.\"\"\"\n    try:\n        return path.expanduser().absolute().is_file()\n    except AttributeError:\n        return os.path.isfile(os.path.abspath(os.path.expanduser(str(path))))", "code_tokens": "def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )", "docstring_tokens": "Determine if a Path or string is a file on the file system .", "label": 0}, {"idx": "cosqa-train-8393", "doc": "using datetime to get the last 7 dates of a week given a date in python", "code": "def get_last_week_range(weekday_start=\"Sunday\"):\n    \"\"\" Gets the date for the first and the last day of the previous complete week.\n\n    :param weekday_start: Either \"Monday\" or \"Sunday\", indicating the first day of the week.\n    :returns: A tuple containing two date objects, for the first and the last day of the week\n              respectively.\n    \"\"\"\n    today = date.today()\n    # Get the first day of the past complete week.\n    start_of_week = snap_to_beginning_of_week(today, weekday_start) - timedelta(weeks=1)\n    end_of_week = start_of_week + timedelta(days=6)\n    return (start_of_week, end_of_week)", "code_tokens": "def get_last_week_range ( weekday_start = \"Sunday\" ) : today = date . today ( ) # Get the first day of the past complete week. start_of_week = snap_to_beginning_of_week ( today , weekday_start ) - timedelta ( weeks = 1 ) end_of_week = start_of_week + timedelta ( days = 6 ) return ( start_of_week , end_of_week )", "docstring_tokens": "Gets the date for the first and the last day of the previous complete week .", "label": 0}, {"idx": "cosqa-train-8394", "doc": "python check success of response", "code": "def __check_success(resp):\n        \"\"\" Check a JSON server response to see if it was successful\n\n        :type resp: Dictionary (parsed JSON from response)\n        :param resp: the response string\n\n        :rtype: String\n        :returns: the success message, if it exists\n\n        :raises: APIError if the success message is not present\n\n\n        \"\"\"\n\n        if \"success\" not in resp.keys():\n            try:\n                raise APIError('200', 'Operation Failed', resp[\"error\"])\n            except KeyError:\n                raise APIError('200', 'Operation Failed', str(resp))\n        return resp[\"success\"]", "code_tokens": "def __check_success ( resp ) : if \"success\" not in resp . keys ( ) : try : raise APIError ( '200' , 'Operation Failed' , resp [ \"error\" ] ) except KeyError : raise APIError ( '200' , 'Operation Failed' , str ( resp ) ) return resp [ \"success\" ]", "docstring_tokens": "Check a JSON server response to see if it was successful", "label": 0}, {"idx": "cosqa-train-8395", "doc": "python check to see of a file is exicutible", "code": "def is_readable_dir(path):\n  \"\"\"Returns whether a path names an existing directory we can list and read files from.\"\"\"\n  return os.path.isdir(path) and os.access(path, os.R_OK) and os.access(path, os.X_OK)", "code_tokens": "def is_readable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . R_OK ) and os . access ( path , os . X_OK )", "docstring_tokens": "Returns whether a path names an existing directory we can list and read files from .", "label": 0}, {"idx": "cosqa-train-8396", "doc": "using python 3 to access s3", "code": "def s3_connect(bucket_name, s3_access_key_id, s3_secret_key):\n    \"\"\" Returns a Boto connection to the provided S3 bucket. \"\"\"\n    conn = connect_s3(s3_access_key_id, s3_secret_key)\n    try:\n        return conn.get_bucket(bucket_name)\n    except S3ResponseError as e:\n        if e.status == 403:\n            raise Exception(\"Bad Amazon S3 credentials.\")\n        raise", "code_tokens": "def s3_connect ( bucket_name , s3_access_key_id , s3_secret_key ) : conn = connect_s3 ( s3_access_key_id , s3_secret_key ) try : return conn . get_bucket ( bucket_name ) except S3ResponseError as e : if e . status == 403 : raise Exception ( \"Bad Amazon S3 credentials.\" ) raise", "docstring_tokens": "Returns a Boto connection to the provided S3 bucket .", "label": 0}, {"idx": "cosqa-train-8397", "doc": "python check type of data frame colimn", "code": "def _validate_pos(df):\n    \"\"\"Validates the returned positional object\n    \"\"\"\n    assert isinstance(df, pd.DataFrame)\n    assert [\"seqname\", \"position\", \"strand\"] == df.columns.tolist()\n    assert df.position.dtype == np.dtype(\"int64\")\n    assert df.strand.dtype == np.dtype(\"O\")\n    assert df.seqname.dtype == np.dtype(\"O\")\n    return df", "code_tokens": "def _validate_pos ( df ) : assert isinstance ( df , pd . DataFrame ) assert [ \"seqname\" , \"position\" , \"strand\" ] == df . columns . tolist ( ) assert df . position . dtype == np . dtype ( \"int64\" ) assert df . strand . dtype == np . dtype ( \"O\" ) assert df . seqname . dtype == np . dtype ( \"O\" ) return df", "docstring_tokens": "Validates the returned positional object", "label": 0}, {"idx": "cosqa-train-8398", "doc": "using python 3 to generate all random passwords", "code": "def GeneratePassphrase(length=20):\n  \"\"\"Create a 20 char passphrase with easily typeable chars.\"\"\"\n  valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  valid_chars += \"0123456789 ,-_&$#\"\n  return \"\".join(random.choice(valid_chars) for i in range(length))", "code_tokens": "def GeneratePassphrase ( length = 20 ) : valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" valid_chars += \"0123456789 ,-_&$#\" return \"\" . join ( random . choice ( valid_chars ) for i in range ( length ) )", "docstring_tokens": "Create a 20 char passphrase with easily typeable chars .", "label": 0}, {"idx": "cosqa-train-8399", "doc": "python check write permission", "code": "def chmod(f):\n    \"\"\" change mod to writeable \"\"\"\n    try:\n        os.chmod(f, S_IWRITE)  # windows (cover all)\n    except Exception as e:\n        pass\n    try:\n        os.chmod(f, 0o777)  # *nix\n    except Exception as e:\n        pass", "code_tokens": "def chmod ( f ) : try : os . chmod ( f , S_IWRITE ) # windows (cover all) except Exception as e : pass try : os . chmod ( f , 0o777 ) # *nix except Exception as e : pass", "docstring_tokens": "change mod to writeable", "label": 0}, {"idx": "cosqa-train-8400", "doc": "using python language how to format action outside of string", "code": "def short_action_string(self):\n        \"\"\"\n        Returns string with actor and verb, allowing target/object\n        to be filled in manually.\n\n        Example:\n        [actor] [verb] or\n        \"Joe cool posted a comment\"\n        \"\"\"\n        output = \"{0} \".format(self.actor)\n        if self.override_string:\n            output += self.override_string\n        else:\n            output += self.verb\n        return output", "code_tokens": "def short_action_string ( self ) : output = \"{0} \" . format ( self . actor ) if self . override_string : output += self . override_string else : output += self . verb return output", "docstring_tokens": "Returns string with actor and verb allowing target / object to be filled in manually .", "label": 0}, {"idx": "cosqa-train-8401", "doc": "python checking for empty queue", "code": "def full(self):\n        \"\"\"Return True if the queue is full\"\"\"\n        if not self.size: return False\n        return len(self.pq) == (self.size + self.removed_count)", "code_tokens": "def full ( self ) : if not self . size : return False return len ( self . pq ) == ( self . size + self . removed_count )", "docstring_tokens": "Return True if the queue is full", "label": 1}, {"idx": "cosqa-train-8402", "doc": "using python to display gps coordinates", "code": "def to_gtp(coord):\n    \"\"\"Converts from a Minigo coordinate to a GTP coordinate.\"\"\"\n    if coord is None:\n        return 'pass'\n    y, x = coord\n    return '{}{}'.format(_GTP_COLUMNS[x], go.N - y)", "code_tokens": "def to_gtp ( coord ) : if coord is None : return 'pass' y , x = coord return '{}{}' . format ( _GTP_COLUMNS [ x ] , go . N - y )", "docstring_tokens": "Converts from a Minigo coordinate to a GTP coordinate .", "label": 1}, {"idx": "cosqa-train-8403", "doc": "python checking multiple fields", "code": "def _check_fields(self, x, y):\n\t\t\"\"\"\n\t\tCheck x and y fields parameters and initialize\n\t\t\"\"\"\n\t\tif x is None:\n\t\t\tif self.x is None:\n\t\t\t\tself.err(\n\t\t\t\t\tself._check_fields,\n\t\t\t\t\t\"X field is not set: please specify a parameter\")\n\t\t\t\treturn\n\t\t\tx = self.x\n\t\tif y is None:\n\t\t\tif self.y is None:\n\t\t\t\tself.err(\n\t\t\t\t\tself._check_fields,\n\t\t\t\t\t\"Y field is not set: please specify a parameter\")\n\t\t\t\treturn\n\t\t\ty = self.y\n\t\treturn x, y", "code_tokens": "def _check_fields ( self , x , y ) : if x is None : if self . x is None : self . err ( self . _check_fields , \"X field is not set: please specify a parameter\" ) return x = self . x if y is None : if self . y is None : self . err ( self . _check_fields , \"Y field is not set: please specify a parameter\" ) return y = self . y return x , y", "docstring_tokens": "Check x and y fields parameters and initialize", "label": 0}, {"idx": "cosqa-train-8404", "doc": "using python to format text +color", "code": "def colorize(string, color, *args, **kwargs):\n    \"\"\"\n    Implements string formatting along with color specified in colorama.Fore\n    \"\"\"\n    string = string.format(*args, **kwargs)\n    return color + string + colorama.Fore.RESET", "code_tokens": "def colorize ( string , color , * args , * * kwargs ) : string = string . format ( * args , * * kwargs ) return color + string + colorama . Fore . RESET", "docstring_tokens": "Implements string formatting along with color specified in colorama . Fore", "label": 0}, {"idx": "cosqa-train-8405", "doc": "python chinese string to pinyin", "code": "def get(s, delimiter='', format=\"diacritical\"):\n    \"\"\"Return pinyin of string, the string must be unicode\n    \"\"\"\n    return delimiter.join(_pinyin_generator(u(s), format=format))", "code_tokens": "def get ( s , delimiter = '' , format = \"diacritical\" ) : return delimiter . join ( _pinyin_generator ( u ( s ) , format = format ) )", "docstring_tokens": "Return pinyin of string the string must be unicode", "label": 0}, {"idx": "cosqa-train-8406", "doc": "using python trace programmatically", "code": "def _trace_full (frame, event, arg):\n    \"\"\"Trace every executed line.\"\"\"\n    if event == \"line\":\n        _trace_line(frame, event, arg)\n    else:\n        _trace(frame, event, arg)\n    return _trace_full", "code_tokens": "def _trace_full ( frame , event , arg ) : if event == \"line\" : _trace_line ( frame , event , arg ) else : _trace ( frame , event , arg ) return _trace_full", "docstring_tokens": "Trace every executed line .", "label": 1}, {"idx": "cosqa-train-8407", "doc": "python chk for empty dictionary", "code": "def _remove_empty_items(d, required):\n  \"\"\"Return a new dict with any empty items removed.\n\n  Note that this is not a deep check. If d contains a dictionary which\n  itself contains empty items, those are never checked.\n\n  This method exists to make to_serializable() functions cleaner.\n  We could revisit this some day, but for now, the serialized objects are\n  stripped of empty values to keep the output YAML more compact.\n\n  Args:\n    d: a dictionary\n    required: list of required keys (for example, TaskDescriptors always emit\n      the \"task-id\", even if None)\n\n  Returns:\n    A dictionary with empty items removed.\n  \"\"\"\n\n  new_dict = {}\n  for k, v in d.items():\n    if k in required:\n      new_dict[k] = v\n    elif isinstance(v, int) or v:\n      # \"if v\" would suppress emitting int(0)\n      new_dict[k] = v\n\n  return new_dict", "code_tokens": "def _remove_empty_items ( d , required ) : new_dict = { } for k , v in d . items ( ) : if k in required : new_dict [ k ] = v elif isinstance ( v , int ) or v : # \"if v\" would suppress emitting int(0) new_dict [ k ] = v return new_dict", "docstring_tokens": "Return a new dict with any empty items removed .", "label": 0}, {"idx": "cosqa-train-8408", "doc": "using split to parse out tuples from a file python", "code": "def readTuple(self, line, n=3):\n        \"\"\" Reads a tuple of numbers. e.g. vertices, normals or teture coords.\n        \"\"\"\n        numbers = [num for num in line.split(' ') if num]\n        return [float(num) for num in numbers[1:n + 1]]", "code_tokens": "def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]", "docstring_tokens": "Reads a tuple of numbers . e . g . vertices normals or teture coords .", "label": 0}, {"idx": "cosqa-train-8409", "doc": "python choose key conditionally from a tuple", "code": "def previous_key(tuple_of_tuples, key):\n    \"\"\"Returns the key which comes before the give key.\n\n    It Processes a tuple of 2-element tuples and returns the key which comes\n    before the given key.\n    \"\"\"\n    for i, t in enumerate(tuple_of_tuples):\n        if t[0] == key:\n            try:\n                return tuple_of_tuples[i - 1][0]\n            except IndexError:\n                return None", "code_tokens": "def previous_key ( tuple_of_tuples , key ) : for i , t in enumerate ( tuple_of_tuples ) : if t [ 0 ] == key : try : return tuple_of_tuples [ i - 1 ] [ 0 ] except IndexError : return None", "docstring_tokens": "Returns the key which comes before the give key .", "label": 1}, {"idx": "cosqa-train-8410", "doc": "using static variables in a python rest api", "code": "def home():\n    \"\"\"Temporary helper function to link to the API routes\"\"\"\n    return dict(links=dict(api='{}{}'.format(request.url, PREFIX[1:]))), \\\n        HTTPStatus.OK", "code_tokens": "def home ( ) : return dict ( links = dict ( api = '{}{}' . format ( request . url , PREFIX [ 1 : ] ) ) ) , HTTPStatus . OK", "docstring_tokens": "Temporary helper function to link to the API routes", "label": 1}, {"idx": "cosqa-train-8411", "doc": "python click how to redirect a group to a command", "code": "def locate(command, on):\n    \"\"\"Locate the command's man page.\"\"\"\n    location = find_page_location(command, on)\n    click.echo(location)", "code_tokens": "def locate ( command , on ) : location = find_page_location ( command , on ) click . echo ( location )", "docstring_tokens": "Locate the command s man page .", "label": 1}, {"idx": "cosqa-train-8412", "doc": "validate schema with json in python", "code": "def validate(raw_schema, target=None, **kwargs):\n    \"\"\"\n    Given the python representation of a JSONschema as defined in the swagger\n    spec, validate that the schema complies to spec.  If `target` is provided,\n    that target will be validated against the provided schema.\n    \"\"\"\n    schema = schema_validator(raw_schema, **kwargs)\n    if target is not None:\n        validate_object(target, schema=schema, **kwargs)", "code_tokens": "def validate ( raw_schema , target = None , * * kwargs ) : schema = schema_validator ( raw_schema , * * kwargs ) if target is not None : validate_object ( target , schema = schema , * * kwargs )", "docstring_tokens": "Given the python representation of a JSONschema as defined in the swagger spec validate that the schema complies to spec . If target is provided that target will be validated against the provided schema .", "label": 1}, {"idx": "cosqa-train-8413", "doc": "python click how to use keyword as command name", "code": "def locate(command, on):\n    \"\"\"Locate the command's man page.\"\"\"\n    location = find_page_location(command, on)\n    click.echo(location)", "code_tokens": "def locate ( command , on ) : location = find_page_location ( command , on ) click . echo ( location )", "docstring_tokens": "Locate the command s man page .", "label": 1}, {"idx": "cosqa-train-8414", "doc": "vs code python unsupported locale", "code": "def translation(language):\n    \"\"\"\n    Return a translation object in the default 'django' domain.\n    \"\"\"\n    global _translations\n    if language not in _translations:\n        _translations[language] = Translations(language)\n    return _translations[language]", "code_tokens": "def translation ( language ) : global _translations if language not in _translations : _translations [ language ] = Translations ( language ) return _translations [ language ]", "docstring_tokens": "Return a translation object in the default django domain .", "label": 0}, {"idx": "cosqa-train-8415", "doc": "python clipping the end of a string", "code": "def _clip(sid, prefix):\n    \"\"\"Clips a prefix from the beginning of a string if it exists.\"\"\"\n    return sid[len(prefix):] if sid.startswith(prefix) else sid", "code_tokens": "def _clip ( sid , prefix ) : return sid [ len ( prefix ) : ] if sid . startswith ( prefix ) else sid", "docstring_tokens": "Clips a prefix from the beginning of a string if it exists .", "label": 0}, {"idx": "cosqa-train-8416", "doc": "waht date type can be used as keys in a python dict", "code": "def _convert_date_to_dict(field_date):\n        \"\"\"\n        Convert native python ``datetime.date`` object  to a format supported by the API\n        \"\"\"\n        return {DAY: field_date.day, MONTH: field_date.month, YEAR: field_date.year}", "code_tokens": "def _convert_date_to_dict ( field_date ) : return { DAY : field_date . day , MONTH : field_date . month , YEAR : field_date . year }", "docstring_tokens": "Convert native python datetime . date object to a format supported by the API", "label": 1}, {"idx": "cosqa-train-8417", "doc": "python close all access connections", "code": "def cleanup(self, app):\n        \"\"\"Close all connections.\"\"\"\n        if hasattr(self.database.obj, 'close_all'):\n            self.database.close_all()", "code_tokens": "def cleanup ( self , app ) : if hasattr ( self . database . obj , 'close_all' ) : self . database . close_all ( )", "docstring_tokens": "Close all connections .", "label": 0}, {"idx": "cosqa-train-8418", "doc": "python close socket connection", "code": "def socket_close(self):\n        \"\"\"Close our socket.\"\"\"\n        if self.sock != NC.INVALID_SOCKET:\n            self.sock.close()\n        self.sock = NC.INVALID_SOCKET", "code_tokens": "def socket_close ( self ) : if self . sock != NC . INVALID_SOCKET : self . sock . close ( ) self . sock = NC . INVALID_SOCKET", "docstring_tokens": "Close our socket .", "label": 1}, {"idx": "cosqa-train-8419", "doc": "webdriver python scroll down", "code": "def mouse_out(self):\n        \"\"\"\n        Performs a mouse out the element.\n\n        Currently works only on Chrome driver.\n        \"\"\"\n        self.scroll_to()\n        ActionChains(self.parent.driver).move_by_offset(0, 0).click().perform()", "code_tokens": "def mouse_out ( self ) : self . scroll_to ( ) ActionChains ( self . parent . driver ) . move_by_offset ( 0 , 0 ) . click ( ) . perform ( )", "docstring_tokens": "Performs a mouse out the element .", "label": 0}, {"idx": "cosqa-train-8420", "doc": "python close tkinter window focus cmd prompt", "code": "def cancel(self, event=None):\n        \"\"\"Function called when Cancel-button clicked.\n\n        This method returns focus to parent, and destroys the dialog.\n        \"\"\"\n\n        if self.parent != None:\n            self.parent.focus_set()\n\n        self.destroy()", "code_tokens": "def cancel ( self , event = None ) : if self . parent != None : self . parent . focus_set ( ) self . destroy ( )", "docstring_tokens": "Function called when Cancel - button clicked .", "label": 0}, {"idx": "cosqa-train-8421", "doc": "websocket keep alive python", "code": "def on_close(self, ws):\n        \"\"\" Called when websocket connection is closed\n        \"\"\"\n        log.debug(\"Closing WebSocket connection with {}\".format(self.url))\n        if self.keepalive and self.keepalive.is_alive():\n            self.keepalive.do_run = False\n            self.keepalive.join()", "code_tokens": "def on_close ( self , ws ) : log . debug ( \"Closing WebSocket connection with {}\" . format ( self . url ) ) if self . keepalive and self . keepalive . is_alive ( ) : self . keepalive . do_run = False self . keepalive . join ( )", "docstring_tokens": "Called when websocket connection is closed", "label": 1}, {"idx": "cosqa-train-8422", "doc": "python closing db connection", "code": "def close_database_session(session):\n    \"\"\"Close connection with the database\"\"\"\n\n    try:\n        session.close()\n    except OperationalError as e:\n        raise DatabaseError(error=e.orig.args[1], code=e.orig.args[0])", "code_tokens": "def close_database_session ( session ) : try : session . close ( ) except OperationalError as e : raise DatabaseError ( error = e . orig . args [ 1 ] , code = e . orig . args [ 0 ] )", "docstring_tokens": "Close connection with the database", "label": 1}, {"idx": "cosqa-train-8423", "doc": "what does putting a hash at he beggining of a line do python", "code": "def _add_hash(source):\n    \"\"\"Add a leading hash '#' at the beginning of every line in the source.\"\"\"\n    source = '\\n'.join('# ' + line.rstrip()\n                       for line in source.splitlines())\n    return source", "code_tokens": "def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "docstring_tokens": "Add a leading hash # at the beginning of every line in the source .", "label": 1}, {"idx": "cosqa-train-8424", "doc": "python cluster method centroid distance euclidean", "code": "def _cal_dist2center(X, center):\n    \"\"\" Calculate the SSE to the cluster center\n    \"\"\"\n    dmemb2cen = scipy.spatial.distance.cdist(X, center.reshape(1,X.shape[1]), metric='seuclidean')\n    return(np.sum(dmemb2cen))", "code_tokens": "def _cal_dist2center ( X , center ) : dmemb2cen = scipy . spatial . distance . cdist ( X , center . reshape ( 1 , X . shape [ 1 ] ) , metric = 'seuclidean' ) return ( np . sum ( dmemb2cen ) )", "docstring_tokens": "Calculate the SSE to the cluster center", "label": 1}, {"idx": "cosqa-train-8425", "doc": "python code for a gaussian distribution", "code": "def gaussian_variogram_model(m, d):\n    \"\"\"Gaussian model, m is [psill, range, nugget]\"\"\"\n    psill = float(m[0])\n    range_ = float(m[1])\n    nugget = float(m[2])\n    return psill * (1. - np.exp(-d**2./(range_*4./7.)**2.)) + nugget", "code_tokens": "def gaussian_variogram_model ( m , d ) : psill = float ( m [ 0 ] ) range_ = float ( m [ 1 ] ) nugget = float ( m [ 2 ] ) return psill * ( 1. - np . exp ( - d ** 2. / ( range_ * 4. / 7. ) ** 2. ) ) + nugget", "docstring_tokens": "Gaussian model m is [ psill range nugget ]", "label": 1}, {"idx": "cosqa-train-8426", "doc": "wirte a markdown parser by python", "code": "def md_to_text(content):\n    \"\"\" Converts markdown content to text \"\"\"\n    text = None\n    html = markdown.markdown(content)\n    if html:\n        text = html_to_text(content)\n    return text", "code_tokens": "def md_to_text ( content ) : text = None html = markdown . markdown ( content ) if html : text = html_to_text ( content ) return text", "docstring_tokens": "Converts markdown content to text", "label": 1}, {"idx": "cosqa-train-8427", "doc": "python code for elastic collision of objects", "code": "def query_collision(collision_object):\n        \"\"\"\n        Check to see if the specified object is colliding with any of the objects currently in the Collision Manager\n        Returns the first object we are colliding with if there was a collision and None if no collisions was found\n        \"\"\"\n        global collidable_objects\n        # Note that we use a Brute Force approach for the time being.\n        # It performs horribly under heavy loads, but it meets\n        # our needs for the time being.\n        for obj in collidable_objects:\n            # Make sure we don't check ourself against ourself.\n            if obj.obj_id is not collision_object.obj_id:\n                if collision_object.is_colliding(obj):\n                    # A collision has been detected. Return the object that we are colliding with.\n                    return obj\n\n        # No collision was noticed. Return None.\n        return None", "code_tokens": "def query_collision ( collision_object ) : global collidable_objects # Note that we use a Brute Force approach for the time being. # It performs horribly under heavy loads, but it meets # our needs for the time being. for obj in collidable_objects : # Make sure we don't check ourself against ourself. if obj . obj_id is not collision_object . obj_id : if collision_object . is_colliding ( obj ) : # A collision has been detected. Return the object that we are colliding with. return obj # No collision was noticed. Return None. return None", "docstring_tokens": "Check to see if the specified object is colliding with any of the objects currently in the Collision Manager Returns the first object we are colliding with if there was a collision and None if no collisions was found", "label": 1}, {"idx": "cosqa-train-8428", "doc": "wrap string on multiple lines python", "code": "def wrap(string, length, indent):\n    \"\"\" Wrap a string at a line length \"\"\"\n    newline = \"\\n\" + \" \" * indent\n    return newline.join((string[i : i + length] for i in range(0, len(string), length)))", "code_tokens": "def wrap ( string , length , indent ) : newline = \"\\n\" + \" \" * indent return newline . join ( ( string [ i : i + length ] for i in range ( 0 , len ( string ) , length ) ) )", "docstring_tokens": "Wrap a string at a line length", "label": 1}, {"idx": "cosqa-train-8429", "doc": "python code for opening geojson file", "code": "def _loadfilepath(self, filepath, **kwargs):\n        \"\"\"This loads a geojson file into a geojson python\n        dictionary using the json module.\n        \n        Note: to load with a different text encoding use the encoding argument.\n        \"\"\"\n        with open(filepath, \"r\") as f:\n            data = json.load(f, **kwargs)\n        return data", "code_tokens": "def _loadfilepath ( self , filepath , * * kwargs ) : with open ( filepath , \"r\" ) as f : data = json . load ( f , * * kwargs ) return data", "docstring_tokens": "This loads a geojson file into a geojson python dictionary using the json module . Note : to load with a different text encoding use the encoding argument .", "label": 1}, {"idx": "cosqa-train-8430", "doc": "write a python program to kill a process, given the program name", "code": "def stop(pid):\n    \"\"\"Shut down a specific process.\n\n    Args:\n      pid: the pid of the process to shutdown.\n    \"\"\"\n    if psutil.pid_exists(pid):\n      try:\n        p = psutil.Process(pid)\n        p.kill()\n      except Exception:\n        pass", "code_tokens": "def stop ( pid ) : if psutil . pid_exists ( pid ) : try : p = psutil . Process ( pid ) p . kill ( ) except Exception : pass", "docstring_tokens": "Shut down a specific process .", "label": 1}, {"idx": "cosqa-train-8431", "doc": "python code for permission", "code": "def has_edit_permission(self, request):\n        \"\"\" Can edit this object \"\"\"\n        return request.user.is_authenticated and request.user.is_active and request.user.is_staff", "code_tokens": "def has_edit_permission ( self , request ) : return request . user . is_authenticated and request . user . is_active and request . user . is_staff", "docstring_tokens": "Can edit this object", "label": 1}, {"idx": "cosqa-train-8432", "doc": "python code input prompt for questions", "code": "def string_input(prompt=''):\n    \"\"\"Python 3 input()/Python 2 raw_input()\"\"\"\n    v = sys.version[0]\n    if v == '3':\n        return input(prompt)\n    else:\n        return raw_input(prompt)", "code_tokens": "def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )", "docstring_tokens": "Python 3 input () / Python 2 raw_input ()", "label": 1}, {"idx": "cosqa-train-8433", "doc": "write to stdout in python", "code": "def println(msg):\n    \"\"\"\n    Convenience function to print messages on a single line in the terminal\n    \"\"\"\n    sys.stdout.write(msg)\n    sys.stdout.flush()\n    sys.stdout.write('\\x08' * len(msg))\n    sys.stdout.flush()", "code_tokens": "def println ( msg ) : sys . stdout . write ( msg ) sys . stdout . flush ( ) sys . stdout . write ( '\\x08' * len ( msg ) ) sys . stdout . flush ( )", "docstring_tokens": "Convenience function to print messages on a single line in the terminal", "label": 0}, {"idx": "cosqa-train-8434", "doc": "python code remove duplicate labels", "code": "def get_labels(labels):\n    \"\"\"Create unique labels.\"\"\"\n    label_u = unique_labels(labels)\n    label_u_line = [i + \"_line\" for i in label_u]\n    return label_u, label_u_line", "code_tokens": "def get_labels ( labels ) : label_u = unique_labels ( labels ) label_u_line = [ i + \"_line\" for i in label_u ] return label_u , label_u_line", "docstring_tokens": "Create unique labels .", "label": 1}, {"idx": "cosqa-train-8435", "doc": "wxpython allow scrolling while disabled", "code": "def disable_wx(self):\n        \"\"\"Disable event loop integration with wxPython.\n\n        This merely sets PyOS_InputHook to NULL.\n        \"\"\"\n        if self._apps.has_key(GUI_WX):\n            self._apps[GUI_WX]._in_event_loop = False\n        self.clear_inputhook()", "code_tokens": "def disable_wx ( self ) : if self . _apps . has_key ( GUI_WX ) : self . _apps [ GUI_WX ] . _in_event_loop = False self . clear_inputhook ( )", "docstring_tokens": "Disable event loop integration with wxPython .", "label": 1}, {"idx": "cosqa-train-8436", "doc": "python code to change a variable type from string to float", "code": "def comma_converter(float_string):\n    \"\"\"Convert numbers to floats whether the decimal point is '.' or ','\"\"\"\n    trans_table = maketrans(b',', b'.')\n    return float(float_string.translate(trans_table))", "code_tokens": "def comma_converter ( float_string ) : trans_table = maketrans ( b',' , b'.' ) return float ( float_string . translate ( trans_table ) )", "docstring_tokens": "Convert numbers to floats whether the decimal point is . or", "label": 1}, {"idx": "cosqa-train-8437", "doc": "python code to display environment variables", "code": "def print_env_info(key, out=sys.stderr):\n    \"\"\"If given environment key is defined, print it out.\"\"\"\n    value = os.getenv(key)\n    if value is not None:\n        print(key, \"=\", repr(value), file=out)", "code_tokens": "def print_env_info ( key , out = sys . stderr ) : value = os . getenv ( key ) if value is not None : print ( key , \"=\" , repr ( value ) , file = out )", "docstring_tokens": "If given environment key is defined print it out .", "label": 1}, {"idx": "cosqa-train-8438", "doc": "wxpython copy image from one bitmap to another", "code": "def set_icon(self, bmp):\n        \"\"\"Sets main window icon to given wx.Bitmap\"\"\"\n\n        _icon = wx.EmptyIcon()\n        _icon.CopyFromBitmap(bmp)\n        self.SetIcon(_icon)", "code_tokens": "def set_icon ( self , bmp ) : _icon = wx . EmptyIcon ( ) _icon . CopyFromBitmap ( bmp ) self . SetIcon ( _icon )", "docstring_tokens": "Sets main window icon to given wx . Bitmap", "label": 0}, {"idx": "cosqa-train-8439", "doc": "python code to format multiple *args", "code": "def reprkwargs(kwargs, sep=', ', fmt=\"{0!s}={1!r}\"):\n    \"\"\"Display kwargs.\"\"\"\n    return sep.join(fmt.format(k, v) for k, v in kwargs.iteritems())", "code_tokens": "def reprkwargs ( kwargs , sep = ', ' , fmt = \"{0!s}={1!r}\" ) : return sep . join ( fmt . format ( k , v ) for k , v in kwargs . iteritems ( ) )", "docstring_tokens": "Display kwargs .", "label": 1}, {"idx": "cosqa-train-8440", "doc": "wxpython no attribute 'makemodal'", "code": "def disable_wx(self):\n        \"\"\"Disable event loop integration with wxPython.\n\n        This merely sets PyOS_InputHook to NULL.\n        \"\"\"\n        if self._apps.has_key(GUI_WX):\n            self._apps[GUI_WX]._in_event_loop = False\n        self.clear_inputhook()", "code_tokens": "def disable_wx ( self ) : if self . _apps . has_key ( GUI_WX ) : self . _apps [ GUI_WX ] . _in_event_loop = False self . clear_inputhook ( )", "docstring_tokens": "Disable event loop integration with wxPython .", "label": 1}, {"idx": "cosqa-train-8441", "doc": "python code to stop an instance", "code": "def _stop_instance(self):\n        \"\"\"Stop the instance.\"\"\"\n        instance = self._get_instance()\n        instance.stop()\n        self._wait_on_instance('stopped', self.timeout)", "code_tokens": "def _stop_instance ( self ) : instance = self . _get_instance ( ) instance . stop ( ) self . _wait_on_instance ( 'stopped' , self . timeout )", "docstring_tokens": "Stop the instance .", "label": 1}, {"idx": "cosqa-train-8442", "doc": "wxpython setting background color of static text", "code": "def _update_bordercolor(self, bordercolor):\n        \"\"\"Updates background color\"\"\"\n\n        border_color = wx.SystemSettings_GetColour(wx.SYS_COLOUR_ACTIVEBORDER)\n        border_color.SetRGB(bordercolor)\n\n        self.linecolor_choice.SetColour(border_color)", "code_tokens": "def _update_bordercolor ( self , bordercolor ) : border_color = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_ACTIVEBORDER ) border_color . SetRGB ( bordercolor ) self . linecolor_choice . SetColour ( border_color )", "docstring_tokens": "Updates background color", "label": 1}, {"idx": "cosqa-train-8443", "doc": "python code to verify valid email address", "code": "def validate_email(email):\n    \"\"\"\n    Validates an email address\n    Source: Himanshu Shankar (https://github.com/iamhssingh)\n    Parameters\n    ----------\n    email: str\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    from django.core.validators import validate_email\n    from django.core.exceptions import ValidationError\n    try:\n        validate_email(email)\n        return True\n    except ValidationError:\n        return False", "code_tokens": "def validate_email ( email ) : from django . core . validators import validate_email from django . core . exceptions import ValidationError try : validate_email ( email ) return True except ValidationError : return False", "docstring_tokens": "Validates an email address Source : Himanshu Shankar ( https : // github . com / iamhssingh ) Parameters ---------- email : str", "label": 0}, {"idx": "cosqa-train-8444", "doc": "wxpython textctrl color for some txt", "code": "def _update_fontcolor(self, fontcolor):\n        \"\"\"Updates text font color button\n\n        Parameters\n        ----------\n\n        fontcolor: Integer\n        \\tText color in integer RGB format\n\n        \"\"\"\n\n        textcolor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)\n        textcolor.SetRGB(fontcolor)\n\n        self.textcolor_choice.SetColour(textcolor)", "code_tokens": "def _update_fontcolor ( self , fontcolor ) : textcolor = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_WINDOWTEXT ) textcolor . SetRGB ( fontcolor ) self . textcolor_choice . SetColour ( textcolor )", "docstring_tokens": "Updates text font color button", "label": 0}, {"idx": "cosqa-train-8445", "doc": "python code words and lines", "code": "def get_codeblock(language, text):\n    \"\"\" Generates rst codeblock for given text and language \"\"\"\n    rst = \"\\n\\n.. code-block:: \" + language + \"\\n\\n\"\n    for line in text.splitlines():\n        rst += \"\\t\" + line + \"\\n\"\n\n    rst += \"\\n\"\n    return rst", "code_tokens": "def get_codeblock ( language , text ) : rst = \"\\n\\n.. code-block:: \" + language + \"\\n\\n\" for line in text . splitlines ( ) : rst += \"\\t\" + line + \"\\n\" rst += \"\\n\" return rst", "docstring_tokens": "Generates rst codeblock for given text and language", "label": 1}, {"idx": "cosqa-train-8446", "doc": "xml get parent node of element python", "code": "def root_parent(self, category=None):\n        \"\"\" Returns the topmost parent of the current category. \"\"\"\n        return next(filter(lambda c: c.is_root, self.hierarchy()))", "code_tokens": "def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )", "docstring_tokens": "Returns the topmost parent of the current category .", "label": 1}, {"idx": "cosqa-train-8447", "doc": "python column string mode", "code": "def format(x, format):\n    \"\"\"Uses http://www.cplusplus.com/reference/string/to_string/ for formatting\"\"\"\n    # don't change the dtype, otherwise for each block the dtype may be different (string length)\n    sl = vaex.strings.format(x, format)\n    return column.ColumnStringArrow(sl.bytes, sl.indices, sl.length, sl.offset, string_sequence=sl)", "code_tokens": "def format ( x , format ) : # don't change the dtype, otherwise for each block the dtype may be different (string length) sl = vaex . strings . format ( x , format ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "docstring_tokens": "Uses http : // www . cplusplus . com / reference / string / to_string / for formatting", "label": 0}, {"idx": "cosqa-train-8448", "doc": "python compare compare sets not in one set", "code": "def isetdiff_flags(list1, list2):\n    \"\"\"\n    move to util_iter\n    \"\"\"\n    set2 = set(list2)\n    return (item not in set2 for item in list1)", "code_tokens": "def isetdiff_flags ( list1 , list2 ) : set2 = set ( list2 ) return ( item not in set2 for item in list1 )", "docstring_tokens": "move to util_iter", "label": 1}, {"idx": "cosqa-train-8449", "doc": "xpath how to get all text inside an element python", "code": "def _extract_node_text(node):\n    \"\"\"Extract text from a given lxml node.\"\"\"\n\n    texts = map(\n        six.text_type.strip, map(six.text_type, map(unescape, node.xpath(\".//text()\")))\n    )\n    return \" \".join(text for text in texts if text)", "code_tokens": "def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( \".//text()\" ) ) ) ) return \" \" . join ( text for text in texts if text )", "docstring_tokens": "Extract text from a given lxml node .", "label": 0}, {"idx": "cosqa-train-8450", "doc": "python compare if files are the same", "code": "def is_same_file (filename1, filename2):\n    \"\"\"Check if filename1 and filename2 point to the same file object.\n    There can be false negatives, ie. the result is False, but it is\n    the same file anyway. Reason is that network filesystems can create\n    different paths to the same physical file.\n    \"\"\"\n    if filename1 == filename2:\n        return True\n    if os.name == 'posix':\n        return os.path.samefile(filename1, filename2)\n    return is_same_filename(filename1, filename2)", "code_tokens": "def is_same_file ( filename1 , filename2 ) : if filename1 == filename2 : return True if os . name == 'posix' : return os . path . samefile ( filename1 , filename2 ) return is_same_filename ( filename1 , filename2 )", "docstring_tokens": "Check if filename1 and filename2 point to the same file object . There can be false negatives ie . the result is False but it is the same file anyway . Reason is that network filesystems can create different paths to the same physical file .", "label": 0}, {"idx": "cosqa-train-8451", "doc": "python compare two ndarray equal", "code": "def allclose(a, b):\n    \"\"\"\n    Test that a and b are close and match in shape.\n\n    Parameters\n    ----------\n    a : ndarray\n        First array to check\n\n    b : ndarray\n        First array to check\n    \"\"\"\n    from numpy import allclose\n    return (a.shape == b.shape) and allclose(a, b)", "code_tokens": "def allclose ( a , b ) : from numpy import allclose return ( a . shape == b . shape ) and allclose ( a , b )", "docstring_tokens": "Test that a and b are close and match in shape .", "label": 1}, {"idx": "cosqa-train-8452", "doc": "yml file parser python", "code": "def _ParseYamlFromFile(filedesc):\n  \"\"\"Parses given YAML file.\"\"\"\n  content = filedesc.read()\n  return yaml.Parse(content) or collections.OrderedDict()", "code_tokens": "def _ParseYamlFromFile ( filedesc ) : content = filedesc . read ( ) return yaml . Parse ( content ) or collections . OrderedDict ( )", "docstring_tokens": "Parses given YAML file .", "label": 0}, {"idx": "cosqa-train-8453", "doc": "python compare two strings character by character", "code": "def compare(string1, string2):\n    \"\"\"Compare two strings while protecting against timing attacks\n\n    :param str string1: the first string\n    :param str string2: the second string\n\n    :returns: True if the strings are equal, False if not\n    :rtype: :obj:`bool`\n    \"\"\"\n    if len(string1) != len(string2):\n        return False\n    result = True\n    for c1, c2 in izip(string1, string2):\n        result &= c1 == c2\n    return result", "code_tokens": "def compare ( string1 , string2 ) : if len ( string1 ) != len ( string2 ) : return False result = True for c1 , c2 in izip ( string1 , string2 ) : result &= c1 == c2 return result", "docstring_tokens": "Compare two strings while protecting against timing attacks", "label": 0}, {"idx": "cosqa-train-8454", "doc": "zero array in python chainging dimension", "code": "def prox_zero(X, step):\n    \"\"\"Proximal operator to project onto zero\n    \"\"\"\n    return np.zeros(X.shape, dtype=X.dtype)", "code_tokens": "def prox_zero ( X , step ) : return np . zeros ( X . shape , dtype = X . dtype )", "docstring_tokens": "Proximal operator to project onto zero", "label": 0}, {"idx": "cosqa-train-8455", "doc": "python compare two strings for similiartiy", "code": "def compare(string1, string2):\n    \"\"\"Compare two strings while protecting against timing attacks\n\n    :param str string1: the first string\n    :param str string2: the second string\n\n    :returns: True if the strings are equal, False if not\n    :rtype: :obj:`bool`\n    \"\"\"\n    if len(string1) != len(string2):\n        return False\n    result = True\n    for c1, c2 in izip(string1, string2):\n        result &= c1 == c2\n    return result", "code_tokens": "def compare ( string1 , string2 ) : if len ( string1 ) != len ( string2 ) : return False result = True for c1 , c2 in izip ( string1 , string2 ) : result &= c1 == c2 return result", "docstring_tokens": "Compare two strings while protecting against timing attacks", "label": 1}, {"idx": "cosqa-train-8456", "doc": "python compare two xml", "code": "def are_equal_xml(a_xml, b_xml):\n    \"\"\"Normalize and compare XML documents for equality. The document may or may not be\n    a DataONE type.\n\n    Args:\n      a_xml: str\n      b_xml: str\n        XML documents to compare for equality.\n\n    Returns:\n      bool: ``True`` if the XML documents are semantically equivalent.\n\n    \"\"\"\n    a_dom = xml.dom.minidom.parseString(a_xml)\n    b_dom = xml.dom.minidom.parseString(b_xml)\n    return are_equal_elements(a_dom.documentElement, b_dom.documentElement)", "code_tokens": "def are_equal_xml ( a_xml , b_xml ) : a_dom = xml . dom . minidom . parseString ( a_xml ) b_dom = xml . dom . minidom . parseString ( b_xml ) return are_equal_elements ( a_dom . documentElement , b_dom . documentElement )", "docstring_tokens": "Normalize and compare XML documents for equality . The document may or may not be a DataONE type .", "label": 0}, {"idx": "cosqa-train-8457", "doc": "python compare float of number to integer", "code": "def _check_for_int(x):\n    \"\"\"\n    This is a compatibility function that takes a C{float} and converts it to an\n    C{int} if the values are equal.\n    \"\"\"\n    try:\n        y = int(x)\n    except (OverflowError, ValueError):\n        pass\n    else:\n        # There is no way in AMF0 to distinguish between integers and floats\n        if x == x and y == x:\n            return y\n\n    return x", "code_tokens": "def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x", "docstring_tokens": "This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal .", "label": 1}, {"idx": "cosqa-train-8458", "doc": "add callbacks \"page\" python", "code": "def register():\n    \"\"\"\n    Calls the shots, based on signals\n    \"\"\"\n    signals.article_generator_finalized.connect(link_source_files)\n    signals.page_generator_finalized.connect(link_source_files)\n    signals.page_writer_finalized.connect(write_source_files)", "code_tokens": "def register ( ) : signals . article_generator_finalized . connect ( link_source_files ) signals . page_generator_finalized . connect ( link_source_files ) signals . page_writer_finalized . connect ( write_source_files )", "docstring_tokens": "Calls the shots based on signals", "label": 1}, {"idx": "cosqa-train-8459", "doc": "python compare multiple strings", "code": "def compare(string1, string2):\n    \"\"\"Compare two strings while protecting against timing attacks\n\n    :param str string1: the first string\n    :param str string2: the second string\n\n    :returns: True if the strings are equal, False if not\n    :rtype: :obj:`bool`\n    \"\"\"\n    if len(string1) != len(string2):\n        return False\n    result = True\n    for c1, c2 in izip(string1, string2):\n        result &= c1 == c2\n    return result", "code_tokens": "def compare ( string1 , string2 ) : if len ( string1 ) != len ( string2 ) : return False result = True for c1 , c2 in izip ( string1 , string2 ) : result &= c1 == c2 return result", "docstring_tokens": "Compare two strings while protecting against timing attacks", "label": 1}, {"idx": "cosqa-train-8460", "doc": "close web browser connection \"webbrowser\" python", "code": "def quit(self):\n        \"\"\"\n        Closes the browser and shuts down the WebKitGTKDriver executable\n        that is started when starting the WebKitGTKDriver\n        \"\"\"\n        try:\n            RemoteWebDriver.quit(self)\n        except http_client.BadStatusLine:\n            pass\n        finally:\n            self.service.stop()", "code_tokens": "def quit ( self ) : try : RemoteWebDriver . quit ( self ) except http_client . BadStatusLine : pass finally : self . service . stop ( )", "docstring_tokens": "Closes the browser and shuts down the WebKitGTKDriver executable that is started when starting the WebKitGTKDriver", "label": 0}, {"idx": "cosqa-train-8461", "doc": "python compare uuid and string", "code": "def valid_uuid(value):\n    \"\"\" Check if value is a valid UUID. \"\"\"\n\n    try:\n        uuid.UUID(value, version=4)\n        return True\n    except (TypeError, ValueError, AttributeError):\n        return False", "code_tokens": "def valid_uuid ( value ) : try : uuid . UUID ( value , version = 4 ) return True except ( TypeError , ValueError , AttributeError ) : return False", "docstring_tokens": "Check if value is a valid UUID .", "label": 1}, {"idx": "cosqa-train-8462", "doc": "python argparse \"valid string\"", "code": "def email_type(arg):\n\t\"\"\"An argparse type representing an email address.\"\"\"\n\tif not is_valid_email_address(arg):\n\t\traise argparse.ArgumentTypeError(\"{0} is not a valid email address\".format(repr(arg)))\n\treturn arg", "code_tokens": "def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( \"{0} is not a valid email address\" . format ( repr ( arg ) ) ) return arg", "docstring_tokens": "An argparse type representing an email address .", "label": 1}, {"idx": "cosqa-train-8463", "doc": "python compare variable with type", "code": "def is_type(value):\n        \"\"\"Determine if value is an instance or subclass of the class Type.\"\"\"\n        if isinstance(value, type):\n            return issubclass(value, Type)\n        return isinstance(value, Type)", "code_tokens": "def is_type ( value ) : if isinstance ( value , type ) : return issubclass ( value , Type ) return isinstance ( value , Type )", "docstring_tokens": "Determine if value is an instance or subclass of the class Type .", "label": 1}, {"idx": "cosqa-train-8464", "doc": "python open file dialog \"no tkinter\"", "code": "def askopenfilename(**kwargs):\n    \"\"\"Return file name(s) from Tkinter's file open dialog.\"\"\"\n    try:\n        from Tkinter import Tk\n        import tkFileDialog as filedialog\n    except ImportError:\n        from tkinter import Tk, filedialog\n    root = Tk()\n    root.withdraw()\n    root.update()\n    filenames = filedialog.askopenfilename(**kwargs)\n    root.destroy()\n    return filenames", "code_tokens": "def askopenfilename ( * * kwargs ) : try : from Tkinter import Tk import tkFileDialog as filedialog except ImportError : from tkinter import Tk , filedialog root = Tk ( ) root . withdraw ( ) root . update ( ) filenames = filedialog . askopenfilename ( * * kwargs ) root . destroy ( ) return filenames", "docstring_tokens": "Return file name ( s ) from Tkinter s file open dialog .", "label": 1}, {"idx": "cosqa-train-8465", "doc": "python comparing two numpy arrays for equality", "code": "def numpy_aware_eq(a, b):\n    \"\"\"Return whether two objects are equal via recursion, using\n    :func:`numpy.array_equal` for comparing numpy arays.\n    \"\"\"\n    if isinstance(a, np.ndarray) or isinstance(b, np.ndarray):\n        return np.array_equal(a, b)\n    if ((isinstance(a, Iterable) and isinstance(b, Iterable)) and\n            not isinstance(a, str) and not isinstance(b, str)):\n        if len(a) != len(b):\n            return False\n        return all(numpy_aware_eq(x, y) for x, y in zip(a, b))\n    return a == b", "code_tokens": "def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b", "docstring_tokens": "Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays .", "label": 1}, {"idx": "cosqa-train-8466", "doc": "python3 can only concatenate str (not \"bytes\") to str", "code": "def to_str(s):\n    \"\"\"\n    Convert bytes and non-string into Python 3 str\n    \"\"\"\n    if isinstance(s, bytes):\n        s = s.decode('utf-8')\n    elif not isinstance(s, str):\n        s = str(s)\n    return s", "code_tokens": "def to_str ( s ) : if isinstance ( s , bytes ) : s = s . decode ( 'utf-8' ) elif not isinstance ( s , str ) : s = str ( s ) return s", "docstring_tokens": "Convert bytes and non - string into Python 3 str", "label": 1}, {"idx": "cosqa-train-8467", "doc": "python compute shannon entropy", "code": "def shannon_entropy(p):\n    \"\"\"Calculates shannon entropy in bits.\n\n    Parameters\n    ----------\n    p : np.array\n        array of probabilities\n\n    Returns\n    -------\n    shannon entropy in bits\n    \"\"\"\n    return -np.sum(np.where(p!=0, p * np.log2(p), 0))", "code_tokens": "def shannon_entropy ( p ) : return - np . sum ( np . where ( p != 0 , p * np . log2 ( p ) , 0 ) )", "docstring_tokens": "Calculates shannon entropy in bits .", "label": 1}, {"idx": "cosqa-train-8468", "doc": "sorting in python list \"date\"", "code": "def sort_fn_list(fn_list):\n    \"\"\"Sort input filename list by datetime\n    \"\"\"\n    dt_list = get_dt_list(fn_list)\n    fn_list_sort = [fn for (dt,fn) in sorted(zip(dt_list,fn_list))]\n    return fn_list_sort", "code_tokens": "def sort_fn_list ( fn_list ) : dt_list = get_dt_list ( fn_list ) fn_list_sort = [ fn for ( dt , fn ) in sorted ( zip ( dt_list , fn_list ) ) ] return fn_list_sort", "docstring_tokens": "Sort input filename list by datetime", "label": 0}, {"idx": "cosqa-train-8469", "doc": "python concantenate arrays along dimension", "code": "def _concatenate_virtual_arrays(arrs, cols=None, scaling=None):\n    \"\"\"Return a virtual concatenate of several NumPy arrays.\"\"\"\n    return None if not len(arrs) else ConcatenatedArrays(arrs, cols,\n                                                         scaling=scaling)", "code_tokens": "def _concatenate_virtual_arrays ( arrs , cols = None , scaling = None ) : return None if not len ( arrs ) else ConcatenatedArrays ( arrs , cols , scaling = scaling )", "docstring_tokens": "Return a virtual concatenate of several NumPy arrays .", "label": 1}, {"idx": "cosqa-train-8470", "doc": "'list of list to a dictionary of dictionary' python", "code": "def list_of_lists_to_dict(l):\n    \"\"\" Convert list of key,value lists to dict\n\n    [['id', 1], ['id', 2], ['id', 3], ['foo': 4]]\n    {'id': [1, 2, 3], 'foo': [4]}\n    \"\"\"\n    d = {}\n    for key, val in l:\n        d.setdefault(key, []).append(val)\n    return d", "code_tokens": "def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d", "docstring_tokens": "Convert list of key value lists to dict", "label": 0}, {"idx": "cosqa-train-8471", "doc": "python conda activate in bash shell script", "code": "def update(packages, env=None, user=None):\n    \"\"\"\n    Update conda packages in a conda env\n\n    Attributes\n    ----------\n        packages: list of packages comma delimited\n    \"\"\"\n    packages = ' '.join(packages.split(','))\n    cmd = _create_conda_cmd('update', args=[packages, '--yes', '-q'], env=env, user=user)\n    return _execcmd(cmd, user=user)", "code_tokens": "def update ( packages , env = None , user = None ) : packages = ' ' . join ( packages . split ( ',' ) ) cmd = _create_conda_cmd ( 'update' , args = [ packages , '--yes' , '-q' ] , env = env , user = user ) return _execcmd ( cmd , user = user )", "docstring_tokens": "Update conda packages in a conda env", "label": 0}, {"idx": "cosqa-train-8472", "doc": "/bin/yum not working in python", "code": "def yum_install(self, packages, ignore_error=False):\n        \"\"\"Install some packages on the remote host.\n\n        :param packages: ist of packages to install.\n        \"\"\"\n        return self.run('yum install -y --quiet ' + ' '.join(packages), ignore_error=ignore_error, retry=5)", "code_tokens": "def yum_install ( self , packages , ignore_error = False ) : return self . run ( 'yum install -y --quiet ' + ' ' . join ( packages ) , ignore_error = ignore_error , retry = 5 )", "docstring_tokens": "Install some packages on the remote host .", "label": 1}, {"idx": "cosqa-train-8473", "doc": "python config parser combine items into dict", "code": "def config_parser_to_dict(config_parser):\n    \"\"\"\n    Convert a ConfigParser to a dictionary.\n    \"\"\"\n    response = {}\n\n    for section in config_parser.sections():\n        for option in config_parser.options(section):\n            response.setdefault(section, {})[option] = config_parser.get(section, option)\n\n    return response", "code_tokens": "def config_parser_to_dict ( config_parser ) : response = { } for section in config_parser . sections ( ) : for option in config_parser . options ( section ) : response . setdefault ( section , { } ) [ option ] = config_parser . get ( section , option ) return response", "docstring_tokens": "Convert a ConfigParser to a dictionary .", "label": 1}, {"idx": "cosqa-train-8474", "doc": "403 response from python requests", "code": "def HttpResponse403(request, template=KEY_AUTH_403_TEMPLATE,\ncontent=KEY_AUTH_403_CONTENT, content_type=KEY_AUTH_403_CONTENT_TYPE):\n    \"\"\"\n    HTTP response for forbidden access (status code 403)\n    \"\"\"\n    return AccessFailedResponse(request, template, content, content_type, status=403)", "code_tokens": "def HttpResponse403 ( request , template = KEY_AUTH_403_TEMPLATE , content = KEY_AUTH_403_CONTENT , content_type = KEY_AUTH_403_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 403 )", "docstring_tokens": "HTTP response for forbidden access ( status code 403 )", "label": 0}, {"idx": "cosqa-train-8475", "doc": "python configparser get list of config sections", "code": "def items(self, section_name):\n        \"\"\":return: list((option, value), ...) pairs of all items in the given section\"\"\"\n        return [(k, v) for k, v in super(GitConfigParser, self).items(section_name) if k != '__name__']", "code_tokens": "def items ( self , section_name ) : return [ ( k , v ) for k , v in super ( GitConfigParser , self ) . items ( section_name ) if k != '__name__' ]", "docstring_tokens": ": return : list (( option value ) ... ) pairs of all items in the given section", "label": 1}, {"idx": "cosqa-train-8476", "doc": "`java` command is not found from this python process", "code": "def version_jar(self):\n\t\t\"\"\"\n\t\tSpecial case of version() when the executable is a JAR file.\n\t\t\"\"\"\n\t\tcmd = config.get_command('java')\n\t\tcmd.append('-jar')\n\t\tcmd += self.cmd\n\t\tself.version(cmd=cmd, path=self.cmd[0])", "code_tokens": "def version_jar ( self ) : cmd = config . get_command ( 'java' ) cmd . append ( '-jar' ) cmd += self . cmd self . version ( cmd = cmd , path = self . cmd [ 0 ] )", "docstring_tokens": "Special case of version () when the executable is a JAR file .", "label": 0}, {"idx": "cosqa-train-8477", "doc": "python configuration see if setting exists", "code": "def _is_already_configured(configuration_details):\n    \"\"\"Returns `True` when alias already in shell config.\"\"\"\n    path = Path(configuration_details.path).expanduser()\n    with path.open('r') as shell_config:\n        return configuration_details.content in shell_config.read()", "code_tokens": "def _is_already_configured ( configuration_details ) : path = Path ( configuration_details . path ) . expanduser ( ) with path . open ( 'r' ) as shell_config : return configuration_details . content in shell_config . read ( )", "docstring_tokens": "Returns True when alias already in shell config .", "label": 0}, {"idx": "cosqa-train-8478", "doc": "a list of month end dates in python", "code": "def get_month_start_end_day():\n    \"\"\"\n    Get the month start date a nd end date\n    \"\"\"\n    t = date.today()\n    n = mdays[t.month]\n    return (date(t.year, t.month, 1), date(t.year, t.month, n))", "code_tokens": "def get_month_start_end_day ( ) : t = date . today ( ) n = mdays [ t . month ] return ( date ( t . year , t . month , 1 ) , date ( t . year , t . month , n ) )", "docstring_tokens": "Get the month start date a nd end date", "label": 1}, {"idx": "cosqa-train-8479", "doc": "python connection displaying password prompt from stdin rather than connecting", "code": "def pass_from_pipe(cls):\n        \"\"\"Return password from pipe if not on TTY, else False.\n        \"\"\"\n        is_pipe = not sys.stdin.isatty()\n        return is_pipe and cls.strip_last_newline(sys.stdin.read())", "code_tokens": "def pass_from_pipe ( cls ) : is_pipe = not sys . stdin . isatty ( ) return is_pipe and cls . strip_last_newline ( sys . stdin . read ( ) )", "docstring_tokens": "Return password from pipe if not on TTY else False .", "label": 1}, {"idx": "cosqa-train-8480", "doc": "a python program to count the occurrences of each word in a given sentence", "code": "def count(lines):\n  \"\"\" Counts the word frequences in a list of sentences.\n\n  Note:\n    This is a helper function for parallel execution of `Vocabulary.from_text`\n    method.\n  \"\"\"\n  words = [w for l in lines for w in l.strip().split()]\n  return Counter(words)", "code_tokens": "def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )", "docstring_tokens": "Counts the word frequences in a list of sentences .", "label": 0}, {"idx": "cosqa-train-8481", "doc": "python convention naming wrapper list apply functions", "code": "def as_list(callable):\n    \"\"\"Convert a scalar validator in a list validator\"\"\"\n    @wraps(callable)\n    def wrapper(value_iter):\n        return [callable(value) for value in value_iter]\n\n    return wrapper", "code_tokens": "def as_list ( callable ) : @ wraps ( callable ) def wrapper ( value_iter ) : return [ callable ( value ) for value in value_iter ] return wrapper", "docstring_tokens": "Convert a scalar validator in a list validator", "label": 1}, {"idx": "cosqa-train-8482", "doc": "a table column at def function python", "code": "def top(n, width=WIDTH, style=STYLE):\n    \"\"\"Prints the top row of a table\"\"\"\n    return hrule(n, width, linestyle=STYLES[style].top)", "code_tokens": "def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )", "docstring_tokens": "Prints the top row of a table", "label": 0}, {"idx": "cosqa-train-8483", "doc": "python conver posixpath to string", "code": "def __unixify(self, s):\n        \"\"\" stupid windows. converts the backslash to forwardslash for consistency \"\"\"\n        return os.path.normpath(s).replace(os.sep, \"/\")", "code_tokens": "def __unixify ( self , s ) : return os . path . normpath ( s ) . replace ( os . sep , \"/\" )", "docstring_tokens": "stupid windows . converts the backslash to forwardslash for consistency", "label": 1}, {"idx": "cosqa-train-8484", "doc": "access dictionary key safely python", "code": "def get_from_human_key(self, key):\n        \"\"\"Return the key (aka database value) of a human key (aka Python identifier).\"\"\"\n        if key in self._identifier_map:\n            return self._identifier_map[key]\n        raise KeyError(key)", "code_tokens": "def get_from_human_key ( self , key ) : if key in self . _identifier_map : return self . _identifier_map [ key ] raise KeyError ( key )", "docstring_tokens": "Return the key ( aka database value ) of a human key ( aka Python identifier ) .", "label": 0}, {"idx": "cosqa-train-8485", "doc": "python converto json to string", "code": "def obj_to_string(obj, top=True):\n    \"\"\"\n    Turn an arbitrary object into a unicode string. If complex (dict/list/tuple), will be json-encoded.\n    \"\"\"\n    obj = prepare_for_json_encoding(obj)\n    if type(obj) == six.text_type:\n        return obj\n    return json.dumps(obj)", "code_tokens": "def obj_to_string ( obj , top = True ) : obj = prepare_for_json_encoding ( obj ) if type ( obj ) == six . text_type : return obj return json . dumps ( obj )", "docstring_tokens": "Turn an arbitrary object into a unicode string . If complex ( dict / list / tuple ) will be json - encoded .", "label": 0}, {"idx": "cosqa-train-8486", "doc": "access token in python without expiration", "code": "def get_oauth_token():\n    \"\"\"Retrieve a simple OAuth Token for use with the local http client.\"\"\"\n    url = \"{0}/token\".format(DEFAULT_ORIGIN[\"Origin\"])\n    r = s.get(url=url)\n    return r.json()[\"t\"]", "code_tokens": "def get_oauth_token ( ) : url = \"{0}/token\" . format ( DEFAULT_ORIGIN [ \"Origin\" ] ) r = s . get ( url = url ) return r . json ( ) [ \"t\" ]", "docstring_tokens": "Retrieve a simple OAuth Token for use with the local http client .", "label": 1}, {"idx": "cosqa-train-8487", "doc": "python copy attributes to object", "code": "def populate_obj(obj, attrs):\n    \"\"\"Populates an object's attributes using the provided dict\n    \"\"\"\n    for k, v in attrs.iteritems():\n        setattr(obj, k, v)", "code_tokens": "def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "docstring_tokens": "Populates an object s attributes using the provided dict", "label": 0}, {"idx": "cosqa-train-8488", "doc": "access type object name python", "code": "def typename(obj):\n    \"\"\"Returns the type of obj as a string. More descriptive and specific than\n    type(obj), and safe for any object, unlike __class__.\"\"\"\n    if hasattr(obj, '__class__'):\n        return getattr(obj, '__class__').__name__\n    else:\n        return type(obj).__name__", "code_tokens": "def typename ( obj ) : if hasattr ( obj , '__class__' ) : return getattr ( obj , '__class__' ) . __name__ else : return type ( obj ) . __name__", "docstring_tokens": "Returns the type of obj as a string . More descriptive and specific than type ( obj ) and safe for any object unlike __class__ .", "label": 1}, {"idx": "cosqa-train-8489", "doc": "python correctly specify tensorflow as a dependency", "code": "def unit_ball_L2(shape):\n  \"\"\"A tensorflow variable tranfomed to be constrained in a L2 unit ball.\n\n  EXPERIMENTAL: Do not use for adverserial examples if you need to be confident\n  they are strong attacks. We are not yet confident in this code.\n  \"\"\"\n  x = tf.Variable(tf.zeros(shape))\n  return constrain_L2(x)", "code_tokens": "def unit_ball_L2 ( shape ) : x = tf . Variable ( tf . zeros ( shape ) ) return constrain_L2 ( x )", "docstring_tokens": "A tensorflow variable tranfomed to be constrained in a L2 unit ball .", "label": 1}, {"idx": "cosqa-train-8490", "doc": "accessing a session in python", "code": "def _get_session():\n    \"\"\"Return (and memoize) a database session\"\"\"\n    session = getattr(g, '_session', None)\n    if session is None:\n        session = g._session = db.session()\n    return session", "code_tokens": "def _get_session ( ) : session = getattr ( g , '_session' , None ) if session is None : session = g . _session = db . session ( ) return session", "docstring_tokens": "Return ( and memoize ) a database session", "label": 1}, {"idx": "cosqa-train-8491", "doc": "python covert string to list by commas", "code": "def comma_delimited_to_list(list_param):\n    \"\"\"Convert comma-delimited list / string into a list of strings\n\n    :param list_param: Comma-delimited string\n    :type list_param: str | unicode\n    :return: A list of strings\n    :rtype: list\n    \"\"\"\n    if isinstance(list_param, list):\n        return list_param\n    if isinstance(list_param, str):\n        return list_param.split(',')\n    else:\n        return []", "code_tokens": "def comma_delimited_to_list ( list_param ) : if isinstance ( list_param , list ) : return list_param if isinstance ( list_param , str ) : return list_param . split ( ',' ) else : return [ ]", "docstring_tokens": "Convert comma - delimited list / string into a list of strings", "label": 1}, {"idx": "cosqa-train-8492", "doc": "add a header to a csv in python", "code": "def writeCSV(data, headers, csvFile):\n  \"\"\"Write data with column headers to a CSV.\"\"\"\n  with open(csvFile, \"wb\") as f:\n    writer = csv.writer(f, delimiter=\",\")\n    writer.writerow(headers)\n    writer.writerows(data)", "code_tokens": "def writeCSV ( data , headers , csvFile ) : with open ( csvFile , \"wb\" ) as f : writer = csv . writer ( f , delimiter = \",\" ) writer . writerow ( headers ) writer . writerows ( data )", "docstring_tokens": "Write data with column headers to a CSV .", "label": 1}, {"idx": "cosqa-train-8493", "doc": "python create a filter with cutoff frequency", "code": "def fft_bandpassfilter(data, fs, lowcut, highcut):\n    \"\"\"\n    http://www.swharden.com/blog/2009-01-21-signal-filtering-with-python/#comment-16801\n    \"\"\"\n    fft = np.fft.fft(data)\n    # n = len(data)\n    # timestep = 1.0 / fs\n    # freq = np.fft.fftfreq(n, d=timestep)\n    bp = fft.copy()\n\n    # Zero out fft coefficients\n    # bp[10:-10] = 0\n\n    # Normalise\n    # bp *= real(fft.dot(fft))/real(bp.dot(bp))\n\n    bp *= fft.dot(fft) / bp.dot(bp)\n\n    # must multipy by 2 to get the correct amplitude\n    ibp = 12 * np.fft.ifft(bp)\n    return ibp", "code_tokens": "def fft_bandpassfilter ( data , fs , lowcut , highcut ) : fft = np . fft . fft ( data ) # n = len(data) # timestep = 1.0 / fs # freq = np.fft.fftfreq(n, d=timestep) bp = fft . copy ( ) # Zero out fft coefficients # bp[10:-10] = 0 # Normalise # bp *= real(fft.dot(fft))/real(bp.dot(bp)) bp *= fft . dot ( fft ) / bp . dot ( bp ) # must multipy by 2 to get the correct amplitude ibp = 12 * np . fft . ifft ( bp ) return ibp", "docstring_tokens": "http : // www . swharden . com / blog / 2009 - 01 - 21 - signal - filtering - with - python / #comment - 16801", "label": 1}, {"idx": "cosqa-train-8494", "doc": "add linux permissions using python", "code": "def _MakeExecutable(self, metadata_script):\n    \"\"\"Add executable permissions to a file.\n\n    Args:\n      metadata_script: string, the path to the executable file.\n    \"\"\"\n    mode = os.stat(metadata_script).st_mode\n    os.chmod(metadata_script, mode | stat.S_IEXEC)", "code_tokens": "def _MakeExecutable ( self , metadata_script ) : mode = os . stat ( metadata_script ) . st_mode os . chmod ( metadata_script , mode | stat . S_IEXEC )", "docstring_tokens": "Add executable permissions to a file .", "label": 1}, {"idx": "cosqa-train-8495", "doc": "python create all the permutations", "code": "def circ_permutation(items):\n    \"\"\"Calculate the circular permutation for a given list of items.\"\"\"\n    permutations = []\n    for i in range(len(items)):\n        permutations.append(items[i:] + items[:i])\n    return permutations", "code_tokens": "def circ_permutation ( items ) : permutations = [ ] for i in range ( len ( items ) ) : permutations . append ( items [ i : ] + items [ : i ] ) return permutations", "docstring_tokens": "Calculate the circular permutation for a given list of items .", "label": 1}, {"idx": "cosqa-train-8496", "doc": "add millsecond to time stamp in python", "code": "def ms_to_datetime(ms):\n    \"\"\"\n    Converts a millisecond accuracy timestamp to a datetime\n    \"\"\"\n    dt = datetime.datetime.utcfromtimestamp(ms / 1000)\n    return dt.replace(microsecond=(ms % 1000) * 1000).replace(tzinfo=pytz.utc)", "code_tokens": "def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )", "docstring_tokens": "Converts a millisecond accuracy timestamp to a datetime", "label": 1}, {"idx": "cosqa-train-8497", "doc": "python create an ordered dict", "code": "def format_result(input):\n        \"\"\"From: http://stackoverflow.com/questions/13062300/convert-a-dict-to-sorted-dict-in-python\n        \"\"\"\n        items = list(iteritems(input))\n        return OrderedDict(sorted(items, key=lambda x: x[0]))", "code_tokens": "def format_result ( input ) : items = list ( iteritems ( input ) ) return OrderedDict ( sorted ( items , key = lambda x : x [ 0 ] ) )", "docstring_tokens": "From : http : // stackoverflow . com / questions / 13062300 / convert - a - dict - to - sorted - dict - in - python", "label": 0}, {"idx": "cosqa-train-8498", "doc": "add plot to document in python", "code": "def fill_document(doc):\n    \"\"\"Add a section, a subsection and some text to the document.\n\n    :param doc: the document\n    :type doc: :class:`pylatex.document.Document` instance\n    \"\"\"\n    with doc.create(Section('A section')):\n        doc.append('Some regular text and some ')\n        doc.append(italic('italic text. '))\n\n        with doc.create(Subsection('A subsection')):\n            doc.append('Also some crazy characters: $&#{}')", "code_tokens": "def fill_document ( doc ) : with doc . create ( Section ( 'A section' ) ) : doc . append ( 'Some regular text and some ' ) doc . append ( italic ( 'italic text. ' ) ) with doc . create ( Subsection ( 'A subsection' ) ) : doc . append ( 'Also some crazy characters: $&#{}' )", "docstring_tokens": "Add a section a subsection and some text to the document .", "label": 1}, {"idx": "cosqa-train-8499", "doc": "python create an ordereddict from a dict", "code": "def format_result(input):\n        \"\"\"From: http://stackoverflow.com/questions/13062300/convert-a-dict-to-sorted-dict-in-python\n        \"\"\"\n        items = list(iteritems(input))\n        return OrderedDict(sorted(items, key=lambda x: x[0]))", "code_tokens": "def format_result ( input ) : items = list ( iteritems ( input ) ) return OrderedDict ( sorted ( items , key = lambda x : x [ 0 ] ) )", "docstring_tokens": "From : http : // stackoverflow . com / questions / 13062300 / convert - a - dict - to - sorted - dict - in - python", "label": 0}, {"idx": "cosqa-train-8500", "doc": "add python code in markdown", "code": "def build_code(self, lang, body):\n        \"\"\"Wrap text with markdown specific flavour.\"\"\"\n        self.out.append(\"```\" + lang)\n        self.build_markdown(lang, body)\n        self.out.append(\"```\")", "code_tokens": "def build_code ( self , lang , body ) : self . out . append ( \"```\" + lang ) self . build_markdown ( lang , body ) self . out . append ( \"```\" )", "docstring_tokens": "Wrap text with markdown specific flavour .", "label": 1}, {"idx": "cosqa-train-8501", "doc": "python create and apply diffs", "code": "def default_diff(latest_config, current_config):\n    \"\"\"Determine if two revisions have actually changed.\"\"\"\n    # Pop off the fields we don't care about:\n    pop_no_diff_fields(latest_config, current_config)\n\n    diff = DeepDiff(\n        latest_config,\n        current_config,\n        ignore_order=True\n    )\n    return diff", "code_tokens": "def default_diff ( latest_config , current_config ) : # Pop off the fields we don't care about: pop_no_diff_fields ( latest_config , current_config ) diff = DeepDiff ( latest_config , current_config , ignore_order = True ) return diff", "docstring_tokens": "Determine if two revisions have actually changed .", "label": 0}, {"idx": "cosqa-train-8502", "doc": "add random noise python numpy", "code": "def add_noise(Y, sigma):\n    \"\"\"Adds noise to Y\"\"\"\n    return Y + np.random.normal(0, sigma, Y.shape)", "code_tokens": "def add_noise ( Y , sigma ) : return Y + np . random . normal ( 0 , sigma , Y . shape )", "docstring_tokens": "Adds noise to Y", "label": 1}, {"idx": "cosqa-train-8503", "doc": "python create folder is not exist", "code": "def check_create_folder(filename):\n    \"\"\"Check if the folder exisits. If not, create the folder\"\"\"\n    os.makedirs(os.path.dirname(filename), exist_ok=True)", "code_tokens": "def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )", "docstring_tokens": "Check if the folder exisits . If not create the folder", "label": 1}, {"idx": "cosqa-train-8504", "doc": "python create instance from string", "code": "def from_json_str(cls, json_str):\n    \"\"\"Convert json string representation into class instance.\n\n    Args:\n      json_str: json representation as string.\n\n    Returns:\n      New instance of the class with data loaded from json string.\n    \"\"\"\n    return cls.from_json(json.loads(json_str, cls=JsonDecoder))", "code_tokens": "def from_json_str ( cls , json_str ) : return cls . from_json ( json . loads ( json_str , cls = JsonDecoder ) )", "docstring_tokens": "Convert json string representation into class instance .", "label": 1}, {"idx": "cosqa-train-8505", "doc": "alembic python model file", "code": "def load_model_from_package(name, **overrides):\n    \"\"\"Load a model from an installed package.\"\"\"\n    cls = importlib.import_module(name)\n    return cls.load(**overrides)", "code_tokens": "def load_model_from_package ( name , * * overrides ) : cls = importlib . import_module ( name ) return cls . load ( * * overrides )", "docstring_tokens": "Load a model from an installed package .", "label": 1}, {"idx": "cosqa-train-8506", "doc": "python create pdf rfrom images", "code": "def save_image(pdf_path, img_path, page_num):\n    \"\"\"\n\n    Creates images for a page of the input pdf document and saves it\n    at img_path.\n\n    :param pdf_path: path to pdf to create images for.\n    :param img_path: path where to save the images.\n    :param page_num: page number to create image from in the pdf file.\n    :return:\n    \"\"\"\n    pdf_img = Image(filename=\"{}[{}]\".format(pdf_path, page_num))\n    with pdf_img.convert(\"png\") as converted:\n        # Set white background.\n        converted.background_color = Color(\"white\")\n        converted.alpha_channel = \"remove\"\n        converted.save(filename=img_path)", "code_tokens": "def save_image ( pdf_path , img_path , page_num ) : pdf_img = Image ( filename = \"{}[{}]\" . format ( pdf_path , page_num ) ) with pdf_img . convert ( \"png\" ) as converted : # Set white background. converted . background_color = Color ( \"white\" ) converted . alpha_channel = \"remove\" converted . save ( filename = img_path )", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-8507", "doc": "all types of variables in python", "code": "def types(self):\n        \"\"\"\n        Return a list of all the variable types that exist in the\n        Variables object.\n        \"\"\"\n        output = set()\n        for var in self.values():\n            if var.has_value():\n                output.update(var.types())\n        return list(output)", "code_tokens": "def types ( self ) : output = set ( ) for var in self . values ( ) : if var . has_value ( ) : output . update ( var . types ( ) ) return list ( output )", "docstring_tokens": "Return a list of all the variable types that exist in the Variables object .", "label": 0}, {"idx": "cosqa-train-8508", "doc": "python creating an html table that you can add on to", "code": "def index():\n    \"\"\" Display productpage with normal user and test user buttons\"\"\"\n    global productpage\n\n    table = json2html.convert(json = json.dumps(productpage),\n                              table_attributes=\"class=\\\"table table-condensed table-bordered table-hover\\\"\")\n\n    return render_template('index.html', serviceTable=table)", "code_tokens": "def index ( ) : global productpage table = json2html . convert ( json = json . dumps ( productpage ) , table_attributes = \"class=\\\"table table-condensed table-bordered table-hover\\\"\" ) return render_template ( 'index.html' , serviceTable = table )", "docstring_tokens": "Display productpage with normal user and test user buttons", "label": 0}, {"idx": "cosqa-train-8509", "doc": "allow in secure connection python requests", "code": "def send_request(self, *args, **kwargs):\n        \"\"\"Wrapper for session.request\n        Handle connection reset error even from pyopenssl\n        \"\"\"\n        try:\n            return self.session.request(*args, **kwargs)\n        except ConnectionError:\n            self.session.close()\n            return self.session.request(*args, **kwargs)", "code_tokens": "def send_request ( self , * args , * * kwargs ) : try : return self . session . request ( * args , * * kwargs ) except ConnectionError : self . session . close ( ) return self . session . request ( * args , * * kwargs )", "docstring_tokens": "Wrapper for session . request Handle connection reset error even from pyopenssl", "label": 1}, {"idx": "cosqa-train-8510", "doc": "python crop an image specified pixels", "code": "def crop_box(im, box=False, **kwargs):\n    \"\"\"Uses box coordinates to crop an image without resizing it first.\"\"\"\n    if box:\n        im = im.crop(box)\n    return im", "code_tokens": "def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im", "docstring_tokens": "Uses box coordinates to crop an image without resizing it first .", "label": 0}, {"idx": "cosqa-train-8511", "doc": "anaconda python3 5 tensorflow", "code": "def transformer_ae_a3():\n  \"\"\"Set of hyperparameters.\"\"\"\n  hparams = transformer_ae_base()\n  hparams.batch_size = 4096\n  hparams.layer_prepostprocess_dropout = 0.3\n  hparams.optimizer = \"Adafactor\"\n  hparams.learning_rate = 0.25\n  hparams.learning_rate_warmup_steps = 10000\n  return hparams", "code_tokens": "def transformer_ae_a3 ( ) : hparams = transformer_ae_base ( ) hparams . batch_size = 4096 hparams . layer_prepostprocess_dropout = 0.3 hparams . optimizer = \"Adafactor\" hparams . learning_rate = 0.25 hparams . learning_rate_warmup_steps = 10000 return hparams", "docstring_tokens": "Set of hyperparameters .", "label": 0}, {"idx": "cosqa-train-8512", "doc": "python csv dictreader as dictionary", "code": "def csv_to_dicts(file, header=None):\n    \"\"\"Reads a csv and returns a List of Dicts with keys given by header row.\"\"\"\n    with open(file) as csvfile:\n        return [row for row in csv.DictReader(csvfile, fieldnames=header)]", "code_tokens": "def csv_to_dicts ( file , header = None ) : with open ( file ) as csvfile : return [ row for row in csv . DictReader ( csvfile , fieldnames = header ) ]", "docstring_tokens": "Reads a csv and returns a List of Dicts with keys given by header row .", "label": 0}, {"idx": "cosqa-train-8513", "doc": "angle between two vector python", "code": "def vec_angle(a, b):\n    \"\"\"\n    Calculate angle between two vectors\n    \"\"\"\n    cosang = np.dot(a, b)\n    sinang = fast_norm(np.cross(a, b))\n    return np.arctan2(sinang, cosang)", "code_tokens": "def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )", "docstring_tokens": "Calculate angle between two vectors", "label": 1}, {"idx": "cosqa-train-8514", "doc": "python ctypes allocate buffer numpy", "code": "def _ram_buffer(self):\n        \"\"\"Setup the RAM buffer from the C++ code.\"\"\"\n        # get the address of the RAM\n        address = _LIB.Memory(self._env)\n        # create a buffer from the contents of the address location\n        buffer_ = ctypes.cast(address, ctypes.POINTER(RAM_VECTOR)).contents\n        # create a NumPy array from the buffer\n        return np.frombuffer(buffer_, dtype='uint8')", "code_tokens": "def _ram_buffer ( self ) : # get the address of the RAM address = _LIB . Memory ( self . _env ) # create a buffer from the contents of the address location buffer_ = ctypes . cast ( address , ctypes . POINTER ( RAM_VECTOR ) ) . contents # create a NumPy array from the buffer return np . frombuffer ( buffer_ , dtype = 'uint8' )", "docstring_tokens": "Setup the RAM buffer from the C ++ code .", "label": 0}, {"idx": "cosqa-train-8515", "doc": "angle of rotation using matrices in python", "code": "def create_rot2d(angle):\n    \"\"\"Create 2D rotation matrix\"\"\"\n    ca = math.cos(angle)\n    sa = math.sin(angle)\n    return np.array([[ca, -sa], [sa, ca]])", "code_tokens": "def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )", "docstring_tokens": "Create 2D rotation matrix", "label": 1}, {"idx": "cosqa-train-8516", "doc": "python ctypes callback function example", "code": "def _monitor_callback_wrapper(callback):\n    \"\"\"A wrapper for the user-defined handle.\"\"\"\n    def callback_handle(name, array, _):\n        \"\"\" ctypes function \"\"\"\n        callback(name, array)\n    return callback_handle", "code_tokens": "def _monitor_callback_wrapper ( callback ) : def callback_handle ( name , array , _ ) : \"\"\" ctypes function \"\"\" callback ( name , array ) return callback_handle", "docstring_tokens": "A wrapper for the user - defined handle .", "label": 0}, {"idx": "cosqa-train-8517", "doc": "api response properties in python", "code": "def experiment_property(prop):\n    \"\"\"Get a property of the experiment by name.\"\"\"\n    exp = experiment(session)\n    p = getattr(exp, prop)\n    return success_response(field=prop, data=p, request_type=prop)", "code_tokens": "def experiment_property ( prop ) : exp = experiment ( session ) p = getattr ( exp , prop ) return success_response ( field = prop , data = p , request_type = prop )", "docstring_tokens": "Get a property of the experiment by name .", "label": 1}, {"idx": "cosqa-train-8518", "doc": "python ctypes load dll dependancies", "code": "def _windowsLdmodTargets(target, source, env, for_signature):\n    \"\"\"Get targets for loadable modules.\"\"\"\n    return _dllTargets(target, source, env, for_signature, 'LDMODULE')", "code_tokens": "def _windowsLdmodTargets ( target , source , env , for_signature ) : return _dllTargets ( target , source , env , for_signature , 'LDMODULE' )", "docstring_tokens": "Get targets for loadable modules .", "label": 1}, {"idx": "cosqa-train-8519", "doc": "append javascript to html python", "code": "def add_to_js(self, name, var):\n        \"\"\"Add an object to Javascript.\"\"\"\n        frame = self.page().mainFrame()\n        frame.addToJavaScriptWindowObject(name, var)", "code_tokens": "def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )", "docstring_tokens": "Add an object to Javascript .", "label": 1}, {"idx": "cosqa-train-8520", "doc": "python cumulative sum of list elements", "code": "def cumsum(inlist):\n    \"\"\"\nReturns a list consisting of the cumulative sum of the items in the\npassed list.\n\nUsage:   lcumsum(inlist)\n\"\"\"\n    newlist = copy.deepcopy(inlist)\n    for i in range(1, len(newlist)):\n        newlist[i] = newlist[i] + newlist[i - 1]\n    return newlist", "code_tokens": "def cumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist", "docstring_tokens": "Returns a list consisting of the cumulative sum of the items in the passed list .", "label": 0}, {"idx": "cosqa-train-8521", "doc": "appium python spinner scroll to", "code": "def mouse_out(self):\n        \"\"\"\n        Performs a mouse out the element.\n\n        Currently works only on Chrome driver.\n        \"\"\"\n        self.scroll_to()\n        ActionChains(self.parent.driver).move_by_offset(0, 0).click().perform()", "code_tokens": "def mouse_out ( self ) : self . scroll_to ( ) ActionChains ( self . parent . driver ) . move_by_offset ( 0 , 0 ) . click ( ) . perform ( )", "docstring_tokens": "Performs a mouse out the element .", "label": 1}, {"idx": "cosqa-train-8522", "doc": "python curses allow print", "code": "def auto():\n\t\"\"\"set colouring on if STDOUT is a terminal device, off otherwise\"\"\"\n\ttry:\n\t\tStyle.enabled = False\n\t\tStyle.enabled = sys.stdout.isatty()\n\texcept (AttributeError, TypeError):\n\t\tpass", "code_tokens": "def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass", "docstring_tokens": "set colouring on if STDOUT is a terminal device off otherwise", "label": 0}, {"idx": "cosqa-train-8523", "doc": "apply lambda python function with multiple inputs", "code": "def compose(*funcs):\n    \"\"\"compose a list of functions\"\"\"\n    return lambda x: reduce(lambda v, f: f(v), reversed(funcs), x)", "code_tokens": "def compose ( * funcs ) : return lambda x : reduce ( lambda v , f : f ( v ) , reversed ( funcs ) , x )", "docstring_tokens": "compose a list of functions", "label": 1}, {"idx": "cosqa-train-8524", "doc": "python custom type from list comprehension", "code": "def coerce(self, value):\n        \"\"\"Convert from whatever is given to a list of scalars for the lookup_field.\"\"\"\n        if isinstance(value, dict):\n            value = [value]\n        if not isiterable_notstring(value):\n            value = [value]\n        return [coerce_single_instance(self.lookup_field, v) for v in value]", "code_tokens": "def coerce ( self , value ) : if isinstance ( value , dict ) : value = [ value ] if not isiterable_notstring ( value ) : value = [ value ] return [ coerce_single_instance ( self . lookup_field , v ) for v in value ]", "docstring_tokens": "Convert from whatever is given to a list of scalars for the lookup_field .", "label": 1}, {"idx": "cosqa-train-8525", "doc": "apply lowercase function in series python", "code": "def downcaseTokens(s,l,t):\n    \"\"\"Helper parse action to convert tokens to lower case.\"\"\"\n    return [ tt.lower() for tt in map(_ustr,t) ]", "code_tokens": "def downcaseTokens ( s , l , t ) : return [ tt . lower ( ) for tt in map ( _ustr , t ) ]", "docstring_tokens": "Helper parse action to convert tokens to lower case .", "label": 1}, {"idx": "cosqa-train-8526", "doc": "python cut string by length", "code": "def split_len(s, length):\n    \"\"\"split string *s* into list of strings no longer than *length*\"\"\"\n    return [s[i:i+length] for i in range(0, len(s), length)]", "code_tokens": "def split_len ( s , length ) : return [ s [ i : i + length ] for i in range ( 0 , len ( s ) , length ) ]", "docstring_tokens": "split string * s * into list of strings no longer than * length *", "label": 1}, {"idx": "cosqa-train-8527", "doc": "apply python fucntion to each row", "code": "def transform(self, df):\n        \"\"\"\n        Transforms a DataFrame in place. Computes all outputs of the DataFrame.\n\n        Args:\n            df (pandas.DataFrame): DataFrame to transform.\n        \"\"\"\n        for name, function in self.outputs:\n            df[name] = function(df)", "code_tokens": "def transform ( self , df ) : for name , function in self . outputs : df [ name ] = function ( df )", "docstring_tokens": "Transforms a DataFrame in place . Computes all outputs of the DataFrame .", "label": 0}, {"idx": "cosqa-train-8528", "doc": "python cv2 pixel viewer", "code": "def screen_cv2(self):\n        \"\"\"cv2 Image of current window screen\"\"\"\n        pil_image = self.screen.convert('RGB')\n        cv2_image = np.array(pil_image)\n        pil_image.close()\n        # Convert RGB to BGR \n        cv2_image = cv2_image[:, :, ::-1]\n        return cv2_image", "code_tokens": "def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR \n cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image", "docstring_tokens": "cv2 Image of current window screen", "label": 1}, {"idx": "cosqa-train-8529", "doc": "applying fourier transform to image using python on windows", "code": "def translate_fourier(image, dx):\n    \"\"\" Translate an image in fourier-space with plane waves \"\"\"\n    N = image.shape[0]\n\n    f = 2*np.pi*np.fft.fftfreq(N)\n    kx,ky,kz = np.meshgrid(*(f,)*3, indexing='ij')\n    kv = np.array([kx,ky,kz]).T\n\n    q = np.fft.fftn(image)*np.exp(-1.j*(kv*dx).sum(axis=-1)).T\n    return np.real(np.fft.ifftn(q))", "code_tokens": "def translate_fourier ( image , dx ) : N = image . shape [ 0 ] f = 2 * np . pi * np . fft . fftfreq ( N ) kx , ky , kz = np . meshgrid ( * ( f , ) * 3 , indexing = 'ij' ) kv = np . array ( [ kx , ky , kz ] ) . T q = np . fft . fftn ( image ) * np . exp ( - 1.j * ( kv * dx ) . sum ( axis = - 1 ) ) . T return np . real ( np . fft . ifftn ( q ) )", "docstring_tokens": "Translate an image in fourier - space with plane waves", "label": 1}, {"idx": "cosqa-train-8530", "doc": "python cv2 rgb to hsv", "code": "def hex_to_hsv(color):\n    \"\"\"\n    Converts from hex to hsv\n\n    Parameters:\n    -----------\n            color : string\n                    Color representation on color\n\n    Example:\n            hex_to_hsv('#ff9933')\n    \"\"\"\n    color = normalize(color)\n    color = color[1:]\n    # color=tuple(ord(c)/255.0 for c in color.decode('hex'))\n    color = (int(color[0:2], base=16) / 255.0, int(color[2:4],\n                                                   base=16) / 255.0, int(color[4:6], base=16) / 255.0)\n    return colorsys.rgb_to_hsv(*color)", "code_tokens": "def hex_to_hsv ( color ) : color = normalize ( color ) color = color [ 1 : ] # color=tuple(ord(c)/255.0 for c in color.decode('hex')) color = ( int ( color [ 0 : 2 ] , base = 16 ) / 255.0 , int ( color [ 2 : 4 ] , base = 16 ) / 255.0 , int ( color [ 4 : 6 ] , base = 16 ) / 255.0 ) return colorsys . rgb_to_hsv ( * color )", "docstring_tokens": "Converts from hex to hsv", "label": 1}, {"idx": "cosqa-train-8531", "doc": "applying gain to certain frequency range in python", "code": "def enbw(wnd):\n  \"\"\" Equivalent Noise Bandwidth in bins (Processing Gain reciprocal). \"\"\"\n  return sum(el ** 2 for el in wnd) / sum(wnd) ** 2 * len(wnd)", "code_tokens": "def enbw ( wnd ) : return sum ( el ** 2 for el in wnd ) / sum ( wnd ) ** 2 * len ( wnd )", "docstring_tokens": "Equivalent Noise Bandwidth in bins ( Processing Gain reciprocal ) .", "label": 1}, {"idx": "cosqa-train-8532", "doc": "python data frame outer join", "code": "def _join(verb):\n    \"\"\"\n    Join helper\n    \"\"\"\n    data = pd.merge(verb.x, verb.y, **verb.kwargs)\n\n    # Preserve x groups\n    if isinstance(verb.x, GroupedDataFrame):\n        data.plydata_groups = list(verb.x.plydata_groups)\n    return data", "code_tokens": "def _join ( verb ) : data = pd . merge ( verb . x , verb . y , * * verb . kwargs ) # Preserve x groups if isinstance ( verb . x , GroupedDataFrame ) : data . plydata_groups = list ( verb . x . plydata_groups ) return data", "docstring_tokens": "Join helper", "label": 1}, {"idx": "cosqa-train-8533", "doc": "array of 10 zeros in python", "code": "def zeros(self, name, **kwargs):\n        \"\"\"Create an array. Keyword arguments as per\n        :func:`zarr.creation.zeros`.\"\"\"\n        return self._write_op(self._zeros_nosync, name, **kwargs)", "code_tokens": "def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )", "docstring_tokens": "Create an array . Keyword arguments as per : func : zarr . creation . zeros .", "label": 0}, {"idx": "cosqa-train-8534", "doc": "python data sort multiple columns", "code": "def sort_data(data, cols):\n    \"\"\"Sort `data` rows and order columns\"\"\"\n    return data.sort_values(cols)[cols + ['value']].reset_index(drop=True)", "code_tokens": "def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )", "docstring_tokens": "Sort data rows and order columns", "label": 0}, {"idx": "cosqa-train-8535", "doc": "array of zeros in python", "code": "def zeros(self, name, **kwargs):\n        \"\"\"Create an array. Keyword arguments as per\n        :func:`zarr.creation.zeros`.\"\"\"\n        return self._write_op(self._zeros_nosync, name, **kwargs)", "code_tokens": "def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )", "docstring_tokens": "Create an array . Keyword arguments as per : func : zarr . creation . zeros .", "label": 1}, {"idx": "cosqa-train-8536", "doc": "python database close ocnnectio", "code": "def cleanup(self, app):\n        \"\"\"Close all connections.\"\"\"\n        if hasattr(self.database.obj, 'close_all'):\n            self.database.close_all()", "code_tokens": "def cleanup ( self , app ) : if hasattr ( self . database . obj , 'close_all' ) : self . database . close_all ( )", "docstring_tokens": "Close all connections .", "label": 0}, {"idx": "cosqa-train-8537", "doc": "array to sql python", "code": "def adapt_array(arr):\n    \"\"\"\n    Adapts a Numpy array into an ARRAY string to put into the database.\n\n    Parameters\n    ----------\n    arr: array\n        The Numpy array to be adapted into an ARRAY type that can be inserted into a SQL file.\n\n    Returns\n    -------\n    ARRAY\n            The adapted array object\n\n    \"\"\"\n    out = io.BytesIO()\n    np.save(out, arr), out.seek(0)\n    return buffer(out.read())", "code_tokens": "def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) , out . seek ( 0 ) return buffer ( out . read ( ) )", "docstring_tokens": "Adapts a Numpy array into an ARRAY string to put into the database .", "label": 1}, {"idx": "cosqa-train-8538", "doc": "python datetime add timezone naive to local", "code": "def make_aware(dt):\n    \"\"\"Appends tzinfo and assumes UTC, if datetime object has no tzinfo already.\"\"\"\n    return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)", "code_tokens": "def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "docstring_tokens": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already .", "label": 0}, {"idx": "cosqa-train-8539", "doc": "artifactory python nested indexes", "code": "def __init__(self, collection, index_type_obj):\n        \"\"\"\n            Constructs wrapper for general index creation and deletion\n\n            :param collection Collection\n            :param index_type_obj BaseIndex Object of a index sub-class\n        \"\"\"\n\n        self.collection = collection\n        self.index_type_obj = index_type_obj", "code_tokens": "def __init__ ( self , collection , index_type_obj ) : self . collection = collection self . index_type_obj = index_type_obj", "docstring_tokens": "Constructs wrapper for general index creation and deletion", "label": 1}, {"idx": "cosqa-train-8540", "doc": "python datetime change timezone without pytz", "code": "def make_aware(dt):\n    \"\"\"Appends tzinfo and assumes UTC, if datetime object has no tzinfo already.\"\"\"\n    return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)", "code_tokens": "def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "docstring_tokens": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already .", "label": 0}, {"idx": "cosqa-train-8541", "doc": "auto generate documentation python", "code": "def setup(app):\n    \"\"\"Allow this package to be used as Sphinx extension.\n    This is also called from the top-level ``__init__.py``.\n\n    :type app: sphinx.application.Sphinx\n    \"\"\"\n    from .patches import patch_django_for_autodoc\n\n    # When running, make sure Django doesn't execute querysets\n    patch_django_for_autodoc()\n\n    # Generate docstrings for Django model fields\n    # Register the docstring processor with sphinx\n    app.connect('autodoc-process-docstring', improve_model_docstring)\n\n    # influence skip rules\n    app.connect(\"autodoc-skip-member\", autodoc_skip)", "code_tokens": "def setup ( app ) : from . patches import patch_django_for_autodoc # When running, make sure Django doesn't execute querysets patch_django_for_autodoc ( ) # Generate docstrings for Django model fields # Register the docstring processor with sphinx app . connect ( 'autodoc-process-docstring' , improve_model_docstring ) # influence skip rules app . connect ( \"autodoc-skip-member\" , autodoc_skip )", "docstring_tokens": "Allow this package to be used as Sphinx extension . This is also called from the top - level __init__ . py .", "label": 0}, {"idx": "cosqa-train-8542", "doc": "python datetime covert for arrays", "code": "def _possibly_convert_objects(values):\n    \"\"\"Convert arrays of datetime.datetime and datetime.timedelta objects into\n    datetime64 and timedelta64, according to the pandas convention.\n    \"\"\"\n    return np.asarray(pd.Series(values.ravel())).reshape(values.shape)", "code_tokens": "def _possibly_convert_objects ( values ) : return np . asarray ( pd . Series ( values . ravel ( ) ) ) . reshape ( values . shape )", "docstring_tokens": "Convert arrays of datetime . datetime and datetime . timedelta objects into datetime64 and timedelta64 according to the pandas convention .", "label": 1}, {"idx": "cosqa-train-8543", "doc": "automatic ctypes wrapper python", "code": "def get_ctype(rtype, cfunc, *args):\n    \"\"\" Call a C function that takes a pointer as its last argument and\n        return the C object that it contains after the function has finished.\n\n    :param rtype:   C data type is filled by the function\n    :param cfunc:   C function to call\n    :param args:    Arguments to call function with\n    :return:        A pointer to the specified data type\n    \"\"\"\n    val_p = backend.ffi.new(rtype)\n    args = args + (val_p,)\n    cfunc(*args)\n    return val_p[0]", "code_tokens": "def get_ctype ( rtype , cfunc , * args ) : val_p = backend . ffi . new ( rtype ) args = args + ( val_p , ) cfunc ( * args ) return val_p [ 0 ]", "docstring_tokens": "Call a C function that takes a pointer as its last argument and return the C object that it contains after the function has finished .", "label": 1}, {"idx": "cosqa-train-8544", "doc": "python datetime epoch millisecond format", "code": "def convertDatetime(t):\n    \"\"\"\n    Converts the specified datetime object into its appropriate protocol\n    value. This is the number of milliseconds from the epoch.\n    \"\"\"\n    epoch = datetime.datetime.utcfromtimestamp(0)\n    delta = t - epoch\n    millis = delta.total_seconds() * 1000\n    return int(millis)", "code_tokens": "def convertDatetime ( t ) : epoch = datetime . datetime . utcfromtimestamp ( 0 ) delta = t - epoch millis = delta . total_seconds ( ) * 1000 return int ( millis )", "docstring_tokens": "Converts the specified datetime object into its appropriate protocol value . This is the number of milliseconds from the epoch .", "label": 1}, {"idx": "cosqa-train-8545", "doc": "average value of an array python", "code": "def variance(arr):\n  \"\"\"variance of the values, must have 2 or more entries.\n\n  :param arr: list of numbers\n  :type arr: number[] a number array\n  :return: variance\n  :rtype: float\n\n  \"\"\"\n  avg = average(arr)\n  return sum([(float(x)-avg)**2 for x in arr])/float(len(arr)-1)", "code_tokens": "def variance ( arr ) : avg = average ( arr ) return sum ( [ ( float ( x ) - avg ) ** 2 for x in arr ] ) / float ( len ( arr ) - 1 )", "docstring_tokens": "variance of the values must have 2 or more entries .", "label": 0}, {"idx": "cosqa-train-8546", "doc": "python datetime from timestamp microsecond", "code": "def timestamp_to_datetime(timestamp):\n    \"\"\"Convert an ARF timestamp to a datetime.datetime object (naive local time)\"\"\"\n    from datetime import datetime, timedelta\n    obj = datetime.fromtimestamp(timestamp[0])\n    return obj + timedelta(microseconds=int(timestamp[1]))", "code_tokens": "def timestamp_to_datetime ( timestamp ) : from datetime import datetime , timedelta obj = datetime . fromtimestamp ( timestamp [ 0 ] ) return obj + timedelta ( microseconds = int ( timestamp [ 1 ] ) )", "docstring_tokens": "Convert an ARF timestamp to a datetime . datetime object ( naive local time )", "label": 0}, {"idx": "cosqa-train-8547", "doc": "aws lambda python read a file from code commit", "code": "def lambda_from_file(python_file):\n    \"\"\"\n    Reads a python file and returns a awslambda.Code object\n    :param python_file:\n    :return:\n    \"\"\"\n    lambda_function = []\n    with open(python_file, 'r') as f:\n        lambda_function.extend(f.read().splitlines())\n\n    return awslambda.Code(ZipFile=(Join('\\n', lambda_function)))", "code_tokens": "def lambda_from_file ( python_file ) : lambda_function = [ ] with open ( python_file , 'r' ) as f : lambda_function . extend ( f . read ( ) . splitlines ( ) ) return awslambda . Code ( ZipFile = ( Join ( '\\n' , lambda_function ) ) )", "docstring_tokens": "Reads a python file and returns a awslambda . Code object : param python_file : : return :", "label": 0}, {"idx": "cosqa-train-8548", "doc": "python datetime get total millisecond", "code": "def datetime_to_ms(dt):\n    \"\"\"\n    Converts a datetime to a millisecond accuracy timestamp\n    \"\"\"\n    seconds = calendar.timegm(dt.utctimetuple())\n    return seconds * 1000 + int(dt.microsecond / 1000)", "code_tokens": "def datetime_to_ms ( dt ) : seconds = calendar . timegm ( dt . utctimetuple ( ) ) return seconds * 1000 + int ( dt . microsecond / 1000 )", "docstring_tokens": "Converts a datetime to a millisecond accuracy timestamp", "label": 1}, {"idx": "cosqa-train-8549", "doc": "base64 to string python3", "code": "def toBase64(s):\n    \"\"\"Represent string / bytes s as base64, omitting newlines\"\"\"\n    if isinstance(s, str):\n        s = s.encode(\"utf-8\")\n    return binascii.b2a_base64(s)[:-1]", "code_tokens": "def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( \"utf-8\" ) return binascii . b2a_base64 ( s ) [ : - 1 ]", "docstring_tokens": "Represent string / bytes s as base64 omitting newlines", "label": 0}, {"idx": "cosqa-train-8550", "doc": "python datetime now in utc", "code": "def now(self):\n\t\t\"\"\"\n\t\tReturn a :py:class:`datetime.datetime` instance representing the current time.\n\n\t\t:rtype: :py:class:`datetime.datetime`\n\t\t\"\"\"\n\t\tif self.use_utc:\n\t\t\treturn datetime.datetime.utcnow()\n\t\telse:\n\t\t\treturn datetime.datetime.now()", "code_tokens": "def now ( self ) : if self . use_utc : return datetime . datetime . utcnow ( ) else : return datetime . datetime . now ( )", "docstring_tokens": "Return a : py : class : datetime . datetime instance representing the current time .", "label": 0}, {"idx": "cosqa-train-8551", "doc": "best way to handle latitude and longitude in python", "code": "def coords_string_parser(self, coords):\n        \"\"\"Pareses the address string into coordinates to match address_to_coords return object\"\"\"\n\n        lat, lon = coords.split(',')\n        return {\"lat\": lat.strip(), \"lon\": lon.strip(), \"bounds\": {}}", "code_tokens": "def coords_string_parser ( self , coords ) : lat , lon = coords . split ( ',' ) return { \"lat\" : lat . strip ( ) , \"lon\" : lon . strip ( ) , \"bounds\" : { } }", "docstring_tokens": "Pareses the address string into coordinates to match address_to_coords return object", "label": 1}, {"idx": "cosqa-train-8552", "doc": "python datetime remove microseconds", "code": "def ToDatetime(self):\n    \"\"\"Converts Timestamp to datetime.\"\"\"\n    return datetime.utcfromtimestamp(\n        self.seconds + self.nanos / float(_NANOS_PER_SECOND))", "code_tokens": "def ToDatetime ( self ) : return datetime . utcfromtimestamp ( self . seconds + self . nanos / float ( _NANOS_PER_SECOND ) )", "docstring_tokens": "Converts Timestamp to datetime .", "label": 0}, {"idx": "cosqa-train-8553", "doc": "best way to interpolate over matrix python", "code": "def _linearInterpolationTransformMatrix(matrix1, matrix2, value):\n    \"\"\" Linear, 'oldstyle' interpolation of the transform matrix.\"\"\"\n    return tuple(_interpolateValue(matrix1[i], matrix2[i], value) for i in range(len(matrix1)))", "code_tokens": "def _linearInterpolationTransformMatrix ( matrix1 , matrix2 , value ) : return tuple ( _interpolateValue ( matrix1 [ i ] , matrix2 [ i ] , value ) for i in range ( len ( matrix1 ) ) )", "docstring_tokens": "Linear oldstyle interpolation of the transform matrix .", "label": 0}, {"idx": "cosqa-train-8554", "doc": "python datetime to epoch seconds", "code": "def _DateToEpoch(date):\n  \"\"\"Converts python datetime to epoch microseconds.\"\"\"\n  tz_zero = datetime.datetime.utcfromtimestamp(0)\n  diff_sec = int((date - tz_zero).total_seconds())\n  return diff_sec * 1000000", "code_tokens": "def _DateToEpoch ( date ) : tz_zero = datetime . datetime . utcfromtimestamp ( 0 ) diff_sec = int ( ( date - tz_zero ) . total_seconds ( ) ) return diff_sec * 1000000", "docstring_tokens": "Converts python datetime to epoch microseconds .", "label": 0}, {"idx": "cosqa-train-8555", "doc": "best way to iterate through files in a directory python", "code": "def each_img(dir_path):\n    \"\"\"\n    Iterates through each image in the given directory. (not recursive)\n    :param dir_path: Directory path where images files are present\n    :return: Iterator to iterate through image files\n    \"\"\"\n    for fname in os.listdir(dir_path):\n        if fname.endswith('.jpg') or fname.endswith('.png') or fname.endswith('.bmp'):\n            yield fname", "code_tokens": "def each_img ( dir_path ) : for fname in os . listdir ( dir_path ) : if fname . endswith ( '.jpg' ) or fname . endswith ( '.png' ) or fname . endswith ( '.bmp' ) : yield fname", "docstring_tokens": "Iterates through each image in the given directory . ( not recursive ) : param dir_path : Directory path where images files are present : return : Iterator to iterate through image files", "label": 1}, {"idx": "cosqa-train-8556", "doc": "python datetime with timezone to without", "code": "def datetime_to_timezone(date, tz=\"UTC\"):\n    \"\"\" convert naive datetime to timezone-aware datetime \"\"\"\n    if not date.tzinfo:\n        date = date.replace(tzinfo=timezone(get_timezone()))\n    return date.astimezone(timezone(tz))", "code_tokens": "def datetime_to_timezone ( date , tz = \"UTC\" ) : if not date . tzinfo : date = date . replace ( tzinfo = timezone ( get_timezone ( ) ) ) return date . astimezone ( timezone ( tz ) )", "docstring_tokens": "convert naive datetime to timezone - aware datetime", "label": 0}, {"idx": "cosqa-train-8557", "doc": "best way to iterate through files in a folder python", "code": "def get_all_files(folder):\n    \"\"\"\n    Generator that loops through all absolute paths of the files within folder\n\n    Parameters\n    ----------\n    folder: str\n    Root folder start point for recursive search.\n\n    Yields\n    ------\n    fpath: str\n    Absolute path of one file in the folders\n    \"\"\"\n    for path, dirlist, filelist in os.walk(folder):\n        for fn in filelist:\n            yield op.join(path, fn)", "code_tokens": "def get_all_files ( folder ) : for path , dirlist , filelist in os . walk ( folder ) : for fn in filelist : yield op . join ( path , fn )", "docstring_tokens": "Generator that loops through all absolute paths of the files within folder", "label": 1}, {"idx": "cosqa-train-8558", "doc": "python dateutil how to get current date/time", "code": "def now_time(str=False):\n    \"\"\"Get the current time.\"\"\"\n    if str:\n        return datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    return datetime.datetime.now()", "code_tokens": "def now_time ( str = False ) : if str : return datetime . datetime . now ( ) . strftime ( \"%Y-%m-%d %H:%M:%S\" ) return datetime . datetime . now ( )", "docstring_tokens": "Get the current time .", "label": 1}, {"idx": "cosqa-train-8559", "doc": "best way to reduce dimmension of image python", "code": "def resize_by_area(img, size):\n  \"\"\"image resize function used by quite a few image problems.\"\"\"\n  return tf.to_int64(\n      tf.image.resize_images(img, [size, size], tf.image.ResizeMethod.AREA))", "code_tokens": "def resize_by_area ( img , size ) : return tf . to_int64 ( tf . image . resize_images ( img , [ size , size ] , tf . image . ResizeMethod . AREA ) )", "docstring_tokens": "image resize function used by quite a few image problems .", "label": 0}, {"idx": "cosqa-train-8560", "doc": "python decarators with args", "code": "def _iterable_to_varargs_method(func):\n    \"\"\"decorator to convert a method taking a iterable to a *args one\"\"\"\n    def wrapped(self, *args, **kwargs):\n        return func(self, args, **kwargs)\n    return wrapped", "code_tokens": "def _iterable_to_varargs_method ( func ) : def wrapped ( self , * args , * * kwargs ) : return func ( self , args , * * kwargs ) return wrapped", "docstring_tokens": "decorator to convert a method taking a iterable to a * args one", "label": 0}, {"idx": "cosqa-train-8561", "doc": "bi linear interpolation in python", "code": "def _linear_interpolation(x, X, Y):\n    \"\"\"Given two data points [X,Y], linearly interpolate those at x.\n    \"\"\"\n    return (Y[1] * (x - X[0]) + Y[0] * (X[1] - x)) / (X[1] - X[0])", "code_tokens": "def _linear_interpolation ( x , X , Y ) : return ( Y [ 1 ] * ( x - X [ 0 ] ) + Y [ 0 ] * ( X [ 1 ] - x ) ) / ( X [ 1 ] - X [ 0 ] )", "docstring_tokens": "Given two data points [ X Y ] linearly interpolate those at x .", "label": 1}, {"idx": "cosqa-train-8562", "doc": "python decode base64 buffer", "code": "def decode_bytes(string):\n    \"\"\" Decodes a given base64 string into bytes.\n\n    :param str string: The string to decode\n    :return: The decoded bytes\n    :rtype: bytes\n    \"\"\"\n\n    if is_string_type(type(string)):\n        string = bytes(string, \"utf-8\")\n    return base64.decodebytes(string)", "code_tokens": "def decode_bytes ( string ) : if is_string_type ( type ( string ) ) : string = bytes ( string , \"utf-8\" ) return base64 . decodebytes ( string )", "docstring_tokens": "Decodes a given base64 string into bytes .", "label": 1}, {"idx": "cosqa-train-8563", "doc": "bin data into integers python", "code": "def to_bin(data, width):\n    \"\"\"\n    Convert an unsigned integer to a numpy binary array with the first\n    element the MSB and the last element the LSB.\n    \"\"\"\n    data_str = bin(data & (2**width-1))[2:].zfill(width)\n    return [int(x) for x in tuple(data_str)]", "code_tokens": "def to_bin ( data , width ) : data_str = bin ( data & ( 2 ** width - 1 ) ) [ 2 : ] . zfill ( width ) return [ int ( x ) for x in tuple ( data_str ) ]", "docstring_tokens": "Convert an unsigned integer to a numpy binary array with the first element the MSB and the last element the LSB .", "label": 1}, {"idx": "cosqa-train-8564", "doc": "python deep merge dic", "code": "def recursively_update(d, d2):\n  \"\"\"dict.update but which merges child dicts (dict2 takes precedence where there's conflict).\"\"\"\n  for k, v in d2.items():\n    if k in d:\n      if isinstance(v, dict):\n        recursively_update(d[k], v)\n        continue\n    d[k] = v", "code_tokens": "def recursively_update ( d , d2 ) : for k , v in d2 . items ( ) : if k in d : if isinstance ( v , dict ) : recursively_update ( d [ k ] , v ) continue d [ k ] = v", "docstring_tokens": "dict . update but which merges child dicts ( dict2 takes precedence where there s conflict ) .", "label": 1}, {"idx": "cosqa-train-8565", "doc": "bin edges to bin centres python", "code": "def val_to_bin(edges, x):\n    \"\"\"Convert axis coordinate to bin index.\"\"\"\n    ibin = np.digitize(np.array(x, ndmin=1), edges) - 1\n    return ibin", "code_tokens": "def val_to_bin ( edges , x ) : ibin = np . digitize ( np . array ( x , ndmin = 1 ) , edges ) - 1 return ibin", "docstring_tokens": "Convert axis coordinate to bin index .", "label": 1}, {"idx": "cosqa-train-8566", "doc": "python deepcopy basic type", "code": "def __deepcopy__(self, memo):\n        \"\"\"Improve deepcopy speed.\"\"\"\n        return type(self)(value=self._value, enum_ref=self.enum_ref)", "code_tokens": "def __deepcopy__ ( self , memo ) : return type ( self ) ( value = self . _value , enum_ref = self . enum_ref )", "docstring_tokens": "Improve deepcopy speed .", "label": 1}, {"idx": "cosqa-train-8567", "doc": "binary tree printing in order python", "code": "def print_bintree(tree, indent='  '):\n    \"\"\"print a binary tree\"\"\"\n    for n in sorted(tree.keys()):\n        print \"%s%s\" % (indent * depth(n,tree), n)", "code_tokens": "def print_bintree ( tree , indent = '  ' ) : for n in sorted ( tree . keys ( ) ) : print \"%s%s\" % ( indent * depth ( n , tree ) , n )", "docstring_tokens": "print a binary tree", "label": 1}, {"idx": "cosqa-train-8568", "doc": "python def change function vaule", "code": "def def_linear(fun):\n    \"\"\"Flags that a function is linear wrt all args\"\"\"\n    defjvp_argnum(fun, lambda argnum, g, ans, args, kwargs:\n                  fun(*subval(args, argnum, g), **kwargs))", "code_tokens": "def def_linear ( fun ) : defjvp_argnum ( fun , lambda argnum , g , ans , args , kwargs : fun ( * subval ( args , argnum , g ) , * * kwargs ) )", "docstring_tokens": "Flags that a function is linear wrt all args", "label": 1}, {"idx": "cosqa-train-8569", "doc": "bool as int python", "code": "def abs_img(img):\n    \"\"\" Return an image with the binarised version of the data of `img`.\"\"\"\n    bool_img = np.abs(read_img(img).get_data())\n    return bool_img.astype(int)", "code_tokens": "def abs_img ( img ) : bool_img = np . abs ( read_img ( img ) . get_data ( ) ) return bool_img . astype ( int )", "docstring_tokens": "Return an image with the binarised version of the data of img .", "label": 1}, {"idx": "cosqa-train-8570", "doc": "python def with external variables", "code": "def exec_function(ast, globals_map):\n    \"\"\"Execute a python code object in the given environment.\n\n    Args:\n      globals_map: Dictionary to use as the globals context.\n    Returns:\n      locals_map: Dictionary of locals from the environment after execution.\n    \"\"\"\n    locals_map = globals_map\n    exec ast in globals_map, locals_map\n    return locals_map", "code_tokens": "def exec_function ( ast , globals_map ) : locals_map = globals_map exec ast in globals_map , locals_map return locals_map", "docstring_tokens": "Execute a python code object in the given environment .", "label": 0}, {"idx": "cosqa-train-8571", "doc": "boolean matrix numpy python", "code": "def is_bool_matrix(l):\n    r\"\"\"Checks if l is a 2D numpy array of bools\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 2 and (l.dtype == bool):\n            return True\n    return False", "code_tokens": "def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False", "docstring_tokens": "r Checks if l is a 2D numpy array of bools", "label": 1}, {"idx": "cosqa-train-8572", "doc": "python default values empty user input", "code": "def input_int_default(question=\"\", default=0):\n    \"\"\"A function that works for both, Python 2.x and Python 3.x.\n       It asks the user for input and returns it as a string.\n    \"\"\"\n    answer = input_string(question)\n    if answer == \"\" or answer == \"yes\":\n        return default\n    else:\n        return int(answer)", "code_tokens": "def input_int_default ( question = \"\" , default = 0 ) : answer = input_string ( question ) if answer == \"\" or answer == \"yes\" : return default else : return int ( answer )", "docstring_tokens": "A function that works for both Python 2 . x and Python 3 . x . It asks the user for input and returns it as a string .", "label": 1}, {"idx": "cosqa-train-8573", "doc": "both read write permission to a file in python", "code": "def make_file_read_only(file_path):\n    \"\"\"\n    Removes the write permissions for the given file for owner, groups and others.\n\n    :param file_path: The file whose privileges are revoked.\n    :raise FileNotFoundError: If the given file does not exist.\n    \"\"\"\n    old_permissions = os.stat(file_path).st_mode\n    os.chmod(file_path, old_permissions & ~WRITE_PERMISSIONS)", "code_tokens": "def make_file_read_only ( file_path ) : old_permissions = os . stat ( file_path ) . st_mode os . chmod ( file_path , old_permissions & ~ WRITE_PERMISSIONS )", "docstring_tokens": "Removes the write permissions for the given file for owner groups and others .", "label": 1}, {"idx": "cosqa-train-8574", "doc": "python define x axis of subplot", "code": "def show_xticklabels(self, row, column):\n        \"\"\"Show the x-axis tick labels for a subplot.\n\n        :param row,column: specify the subplot.\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.show_xticklabels()", "code_tokens": "def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "docstring_tokens": "Show the x - axis tick labels for a subplot .", "label": 1}, {"idx": "cosqa-train-8575", "doc": "boto3 python opening a file on s3", "code": "def download_file_from_bucket(self, bucket, file_path, key):\n        \"\"\" Download file from S3 Bucket \"\"\"\n        with open(file_path, 'wb') as data:\n            self.__s3.download_fileobj(bucket, key, data)\n            return file_path", "code_tokens": "def download_file_from_bucket ( self , bucket , file_path , key ) : with open ( file_path , 'wb' ) as data : self . __s3 . download_fileobj ( bucket , key , data ) return file_path", "docstring_tokens": "Download file from S3 Bucket", "label": 1}, {"idx": "cosqa-train-8576", "doc": "python delete a file safely", "code": "def safe_delete(filename):\n  \"\"\"Delete a file safely. If it's not present, no-op.\"\"\"\n  try:\n    os.unlink(filename)\n  except OSError as e:\n    if e.errno != errno.ENOENT:\n      raise", "code_tokens": "def safe_delete ( filename ) : try : os . unlink ( filename ) except OSError as e : if e . errno != errno . ENOENT : raise", "docstring_tokens": "Delete a file safely . If it s not present no - op .", "label": 1}, {"idx": "cosqa-train-8577", "doc": "break sentence into words python", "code": "def split_into_words(s):\n  \"\"\"Split a sentence into list of words.\"\"\"\n  s = re.sub(r\"\\W+\", \" \", s)\n  s = re.sub(r\"[_0-9]+\", \" \", s)\n  return s.split()", "code_tokens": "def split_into_words ( s ) : s = re . sub ( r\"\\W+\" , \" \" , s ) s = re . sub ( r\"[_0-9]+\" , \" \" , s ) return s . split ( )", "docstring_tokens": "Split a sentence into list of words .", "label": 1}, {"idx": "cosqa-train-8578", "doc": "python delete all non alphanumeric characters", "code": "def strip_accents(string):\n    \"\"\"\n    Strip all the accents from the string\n    \"\"\"\n    return u''.join(\n        (character for character in unicodedata.normalize('NFD', string)\n         if unicodedata.category(character) != 'Mn'))", "code_tokens": "def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )", "docstring_tokens": "Strip all the accents from the string", "label": 1}, {"idx": "cosqa-train-8579", "doc": "build a url in python using kwargs", "code": "def url(self, action, **kwargs):\n        \"\"\" Construct and return the URL for a specific API service. \"\"\"\n        # TODO : should be static method ?\n        return self.URLS['BASE'] % self.URLS[action] % kwargs", "code_tokens": "def url ( self , action , * * kwargs ) : # TODO : should be static method ? return self . URLS [ 'BASE' ] % self . URLS [ action ] % kwargs", "docstring_tokens": "Construct and return the URL for a specific API service .", "label": 0}, {"idx": "cosqa-train-8580", "doc": "python delete character on screen", "code": "def backward_delete_word(self, e): # (Control-Rubout)\n        u\"\"\"Delete the character behind the cursor. A numeric argument means\n        to kill the characters instead of deleting them.\"\"\"\n        self.l_buffer.backward_delete_word(self.argument_reset)\n        self.finalize()", "code_tokens": "def backward_delete_word ( self , e ) : # (Control-Rubout)\n self . l_buffer . backward_delete_word ( self . argument_reset ) self . finalize ( )", "docstring_tokens": "u Delete the character behind the cursor . A numeric argument means to kill the characters instead of deleting them .", "label": 1}, {"idx": "cosqa-train-8581", "doc": "build python clear clean rebuild", "code": "def clean_all(self, args):\n        \"\"\"Delete all build components; the package cache, package builds,\n        bootstrap builds and distributions.\"\"\"\n        self.clean_dists(args)\n        self.clean_builds(args)\n        self.clean_download_cache(args)", "code_tokens": "def clean_all ( self , args ) : self . clean_dists ( args ) self . clean_builds ( args ) self . clean_download_cache ( args )", "docstring_tokens": "Delete all build components ; the package cache package builds bootstrap builds and distributions .", "label": 1}, {"idx": "cosqa-train-8582", "doc": "python delete index from dictionary", "code": "def __delitem__(self, key):\n\t\t\"\"\"Remove item with given key from the mapping.\n\n\t\tRuns in O(n), unless removing last item, then in O(1).\n\t\t\"\"\"\n\t\tindex, value = self._dict.pop(key)\n\t\tkey2, value2 = self._list.pop(index)\n\t\tassert key == key2\n\t\tassert value is value2\n\n\t\tself._fix_indices_after_delete(index)", "code_tokens": "def __delitem__ ( self , key ) : index , value = self . _dict . pop ( key ) key2 , value2 = self . _list . pop ( index ) assert key == key2 assert value is value2 self . _fix_indices_after_delete ( index )", "docstring_tokens": "Remove item with given key from the mapping .", "label": 0}, {"idx": "cosqa-train-8583", "doc": "button change state python", "code": "def restore_button_state(self):\n        \"\"\"Helper to restore button state.\"\"\"\n        self.parent.pbnNext.setEnabled(self.next_button_state)\n        self.parent.pbnBack.setEnabled(self.back_button_state)", "code_tokens": "def restore_button_state ( self ) : self . parent . pbnNext . setEnabled ( self . next_button_state ) self . parent . pbnBack . setEnabled ( self . back_button_state )", "docstring_tokens": "Helper to restore button state .", "label": 1}, {"idx": "cosqa-train-8584", "doc": "python delete node in linked list", "code": "def remove_this_tlink(self,tlink_id):\n        \"\"\"\n        Removes the tlink for the given tlink identifier\n        @type tlink_id: string\n        @param tlink_id: the tlink identifier to be removed\n        \"\"\"\n        for tlink in self.get_tlinks():\n            if tlink.get_id() == tlink_id:\n                self.node.remove(tlink.get_node())\n                break", "code_tokens": "def remove_this_tlink ( self , tlink_id ) : for tlink in self . get_tlinks ( ) : if tlink . get_id ( ) == tlink_id : self . node . remove ( tlink . get_node ( ) ) break", "docstring_tokens": "Removes the tlink for the given tlink identifier", "label": 0}, {"idx": "cosqa-train-8585", "doc": "caffe python layer add new feature", "code": "def _int64_feature(value):\n  \"\"\"Wrapper for inserting int64 features into Example proto.\"\"\"\n  if not isinstance(value, list):\n    value = [value]\n  return tf.train.Feature(int64_list=tf.train.Int64List(value=value))", "code_tokens": "def _int64_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( int64_list = tf . train . Int64List ( value = value ) )", "docstring_tokens": "Wrapper for inserting int64 features into Example proto .", "label": 1}, {"idx": "cosqa-train-8586", "doc": "python delete objects inside of objects", "code": "def _removeTags(tags, objects):\n    \"\"\" Removes tags from objects \"\"\"\n    for t in tags:\n        for o in objects:\n            o.tags.remove(t)\n\n    return True", "code_tokens": "def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True", "docstring_tokens": "Removes tags from objects", "label": 1}, {"idx": "cosqa-train-8587", "doc": "calculate area of 3 points python", "code": "def get_tri_area(pts):\n    \"\"\"\n    Given a list of coords for 3 points,\n    Compute the area of this triangle.\n\n    Args:\n        pts: [a, b, c] three points\n    \"\"\"\n    a, b, c = pts[0], pts[1], pts[2]\n    v1 = np.array(b) - np.array(a)\n    v2 = np.array(c) - np.array(a)\n    area_tri = abs(sp.linalg.norm(sp.cross(v1, v2)) / 2)\n    return area_tri", "code_tokens": "def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri", "docstring_tokens": "Given a list of coords for 3 points Compute the area of this triangle .", "label": 0}, {"idx": "cosqa-train-8588", "doc": "python delete some letters from string", "code": "def _sanitize(text):\n    \"\"\"Return sanitized Eidos text field for human readability.\"\"\"\n    d = {'-LRB-': '(', '-RRB-': ')'}\n    return re.sub('|'.join(d.keys()), lambda m: d[m.group(0)], text)", "code_tokens": "def _sanitize ( text ) : d = { '-LRB-' : '(' , '-RRB-' : ')' } return re . sub ( '|' . join ( d . keys ( ) ) , lambda m : d [ m . group ( 0 ) ] , text )", "docstring_tokens": "Return sanitized Eidos text field for human readability .", "label": 0}, {"idx": "cosqa-train-8589", "doc": "calculate distance to object in image python", "code": "def normalized_distance(self, image):\n        \"\"\"Calculates the distance of a given image to the\n        original image.\n\n        Parameters\n        ----------\n        image : `numpy.ndarray`\n            The image that should be compared to the original image.\n\n        Returns\n        -------\n        :class:`Distance`\n            The distance between the given image and the original image.\n\n        \"\"\"\n        return self.__distance(\n            self.__original_image_for_distance,\n            image,\n            bounds=self.bounds())", "code_tokens": "def normalized_distance ( self , image ) : return self . __distance ( self . __original_image_for_distance , image , bounds = self . bounds ( ) )", "docstring_tokens": "Calculates the distance of a given image to the original image .", "label": 1}, {"idx": "cosqa-train-8590", "doc": "python delete specific index", "code": "def _remove_from_index(index, obj):\n    \"\"\"Removes object ``obj`` from the ``index``.\"\"\"\n    try:\n        index.value_map[indexed_value(index, obj)].remove(obj.id)\n    except KeyError:\n        pass", "code_tokens": "def _remove_from_index ( index , obj ) : try : index . value_map [ indexed_value ( index , obj ) ] . remove ( obj . id ) except KeyError : pass", "docstring_tokens": "Removes object obj from the index .", "label": 1}, {"idx": "cosqa-train-8591", "doc": "calculate distance two points latitude longitude in python", "code": "def _distance(coord1, coord2):\n    \"\"\"\n    Return the distance between two points, `coord1` and `coord2`. These\n    parameters are assumed to be (x, y) tuples.\n    \"\"\"\n    xdist = coord1[0] - coord2[0]\n    ydist = coord1[1] - coord2[1]\n    return sqrt(xdist*xdist + ydist*ydist)", "code_tokens": "def _distance ( coord1 , coord2 ) : xdist = coord1 [ 0 ] - coord2 [ 0 ] ydist = coord1 [ 1 ] - coord2 [ 1 ] return sqrt ( xdist * xdist + ydist * ydist )", "docstring_tokens": "Return the distance between two points coord1 and coord2 . These parameters are assumed to be ( x y ) tuples .", "label": 1}, {"idx": "cosqa-train-8592", "doc": "python deode bytet objet", "code": "def _decode(self, obj, context):\n        \"\"\"\n        Get the python representation of the obj\n        \"\"\"\n        return b''.join(map(int2byte, [c + 0x60 for c in bytearray(obj)])).decode(\"utf8\")", "code_tokens": "def _decode ( self , obj , context ) : return b'' . join ( map ( int2byte , [ c + 0x60 for c in bytearray ( obj ) ] ) ) . decode ( \"utf8\" )", "docstring_tokens": "Get the python representation of the obj", "label": 1}, {"idx": "cosqa-train-8593", "doc": "calculate fpr and tpr in h2o logistic regression python", "code": "def tpr(y, z):\n    \"\"\"True positive rate `tp / (tp + fn)`\n    \"\"\"\n    tp, tn, fp, fn = contingency_table(y, z)\n    return tp / (tp + fn)", "code_tokens": "def tpr ( y , z ) : tp , tn , fp , fn = contingency_table ( y , z ) return tp / ( tp + fn )", "docstring_tokens": "True positive rate tp / ( tp + fn )", "label": 0}, {"idx": "cosqa-train-8594", "doc": "python describe exclude type object", "code": "def is_descriptor_class(desc, include_abstract=False):\n    r\"\"\"Check calculatable descriptor class or not.\n\n    Returns:\n        bool\n\n    \"\"\"\n    return (\n        isinstance(desc, type)\n        and issubclass(desc, Descriptor)\n        and (True if include_abstract else not inspect.isabstract(desc))\n    )", "code_tokens": "def is_descriptor_class ( desc , include_abstract = False ) : return ( isinstance ( desc , type ) and issubclass ( desc , Descriptor ) and ( True if include_abstract else not inspect . isabstract ( desc ) ) )", "docstring_tokens": "r Check calculatable descriptor class or not .", "label": 0}, {"idx": "cosqa-train-8595", "doc": "calculate inverse of a matrix in python", "code": "def inh(table):\n    \"\"\"\n    inverse hyperbolic sine transformation\n    \"\"\"\n    t = []\n    for i in table:\n        t.append(np.ndarray.tolist(np.arcsinh(i)))\n    return t", "code_tokens": "def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "docstring_tokens": "inverse hyperbolic sine transformation", "label": 0}, {"idx": "cosqa-train-8596", "doc": "python destroy all threads", "code": "def terminate(self):\n        \"\"\"Terminate all workers and threads.\"\"\"\n        for t in self._threads:\n            t.quit()\n        self._thread = []\n        self._workers = []", "code_tokens": "def terminate ( self ) : for t in self . _threads : t . quit ( ) self . _thread = [ ] self . _workers = [ ]", "docstring_tokens": "Terminate all workers and threads .", "label": 1}, {"idx": "cosqa-train-8597", "doc": "python detect if in interactive mode", "code": "def determine_interactive(self):\n\t\t\"\"\"Determine whether we're in an interactive shell.\n\t\tSets interactivity off if appropriate.\n\t\tcf http://stackoverflow.com/questions/24861351/how-to-detect-if-python-script-is-being-run-as-a-background-process\n\t\t\"\"\"\n\t\ttry:\n\t\t\tif not sys.stdout.isatty() or os.getpgrp() != os.tcgetpgrp(sys.stdout.fileno()):\n\t\t\t\tself.interactive = 0\n\t\t\t\treturn False\n\t\texcept Exception:\n\t\t\tself.interactive = 0\n\t\t\treturn False\n\t\tif self.interactive == 0:\n\t\t\treturn False\n\t\treturn True", "code_tokens": "def determine_interactive ( self ) : try : if not sys . stdout . isatty ( ) or os . getpgrp ( ) != os . tcgetpgrp ( sys . stdout . fileno ( ) ) : self . interactive = 0 return False except Exception : self . interactive = 0 return False if self . interactive == 0 : return False return True", "docstring_tokens": "Determine whether we re in an interactive shell . Sets interactivity off if appropriate . cf http : // stackoverflow . com / questions / 24861351 / how - to - detect - if - python - script - is - being - run - as - a - background - process", "label": 0}, {"idx": "cosqa-train-8598", "doc": "calculate p value for normal distribution python", "code": "def EvalGaussianPdf(x, mu, sigma):\n    \"\"\"Computes the unnormalized PDF of the normal distribution.\n\n    x: value\n    mu: mean\n    sigma: standard deviation\n    \n    returns: float probability density\n    \"\"\"\n    return scipy.stats.norm.pdf(x, mu, sigma)", "code_tokens": "def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )", "docstring_tokens": "Computes the unnormalized PDF of the normal distribution .", "label": 0}, {"idx": "cosqa-train-8599", "doc": "python detect signal kill", "code": "def set_terminate_listeners(stream):\n    \"\"\"Die on SIGTERM or SIGINT\"\"\"\n\n    def stop(signum, frame):\n        terminate(stream.listener)\n\n    # Installs signal handlers for handling SIGINT and SIGTERM\n    # gracefully.\n    signal.signal(signal.SIGINT, stop)\n    signal.signal(signal.SIGTERM, stop)", "code_tokens": "def set_terminate_listeners ( stream ) : def stop ( signum , frame ) : terminate ( stream . listener ) # Installs signal handlers for handling SIGINT and SIGTERM # gracefully. signal . signal ( signal . SIGINT , stop ) signal . signal ( signal . SIGTERM , stop )", "docstring_tokens": "Die on SIGTERM or SIGINT", "label": 1}, {"idx": "cosqa-train-8600", "doc": "calculate the eigen values in python", "code": "def center_eigenvalue_diff(mat):\n    \"\"\"Compute the eigvals of mat and then find the center eigval difference.\"\"\"\n    N = len(mat)\n    evals = np.sort(la.eigvals(mat))\n    diff = np.abs(evals[N/2] - evals[N/2-1])\n    return diff", "code_tokens": "def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff", "docstring_tokens": "Compute the eigvals of mat and then find the center eigval difference .", "label": 1}, {"idx": "cosqa-train-8601", "doc": "python detecting string matches", "code": "def matches(self, s):\n    \"\"\"Whether the pattern matches anywhere in the string s.\"\"\"\n    regex_matches = self.compiled_regex.search(s) is not None\n    return not regex_matches if self.inverted else regex_matches", "code_tokens": "def matches ( self , s ) : regex_matches = self . compiled_regex . search ( s ) is not None return not regex_matches if self . inverted else regex_matches", "docstring_tokens": "Whether the pattern matches anywhere in the string s .", "label": 0}, {"idx": "cosqa-train-8602", "doc": "calculate time to run a function python", "code": "def timed_call(func, *args, log_level='DEBUG', **kwargs):\n    \"\"\"Logs a function's run time\n\n    :param func: The function to run\n    :param args: The args to pass to the function\n    :param kwargs: The keyword args to pass to the function\n    :param log_level: The log level at which to print the run time\n    :return: The function's return value\n    \"\"\"\n    start = time()\n    r = func(*args, **kwargs)\n    t = time() - start\n    log(log_level, \"Call to '{}' took {:0.6f}s\".format(func.__name__, t))\n    return r", "code_tokens": "def timed_call ( func , * args , log_level = 'DEBUG' , * * kwargs ) : start = time ( ) r = func ( * args , * * kwargs ) t = time ( ) - start log ( log_level , \"Call to '{}' took {:0.6f}s\" . format ( func . __name__ , t ) ) return r", "docstring_tokens": "Logs a function s run time", "label": 0}, {"idx": "cosqa-train-8603", "doc": "python determin linux or windows", "code": "def is_unix_like(platform=None):\n    \"\"\"Returns whether the given platform is a Unix-like platform with the usual\n    Unix filesystem. When the parameter is omitted, it defaults to ``sys.platform``\n    \"\"\"\n    platform = platform or sys.platform\n    platform = platform.lower()\n    return platform.startswith(\"linux\") or platform.startswith(\"darwin\") or \\\n            platform.startswith(\"cygwin\")", "code_tokens": "def is_unix_like ( platform = None ) : platform = platform or sys . platform platform = platform . lower ( ) return platform . startswith ( \"linux\" ) or platform . startswith ( \"darwin\" ) or platform . startswith ( \"cygwin\" )", "docstring_tokens": "Returns whether the given platform is a Unix - like platform with the usual Unix filesystem . When the parameter is omitted it defaults to sys . platform", "label": 1}, {"idx": "cosqa-train-8604", "doc": "calculating list size in python", "code": "def calculate_size(name, data_list):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    for data_list_item in data_list:\n        data_size += calculate_size_data(data_list_item)\n    return data_size", "code_tokens": "def calculate_size ( name , data_list ) : data_size = 0 data_size += calculate_size_str ( name ) data_size += INT_SIZE_IN_BYTES for data_list_item in data_list : data_size += calculate_size_data ( data_list_item ) return data_size", "docstring_tokens": "Calculates the request payload size", "label": 1}, {"idx": "cosqa-train-8605", "doc": "python determine if a value is an array", "code": "def is_int_vector(l):\n    r\"\"\"Checks if l is a numpy array of integers\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 1 and (l.dtype.kind == 'i' or l.dtype.kind == 'u'):\n            return True\n    return False", "code_tokens": "def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False", "docstring_tokens": "r Checks if l is a numpy array of integers", "label": 0}, {"idx": "cosqa-train-8606", "doc": "call a function in another function with parametters python", "code": "def trigger(self, target: str, trigger: str, parameters: Dict[str, Any]={}):\n\t\t\"\"\"Calls the specified Trigger of another Area with the optionally given parameters.\n\n\t\tArgs:\n\t\t\ttarget: The name of the target Area.\n\t\t\ttrigger: The name of the Trigger.\n\t\t\tparameters: The parameters of the function call.\n\t\t\"\"\"\n\t\tpass", "code_tokens": "def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass", "docstring_tokens": "Calls the specified Trigger of another Area with the optionally given parameters .", "label": 0}, {"idx": "cosqa-train-8607", "doc": "python determine if file has specific file extension", "code": "def get_file_extension_type(filename):\n    \"\"\"\n    Return the group associated to the file\n    :param filename:\n    :return: str\n    \"\"\"\n    ext = get_file_extension(filename)\n    if ext:\n        for name, group in EXTENSIONS.items():\n            if ext in group:\n                return name\n    return \"OTHER\"", "code_tokens": "def get_file_extension_type ( filename ) : ext = get_file_extension ( filename ) if ext : for name , group in EXTENSIONS . items ( ) : if ext in group : return name return \"OTHER\"", "docstring_tokens": "Return the group associated to the file : param filename : : return : str", "label": 1}, {"idx": "cosqa-train-8608", "doc": "call a route from within another route in same blueprint python", "code": "def register(self, target):\n        \"\"\"Registers url_rules on the blueprint\n        \"\"\"\n        for rule, options in self.url_rules:\n            target.add_url_rule(rule, self.name, self.dispatch_request, **options)", "code_tokens": "def register ( self , target ) : for rule , options in self . url_rules : target . add_url_rule ( rule , self . name , self . dispatch_request , * * options )", "docstring_tokens": "Registers url_rules on the blueprint", "label": 0}, {"idx": "cosqa-train-8609", "doc": "python determine key is equal", "code": "def check_hash_key(query_on, key):\n    \"\"\"Only allows == against query_on.hash_key\"\"\"\n    return (\n        isinstance(key, BaseCondition) and\n        (key.operation == \"==\") and\n        (key.column is query_on.hash_key)\n    )", "code_tokens": "def check_hash_key ( query_on , key ) : return ( isinstance ( key , BaseCondition ) and ( key . operation == \"==\" ) and ( key . column is query_on . hash_key ) )", "docstring_tokens": "Only allows == against query_on . hash_key", "label": 1}, {"idx": "cosqa-train-8610", "doc": "call multiple python files in a script", "code": "def load_files(files):\n    \"\"\"Load and execute a python file.\"\"\"\n\n    for py_file in files:\n        LOG.debug(\"exec %s\", py_file)\n        execfile(py_file, globals(), locals())", "code_tokens": "def load_files ( files ) : for py_file in files : LOG . debug ( \"exec %s\" , py_file ) execfile ( py_file , globals ( ) , locals ( ) )", "docstring_tokens": "Load and execute a python file .", "label": 1}, {"idx": "cosqa-train-8611", "doc": "python determine operational time", "code": "def _uptime_syllable():\n    \"\"\"Returns uptime in seconds or None, on Syllable.\"\"\"\n    global __boottime\n    try:\n        __boottime = os.stat('/dev/pty/mst/pty0').st_mtime\n        return time.time() - __boottime\n    except (NameError, OSError):\n        return None", "code_tokens": "def _uptime_syllable ( ) : global __boottime try : __boottime = os . stat ( '/dev/pty/mst/pty0' ) . st_mtime return time . time ( ) - __boottime except ( NameError , OSError ) : return None", "docstring_tokens": "Returns uptime in seconds or None on Syllable .", "label": 1}, {"idx": "cosqa-train-8612", "doc": "call python script from typescript", "code": "def typescript_compile(source):\n    \"\"\"Compiles the given ``source`` from TypeScript to ES5 using TypescriptServices.js\"\"\"\n    with open(TS_COMPILER, 'r') as tsservices_js:\n        return evaljs(\n            (tsservices_js.read(),\n             'ts.transpile(dukpy.tscode, {options});'.format(options=TSC_OPTIONS)),\n            tscode=source\n        )", "code_tokens": "def typescript_compile ( source ) : with open ( TS_COMPILER , 'r' ) as tsservices_js : return evaljs ( ( tsservices_js . read ( ) , 'ts.transpile(dukpy.tscode, {options});' . format ( options = TSC_OPTIONS ) ) , tscode = source )", "docstring_tokens": "Compiles the given source from TypeScript to ES5 using TypescriptServices . js", "label": 1}, {"idx": "cosqa-train-8613", "doc": "python determine whether particular key is in dictionary", "code": "def __contains__(self, key):\n        \"\"\"\n        Invoked when determining whether a specific key is in the dictionary\n        using `key in d`.\n\n        The key is looked up case-insensitively.\n        \"\"\"\n        k = self._real_key(key)\n        return k in self._data", "code_tokens": "def __contains__ ( self , key ) : k = self . _real_key ( key ) return k in self . _data", "docstring_tokens": "Invoked when determining whether a specific key is in the dictionary using key in d .", "label": 1}, {"idx": "cosqa-train-8614", "doc": "calling method of object as sorted key python", "code": "def sort_func(self, key):\n        \"\"\"Sorting logic for `Quantity` objects.\"\"\"\n        if key == self._KEYS.VALUE:\n            return 'aaa'\n        if key == self._KEYS.SOURCE:\n            return 'zzz'\n        return key", "code_tokens": "def sort_func ( self , key ) : if key == self . _KEYS . VALUE : return 'aaa' if key == self . _KEYS . SOURCE : return 'zzz' return key", "docstring_tokens": "Sorting logic for Quantity objects .", "label": 1}, {"idx": "cosqa-train-8615", "doc": "python deterministic dictionary printing", "code": "def pprint_for_ordereddict():\n    \"\"\"\n    Context manager that causes pprint() to print OrderedDict objects as nicely\n    as standard Python dictionary objects.\n    \"\"\"\n    od_saved = OrderedDict.__repr__\n    try:\n        OrderedDict.__repr__ = dict.__repr__\n        yield\n    finally:\n        OrderedDict.__repr__ = od_saved", "code_tokens": "def pprint_for_ordereddict ( ) : od_saved = OrderedDict . __repr__ try : OrderedDict . __repr__ = dict . __repr__ yield finally : OrderedDict . __repr__ = od_saved", "docstring_tokens": "Context manager that causes pprint () to print OrderedDict objects as nicely as standard Python dictionary objects .", "label": 1}, {"idx": "cosqa-train-8616", "doc": "calling python functions within itself", "code": "def __call__(self, func, *args, **kwargs):\n        \"\"\"Shorcut for self.run.\"\"\"\n        return self.run(func, *args, **kwargs)", "code_tokens": "def __call__ ( self , func , * args , * * kwargs ) : return self . run ( func , * args , * * kwargs )", "docstring_tokens": "Shorcut for self . run .", "label": 1}, {"idx": "cosqa-train-8617", "doc": "python dict drop empty", "code": "def purge_dict(idict):\n    \"\"\"Remove null items from a dictionary \"\"\"\n    odict = {}\n    for key, val in idict.items():\n        if is_null(val):\n            continue\n        odict[key] = val\n    return odict", "code_tokens": "def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict", "docstring_tokens": "Remove null items from a dictionary", "label": 1}, {"idx": "cosqa-train-8618", "doc": "can a python enum have fucntions", "code": "def check(self, var):\n        \"\"\"Check whether the provided value is a valid enum constant.\"\"\"\n        if not isinstance(var, _str_type): return False\n        return _enum_mangle(var) in self._consts", "code_tokens": "def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts", "docstring_tokens": "Check whether the provided value is a valid enum constant .", "label": 0}, {"idx": "cosqa-train-8619", "doc": "python dict howto empty", "code": "def nonull_dict(self):\n        \"\"\"Like dict, but does not hold any null values.\n\n        :return:\n\n        \"\"\"\n        return {k: v for k, v in six.iteritems(self.dict) if v and k != '_codes'}", "code_tokens": "def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }", "docstring_tokens": "Like dict but does not hold any null values .", "label": 0}, {"idx": "cosqa-train-8620", "doc": "can a python object have multiple init", "code": "def __init__(self):\n        \"\"\"Initialize the state of the object\"\"\"\n        self.state = self.STATE_INITIALIZING\n        self.state_start = time.time()", "code_tokens": "def __init__ ( self ) : self . state = self . STATE_INITIALIZING self . state_start = time . time ( )", "docstring_tokens": "Initialize the state of the object", "label": 0}, {"idx": "cosqa-train-8621", "doc": "python dict key encode ascii", "code": "def clean_dict_keys(d):\n    \"\"\"Convert all keys of the dict 'd' to (ascii-)strings.\n\n    :Raises: UnicodeEncodeError\n    \"\"\"\n    new_d = {}\n    for (k, v) in d.iteritems():\n        new_d[str(k)] = v\n    return new_d", "code_tokens": "def clean_dict_keys ( d ) : new_d = { } for ( k , v ) in d . iteritems ( ) : new_d [ str ( k ) ] = v return new_d", "docstring_tokens": "Convert all keys of the dict d to ( ascii - ) strings .", "label": 1}, {"idx": "cosqa-train-8622", "doc": "can i send a variable through python flask redirect", "code": "def redirect(view=None, url=None, **kwargs):\n    \"\"\"Redirects to the specified view or url\n    \"\"\"\n    if view:\n        if url:\n            kwargs[\"url\"] = url\n        url = flask.url_for(view, **kwargs)\n    current_context.exit(flask.redirect(url))", "code_tokens": "def redirect ( view = None , url = None , * * kwargs ) : if view : if url : kwargs [ \"url\" ] = url url = flask . url_for ( view , * * kwargs ) current_context . exit ( flask . redirect ( url ) )", "docstring_tokens": "Redirects to the specified view or url", "label": 0}, {"idx": "cosqa-train-8623", "doc": "python dict keys lowercase", "code": "def keys_to_snake_case(camel_case_dict):\n    \"\"\"\n    Make a copy of a dictionary with all keys converted to snake case. This is just calls to_snake_case on\n    each of the keys in the dictionary and returns a new dictionary.\n\n    :param camel_case_dict: Dictionary with the keys to convert.\n    :type camel_case_dict: Dictionary.\n\n    :return: Dictionary with the keys converted to snake case.\n    \"\"\"\n    return dict((to_snake_case(key), value) for (key, value) in camel_case_dict.items())", "code_tokens": "def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )", "docstring_tokens": "Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .", "label": 1}, {"idx": "cosqa-train-8624", "doc": "can python access files inside zip directly", "code": "def extract_zip(zip_path, target_folder):\n    \"\"\"\n    Extract the content of the zip-file at `zip_path` into `target_folder`.\n    \"\"\"\n    with zipfile.ZipFile(zip_path) as archive:\n        archive.extractall(target_folder)", "code_tokens": "def extract_zip ( zip_path , target_folder ) : with zipfile . ZipFile ( zip_path ) as archive : archive . extractall ( target_folder )", "docstring_tokens": "Extract the content of the zip - file at zip_path into target_folder .", "label": 1}, {"idx": "cosqa-train-8625", "doc": "python dict keys to lower", "code": "def keys_to_snake_case(camel_case_dict):\n    \"\"\"\n    Make a copy of a dictionary with all keys converted to snake case. This is just calls to_snake_case on\n    each of the keys in the dictionary and returns a new dictionary.\n\n    :param camel_case_dict: Dictionary with the keys to convert.\n    :type camel_case_dict: Dictionary.\n\n    :return: Dictionary with the keys converted to snake case.\n    \"\"\"\n    return dict((to_snake_case(key), value) for (key, value) in camel_case_dict.items())", "code_tokens": "def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )", "docstring_tokens": "Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .", "label": 1}, {"idx": "cosqa-train-8626", "doc": "can you chain if tags in python", "code": "def is_break_tag(self, el):\n        \"\"\"Check if tag is an element we should break on.\"\"\"\n\n        name = el.name\n        return name in self.break_tags or name in self.user_break_tags", "code_tokens": "def is_break_tag ( self , el ) : name = el . name return name in self . break_tags or name in self . user_break_tags", "docstring_tokens": "Check if tag is an element we should break on .", "label": 1}, {"idx": "cosqa-train-8627", "doc": "python dict pretty output", "code": "def pretty_dict_str(d, indent=2):\n    \"\"\"shows JSON indented representation of d\"\"\"\n    b = StringIO()\n    write_pretty_dict_str(b, d, indent=indent)\n    return b.getvalue()", "code_tokens": "def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )", "docstring_tokens": "shows JSON indented representation of d", "label": 1}, {"idx": "cosqa-train-8628", "doc": "can you pull multiple index slices from a single python string", "code": "def ignored_regions(source):\n    \"\"\"Return ignored regions like strings and comments in `source` \"\"\"\n    return [(match.start(), match.end()) for match in _str.finditer(source)]", "code_tokens": "def ignored_regions ( source ) : return [ ( match . start ( ) , match . end ( ) ) for match in _str . finditer ( source ) ]", "docstring_tokens": "Return ignored regions like strings and comments in source", "label": 1}, {"idx": "cosqa-train-8629", "doc": "python dict remove any", "code": "def _remove_dict_keys_with_value(dict_, val):\n  \"\"\"Removes `dict` keys which have have `self` as value.\"\"\"\n  return {k: v for k, v in dict_.items() if v is not val}", "code_tokens": "def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }", "docstring_tokens": "Removes dict keys which have have self as value .", "label": 1}, {"idx": "cosqa-train-8630", "doc": "cant run python plug in for git", "code": "def install_plugin(username, repo):\n    \"\"\"Installs a Blended plugin from GitHub\"\"\"\n    print(\"Installing plugin from \" + username + \"/\" + repo)\n\n    pip.main(['install', '-U', \"git+git://github.com/\" +\n              username + \"/\" + repo + \".git\"])", "code_tokens": "def install_plugin ( username , repo ) : print ( \"Installing plugin from \" + username + \"/\" + repo ) pip . main ( [ 'install' , '-U' , \"git+git://github.com/\" + username + \"/\" + repo + \".git\" ] )", "docstring_tokens": "Installs a Blended plugin from GitHub", "label": 1}, {"idx": "cosqa-train-8631", "doc": "python dict setdefault multiple", "code": "def setdefaults(dct, defaults):\n    \"\"\"Given a target dct and a dict of {key:default value} pairs,\n    calls setdefault for all of those pairs.\"\"\"\n    for key in defaults:\n        dct.setdefault(key, defaults[key])\n\n    return dct", "code_tokens": "def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct", "docstring_tokens": "Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs .", "label": 1}, {"idx": "cosqa-train-8632", "doc": "capitalize to words in python", "code": "def to_camel_case(text):\n    \"\"\"Convert to camel case.\n\n    :param str text:\n    :rtype: str\n    :return:\n    \"\"\"\n    split = text.split('_')\n    return split[0] + \"\".join(x.title() for x in split[1:])", "code_tokens": "def to_camel_case ( text ) : split = text . split ( '_' ) return split [ 0 ] + \"\" . join ( x . title ( ) for x in split [ 1 : ] )", "docstring_tokens": "Convert to camel case .", "label": 1}, {"idx": "cosqa-train-8633", "doc": "python dict to json pretty", "code": "def pretty_dict_str(d, indent=2):\n    \"\"\"shows JSON indented representation of d\"\"\"\n    b = StringIO()\n    write_pretty_dict_str(b, d, indent=indent)\n    return b.getvalue()", "code_tokens": "def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )", "docstring_tokens": "shows JSON indented representation of d", "label": 1}, {"idx": "cosqa-train-8634", "doc": "cast string to json python", "code": "def serialize_json_string(self, value):\n        \"\"\"\n        Tries to load an encoded json string back into an object\n        :param json_string:\n        :return:\n        \"\"\"\n\n        # Check if the value might be a json string\n        if not isinstance(value, six.string_types):\n            return value\n\n        # Make sure it starts with a brace\n        if not value.startswith('{') or value.startswith('['):\n            return value\n\n        # Try to load the string\n        try:\n            return json.loads(value)\n        except:\n            return value", "code_tokens": "def serialize_json_string ( self , value ) : # Check if the value might be a json string if not isinstance ( value , six . string_types ) : return value # Make sure it starts with a brace if not value . startswith ( '{' ) or value . startswith ( '[' ) : return value # Try to load the string try : return json . loads ( value ) except : return value", "docstring_tokens": "Tries to load an encoded json string back into an object : param json_string : : return :", "label": 1}, {"idx": "cosqa-train-8635", "doc": "python dict to key string and value stirng", "code": "def stringify_dict_contents(dct):\n    \"\"\"Turn dict keys and values into native strings.\"\"\"\n    return {\n        str_if_nested_or_str(k): str_if_nested_or_str(v)\n        for k, v in dct.items()\n    }", "code_tokens": "def stringify_dict_contents ( dct ) : return { str_if_nested_or_str ( k ) : str_if_nested_or_str ( v ) for k , v in dct . items ( ) }", "docstring_tokens": "Turn dict keys and values into native strings .", "label": 1}, {"idx": "cosqa-train-8636", "doc": "cast to bytes python", "code": "def str2bytes(x):\n  \"\"\"Convert input argument to bytes\"\"\"\n  if type(x) is bytes:\n    return x\n  elif type(x) is str:\n    return bytes([ ord(i) for i in x ])\n  else:\n    return str2bytes(str(x))", "code_tokens": "def str2bytes ( x ) : if type ( x ) is bytes : return x elif type ( x ) is str : return bytes ( [ ord ( i ) for i in x ] ) else : return str2bytes ( str ( x ) )", "docstring_tokens": "Convert input argument to bytes", "label": 1}, {"idx": "cosqa-train-8637", "doc": "python dict to querystring", "code": "def dict_to_querystring(dictionary):\n    \"\"\"Converts a dict to a querystring suitable to be appended to a URL.\"\"\"\n    s = u\"\"\n    for d in dictionary.keys():\n        s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d])\n    return s[:-1]", "code_tokens": "def dict_to_querystring ( dictionary ) : s = u\"\" for d in dictionary . keys ( ) : s = unicode . format ( u\"{0}{1}={2}&\" , s , d , dictionary [ d ] ) return s [ : - 1 ]", "docstring_tokens": "Converts a dict to a querystring suitable to be appended to a URL .", "label": 1}, {"idx": "cosqa-train-8638", "doc": "catch output of a shell command in python without displaying on screen", "code": "def run_cmd(command, verbose=True, shell='/bin/bash'):\n    \"\"\"internal helper function to run shell commands and get output\"\"\"\n    process = Popen(command, shell=True, stdout=PIPE, stderr=STDOUT, executable=shell)\n    output = process.stdout.read().decode().strip().split('\\n')\n    if verbose:\n        # return full output including empty lines\n        return output\n    return [line for line in output if line.strip()]", "code_tokens": "def run_cmd ( command , verbose = True , shell = '/bin/bash' ) : process = Popen ( command , shell = True , stdout = PIPE , stderr = STDOUT , executable = shell ) output = process . stdout . read ( ) . decode ( ) . strip ( ) . split ( '\\n' ) if verbose : # return full output including empty lines return output return [ line for line in output if line . strip ( ) ]", "docstring_tokens": "internal helper function to run shell commands and get output", "label": 0}, {"idx": "cosqa-train-8639", "doc": "python dict update multiple items", "code": "def update(self, other_dict):\n        \"\"\"update() extends rather than replaces existing key lists.\"\"\"\n        for key, value in iter_multi_items(other_dict):\n            MultiDict.add(self, key, value)", "code_tokens": "def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )", "docstring_tokens": "update () extends rather than replaces existing key lists .", "label": 1}, {"idx": "cosqa-train-8640", "doc": "catch signals sigkill python", "code": "def set_terminate_listeners(stream):\n    \"\"\"Die on SIGTERM or SIGINT\"\"\"\n\n    def stop(signum, frame):\n        terminate(stream.listener)\n\n    # Installs signal handlers for handling SIGINT and SIGTERM\n    # gracefully.\n    signal.signal(signal.SIGINT, stop)\n    signal.signal(signal.SIGTERM, stop)", "code_tokens": "def set_terminate_listeners ( stream ) : def stop ( signum , frame ) : terminate ( stream . listener ) # Installs signal handlers for handling SIGINT and SIGTERM # gracefully. signal . signal ( signal . SIGINT , stop ) signal . signal ( signal . SIGTERM , stop )", "docstring_tokens": "Die on SIGTERM or SIGINT", "label": 0}, {"idx": "cosqa-train-8641", "doc": "python dictionary case insensitive", "code": "def keys_to_snake_case(camel_case_dict):\n    \"\"\"\n    Make a copy of a dictionary with all keys converted to snake case. This is just calls to_snake_case on\n    each of the keys in the dictionary and returns a new dictionary.\n\n    :param camel_case_dict: Dictionary with the keys to convert.\n    :type camel_case_dict: Dictionary.\n\n    :return: Dictionary with the keys converted to snake case.\n    \"\"\"\n    return dict((to_snake_case(key), value) for (key, value) in camel_case_dict.items())", "code_tokens": "def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )", "docstring_tokens": "Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .", "label": 1}, {"idx": "cosqa-train-8642", "doc": "cauculate distance between clusters python", "code": "def _cal_dist2center(X, center):\n    \"\"\" Calculate the SSE to the cluster center\n    \"\"\"\n    dmemb2cen = scipy.spatial.distance.cdist(X, center.reshape(1,X.shape[1]), metric='seuclidean')\n    return(np.sum(dmemb2cen))", "code_tokens": "def _cal_dist2center ( X , center ) : dmemb2cen = scipy . spatial . distance . cdist ( X , center . reshape ( 1 , X . shape [ 1 ] ) , metric = 'seuclidean' ) return ( np . sum ( dmemb2cen ) )", "docstring_tokens": "Calculate the SSE to the cluster center", "label": 1}, {"idx": "cosqa-train-8643", "doc": "python dictionary contain global variable, update", "code": "def update(self, params):\n        \"\"\"Update the dev_info data from a dictionary.\n\n        Only updates if it already exists in the device.\n        \"\"\"\n        dev_info = self.json_state.get('deviceInfo')\n        dev_info.update({k: params[k] for k in params if dev_info.get(k)})", "code_tokens": "def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )", "docstring_tokens": "Update the dev_info data from a dictionary .", "label": 1}, {"idx": "cosqa-train-8644", "doc": "center of an image gaussian fit python", "code": "def gauss_box_model(x, amplitude=1.0, mean=0.0, stddev=1.0, hpix=0.5):\n    \"\"\"Integrate a Gaussian profile.\"\"\"\n    z = (x - mean) / stddev\n    z2 = z + hpix / stddev\n    z1 = z - hpix / stddev\n    return amplitude * (norm.cdf(z2) - norm.cdf(z1))", "code_tokens": "def gauss_box_model ( x , amplitude = 1.0 , mean = 0.0 , stddev = 1.0 , hpix = 0.5 ) : z = ( x - mean ) / stddev z2 = z + hpix / stddev z1 = z - hpix / stddev return amplitude * ( norm . cdf ( z2 ) - norm . cdf ( z1 ) )", "docstring_tokens": "Integrate a Gaussian profile .", "label": 1}, {"idx": "cosqa-train-8645", "doc": "python dictionary dump indent", "code": "def pretty_dict_str(d, indent=2):\n    \"\"\"shows JSON indented representation of d\"\"\"\n    b = StringIO()\n    write_pretty_dict_str(b, d, indent=indent)\n    return b.getvalue()", "code_tokens": "def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )", "docstring_tokens": "shows JSON indented representation of d", "label": 0}, {"idx": "cosqa-train-8646", "doc": "centered image minus centroid python", "code": "def min_max_normalize(img):\n    \"\"\"Centre and normalize a given array.\n\n    Parameters:\n    ----------\n    img: np.ndarray\n\n    \"\"\"\n\n    min_img = img.min()\n    max_img = img.max()\n\n    return (img - min_img) / (max_img - min_img)", "code_tokens": "def min_max_normalize ( img ) : min_img = img . min ( ) max_img = img . max ( ) return ( img - min_img ) / ( max_img - min_img )", "docstring_tokens": "Centre and normalize a given array .", "label": 1}, {"idx": "cosqa-train-8647", "doc": "python dictionary in dictionary remove all specific keys", "code": "def filter_dict_by_key(d, keys):\n    \"\"\"Filter the dict *d* to remove keys not in *keys*.\"\"\"\n    return {k: v for k, v in d.items() if k in keys}", "code_tokens": "def filter_dict_by_key ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "docstring_tokens": "Filter the dict * d * to remove keys not in * keys * .", "label": 1}, {"idx": "cosqa-train-8648", "doc": "chage plot bounds python", "code": "def swap(self):\n        \"\"\"Return the box (for horizontal graphs)\"\"\"\n        self.xmin, self.ymin = self.ymin, self.xmin\n        self.xmax, self.ymax = self.ymax, self.xmax", "code_tokens": "def swap ( self ) : self . xmin , self . ymin = self . ymin , self . xmin self . xmax , self . ymax = self . ymax , self . xmax", "docstring_tokens": "Return the box ( for horizontal graphs )", "label": 0}, {"idx": "cosqa-train-8649", "doc": "python dictionary to np array", "code": "def dump_nparray(self, obj, class_name=numpy_ndarray_class_name):\n        \"\"\"\n        ``numpy.ndarray`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: self._json_convert(obj.tolist())}", "code_tokens": "def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { \"$\" + class_name : self . _json_convert ( obj . tolist ( ) ) }", "docstring_tokens": "numpy . ndarray dumper .", "label": 1}, {"idx": "cosqa-train-8650", "doc": "change a string of numbers to int python if string contains non int", "code": "def get_number(s, cast=int):\n    \"\"\"\n    Try to get a number out of a string, and cast it.\n    \"\"\"\n    import string\n    d = \"\".join(x for x in str(s) if x in string.digits)\n    return cast(d)", "code_tokens": "def get_number ( s , cast = int ) : import string d = \"\" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )", "docstring_tokens": "Try to get a number out of a string and cast it .", "label": 1}, {"idx": "cosqa-train-8651", "doc": "python dictionary write as a json readable", "code": "def pretty_dict_str(d, indent=2):\n    \"\"\"shows JSON indented representation of d\"\"\"\n    b = StringIO()\n    write_pretty_dict_str(b, d, indent=indent)\n    return b.getvalue()", "code_tokens": "def pretty_dict_str ( d , indent = 2 ) : b = StringIO ( ) write_pretty_dict_str ( b , d , indent = indent ) return b . getvalue ( )", "docstring_tokens": "shows JSON indented representation of d", "label": 0}, {"idx": "cosqa-train-8652", "doc": "change axes 3d plot python'", "code": "def plot3d_init(fignum):\n    \"\"\"\n    initializes 3D plot\n    \"\"\"\n    from mpl_toolkits.mplot3d import Axes3D\n    fig = plt.figure(fignum)\n    ax = fig.add_subplot(111, projection='3d')\n    return ax", "code_tokens": "def plot3d_init ( fignum ) : from mpl_toolkits . mplot3d import Axes3D fig = plt . figure ( fignum ) ax = fig . add_subplot ( 111 , projection = '3d' ) return ax", "docstring_tokens": "initializes 3D plot", "label": 1}, {"idx": "cosqa-train-8653", "doc": "python dill dump closure", "code": "def safe_dump_all(documents, stream=None, **kwds):\n    \"\"\"\n    Serialize a sequence of Python objects into a YAML stream.\n    Produce only basic YAML tags.\n    If stream is None, return the produced string instead.\n    \"\"\"\n    return dump_all(documents, stream, Dumper=SafeDumper, **kwds)", "code_tokens": "def safe_dump_all ( documents , stream = None , * * kwds ) : return dump_all ( documents , stream , Dumper = SafeDumper , * * kwds )", "docstring_tokens": "Serialize a sequence of Python objects into a YAML stream . Produce only basic YAML tags . If stream is None return the produced string instead .", "label": 1}, {"idx": "cosqa-train-8654", "doc": "change axis of index name in data frame python", "code": "def _update_index_on_df(df, index_names):\n    \"\"\"Helper function to restore index information after collection. Doesn't\n    use self so we can serialize this.\"\"\"\n    if index_names:\n        df = df.set_index(index_names)\n        # Remove names from unnamed indexes\n        index_names = _denormalize_index_names(index_names)\n        df.index.names = index_names\n    return df", "code_tokens": "def _update_index_on_df ( df , index_names ) : if index_names : df = df . set_index ( index_names ) # Remove names from unnamed indexes index_names = _denormalize_index_names ( index_names ) df . index . names = index_names return df", "docstring_tokens": "Helper function to restore index information after collection . Doesn t use self so we can serialize this .", "label": 1}, {"idx": "cosqa-train-8655", "doc": "python discord check if voice channel is empty", "code": "async def vc_check(ctx: commands.Context):  # pylint: disable=unused-argument\n    \"\"\"\n    Check for whether VC is available in this bot.\n    \"\"\"\n\n    if not discord.voice_client.has_nacl:\n        raise commands.CheckFailure(\"voice cannot be used because PyNaCl is not loaded\")\n\n    if not discord.opus.is_loaded():\n        raise commands.CheckFailure(\"voice cannot be used because libopus is not loaded\")\n\n    return True", "code_tokens": "async def vc_check ( ctx : commands . Context ) : # pylint: disable=unused-argument if not discord . voice_client . has_nacl : raise commands . CheckFailure ( \"voice cannot be used because PyNaCl is not loaded\" ) if not discord . opus . is_loaded ( ) : raise commands . CheckFailure ( \"voice cannot be used because libopus is not loaded\" ) return True", "docstring_tokens": "Check for whether VC is available in this bot .", "label": 1}, {"idx": "cosqa-train-8656", "doc": "change background of the image in python", "code": "def copy_image_on_background(image, color=WHITE):\n    \"\"\"\n    Create a new image by copying the image on a *color* background.\n\n    Args:\n        image (PIL.Image.Image): Image to copy\n        color (tuple): Background color usually WHITE or BLACK\n\n    Returns:\n        PIL.Image.Image\n\n    \"\"\"\n    background = Image.new(\"RGB\", image.size, color)\n    background.paste(image, mask=image.split()[3])\n    return background", "code_tokens": "def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( \"RGB\" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background", "docstring_tokens": "Create a new image by copying the image on a * color * background .", "label": 0}, {"idx": "cosqa-train-8657", "doc": "python display a list as a table\\", "code": "def _render_table(data, fields=None):\n  \"\"\" Helper to render a list of dictionaries as an HTML display object. \"\"\"\n  return IPython.core.display.HTML(datalab.utils.commands.HtmlBuilder.render_table(data, fields))", "code_tokens": "def _render_table ( data , fields = None ) : return IPython . core . display . HTML ( datalab . utils . commands . HtmlBuilder . render_table ( data , fields ) )", "docstring_tokens": "Helper to render a list of dictionaries as an HTML display object .", "label": 1}, {"idx": "cosqa-train-8658", "doc": "change global env python eval", "code": "def exec_function(ast, globals_map):\n    \"\"\"Execute a python code object in the given environment.\n\n    Args:\n      globals_map: Dictionary to use as the globals context.\n    Returns:\n      locals_map: Dictionary of locals from the environment after execution.\n    \"\"\"\n    locals_map = globals_map\n    exec ast in globals_map, locals_map\n    return locals_map", "code_tokens": "def exec_function ( ast , globals_map ) : locals_map = globals_map exec ast in globals_map , locals_map return locals_map", "docstring_tokens": "Execute a python code object in the given environment .", "label": 1}, {"idx": "cosqa-train-8659", "doc": "python distinct values query", "code": "def fast_distinct(self):\n        \"\"\"\n        Because standard distinct used on the all fields are very slow and works only with PostgreSQL database\n        this method provides alternative to the standard distinct method.\n        :return: qs with unique objects\n        \"\"\"\n        return self.model.objects.filter(pk__in=self.values_list('pk', flat=True))", "code_tokens": "def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )", "docstring_tokens": "Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects", "label": 1}, {"idx": "cosqa-train-8660", "doc": "change logging format during runtime python", "code": "def logger(message, level=10):\n    \"\"\"Handle logging.\"\"\"\n    logging.getLogger(__name__).log(level, str(message))", "code_tokens": "def logger ( message , level = 10 ) : logging . getLogger ( __name__ ) . log ( level , str ( message ) )", "docstring_tokens": "Handle logging .", "label": 1}, {"idx": "cosqa-train-8661", "doc": "python django booleanfield default", "code": "def parse_value(self, value):\n        \"\"\"Cast value to `bool`.\"\"\"\n        parsed = super(BoolField, self).parse_value(value)\n        return bool(parsed) if parsed is not None else None", "code_tokens": "def parse_value ( self , value ) : parsed = super ( BoolField , self ) . parse_value ( value ) return bool ( parsed ) if parsed is not None else None", "docstring_tokens": "Cast value to bool .", "label": 1}, {"idx": "cosqa-train-8662", "doc": "change na values in series python", "code": "def na_if(series, *values):\n    \"\"\"\n    If values in a series match a specified value, change them to `np.nan`.\n\n    Args:\n        series: Series or vector, often symbolic.\n        *values: Value(s) to convert to `np.nan` in the series.\n    \"\"\"\n\n    series = pd.Series(series)\n    series[series.isin(values)] = np.nan\n    return series", "code_tokens": "def na_if ( series , * values ) : series = pd . Series ( series ) series [ series . isin ( values ) ] = np . nan return series", "docstring_tokens": "If values in a series match a specified value change them to np . nan .", "label": 1}, {"idx": "cosqa-train-8663", "doc": "python django foreach list to str with ,", "code": "def commajoin_as_strings(iterable):\n    \"\"\" Join the given iterable with ',' \"\"\"\n    return _(u',').join((six.text_type(i) for i in iterable))", "code_tokens": "def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )", "docstring_tokens": "Join the given iterable with", "label": 1}, {"idx": "cosqa-train-8664", "doc": "change position of text cursor in combobox text field python", "code": "def set_cursor_position(self, position):\n        \"\"\"Set cursor position\"\"\"\n        position = self.get_position(position)\n        cursor = self.textCursor()\n        cursor.setPosition(position)\n        self.setTextCursor(cursor)\n        self.ensureCursorVisible()", "code_tokens": "def set_cursor_position ( self , position ) : position = self . get_position ( position ) cursor = self . textCursor ( ) cursor . setPosition ( position ) self . setTextCursor ( cursor ) self . ensureCursorVisible ( )", "docstring_tokens": "Set cursor position", "label": 1}, {"idx": "cosqa-train-8665", "doc": "python django link static files", "code": "def glr_path_static():\n    \"\"\"Returns path to packaged static files\"\"\"\n    return os.path.abspath(os.path.join(os.path.dirname(__file__), '_static'))", "code_tokens": "def glr_path_static ( ) : return os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '_static' ) )", "docstring_tokens": "Returns path to packaged static files", "label": 1}, {"idx": "cosqa-train-8666", "doc": "change python file set last modified date", "code": "def set_time(filename, mod_time):\n\t\"\"\"\n\tSet the modified time of a file\n\t\"\"\"\n\tlog.debug('Setting modified time to %s', mod_time)\n\tmtime = calendar.timegm(mod_time.utctimetuple())\n\t# utctimetuple discards microseconds, so restore it (for consistency)\n\tmtime += mod_time.microsecond / 1000000\n\tatime = os.stat(filename).st_atime\n\tos.utime(filename, (atime, mtime))", "code_tokens": "def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)\n mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )", "docstring_tokens": "Set the modified time of a file", "label": 1}, {"idx": "cosqa-train-8667", "doc": "python django request header exists", "code": "def get_header(request, header_service):\n    \"\"\"Return request's 'X_POLYAXON_...:' header, as a bytestring.\n\n    Hide some test client ickyness where the header can be unicode.\n    \"\"\"\n    service = request.META.get('HTTP_{}'.format(header_service), b'')\n    if isinstance(service, str):\n        # Work around django test client oddness\n        service = service.encode(HTTP_HEADER_ENCODING)\n    return service", "code_tokens": "def get_header ( request , header_service ) : service = request . META . get ( 'HTTP_{}' . format ( header_service ) , b'' ) if isinstance ( service , str ) : # Work around django test client oddness service = service . encode ( HTTP_HEADER_ENCODING ) return service", "docstring_tokens": "Return request s X_POLYAXON_ ... : header as a bytestring .", "label": 0}, {"idx": "cosqa-train-8668", "doc": "change python list of sting to float", "code": "def string_to_float_list(string_var):\n        \"\"\"Pull comma separated string values out of a text file and converts them to float list\"\"\"\n        try:\n            return [float(s) for s in string_var.strip('[').strip(']').split(', ')]\n        except:\n            return [float(s) for s in string_var.strip('[').strip(']').split(',')]", "code_tokens": "def string_to_float_list ( string_var ) : try : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ', ' ) ] except : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ',' ) ]", "docstring_tokens": "Pull comma separated string values out of a text file and converts them to float list", "label": 1}, {"idx": "cosqa-train-8669", "doc": "python dll deallocate memory", "code": "def __del__(self):\n        \"\"\"Cleanup any active connections and free all DDEML resources.\"\"\"\n        if self._hConv:\n            DDE.Disconnect(self._hConv)\n        if self._idInst:\n            DDE.Uninitialize(self._idInst)", "code_tokens": "def __del__ ( self ) : if self . _hConv : DDE . Disconnect ( self . _hConv ) if self . _idInst : DDE . Uninitialize ( self . _idInst )", "docstring_tokens": "Cleanup any active connections and free all DDEML resources .", "label": 1}, {"idx": "cosqa-train-8670", "doc": "change str to boolena python", "code": "def strToBool(val):\n    \"\"\"\n    Helper function to turn a string representation of \"true\" into\n    boolean True.\n    \"\"\"\n    if isinstance(val, str):\n        val = val.lower()\n\n    return val in ['true', 'on', 'yes', True]", "code_tokens": "def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]", "docstring_tokens": "Helper function to turn a string representation of true into boolean True .", "label": 1}, {"idx": "cosqa-train-8671", "doc": "python documentation suppress space", "code": "def format_doc_text(text):\n    \"\"\"\n    A very thin wrapper around textwrap.fill to consistently wrap documentation text\n    for display in a command line environment. The text is wrapped to 99 characters with an\n    indentation depth of 4 spaces. Each line is wrapped independently in order to preserve\n    manually added line breaks.\n\n    :param text: The text to format, it is cleaned by inspect.cleandoc.\n    :return: The formatted doc text.\n    \"\"\"\n\n    return '\\n'.join(\n        textwrap.fill(line, width=99, initial_indent='    ', subsequent_indent='    ')\n        for line in inspect.cleandoc(text).splitlines())", "code_tokens": "def format_doc_text ( text ) : return '\\n' . join ( textwrap . fill ( line , width = 99 , initial_indent = '    ' , subsequent_indent = '    ' ) for line in inspect . cleandoc ( text ) . splitlines ( ) )", "docstring_tokens": "A very thin wrapper around textwrap . fill to consistently wrap documentation text for display in a command line environment . The text is wrapped to 99 characters with an indentation depth of 4 spaces . Each line is wrapped independently in order to preserve manually added line breaks .", "label": 1}, {"idx": "cosqa-train-8672", "doc": "change to array python", "code": "def adapt_array(arr):\n    \"\"\"\n    http://stackoverflow.com/a/31312102/190597 (SoulNibbler)\n    \"\"\"\n    out = io.BytesIO()\n    np.save(out, arr)\n    out.seek(0)\n    return sqlite3.Binary(out.read())", "code_tokens": "def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) out . seek ( 0 ) return sqlite3 . Binary ( out . read ( ) )", "docstring_tokens": "http : // stackoverflow . com / a / 31312102 / 190597 ( SoulNibbler )", "label": 1}, {"idx": "cosqa-train-8673", "doc": "python docx no style with name", "code": "def prepare(doc):\n    \"\"\"Sets the caption_found and plot_found variables to False.\"\"\"\n    doc.caption_found = False\n    doc.plot_found = False\n    doc.listings_counter = 0", "code_tokens": "def prepare ( doc ) : doc . caption_found = False doc . plot_found = False doc . listings_counter = 0", "docstring_tokens": "Sets the caption_found and plot_found variables to False .", "label": 0}, {"idx": "cosqa-train-8674", "doc": "change treemap labels in python", "code": "def _renamer(self, tre):\n        \"\"\" renames newick from numbers to sample names\"\"\"\n        ## get the tre with numbered tree tip labels\n        names = tre.get_leaves()\n\n        ## replace numbered names with snames\n        for name in names:\n            name.name = self.samples[int(name.name)]\n\n        ## return with only topology and leaf labels\n        return tre.write(format=9)", "code_tokens": "def _renamer ( self , tre ) : ## get the tre with numbered tree tip labels names = tre . get_leaves ( ) ## replace numbered names with snames for name in names : name . name = self . samples [ int ( name . name ) ] ## return with only topology and leaf labels return tre . write ( format = 9 )", "docstring_tokens": "renames newick from numbers to sample names", "label": 1}, {"idx": "cosqa-train-8675", "doc": "python dot write dot flush", "code": "def comment (self, s, **args):\n        \"\"\"Write DOT comment.\"\"\"\n        self.write(u\"// \")\n        self.writeln(s=s, **args)", "code_tokens": "def comment ( self , s , * * args ) : self . write ( u\"// \" ) self . writeln ( s = s , * * args )", "docstring_tokens": "Write DOT comment .", "label": 1}, {"idx": "cosqa-train-8676", "doc": "change type in python to string", "code": "def to_str(obj):\n    \"\"\"Attempts to convert given object to a string object\n    \"\"\"\n    if not isinstance(obj, str) and PY3 and isinstance(obj, bytes):\n        obj = obj.decode('utf-8')\n    return obj if isinstance(obj, string_types) else str(obj)", "code_tokens": "def to_str ( obj ) : if not isinstance ( obj , str ) and PY3 and isinstance ( obj , bytes ) : obj = obj . decode ( 'utf-8' ) return obj if isinstance ( obj , string_types ) else str ( obj )", "docstring_tokens": "Attempts to convert given object to a string object", "label": 0}, {"idx": "cosqa-train-8677", "doc": "python double click in tree view", "code": "def OnRootView(self, event):\n        \"\"\"Reset view to the root of the tree\"\"\"\n        self.adapter, tree, rows = self.RootNode()\n        self.squareMap.SetModel(tree, self.adapter)\n        self.RecordHistory()\n        self.ConfigureViewTypeChoices()", "code_tokens": "def OnRootView ( self , event ) : self . adapter , tree , rows = self . RootNode ( ) self . squareMap . SetModel ( tree , self . adapter ) self . RecordHistory ( ) self . ConfigureViewTypeChoices ( )", "docstring_tokens": "Reset view to the root of the tree", "label": 1}, {"idx": "cosqa-train-8678", "doc": "changing data types in python data frame", "code": "def _to_corrected_pandas_type(dt):\n    \"\"\"\n    When converting Spark SQL records to Pandas DataFrame, the inferred data type may be wrong.\n    This method gets the corrected data type for Pandas if that type may be inferred uncorrectly.\n    \"\"\"\n    import numpy as np\n    if type(dt) == ByteType:\n        return np.int8\n    elif type(dt) == ShortType:\n        return np.int16\n    elif type(dt) == IntegerType:\n        return np.int32\n    elif type(dt) == FloatType:\n        return np.float32\n    else:\n        return None", "code_tokens": "def _to_corrected_pandas_type ( dt ) : import numpy as np if type ( dt ) == ByteType : return np . int8 elif type ( dt ) == ShortType : return np . int16 elif type ( dt ) == IntegerType : return np . int32 elif type ( dt ) == FloatType : return np . float32 else : return None", "docstring_tokens": "When converting Spark SQL records to Pandas DataFrame the inferred data type may be wrong . This method gets the corrected data type for Pandas if that type may be inferred uncorrectly .", "label": 1}, {"idx": "cosqa-train-8679", "doc": "python draw image frombyte array", "code": "def from_bytes(cls, b):\n\t\t\"\"\"Create :class:`PNG` from raw bytes.\n\t\t\n\t\t:arg bytes b: The raw bytes of the PNG file.\n\t\t:rtype: :class:`PNG`\n\t\t\"\"\"\n\t\tim = cls()\n\t\tim.chunks = list(parse_chunks(b))\n\t\tim.init()\n\t\treturn im", "code_tokens": "def from_bytes ( cls , b ) : im = cls ( ) im . chunks = list ( parse_chunks ( b ) ) im . init ( ) return im", "docstring_tokens": "Create : class : PNG from raw bytes . : arg bytes b : The raw bytes of the PNG file . : rtype : : class : PNG", "label": 1}, {"idx": "cosqa-train-8680", "doc": "changing pixels opencv python", "code": "def screen_cv2(self):\n        \"\"\"cv2 Image of current window screen\"\"\"\n        pil_image = self.screen.convert('RGB')\n        cv2_image = np.array(pil_image)\n        pil_image.close()\n        # Convert RGB to BGR \n        cv2_image = cv2_image[:, :, ::-1]\n        return cv2_image", "code_tokens": "def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR \n cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image", "docstring_tokens": "cv2 Image of current window screen", "label": 0}, {"idx": "cosqa-train-8681", "doc": "python draw line with scope and intercept", "code": "def vline(self, x, y, height, color):\n        \"\"\"Draw a vertical line up to a given length.\"\"\"\n        self.rect(x, y, 1, height, color, fill=True)", "code_tokens": "def vline ( self , x , y , height , color ) : self . rect ( x , y , 1 , height , color , fill = True )", "docstring_tokens": "Draw a vertical line up to a given length .", "label": 1}, {"idx": "cosqa-train-8682", "doc": "changing timezone utc to est python", "code": "def to_utc(self, dt):\n        \"\"\"Convert any timestamp to UTC (with tzinfo).\"\"\"\n        if dt.tzinfo is None:\n            return dt.replace(tzinfo=self.utc)\n        return dt.astimezone(self.utc)", "code_tokens": "def to_utc ( self , dt ) : if dt . tzinfo is None : return dt . replace ( tzinfo = self . utc ) return dt . astimezone ( self . utc )", "docstring_tokens": "Convert any timestamp to UTC ( with tzinfo ) .", "label": 1}, {"idx": "cosqa-train-8683", "doc": "python draw rectangle with dotted line", "code": "def hline(self, x, y, width, color):\n        \"\"\"Draw a horizontal line up to a given length.\"\"\"\n        self.rect(x, y, width, 1, color, fill=True)", "code_tokens": "def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )", "docstring_tokens": "Draw a horizontal line up to a given length .", "label": 1}, {"idx": "cosqa-train-8684", "doc": "chart multiple glyphs in bokeh python", "code": "def _init_glyph(self, plot, mapping, properties):\n        \"\"\"\n        Returns a Bokeh glyph object.\n        \"\"\"\n        properties = mpl_to_bokeh(properties)\n        plot_method = self._plot_methods.get('batched' if self.batched else 'single')\n        if isinstance(plot_method, tuple):\n            # Handle alternative plot method for flipped axes\n            plot_method = plot_method[int(self.invert_axes)]\n        renderer = getattr(plot, plot_method)(**dict(properties, **mapping))\n        return renderer, renderer.glyph", "code_tokens": "def _init_glyph ( self , plot , mapping , properties ) : properties = mpl_to_bokeh ( properties ) plot_method = self . _plot_methods . get ( 'batched' if self . batched else 'single' ) if isinstance ( plot_method , tuple ) : # Handle alternative plot method for flipped axes plot_method = plot_method [ int ( self . invert_axes ) ] renderer = getattr ( plot , plot_method ) ( * * dict ( properties , * * mapping ) ) return renderer , renderer . glyph", "docstring_tokens": "Returns a Bokeh glyph object .", "label": 1}, {"idx": "cosqa-train-8685", "doc": "python dump current logger", "code": "def pylog(self, *args, **kwargs):\n        \"\"\"Display all available logging information.\"\"\"\n        printerr(self.name, args, kwargs, traceback.format_exc())", "code_tokens": "def pylog ( self , * args , * * kwargs ) : printerr ( self . name , args , kwargs , traceback . format_exc ( ) )", "docstring_tokens": "Display all available logging information .", "label": 0}, {"idx": "cosqa-train-8686", "doc": "check config value is defined in python", "code": "def _is_already_configured(configuration_details):\n    \"\"\"Returns `True` when alias already in shell config.\"\"\"\n    path = Path(configuration_details.path).expanduser()\n    with path.open('r') as shell_config:\n        return configuration_details.content in shell_config.read()", "code_tokens": "def _is_already_configured ( configuration_details ) : path = Path ( configuration_details . path ) . expanduser ( ) with path . open ( 'r' ) as shell_config : return configuration_details . content in shell_config . read ( )", "docstring_tokens": "Returns True when alias already in shell config .", "label": 1}, {"idx": "cosqa-train-8687", "doc": "python dump diction to yaml", "code": "def safe_dump(data, stream=None, **kwds):\n    \"\"\"implementation of safe dumper using Ordered Dict Yaml Dumper\"\"\"\n    return yaml.dump(data, stream=stream, Dumper=ODYD, **kwds)", "code_tokens": "def safe_dump ( data , stream = None , * * kwds ) : return yaml . dump ( data , stream = stream , Dumper = ODYD , * * kwds )", "docstring_tokens": "implementation of safe dumper using Ordered Dict Yaml Dumper", "label": 0}, {"idx": "cosqa-train-8688", "doc": "check dupliates in the combinatin of tow datafrmae columns in python", "code": "def duplicated_rows(df, col_name):\n    \"\"\" Return a DataFrame with the duplicated values of the column `col_name`\n    in `df`.\"\"\"\n    _check_cols(df, [col_name])\n\n    dups = df[pd.notnull(df[col_name]) & df.duplicated(subset=[col_name])]\n    return dups", "code_tokens": "def duplicated_rows ( df , col_name ) : _check_cols ( df , [ col_name ] ) dups = df [ pd . notnull ( df [ col_name ] ) & df . duplicated ( subset = [ col_name ] ) ] return dups", "docstring_tokens": "Return a DataFrame with the duplicated values of the column col_name in df .", "label": 1}, {"idx": "cosqa-train-8689", "doc": "python duplicated set in list", "code": "def delete_duplicates(seq):\n    \"\"\"\n    Remove duplicates from an iterable, preserving the order.\n\n    Args:\n        seq: Iterable of various type.\n\n    Returns:\n        list: List of unique objects.\n\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "Remove duplicates from an iterable preserving the order .", "label": 1}, {"idx": "cosqa-train-8690", "doc": "check file eof in python", "code": "def eof(fd):\n    \"\"\"Determine if end-of-file is reached for file fd.\"\"\"\n    b = fd.read(1)\n    end = len(b) == 0\n    if not end:\n        curpos = fd.tell()\n        fd.seek(curpos - 1)\n    return end", "code_tokens": "def eof ( fd ) : b = fd . read ( 1 ) end = len ( b ) == 0 if not end : curpos = fd . tell ( ) fd . seek ( curpos - 1 ) return end", "docstring_tokens": "Determine if end - of - file is reached for file fd .", "label": 0}, {"idx": "cosqa-train-8691", "doc": "python dynamic doc string", "code": "def _add_params_docstring(params):\n    \"\"\" Add params to doc string\n    \"\"\"\n    p_string = \"\\nAccepts the following paramters: \\n\"\n    for param in params:\n         p_string += \"name: %s, required: %s, description: %s \\n\" % (param['name'], param['required'], param['description'])\n    return p_string", "code_tokens": "def _add_params_docstring ( params ) : p_string = \"\\nAccepts the following paramters: \\n\" for param in params : p_string += \"name: %s, required: %s, description: %s \\n\" % ( param [ 'name' ] , param [ 'required' ] , param [ 'description' ] ) return p_string", "docstring_tokens": "Add params to doc string", "label": 0}, {"idx": "cosqa-train-8692", "doc": "check for 404 with requests python", "code": "def _request_limit_reached(exception):\n    \"\"\" Checks if exception was raised because of too many executed requests. (This is a temporal solution and\n    will be changed in later package versions.)\n\n    :param exception: Exception raised during download\n    :type exception: Exception\n    :return: True if exception is caused because too many requests were executed at once and False otherwise\n    :rtype: bool\n    \"\"\"\n    return isinstance(exception, requests.HTTPError) and \\\n        exception.response.status_code == requests.status_codes.codes.TOO_MANY_REQUESTS", "code_tokens": "def _request_limit_reached ( exception ) : return isinstance ( exception , requests . HTTPError ) and exception . response . status_code == requests . status_codes . codes . TOO_MANY_REQUESTS", "docstring_tokens": "Checks if exception was raised because of too many executed requests . ( This is a temporal solution and will be changed in later package versions . )", "label": 1}, {"idx": "cosqa-train-8693", "doc": "python dynamic field access", "code": "def _basic_field_data(field, obj):\n    \"\"\"Returns ``obj.field`` data as a dict\"\"\"\n    value = field.value_from_object(obj)\n    return {Field.TYPE: FieldType.VAL, Field.VALUE: value}", "code_tokens": "def _basic_field_data ( field , obj ) : value = field . value_from_object ( obj ) return { Field . TYPE : FieldType . VAL , Field . VALUE : value }", "docstring_tokens": "Returns obj . field data as a dict", "label": 1}, {"idx": "cosqa-train-8694", "doc": "check if a python variable is a numpy datetime64", "code": "def ensure_us_time_resolution(val):\n    \"\"\"Convert val out of numpy time, for use in to_dict.\n    Needed because of numpy bug GH#7619\"\"\"\n    if np.issubdtype(val.dtype, np.datetime64):\n        val = val.astype('datetime64[us]')\n    elif np.issubdtype(val.dtype, np.timedelta64):\n        val = val.astype('timedelta64[us]')\n    return val", "code_tokens": "def ensure_us_time_resolution ( val ) : if np . issubdtype ( val . dtype , np . datetime64 ) : val = val . astype ( 'datetime64[us]' ) elif np . issubdtype ( val . dtype , np . timedelta64 ) : val = val . astype ( 'timedelta64[us]' ) return val", "docstring_tokens": "Convert val out of numpy time for use in to_dict . Needed because of numpy bug GH#7619", "label": 1}, {"idx": "cosqa-train-8695", "doc": "python efficient paren matching", "code": "def match_paren(self, tokens, item):\n        \"\"\"Matches a paren.\"\"\"\n        match, = tokens\n        return self.match(match, item)", "code_tokens": "def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "docstring_tokens": "Matches a paren .", "label": 0}, {"idx": "cosqa-train-8696", "doc": "check if a queue is empty python", "code": "def full(self):\n        \"\"\"Return True if the queue is full\"\"\"\n        if not self.size: return False\n        return len(self.pq) == (self.size + self.removed_count)", "code_tokens": "def full ( self ) : if not self . size : return False return len ( self . pq ) == ( self . size + self . removed_count )", "docstring_tokens": "Return True if the queue is full", "label": 0}, {"idx": "cosqa-train-8697", "doc": "python elasticsearch bulk index tail", "code": "def update_index(index):\n    \"\"\"Re-index every document in a named index.\"\"\"\n    logger.info(\"Updating search index: '%s'\", index)\n    client = get_client()\n    responses = []\n    for model in get_index_models(index):\n        logger.info(\"Updating search index model: '%s'\", model.search_doc_type)\n        objects = model.objects.get_search_queryset(index).iterator()\n        actions = bulk_actions(objects, index=index, action=\"index\")\n        response = helpers.bulk(client, actions, chunk_size=get_setting(\"chunk_size\"))\n        responses.append(response)\n    return responses", "code_tokens": "def update_index ( index ) : logger . info ( \"Updating search index: '%s'\" , index ) client = get_client ( ) responses = [ ] for model in get_index_models ( index ) : logger . info ( \"Updating search index model: '%s'\" , model . search_doc_type ) objects = model . objects . get_search_queryset ( index ) . iterator ( ) actions = bulk_actions ( objects , index = index , action = \"index\" ) response = helpers . bulk ( client , actions , chunk_size = get_setting ( \"chunk_size\" ) ) responses . append ( response ) return responses", "docstring_tokens": "Re - index every document in a named index .", "label": 0}, {"idx": "cosqa-train-8698", "doc": "check if a value is a list python", "code": "def is_listish(obj):\n    \"\"\"Check if something quacks like a list.\"\"\"\n    if isinstance(obj, (list, tuple, set)):\n        return True\n    return is_sequence(obj)", "code_tokens": "def is_listish ( obj ) : if isinstance ( obj , ( list , tuple , set ) ) : return True return is_sequence ( obj )", "docstring_tokens": "Check if something quacks like a list .", "label": 1}, {"idx": "cosqa-train-8699", "doc": "python elasticsearch get types in index", "code": "def determine_types(self):\n        \"\"\" Determine ES type names from request data.\n\n        In particular `request.matchdict['collections']` is used to\n        determine types names. Its value is comma-separated sequence\n        of collection names under which views have been registered.\n        \"\"\"\n        from nefertari.elasticsearch import ES\n        collections = self.get_collections()\n        resources = self.get_resources(collections)\n        models = set([res.view.Model for res in resources])\n        es_models = [mdl for mdl in models if mdl\n                     and getattr(mdl, '_index_enabled', False)]\n        types = [ES.src2type(mdl.__name__) for mdl in es_models]\n        return types", "code_tokens": "def determine_types ( self ) : from nefertari . elasticsearch import ES collections = self . get_collections ( ) resources = self . get_resources ( collections ) models = set ( [ res . view . Model for res in resources ] ) es_models = [ mdl for mdl in models if mdl and getattr ( mdl , '_index_enabled' , False ) ] types = [ ES . src2type ( mdl . __name__ ) for mdl in es_models ] return types", "docstring_tokens": "Determine ES type names from request data .", "label": 0}, {"idx": "cosqa-train-8700", "doc": "check if array contains integer python", "code": "def is_int_vector(l):\n    r\"\"\"Checks if l is a numpy array of integers\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 1 and (l.dtype.kind == 'i' or l.dtype.kind == 'u'):\n            return True\n    return False", "code_tokens": "def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False", "docstring_tokens": "r Checks if l is a numpy array of integers", "label": 1}, {"idx": "cosqa-train-8701", "doc": "python elasticsearch list of types in index", "code": "def determine_types(self):\n        \"\"\" Determine ES type names from request data.\n\n        In particular `request.matchdict['collections']` is used to\n        determine types names. Its value is comma-separated sequence\n        of collection names under which views have been registered.\n        \"\"\"\n        from nefertari.elasticsearch import ES\n        collections = self.get_collections()\n        resources = self.get_resources(collections)\n        models = set([res.view.Model for res in resources])\n        es_models = [mdl for mdl in models if mdl\n                     and getattr(mdl, '_index_enabled', False)]\n        types = [ES.src2type(mdl.__name__) for mdl in es_models]\n        return types", "code_tokens": "def determine_types ( self ) : from nefertari . elasticsearch import ES collections = self . get_collections ( ) resources = self . get_resources ( collections ) models = set ( [ res . view . Model for res in resources ] ) es_models = [ mdl for mdl in models if mdl and getattr ( mdl , '_index_enabled' , False ) ] types = [ ES . src2type ( mdl . __name__ ) for mdl in es_models ] return types", "docstring_tokens": "Determine ES type names from request data .", "label": 1}, {"idx": "cosqa-train-8702", "doc": "check if data is sequence of vectors python", "code": "def is_vector(inp):\n    \"\"\" Returns true if the input can be interpreted as a 'true' vector\n\n    Note\n    ----\n    Does only check dimensions, not if type is numeric\n\n    Parameters\n    ----------\n    inp : numpy.ndarray or something that can be converted into ndarray\n\n    Returns\n    -------\n    Boolean\n        True for vectors: ndim = 1 or ndim = 2 and shape of one axis = 1\n        False for all other arrays\n    \"\"\"\n    inp = np.asarray(inp)\n    nr_dim = np.ndim(inp)\n    if nr_dim == 1:\n        return True\n    elif (nr_dim == 2) and (1 in inp.shape):\n        return True\n    else:\n        return False", "code_tokens": "def is_vector ( inp ) : inp = np . asarray ( inp ) nr_dim = np . ndim ( inp ) if nr_dim == 1 : return True elif ( nr_dim == 2 ) and ( 1 in inp . shape ) : return True else : return False", "docstring_tokens": "Returns true if the input can be interpreted as a true vector", "label": 0}, {"idx": "cosqa-train-8703", "doc": "python eliminate blank lines from a file", "code": "def lines(input):\n    \"\"\"Remove comments and empty lines\"\"\"\n    for raw_line in input:\n        line = raw_line.strip()\n        if line and not line.startswith('#'):\n            yield strip_comments(line)", "code_tokens": "def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )", "docstring_tokens": "Remove comments and empty lines", "label": 1}, {"idx": "cosqa-train-8704", "doc": "check if dictionary key is in a string python", "code": "def __contains__ (self, key):\n        \"\"\"Check lowercase key item.\"\"\"\n        assert isinstance(key, basestring)\n        return dict.__contains__(self, key.lower())", "code_tokens": "def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "docstring_tokens": "Check lowercase key item .", "label": 0}, {"idx": "cosqa-train-8705", "doc": "python emptying current memory", "code": "def close( self ):\n        \"\"\"\n        Close the db and release memory\n        \"\"\"\n        if self.db is not None:\n            self.db.commit()\n            self.db.close()\n            self.db = None\n\n        return", "code_tokens": "def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return", "docstring_tokens": "Close the db and release memory", "label": 0}, {"idx": "cosqa-train-8706", "doc": "check if folder is writeable python", "code": "def _writable_dir(path):\n    \"\"\"Whether `path` is a directory, to which the user has write access.\"\"\"\n    return os.path.isdir(path) and os.access(path, os.W_OK)", "code_tokens": "def _writable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . W_OK )", "docstring_tokens": "Whether path is a directory to which the user has write access .", "label": 1}, {"idx": "cosqa-train-8707", "doc": "python ensure objects passed into a function are immutable", "code": "def mutating_method(func):\n    \"\"\"Decorator for methods that are allowed to modify immutable objects\"\"\"\n    def wrapper(self, *__args, **__kwargs):\n        old_mutable = self._mutable\n        self._mutable = True\n        try:\n            # Call the wrapped function\n            return func(self, *__args, **__kwargs)\n        finally:\n            self._mutable = old_mutable\n    return wrapper", "code_tokens": "def mutating_method ( func ) : def wrapper ( self , * __args , * * __kwargs ) : old_mutable = self . _mutable self . _mutable = True try : # Call the wrapped function return func ( self , * __args , * * __kwargs ) finally : self . _mutable = old_mutable return wrapper", "docstring_tokens": "Decorator for methods that are allowed to modify immutable objects", "label": 0}, {"idx": "cosqa-train-8708", "doc": "check if headers python text", "code": "def required_header(header):\n    \"\"\"Function that verify if the header parameter is a essential header\n\n    :param header:  A string represented a header\n    :returns:       A boolean value that represent if the header is required\n    \"\"\"\n    if header in IGNORE_HEADERS:\n        return False\n\n    if header.startswith('HTTP_') or header == 'CONTENT_TYPE':\n        return True\n\n    return False", "code_tokens": "def required_header ( header ) : if header in IGNORE_HEADERS : return False if header . startswith ( 'HTTP_' ) or header == 'CONTENT_TYPE' : return True return False", "docstring_tokens": "Function that verify if the header parameter is a essential header", "label": 1}, {"idx": "cosqa-train-8709", "doc": "python enum code style", "code": "def write_enum(fo, datum, schema):\n    \"\"\"An enum is encoded by a int, representing the zero-based position of\n    the symbol in the schema.\"\"\"\n    index = schema['symbols'].index(datum)\n    write_int(fo, index)", "code_tokens": "def write_enum ( fo , datum , schema ) : index = schema [ 'symbols' ] . index ( datum ) write_int ( fo , index )", "docstring_tokens": "An enum is encoded by a int representing the zero - based position of the symbol in the schema .", "label": 1}, {"idx": "cosqa-train-8710", "doc": "check if stringstarts with python", "code": "def __is__(cls, s):\n        \"\"\"Test if string matches this argument's format.\"\"\"\n        return s.startswith(cls.delims()[0]) and s.endswith(cls.delims()[1])", "code_tokens": "def __is__ ( cls , s ) : return s . startswith ( cls . delims ( ) [ 0 ] ) and s . endswith ( cls . delims ( ) [ 1 ] )", "docstring_tokens": "Test if string matches this argument s format .", "label": 1}, {"idx": "cosqa-train-8711", "doc": "python enum control print", "code": "def _dump_enum(self, e, top=''):\n        \"\"\"Dump single enum type.\n        \n        Keyword arguments:\n        top -- top namespace\n        \"\"\"\n        self._print()\n        self._print('enum {} {{'.format(e.name))\n        self.defines.append('{}.{}'.format(top,e.name))\n        \n        self.tabs+=1\n        for v in e.value:\n            self._print('{} = {};'.format(v.name, v.number))\n        self.tabs-=1\n        self._print('}')", "code_tokens": "def _dump_enum ( self , e , top = '' ) : self . _print ( ) self . _print ( 'enum {} {{' . format ( e . name ) ) self . defines . append ( '{}.{}' . format ( top , e . name ) ) self . tabs += 1 for v in e . value : self . _print ( '{} = {};' . format ( v . name , v . number ) ) self . tabs -= 1 self . _print ( '}' )", "docstring_tokens": "Dump single enum type . Keyword arguments : top -- top namespace", "label": 0}, {"idx": "cosqa-train-8712", "doc": "check index mongod python", "code": "def ensure_index(self, key, unique=False):\n        \"\"\"Wrapper for pymongo.Collection.ensure_index\n        \"\"\"\n        return self.collection.ensure_index(key, unique=unique)", "code_tokens": "def ensure_index ( self , key , unique = False ) : return self . collection . ensure_index ( key , unique = unique )", "docstring_tokens": "Wrapper for pymongo . Collection . ensure_index", "label": 1}, {"idx": "cosqa-train-8713", "doc": "python enum custom enummeta", "code": "def describe_enum_value(enum_value):\n    \"\"\"Build descriptor for Enum instance.\n\n    Args:\n      enum_value: Enum value to provide descriptor for.\n\n    Returns:\n      Initialized EnumValueDescriptor instance describing the Enum instance.\n    \"\"\"\n    enum_value_descriptor = EnumValueDescriptor()\n    enum_value_descriptor.name = six.text_type(enum_value.name)\n    enum_value_descriptor.number = enum_value.number\n    return enum_value_descriptor", "code_tokens": "def describe_enum_value ( enum_value ) : enum_value_descriptor = EnumValueDescriptor ( ) enum_value_descriptor . name = six . text_type ( enum_value . name ) enum_value_descriptor . number = enum_value . number return enum_value_descriptor", "docstring_tokens": "Build descriptor for Enum instance .", "label": 1}, {"idx": "cosqa-train-8714", "doc": "check is checkbox is checked python", "code": "def set_value(self, value):\n        \"\"\"Set value of the checkbox.\n\n        Parameters\n        ----------\n        value : bool\n            value for the checkbox\n\n        \"\"\"\n        if value:\n            self.setChecked(Qt.Checked)\n        else:\n            self.setChecked(Qt.Unchecked)", "code_tokens": "def set_value ( self , value ) : if value : self . setChecked ( Qt . Checked ) else : self . setChecked ( Qt . Unchecked )", "docstring_tokens": "Set value of the checkbox .", "label": 1}, {"idx": "cosqa-train-8715", "doc": "check my python intrepreter location", "code": "def is_defined(self, objtxt, force_import=False):\n        \"\"\"Return True if object is defined\"\"\"\n        return self.interpreter.is_defined(objtxt, force_import)", "code_tokens": "def is_defined ( self , objtxt , force_import = False ) : return self . interpreter . is_defined ( objtxt , force_import )", "docstring_tokens": "Return True if object is defined", "label": 0}, {"idx": "cosqa-train-8716", "doc": "python enum has name", "code": "def Value(self, name):\n    \"\"\"Returns the value coresponding to the given enum name.\"\"\"\n    if name in self._enum_type.values_by_name:\n      return self._enum_type.values_by_name[name].number\n    raise ValueError('Enum %s has no value defined for name %s' % (\n        self._enum_type.name, name))", "code_tokens": "def Value ( self , name ) : if name in self . _enum_type . values_by_name : return self . _enum_type . values_by_name [ name ] . number raise ValueError ( 'Enum %s has no value defined for name %s' % ( self . _enum_type . name , name ) )", "docstring_tokens": "Returns the value coresponding to the given enum name .", "label": 1}, {"idx": "cosqa-train-8717", "doc": "check prefix in string in python", "code": "def starts_with_prefix_in_list(text, prefixes):\n    \"\"\"\n    Return True if the given string starts with one of the prefixes in the given list, otherwise\n    return False.\n\n    Arguments:\n        text (str): Text to check for prefixes.\n        prefixes (list): List of prefixes to check for.\n\n    Returns:\n        bool: True if the given text starts with any of the given prefixes, otherwise False.\n    \"\"\"\n    for prefix in prefixes:\n        if text.startswith(prefix):\n            return True\n    return False", "code_tokens": "def starts_with_prefix_in_list ( text , prefixes ) : for prefix in prefixes : if text . startswith ( prefix ) : return True return False", "docstring_tokens": "Return True if the given string starts with one of the prefixes in the given list otherwise return False .", "label": 0}, {"idx": "cosqa-train-8718", "doc": "python enum no attribute 'decode'", "code": "def unpack_out(self, name):\n        return self.parse(\"\"\"\n            $enum = $enum_class($value.value)\n            \"\"\", enum_class=self._import_type(), value=name)[\"enum\"]", "code_tokens": "def unpack_out ( self , name ) : return self . parse ( \"\"\"\n            $enum = $enum_class($value.value)\n            \"\"\" , enum_class = self . _import_type ( ) , value = name ) [ \"enum\" ]", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-8719", "doc": "check the structure of df in python", "code": "def _validate_pos(df):\n    \"\"\"Validates the returned positional object\n    \"\"\"\n    assert isinstance(df, pd.DataFrame)\n    assert [\"seqname\", \"position\", \"strand\"] == df.columns.tolist()\n    assert df.position.dtype == np.dtype(\"int64\")\n    assert df.strand.dtype == np.dtype(\"O\")\n    assert df.seqname.dtype == np.dtype(\"O\")\n    return df", "code_tokens": "def _validate_pos ( df ) : assert isinstance ( df , pd . DataFrame ) assert [ \"seqname\" , \"position\" , \"strand\" ] == df . columns . tolist ( ) assert df . position . dtype == np . dtype ( \"int64\" ) assert df . strand . dtype == np . dtype ( \"O\" ) assert df . seqname . dtype == np . dtype ( \"O\" ) return df", "docstring_tokens": "Validates the returned positional object", "label": 0}, {"idx": "cosqa-train-8720", "doc": "python equivalents for sed commands", "code": "def sed(match, replacement, path, modifiers=\"\"):\n    \"\"\"\n    Perform sed text substitution.\n    \"\"\"\n    cmd = \"sed -r -i 's/%s/%s/%s' %s\" % (match, replacement, modifiers, path)\n\n    process = Subprocess(cmd, shell=True)\n    ret, out, err = process.run(timeout=60)\n    if ret:\n        raise SubprocessError(\"Sed command failed!\")", "code_tokens": "def sed ( match , replacement , path , modifiers = \"\" ) : cmd = \"sed -r -i 's/%s/%s/%s' %s\" % ( match , replacement , modifiers , path ) process = Subprocess ( cmd , shell = True ) ret , out , err = process . run ( timeout = 60 ) if ret : raise SubprocessError ( \"Sed command failed!\" )", "docstring_tokens": "Perform sed text substitution .", "label": 0}, {"idx": "cosqa-train-8721", "doc": "check to see if a file is json python", "code": "def is_json_file(filename, show_warnings = False):\n    \"\"\"Check configuration file type is JSON\n    Return a boolean indicating wheather the file is JSON format or not\n    \"\"\"\n    try:\n        config_dict = load_config(filename, file_type = \"json\")\n        is_json = True\n    except:\n        is_json = False\n    return(is_json)", "code_tokens": "def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = \"json\" ) is_json = True except : is_json = False return ( is_json )", "docstring_tokens": "Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not", "label": 1}, {"idx": "cosqa-train-8722", "doc": "python euler to rotation matrix", "code": "def euler(self):\n        \"\"\"TODO DEPRECATE THIS?\"\"\"\n        e_xyz = transformations.euler_from_matrix(self.rotation, 'sxyz')\n        return np.array([180.0 / np.pi * a for a in e_xyz])", "code_tokens": "def euler ( self ) : e_xyz = transformations . euler_from_matrix ( self . rotation , 'sxyz' ) return np . array ( [ 180.0 / np . pi * a for a in e_xyz ] )", "docstring_tokens": "TODO DEPRECATE THIS?", "label": 0}, {"idx": "cosqa-train-8723", "doc": "check value of enum in python", "code": "def check(self, var):\n        \"\"\"Check whether the provided value is a valid enum constant.\"\"\"\n        if not isinstance(var, _str_type): return False\n        return _enum_mangle(var) in self._consts", "code_tokens": "def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts", "docstring_tokens": "Check whether the provided value is a valid enum constant .", "label": 0}, {"idx": "cosqa-train-8724", "doc": "python event loop run dont block", "code": "def run(self):\n        \"\"\"Run the event loop.\"\"\"\n        self.signal_init()\n        self.listen_init()\n        self.logger.info('starting')\n        self.loop.start()", "code_tokens": "def run ( self ) : self . signal_init ( ) self . listen_init ( ) self . logger . info ( 'starting' ) self . loop . start ( )", "docstring_tokens": "Run the event loop .", "label": 1}, {"idx": "cosqa-train-8725", "doc": "checking for punctuation in string python", "code": "def is_delimiter(line):\n    \"\"\" True if a line consists only of a single punctuation character.\"\"\"\n    return bool(line) and line[0] in punctuation and line[0]*len(line) == line", "code_tokens": "def is_delimiter ( line ) : return bool ( line ) and line [ 0 ] in punctuation and line [ 0 ] * len ( line ) == line", "docstring_tokens": "True if a line consists only of a single punctuation character .", "label": 1}, {"idx": "cosqa-train-8726", "doc": "python examples for setting locale", "code": "def set_locale(request):\n    \"\"\"Return locale from GET lang param or automatically.\"\"\"\n    return request.query.get('lang', app.ps.babel.select_locale_by_request(request))", "code_tokens": "def set_locale ( request ) : return request . query . get ( 'lang' , app . ps . babel . select_locale_by_request ( request ) )", "docstring_tokens": "Return locale from GET lang param or automatically .", "label": 1}, {"idx": "cosqa-train-8727", "doc": "checking username and passwords with dictionaries python", "code": "def check_auth(username, pwd):\n    \"\"\"This function is called to check if a username /\n    password combination is valid.\n    \"\"\"\n    cfg = get_current_config()\n    return username == cfg[\"dashboard_httpauth\"].split(\n        \":\")[0] and pwd == cfg[\"dashboard_httpauth\"].split(\":\")[1]", "code_tokens": "def check_auth ( username , pwd ) : cfg = get_current_config ( ) return username == cfg [ \"dashboard_httpauth\" ] . split ( \":\" ) [ 0 ] and pwd == cfg [ \"dashboard_httpauth\" ] . split ( \":\" ) [ 1 ]", "docstring_tokens": "This function is called to check if a username / password combination is valid .", "label": 0}, {"idx": "cosqa-train-8728", "doc": "python except file is not a zip file", "code": "def current_zipfile():\n    \"\"\"A function to vend the current zipfile, if any\"\"\"\n    if zipfile.is_zipfile(sys.argv[0]):\n        fd = open(sys.argv[0], \"rb\")\n        return zipfile.ZipFile(fd)", "code_tokens": "def current_zipfile ( ) : if zipfile . is_zipfile ( sys . argv [ 0 ] ) : fd = open ( sys . argv [ 0 ] , \"rb\" ) return zipfile . ZipFile ( fd )", "docstring_tokens": "A function to vend the current zipfile if any", "label": 0}, {"idx": "cosqa-train-8729", "doc": "chmod + w python", "code": "def chmod(f):\n    \"\"\" change mod to writeable \"\"\"\n    try:\n        os.chmod(f, S_IWRITE)  # windows (cover all)\n    except Exception as e:\n        pass\n    try:\n        os.chmod(f, 0o777)  # *nix\n    except Exception as e:\n        pass", "code_tokens": "def chmod ( f ) : try : os . chmod ( f , S_IWRITE ) # windows (cover all) except Exception as e : pass try : os . chmod ( f , 0o777 ) # *nix except Exception as e : pass", "docstring_tokens": "change mod to writeable", "label": 0}, {"idx": "cosqa-train-8730", "doc": "python exit doesn't end", "code": "def safe_exit(output):\n    \"\"\"exit without breaking pipes.\"\"\"\n    try:\n        sys.stdout.write(output)\n        sys.stdout.flush()\n    except IOError:\n        pass", "code_tokens": "def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass", "docstring_tokens": "exit without breaking pipes .", "label": 1}, {"idx": "cosqa-train-8731", "doc": "clean output folder in python", "code": "def cleanup():\n    \"\"\"Cleanup the output directory\"\"\"\n    if _output_dir and os.path.exists(_output_dir):\n        log.msg_warn(\"Cleaning up output directory at '{output_dir}' ...\"\n                     .format(output_dir=_output_dir))\n        if not _dry_run:\n            shutil.rmtree(_output_dir)", "code_tokens": "def cleanup ( ) : if _output_dir and os . path . exists ( _output_dir ) : log . msg_warn ( \"Cleaning up output directory at '{output_dir}' ...\" . format ( output_dir = _output_dir ) ) if not _dry_run : shutil . rmtree ( _output_dir )", "docstring_tokens": "Cleanup the output directory", "label": 1}, {"idx": "cosqa-train-8732", "doc": "python exit out of def", "code": "def __exit__(self, type, value, traceback):\n        \"\"\"When the `with` statement ends.\"\"\"\n\n        if not self.asarfile:\n            return\n\n        self.asarfile.close()\n        self.asarfile = None", "code_tokens": "def __exit__ ( self , type , value , traceback ) : if not self . asarfile : return self . asarfile . close ( ) self . asarfile = None", "docstring_tokens": "When the with statement ends .", "label": 1}, {"idx": "cosqa-train-8733", "doc": "clicking the next button on a page python", "code": "def accel_next(self, *args):\n        \"\"\"Callback to go to the next tab. Called by the accel key.\n        \"\"\"\n        if self.get_notebook().get_current_page() + 1 == self.get_notebook().get_n_pages():\n            self.get_notebook().set_current_page(0)\n        else:\n            self.get_notebook().next_page()\n        return True", "code_tokens": "def accel_next ( self , * args ) : if self . get_notebook ( ) . get_current_page ( ) + 1 == self . get_notebook ( ) . get_n_pages ( ) : self . get_notebook ( ) . set_current_page ( 0 ) else : self . get_notebook ( ) . next_page ( ) return True", "docstring_tokens": "Callback to go to the next tab . Called by the accel key .", "label": 1}, {"idx": "cosqa-train-8734", "doc": "python exit without traceback", "code": "def __exit__(self, type, value, traceback):\n        \"\"\"When the `with` statement ends.\"\"\"\n\n        if not self.asarfile:\n            return\n\n        self.asarfile.close()\n        self.asarfile = None", "code_tokens": "def __exit__ ( self , type , value , traceback ) : if not self . asarfile : return self . asarfile . close ( ) self . asarfile = None", "docstring_tokens": "When the with statement ends .", "label": 1}, {"idx": "cosqa-train-8735", "doc": "clipboard contents from python 3", "code": "def paste(cmd=paste_cmd, stdout=PIPE):\n    \"\"\"Returns system clipboard contents.\n    \"\"\"\n    return Popen(cmd, stdout=stdout).communicate()[0].decode('utf-8')", "code_tokens": "def paste ( cmd = paste_cmd , stdout = PIPE ) : return Popen ( cmd , stdout = stdout ) . communicate ( ) [ 0 ] . decode ( 'utf-8' )", "docstring_tokens": "Returns system clipboard contents .", "label": 0}, {"idx": "cosqa-train-8736", "doc": "python expanding scroll window", "code": "def restore_scrollbar_position(self):\n        \"\"\"Restoring scrollbar position after main window is visible\"\"\"\n        scrollbar_pos = self.get_option('scrollbar_position', None)\n        if scrollbar_pos is not None:\n            self.explorer.treewidget.set_scrollbar_position(scrollbar_pos)", "code_tokens": "def restore_scrollbar_position ( self ) : scrollbar_pos = self . get_option ( 'scrollbar_position' , None ) if scrollbar_pos is not None : self . explorer . treewidget . set_scrollbar_position ( scrollbar_pos )", "docstring_tokens": "Restoring scrollbar position after main window is visible", "label": 0}, {"idx": "cosqa-train-8737", "doc": "clipboard to variable python", "code": "def osx_clipboard_get():\n    \"\"\" Get the clipboard's text on OS X.\n    \"\"\"\n    p = subprocess.Popen(['pbpaste', '-Prefer', 'ascii'],\n        stdout=subprocess.PIPE)\n    text, stderr = p.communicate()\n    # Text comes in with old Mac \\r line endings. Change them to \\n.\n    text = text.replace('\\r', '\\n')\n    return text", "code_tokens": "def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \\r line endings. Change them to \\n. text = text . replace ( '\\r' , '\\n' ) return text", "docstring_tokens": "Get the clipboard s text on OS X .", "label": 1}, {"idx": "cosqa-train-8738", "doc": "python expection e message", "code": "def format_exception(e):\n    \"\"\"Returns a string containing the type and text of the exception.\n\n    \"\"\"\n    from .utils.printing import fill\n    return '\\n'.join(fill(line) for line in traceback.format_exception_only(type(e), e))", "code_tokens": "def format_exception ( e ) : from . utils . printing import fill return '\\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )", "docstring_tokens": "Returns a string containing the type and text of the exception .", "label": 0}, {"idx": "cosqa-train-8739", "doc": "close all figures in the python", "code": "def close_all_but_this(self):\n        \"\"\"Close all files but the current one\"\"\"\n        self.close_all_right()\n        for i in range(0, self.get_stack_count()-1  ):\n            self.close_file(0)", "code_tokens": "def close_all_but_this ( self ) : self . close_all_right ( ) for i in range ( 0 , self . get_stack_count ( ) - 1 ) : self . close_file ( 0 )", "docstring_tokens": "Close all files but the current one", "label": 1}, {"idx": "cosqa-train-8740", "doc": "python extract certain percentile of values from list", "code": "def percentile(values, k):\n    \"\"\"Find the percentile of a list of values.\n\n    :param list values: The list of values to find the percentile of\n    :param int k: The percentile to find\n    :rtype: float or int\n\n    \"\"\"\n    if not values:\n        return None\n    values.sort()\n    index = (len(values) * (float(k) / 100)) - 1\n    return values[int(math.ceil(index))]", "code_tokens": "def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]", "docstring_tokens": "Find the percentile of a list of values .", "label": 1}, {"idx": "cosqa-train-8741", "doc": "close the sql sessions in python", "code": "def unlock(self):\n    \"\"\"Closes the session to the database.\"\"\"\n    if not hasattr(self, 'session'):\n      raise RuntimeError('Error detected! The session that you want to close does not exist any more!')\n    logger.debug(\"Closed database session of '%s'\" % self._database)\n    self.session.close()\n    del self.session", "code_tokens": "def unlock ( self ) : if not hasattr ( self , 'session' ) : raise RuntimeError ( 'Error detected! The session that you want to close does not exist any more!' ) logger . debug ( \"Closed database session of '%s'\" % self . _database ) self . session . close ( ) del self . session", "docstring_tokens": "Closes the session to the database .", "label": 1}, {"idx": "cosqa-train-8742", "doc": "python fallback on not found values", "code": "def apply_to_field_if_exists(effect, field_name, fn, default):\n    \"\"\"\n    Apply function to specified field of effect if it is not None,\n    otherwise return default.\n    \"\"\"\n    value = getattr(effect, field_name, None)\n    if value is None:\n        return default\n    else:\n        return fn(value)", "code_tokens": "def apply_to_field_if_exists ( effect , field_name , fn , default ) : value = getattr ( effect , field_name , None ) if value is None : return default else : return fn ( value )", "docstring_tokens": "Apply function to specified field of effect if it is not None otherwise return default .", "label": 1}, {"idx": "cosqa-train-8743", "doc": "closest match in dictionary python", "code": "def fuzzy_get_tuple(dict_obj, approximate_key, dict_keys=None, key_and_value=False, similarity=0.6, default=None):\n    \"\"\"Find the closest matching key and/or value in a dictionary (must have all string keys!)\"\"\"\n    return fuzzy_get(dict(('|'.join(str(k2) for k2 in k), v) for (k, v) in viewitems(dict_obj)),\n                     '|'.join(str(k) for k in approximate_key), dict_keys=dict_keys,\n                     key_and_value=key_and_value, similarity=similarity, default=default)", "code_tokens": "def fuzzy_get_tuple ( dict_obj , approximate_key , dict_keys = None , key_and_value = False , similarity = 0.6 , default = None ) : return fuzzy_get ( dict ( ( '|' . join ( str ( k2 ) for k2 in k ) , v ) for ( k , v ) in viewitems ( dict_obj ) ) , '|' . join ( str ( k ) for k in approximate_key ) , dict_keys = dict_keys , key_and_value = key_and_value , similarity = similarity , default = default )", "docstring_tokens": "Find the closest matching key and / or value in a dictionary ( must have all string keys! )", "label": 1}, {"idx": "cosqa-train-8744", "doc": "python fastest way to determine nearest neighbor", "code": "def index_nearest(value, array):\n    \"\"\"\n    expects a _n.array\n    returns the global minimum of (value-array)^2\n    \"\"\"\n\n    a = (array-value)**2\n    return index(a.min(), a)", "code_tokens": "def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )", "docstring_tokens": "expects a _n . array returns the global minimum of ( value - array ) ^2", "label": 0}, {"idx": "cosqa-train-8745", "doc": "code to get the average in a list python", "code": "def calc_list_average(l):\n    \"\"\"\n    Calculates the average value of a list of numbers\n    Returns a float\n    \"\"\"\n    total = 0.0\n    for value in l:\n        total += value\n    return total / len(l)", "code_tokens": "def calc_list_average ( l ) : total = 0.0 for value in l : total += value return total / len ( l )", "docstring_tokens": "Calculates the average value of a list of numbers Returns a float", "label": 0}, {"idx": "cosqa-train-8746", "doc": "python figure out value type", "code": "def get_typecast_value(self, value, type):\n    \"\"\" Helper method to determine actual value based on type of feature variable.\n\n    Args:\n      value: Value in string form as it was parsed from datafile.\n      type: Type denoting the feature flag type.\n\n    Return:\n      Value type-casted based on type of feature variable.\n    \"\"\"\n\n    if type == entities.Variable.Type.BOOLEAN:\n      return value == 'true'\n    elif type == entities.Variable.Type.INTEGER:\n      return int(value)\n    elif type == entities.Variable.Type.DOUBLE:\n      return float(value)\n    else:\n      return value", "code_tokens": "def get_typecast_value ( self , value , type ) : if type == entities . Variable . Type . BOOLEAN : return value == 'true' elif type == entities . Variable . Type . INTEGER : return int ( value ) elif type == entities . Variable . Type . DOUBLE : return float ( value ) else : return value", "docstring_tokens": "Helper method to determine actual value based on type of feature variable .", "label": 1}, {"idx": "cosqa-train-8747", "doc": "code to perform scalar product in python", "code": "def get_scalar_product(self, other):\n        \"\"\"Returns the scalar product of this vector with the given\n        other vector.\"\"\"\n        return self.x*other.x+self.y*other.y", "code_tokens": "def get_scalar_product ( self , other ) : return self . x * other . x + self . y * other . y", "docstring_tokens": "Returns the scalar product of this vector with the given other vector .", "label": 1}, {"idx": "cosqa-train-8748", "doc": "python file desc is closed", "code": "def get_long_description():\n    \"\"\"Convert the README file into the long description.\n    \"\"\"\n    with open(path.join(root_path, 'README.md'), encoding='utf-8') as f:\n        long_description = f.read()\n    return long_description", "code_tokens": "def get_long_description ( ) : with open ( path . join ( root_path , 'README.md' ) , encoding = 'utf-8' ) as f : long_description = f . read ( ) return long_description", "docstring_tokens": "Convert the README file into the long description .", "label": 0}, {"idx": "cosqa-train-8749", "doc": "collapsing list in python to single string", "code": "def list2string (inlist,delimit=' '):\n    \"\"\"\nConverts a 1D list to a single long string for file output, using\nthe string.join function.\n\nUsage:   list2string (inlist,delimit=' ')\nReturns: the string created from inlist\n\"\"\"\n    stringlist = [makestr(_) for _ in inlist]\n    return string.join(stringlist,delimit)", "code_tokens": "def list2string ( inlist , delimit = ' ' ) : stringlist = [ makestr ( _ ) for _ in inlist ] return string . join ( stringlist , delimit )", "docstring_tokens": "Converts a 1D list to a single long string for file output using the string . join function .", "label": 1}, {"idx": "cosqa-train-8750", "doc": "python file encoding judge", "code": "def get_best_encoding(stream):\n    \"\"\"Returns the default stream encoding if not found.\"\"\"\n    rv = getattr(stream, 'encoding', None) or sys.getdefaultencoding()\n    if is_ascii_encoding(rv):\n        return 'utf-8'\n    return rv", "code_tokens": "def get_best_encoding ( stream ) : rv = getattr ( stream , 'encoding' , None ) or sys . getdefaultencoding ( ) if is_ascii_encoding ( rv ) : return 'utf-8' return rv", "docstring_tokens": "Returns the default stream encoding if not found .", "label": 1}, {"idx": "cosqa-train-8751", "doc": "compare a float to the third decimal place python", "code": "def _float_almost_equal(float1, float2, places=7):\n    \"\"\"Return True if two numbers are equal up to the\n    specified number of \"places\" after the decimal point.\n    \"\"\"\n\n    if round(abs(float2 - float1), places) == 0:\n        return True\n\n    return False", "code_tokens": "def _float_almost_equal ( float1 , float2 , places = 7 ) : if round ( abs ( float2 - float1 ) , places ) == 0 : return True return False", "docstring_tokens": "Return True if two numbers are equal up to the specified number of places after the decimal point .", "label": 1}, {"idx": "cosqa-train-8752", "doc": "python file open encoding is an invalid keyword", "code": "def open_with_encoding(filename, encoding, mode='r'):\n    \"\"\"Return opened file with a specific encoding.\"\"\"\n    return io.open(filename, mode=mode, encoding=encoding,\n                   newline='')", "code_tokens": "def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )", "docstring_tokens": "Return opened file with a specific encoding .", "label": 1}, {"idx": "cosqa-train-8753", "doc": "compare str with int in python", "code": "def is_int(string):\n    \"\"\"\n    Checks if a string is an integer. If the string value is an integer\n    return True, otherwise return False. \n    \n    Args:\n        string: a string to test.\n\n    Returns: \n        boolean\n    \"\"\"\n    try:\n        a = float(string)\n        b = int(a)\n    except ValueError:\n        return False\n    else:\n        return a == b", "code_tokens": "def is_int ( string ) : try : a = float ( string ) b = int ( a ) except ValueError : return False else : return a == b", "docstring_tokens": "Checks if a string is an integer . If the string value is an integer return True otherwise return False . Args : string : a string to test .", "label": 1}, {"idx": "cosqa-train-8754", "doc": "python file that excepts command line inputs", "code": "def main(argv=None):\n    \"\"\"Main command line interface.\"\"\"\n\n    if argv is None:\n        argv = sys.argv[1:]\n\n    cli = CommandLineTool()\n    return cli.run(argv)", "code_tokens": "def main ( argv = None ) : if argv is None : argv = sys . argv [ 1 : ] cli = CommandLineTool ( ) return cli . run ( argv )", "docstring_tokens": "Main command line interface .", "label": 0}, {"idx": "cosqa-train-8755", "doc": "comparing 2 strings python", "code": "def compare(string1, string2):\n    \"\"\"Compare two strings while protecting against timing attacks\n\n    :param str string1: the first string\n    :param str string2: the second string\n\n    :returns: True if the strings are equal, False if not\n    :rtype: :obj:`bool`\n    \"\"\"\n    if len(string1) != len(string2):\n        return False\n    result = True\n    for c1, c2 in izip(string1, string2):\n        result &= c1 == c2\n    return result", "code_tokens": "def compare ( string1 , string2 ) : if len ( string1 ) != len ( string2 ) : return False result = True for c1 , c2 in izip ( string1 , string2 ) : result &= c1 == c2 return result", "docstring_tokens": "Compare two strings while protecting against timing attacks", "label": 1}, {"idx": "cosqa-train-8756", "doc": "python fillna of specific column", "code": "def _maybe_fill(arr, fill_value=np.nan):\n    \"\"\"\n    if we have a compatible fill_value and arr dtype, then fill\n    \"\"\"\n    if _isna_compat(arr, fill_value):\n        arr.fill(fill_value)\n    return arr", "code_tokens": "def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr", "docstring_tokens": "if we have a compatible fill_value and arr dtype then fill", "label": 1}, {"idx": "cosqa-train-8757", "doc": "comparing contents of one python dictionary to another", "code": "def intersect(d1, d2):\n    \"\"\"Intersect dictionaries d1 and d2 by key *and* value.\"\"\"\n    return dict((k, d1[k]) for k in d1 if k in d2 and d1[k] == d2[k])", "code_tokens": "def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )", "docstring_tokens": "Intersect dictionaries d1 and d2 by key * and * value .", "label": 1}, {"idx": "cosqa-train-8758", "doc": "python filter object at", "code": "def __init__(self, function):\n\t\t\"\"\"function: to be called with each stream element as its\n\t\tonly argument\n\t\t\"\"\"\n\t\tsuper(filter, self).__init__()\n\t\tself.function = function", "code_tokens": "def __init__ ( self , function ) : super ( filter , self ) . __init__ ( ) self . function = function", "docstring_tokens": "function : to be called with each stream element as its only argument", "label": 1}, {"idx": "cosqa-train-8759", "doc": "compile python source too long", "code": "def make_code_from_py(filename):\n    \"\"\"Get source from `filename` and make a code object of it.\"\"\"\n    # Open the source file.\n    try:\n        source_file = open_source(filename)\n    except IOError:\n        raise NoSource(\"No file to run: %r\" % filename)\n\n    try:\n        source = source_file.read()\n    finally:\n        source_file.close()\n\n    # We have the source.  `compile` still needs the last line to be clean,\n    # so make sure it is, then compile a code object from it.\n    if not source or source[-1] != '\\n':\n        source += '\\n'\n    code = compile(source, filename, \"exec\")\n\n    return code", "code_tokens": "def make_code_from_py ( filename ) : # Open the source file. try : source_file = open_source ( filename ) except IOError : raise NoSource ( \"No file to run: %r\" % filename ) try : source = source_file . read ( ) finally : source_file . close ( ) # We have the source.  `compile` still needs the last line to be clean, # so make sure it is, then compile a code object from it. if not source or source [ - 1 ] != '\\n' : source += '\\n' code = compile ( source , filename , \"exec\" ) return code", "docstring_tokens": "Get source from filename and make a code object of it .", "label": 0}, {"idx": "cosqa-train-8760", "doc": "python filter object is empty", "code": "def __init__(self):\n    \"\"\"Initializes a filter object.\"\"\"\n    super(FilterObject, self).__init__()\n    self._filter_expression = None\n    self._matcher = None", "code_tokens": "def __init__ ( self ) : super ( FilterObject , self ) . __init__ ( ) self . _filter_expression = None self . _matcher = None", "docstring_tokens": "Initializes a filter object .", "label": 1}, {"idx": "cosqa-train-8761", "doc": "compute the distance between each pair of points in python numpy", "code": "def dist(x1, x2, axis=0):\n    \"\"\"Return the distance between two points.\n\n    Set axis=1 if x1 is a vector and x2 a matrix to get a vector of distances.\n    \"\"\"\n    return np.linalg.norm(x2 - x1, axis=axis)", "code_tokens": "def dist ( x1 , x2 , axis = 0 ) : return np . linalg . norm ( x2 - x1 , axis = axis )", "docstring_tokens": "Return the distance between two points .", "label": 1}, {"idx": "cosqa-train-8762", "doc": "python filter object subscript", "code": "def __init__(self, function):\n\t\t\"\"\"function: to be called with each stream element as its\n\t\tonly argument\n\t\t\"\"\"\n\t\tsuper(filter, self).__init__()\n\t\tself.function = function", "code_tokens": "def __init__ ( self , function ) : super ( filter , self ) . __init__ ( ) self . function = function", "docstring_tokens": "function : to be called with each stream element as its only argument", "label": 1}, {"idx": "cosqa-train-8763", "doc": "compute the euclidean distance between a and b python", "code": "def euclidean(c1, c2):\n    \"\"\"Square of the euclidean distance\"\"\"\n    diffs = ((i - j) for i, j in zip(c1, c2))\n    return sum(x * x for x in diffs)", "code_tokens": "def euclidean ( c1 , c2 ) : diffs = ( ( i - j ) for i , j in zip ( c1 , c2 ) ) return sum ( x * x for x in diffs )", "docstring_tokens": "Square of the euclidean distance", "label": 0}, {"idx": "cosqa-train-8764", "doc": "python finding index of element in a list", "code": "def binSearch(arr, val):\n  \"\"\" \n  Function for running binary search on a sorted list.\n\n  :param arr: (list) a sorted list of integers to search\n  :param val: (int)  a integer to search for in the sorted array\n  :returns: (int) the index of the element if it is found and -1 otherwise.\n  \"\"\"\n  i = bisect_left(arr, val)\n  if i != len(arr) and arr[i] == val:\n    return i\n  return -1", "code_tokens": "def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1", "docstring_tokens": "Function for running binary search on a sorted list .", "label": 0}, {"idx": "cosqa-train-8765", "doc": "computing tpr and fpr in python", "code": "def tpr(y, z):\n    \"\"\"True positive rate `tp / (tp + fn)`\n    \"\"\"\n    tp, tn, fp, fn = contingency_table(y, z)\n    return tp / (tp + fn)", "code_tokens": "def tpr ( y , z ) : tp , tn , fp , fn = contingency_table ( y , z ) return tp / ( tp + fn )", "docstring_tokens": "True positive rate tp / ( tp + fn )", "label": 1}, {"idx": "cosqa-train-8766", "doc": "python first line from file", "code": "def getfirstline(file, default):\n    \"\"\"\n    Returns the first line of a file.\n    \"\"\"\n    with open(file, 'rb') as fh:\n        content = fh.readlines()\n        if len(content) == 1:\n            return content[0].decode('utf-8').strip('\\n')\n\n    return default", "code_tokens": "def getfirstline ( file , default ) : with open ( file , 'rb' ) as fh : content = fh . readlines ( ) if len ( content ) == 1 : return content [ 0 ] . decode ( 'utf-8' ) . strip ( '\\n' ) return default", "docstring_tokens": "Returns the first line of a file .", "label": 1}, {"idx": "cosqa-train-8767", "doc": "concatenate columns in python using sql", "code": "def join_cols(cols):\n    \"\"\"Join list of columns into a string for a SQL query\"\"\"\n    return \", \".join([i for i in cols]) if isinstance(cols, (list, tuple, set)) else cols", "code_tokens": "def join_cols ( cols ) : return \", \" . join ( [ i for i in cols ] ) if isinstance ( cols , ( list , tuple , set ) ) else cols", "docstring_tokens": "Join list of columns into a string for a SQL query", "label": 0}, {"idx": "cosqa-train-8768", "doc": "python fit three coefficients", "code": "def apply_fit(xy,coeffs):\n    \"\"\" Apply the coefficients from a linear fit to\n        an array of x,y positions.\n\n        The coeffs come from the 'coeffs' member of the\n        'fit_arrays()' output.\n    \"\"\"\n    x_new = coeffs[0][2] + coeffs[0][0]*xy[:,0] + coeffs[0][1]*xy[:,1]\n    y_new = coeffs[1][2] + coeffs[1][0]*xy[:,0] + coeffs[1][1]*xy[:,1]\n\n    return x_new,y_new", "code_tokens": "def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "docstring_tokens": "Apply the coefficients from a linear fit to an array of x y positions .", "label": 1}, {"idx": "cosqa-train-8769", "doc": "concatinate multiple values to a string in python", "code": "def vectorize(values):\n    \"\"\"\n    Takes a value or list of values and returns a single result, joined by \",\"\n    if necessary.\n    \"\"\"\n    if isinstance(values, list):\n        return ','.join(str(v) for v in values)\n    return values", "code_tokens": "def vectorize ( values ) : if isinstance ( values , list ) : return ',' . join ( str ( v ) for v in values ) return values", "docstring_tokens": "Takes a value or list of values and returns a single result joined by if necessary .", "label": 0}, {"idx": "cosqa-train-8770", "doc": "python fixed aspect ratio plot", "code": "def figsize(x=8, y=7., aspect=1.):\n    \"\"\" manually set the default figure size of plots\n    ::Arguments::\n        x (float): x-axis size\n        y (float): y-axis size\n        aspect (float): aspect ratio scalar\n    \"\"\"\n    # update rcparams with adjusted figsize params\n    mpl.rcParams.update({'figure.figsize': (x*aspect, y)})", "code_tokens": "def figsize ( x = 8 , y = 7. , aspect = 1. ) : # update rcparams with adjusted figsize params mpl . rcParams . update ( { 'figure.figsize' : ( x * aspect , y ) } )", "docstring_tokens": "manually set the default figure size of plots :: Arguments :: x ( float ) : x - axis size y ( float ) : y - axis size aspect ( float ) : aspect ratio scalar", "label": 1}, {"idx": "cosqa-train-8771", "doc": "concatinate string and datetime python", "code": "def convert_time_string(date_str):\n    \"\"\" Change a date string from the format 2018-08-15T23:55:17 into a datetime object \"\"\"\n    dt, _, _ = date_str.partition(\".\")\n    dt = datetime.strptime(dt, \"%Y-%m-%dT%H:%M:%S\")\n    return dt", "code_tokens": "def convert_time_string ( date_str ) : dt , _ , _ = date_str . partition ( \".\" ) dt = datetime . strptime ( dt , \"%Y-%m-%dT%H:%M:%S\" ) return dt", "docstring_tokens": "Change a date string from the format 2018 - 08 - 15T23 : 55 : 17 into a datetime object", "label": 1}, {"idx": "cosqa-train-8772", "doc": "python fixed width parse", "code": "def parse_fixed_width(types, lines):\n    \"\"\"Parse a fixed width line.\"\"\"\n    values = []\n    line = []\n    for width, parser in types:\n        if not line:\n            line = lines.pop(0).replace('\\n', '')\n\n        values.append(parser(line[:width]))\n        line = line[width:]\n\n    return values", "code_tokens": "def parse_fixed_width ( types , lines ) : values = [ ] line = [ ] for width , parser in types : if not line : line = lines . pop ( 0 ) . replace ( '\\n' , '' ) values . append ( parser ( line [ : width ] ) ) line = line [ width : ] return values", "docstring_tokens": "Parse a fixed width line .", "label": 0}, {"idx": "cosqa-train-8773", "doc": "confidence interval of means in python using bootstrapping", "code": "def mean_cl_boot(series, n_samples=1000, confidence_interval=0.95,\n                 random_state=None):\n    \"\"\"\n    Bootstrapped mean with confidence limits\n    \"\"\"\n    return bootstrap_statistics(series, np.mean,\n                                n_samples=n_samples,\n                                confidence_interval=confidence_interval,\n                                random_state=random_state)", "code_tokens": "def mean_cl_boot ( series , n_samples = 1000 , confidence_interval = 0.95 , random_state = None ) : return bootstrap_statistics ( series , np . mean , n_samples = n_samples , confidence_interval = confidence_interval , random_state = random_state )", "docstring_tokens": "Bootstrapped mean with confidence limits", "label": 1}, {"idx": "cosqa-train-8774", "doc": "python flask api post 400", "code": "def handle_request_parsing_error(err, req, schema, error_status_code, error_headers):\n    \"\"\"webargs error handler that uses Flask-RESTful's abort function to return\n    a JSON error response to the client.\n    \"\"\"\n    abort(error_status_code, errors=err.messages)", "code_tokens": "def handle_request_parsing_error ( err , req , schema , error_status_code , error_headers ) : abort ( error_status_code , errors = err . messages )", "docstring_tokens": "webargs error handler that uses Flask - RESTful s abort function to return a JSON error response to the client .", "label": 1}, {"idx": "cosqa-train-8775", "doc": "consuming rest api service python 3", "code": "def list_apis(awsclient):\n    \"\"\"List APIs in account.\"\"\"\n    client_api = awsclient.get_client('apigateway')\n\n    apis = client_api.get_rest_apis()['items']\n\n    for api in apis:\n        print(json2table(api))", "code_tokens": "def list_apis ( awsclient ) : client_api = awsclient . get_client ( 'apigateway' ) apis = client_api . get_rest_apis ( ) [ 'items' ] for api in apis : print ( json2table ( api ) )", "docstring_tokens": "List APIs in account .", "label": 1}, {"idx": "cosqa-train-8776", "doc": "python flask call internal route", "code": "def handleFlaskPostRequest(flaskRequest, endpoint):\n    \"\"\"\n    Handles the specified flask request for one of the POST URLS\n    Invokes the specified endpoint to generate a response.\n    \"\"\"\n    if flaskRequest.method == \"POST\":\n        return handleHttpPost(flaskRequest, endpoint)\n    elif flaskRequest.method == \"OPTIONS\":\n        return handleHttpOptions()\n    else:\n        raise exceptions.MethodNotAllowedException()", "code_tokens": "def handleFlaskPostRequest ( flaskRequest , endpoint ) : if flaskRequest . method == \"POST\" : return handleHttpPost ( flaskRequest , endpoint ) elif flaskRequest . method == \"OPTIONS\" : return handleHttpOptions ( ) else : raise exceptions . MethodNotAllowedException ( )", "docstring_tokens": "Handles the specified flask request for one of the POST URLS Invokes the specified endpoint to generate a response .", "label": 1}, {"idx": "cosqa-train-8777", "doc": "continue command in next line in python", "code": "def do_next(self, args):\n        \"\"\"Step over the next statement\n        \"\"\"\n        self._do_print_from_last_cmd = True\n        self._interp.step_over()\n        return True", "code_tokens": "def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "docstring_tokens": "Step over the next statement", "label": 0}, {"idx": "cosqa-train-8778", "doc": "python flask checkbox onclick", "code": "def checkbox_uncheck(self, force_check=False):\n        \"\"\"\n        Wrapper to uncheck a checkbox\n        \"\"\"\n        if self.get_attribute('checked'):\n            self.click(force_click=force_check)", "code_tokens": "def checkbox_uncheck ( self , force_check = False ) : if self . get_attribute ( 'checked' ) : self . click ( force_click = force_check )", "docstring_tokens": "Wrapper to uncheck a checkbox", "label": 1}, {"idx": "cosqa-train-8779", "doc": "convention python function names", "code": "def export(defn):\n    \"\"\"Decorator to explicitly mark functions that are exposed in a lib.\"\"\"\n    globals()[defn.__name__] = defn\n    __all__.append(defn.__name__)\n    return defn", "code_tokens": "def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "docstring_tokens": "Decorator to explicitly mark functions that are exposed in a lib .", "label": 1}, {"idx": "cosqa-train-8780", "doc": "python flask generate link to external file", "code": "def static_url(path, absolute=False):\n    \"\"\" Shorthand for returning a URL for the requested static file.\n\n    Arguments:\n\n    path -- the path to the file (relative to the static files directory)\n    absolute -- whether the link should be absolute or relative\n    \"\"\"\n\n    if os.sep != '/':\n        path = '/'.join(path.split(os.sep))\n\n    return flask.url_for('static', filename=path, _external=absolute)", "code_tokens": "def static_url ( path , absolute = False ) : if os . sep != '/' : path = '/' . join ( path . split ( os . sep ) ) return flask . url_for ( 'static' , filename = path , _external = absolute )", "docstring_tokens": "Shorthand for returning a URL for the requested static file .", "label": 1}, {"idx": "cosqa-train-8781", "doc": "converter string to json python", "code": "def json(body, charset='utf-8', **kwargs):\n    \"\"\"Takes JSON formatted data, converting it into native Python objects\"\"\"\n    return json_converter.loads(text(body, charset=charset))", "code_tokens": "def json ( body , charset = 'utf-8' , * * kwargs ) : return json_converter . loads ( text ( body , charset = charset ) )", "docstring_tokens": "Takes JSON formatted data converting it into native Python objects", "label": 1}, {"idx": "cosqa-train-8782", "doc": "converts matrix to pictures by python", "code": "def im2mat(I):\n    \"\"\"Converts and image to matrix (one pixel per line)\"\"\"\n    return I.reshape((I.shape[0] * I.shape[1], I.shape[2]))", "code_tokens": "def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )", "docstring_tokens": "Converts and image to matrix ( one pixel per line )", "label": 1}, {"idx": "cosqa-train-8783", "doc": "python flask items in a table", "code": "def index():\n    \"\"\" Display productpage with normal user and test user buttons\"\"\"\n    global productpage\n\n    table = json2html.convert(json = json.dumps(productpage),\n                              table_attributes=\"class=\\\"table table-condensed table-bordered table-hover\\\"\")\n\n    return render_template('index.html', serviceTable=table)", "code_tokens": "def index ( ) : global productpage table = json2html . convert ( json = json . dumps ( productpage ) , table_attributes = \"class=\\\"table table-condensed table-bordered table-hover\\\"\" ) return render_template ( 'index.html' , serviceTable = table )", "docstring_tokens": "Display productpage with normal user and test user buttons", "label": 1}, {"idx": "cosqa-train-8784", "doc": "convolution without using numpy python", "code": "def conv1x1(in_planes, out_planes, stride=1):\n    \"\"\"1x1 convolution\"\"\"\n    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)", "code_tokens": "def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )", "docstring_tokens": "1x1 convolution", "label": 0}, {"idx": "cosqa-train-8785", "doc": "python flask jsonify example", "code": "def jsonify(resource):\n    \"\"\"Return a Flask ``Response`` object containing a\n    JSON representation of *resource*.\n\n    :param resource: The resource to act as the basis of the response\n    \"\"\"\n\n    response = flask.jsonify(resource.to_dict())\n    response = add_link_headers(response, resource.links())\n    return response", "code_tokens": "def jsonify ( resource ) : response = flask . jsonify ( resource . to_dict ( ) ) response = add_link_headers ( response , resource . links ( ) ) return response", "docstring_tokens": "Return a Flask Response object containing a JSON representation of * resource * .", "label": 1}, {"idx": "cosqa-train-8786", "doc": "copy manipulate and paste text python pyperclip", "code": "def copy(string, **kwargs):\n    \"\"\"Copy given string into system clipboard.\"\"\"\n    window = Tk()\n    window.withdraw()\n    window.clipboard_clear()\n    window.clipboard_append(string)\n    window.destroy()\n    return", "code_tokens": "def copy ( string , * * kwargs ) : window = Tk ( ) window . withdraw ( ) window . clipboard_clear ( ) window . clipboard_append ( string ) window . destroy ( ) return", "docstring_tokens": "Copy given string into system clipboard .", "label": 1}, {"idx": "cosqa-train-8787", "doc": "python flask modify request header", "code": "def set_header(self, name, value):\n        \"\"\" Create a new response header, replacing any previously defined\n            headers with the same name. \"\"\"\n        self._headers[_hkey(name)] = [_hval(value)]", "code_tokens": "def set_header ( self , name , value ) : self . _headers [ _hkey ( name ) ] = [ _hval ( value ) ]", "docstring_tokens": "Create a new response header replacing any previously defined headers with the same name .", "label": 1}, {"idx": "cosqa-train-8788", "doc": "correlation coefficient matrix in python", "code": "def sample_correlations(self):\n        \"\"\"Returns an `ExpMatrix` containing all pairwise sample correlations.\n\n        Returns\n        -------\n        `ExpMatrix`\n            The sample correlation matrix.\n\n        \"\"\"\n        C = np.corrcoef(self.X.T)\n        corr_matrix = ExpMatrix(genes=self.samples, samples=self.samples, X=C)\n        return corr_matrix", "code_tokens": "def sample_correlations ( self ) : C = np . corrcoef ( self . X . T ) corr_matrix = ExpMatrix ( genes = self . samples , samples = self . samples , X = C ) return corr_matrix", "docstring_tokens": "Returns an ExpMatrix containing all pairwise sample correlations .", "label": 1}, {"idx": "cosqa-train-8789", "doc": "python flask ngnix close connection", "code": "def end(self):\n        \"\"\"End of the Glances server session.\"\"\"\n        if not self.args.disable_autodiscover:\n            self.autodiscover_client.close()\n        self.server.end()", "code_tokens": "def end ( self ) : if not self . args . disable_autodiscover : self . autodiscover_client . close ( ) self . server . end ( )", "docstring_tokens": "End of the Glances server session .", "label": 1}, {"idx": "cosqa-train-8790", "doc": "correlation heat map for different features in python", "code": "def scatterplot_matrix(df, features, downsample_frac=None, figsize=(15, 15)):\n    \"\"\"\n    Plot a scatterplot matrix for a list of features, colored by target value.\n\n    Example: `scatterplot_matrix(X, X.columns.tolist(), downsample_frac=0.01)`\n\n    Args:\n        df: Pandas dataframe containing the target column (named 'target').\n        features: The list of features to include in the correlation plot.\n        downsample_frac: Dataframe downsampling rate (0.1 to include 10% of the dataset).\n        figsize: The size of the plot.\n    \"\"\"\n\n    if downsample_frac:\n        df = df.sample(frac=downsample_frac)\n\n    plt.figure(figsize=figsize)\n    sns.pairplot(df[features], hue='target')\n    plt.show()", "code_tokens": "def scatterplot_matrix ( df , features , downsample_frac = None , figsize = ( 15 , 15 ) ) : if downsample_frac : df = df . sample ( frac = downsample_frac ) plt . figure ( figsize = figsize ) sns . pairplot ( df [ features ] , hue = 'target' ) plt . show ( )", "docstring_tokens": "Plot a scatterplot matrix for a list of features colored by target value .", "label": 1}, {"idx": "cosqa-train-8791", "doc": "python flask return message 500", "code": "def handle_exception(error):\n        \"\"\"Simple method for handling exceptions raised by `PyBankID`.\n\n        :param flask_pybankid.FlaskPyBankIDError error: The exception to handle.\n        :return: The exception represented as a dictionary.\n        :rtype: dict\n\n        \"\"\"\n        response = jsonify(error.to_dict())\n        response.status_code = error.status_code\n        return response", "code_tokens": "def handle_exception ( error ) : response = jsonify ( error . to_dict ( ) ) response . status_code = error . status_code return response", "docstring_tokens": "Simple method for handling exceptions raised by PyBankID .", "label": 1}, {"idx": "cosqa-train-8792", "doc": "count non na python numpy axis", "code": "def count(data, axis=None):\n    \"\"\"Count the number of non-NA in this array along the given axis or axes\n    \"\"\"\n    return np.sum(np.logical_not(isnull(data)), axis=axis)", "code_tokens": "def count ( data , axis = None ) : return np . sum ( np . logical_not ( isnull ( data ) ) , axis = axis )", "docstring_tokens": "Count the number of non - NA in this array along the given axis or axes", "label": 1}, {"idx": "cosqa-train-8793", "doc": "python flask session cookie", "code": "def dispatch(self):\n    \"\"\"Wraps the dispatch method to add session support.\"\"\"\n    try:\n      webapp2.RequestHandler.dispatch(self)\n    finally:\n      self.session_store.save_sessions(self.response)", "code_tokens": "def dispatch ( self ) : try : webapp2 . RequestHandler . dispatch ( self ) finally : self . session_store . save_sessions ( self . response )", "docstring_tokens": "Wraps the dispatch method to add session support .", "label": 0}, {"idx": "cosqa-train-8794", "doc": "count null value in python from a dataset", "code": "def count(data, axis=None):\n    \"\"\"Count the number of non-NA in this array along the given axis or axes\n    \"\"\"\n    return np.sum(np.logical_not(isnull(data)), axis=axis)", "code_tokens": "def count ( data , axis = None ) : return np . sum ( np . logical_not ( isnull ( data ) ) , axis = axis )", "docstring_tokens": "Count the number of non - NA in this array along the given axis or axes", "label": 0}, {"idx": "cosqa-train-8795", "doc": "python flask set static folder", "code": "def staticdir():\n    \"\"\"Return the location of the static data directory.\"\"\"\n    root = os.path.abspath(os.path.dirname(__file__))\n    return os.path.join(root, \"static\")", "code_tokens": "def staticdir ( ) : root = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( root , \"static\" )", "docstring_tokens": "Return the location of the static data directory .", "label": 1}, {"idx": "cosqa-train-8796", "doc": "coverage analysis python unittest", "code": "def cover(session):\n    \"\"\"Run the final coverage report.\n    This outputs the coverage report aggregating coverage from the unit\n    test runs (not system test runs), and then erases coverage data.\n    \"\"\"\n    session.interpreter = 'python3.6'\n    session.install('coverage', 'pytest-cov')\n    session.run('coverage', 'report', '--show-missing', '--fail-under=100')\n    session.run('coverage', 'erase')", "code_tokens": "def cover ( session ) : session . interpreter = 'python3.6' session . install ( 'coverage' , 'pytest-cov' ) session . run ( 'coverage' , 'report' , '--show-missing' , '--fail-under=100' ) session . run ( 'coverage' , 'erase' )", "docstring_tokens": "Run the final coverage report . This outputs the coverage report aggregating coverage from the unit test runs ( not system test runs ) and then erases coverage data .", "label": 1}, {"idx": "cosqa-train-8797", "doc": "python flask static folder location", "code": "def staticdir():\n    \"\"\"Return the location of the static data directory.\"\"\"\n    root = os.path.abspath(os.path.dirname(__file__))\n    return os.path.join(root, \"static\")", "code_tokens": "def staticdir ( ) : root = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( root , \"static\" )", "docstring_tokens": "Return the location of the static data directory .", "label": 0}, {"idx": "cosqa-train-8798", "doc": "creat random array python gaussian", "code": "def rnormal(mu, tau, size=None):\n    \"\"\"\n    Random normal variates.\n    \"\"\"\n    return np.random.normal(mu, 1. / np.sqrt(tau), size)", "code_tokens": "def rnormal ( mu , tau , size = None ) : return np . random . normal ( mu , 1. / np . sqrt ( tau ) , size )", "docstring_tokens": "Random normal variates .", "label": 0}, {"idx": "cosqa-train-8799", "doc": "python flatten nested tuple", "code": "def flatten(nested, containers=(list, tuple)):\n    \"\"\" Flatten a nested list by yielding its scalar items.\n    \"\"\"\n    for item in nested:\n        if hasattr(item, \"next\") or isinstance(item, containers):\n            for subitem in flatten(item):\n                yield subitem\n        else:\n            yield item", "code_tokens": "def flatten ( nested , containers = ( list , tuple ) ) : for item in nested : if hasattr ( item , \"next\" ) or isinstance ( item , containers ) : for subitem in flatten ( item ) : yield subitem else : yield item", "docstring_tokens": "Flatten a nested list by yielding its scalar items .", "label": 1}, {"idx": "cosqa-train-8800", "doc": "create a bool matrix python", "code": "def is_bool_matrix(l):\n    r\"\"\"Checks if l is a 2D numpy array of bools\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 2 and (l.dtype == bool):\n            return True\n    return False", "code_tokens": "def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False", "docstring_tokens": "r Checks if l is a 2D numpy array of bools", "label": 1}, {"idx": "cosqa-train-8801", "doc": "python folder location mac", "code": "def get_mac_dot_app_dir(directory):\n    \"\"\"Returns parent directory of mac .app\n\n    Args:\n\n       directory (str): Current directory\n\n    Returns:\n\n       (str): Parent directory of mac .app\n    \"\"\"\n    return os.path.dirname(os.path.dirname(os.path.dirname(directory)))", "code_tokens": "def get_mac_dot_app_dir ( directory ) : return os . path . dirname ( os . path . dirname ( os . path . dirname ( directory ) ) )", "docstring_tokens": "Returns parent directory of mac . app", "label": 0}, {"idx": "cosqa-train-8802", "doc": "create a fix size list in python", "code": "def _crop_list_to_size(l, size):\n    \"\"\"Make a list a certain size\"\"\"\n    for x in range(size - len(l)):\n        l.append(False)\n    for x in range(len(l) - size):\n        l.pop()\n    return l", "code_tokens": "def _crop_list_to_size ( l , size ) : for x in range ( size - len ( l ) ) : l . append ( False ) for x in range ( len ( l ) - size ) : l . pop ( ) return l", "docstring_tokens": "Make a list a certain size", "label": 1}, {"idx": "cosqa-train-8803", "doc": "python for window to popup before main window closes", "code": "def closing_plugin(self, cancelable=False):\n        \"\"\"Perform actions before parent main window is closed\"\"\"\n        self.dialog_manager.close_all()\n        self.shell.exit_interpreter()\n        return True", "code_tokens": "def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True", "docstring_tokens": "Perform actions before parent main window is closed", "label": 1}, {"idx": "cosqa-train-8804", "doc": "create a float variable in python and display after rounding in 2 decimal", "code": "def _saferound(value, decimal_places):\n    \"\"\"\n    Rounds a float value off to the desired precision\n    \"\"\"\n    try:\n        f = float(value)\n    except ValueError:\n        return ''\n    format = '%%.%df' % decimal_places\n    return format % f", "code_tokens": "def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f", "docstring_tokens": "Rounds a float value off to the desired precision", "label": 1}, {"idx": "cosqa-train-8805", "doc": "python force close h5 file", "code": "def _closeResources(self):\n        \"\"\" Closes the root Dataset.\n        \"\"\"\n        logger.info(\"Closing: {}\".format(self._fileName))\n        self._h5Group.close()\n        self._h5Group = None", "code_tokens": "def _closeResources ( self ) : logger . info ( \"Closing: {}\" . format ( self . _fileName ) ) self . _h5Group . close ( ) self . _h5Group = None", "docstring_tokens": "Closes the root Dataset .", "label": 1}, {"idx": "cosqa-train-8806", "doc": "create a function to realise the fibanacci number python", "code": "def software_fibonacci(n):\n    \"\"\" a normal old python function to return the Nth fibonacci number. \"\"\"\n    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    return a", "code_tokens": "def software_fibonacci ( n ) : a , b = 0 , 1 for i in range ( n ) : a , b = b , a + b return a", "docstring_tokens": "a normal old python function to return the Nth fibonacci number .", "label": 1}, {"idx": "cosqa-train-8807", "doc": "python force print to flush immediately", "code": "def flush(self):\n        \"\"\" Force commit changes to the file and stdout \"\"\"\n        if not self.nostdout:\n            self.stdout.flush()\n        if self.file is not None:\n            self.file.flush()", "code_tokens": "def flush ( self ) : if not self . nostdout : self . stdout . flush ( ) if self . file is not None : self . file . flush ( )", "docstring_tokens": "Force commit changes to the file and stdout", "label": 0}, {"idx": "cosqa-train-8808", "doc": "create a new column with empty strings in python", "code": "def stringify_col(df, col_name):\n    \"\"\"\n    Take a dataframe and string-i-fy a column of values.\n    Turn nan/None into \"\" and all other values into strings.\n\n    Parameters\n    ----------\n    df : dataframe\n    col_name : string\n    \"\"\"\n    df = df.copy()\n    df[col_name] = df[col_name].fillna(\"\")\n    df[col_name] = df[col_name].astype(str)\n    return df", "code_tokens": "def stringify_col ( df , col_name ) : df = df . copy ( ) df [ col_name ] = df [ col_name ] . fillna ( \"\" ) df [ col_name ] = df [ col_name ] . astype ( str ) return df", "docstring_tokens": "Take a dataframe and string - i - fy a column of values . Turn nan / None into and all other values into strings .", "label": 0}, {"idx": "cosqa-train-8809", "doc": "python fork check alive", "code": "def go_to_background():\n    \"\"\" Daemonize the running process. \"\"\"\n    try:\n        if os.fork():\n            sys.exit()\n    except OSError as errmsg:\n        LOGGER.error('Fork failed: {0}'.format(errmsg))\n        sys.exit('Fork failed')", "code_tokens": "def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "docstring_tokens": "Daemonize the running process .", "label": 0}, {"idx": "cosqa-train-8810", "doc": "create a temporaly qcoreapplication python", "code": "def create_app():\n    \"\"\"Create a Qt application.\"\"\"\n    global QT_APP\n    QT_APP = QApplication.instance()\n    if QT_APP is None:  # pragma: no cover\n        QT_APP = QApplication(sys.argv)\n    return QT_APP", "code_tokens": "def create_app ( ) : global QT_APP QT_APP = QApplication . instance ( ) if QT_APP is None : # pragma: no cover QT_APP = QApplication ( sys . argv ) return QT_APP", "docstring_tokens": "Create a Qt application .", "label": 1}, {"idx": "cosqa-train-8811", "doc": "python fork process crash", "code": "def go_to_background():\n    \"\"\" Daemonize the running process. \"\"\"\n    try:\n        if os.fork():\n            sys.exit()\n    except OSError as errmsg:\n        LOGGER.error('Fork failed: {0}'.format(errmsg))\n        sys.exit('Fork failed')", "code_tokens": "def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "docstring_tokens": "Daemonize the running process .", "label": 0}, {"idx": "cosqa-train-8812", "doc": "create an array from a list in python without numpy", "code": "def pack_triples_numpy(triples):\n    \"\"\"Packs a list of triple indexes into a 2D numpy array.\"\"\"\n    if len(triples) == 0:\n        return np.array([], dtype=np.int64)\n    return np.stack(list(map(_transform_triple_numpy, triples)), axis=0)", "code_tokens": "def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )", "docstring_tokens": "Packs a list of triple indexes into a 2D numpy array .", "label": 0}, {"idx": "cosqa-train-8813", "doc": "python format function money decimals", "code": "def fixed(ctx, number, decimals=2, no_commas=False):\n    \"\"\"\n    Formats the given number in decimal format using a period and commas\n    \"\"\"\n    value = _round(ctx, number, decimals)\n    format_str = '{:f}' if no_commas else '{:,f}'\n    return format_str.format(value)", "code_tokens": "def fixed ( ctx , number , decimals = 2 , no_commas = False ) : value = _round ( ctx , number , decimals ) format_str = '{:f}' if no_commas else '{:,f}' return format_str . format ( value )", "docstring_tokens": "Formats the given number in decimal format using a period and commas", "label": 0}, {"idx": "cosqa-train-8814", "doc": "create df from list as columns in python", "code": "def _make_index(df, cols=META_IDX):\n    \"\"\"Create an index from the columns of a dataframe\"\"\"\n    return pd.MultiIndex.from_tuples(\n        pd.unique(list(zip(*[df[col] for col in cols]))), names=tuple(cols))", "code_tokens": "def _make_index ( df , cols = META_IDX ) : return pd . MultiIndex . from_tuples ( pd . unique ( list ( zip ( * [ df [ col ] for col in cols ] ) ) ) , names = tuple ( cols ) )", "docstring_tokens": "Create an index from the columns of a dataframe", "label": 1}, {"idx": "cosqa-train-8815", "doc": "python format string escaping curly brace", "code": "def string_format_func(s):\n\t\"\"\"\n\tFunction used internally to format string data for output to XML.\n\tEscapes back-slashes and quotes, and wraps the resulting string in\n\tquotes.\n\t\"\"\"\n\treturn u\"\\\"%s\\\"\" % unicode(s).replace(u\"\\\\\", u\"\\\\\\\\\").replace(u\"\\\"\", u\"\\\\\\\"\")", "code_tokens": "def string_format_func ( s ) : return u\"\\\"%s\\\"\" % unicode ( s ) . replace ( u\"\\\\\" , u\"\\\\\\\\\" ) . replace ( u\"\\\"\" , u\"\\\\\\\"\" )", "docstring_tokens": "Function used internally to format string data for output to XML . Escapes back - slashes and quotes and wraps the resulting string in quotes .", "label": 1}, {"idx": "cosqa-train-8816", "doc": "create dictionary wiht programmatic field names python", "code": "def map_parameters(cls, params):\n        \"\"\"Maps parameters to form field names\"\"\"\n\n        d = {}\n        for k, v in six.iteritems(params):\n            d[cls.FIELD_MAP.get(k.lower(), k)] = v\n        return d", "code_tokens": "def map_parameters ( cls , params ) : d = { } for k , v in six . iteritems ( params ) : d [ cls . FIELD_MAP . get ( k . lower ( ) , k ) ] = v return d", "docstring_tokens": "Maps parameters to form field names", "label": 0}, {"idx": "cosqa-train-8817", "doc": "python formatting ansi escape character", "code": "def position(self, x, y, text):\n        \"\"\"\n            ANSI Escape sequences\n            http://ascii-table.com/ansi-escape-sequences.php\n        \"\"\"\n        sys.stdout.write(\"\\x1b7\\x1b[%d;%df%s\\x1b8\" % (x, y, text))\n        sys.stdout.flush()", "code_tokens": "def position ( self , x , y , text ) : sys . stdout . write ( \"\\x1b7\\x1b[%d;%df%s\\x1b8\" % ( x , y , text ) ) sys . stdout . flush ( )", "docstring_tokens": "ANSI Escape sequences http : // ascii - table . com / ansi - escape - sequences . php", "label": 1}, {"idx": "cosqa-train-8818", "doc": "create doc path in python", "code": "def RunSphinxAPIDoc(_):\n  \"\"\"Runs sphinx-apidoc to auto-generate documentation.\"\"\"\n  current_directory = os.path.abspath(os.path.dirname(__file__))\n  module = os.path.join(current_directory, '..', 'plaso')\n  api_directory = os.path.join(current_directory, 'sources', 'api')\n  apidoc.main(['-o', api_directory, module, '--force'])", "code_tokens": "def RunSphinxAPIDoc ( _ ) : current_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) module = os . path . join ( current_directory , '..' , 'plaso' ) api_directory = os . path . join ( current_directory , 'sources' , 'api' ) apidoc . main ( [ '-o' , api_directory , module , '--force' ] )", "docstring_tokens": "Runs sphinx - apidoc to auto - generate documentation .", "label": 1}, {"idx": "cosqa-train-8819", "doc": "python function default args", "code": "def get_default_args(func):\n    \"\"\"\n    returns a dictionary of arg_name:default_values for the input function\n    \"\"\"\n    args, varargs, keywords, defaults = getargspec_no_self(func)\n    return dict(zip(args[-len(defaults):], defaults))", "code_tokens": "def get_default_args ( func ) : args , varargs , keywords , defaults = getargspec_no_self ( func ) return dict ( zip ( args [ - len ( defaults ) : ] , defaults ) )", "docstring_tokens": "returns a dictionary of arg_name : default_values for the input function", "label": 1}, {"idx": "cosqa-train-8820", "doc": "create empty python queryset object", "code": "def none(self):\n        \"\"\"\n        Returns an empty QuerySet.\n        \"\"\"\n        return EmptyQuerySet(model=self.model, using=self._using, connection=self._connection)", "code_tokens": "def none ( self ) : return EmptyQuerySet ( model = self . model , using = self . _using , connection = self . _connection )", "docstring_tokens": "Returns an empty QuerySet .", "label": 1}, {"idx": "cosqa-train-8821", "doc": "python function definition with underscore", "code": "def ucamel_method(func):\n    \"\"\"\n    Decorator to ensure the given snake_case method is also written in\n    UpperCamelCase in the given namespace. That was mainly written to\n    avoid confusion when using wxPython and its UpperCamelCaseMethods.\n    \"\"\"\n    frame_locals = inspect.currentframe().f_back.f_locals\n    frame_locals[snake2ucamel(func.__name__)] = func\n    return func", "code_tokens": "def ucamel_method ( func ) : frame_locals = inspect . currentframe ( ) . f_back . f_locals frame_locals [ snake2ucamel ( func . __name__ ) ] = func return func", "docstring_tokens": "Decorator to ensure the given snake_case method is also written in UpperCamelCase in the given namespace . That was mainly written to avoid confusion when using wxPython and its UpperCamelCaseMethods .", "label": 0}, {"idx": "cosqa-train-8822", "doc": "create engine python connect to server", "code": "def main(ctx, connection):\n    \"\"\"Command line interface for PyBEL.\"\"\"\n    ctx.obj = Manager(connection=connection)\n    ctx.obj.bind()", "code_tokens": "def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )", "docstring_tokens": "Command line interface for PyBEL .", "label": 1}, {"idx": "cosqa-train-8823", "doc": "python function name leading underscore", "code": "def ucamel_method(func):\n    \"\"\"\n    Decorator to ensure the given snake_case method is also written in\n    UpperCamelCase in the given namespace. That was mainly written to\n    avoid confusion when using wxPython and its UpperCamelCaseMethods.\n    \"\"\"\n    frame_locals = inspect.currentframe().f_back.f_locals\n    frame_locals[snake2ucamel(func.__name__)] = func\n    return func", "code_tokens": "def ucamel_method ( func ) : frame_locals = inspect . currentframe ( ) . f_back . f_locals frame_locals [ snake2ucamel ( func . __name__ ) ] = func return func", "docstring_tokens": "Decorator to ensure the given snake_case method is also written in UpperCamelCase in the given namespace . That was mainly written to avoid confusion when using wxPython and its UpperCamelCaseMethods .", "label": 0}, {"idx": "cosqa-train-8824", "doc": "create python dictionary from sqlite3 response", "code": "def sqliteRowsToDicts(sqliteRows):\n    \"\"\"\n    Unpacks sqlite rows as returned by fetchall\n    into an array of simple dicts.\n\n    :param sqliteRows: array of rows returned from fetchall DB call\n    :return:  array of dicts, keyed by the column names.\n    \"\"\"\n    return map(lambda r: dict(zip(r.keys(), r)), sqliteRows)", "code_tokens": "def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )", "docstring_tokens": "Unpacks sqlite rows as returned by fetchall into an array of simple dicts .", "label": 1}, {"idx": "cosqa-train-8825", "doc": "python function replaces all occurences of old with new in a string", "code": "def myreplace(astr, thefind, thereplace):\n    \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"\n    alist = astr.split(thefind)\n    new_s = alist.split(thereplace)\n    return new_s", "code_tokens": "def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "docstring_tokens": "in string astr replace all occurences of thefind with thereplace", "label": 1}, {"idx": "cosqa-train-8826", "doc": "create python file from ipynb", "code": "def nb_to_python(nb_path):\n    \"\"\"convert notebook to python script\"\"\"\n    exporter = python.PythonExporter()\n    output, resources = exporter.from_filename(nb_path)\n    return output", "code_tokens": "def nb_to_python ( nb_path ) : exporter = python . PythonExporter ( ) output , resources = exporter . from_filename ( nb_path ) return output", "docstring_tokens": "convert notebook to python script", "label": 1}, {"idx": "cosqa-train-8827", "doc": "python function that returns to arrays", "code": "def pack_triples_numpy(triples):\n    \"\"\"Packs a list of triple indexes into a 2D numpy array.\"\"\"\n    if len(triples) == 0:\n        return np.array([], dtype=np.int64)\n    return np.stack(list(map(_transform_triple_numpy, triples)), axis=0)", "code_tokens": "def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )", "docstring_tokens": "Packs a list of triple indexes into a 2D numpy array .", "label": 0}, {"idx": "cosqa-train-8828", "doc": "creating a leap year function in python returning true or false", "code": "def _is_leap_year(year):\n    \"\"\"Determine if a year is leap year.\n\n    Parameters\n    ----------\n    year : numeric\n\n    Returns\n    -------\n    isleap : array of bools\n    \"\"\"\n    isleap = ((np.mod(year, 4) == 0) &\n              ((np.mod(year, 100) != 0) | (np.mod(year, 400) == 0)))\n    return isleap", "code_tokens": "def _is_leap_year ( year ) : isleap = ( ( np . mod ( year , 4 ) == 0 ) & ( ( np . mod ( year , 100 ) != 0 ) | ( np . mod ( year , 400 ) == 0 ) ) ) return isleap", "docstring_tokens": "Determine if a year is leap year .", "label": 1}, {"idx": "cosqa-train-8829", "doc": "python gaussian filter array", "code": "def smooth_gaussian(image, sigma=1):\n    \"\"\"Returns Gaussian smoothed image.\n\n    :param image: numpy array or :class:`jicimagelib.image.Image`\n    :param sigma: standard deviation\n    :returns: :class:`jicimagelib.image.Image`\n    \"\"\"\n    return scipy.ndimage.filters.gaussian_filter(image, sigma=sigma, mode=\"nearest\")", "code_tokens": "def smooth_gaussian ( image , sigma = 1 ) : return scipy . ndimage . filters . gaussian_filter ( image , sigma = sigma , mode = \"nearest\" )", "docstring_tokens": "Returns Gaussian smoothed image .", "label": 1}, {"idx": "cosqa-train-8830", "doc": "creating comment block with python", "code": "def comment (self, s, **args):\n        \"\"\"Write GML comment.\"\"\"\n        self.writeln(s=u'comment \"%s\"' % s, **args)", "code_tokens": "def comment ( self , s , * * args ) : self . writeln ( s = u'comment \"%s\"' % s , * * args )", "docstring_tokens": "Write GML comment .", "label": 0}, {"idx": "cosqa-train-8831", "doc": "python generate all permutations of list", "code": "def circ_permutation(items):\n    \"\"\"Calculate the circular permutation for a given list of items.\"\"\"\n    permutations = []\n    for i in range(len(items)):\n        permutations.append(items[i:] + items[:i])\n    return permutations", "code_tokens": "def circ_permutation ( items ) : permutations = [ ] for i in range ( len ( items ) ) : permutations . append ( items [ i : ] + items [ : i ] ) return permutations", "docstring_tokens": "Calculate the circular permutation for a given list of items .", "label": 0}, {"idx": "cosqa-train-8832", "doc": "creating function to match column to key python", "code": "def check_hash_key(query_on, key):\n    \"\"\"Only allows == against query_on.hash_key\"\"\"\n    return (\n        isinstance(key, BaseCondition) and\n        (key.operation == \"==\") and\n        (key.column is query_on.hash_key)\n    )", "code_tokens": "def check_hash_key ( query_on , key ) : return ( isinstance ( key , BaseCondition ) and ( key . operation == \"==\" ) and ( key . column is query_on . hash_key ) )", "docstring_tokens": "Only allows == against query_on . hash_key", "label": 0}, {"idx": "cosqa-train-8833", "doc": "python generate android deviceid", "code": "def generate_device_id(steamid):\n    \"\"\"Generate Android device id\n\n    :param steamid: Steam ID\n    :type steamid: :class:`.SteamID`, :class:`int`\n    :return: android device id\n    :rtype: str\n    \"\"\"\n    h = hexlify(sha1_hash(str(steamid).encode('ascii'))).decode('ascii')\n    return \"android:%s-%s-%s-%s-%s\" % (h[:8], h[8:12], h[12:16], h[16:20], h[20:32])", "code_tokens": "def generate_device_id ( steamid ) : h = hexlify ( sha1_hash ( str ( steamid ) . encode ( 'ascii' ) ) ) . decode ( 'ascii' ) return \"android:%s-%s-%s-%s-%s\" % ( h [ : 8 ] , h [ 8 : 12 ] , h [ 12 : 16 ] , h [ 16 : 20 ] , h [ 20 : 32 ] )", "docstring_tokens": "Generate Android device id", "label": 1}, {"idx": "cosqa-train-8834", "doc": "creating gist with python passing authentication", "code": "def __init__(self, token, editor=None):\n        \"\"\"Create a GistAPI object\n\n        Arguments:\n            token: an authentication token\n            editor: path to the editor to use when editing a gist\n\n        \"\"\"\n        self.token = token\n        self.editor = editor\n        self.session = requests.Session()", "code_tokens": "def __init__ ( self , token , editor = None ) : self . token = token self . editor = editor self . session = requests . Session ( )", "docstring_tokens": "Create a GistAPI object", "label": 0}, {"idx": "cosqa-train-8835", "doc": "python generate new unique id", "code": "def generate_id(self):\n        \"\"\"Generate a fresh id\"\"\"\n        if self.use_repeatable_ids:\n            self.repeatable_id_counter += 1\n            return 'autobaked-{}'.format(self.repeatable_id_counter)\n        else:\n            return str(uuid4())", "code_tokens": "def generate_id ( self ) : if self . use_repeatable_ids : self . repeatable_id_counter += 1 return 'autobaked-{}' . format ( self . repeatable_id_counter ) else : return str ( uuid4 ( ) )", "docstring_tokens": "Generate a fresh id", "label": 1}, {"idx": "cosqa-train-8836", "doc": "creating model in python sqlalchemy flask", "code": "def create_db(app, appbuilder):\n    \"\"\"\n        Create all your database objects (SQLAlchemy specific).\n    \"\"\"\n    from flask_appbuilder.models.sqla import Base\n\n    _appbuilder = import_application(app, appbuilder)\n    engine = _appbuilder.get_session.get_bind(mapper=None, clause=None)\n    Base.metadata.create_all(engine)\n    click.echo(click.style(\"DB objects created\", fg=\"green\"))", "code_tokens": "def create_db ( app , appbuilder ) : from flask_appbuilder . models . sqla import Base _appbuilder = import_application ( app , appbuilder ) engine = _appbuilder . get_session . get_bind ( mapper = None , clause = None ) Base . metadata . create_all ( engine ) click . echo ( click . style ( \"DB objects created\" , fg = \"green\" ) )", "docstring_tokens": "Create all your database objects ( SQLAlchemy specific ) .", "label": 0}, {"idx": "cosqa-train-8837", "doc": "python generate random file name", "code": "def get_incomplete_path(filename):\n  \"\"\"Returns a temporary filename based on filename.\"\"\"\n  random_suffix = \"\".join(\n      random.choice(string.ascii_uppercase + string.digits) for _ in range(6))\n  return filename + \".incomplete\" + random_suffix", "code_tokens": "def get_incomplete_path ( filename ) : random_suffix = \"\" . join ( random . choice ( string . ascii_uppercase + string . digits ) for _ in range ( 6 ) ) return filename + \".incomplete\" + random_suffix", "docstring_tokens": "Returns a temporary filename based on filename .", "label": 1}, {"idx": "cosqa-train-8838", "doc": "creating python list from json", "code": "def from_json_list(cls, api_client, data):\n        \"\"\"Convert a list of JSON values to a list of models\n        \"\"\"\n        return [cls.from_json(api_client, item) for item in data]", "code_tokens": "def from_json_list ( cls , api_client , data ) : return [ cls . from_json ( api_client , item ) for item in data ]", "docstring_tokens": "Convert a list of JSON values to a list of models", "label": 1}, {"idx": "cosqa-train-8839", "doc": "python generate random hash string", "code": "def generate_hash(self, length=30):\n        \"\"\" Generate random string of given length \"\"\"\n        import random, string\n        chars = string.ascii_letters + string.digits\n        ran = random.SystemRandom().choice\n        hash = ''.join(ran(chars) for i in range(length))\n        return hash", "code_tokens": "def generate_hash ( self , length = 30 ) : import random , string chars = string . ascii_letters + string . digits ran = random . SystemRandom ( ) . choice hash = '' . join ( ran ( chars ) for i in range ( length ) ) return hash", "docstring_tokens": "Generate random string of given length", "label": 1}, {"idx": "cosqa-train-8840", "doc": "cursor not visible in python kinter", "code": "def ensure_hbounds(self):\n        \"\"\"Ensure the cursor is within horizontal screen bounds.\"\"\"\n        self.cursor.x = min(max(0, self.cursor.x), self.columns - 1)", "code_tokens": "def ensure_hbounds ( self ) : self . cursor . x = min ( max ( 0 , self . cursor . x ) , self . columns - 1 )", "docstring_tokens": "Ensure the cursor is within horizontal screen bounds .", "label": 1}, {"idx": "cosqa-train-8841", "doc": "python generate timespan value", "code": "def timespan(start_time):\n    \"\"\"Return time in milliseconds from start_time\"\"\"\n\n    timespan = datetime.datetime.now() - start_time\n    timespan_ms = timespan.total_seconds() * 1000\n    return timespan_ms", "code_tokens": "def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms", "docstring_tokens": "Return time in milliseconds from start_time", "label": 0}, {"idx": "cosqa-train-8842", "doc": "cuts in python bins code", "code": "def lon_lat_bins(bb, coord_bin_width):\n    \"\"\"\n    Define bin edges for disaggregation histograms.\n\n    Given bins data as provided by :func:`collect_bin_data`, this function\n    finds edges of histograms, taking into account maximum and minimum values\n    of magnitude, distance and coordinates as well as requested sizes/numbers\n    of bins.\n    \"\"\"\n    west, south, east, north = bb\n    west = numpy.floor(west / coord_bin_width) * coord_bin_width\n    east = numpy.ceil(east / coord_bin_width) * coord_bin_width\n    lon_extent = get_longitudinal_extent(west, east)\n    lon_bins, _, _ = npoints_between(\n        west, 0, 0, east, 0, 0,\n        numpy.round(lon_extent / coord_bin_width + 1))\n    lat_bins = coord_bin_width * numpy.arange(\n        int(numpy.floor(south / coord_bin_width)),\n        int(numpy.ceil(north / coord_bin_width) + 1))\n    return lon_bins, lat_bins", "code_tokens": "def lon_lat_bins ( bb , coord_bin_width ) : west , south , east , north = bb west = numpy . floor ( west / coord_bin_width ) * coord_bin_width east = numpy . ceil ( east / coord_bin_width ) * coord_bin_width lon_extent = get_longitudinal_extent ( west , east ) lon_bins , _ , _ = npoints_between ( west , 0 , 0 , east , 0 , 0 , numpy . round ( lon_extent / coord_bin_width + 1 ) ) lat_bins = coord_bin_width * numpy . arange ( int ( numpy . floor ( south / coord_bin_width ) ) , int ( numpy . ceil ( north / coord_bin_width ) + 1 ) ) return lon_bins , lat_bins", "docstring_tokens": "Define bin edges for disaggregation histograms .", "label": 0}, {"idx": "cosqa-train-8843", "doc": "python geocoder result not found", "code": "def get_geoip(ip):\n    \"\"\"Lookup country for IP address.\"\"\"\n    reader = geolite2.reader()\n    ip_data = reader.get(ip) or {}\n    return ip_data.get('country', {}).get('iso_code')", "code_tokens": "def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )", "docstring_tokens": "Lookup country for IP address .", "label": 1}, {"idx": "cosqa-train-8844", "doc": "date to number converter python", "code": "def int_to_date(date):\n    \"\"\"\n    Convert an int of form yyyymmdd to a python date object.\n    \"\"\"\n\n    year = date // 10**4\n    month = date % 10**4 // 10**2\n    day = date % 10**2\n\n    return datetime.date(year, month, day)", "code_tokens": "def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )", "docstring_tokens": "Convert an int of form yyyymmdd to a python date object .", "label": 1}, {"idx": "cosqa-train-8845", "doc": "python get 2d array dimensions", "code": "def out_shape_from_array(arr):\n    \"\"\"Get the output shape from an array.\"\"\"\n    arr = np.asarray(arr)\n    if arr.ndim == 1:\n        return arr.shape\n    else:\n        return (arr.shape[1],)", "code_tokens": "def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "docstring_tokens": "Get the output shape from an array .", "label": 1}, {"idx": "cosqa-train-8846", "doc": "datetime python round to minute", "code": "def __round_time(self, dt):\n    \"\"\"Round a datetime object to a multiple of a timedelta\n    dt : datetime.datetime object, default now.\n    \"\"\"\n    round_to = self._resolution.total_seconds()\n    seconds  = (dt - dt.min).seconds\n    rounding = (seconds + round_to / 2) // round_to * round_to\n    return dt + timedelta(0, rounding - seconds, -dt.microsecond)", "code_tokens": "def __round_time ( self , dt ) : round_to = self . _resolution . total_seconds ( ) seconds = ( dt - dt . min ) . seconds rounding = ( seconds + round_to / 2 ) // round_to * round_to return dt + timedelta ( 0 , rounding - seconds , - dt . microsecond )", "docstring_tokens": "Round a datetime object to a multiple of a timedelta dt : datetime . datetime object default now .", "label": 0}, {"idx": "cosqa-train-8847", "doc": "python get a list of font names from windows", "code": "def get_font_list():\n    \"\"\"Returns a sorted list of all system font names\"\"\"\n\n    font_map = pangocairo.cairo_font_map_get_default()\n    font_list = [f.get_name() for f in font_map.list_families()]\n    font_list.sort()\n\n    return font_list", "code_tokens": "def get_font_list ( ) : font_map = pangocairo . cairo_font_map_get_default ( ) font_list = [ f . get_name ( ) for f in font_map . list_families ( ) ] font_list . sort ( ) return font_list", "docstring_tokens": "Returns a sorted list of all system font names", "label": 1}, {"idx": "cosqa-train-8848", "doc": "datetime timezone python utc", "code": "def to_utc(self, dt):\n        \"\"\"Convert any timestamp to UTC (with tzinfo).\"\"\"\n        if dt.tzinfo is None:\n            return dt.replace(tzinfo=self.utc)\n        return dt.astimezone(self.utc)", "code_tokens": "def to_utc ( self , dt ) : if dt . tzinfo is None : return dt . replace ( tzinfo = self . utc ) return dt . astimezone ( self . utc )", "docstring_tokens": "Convert any timestamp to UTC ( with tzinfo ) .", "label": 1}, {"idx": "cosqa-train-8849", "doc": "python get a method's name", "code": "def FindMethodByName(self, name):\n    \"\"\"Searches for the specified method, and returns its descriptor.\"\"\"\n    for method in self.methods:\n      if name == method.name:\n        return method\n    return None", "code_tokens": "def FindMethodByName ( self , name ) : for method in self . methods : if name == method . name : return method return None", "docstring_tokens": "Searches for the specified method and returns its descriptor .", "label": 0}, {"idx": "cosqa-train-8850", "doc": "datetime to epoch in python", "code": "def _dt_to_epoch(dt):\n        \"\"\"Convert datetime to epoch seconds.\"\"\"\n        try:\n            epoch = dt.timestamp()\n        except AttributeError:  # py2\n            epoch = (dt - datetime(1970, 1, 1)).total_seconds()\n        return epoch", "code_tokens": "def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch", "docstring_tokens": "Convert datetime to epoch seconds .", "label": 1}, {"idx": "cosqa-train-8851", "doc": "python get all a on a string", "code": "def return_letters_from_string(text):\n    \"\"\"Get letters from string only.\"\"\"\n    out = \"\"\n    for letter in text:\n        if letter.isalpha():\n            out += letter\n    return out", "code_tokens": "def return_letters_from_string ( text ) : out = \"\" for letter in text : if letter . isalpha ( ) : out += letter return out", "docstring_tokens": "Get letters from string only .", "label": 0}, {"idx": "cosqa-train-8852", "doc": "datetime type to string python", "code": "def object_to_json(obj):\n    \"\"\"Convert object that cannot be natively serialized by python to JSON representation.\"\"\"\n    if isinstance(obj, (datetime.datetime, datetime.date, datetime.time)):\n        return obj.isoformat()\n    return str(obj)", "code_tokens": "def object_to_json ( obj ) : if isinstance ( obj , ( datetime . datetime , datetime . date , datetime . time ) ) : return obj . isoformat ( ) return str ( obj )", "docstring_tokens": "Convert object that cannot be natively serialized by python to JSON representation .", "label": 0}, {"idx": "cosqa-train-8853", "doc": "python get all of the pids in a process group", "code": "def get_pid_list():\n    \"\"\"Returns a list of PIDs currently running on the system.\"\"\"\n    pids = [int(x) for x in os.listdir('/proc') if x.isdigit()]\n    return pids", "code_tokens": "def get_pid_list ( ) : pids = [ int ( x ) for x in os . listdir ( '/proc' ) if x . isdigit ( ) ] return pids", "docstring_tokens": "Returns a list of PIDs currently running on the system .", "label": 0}, {"idx": "cosqa-train-8854", "doc": "declaring a method as private in python", "code": "def method(func):\n    \"\"\"Wrap a function as a method.\"\"\"\n    attr = abc.abstractmethod(func)\n    attr.__imethod__ = True\n    return attr", "code_tokens": "def method ( func ) : attr = abc . abstractmethod ( func ) attr . __imethod__ = True return attr", "docstring_tokens": "Wrap a function as a method .", "label": 0}, {"idx": "cosqa-train-8855", "doc": "python get bounds of window", "code": "def getRect(self):\n\t\t\"\"\"\n\t\tReturns the window bounds as a tuple of (x,y,w,h)\n\t\t\"\"\"\n\t\treturn (self.x, self.y, self.w, self.h)", "code_tokens": "def getRect ( self ) : return ( self . x , self . y , self . w , self . h )", "docstring_tokens": "Returns the window bounds as a tuple of ( x y w h )", "label": 1}, {"idx": "cosqa-train-8856", "doc": "default value for *args python", "code": "def validate_args(**args):\n\t\"\"\"\n\tfunction to check if input query is not None \n\tand set missing arguments to default value\n\t\"\"\"\n\tif not args['query']:\n\t\tprint(\"\\nMissing required query argument.\")\n\t\tsys.exit()\n\n\tfor key in DEFAULTS:\n\t\tif key not in args:\n\t\t\targs[key] = DEFAULTS[key]\n\n\treturn args", "code_tokens": "def validate_args ( * * args ) : if not args [ 'query' ] : print ( \"\\nMissing required query argument.\" ) sys . exit ( ) for key in DEFAULTS : if key not in args : args [ key ] = DEFAULTS [ key ] return args", "docstring_tokens": "function to check if input query is not None and set missing arguments to default value", "label": 0}, {"idx": "cosqa-train-8857", "doc": "python get content length from http response", "code": "def get_body_size(params, boundary):\n    \"\"\"Returns the number of bytes that the multipart/form-data encoding\n    of ``params`` will be.\"\"\"\n    size = sum(p.get_size(boundary) for p in MultipartParam.from_params(params))\n    return size + len(boundary) + 6", "code_tokens": "def get_body_size ( params , boundary ) : size = sum ( p . get_size ( boundary ) for p in MultipartParam . from_params ( params ) ) return size + len ( boundary ) + 6", "docstring_tokens": "Returns the number of bytes that the multipart / form - data encoding of params will be .", "label": 1}, {"idx": "cosqa-train-8858", "doc": "default value for input python3", "code": "def input_int_default(question=\"\", default=0):\n    \"\"\"A function that works for both, Python 2.x and Python 3.x.\n       It asks the user for input and returns it as a string.\n    \"\"\"\n    answer = input_string(question)\n    if answer == \"\" or answer == \"yes\":\n        return default\n    else:\n        return int(answer)", "code_tokens": "def input_int_default ( question = \"\" , default = 0 ) : answer = input_string ( question ) if answer == \"\" or answer == \"yes\" : return default else : return int ( answer )", "docstring_tokens": "A function that works for both Python 2 . x and Python 3 . x . It asks the user for input and returns it as a string .", "label": 1}, {"idx": "cosqa-train-8859", "doc": "python get current index of iterator", "code": "def index(self, elem):\n        \"\"\"Find the index of elem in the reversed iterator.\"\"\"\n        return _coconut.len(self._iter) - self._iter.index(elem) - 1", "code_tokens": "def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1", "docstring_tokens": "Find the index of elem in the reversed iterator .", "label": 0}, {"idx": "cosqa-train-8860", "doc": "defaultdict python lambda argrument", "code": "def get_default_args(func):\n    \"\"\"\n    returns a dictionary of arg_name:default_values for the input function\n    \"\"\"\n    args, varargs, keywords, defaults = getargspec_no_self(func)\n    return dict(zip(args[-len(defaults):], defaults))", "code_tokens": "def get_default_args ( func ) : args , varargs , keywords , defaults = getargspec_no_self ( func ) return dict ( zip ( args [ - len ( defaults ) : ] , defaults ) )", "docstring_tokens": "returns a dictionary of arg_name : default_values for the input function", "label": 0}, {"idx": "cosqa-train-8861", "doc": "python get current loggers", "code": "def _get_loggers():\n    \"\"\"Return list of Logger classes.\"\"\"\n    from .. import loader\n    modules = loader.get_package_modules('logger')\n    return list(loader.get_plugins(modules, [_Logger]))", "code_tokens": "def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )", "docstring_tokens": "Return list of Logger classes .", "label": 1}, {"idx": "cosqa-train-8862", "doc": "define an array inside structure in python ctype", "code": "def c_array(ctype, values):\n    \"\"\"Convert a python string to c array.\"\"\"\n    if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype):\n        return (ctype * len(values)).from_buffer_copy(values)\n    return (ctype * len(values))(*values)", "code_tokens": "def c_array ( ctype , values ) : if isinstance ( values , np . ndarray ) and values . dtype . itemsize == ctypes . sizeof ( ctype ) : return ( ctype * len ( values ) ) . from_buffer_copy ( values ) return ( ctype * len ( values ) ) ( * values )", "docstring_tokens": "Convert a python string to c array .", "label": 1}, {"idx": "cosqa-train-8863", "doc": "python get dimenstions of object", "code": "def get_shape(self):\n\t\t\"\"\"\n\t\tReturn a tuple of this array's dimensions.  This is done by\n\t\tquerying the Dim children.  Note that once it has been\n\t\tcreated, it is also possible to examine an Array object's\n\t\t.array attribute directly, and doing that is much faster.\n\t\t\"\"\"\n\t\treturn tuple(int(c.pcdata) for c in self.getElementsByTagName(ligolw.Dim.tagName))[::-1]", "code_tokens": "def get_shape ( self ) : return tuple ( int ( c . pcdata ) for c in self . getElementsByTagName ( ligolw . Dim . tagName ) ) [ : : - 1 ]", "docstring_tokens": "Return a tuple of this array s dimensions . This is done by querying the Dim children . Note that once it has been created it is also possible to examine an Array object s . array attribute directly and doing that is much faster .", "label": 1}, {"idx": "cosqa-train-8864", "doc": "defining an array in python zeroes", "code": "def zeros(self, name, **kwargs):\n        \"\"\"Create an array. Keyword arguments as per\n        :func:`zarr.creation.zeros`.\"\"\"\n        return self._write_op(self._zeros_nosync, name, **kwargs)", "code_tokens": "def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )", "docstring_tokens": "Create an array . Keyword arguments as per : func : zarr . creation . zeros .", "label": 1}, {"idx": "cosqa-train-8865", "doc": "python get distance between two points multiple dimensions", "code": "def dist(x1, x2, axis=0):\n    \"\"\"Return the distance between two points.\n\n    Set axis=1 if x1 is a vector and x2 a matrix to get a vector of distances.\n    \"\"\"\n    return np.linalg.norm(x2 - x1, axis=axis)", "code_tokens": "def dist ( x1 , x2 , axis = 0 ) : return np . linalg . norm ( x2 - x1 , axis = axis )", "docstring_tokens": "Return the distance between two points .", "label": 1}, {"idx": "cosqa-train-8866", "doc": "delaunay 3d triangulation python", "code": "def delaunay_2d(self, tol=1e-05, alpha=0.0, offset=1.0, bound=False):\n        \"\"\"Apply a delaunay 2D filter along the best fitting plane. This\n        extracts the grid's points and perfoms the triangulation on those alone.\n        \"\"\"\n        return PolyData(self.points).delaunay_2d(tol=tol, alpha=alpha, offset=offset, bound=bound)", "code_tokens": "def delaunay_2d ( self , tol = 1e-05 , alpha = 0.0 , offset = 1.0 , bound = False ) : return PolyData ( self . points ) . delaunay_2d ( tol = tol , alpha = alpha , offset = offset , bound = bound )", "docstring_tokens": "Apply a delaunay 2D filter along the best fitting plane . This extracts the grid s points and perfoms the triangulation on those alone .", "label": 1}, {"idx": "cosqa-train-8867", "doc": "python get domain from links", "code": "def parse_domain(url):\n    \"\"\" parse the domain from the url \"\"\"\n    domain_match = lib.DOMAIN_REGEX.match(url)\n    if domain_match:\n        return domain_match.group()", "code_tokens": "def parse_domain ( url ) : domain_match = lib . DOMAIN_REGEX . match ( url ) if domain_match : return domain_match . group ( )", "docstring_tokens": "parse the domain from the url", "label": 1}, {"idx": "cosqa-train-8868", "doc": "delete all figures python", "code": "def close_all():\n    \"\"\"Close all open/active plotters\"\"\"\n    for key, p in _ALL_PLOTTERS.items():\n        p.close()\n    _ALL_PLOTTERS.clear()\n    return True", "code_tokens": "def close_all ( ) : for key , p in _ALL_PLOTTERS . items ( ) : p . close ( ) _ALL_PLOTTERS . clear ( ) return True", "docstring_tokens": "Close all open / active plotters", "label": 1}, {"idx": "cosqa-train-8869", "doc": "python get epoch seconds from datetime", "code": "def _DateToEpoch(date):\n  \"\"\"Converts python datetime to epoch microseconds.\"\"\"\n  tz_zero = datetime.datetime.utcfromtimestamp(0)\n  diff_sec = int((date - tz_zero).total_seconds())\n  return diff_sec * 1000000", "code_tokens": "def _DateToEpoch ( date ) : tz_zero = datetime . datetime . utcfromtimestamp ( 0 ) diff_sec = int ( ( date - tz_zero ) . total_seconds ( ) ) return diff_sec * 1000000", "docstring_tokens": "Converts python datetime to epoch microseconds .", "label": 0}, {"idx": "cosqa-train-8870", "doc": "delete elements from canvas python", "code": "def forget_canvas(canvas):\n    \"\"\" Forget about the given canvas. Used by the canvas when closed.\n    \"\"\"\n    cc = [c() for c in canvasses if c() is not None]\n    while canvas in cc:\n        cc.remove(canvas)\n    canvasses[:] = [weakref.ref(c) for c in cc]", "code_tokens": "def forget_canvas ( canvas ) : cc = [ c ( ) for c in canvasses if c ( ) is not None ] while canvas in cc : cc . remove ( canvas ) canvasses [ : ] = [ weakref . ref ( c ) for c in cc ]", "docstring_tokens": "Forget about the given canvas . Used by the canvas when closed .", "label": 1}, {"idx": "cosqa-train-8871", "doc": "python get epoch time int", "code": "def AmericanDateToEpoch(self, date_str):\n    \"\"\"Take a US format date and return epoch.\"\"\"\n    try:\n      epoch = time.strptime(date_str, \"%m/%d/%Y\")\n      return int(calendar.timegm(epoch)) * 1000000\n    except ValueError:\n      return 0", "code_tokens": "def AmericanDateToEpoch ( self , date_str ) : try : epoch = time . strptime ( date_str , \"%m/%d/%Y\" ) return int ( calendar . timegm ( epoch ) ) * 1000000 except ValueError : return 0", "docstring_tokens": "Take a US format date and return epoch .", "label": 0}, {"idx": "cosqa-train-8872", "doc": "delete map member in python", "code": "def __delitem__(self, key):\n        \"\"\"Remove a variable from this dataset.\n        \"\"\"\n        del self._variables[key]\n        self._coord_names.discard(key)", "code_tokens": "def __delitem__ ( self , key ) : del self . _variables [ key ] self . _coord_names . discard ( key )", "docstring_tokens": "Remove a variable from this dataset .", "label": 0}, {"idx": "cosqa-train-8873", "doc": "python get file name in function", "code": "def get_file_name(url):\n  \"\"\"Returns file name of file at given url.\"\"\"\n  return os.path.basename(urllib.parse.urlparse(url).path) or 'unknown_name'", "code_tokens": "def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'", "docstring_tokens": "Returns file name of file at given url .", "label": 1}, {"idx": "cosqa-train-8874", "doc": "delete pyc files from python script", "code": "def clean(dry_run='n'):\n    \"\"\"Wipes compiled and cached python files. To simulate: pynt clean[dry_run=y]\"\"\"\n    file_patterns = ['*.pyc', '*.pyo', '*~']\n    dir_patterns = ['__pycache__']\n    recursive_pattern_delete(project_paths.root, file_patterns, dir_patterns, dry_run=bool(dry_run.lower() == 'y'))", "code_tokens": "def clean ( dry_run = 'n' ) : file_patterns = [ '*.pyc' , '*.pyo' , '*~' ] dir_patterns = [ '__pycache__' ] recursive_pattern_delete ( project_paths . root , file_patterns , dir_patterns , dry_run = bool ( dry_run . lower ( ) == 'y' ) )", "docstring_tokens": "Wipes compiled and cached python files . To simulate : pynt clean [ dry_run = y ]", "label": 1}, {"idx": "cosqa-train-8875", "doc": "python get first number of float", "code": "def find_first_number(ll):\n    \"\"\" Returns nr of first entry parseable to float in ll, None otherwise\"\"\"\n    for nr, entry in enumerate(ll):\n        try:\n            float(entry)\n        except (ValueError, TypeError) as e:\n            pass\n        else:\n            return nr\n    return None", "code_tokens": "def find_first_number ( ll ) : for nr , entry in enumerate ( ll ) : try : float ( entry ) except ( ValueError , TypeError ) as e : pass else : return nr return None", "docstring_tokens": "Returns nr of first entry parseable to float in ll None otherwise", "label": 1}, {"idx": "cosqa-train-8876", "doc": "depth first tree traversal python", "code": "def walk_tree(root):\n    \"\"\"Pre-order depth-first\"\"\"\n    yield root\n\n    for child in root.children:\n        for el in walk_tree(child):\n            yield el", "code_tokens": "def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el", "docstring_tokens": "Pre - order depth - first", "label": 1}, {"idx": "cosqa-train-8877", "doc": "python get frequency of mic sound", "code": "def calc_volume(self, sample: np.ndarray):\n        \"\"\"Find the RMS of the audio\"\"\"\n        return sqrt(np.mean(np.square(sample)))", "code_tokens": "def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )", "docstring_tokens": "Find the RMS of the audio", "label": 0}, {"idx": "cosqa-train-8878", "doc": "python get ipaddress of server", "code": "def get_own_ip():\n    \"\"\"Get the host's ip number.\n    \"\"\"\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    try:\n        sock.connect((\"8.8.8.8\", 80))\n    except socket.gaierror:\n        ip_ = \"127.0.0.1\"\n    else:\n        ip_ = sock.getsockname()[0]\n    finally:\n        sock.close()\n    return ip_", "code_tokens": "def get_own_ip ( ) : sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) try : sock . connect ( ( \"8.8.8.8\" , 80 ) ) except socket . gaierror : ip_ = \"127.0.0.1\" else : ip_ = sock . getsockname ( ) [ 0 ] finally : sock . close ( ) return ip_", "docstring_tokens": "Get the host s ip number .", "label": 1}, {"idx": "cosqa-train-8879", "doc": "detecting foreign language in text python", "code": "def load_feature(fname, language):\n    \"\"\" Load and parse a feature file. \"\"\"\n\n    fname = os.path.abspath(fname)\n    feat = parse_file(fname, language)\n    return feat", "code_tokens": "def load_feature ( fname , language ) : fname = os . path . abspath ( fname ) feat = parse_file ( fname , language ) return feat", "docstring_tokens": "Load and parse a feature file .", "label": 1}, {"idx": "cosqa-train-8880", "doc": "python get jvm default path", "code": "def get_java_path():\n  \"\"\"Get the path of java executable\"\"\"\n  java_home = os.environ.get(\"JAVA_HOME\")\n  return os.path.join(java_home, BIN_DIR, \"java\")", "code_tokens": "def get_java_path ( ) : java_home = os . environ . get ( \"JAVA_HOME\" ) return os . path . join ( java_home , BIN_DIR , \"java\" )", "docstring_tokens": "Get the path of java executable", "label": 1}, {"idx": "cosqa-train-8881", "doc": "detecting strings in an object in python", "code": "def is_collection(obj):\n    \"\"\"Tests if an object is a collection.\"\"\"\n\n    col = getattr(obj, '__getitem__', False)\n    val = False if (not col) else True\n\n    if isinstance(obj, basestring):\n        val = False\n\n    return val", "code_tokens": "def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val", "docstring_tokens": "Tests if an object is a collection .", "label": 0}, {"idx": "cosqa-train-8882", "doc": "python get last file in sequence", "code": "def newest_file(file_iterable):\n  \"\"\"\n  Returns the name of the newest file given an iterable of file names.\n\n  \"\"\"\n  return max(file_iterable, key=lambda fname: os.path.getmtime(fname))", "code_tokens": "def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )", "docstring_tokens": "Returns the name of the newest file given an iterable of file names .", "label": 0}, {"idx": "cosqa-train-8883", "doc": "determine last element of a line python code", "code": "def cell_ends_with_code(lines):\n    \"\"\"Is the last line of the cell a line with code?\"\"\"\n    if not lines:\n        return False\n    if not lines[-1].strip():\n        return False\n    if lines[-1].startswith('#'):\n        return False\n    return True", "code_tokens": "def cell_ends_with_code ( lines ) : if not lines : return False if not lines [ - 1 ] . strip ( ) : return False if lines [ - 1 ] . startswith ( '#' ) : return False return True", "docstring_tokens": "Is the last line of the cell a line with code?", "label": 0}, {"idx": "cosqa-train-8884", "doc": "python get last id in db", "code": "def get_last_id(self, cur, table='reaction'):\n        \"\"\"\n        Get the id of the last written row in table\n\n        Parameters\n        ----------\n        cur: database connection().cursor() object\n        table: str\n            'reaction', 'publication', 'publication_system', 'reaction_system'\n\n        Returns: id\n        \"\"\"\n        cur.execute(\"SELECT seq FROM sqlite_sequence WHERE name='{0}'\"\n                    .format(table))\n        result = cur.fetchone()\n        if result is not None:\n            id = result[0]\n        else:\n            id = 0\n        return id", "code_tokens": "def get_last_id ( self , cur , table = 'reaction' ) : cur . execute ( \"SELECT seq FROM sqlite_sequence WHERE name='{0}'\" . format ( table ) ) result = cur . fetchone ( ) if result is not None : id = result [ 0 ] else : id = 0 return id", "docstring_tokens": "Get the id of the last written row in table", "label": 1}, {"idx": "cosqa-train-8885", "doc": "determine the data type of each column in the data in python", "code": "def _get_column_types(self, data):\n        \"\"\"Get a list of the data types for each column in *data*.\"\"\"\n        columns = list(zip_longest(*data))\n        return [self._get_column_type(column) for column in columns]", "code_tokens": "def _get_column_types ( self , data ) : columns = list ( zip_longest ( * data ) ) return [ self . _get_column_type ( column ) for column in columns ]", "docstring_tokens": "Get a list of the data types for each column in * data * .", "label": 1}, {"idx": "cosqa-train-8886", "doc": "python get linked table location", "code": "def get_table_pos(self, tablename):\n        \"\"\"\n        :param str tablename: Name of table to get position of.\n        :return: Upper left (row, col) coordinate of the named table.\n        \"\"\"\n        _table, (row, col) = self.__tables[tablename]\n        return (row, col)", "code_tokens": "def get_table_pos ( self , tablename ) : _table , ( row , col ) = self . __tables [ tablename ] return ( row , col )", "docstring_tokens": ": param str tablename : Name of table to get position of . : return : Upper left ( row col ) coordinate of the named table .", "label": 0}, {"idx": "cosqa-train-8887", "doc": "determine timezone pytz function python", "code": "def now(timezone=None):\n    \"\"\"\n    Return a naive datetime object for the given ``timezone``. A ``timezone``\n    is any pytz- like or datetime.tzinfo-like timezone object. If no timezone\n    is given, then UTC is assumed.\n\n    This method is best used with pytz installed::\n\n        pip install pytz\n    \"\"\"\n    d = datetime.datetime.utcnow()\n    if not timezone:\n        return d\n\n    return to_timezone(d, timezone).replace(tzinfo=None)", "code_tokens": "def now ( timezone = None ) : d = datetime . datetime . utcnow ( ) if not timezone : return d return to_timezone ( d , timezone ) . replace ( tzinfo = None )", "docstring_tokens": "Return a naive datetime object for the given timezone . A timezone is any pytz - like or datetime . tzinfo - like timezone object . If no timezone is given then UTC is assumed .", "label": 1}, {"idx": "cosqa-train-8888", "doc": "python get lnorm for two vectors", "code": "def l2_norm(arr):\n    \"\"\"\n    The l2 norm of an array is is defined as: sqrt(||x||), where ||x|| is the\n    dot product of the vector.\n    \"\"\"\n    arr = np.asarray(arr)\n    return np.sqrt(np.dot(arr.ravel().squeeze(), arr.ravel().squeeze()))", "code_tokens": "def l2_norm ( arr ) : arr = np . asarray ( arr ) return np . sqrt ( np . dot ( arr . ravel ( ) . squeeze ( ) , arr . ravel ( ) . squeeze ( ) ) )", "docstring_tokens": "The l2 norm of an array is is defined as : sqrt ( ||x|| ) where ||x|| is the dot product of the vector .", "label": 1}, {"idx": "cosqa-train-8889", "doc": "determining pitch of audio python", "code": "def calc_volume(self, sample: np.ndarray):\n        \"\"\"Find the RMS of the audio\"\"\"\n        return sqrt(np.mean(np.square(sample)))", "code_tokens": "def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )", "docstring_tokens": "Find the RMS of the audio", "label": 1}, {"idx": "cosqa-train-8890", "doc": "python get main axis of shape", "code": "def array_size(x, axis):\n  \"\"\"Calculate the size of `x` along `axis` dimensions only.\"\"\"\n  axis_shape = x.shape if axis is None else tuple(x.shape[a] for a in axis)\n  return max(numpy.prod(axis_shape), 1)", "code_tokens": "def array_size ( x , axis ) : axis_shape = x . shape if axis is None else tuple ( x . shape [ a ] for a in axis ) return max ( numpy . prod ( axis_shape ) , 1 )", "docstring_tokens": "Calculate the size of x along axis dimensions only .", "label": 0}, {"idx": "cosqa-train-8891", "doc": "dictionary in python read from text", "code": "def parse_text_to_dict(self, txt):\n        \"\"\" \n        takes a string and parses via NLP, ready for mapping\n        \"\"\"\n        op = {}\n        print('TODO - import NLP, split into verbs / nouns')\n        op['nouns'] = txt\n        op['verbs'] = txt\n        \n        return op", "code_tokens": "def parse_text_to_dict ( self , txt ) : op = { } print ( 'TODO - import NLP, split into verbs / nouns' ) op [ 'nouns' ] = txt op [ 'verbs' ] = txt return op", "docstring_tokens": "takes a string and parses via NLP ready for mapping", "label": 1}, {"idx": "cosqa-train-8892", "doc": "python get maximum and minimum index list", "code": "def get_idx_rect(index_list):\n    \"\"\"Extract the boundaries from a list of indexes\"\"\"\n    rows, cols = list(zip(*[(i.row(), i.column()) for i in index_list]))\n    return ( min(rows), max(rows), min(cols), max(cols) )", "code_tokens": "def get_idx_rect ( index_list ) : rows , cols = list ( zip ( * [ ( i . row ( ) , i . column ( ) ) for i in index_list ] ) ) return ( min ( rows ) , max ( rows ) , min ( cols ) , max ( cols ) )", "docstring_tokens": "Extract the boundaries from a list of indexes", "label": 1}, {"idx": "cosqa-train-8893", "doc": "dimensions of a nested list in python", "code": "def get_list_dimensions(_list):\n    \"\"\"\n    Takes a nested list and returns the size of each dimension followed\n    by the element type in the list\n    \"\"\"\n    if isinstance(_list, list) or isinstance(_list, tuple):\n        return [len(_list)] + get_list_dimensions(_list[0])\n    return []", "code_tokens": "def get_list_dimensions ( _list ) : if isinstance ( _list , list ) or isinstance ( _list , tuple ) : return [ len ( _list ) ] + get_list_dimensions ( _list [ 0 ] ) return [ ]", "docstring_tokens": "Takes a nested list and returns the size of each dimension followed by the element type in the list", "label": 1}, {"idx": "cosqa-train-8894", "doc": "python get name of file on s3", "code": "def download_file_from_bucket(self, bucket, file_path, key):\n        \"\"\" Download file from S3 Bucket \"\"\"\n        with open(file_path, 'wb') as data:\n            self.__s3.download_fileobj(bucket, key, data)\n            return file_path", "code_tokens": "def download_file_from_bucket ( self , bucket , file_path , key ) : with open ( file_path , 'wb' ) as data : self . __s3 . download_fileobj ( bucket , key , data ) return file_path", "docstring_tokens": "Download file from S3 Bucket", "label": 1}, {"idx": "cosqa-train-8895", "doc": "directing python output to log file", "code": "def log_no_newline(self, msg):\n      \"\"\" print the message to the predefined log file without newline \"\"\"\n      self.print2file(self.logfile, False, False, msg)", "code_tokens": "def log_no_newline ( self , msg ) : self . print2file ( self . logfile , False , False , msg )", "docstring_tokens": "print the message to the predefined log file without newline", "label": 1}, {"idx": "cosqa-train-8896", "doc": "python get next month end date", "code": "def get_previous_month(self):\n        \"\"\"Returns date range for the previous full month.\"\"\"\n        end = utils.get_month_start() - relativedelta(days=1)\n        end = utils.to_datetime(end)\n        start = utils.get_month_start(end)\n        return start, end", "code_tokens": "def get_previous_month ( self ) : end = utils . get_month_start ( ) - relativedelta ( days = 1 ) end = utils . to_datetime ( end ) start = utils . get_month_start ( end ) return start , end", "docstring_tokens": "Returns date range for the previous full month .", "label": 0}, {"idx": "cosqa-train-8897", "doc": "disable key repeat in python curses", "code": "def off(self):\n        \"\"\"Turn off curses\"\"\"\n        self.win.keypad(0)\n        curses.nocbreak()\n        curses.echo()\n        try:\n            curses.curs_set(1)\n        except:\n            pass\n        curses.endwin()", "code_tokens": "def off ( self ) : self . win . keypad ( 0 ) curses . nocbreak ( ) curses . echo ( ) try : curses . curs_set ( 1 ) except : pass curses . endwin ( )", "docstring_tokens": "Turn off curses", "label": 0}, {"idx": "cosqa-train-8898", "doc": "python get num days in year", "code": "def gday_of_year(self):\n        \"\"\"Return the number of days since January 1 of the given year.\"\"\"\n        return (self.date - dt.date(self.date.year, 1, 1)).days", "code_tokens": "def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days", "docstring_tokens": "Return the number of days since January 1 of the given year .", "label": 0}, {"idx": "cosqa-train-8899", "doc": "discord how to have a bot send a private message python", "code": "def send_text(self, text):\n        \"\"\"Send a plain text message to the room.\"\"\"\n        return self.client.api.send_message(self.room_id, text)", "code_tokens": "def send_text ( self , text ) : return self . client . api . send_message ( self . room_id , text )", "docstring_tokens": "Send a plain text message to the room .", "label": 0}, {"idx": "cosqa-train-8900", "doc": "python get number of processors", "code": "def _num_cpus_darwin():\n    \"\"\"Return the number of active CPUs on a Darwin system.\"\"\"\n    p = subprocess.Popen(['sysctl','-n','hw.ncpu'],stdout=subprocess.PIPE)\n    return p.stdout.read()", "code_tokens": "def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )", "docstring_tokens": "Return the number of active CPUs on a Darwin system .", "label": 0}, {"idx": "cosqa-train-8901", "doc": "discord python bot user data", "code": "def me(self):\n        \"\"\"Similar to :attr:`.Guild.me` except it may return the :class:`.ClientUser` in private message contexts.\"\"\"\n        return self.guild.me if self.guild is not None else self.bot.user", "code_tokens": "def me ( self ) : return self . guild . me if self . guild is not None else self . bot . user", "docstring_tokens": "Similar to : attr : . Guild . me except it may return the : class : . ClientUser in private message contexts .", "label": 1}, {"idx": "cosqa-train-8902", "doc": "python get object dimension", "code": "def get_shape(self):\n\t\t\"\"\"\n\t\tReturn a tuple of this array's dimensions.  This is done by\n\t\tquerying the Dim children.  Note that once it has been\n\t\tcreated, it is also possible to examine an Array object's\n\t\t.array attribute directly, and doing that is much faster.\n\t\t\"\"\"\n\t\treturn tuple(int(c.pcdata) for c in self.getElementsByTagName(ligolw.Dim.tagName))[::-1]", "code_tokens": "def get_shape ( self ) : return tuple ( int ( c . pcdata ) for c in self . getElementsByTagName ( ligolw . Dim . tagName ) ) [ : : - 1 ]", "docstring_tokens": "Return a tuple of this array s dimensions . This is done by querying the Dim children . Note that once it has been created it is also possible to examine an Array object s . array attribute directly and doing that is much faster .", "label": 0}, {"idx": "cosqa-train-8903", "doc": "discord python join voice channel", "code": "async def join(self, ctx, *, channel: discord.VoiceChannel):\n        \"\"\"Joins a voice channel\"\"\"\n\n        if ctx.voice_client is not None:\n            return await ctx.voice_client.move_to(channel)\n\n        await channel.connect()", "code_tokens": "async def join ( self , ctx , * , channel : discord . VoiceChannel ) : if ctx . voice_client is not None : return await ctx . voice_client . move_to ( channel ) await channel . connect ( )", "docstring_tokens": "Joins a voice channel", "label": 1}, {"idx": "cosqa-train-8904", "doc": "python get object parent", "code": "def _lookup_parent(self, cls):\n        \"\"\"Lookup a transitive parent object that is an instance\n            of a given class.\"\"\"\n        codeobj = self.parent\n        while codeobj is not None and not isinstance(codeobj, cls):\n            codeobj = codeobj.parent\n        return codeobj", "code_tokens": "def _lookup_parent ( self , cls ) : codeobj = self . parent while codeobj is not None and not isinstance ( codeobj , cls ) : codeobj = codeobj . parent return codeobj", "docstring_tokens": "Lookup a transitive parent object that is an instance of a given class .", "label": 1}, {"idx": "cosqa-train-8905", "doc": "display column names of a table using python", "code": "def _columns_for_table(table_name):\n    \"\"\"\n    Return all of the columns registered for a given table.\n\n    Parameters\n    ----------\n    table_name : str\n\n    Returns\n    -------\n    columns : dict of column wrappers\n        Keys will be column names.\n\n    \"\"\"\n    return {cname: col\n            for (tname, cname), col in _COLUMNS.items()\n            if tname == table_name}", "code_tokens": "def _columns_for_table ( table_name ) : return { cname : col for ( tname , cname ) , col in _COLUMNS . items ( ) if tname == table_name }", "docstring_tokens": "Return all of the columns registered for a given table .", "label": 0}, {"idx": "cosqa-train-8906", "doc": "python get output from shell command", "code": "def _run_cmd_get_output(cmd):\n    \"\"\"Runs a shell command, returns console output.\n\n    Mimics python3's subprocess.getoutput\n    \"\"\"\n    process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)\n    out, err = process.communicate()\n    return out or err", "code_tokens": "def _run_cmd_get_output ( cmd ) : process = subprocess . Popen ( cmd . split ( ) , stdout = subprocess . PIPE ) out , err = process . communicate ( ) return out or err", "docstring_tokens": "Runs a shell command returns console output .", "label": 0}, {"idx": "cosqa-train-8907", "doc": "does cos and sin in python use degrees or radians", "code": "def cos_sin_deg(deg):\n    \"\"\"Return the cosine and sin for the given angle\n    in degrees, with special-case handling of multiples\n    of 90 for perfect right angles\n    \"\"\"\n    deg = deg % 360.0\n    if deg == 90.0:\n        return 0.0, 1.0\n    elif deg == 180.0:\n        return -1.0, 0\n    elif deg == 270.0:\n        return 0, -1.0\n    rad = math.radians(deg)\n    return math.cos(rad), math.sin(rad)", "code_tokens": "def cos_sin_deg ( deg ) : deg = deg % 360.0 if deg == 90.0 : return 0.0 , 1.0 elif deg == 180.0 : return - 1.0 , 0 elif deg == 270.0 : return 0 , - 1.0 rad = math . radians ( deg ) return math . cos ( rad ) , math . sin ( rad )", "docstring_tokens": "Return the cosine and sin for the given angle in degrees with special - case handling of multiples of 90 for perfect right angles", "label": 1}, {"idx": "cosqa-train-8908", "doc": "python get output of shell command", "code": "def _run_cmd_get_output(cmd):\n    \"\"\"Runs a shell command, returns console output.\n\n    Mimics python3's subprocess.getoutput\n    \"\"\"\n    process = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE)\n    out, err = process.communicate()\n    return out or err", "code_tokens": "def _run_cmd_get_output ( cmd ) : process = subprocess . Popen ( cmd . split ( ) , stdout = subprocess . PIPE ) out , err = process . communicate ( ) return out or err", "docstring_tokens": "Runs a shell command returns console output .", "label": 0}, {"idx": "cosqa-train-8909", "doc": "does python compile to c++", "code": "def cpp_prog_builder(build_context, target):\n    \"\"\"Build a C++ binary executable\"\"\"\n    yprint(build_context.conf, 'Build CppProg', target)\n    workspace_dir = build_context.get_workspace('CppProg', target.name)\n    build_cpp(build_context, target, target.compiler_config, workspace_dir)", "code_tokens": "def cpp_prog_builder ( build_context , target ) : yprint ( build_context . conf , 'Build CppProg' , target ) workspace_dir = build_context . get_workspace ( 'CppProg' , target . name ) build_cpp ( build_context , target , target . compiler_config , workspace_dir )", "docstring_tokens": "Build a C ++ binary executable", "label": 1}, {"idx": "cosqa-train-8910", "doc": "python get parent directory for file", "code": "def get_parent_folder_name(file_path):\n    \"\"\"Finds parent folder of file\n\n    :param file_path: path\n    :return: Name of folder container\n    \"\"\"\n    return os.path.split(os.path.split(os.path.abspath(file_path))[0])[-1]", "code_tokens": "def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]", "docstring_tokens": "Finds parent folder of file", "label": 1}, {"idx": "cosqa-train-8911", "doc": "does python have function headers like c++", "code": "def method_header(method_name, nogil=False, idx_as_arg=False):\n    \"\"\"Returns the Cython method header for methods without arguments except\n    `self`.\"\"\"\n    if not config.FASTCYTHON:\n        nogil = False\n    header = 'cpdef inline void %s(self' % method_name\n    header += ', int idx)' if idx_as_arg else ')'\n    header += ' nogil:' if nogil else ':'\n    return header", "code_tokens": "def method_header ( method_name , nogil = False , idx_as_arg = False ) : if not config . FASTCYTHON : nogil = False header = 'cpdef inline void %s(self' % method_name header += ', int idx)' if idx_as_arg else ')' header += ' nogil:' if nogil else ':' return header", "docstring_tokens": "Returns the Cython method header for methods without arguments except self .", "label": 1}, {"idx": "cosqa-train-8912", "doc": "python get parent path of one path", "code": "def grandparent_path(self):\n        \"\"\" return grandparent's path string \"\"\"\n        return os.path.basename(os.path.join(self.path, '../..'))", "code_tokens": "def grandparent_path ( self ) : return os . path . basename ( os . path . join ( self . path , '../..' ) )", "docstring_tokens": "return grandparent s path string", "label": 0}, {"idx": "cosqa-train-8913", "doc": "does pythons sorted function sort by alphabetical", "code": "def get_order(self, codes):\n        \"\"\"Return evidence codes in order shown in code2name.\"\"\"\n        return sorted(codes, key=lambda e: [self.ev2idx.get(e)])", "code_tokens": "def get_order ( self , codes ) : return sorted ( codes , key = lambda e : [ self . ev2idx . get ( e ) ] )", "docstring_tokens": "Return evidence codes in order shown in code2name .", "label": 0}, {"idx": "cosqa-train-8914", "doc": "python get path of parent folder", "code": "def grandparent_path(self):\n        \"\"\" return grandparent's path string \"\"\"\n        return os.path.basename(os.path.join(self.path, '../..'))", "code_tokens": "def grandparent_path ( self ) : return os . path . basename ( os . path . join ( self . path , '../..' ) )", "docstring_tokens": "return grandparent s path string", "label": 1}, {"idx": "cosqa-train-8915", "doc": "doing bulk insert into oracle in python", "code": "def bulk_query(self, query, *multiparams):\n        \"\"\"Bulk insert or update.\"\"\"\n\n        with self.get_connection() as conn:\n            conn.bulk_query(query, *multiparams)", "code_tokens": "def bulk_query ( self , query , * multiparams ) : with self . get_connection ( ) as conn : conn . bulk_query ( query , * multiparams )", "docstring_tokens": "Bulk insert or update .", "label": 0}, {"idx": "cosqa-train-8916", "doc": "python get path to file in project", "code": "def read(filename):\n    \"\"\"Read and return `filename` in root dir of project and return string\"\"\"\n    return codecs.open(os.path.join(__DIR__, filename), 'r').read()", "code_tokens": "def read ( filename ) : return codecs . open ( os . path . join ( __DIR__ , filename ) , 'r' ) . read ( )", "docstring_tokens": "Read and return filename in root dir of project and return string", "label": 1}, {"idx": "cosqa-train-8917", "doc": "double the pixels without changing the aspect ratio python", "code": "def match_aspect_to_viewport(self):\n        \"\"\"Updates Camera.aspect to match the viewport's aspect ratio.\"\"\"\n        viewport = self.viewport\n        self.aspect = float(viewport.width) / viewport.height", "code_tokens": "def match_aspect_to_viewport ( self ) : viewport = self . viewport self . aspect = float ( viewport . width ) / viewport . height", "docstring_tokens": "Updates Camera . aspect to match the viewport s aspect ratio .", "label": 0}, {"idx": "cosqa-train-8918", "doc": "python get previous quarter end date", "code": "def previous_quarter(d):\n    \"\"\"\n    Retrieve the previous quarter for dt\n    \"\"\"\n    from django_toolkit.datetime_util import quarter as datetime_quarter\n    return quarter( (datetime_quarter(datetime(d.year, d.month, d.day))[0] + timedelta(days=-1)).date() )", "code_tokens": "def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )", "docstring_tokens": "Retrieve the previous quarter for dt", "label": 1}, {"idx": "cosqa-train-8919", "doc": "draw a cube in python", "code": "def paint_cube(self, x, y):\n        \"\"\"\n        Paints a cube at a certain position a color.\n\n        Parameters\n        ----------\n        x: int\n            Horizontal position of the upper left corner of the cube.\n        y: int\n            Vertical position of the upper left corner of the cube.\n\n        \"\"\"\n        # get the color\n        color = self.next_color()\n        # calculate the position\n        cube_pos = [x, y, x + self.cube_size, y + self.cube_size]\n        # draw the cube\n        draw = ImageDraw.Draw(im=self.image)\n        draw.rectangle(xy=cube_pos, fill=color)", "code_tokens": "def paint_cube ( self , x , y ) : # get the color color = self . next_color ( ) # calculate the position cube_pos = [ x , y , x + self . cube_size , y + self . cube_size ] # draw the cube draw = ImageDraw . Draw ( im = self . image ) draw . rectangle ( xy = cube_pos , fill = color )", "docstring_tokens": "Paints a cube at a certain position a color .", "label": 1}, {"idx": "cosqa-train-8920", "doc": "python get process memory used", "code": "def get_memory_usage():\n    \"\"\"Gets RAM memory usage\n\n    :return: MB of memory used by this process\n    \"\"\"\n    process = psutil.Process(os.getpid())\n    mem = process.memory_info().rss\n    return mem / (1024 * 1024)", "code_tokens": "def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )", "docstring_tokens": "Gets RAM memory usage", "label": 0}, {"idx": "cosqa-train-8921", "doc": "dump a python dict to url query", "code": "def dict_to_querystring(dictionary):\n    \"\"\"Converts a dict to a querystring suitable to be appended to a URL.\"\"\"\n    s = u\"\"\n    for d in dictionary.keys():\n        s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d])\n    return s[:-1]", "code_tokens": "def dict_to_querystring ( dictionary ) : s = u\"\" for d in dictionary . keys ( ) : s = unicode . format ( u\"{0}{1}={2}&\" , s , d , dictionary [ d ] ) return s [ : - 1 ]", "docstring_tokens": "Converts a dict to a querystring suitable to be appended to a URL .", "label": 1}, {"idx": "cosqa-train-8922", "doc": "python get reference to namespace of function defined", "code": "def extract_module_locals(depth=0):\n    \"\"\"Returns (module, locals) of the funciton `depth` frames away from the caller\"\"\"\n    f = sys._getframe(depth + 1)\n    global_ns = f.f_globals\n    module = sys.modules[global_ns['__name__']]\n    return (module, f.f_locals)", "code_tokens": "def extract_module_locals ( depth = 0 ) : f = sys . _getframe ( depth + 1 ) global_ns = f . f_globals module = sys . modules [ global_ns [ '__name__' ] ] return ( module , f . f_locals )", "docstring_tokens": "Returns ( module locals ) of the funciton depth frames away from the caller", "label": 0}, {"idx": "cosqa-train-8923", "doc": "dynamically add a property python using property", "code": "def set_property(self, key, value):\n        \"\"\"\n        Update only one property in the dict\n        \"\"\"\n        self.properties[key] = value\n        self.sync_properties()", "code_tokens": "def set_property ( self , key , value ) : self . properties [ key ] = value self . sync_properties ( )", "docstring_tokens": "Update only one property in the dict", "label": 0}, {"idx": "cosqa-train-8924", "doc": "python get relative path of an absolute path", "code": "def __absolute__(self, uri):\n        \"\"\" Get the absolute uri for a file\n\n        :param uri: URI of the resource to be retrieved\n        :return: Absolute Path\n        \"\"\"\n        return op.abspath(op.join(self.__path__, uri))", "code_tokens": "def __absolute__ ( self , uri ) : return op . abspath ( op . join ( self . __path__ , uri ) )", "docstring_tokens": "Get the absolute uri for a file", "label": 1}, {"idx": "cosqa-train-8925", "doc": "dynamically update value in dictionary python", "code": "def update(self, params):\n        \"\"\"Update the dev_info data from a dictionary.\n\n        Only updates if it already exists in the device.\n        \"\"\"\n        dev_info = self.json_state.get('deviceInfo')\n        dev_info.update({k: params[k] for k in params if dev_info.get(k)})", "code_tokens": "def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )", "docstring_tokens": "Update the dev_info data from a dictionary .", "label": 1}, {"idx": "cosqa-train-8926", "doc": "python get rid of handles on legend", "code": "def remove_legend(ax=None):\n    \"\"\"Remove legend for axes or gca.\n\n    See http://osdir.com/ml/python.matplotlib.general/2005-07/msg00285.html\n    \"\"\"\n    from pylab import gca, draw\n    if ax is None:\n        ax = gca()\n    ax.legend_ = None\n    draw()", "code_tokens": "def remove_legend ( ax = None ) : from pylab import gca , draw if ax is None : ax = gca ( ) ax . legend_ = None draw ( )", "docstring_tokens": "Remove legend for axes or gca .", "label": 1}, {"idx": "cosqa-train-8927", "doc": "easiest way to access corpus in python", "code": "def read_corpus(file_name):\n    \"\"\"\n    Read and return the data from a corpus json file.\n    \"\"\"\n    with io.open(file_name, encoding='utf-8') as data_file:\n        return yaml.load(data_file)", "code_tokens": "def read_corpus ( file_name ) : with io . open ( file_name , encoding = 'utf-8' ) as data_file : return yaml . load ( data_file )", "docstring_tokens": "Read and return the data from a corpus json file .", "label": 1}, {"idx": "cosqa-train-8928", "doc": "python get rid of line feed", "code": "def _delete_whitespace(self):\n        \"\"\"Delete all whitespace from the end of the line.\"\"\"\n        while isinstance(self._lines[-1], (self._Space, self._LineBreak,\n                                           self._Indent)):\n            del self._lines[-1]", "code_tokens": "def _delete_whitespace ( self ) : while isinstance ( self . _lines [ - 1 ] , ( self . _Space , self . _LineBreak , self . _Indent ) ) : del self . _lines [ - 1 ]", "docstring_tokens": "Delete all whitespace from the end of the line .", "label": 1}, {"idx": "cosqa-train-8929", "doc": "easy python decompiler invalid pyc file", "code": "def disassemble_file(filename, outstream=None):\n    \"\"\"\n    disassemble Python byte-code file (.pyc)\n\n    If given a Python source file (\".py\") file, we'll\n    try to find the corresponding compiled object.\n    \"\"\"\n    filename = check_object_path(filename)\n    (version, timestamp, magic_int, co, is_pypy,\n     source_size) = load_module(filename)\n    if type(co) == list:\n        for con in co:\n            disco(version, con, outstream)\n    else:\n        disco(version, co, outstream, is_pypy=is_pypy)\n    co = None", "code_tokens": "def disassemble_file ( filename , outstream = None ) : filename = check_object_path ( filename ) ( version , timestamp , magic_int , co , is_pypy , source_size ) = load_module ( filename ) if type ( co ) == list : for con in co : disco ( version , con , outstream ) else : disco ( version , co , outstream , is_pypy = is_pypy ) co = None", "docstring_tokens": "disassemble Python byte - code file ( . pyc )", "label": 1}, {"idx": "cosqa-train-8930", "doc": "python get the indices of an array that equals a pecific value", "code": "def percentile_index(a, q):\n    \"\"\"\n    Returns the index of the value at the Qth percentile in array a.\n    \"\"\"\n    return np.where(\n        a==np.percentile(a, q, interpolation='nearest')\n    )[0][0]", "code_tokens": "def percentile_index ( a , q ) : return np . where ( a == np . percentile ( a , q , interpolation = 'nearest' ) ) [ 0 ] [ 0 ]", "docstring_tokens": "Returns the index of the value at the Qth percentile in array a .", "label": 0}, {"idx": "cosqa-train-8931", "doc": "elasticsearch get mapping python", "code": "def find_mapping(es_url, index):\n    \"\"\" Find the mapping given an index \"\"\"\n\n    mapping = None\n\n    backend = find_perceval_backend(es_url, index)\n\n    if backend:\n        mapping = backend.get_elastic_mappings()\n\n    if mapping:\n        logging.debug(\"MAPPING FOUND:\\n%s\", json.dumps(json.loads(mapping['items']), indent=True))\n    return mapping", "code_tokens": "def find_mapping ( es_url , index ) : mapping = None backend = find_perceval_backend ( es_url , index ) if backend : mapping = backend . get_elastic_mappings ( ) if mapping : logging . debug ( \"MAPPING FOUND:\\n%s\" , json . dumps ( json . loads ( mapping [ 'items' ] ) , indent = True ) ) return mapping", "docstring_tokens": "Find the mapping given an index", "label": 1}, {"idx": "cosqa-train-8932", "doc": "python get value by key default otherwise", "code": "def get_value(key, obj, default=missing):\n    \"\"\"Helper for pulling a keyed value off various types of objects\"\"\"\n    if isinstance(key, int):\n        return _get_value_for_key(key, obj, default)\n    return _get_value_for_keys(key.split('.'), obj, default)", "code_tokens": "def get_value ( key , obj , default = missing ) : if isinstance ( key , int ) : return _get_value_for_key ( key , obj , default ) return _get_value_for_keys ( key . split ( '.' ) , obj , default )", "docstring_tokens": "Helper for pulling a keyed value off various types of objects", "label": 0}, {"idx": "cosqa-train-8933", "doc": "elasticsearch python return all index name", "code": "def get_model_index_properties(instance, index):\n    \"\"\"Return the list of properties specified for a model in an index.\"\"\"\n    mapping = get_index_mapping(index)\n    doc_type = instance._meta.model_name.lower()\n    return list(mapping[\"mappings\"][doc_type][\"properties\"].keys())", "code_tokens": "def get_model_index_properties ( instance , index ) : mapping = get_index_mapping ( index ) doc_type = instance . _meta . model_name . lower ( ) return list ( mapping [ \"mappings\" ] [ doc_type ] [ \"properties\" ] . keys ( ) )", "docstring_tokens": "Return the list of properties specified for a model in an index .", "label": 1}, {"idx": "cosqa-train-8934", "doc": "python get value from property name", "code": "def get_property_by_name(pif, name):\n    \"\"\"Get a property by name\"\"\"\n    return next((x for x in pif.properties if x.name == name), None)", "code_tokens": "def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )", "docstring_tokens": "Get a property by name", "label": 0}, {"idx": "cosqa-train-8935", "doc": "elasticsearch scroll api python", "code": "def scan(client, query=None, scroll='5m', raise_on_error=True,\n         preserve_order=False, size=1000, **kwargs):\n    \"\"\"\n    Simple abstraction on top of the\n    :meth:`~elasticsearch.Elasticsearch.scroll` api - a simple iterator that\n    yields all hits as returned by underlining scroll requests.\n    By default scan does not return results in any pre-determined order. To\n    have a standard order in the returned documents (either by score or\n    explicit sort definition) when scrolling, use ``preserve_order=True``. This\n    may be an expensive operation and will negate the performance benefits of\n    using ``scan``.\n    :arg client: instance of :class:`~elasticsearch.Elasticsearch` to use\n    :arg query: body for the :meth:`~elasticsearch.Elasticsearch.search` api\n    :arg scroll: Specify how long a consistent view of the index should be\n        maintained for scrolled search\n    :arg raise_on_error: raises an exception (``ScanError``) if an error is\n        encountered (some shards fail to execute). By default we raise.\n    :arg preserve_order: don't set the ``search_type`` to ``scan`` - this will\n        cause the scroll to paginate with preserving the order. Note that this\n        can be an extremely expensive operation and can easily lead to\n        unpredictable results, use with caution.\n    :arg size: size (per shard) of the batch send at each iteration.\n    Any additional keyword arguments will be passed to the initial\n    :meth:`~elasticsearch.Elasticsearch.search` call::\n        scan(es,\n            query={\"query\": {\"match\": {\"title\": \"python\"}}},\n            index=\"orders-*\",\n            doc_type=\"books\"\n        )\n    \"\"\"\n    if not preserve_order:\n        kwargs['search_type'] = 'scan'\n    # initial search\n    resp = client.search(body=query, scroll=scroll, size=size, **kwargs)\n\n    scroll_id = resp.get('_scroll_id')\n    if scroll_id is None:\n        return\n\n    first_run = True\n    while True:\n        # if we didn't set search_type to scan initial search contains data\n        if preserve_order and first_run:\n            first_run = False\n        else:\n            resp = client.scroll(scroll_id, scroll=scroll)\n\n        for hit in resp['hits']['hits']:\n            yield hit\n\n        # check if we have any errrors\n        if resp[\"_shards\"][\"failed\"]:\n            logger.warning(\n                'Scroll request has failed on %d shards out of %d.',\n                resp['_shards']['failed'], resp['_shards']['total']\n            )\n            if raise_on_error:\n                raise ScanError(\n                    'Scroll request has failed on %d shards out of %d.' %\n                    (resp['_shards']['failed'], resp['_shards']['total'])\n                )\n\n        scroll_id = resp.get('_scroll_id')\n        # end of scroll\n        if scroll_id is None or not resp['hits']['hits']:\n            break", "code_tokens": "def scan ( client , query = None , scroll = '5m' , raise_on_error = True , preserve_order = False , size = 1000 , * * kwargs ) : if not preserve_order : kwargs [ 'search_type' ] = 'scan' # initial search resp = client . search ( body = query , scroll = scroll , size = size , * * kwargs ) scroll_id = resp . get ( '_scroll_id' ) if scroll_id is None : return first_run = True while True : # if we didn't set search_type to scan initial search contains data if preserve_order and first_run : first_run = False else : resp = client . scroll ( scroll_id , scroll = scroll ) for hit in resp [ 'hits' ] [ 'hits' ] : yield hit # check if we have any errrors if resp [ \"_shards\" ] [ \"failed\" ] : logger . warning ( 'Scroll request has failed on %d shards out of %d.' , resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) if raise_on_error : raise ScanError ( 'Scroll request has failed on %d shards out of %d.' % ( resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) ) scroll_id = resp . get ( '_scroll_id' ) # end of scroll if scroll_id is None or not resp [ 'hits' ] [ 'hits' ] : break", "docstring_tokens": "Simple abstraction on top of the : meth : ~elasticsearch . Elasticsearch . scroll api - a simple iterator that yields all hits as returned by underlining scroll requests . By default scan does not return results in any pre - determined order . To have a standard order in the returned documents ( either by score or explicit sort definition ) when scrolling use preserve_order = True . This may be an expensive operation and will negate the performance benefits of using scan . : arg client : instance of : class : ~elasticsearch . Elasticsearch to use : arg query : body for the : meth : ~elasticsearch . Elasticsearch . search api : arg scroll : Specify how long a consistent view of the index should be maintained for scrolled search : arg raise_on_error : raises an exception ( ScanError ) if an error is encountered ( some shards fail to execute ) . By default we raise . : arg preserve_order : don t set the search_type to scan - this will cause the scroll to paginate with preserving the order . Note that this can be an extremely expensive operation and can easily lead to unpredictable results use with caution . : arg size : size ( per shard ) of the batch send at each iteration . Any additional keyword arguments will be passed to the initial : meth : ~elasticsearch . Elasticsearch . search call :: scan ( es query = { query : { match : { title : python }}} index = orders - * doc_type = books )", "label": 1}, {"idx": "cosqa-train-8936", "doc": "python get variable by its name", "code": "def get_var(self, name):\n        \"\"\" Returns the variable set with the given name.\n        \"\"\"\n        for var in self.vars:\n            if var.name == name:\n                return var\n        else:\n            raise ValueError", "code_tokens": "def get_var ( self , name ) : for var in self . vars : if var . name == name : return var else : raise ValueError", "docstring_tokens": "Returns the variable set with the given name .", "label": 1}, {"idx": "cosqa-train-8937", "doc": "enable logging for python stdout", "code": "def disable_stdout_buffering():\n    \"\"\"This turns off stdout buffering so that outputs are immediately\n    materialized and log messages show up before the program exits\"\"\"\n    stdout_orig = sys.stdout\n    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)\n    # NOTE(brandyn): This removes the original stdout\n    return stdout_orig", "code_tokens": "def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig", "docstring_tokens": "This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits", "label": 1}, {"idx": "cosqa-train-8938", "doc": "python get variable dynamically from string", "code": "def _get_var_from_string(item):\n    \"\"\" Get resource variable. \"\"\"\n    modname, varname = _split_mod_var_names(item)\n    if modname:\n        mod = __import__(modname, globals(), locals(), [varname], -1)\n        return getattr(mod, varname)\n    else:\n        return globals()[varname]", "code_tokens": "def _get_var_from_string ( item ) : modname , varname = _split_mod_var_names ( item ) if modname : mod = __import__ ( modname , globals ( ) , locals ( ) , [ varname ] , - 1 ) return getattr ( mod , varname ) else : return globals ( ) [ varname ]", "docstring_tokens": "Get resource variable .", "label": 0}, {"idx": "cosqa-train-8939", "doc": "enlarge the bounding box python", "code": "def adjust_bounding_box(bbox):\n    \"\"\"Adjust the bounding box as specified by user.\n    Returns the adjusted bounding box.\n\n    - bbox: Bounding box computed from the canvas drawings.\n    It must be a four-tuple of numbers.\n    \"\"\"\n    for i in range(0, 4):\n        if i in bounding_box:\n            bbox[i] = bounding_box[i]\n        else:\n            bbox[i] += delta_bounding_box[i]\n    return bbox", "code_tokens": "def adjust_bounding_box ( bbox ) : for i in range ( 0 , 4 ) : if i in bounding_box : bbox [ i ] = bounding_box [ i ] else : bbox [ i ] += delta_bounding_box [ i ] return bbox", "docstring_tokens": "Adjust the bounding box as specified by user . Returns the adjusted bounding box .", "label": 0}, {"idx": "cosqa-train-8940", "doc": "python get variance of a series", "code": "def var(series):\n    \"\"\"\n    Returns the variance of values in a series.\n\n    Args:\n        series (pandas.Series): column to summarize.\n    \"\"\"\n    if np.issubdtype(series.dtype, np.number):\n        return series.var()\n    else:\n        return np.nan", "code_tokens": "def var ( series ) : if np . issubdtype ( series . dtype , np . number ) : return series . var ( ) else : return np . nan", "docstring_tokens": "Returns the variance of values in a series .", "label": 1}, {"idx": "cosqa-train-8941", "doc": "equivalent of timespan in python", "code": "def timespan(start_time):\n    \"\"\"Return time in milliseconds from start_time\"\"\"\n\n    timespan = datetime.datetime.now() - start_time\n    timespan_ms = timespan.total_seconds() * 1000\n    return timespan_ms", "code_tokens": "def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms", "docstring_tokens": "Return time in milliseconds from start_time", "label": 0}, {"idx": "cosqa-train-8942", "doc": "python get windows network userid", "code": "def get_nt_system_uid():\n    \"\"\"Get the MachineGuid from\n    HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Cryptography\\MachineGuid\n    \"\"\"\n    try:\n        import _winreg as winreg\n    except ImportError:\n        import winreg\n    lm = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n    try:\n        key = winreg.OpenKey(lm, r\"Software\\Microsoft\\Cryptography\")\n        try:\n            return winreg.QueryValueEx(key, \"MachineGuid\")[0]\n        finally:\n            key.Close()\n    finally:\n        lm.Close()", "code_tokens": "def get_nt_system_uid ( ) : try : import _winreg as winreg except ImportError : import winreg lm = winreg . ConnectRegistry ( None , winreg . HKEY_LOCAL_MACHINE ) try : key = winreg . OpenKey ( lm , r\"Software\\Microsoft\\Cryptography\" ) try : return winreg . QueryValueEx ( key , \"MachineGuid\" ) [ 0 ] finally : key . Close ( ) finally : lm . Close ( )", "docstring_tokens": "Get the MachineGuid from HKEY_LOCAL_MACHINE \\ Software \\ Microsoft \\ Cryptography \\ MachineGuid", "label": 1}, {"idx": "cosqa-train-8943", "doc": "escape % in string python", "code": "def quote(s, unsafe='/'):\n    \"\"\"Pass in a dictionary that has unsafe characters as the keys, and the percent\n    encoded value as the value.\"\"\"\n    res = s.replace('%', '%25')\n    for c in unsafe:\n        res = res.replace(c, '%' + (hex(ord(c)).upper())[2:])\n    return res", "code_tokens": "def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res", "docstring_tokens": "Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value .", "label": 1}, {"idx": "cosqa-train-8944", "doc": "python gevent is not defined", "code": "def _gevent_patch():\n    \"\"\"Patch the modules with gevent\n\n    :return: Default is GEVENT. If it not supports gevent then return MULTITHREAD\n    :rtype: int\n    \"\"\"\n    try:\n        assert gevent\n        assert grequests\n    except NameError:\n        logger.warn('gevent not exist, fallback to multiprocess...')\n        return MULTITHREAD\n    else:\n        monkey.patch_all()  # Must patch before get_photos_info\n        return GEVENT", "code_tokens": "def _gevent_patch ( ) : try : assert gevent assert grequests except NameError : logger . warn ( 'gevent not exist, fallback to multiprocess...' ) return MULTITHREAD else : monkey . patch_all ( ) # Must patch before get_photos_info return GEVENT", "docstring_tokens": "Patch the modules with gevent", "label": 1}, {"idx": "cosqa-train-8945", "doc": "evaluate a user entered expression in python", "code": "def get_value(self, context):\n        \"\"\"Run python eval on the input string.\"\"\"\n        if self.value:\n            return expressions.eval_string(self.value, context)\n        else:\n            # Empty input raises cryptic EOF syntax err, this more human\n            # friendly\n            raise ValueError('!py string expression is empty. It must be a '\n                             'valid python expression instead.')", "code_tokens": "def get_value ( self , context ) : if self . value : return expressions . eval_string ( self . value , context ) else : # Empty input raises cryptic EOF syntax err, this more human # friendly raise ValueError ( '!py string expression is empty. It must be a ' 'valid python expression instead.' )", "docstring_tokens": "Run python eval on the input string .", "label": 1}, {"idx": "cosqa-train-8946", "doc": "python gevent shared param", "code": "def _spawn(self, func, *args, **kwargs):\n        \"\"\"Spawn a handler function.\n\n        Spawns the supplied ``func`` with ``*args`` and ``**kwargs``\n        as a gevent greenlet.\n\n        :param func: A callable to call.\n        :param args: Arguments to ``func``.\n        :param kwargs: Keyword arguments to ``func``.\n        \"\"\"\n        gevent.spawn(func, *args, **kwargs)", "code_tokens": "def _spawn ( self , func , * args , * * kwargs ) : gevent . spawn ( func , * args , * * kwargs )", "docstring_tokens": "Spawn a handler function .", "label": 0}, {"idx": "cosqa-train-8947", "doc": "example python bokeh customjs", "code": "def get_code_language(self):\n        \"\"\"\n        This is largely copied from bokeh.sphinxext.bokeh_plot.run\n        \"\"\"\n        js_source = self.get_js_source()\n        if self.options.get(\"include_html\", False):\n            resources = get_sphinx_resources(include_bokehjs_api=True)\n            html_source = BJS_HTML.render(\n                css_files=resources.css_files,\n                js_files=resources.js_files,\n                bjs_script=js_source)\n            return [html_source, \"html\"]\n        else:\n            return [js_source, \"javascript\"]", "code_tokens": "def get_code_language ( self ) : js_source = self . get_js_source ( ) if self . options . get ( \"include_html\" , False ) : resources = get_sphinx_resources ( include_bokehjs_api = True ) html_source = BJS_HTML . render ( css_files = resources . css_files , js_files = resources . js_files , bjs_script = js_source ) return [ html_source , \"html\" ] else : return [ js_source , \"javascript\" ]", "docstring_tokens": "This is largely copied from bokeh . sphinxext . bokeh_plot . run", "label": 1}, {"idx": "cosqa-train-8948", "doc": "python glx transparent window", "code": "def set(self):\n        \"\"\"Set the color as current OpenGL color\n        \"\"\"\n        glColor4f(self.r, self.g, self.b, self.a)", "code_tokens": "def set ( self ) : glColor4f ( self . r , self . g , self . b , self . a )", "docstring_tokens": "Set the color as current OpenGL color", "label": 0}, {"idx": "cosqa-train-8949", "doc": "extract numbers from tuple python", "code": "def version_triple(tag):\n    \"\"\"\n    returns: a triple of integers from a version tag\n    \"\"\"\n    groups = re.match(r'v?(\\d+)\\.(\\d+)\\.(\\d+)', tag).groups()\n    return tuple(int(n) for n in groups)", "code_tokens": "def version_triple ( tag ) : groups = re . match ( r'v?(\\d+)\\.(\\d+)\\.(\\d+)' , tag ) . groups ( ) return tuple ( int ( n ) for n in groups )", "docstring_tokens": "returns : a triple of integers from a version tag", "label": 1}, {"idx": "cosqa-train-8950", "doc": "python gnereating a md5 checksum for a file", "code": "def get_file_md5sum(path):\n    \"\"\"Calculate the MD5 hash for a file.\"\"\"\n    with open(path, 'rb') as fh:\n        h = str(hashlib.md5(fh.read()).hexdigest())\n    return h", "code_tokens": "def get_file_md5sum ( path ) : with open ( path , 'rb' ) as fh : h = str ( hashlib . md5 ( fh . read ( ) ) . hexdigest ( ) ) return h", "docstring_tokens": "Calculate the MD5 hash for a file .", "label": 1}, {"idx": "cosqa-train-8951", "doc": "extract only letters only words in python", "code": "def strip_accents(text):\n    \"\"\"\n    Strip agents from a string.\n    \"\"\"\n\n    normalized_str = unicodedata.normalize('NFD', text)\n\n    return ''.join([\n        c for c in normalized_str if unicodedata.category(c) != 'Mn'])", "code_tokens": "def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "docstring_tokens": "Strip agents from a string .", "label": 0}, {"idx": "cosqa-train-8952", "doc": "python go to end of line python", "code": "def erase_lines(n=1):\n    \"\"\" Erases n lines from the screen and moves the cursor up to follow\n    \"\"\"\n    for _ in range(n):\n        print(codes.cursor[\"up\"], end=\"\")\n        print(codes.cursor[\"eol\"], end=\"\")", "code_tokens": "def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ \"up\" ] , end = \"\" ) print ( codes . cursor [ \"eol\" ] , end = \"\" )", "docstring_tokens": "Erases n lines from the screen and moves the cursor up to follow", "label": 1}, {"idx": "cosqa-train-8953", "doc": "extract words from documents python", "code": "def contains_extractor(document):\n    \"\"\"A basic document feature extractor that returns a dict of words that the\n    document contains.\"\"\"\n    tokens = _get_document_tokens(document)\n    features = dict((u'contains({0})'.format(w), True) for w in tokens)\n    return features", "code_tokens": "def contains_extractor ( document ) : tokens = _get_document_tokens ( document ) features = dict ( ( u'contains({0})' . format ( w ) , True ) for w in tokens ) return features", "docstring_tokens": "A basic document feature extractor that returns a dict of words that the document contains .", "label": 1}, {"idx": "cosqa-train-8954", "doc": "python go to next page", "code": "def accel_next(self, *args):\n        \"\"\"Callback to go to the next tab. Called by the accel key.\n        \"\"\"\n        if self.get_notebook().get_current_page() + 1 == self.get_notebook().get_n_pages():\n            self.get_notebook().set_current_page(0)\n        else:\n            self.get_notebook().next_page()\n        return True", "code_tokens": "def accel_next ( self , * args ) : if self . get_notebook ( ) . get_current_page ( ) + 1 == self . get_notebook ( ) . get_n_pages ( ) : self . get_notebook ( ) . set_current_page ( 0 ) else : self . get_notebook ( ) . next_page ( ) return True", "docstring_tokens": "Callback to go to the next tab . Called by the accel key .", "label": 1}, {"idx": "cosqa-train-8955", "doc": "fastest way to make a list python", "code": "def _listify(collection):\n        \"\"\"This is a workaround where Collections are no longer iterable\n        when using JPype.\"\"\"\n        new_list = []\n        for index in range(len(collection)):\n            new_list.append(collection[index])\n        return new_list", "code_tokens": "def _listify ( collection ) : new_list = [ ] for index in range ( len ( collection ) ) : new_list . append ( collection [ index ] ) return new_list", "docstring_tokens": "This is a workaround where Collections are no longer iterable when using JPype .", "label": 1}, {"idx": "cosqa-train-8956", "doc": "python goodness of fit plot", "code": "def plot(self):\n        \"\"\"Plot the empirical histogram versus best-fit distribution's PDF.\"\"\"\n        plt.plot(self.bin_edges, self.hist, self.bin_edges, self.best_pdf)", "code_tokens": "def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )", "docstring_tokens": "Plot the empirical histogram versus best - fit distribution s PDF .", "label": 1}, {"idx": "cosqa-train-8957", "doc": "fetch a single column from an ndarray python\\", "code": "def get_column(self, X, column):\n        \"\"\"Return a column of the given matrix.\n\n        Args:\n            X: `numpy.ndarray` or `pandas.DataFrame`.\n            column: `int` or `str`.\n\n        Returns:\n            np.ndarray: Selected column.\n        \"\"\"\n        if isinstance(X, pd.DataFrame):\n            return X[column].values\n\n        return X[:, column]", "code_tokens": "def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]", "docstring_tokens": "Return a column of the given matrix .", "label": 1}, {"idx": "cosqa-train-8958", "doc": "python grab image from url", "code": "def url_to_image(url):\n    \"\"\"\n    Fetch an image from url and convert it into a Pillow Image object\n    \"\"\"\n    r = requests.get(url)\n    image = StringIO(r.content)\n    return image", "code_tokens": "def url_to_image ( url ) : r = requests . get ( url ) image = StringIO ( r . content ) return image", "docstring_tokens": "Fetch an image from url and convert it into a Pillow Image object", "label": 1}, {"idx": "cosqa-train-8959", "doc": "file pattern matching in python", "code": "def file_matches(filename, patterns):\n    \"\"\"Does this filename match any of the patterns?\"\"\"\n    return any(fnmatch.fnmatch(filename, pat) for pat in patterns)", "code_tokens": "def file_matches ( filename , patterns ) : return any ( fnmatch . fnmatch ( filename , pat ) for pat in patterns )", "docstring_tokens": "Does this filename match any of the patterns?", "label": 1}, {"idx": "cosqa-train-8960", "doc": "python grabbing a file from the internet", "code": "def wget(url):\n    \"\"\"\n    Download the page into a string\n    \"\"\"\n    import urllib.parse\n    request = urllib.request.urlopen(url)\n    filestring = request.read()\n    return filestring", "code_tokens": "def wget ( url ) : import urllib . parse request = urllib . request . urlopen ( url ) filestring = request . read ( ) return filestring", "docstring_tokens": "Download the page into a string", "label": 1}, {"idx": "cosqa-train-8961", "doc": "fill a column with null in python", "code": "def fill_nulls(self, col: str):\n        \"\"\"\n        Fill all null values with NaN values in a column.\n        Null values are ``None`` or en empty string\n\n        :param col: column name\n        :type col: str\n\n        :example: ``ds.fill_nulls(\"mycol\")``\n        \"\"\"\n        n = [None, \"\"]\n        try:\n            self.df[col] = self.df[col].replace(n, nan)\n        except Exception as e:\n            self.err(e)", "code_tokens": "def fill_nulls ( self , col : str ) : n = [ None , \"\" ] try : self . df [ col ] = self . df [ col ] . replace ( n , nan ) except Exception as e : self . err ( e )", "docstring_tokens": "Fill all null values with NaN values in a column . Null values are None or en empty string", "label": 1}, {"idx": "cosqa-train-8962", "doc": "python group by multiple keys itertools", "code": "def group_by(iterable, key_func):\n    \"\"\"Wrap itertools.groupby to make life easier.\"\"\"\n    groups = (\n        list(sub) for key, sub in groupby(iterable, key_func)\n    )\n    return zip(groups, groups)", "code_tokens": "def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "docstring_tokens": "Wrap itertools . groupby to make life easier .", "label": 1}, {"idx": "cosqa-train-8963", "doc": "filling out a pdf with python", "code": "def append_pdf(input_pdf: bytes, output_writer: PdfFileWriter):\n    \"\"\"\n    Appends a PDF to a pyPDF writer. Legacy interface.\n    \"\"\"\n    append_memory_pdf_to_writer(input_pdf=input_pdf,\n                                writer=output_writer)", "code_tokens": "def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )", "docstring_tokens": "Appends a PDF to a pyPDF writer . Legacy interface .", "label": 1}, {"idx": "cosqa-train-8964", "doc": "python gui change title window", "code": "def title(msg):\n    \"\"\"Sets the title of the console window.\"\"\"\n    if sys.platform.startswith(\"win\"):\n        ctypes.windll.kernel32.SetConsoleTitleW(tounicode(msg))", "code_tokens": "def title ( msg ) : if sys . platform . startswith ( \"win\" ) : ctypes . windll . kernel32 . SetConsoleTitleW ( tounicode ( msg ) )", "docstring_tokens": "Sets the title of the console window .", "label": 1}, {"idx": "cosqa-train-8965", "doc": "fillna python specific columns", "code": "def _maybe_fill(arr, fill_value=np.nan):\n    \"\"\"\n    if we have a compatible fill_value and arr dtype, then fill\n    \"\"\"\n    if _isna_compat(arr, fill_value):\n        arr.fill(fill_value)\n    return arr", "code_tokens": "def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr", "docstring_tokens": "if we have a compatible fill_value and arr dtype then fill", "label": 1}, {"idx": "cosqa-train-8966", "doc": "python hamming distance script", "code": "def hamming(s, t):\n    \"\"\"\n    Calculate the Hamming distance between two strings. From Wikipedia article: Iterative with two matrix rows.\n\n    :param s: string 1\n    :type s: str\n    :param t: string 2\n    :type s: str\n    :return: Hamming distance\n    :rtype: float\n    \"\"\"\n    if len(s) != len(t):\n        raise ValueError('Hamming distance needs strings of equal length.')\n    return sum(s_ != t_ for s_, t_ in zip(s, t))", "code_tokens": "def hamming ( s , t ) : if len ( s ) != len ( t ) : raise ValueError ( 'Hamming distance needs strings of equal length.' ) return sum ( s_ != t_ for s_ , t_ in zip ( s , t ) )", "docstring_tokens": "Calculate the Hamming distance between two strings . From Wikipedia article : Iterative with two matrix rows .", "label": 1}, {"idx": "cosqa-train-8967", "doc": "filter list with none python", "code": "def filter_none(list_of_points):\n    \"\"\"\n    \n    :param list_of_points: \n    :return: list_of_points with None's removed\n    \"\"\"\n    remove_elementnone = filter(lambda p: p is not None, list_of_points)\n    remove_sublistnone = filter(lambda p: not contains_none(p), remove_elementnone)\n    return list(remove_sublistnone)", "code_tokens": "def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "docstring_tokens": ": param list_of_points : : return : list_of_points with None s removed", "label": 0}, {"idx": "cosqa-train-8968", "doc": "python hash function crash", "code": "def double_sha256(data):\n    \"\"\"A standard compound hash.\"\"\"\n    return bytes_as_revhex(hashlib.sha256(hashlib.sha256(data).digest()).digest())", "code_tokens": "def double_sha256 ( data ) : return bytes_as_revhex ( hashlib . sha256 ( hashlib . sha256 ( data ) . digest ( ) ) . digest ( ) )", "docstring_tokens": "A standard compound hash .", "label": 1}, {"idx": "cosqa-train-8969", "doc": "finding file extensions in python", "code": "def get_abi3_suffix():\n    \"\"\"Return the file extension for an abi3-compliant Extension()\"\"\"\n    for suffix, _, _ in (s for s in imp.get_suffixes() if s[2] == imp.C_EXTENSION):\n        if '.abi3' in suffix:  # Unix\n            return suffix\n        elif suffix == '.pyd':  # Windows\n            return suffix", "code_tokens": "def get_abi3_suffix ( ) : for suffix , _ , _ in ( s for s in imp . get_suffixes ( ) if s [ 2 ] == imp . C_EXTENSION ) : if '.abi3' in suffix : # Unix return suffix elif suffix == '.pyd' : # Windows return suffix", "docstring_tokens": "Return the file extension for an abi3 - compliant Extension ()", "label": 0}, {"idx": "cosqa-train-8970", "doc": "python hash function for numpy array", "code": "def np_hash(a):\n    \"\"\"Return a hash of a NumPy array.\"\"\"\n    if a is None:\n        return hash(None)\n    # Ensure that hashes are equal whatever the ordering in memory (C or\n    # Fortran)\n    a = np.ascontiguousarray(a)\n    # Compute the digest and return a decimal int\n    return int(hashlib.sha1(a.view(a.dtype)).hexdigest(), 16)", "code_tokens": "def np_hash ( a ) : if a is None : return hash ( None ) # Ensure that hashes are equal whatever the ordering in memory (C or # Fortran) a = np . ascontiguousarray ( a ) # Compute the digest and return a decimal int return int ( hashlib . sha1 ( a . view ( a . dtype ) ) . hexdigest ( ) , 16 )", "docstring_tokens": "Return a hash of a NumPy array .", "label": 1}, {"idx": "cosqa-train-8971", "doc": "finding shape of an array python", "code": "def out_shape_from_array(arr):\n    \"\"\"Get the output shape from an array.\"\"\"\n    arr = np.asarray(arr)\n    if arr.ndim == 1:\n        return arr.shape\n    else:\n        return (arr.shape[1],)", "code_tokens": "def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "docstring_tokens": "Get the output shape from an array .", "label": 0}, {"idx": "cosqa-train-8972", "doc": "finding the max value in an array python", "code": "def findMax(arr):\n    \"\"\"\n    in comparison to argrelmax() more simple and  reliable peak finder\n    \"\"\"\n    out = np.zeros(shape=arr.shape, dtype=bool)\n    _calcMax(arr, out)\n    return out", "code_tokens": "def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out", "docstring_tokens": "in comparison to argrelmax () more simple and reliable peak finder", "label": 1}, {"idx": "cosqa-train-8973", "doc": "python how check int or float", "code": "def is_float(value):\n    \"\"\"must be a float\"\"\"\n    return isinstance(value, float) or isinstance(value, int) or isinstance(value, np.float64), float(value)", "code_tokens": "def is_float ( value ) : return isinstance ( value , float ) or isinstance ( value , int ) or isinstance ( value , np . float64 ) , float ( value )", "docstring_tokens": "must be a float", "label": 1}, {"idx": "cosqa-train-8974", "doc": "finding the median in python 3", "code": "def median_high(data):\n    \"\"\"Return the high median of data.\n\n    When the number of data points is odd, the middle value is returned.\n    When it is even, the larger of the two middle values is returned.\n\n    \"\"\"\n    data = sorted(data)\n    n = len(data)\n    if n == 0:\n        raise StatisticsError(\"no median for empty data\")\n    return data[n // 2]", "code_tokens": "def median_high ( data ) : data = sorted ( data ) n = len ( data ) if n == 0 : raise StatisticsError ( \"no median for empty data\" ) return data [ n // 2 ]", "docstring_tokens": "Return the high median of data .", "label": 1}, {"idx": "cosqa-train-8975", "doc": "python how read contents from clipboard", "code": "def osx_clipboard_get():\n    \"\"\" Get the clipboard's text on OS X.\n    \"\"\"\n    p = subprocess.Popen(['pbpaste', '-Prefer', 'ascii'],\n        stdout=subprocess.PIPE)\n    text, stderr = p.communicate()\n    # Text comes in with old Mac \\r line endings. Change them to \\n.\n    text = text.replace('\\r', '\\n')\n    return text", "code_tokens": "def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \\r line endings. Change them to \\n. text = text . replace ( '\\r' , '\\n' ) return text", "docstring_tokens": "Get the clipboard s text on OS X .", "label": 0}, {"idx": "cosqa-train-8976", "doc": "finding the median in python arthimeticallly", "code": "def median(data):\n    \"\"\"Calculate the median of a list.\"\"\"\n    data.sort()\n    num_values = len(data)\n    half = num_values // 2\n    if num_values % 2:\n        return data[half]\n    return 0.5 * (data[half-1] + data[half])", "code_tokens": "def median ( data ) : data . sort ( ) num_values = len ( data ) half = num_values // 2 if num_values % 2 : return data [ half ] return 0.5 * ( data [ half - 1 ] + data [ half ] )", "docstring_tokens": "Calculate the median of a list .", "label": 1}, {"idx": "cosqa-train-8977", "doc": "python how to average the values of a dictionary", "code": "def _mean_dict(dict_list):\n    \"\"\"Compute the mean value across a list of dictionaries\n    \"\"\"\n    return {k: np.array([d[k] for d in dict_list]).mean()\n            for k in dict_list[0].keys()}", "code_tokens": "def _mean_dict ( dict_list ) : return { k : np . array ( [ d [ k ] for d in dict_list ] ) . mean ( ) for k in dict_list [ 0 ] . keys ( ) }", "docstring_tokens": "Compute the mean value across a list of dictionaries", "label": 1}, {"idx": "cosqa-train-8978", "doc": "finding unique lists in python", "code": "def uniquify_list(L):\n    \"\"\"Same order unique list using only a list compression.\"\"\"\n    return [e for i, e in enumerate(L) if L.index(e) == i]", "code_tokens": "def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]", "docstring_tokens": "Same order unique list using only a list compression .", "label": 1}, {"idx": "cosqa-train-8979", "doc": "python how to calculate pairwise distance matrix", "code": "def distance_matrix(trains1, trains2, cos, tau):\n    \"\"\"\n    Return the *bipartite* (rectangular) distance matrix between the observations in the first and the second list.\n\n    Convenience function; equivalent to ``dissimilarity_matrix(trains1, trains2, cos, tau, \"distance\")``. Refer to :func:`pymuvr.dissimilarity_matrix` for full documentation.\n    \"\"\"\n    return dissimilarity_matrix(trains1, trains2, cos, tau, \"distance\")", "code_tokens": "def distance_matrix ( trains1 , trains2 , cos , tau ) : return dissimilarity_matrix ( trains1 , trains2 , cos , tau , \"distance\" )", "docstring_tokens": "Return the * bipartite * ( rectangular ) distance matrix between the observations in the first and the second list .", "label": 1}, {"idx": "cosqa-train-8980", "doc": "fitting a gaussian curve python", "code": "def fit_gaussian(x, y, yerr, p0):\n    \"\"\" Fit a Gaussian to the data \"\"\"\n    try:\n        popt, pcov = curve_fit(gaussian, x, y, sigma=yerr, p0=p0, absolute_sigma=True)\n    except RuntimeError:\n        return [0],[0]\n    return popt, pcov", "code_tokens": "def fit_gaussian ( x , y , yerr , p0 ) : try : popt , pcov = curve_fit ( gaussian , x , y , sigma = yerr , p0 = p0 , absolute_sigma = True ) except RuntimeError : return [ 0 ] , [ 0 ] return popt , pcov", "docstring_tokens": "Fit a Gaussian to the data", "label": 0}, {"idx": "cosqa-train-8981", "doc": "python how to change partial object to function", "code": "def save_partial(self, obj):\n        \"\"\"Partial objects do not serialize correctly in python2.x -- this fixes the bugs\"\"\"\n        self.save_reduce(_genpartial, (obj.func, obj.args, obj.keywords))", "code_tokens": "def save_partial ( self , obj ) : self . save_reduce ( _genpartial , ( obj . func , obj . args , obj . keywords ) )", "docstring_tokens": "Partial objects do not serialize correctly in python2 . x -- this fixes the bugs", "label": 1}, {"idx": "cosqa-train-8982", "doc": "flag for null in python", "code": "def _none_value(self):\n        \"\"\"Get an appropriate \"null\" value for this field's type. This\n        is used internally when setting the field to None.\n        \"\"\"\n        if self.out_type == int:\n            return 0\n        elif self.out_type == float:\n            return 0.0\n        elif self.out_type == bool:\n            return False\n        elif self.out_type == six.text_type:\n            return u''", "code_tokens": "def _none_value ( self ) : if self . out_type == int : return 0 elif self . out_type == float : return 0.0 elif self . out_type == bool : return False elif self . out_type == six . text_type : return u''", "docstring_tokens": "Get an appropriate null value for this field s type . This is used internally when setting the field to None .", "label": 1}, {"idx": "cosqa-train-8983", "doc": "python how to check if a user has read permissions to a file", "code": "def perform_permissions_check(self, user, obj, perms):\n        \"\"\" Performs the permission check. \"\"\"\n        return self.request.forum_permission_handler.can_download_files(obj, user)", "code_tokens": "def perform_permissions_check ( self , user , obj , perms ) : return self . request . forum_permission_handler . can_download_files ( obj , user )", "docstring_tokens": "Performs the permission check .", "label": 1}, {"idx": "cosqa-train-8984", "doc": "flask python replacing quotes in html", "code": "def safe_quotes(text, escape_single_quotes=False):\n    \"\"\"htmlify string\"\"\"\n    if isinstance(text, str):\n        safe_text = text.replace('\"', \"&quot;\")\n        if escape_single_quotes:\n            safe_text = safe_text.replace(\"'\", \"&#92;'\")\n        return safe_text.replace('True', 'true')\n    return text", "code_tokens": "def safe_quotes ( text , escape_single_quotes = False ) : if isinstance ( text , str ) : safe_text = text . replace ( '\"' , \"&quot;\" ) if escape_single_quotes : safe_text = safe_text . replace ( \"'\" , \"&#92;'\" ) return safe_text . replace ( 'True' , 'true' ) return text", "docstring_tokens": "htmlify string", "label": 0}, {"idx": "cosqa-train-8985", "doc": "python how to check if an attribute exist", "code": "def has_attribute(module_name, attribute_name):\n    \"\"\"Is this attribute present?\"\"\"\n    init_file = '%s/__init__.py' % module_name\n    return any(\n        [attribute_name in init_line for init_line in open(init_file).readlines()]\n    )", "code_tokens": "def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )", "docstring_tokens": "Is this attribute present?", "label": 1}, {"idx": "cosqa-train-8986", "doc": "flask python serialize databse query object", "code": "def serialize(self):\n        \"\"\"Serialize the query to a structure using the query DSL.\"\"\"\n        data = {'doc': self.doc}\n        if isinstance(self.query, Query):\n            data['query'] = self.query.serialize()\n        return data", "code_tokens": "def serialize ( self ) : data = { 'doc' : self . doc } if isinstance ( self . query , Query ) : data [ 'query' ] = self . query . serialize ( ) return data", "docstring_tokens": "Serialize the query to a structure using the query DSL .", "label": 1}, {"idx": "cosqa-train-8987", "doc": "python how to check if host is local", "code": "def we_are_in_lyon():\n    \"\"\"Check if we are on a Lyon machine\"\"\"\n    import socket\n    try:\n        hostname = socket.gethostname()\n        ip = socket.gethostbyname(hostname)\n    except socket.gaierror:\n        return False\n    return ip.startswith(\"134.158.\")", "code_tokens": "def we_are_in_lyon ( ) : import socket try : hostname = socket . gethostname ( ) ip = socket . gethostbyname ( hostname ) except socket . gaierror : return False return ip . startswith ( \"134.158.\" )", "docstring_tokens": "Check if we are on a Lyon machine", "label": 1}, {"idx": "cosqa-train-8988", "doc": "flask python static files", "code": "def glr_path_static():\n    \"\"\"Returns path to packaged static files\"\"\"\n    return os.path.abspath(os.path.join(os.path.dirname(__file__), '_static'))", "code_tokens": "def glr_path_static ( ) : return os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '_static' ) )", "docstring_tokens": "Returns path to packaged static files", "label": 0}, {"idx": "cosqa-train-8989", "doc": "python how to check if key exists before key error", "code": "def check_if_branch_exist(db, root_hash, key_prefix):\n    \"\"\"\n    Given a key prefix, return whether this prefix is\n    the prefix of an existing key in the trie.\n    \"\"\"\n    validate_is_bytes(key_prefix)\n\n    return _check_if_branch_exist(db, root_hash, encode_to_bin(key_prefix))", "code_tokens": "def check_if_branch_exist ( db , root_hash , key_prefix ) : validate_is_bytes ( key_prefix ) return _check_if_branch_exist ( db , root_hash , encode_to_bin ( key_prefix ) )", "docstring_tokens": "Given a key prefix return whether this prefix is the prefix of an existing key in the trie .", "label": 1}, {"idx": "cosqa-train-8990", "doc": "for loop iterate string replace python", "code": "def _sub_patterns(patterns, text):\n    \"\"\"\n    Apply re.sub to bunch of (pattern, repl)\n    \"\"\"\n    for pattern, repl in patterns:\n        text = re.sub(pattern, repl, text)\n    return text", "code_tokens": "def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text", "docstring_tokens": "Apply re . sub to bunch of ( pattern repl )", "label": 1}, {"idx": "cosqa-train-8991", "doc": "python how to check if string contains file extension", "code": "def is_valid_image_extension(file_path):\n    \"\"\"is_valid_image_extension.\"\"\"\n    valid_extensions = ['.jpeg', '.jpg', '.gif', '.png']\n    _, extension = os.path.splitext(file_path)\n    return extension.lower() in valid_extensions", "code_tokens": "def is_valid_image_extension ( file_path ) : valid_extensions = [ '.jpeg' , '.jpg' , '.gif' , '.png' ] _ , extension = os . path . splitext ( file_path ) return extension . lower ( ) in valid_extensions", "docstring_tokens": "is_valid_image_extension .", "label": 1}, {"idx": "cosqa-train-8992", "doc": "for statemnets python, how to make range inclusive", "code": "def min_values(args):\n    \"\"\" Return possible range for min function. \"\"\"\n    return Interval(min(x.low for x in args), min(x.high for x in args))", "code_tokens": "def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )", "docstring_tokens": "Return possible range for min function .", "label": 1}, {"idx": "cosqa-train-8993", "doc": "python how to check if value is in enum", "code": "def has_value_name(self, name):\n        \"\"\"Check if this `enum` has a particular name among its values.\n\n        :param name: Enumeration value name\n        :type name: str\n        :rtype: True if there is an enumeration value with the given name\n        \"\"\"\n        for val, _ in self._values:\n            if val == name:\n                return True\n        return False", "code_tokens": "def has_value_name ( self , name ) : for val , _ in self . _values : if val == name : return True return False", "docstring_tokens": "Check if this enum has a particular name among its values .", "label": 1}, {"idx": "cosqa-train-8994", "doc": "for to return 5 largest value in python", "code": "def best(self):\n        \"\"\"\n        Returns the element with the highest probability.\n        \"\"\"\n        b = (-1e999999, None)\n        for k, c in iteritems(self.counts):\n            b = max(b, (c, k))\n        return b[1]", "code_tokens": "def best ( self ) : b = ( - 1e999999 , None ) for k , c in iteritems ( self . counts ) : b = max ( b , ( c , k ) ) return b [ 1 ]", "docstring_tokens": "Returns the element with the highest probability .", "label": 0}, {"idx": "cosqa-train-8995", "doc": "python how to check if variable has any sub functions", "code": "def is_callable(*p):\n    \"\"\" True if all the args are functions and / or subroutines\n    \"\"\"\n    import symbols\n    return all(isinstance(x, symbols.FUNCTION) for x in p)", "code_tokens": "def is_callable ( * p ) : import symbols return all ( isinstance ( x , symbols . FUNCTION ) for x in p )", "docstring_tokens": "True if all the args are functions and / or subroutines", "label": 1}, {"idx": "cosqa-train-8996", "doc": "force an array to be float in python", "code": "def ensure_dtype_float(x, default=np.float64):\n    r\"\"\"Makes sure that x is type of float\n\n    \"\"\"\n    if isinstance(x, np.ndarray):\n        if x.dtype.kind == 'f':\n            return x\n        elif x.dtype.kind == 'i':\n            return x.astype(default)\n        else:\n            raise TypeError('x is of type '+str(x.dtype)+' that cannot be converted to float')\n    else:\n        raise TypeError('x is not an array')", "code_tokens": "def ensure_dtype_float ( x , default = np . float64 ) : if isinstance ( x , np . ndarray ) : if x . dtype . kind == 'f' : return x elif x . dtype . kind == 'i' : return x . astype ( default ) else : raise TypeError ( 'x is of type ' + str ( x . dtype ) + ' that cannot be converted to float' ) else : raise TypeError ( 'x is not an array' )", "docstring_tokens": "r Makes sure that x is type of float", "label": 1}, {"idx": "cosqa-train-8997", "doc": "python how to check the extension of a file", "code": "def get_file_extension_type(filename):\n    \"\"\"\n    Return the group associated to the file\n    :param filename:\n    :return: str\n    \"\"\"\n    ext = get_file_extension(filename)\n    if ext:\n        for name, group in EXTENSIONS.items():\n            if ext in group:\n                return name\n    return \"OTHER\"", "code_tokens": "def get_file_extension_type ( filename ) : ext = get_file_extension ( filename ) if ext : for name , group in EXTENSIONS . items ( ) : if ext in group : return name return \"OTHER\"", "docstring_tokens": "Return the group associated to the file : param filename : : return : str", "label": 1}, {"idx": "cosqa-train-8998", "doc": "force user input to be saved as pdf file python", "code": "def append_pdf(input_pdf: bytes, output_writer: PdfFileWriter):\n    \"\"\"\n    Appends a PDF to a pyPDF writer. Legacy interface.\n    \"\"\"\n    append_memory_pdf_to_writer(input_pdf=input_pdf,\n                                writer=output_writer)", "code_tokens": "def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )", "docstring_tokens": "Appends a PDF to a pyPDF writer . Legacy interface .", "label": 1}, {"idx": "cosqa-train-8999", "doc": "python how to check url", "code": "def get_url_nofollow(url):\n\t\"\"\" \n\tfunction to get return code of a url\n\n\tCredits: http://blog.jasonantman.com/2013/06/python-script-to-check-a-list-of-urls-for-return-code-and-final-return-code-if-redirected/\n\t\"\"\"\n\ttry:\n\t\tresponse = urlopen(url)\n\t\tcode = response.getcode()\n\t\treturn code\n\texcept HTTPError as e:\n\t\treturn e.code\n\texcept:\n\t\treturn 0", "code_tokens": "def get_url_nofollow ( url ) : try : response = urlopen ( url ) code = response . getcode ( ) return code except HTTPError as e : return e . code except : return 0", "docstring_tokens": "function to get return code of a url", "label": 1}, {"idx": "cosqa-train-9000", "doc": "fork a daemon python", "code": "def go_to_background():\n    \"\"\" Daemonize the running process. \"\"\"\n    try:\n        if os.fork():\n            sys.exit()\n    except OSError as errmsg:\n        LOGGER.error('Fork failed: {0}'.format(errmsg))\n        sys.exit('Fork failed')", "code_tokens": "def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "docstring_tokens": "Daemonize the running process .", "label": 0}, {"idx": "cosqa-train-9001", "doc": "python how to create a md5 hash on a file", "code": "def get_file_md5sum(path):\n    \"\"\"Calculate the MD5 hash for a file.\"\"\"\n    with open(path, 'rb') as fh:\n        h = str(hashlib.md5(fh.read()).hexdigest())\n    return h", "code_tokens": "def get_file_md5sum ( path ) : with open ( path , 'rb' ) as fh : h = str ( hashlib . md5 ( fh . read ( ) ) . hexdigest ( ) ) return h", "docstring_tokens": "Calculate the MD5 hash for a file .", "label": 0}, {"idx": "cosqa-train-9002", "doc": "fork in python in windows", "code": "def go_to_background():\n    \"\"\" Daemonize the running process. \"\"\"\n    try:\n        if os.fork():\n            sys.exit()\n    except OSError as errmsg:\n        LOGGER.error('Fork failed: {0}'.format(errmsg))\n        sys.exit('Fork failed')", "code_tokens": "def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "docstring_tokens": "Daemonize the running process .", "label": 0}, {"idx": "cosqa-train-9003", "doc": "python how to define static uuid", "code": "def generate_uuid():\n    \"\"\"Generate a UUID.\"\"\"\n    r_uuid = base64.urlsafe_b64encode(uuid.uuid4().bytes)\n    return r_uuid.decode().replace('=', '')", "code_tokens": "def generate_uuid ( ) : r_uuid = base64 . urlsafe_b64encode ( uuid . uuid4 ( ) . bytes ) return r_uuid . decode ( ) . replace ( '=' , '' )", "docstring_tokens": "Generate a UUID .", "label": 1}, {"idx": "cosqa-train-9004", "doc": "format json output in python", "code": "def to_json(data):\n    \"\"\"Return data as a JSON string.\"\"\"\n    return json.dumps(data, default=lambda x: x.__dict__, sort_keys=True, indent=4)", "code_tokens": "def to_json ( data ) : return json . dumps ( data , default = lambda x : x . __dict__ , sort_keys = True , indent = 4 )", "docstring_tokens": "Return data as a JSON string .", "label": 1}, {"idx": "cosqa-train-9005", "doc": "python how to determine if image is mostly black in decimals", "code": "def check_color(cls, raw_image):\n        \"\"\"\n        Just check if raw_image is completely white.\n        http://stackoverflow.com/questions/14041562/python-pil-detect-if-an-image-is-completely-black-or-white\n        \"\"\"\n        # sum(img.convert(\"L\").getextrema()) in (0, 2)\n        extrema = raw_image.convert(\"L\").getextrema()\n        if extrema == (255, 255): # all white\n            raise cls.MonoImageException", "code_tokens": "def check_color ( cls , raw_image ) : # sum(img.convert(\"L\").getextrema()) in (0, 2)\n extrema = raw_image . convert ( \"L\" ) . getextrema ( ) if extrema == ( 255 , 255 ) : # all white\n raise cls . MonoImageException", "docstring_tokens": "Just check if raw_image is completely white . http : // stackoverflow . com / questions / 14041562 / python - pil - detect - if - an - image - is - completely - black - or - white", "label": 0}, {"idx": "cosqa-train-9006", "doc": "format object to format string python", "code": "def __str__(self):\n    \"\"\"Returns a pretty-printed string for this object.\"\"\"\n    return 'Output name: \"%s\" watts: %d type: \"%s\" id: %d' % (\n        self._name, self._watts, self._output_type, self._integration_id)", "code_tokens": "def __str__ ( self ) : return 'Output name: \"%s\" watts: %d type: \"%s\" id: %d' % ( self . _name , self . _watts , self . _output_type , self . _integration_id )", "docstring_tokens": "Returns a pretty - printed string for this object .", "label": 1}, {"idx": "cosqa-train-9007", "doc": "python how to do multiple string replaces", "code": "def multi_replace(instr, search_list=[], repl_list=None):\n    \"\"\"\n    Does a string replace with a list of search and replacements\n\n    TODO: rename\n    \"\"\"\n    repl_list = [''] * len(search_list) if repl_list is None else repl_list\n    for ser, repl in zip(search_list, repl_list):\n        instr = instr.replace(ser, repl)\n    return instr", "code_tokens": "def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr", "docstring_tokens": "Does a string replace with a list of search and replacements", "label": 1}, {"idx": "cosqa-train-9008", "doc": "format string in python to pass a specific string", "code": "def safe_format(s, **kwargs):\n  \"\"\"\n  :type s str\n  \"\"\"\n  return string.Formatter().vformat(s, (), defaultdict(str, **kwargs))", "code_tokens": "def safe_format ( s , * * kwargs ) : return string . Formatter ( ) . vformat ( s , ( ) , defaultdict ( str , * * kwargs ) )", "docstring_tokens": ": type s str", "label": 1}, {"idx": "cosqa-train-9009", "doc": "python how to download a json url and save it as a file to your computer", "code": "def download_json(local_filename, url, clobber=False):\n    \"\"\"Download the given JSON file, and pretty-print before we output it.\"\"\"\n    with open(local_filename, 'w') as json_file:\n        json_file.write(json.dumps(requests.get(url).json(), sort_keys=True, indent=2, separators=(',', ': ')))", "code_tokens": "def download_json ( local_filename , url , clobber = False ) : with open ( local_filename , 'w' ) as json_file : json_file . write ( json . dumps ( requests . get ( url ) . json ( ) , sort_keys = True , indent = 2 , separators = ( ',' , ': ' ) ) )", "docstring_tokens": "Download the given JSON file and pretty - print before we output it .", "label": 0}, {"idx": "cosqa-train-9010", "doc": "fourier coefficients for each pixel using fft in python", "code": "def translate_fourier(image, dx):\n    \"\"\" Translate an image in fourier-space with plane waves \"\"\"\n    N = image.shape[0]\n\n    f = 2*np.pi*np.fft.fftfreq(N)\n    kx,ky,kz = np.meshgrid(*(f,)*3, indexing='ij')\n    kv = np.array([kx,ky,kz]).T\n\n    q = np.fft.fftn(image)*np.exp(-1.j*(kv*dx).sum(axis=-1)).T\n    return np.real(np.fft.ifftn(q))", "code_tokens": "def translate_fourier ( image , dx ) : N = image . shape [ 0 ] f = 2 * np . pi * np . fft . fftfreq ( N ) kx , ky , kz = np . meshgrid ( * ( f , ) * 3 , indexing = 'ij' ) kv = np . array ( [ kx , ky , kz ] ) . T q = np . fft . fftn ( image ) * np . exp ( - 1.j * ( kv * dx ) . sum ( axis = - 1 ) ) . T return np . real ( np . fft . ifftn ( q ) )", "docstring_tokens": "Translate an image in fourier - space with plane waves", "label": 1}, {"idx": "cosqa-train-9011", "doc": "python how to end indentation", "code": "def _pad(self):\n    \"\"\"Pads the output with an amount of indentation appropriate for the number of open element.\n\n    This method does nothing if the indent value passed to the constructor is falsy.\n    \"\"\"\n    if self._indent:\n      self.whitespace(self._indent * len(self._open_elements))", "code_tokens": "def _pad ( self ) : if self . _indent : self . whitespace ( self . _indent * len ( self . _open_elements ) )", "docstring_tokens": "Pads the output with an amount of indentation appropriate for the number of open element .", "label": 1}, {"idx": "cosqa-train-9012", "doc": "from json to obejct python", "code": "def json(body, charset='utf-8', **kwargs):\n    \"\"\"Takes JSON formatted data, converting it into native Python objects\"\"\"\n    return json_converter.loads(text(body, charset=charset))", "code_tokens": "def json ( body , charset = 'utf-8' , * * kwargs ) : return json_converter . loads ( text ( body , charset = charset ) )", "docstring_tokens": "Takes JSON formatted data converting it into native Python objects", "label": 1}, {"idx": "cosqa-train-9013", "doc": "python how to exist a gevent thread", "code": "def start(self):\n        \"\"\"\n        Starts the loop. Calling a running loop is an error.\n        \"\"\"\n        assert not self.has_started(), \"called start() on an active GeventLoop\"\n        self._stop_event = Event()\n        # note that we don't use safe_greenlets.spawn because we take care of it in _loop by ourselves\n        self._greenlet = gevent.spawn(self._loop)", "code_tokens": "def start ( self ) : assert not self . has_started ( ) , \"called start() on an active GeventLoop\" self . _stop_event = Event ( ) # note that we don't use safe_greenlets.spawn because we take care of it in _loop by ourselves self . _greenlet = gevent . spawn ( self . _loop )", "docstring_tokens": "Starts the loop . Calling a running loop is an error .", "label": 0}, {"idx": "cosqa-train-9014", "doc": "function pointer to string representation python", "code": "def give_str(self):\n        \"\"\"\n            Give string representation of the callable.\n        \"\"\"\n        args = self._args[:]\n        kwargs = self._kwargs\n        return self._give_str(args, kwargs)", "code_tokens": "def give_str ( self ) : args = self . _args [ : ] kwargs = self . _kwargs return self . _give_str ( args , kwargs )", "docstring_tokens": "Give string representation of the callable .", "label": 0}, {"idx": "cosqa-train-9015", "doc": "python how to fix mixed tabs and spaces", "code": "def handle_whitespace(text):\n    r\"\"\"Handles whitespace cleanup.\n\n    Tabs are \"smartly\" retabbed (see sub_retab). Lines that contain\n    only whitespace are truncated to a single newline.\n    \"\"\"\n    text = re_retab.sub(sub_retab, text)\n    text = re_whitespace.sub('', text).strip()\n    return text", "code_tokens": "def handle_whitespace ( text ) : text = re_retab . sub ( sub_retab , text ) text = re_whitespace . sub ( '' , text ) . strip ( ) return text", "docstring_tokens": "r Handles whitespace cleanup .", "label": 0}, {"idx": "cosqa-train-9016", "doc": "function that return the number of days in a month without the year python", "code": "def gday_of_year(self):\n        \"\"\"Return the number of days since January 1 of the given year.\"\"\"\n        return (self.date - dt.date(self.date.year, 1, 1)).days", "code_tokens": "def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days", "docstring_tokens": "Return the number of days since January 1 of the given year .", "label": 0}, {"idx": "cosqa-train-9017", "doc": "python how to flip a matrix", "code": "def imflip(img, direction='horizontal'):\n    \"\"\"Flip an image horizontally or vertically.\n\n    Args:\n        img (ndarray): Image to be flipped.\n        direction (str): The flip direction, either \"horizontal\" or \"vertical\".\n\n    Returns:\n        ndarray: The flipped image.\n    \"\"\"\n    assert direction in ['horizontal', 'vertical']\n    if direction == 'horizontal':\n        return np.flip(img, axis=1)\n    else:\n        return np.flip(img, axis=0)", "code_tokens": "def imflip ( img , direction = 'horizontal' ) : assert direction in [ 'horizontal' , 'vertical' ] if direction == 'horizontal' : return np . flip ( img , axis = 1 ) else : return np . flip ( img , axis = 0 )", "docstring_tokens": "Flip an image horizontally or vertically .", "label": 1}, {"idx": "cosqa-train-9018", "doc": "function to check strngth of password in python", "code": "def is_password_valid(password):\n    \"\"\"\n    Check if a password is valid\n    \"\"\"\n    pattern = re.compile(r\"^.{4,75}$\")\n    return bool(pattern.match(password))", "code_tokens": "def is_password_valid ( password ) : pattern = re . compile ( r\"^.{4,75}$\" ) return bool ( pattern . match ( password ) )", "docstring_tokens": "Check if a password is valid", "label": 1}, {"idx": "cosqa-train-9019", "doc": "python how to force paratemr type to int", "code": "def robust_int(v):\n    \"\"\"Parse an int robustly, ignoring commas and other cruft. \"\"\"\n\n    if isinstance(v, int):\n        return v\n\n    if isinstance(v, float):\n        return int(v)\n\n    v = str(v).replace(',', '')\n\n    if not v:\n        return None\n\n    return int(v)", "code_tokens": "def robust_int ( v ) : if isinstance ( v , int ) : return v if isinstance ( v , float ) : return int ( v ) v = str ( v ) . replace ( ',' , '' ) if not v : return None return int ( v )", "docstring_tokens": "Parse an int robustly ignoring commas and other cruft .", "label": 0}, {"idx": "cosqa-train-9020", "doc": "function to to check if user exist in python", "code": "def user_exists(username):\n    \"\"\"Check if a user exists\"\"\"\n    try:\n        pwd.getpwnam(username)\n        user_exists = True\n    except KeyError:\n        user_exists = False\n    return user_exists", "code_tokens": "def user_exists ( username ) : try : pwd . getpwnam ( username ) user_exists = True except KeyError : user_exists = False return user_exists", "docstring_tokens": "Check if a user exists", "label": 1}, {"idx": "cosqa-train-9021", "doc": "python how to get domain top ;level", "code": "def top_level(url, fix_protocol=True):\n    \"\"\"Extract the top level domain from an URL.\"\"\"\n    ext = tld.get_tld(url, fix_protocol=fix_protocol)\n    toplevel = '.'.join(urlparse(url).netloc.split('.')[-2:]).split(\n        ext)[0] + ext\n    return toplevel", "code_tokens": "def top_level ( url , fix_protocol = True ) : ext = tld . get_tld ( url , fix_protocol = fix_protocol ) toplevel = '.' . join ( urlparse ( url ) . netloc . split ( '.' ) [ - 2 : ] ) . split ( ext ) [ 0 ] + ext return toplevel", "docstring_tokens": "Extract the top level domain from an URL .", "label": 1}, {"idx": "cosqa-train-9022", "doc": "gaussian blur opencv python", "code": "def GaussianBlur(X, ksize_width, ksize_height, sigma_x, sigma_y):\n    \"\"\"Apply Gaussian blur to the given data.\n\n    Args:\n        X: data to blur\n        kernel_size: Gaussian kernel size\n        stddev: Gaussian kernel standard deviation (in both X and Y directions)\n    \"\"\"\n    return image_transform(\n        X,\n        cv2.GaussianBlur,\n        ksize=(ksize_width, ksize_height),\n        sigmaX=sigma_x,\n        sigmaY=sigma_y\n    )", "code_tokens": "def GaussianBlur ( X , ksize_width , ksize_height , sigma_x , sigma_y ) : return image_transform ( X , cv2 . GaussianBlur , ksize = ( ksize_width , ksize_height ) , sigmaX = sigma_x , sigmaY = sigma_y )", "docstring_tokens": "Apply Gaussian blur to the given data .", "label": 1}, {"idx": "cosqa-train-9023", "doc": "python how to get function name", "code": "def get_func_name(func):\n    \"\"\"Return a name which includes the module name and function name.\"\"\"\n    func_name = getattr(func, '__name__', func.__class__.__name__)\n    module_name = func.__module__\n\n    if module_name is not None:\n        module_name = func.__module__\n        return '{}.{}'.format(module_name, func_name)\n\n    return func_name", "code_tokens": "def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name", "docstring_tokens": "Return a name which includes the module name and function name .", "label": 1}, {"idx": "cosqa-train-9024", "doc": "gaussian distribution formula python", "code": "def gauss_pdf(x, mu, sigma):\n    \"\"\"Normalized Gaussian\"\"\"\n    return 1 / np.sqrt(2 * np.pi) / sigma * np.exp(-(x - mu) ** 2 / 2. / sigma ** 2)", "code_tokens": "def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )", "docstring_tokens": "Normalized Gaussian", "label": 1}, {"idx": "cosqa-train-9025", "doc": "python how to get method name", "code": "def get_method_name(method):\n    \"\"\"\n    Returns given method name.\n\n    :param method: Method to retrieve the name.\n    :type method: object\n    :return: Method name.\n    :rtype: unicode\n    \"\"\"\n\n    name = get_object_name(method)\n    if name.startswith(\"__\") and not name.endswith(\"__\"):\n        name = \"_{0}{1}\".format(get_object_name(method.im_class), name)\n    return name", "code_tokens": "def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( \"__\" ) and not name . endswith ( \"__\" ) : name = \"_{0}{1}\" . format ( get_object_name ( method . im_class ) , name ) return name", "docstring_tokens": "Returns given method name .", "label": 1}, {"idx": "cosqa-train-9026", "doc": "generate a random apikey for a user python", "code": "def gen_api_key(username):\n    \"\"\"\n    Create a random API key for a user\n    :param username:\n    :return: Hex encoded SHA512 random string\n    \"\"\"\n    salt = str(os.urandom(64)).encode('utf-8')\n    return hash_password(username, salt)", "code_tokens": "def gen_api_key ( username ) : salt = str ( os . urandom ( 64 ) ) . encode ( 'utf-8' ) return hash_password ( username , salt )", "docstring_tokens": "Create a random API key for a user : param username : : return : Hex encoded SHA512 random string", "label": 1}, {"idx": "cosqa-train-9027", "doc": "python how to get original data from normalized data", "code": "def normalize(data):\n    \"\"\"Normalize the data to be in the [0, 1] range.\n\n    :param data:\n    :return: normalized data\n    \"\"\"\n    out_data = data.copy()\n\n    for i, sample in enumerate(out_data):\n        out_data[i] /= sum(out_data[i])\n\n    return out_data", "code_tokens": "def normalize ( data ) : out_data = data . copy ( ) for i , sample in enumerate ( out_data ) : out_data [ i ] /= sum ( out_data [ i ] ) return out_data", "docstring_tokens": "Normalize the data to be in the [ 0 1 ] range .", "label": 0}, {"idx": "cosqa-train-9028", "doc": "generate list of fixed size python", "code": "def batch(items, size):\n    \"\"\"Batches a list into a list of lists, with sub-lists sized by a specified\n    batch size.\"\"\"\n    return [items[x:x + size] for x in xrange(0, len(items), size)]", "code_tokens": "def batch ( items , size ) : return [ items [ x : x + size ] for x in xrange ( 0 , len ( items ) , size ) ]", "docstring_tokens": "Batches a list into a list of lists with sub - lists sized by a specified batch size .", "label": 1}, {"idx": "cosqa-train-9029", "doc": "python how to get program to restart after executing", "code": "def restart_program():\n    \"\"\"\n    DOES NOT WORK WELL WITH MOPIDY\n    Hack from\n    https://www.daniweb.com/software-development/python/code/260268/restart-your-python-program\n    to support updating the settings, since mopidy is not able to do that yet\n    Restarts the current program\n    Note: this function does not return. Any cleanup action (like\n    saving data) must be done before calling this function\n    \"\"\"\n\n    python = sys.executable\n    os.execl(python, python, * sys.argv)", "code_tokens": "def restart_program ( ) : python = sys . executable os . execl ( python , python , * sys . argv )", "docstring_tokens": "DOES NOT WORK WELL WITH MOPIDY Hack from https : // www . daniweb . com / software - development / python / code / 260268 / restart - your - python - program to support updating the settings since mopidy is not able to do that yet Restarts the current program Note : this function does not return . Any cleanup action ( like saving data ) must be done before calling this function", "label": 0}, {"idx": "cosqa-train-9030", "doc": "generate random hash string python", "code": "def generate_hash(self, length=30):\n        \"\"\" Generate random string of given length \"\"\"\n        import random, string\n        chars = string.ascii_letters + string.digits\n        ran = random.SystemRandom().choice\n        hash = ''.join(ran(chars) for i in range(length))\n        return hash", "code_tokens": "def generate_hash ( self , length = 30 ) : import random , string chars = string . ascii_letters + string . digits ran = random . SystemRandom ( ) . choice hash = '' . join ( ran ( chars ) for i in range ( length ) ) return hash", "docstring_tokens": "Generate random string of given length", "label": 1}, {"idx": "cosqa-train-9031", "doc": "python how to get stem of filename", "code": "def guess_title(basename):\n    \"\"\" Attempt to guess the title from the filename \"\"\"\n\n    base, _ = os.path.splitext(basename)\n    return re.sub(r'[ _-]+', r' ', base).title()", "code_tokens": "def guess_title ( basename ) : base , _ = os . path . splitext ( basename ) return re . sub ( r'[ _-]+' , r' ' , base ) . title ( )", "docstring_tokens": "Attempt to guess the title from the filename", "label": 1}, {"idx": "cosqa-train-9032", "doc": "generating documentation from python docstring comments", "code": "def process_docstring(app, what, name, obj, options, lines):\n    \"\"\"React to a docstring event and append contracts to it.\"\"\"\n    # pylint: disable=unused-argument\n    # pylint: disable=too-many-arguments\n    lines.extend(_format_contracts(what=what, obj=obj))", "code_tokens": "def process_docstring ( app , what , name , obj , options , lines ) : # pylint: disable=unused-argument # pylint: disable=too-many-arguments lines . extend ( _format_contracts ( what = what , obj = obj ) )", "docstring_tokens": "React to a docstring event and append contracts to it .", "label": 1}, {"idx": "cosqa-train-9033", "doc": "python how to get the average of red blue and green values", "code": "def get_average_color(colors):\n    \"\"\"Calculate the average color from the list of colors, where each color\n    is a 3-tuple of (r, g, b) values.\n    \"\"\"\n    c = reduce(color_reducer, colors)\n    total = len(colors)\n    return tuple(v / total for v in c)", "code_tokens": "def get_average_color ( colors ) : c = reduce ( color_reducer , colors ) total = len ( colors ) return tuple ( v / total for v in c )", "docstring_tokens": "Calculate the average color from the list of colors where each color is a 3 - tuple of ( r g b ) values .", "label": 1}, {"idx": "cosqa-train-9034", "doc": "get all dates between range datetime python", "code": "def dates_in_range(start_date, end_date):\n    \"\"\"Returns all dates between two dates.\n\n    Inclusive of the start date but not the end date.\n\n    Args:\n        start_date (datetime.date)\n        end_date (datetime.date)\n\n    Returns:\n        (list) of datetime.date objects\n    \"\"\"\n    return [\n        start_date + timedelta(n)\n        for n in range(int((end_date - start_date).days))\n    ]", "code_tokens": "def dates_in_range ( start_date , end_date ) : return [ start_date + timedelta ( n ) for n in range ( int ( ( end_date - start_date ) . days ) ) ]", "docstring_tokens": "Returns all dates between two dates .", "label": 1}, {"idx": "cosqa-train-9035", "doc": "python how to get the last n elements of a list", "code": "def chunk_list(l, n):\n    \"\"\"Return `n` size lists from a given list `l`\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Return n size lists from a given list l", "label": 1}, {"idx": "cosqa-train-9036", "doc": "get all integers from a string python", "code": "def get_numbers(s):\n    \"\"\"Extracts all integers from a string an return them in a list\"\"\"\n\n    result = map(int, re.findall(r'[0-9]+', unicode(s)))\n    return result + [1] * (2 - len(result))", "code_tokens": "def get_numbers ( s ) : result = map ( int , re . findall ( r'[0-9]+' , unicode ( s ) ) ) return result + [ 1 ] * ( 2 - len ( result ) )", "docstring_tokens": "Extracts all integers from a string an return them in a list", "label": 1}, {"idx": "cosqa-train-9037", "doc": "python how to get the variable with the same name as the string", "code": "def get_var(self, name):\n        \"\"\" Returns the variable set with the given name.\n        \"\"\"\n        for var in self.vars:\n            if var.name == name:\n                return var\n        else:\n            raise ValueError", "code_tokens": "def get_var ( self , name ) : for var in self . vars : if var . name == name : return var else : raise ValueError", "docstring_tokens": "Returns the variable set with the given name .", "label": 1}, {"idx": "cosqa-train-9038", "doc": "get all numbers in a string python", "code": "def get_numbers(s):\n    \"\"\"Extracts all integers from a string an return them in a list\"\"\"\n\n    result = map(int, re.findall(r'[0-9]+', unicode(s)))\n    return result + [1] * (2 - len(result))", "code_tokens": "def get_numbers ( s ) : result = map ( int , re . findall ( r'[0-9]+' , unicode ( s ) ) ) return result + [ 1 ] * ( 2 - len ( result ) )", "docstring_tokens": "Extracts all integers from a string an return them in a list", "label": 0}, {"idx": "cosqa-train-9039", "doc": "python how to gzip a file", "code": "def __gzip(filename):\n\t\t\"\"\" Compress a file returning the new filename (.gz)\n\t\t\"\"\"\n\t\tzipname = filename + '.gz'\n\t\tfile_pointer = open(filename,'rb')\n\t\tzip_pointer = gzip.open(zipname,'wb')\n\t\tzip_pointer.writelines(file_pointer)\n\t\tfile_pointer.close()\n\t\tzip_pointer.close()\n\t\treturn zipname", "code_tokens": "def __gzip ( filename ) : zipname = filename + '.gz' file_pointer = open ( filename , 'rb' ) zip_pointer = gzip . open ( zipname , 'wb' ) zip_pointer . writelines ( file_pointer ) file_pointer . close ( ) zip_pointer . close ( ) return zipname", "docstring_tokens": "Compress a file returning the new filename ( . gz )", "label": 1}, {"idx": "cosqa-train-9040", "doc": "python how to hide axes ticks matplotlib", "code": "def clear_matplotlib_ticks(self, axis=\"both\"):\n        \"\"\"Clears the default matplotlib ticks.\"\"\"\n        ax = self.get_axes()\n        plotting.clear_matplotlib_ticks(ax=ax, axis=axis)", "code_tokens": "def clear_matplotlib_ticks ( self , axis = \"both\" ) : ax = self . get_axes ( ) plotting . clear_matplotlib_ticks ( ax = ax , axis = axis )", "docstring_tokens": "Clears the default matplotlib ticks .", "label": 1}, {"idx": "cosqa-train-9041", "doc": "get an entry from a dictionary dynaimcally python3", "code": "def get_single_item(d):\n    \"\"\"Get an item from a dict which contains just one item.\"\"\"\n    assert len(d) == 1, 'Single-item dict must have just one item, not %d.' % len(d)\n    return next(six.iteritems(d))", "code_tokens": "def get_single_item ( d ) : assert len ( d ) == 1 , 'Single-item dict must have just one item, not %d.' % len ( d ) return next ( six . iteritems ( d ) )", "docstring_tokens": "Get an item from a dict which contains just one item .", "label": 1}, {"idx": "cosqa-train-9042", "doc": "python how to identify integers or floats", "code": "def type_converter(text):\n    \"\"\" I convert strings into integers, floats, and strings! \"\"\"\n    if text.isdigit():\n        return int(text), int\n\n    try:\n        return float(text), float\n    except ValueError:\n        return text, STRING_TYPE", "code_tokens": "def type_converter ( text ) : if text . isdigit ( ) : return int ( text ) , int try : return float ( text ) , float except ValueError : return text , STRING_TYPE", "docstring_tokens": "I convert strings into integers floats and strings!", "label": 1}, {"idx": "cosqa-train-9043", "doc": "get attached logger handlers python", "code": "def find_console_handler(logger):\n    \"\"\"Return a stream handler, if it exists.\"\"\"\n    for handler in logger.handlers:\n        if (isinstance(handler, logging.StreamHandler) and\n                handler.stream == sys.stderr):\n            return handler", "code_tokens": "def find_console_handler ( logger ) : for handler in logger . handlers : if ( isinstance ( handler , logging . StreamHandler ) and handler . stream == sys . stderr ) : return handler", "docstring_tokens": "Return a stream handler if it exists .", "label": 1}, {"idx": "cosqa-train-9044", "doc": "python how to investigate time used in each call", "code": "def timeit(output):\n    \"\"\"\n    If output is string, then print the string and also time used\n    \"\"\"\n    b = time.time()\n    yield\n    print output, 'time used: %.3fs' % (time.time()-b)", "code_tokens": "def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )", "docstring_tokens": "If output is string then print the string and also time used", "label": 1}, {"idx": "cosqa-train-9045", "doc": "get average from list in python", "code": "def calc_list_average(l):\n    \"\"\"\n    Calculates the average value of a list of numbers\n    Returns a float\n    \"\"\"\n    total = 0.0\n    for value in l:\n        total += value\n    return total / len(l)", "code_tokens": "def calc_list_average ( l ) : total = 0.0 for value in l : total += value return total / len ( l )", "docstring_tokens": "Calculates the average value of a list of numbers Returns a float", "label": 1}, {"idx": "cosqa-train-9046", "doc": "python how to know if a file handle is valid", "code": "def is_readable(fp, size=1):\n    \"\"\"\n    Check if the file-like object is readable.\n\n    :param fp: file-like object\n    :param size: byte size\n    :return: bool\n    \"\"\"\n    read_size = len(fp.read(size))\n    fp.seek(-read_size, 1)\n    return read_size == size", "code_tokens": "def is_readable ( fp , size = 1 ) : read_size = len ( fp . read ( size ) ) fp . seek ( - read_size , 1 ) return read_size == size", "docstring_tokens": "Check if the file - like object is readable .", "label": 1}, {"idx": "cosqa-train-9047", "doc": "get average of items in a list python", "code": "def mean(inlist):\n    \"\"\"\nReturns the arithematic mean of the values in the passed list.\nAssumes a '1D' list, but will function on the 1st dim of an array(!).\n\nUsage:   lmean(inlist)\n\"\"\"\n    sum = 0\n    for item in inlist:\n        sum = sum + item\n    return sum / float(len(inlist))", "code_tokens": "def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )", "docstring_tokens": "Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) .", "label": 1}, {"idx": "cosqa-train-9048", "doc": "python how to list the most recent file", "code": "def get_last_modified_timestamp(self):\n        \"\"\"\n        Looks at the files in a git root directory and grabs the last modified timestamp\n        \"\"\"\n        cmd = \"find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '\"\n        ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        output = ps.communicate()[0]\n        print output", "code_tokens": "def get_last_modified_timestamp ( self ) : cmd = \"find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '\" ps = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) output = ps . communicate ( ) [ 0 ] print output", "docstring_tokens": "Looks at the files in a git root directory and grabs the last modified timestamp", "label": 0}, {"idx": "cosqa-train-9049", "doc": "get base address of a process python", "code": "def get_base_dir():\n    \"\"\"\n    Return the base directory\n    \"\"\"\n    return os.path.split(os.path.abspath(os.path.dirname(__file__)))[0]", "code_tokens": "def get_base_dir ( ) : return os . path . split ( os . path . abspath ( os . path . dirname ( __file__ ) ) ) [ 0 ]", "docstring_tokens": "Return the base directory", "label": 1}, {"idx": "cosqa-train-9050", "doc": "python how to make an infinity sign", "code": "def get_neg_infinity(dtype):\n    \"\"\"Return an appropriate positive infinity for this dtype.\n\n    Parameters\n    ----------\n    dtype : np.dtype\n\n    Returns\n    -------\n    fill_value : positive infinity value corresponding to this dtype.\n    \"\"\"\n    if issubclass(dtype.type, (np.floating, np.integer)):\n        return -np.inf\n\n    if issubclass(dtype.type, np.complexfloating):\n        return -np.inf - 1j * np.inf\n\n    return NINF", "code_tokens": "def get_neg_infinity ( dtype ) : if issubclass ( dtype . type , ( np . floating , np . integer ) ) : return - np . inf if issubclass ( dtype . type , np . complexfloating ) : return - np . inf - 1j * np . inf return NINF", "docstring_tokens": "Return an appropriate positive infinity for this dtype .", "label": 1}, {"idx": "cosqa-train-9051", "doc": "get cache path python", "code": "def is_cached(file_name):\n\t\"\"\"\n\tCheck if a given file is available in the cache or not\n\t\"\"\"\n\n\tgml_file_path = join(join(expanduser('~'), OCTOGRID_DIRECTORY), file_name)\n\n\treturn isfile(gml_file_path)", "code_tokens": "def is_cached ( file_name ) : gml_file_path = join ( join ( expanduser ( '~' ) , OCTOGRID_DIRECTORY ) , file_name ) return isfile ( gml_file_path )", "docstring_tokens": "Check if a given file is available in the cache or not", "label": 1}, {"idx": "cosqa-train-9052", "doc": "python how to make an object into a string", "code": "def __repr__(self):\n    \"\"\"Returns a stringified representation of this object.\"\"\"\n    return str({'name': self._name, 'watts': self._watts,\n                'type': self._output_type, 'id': self._integration_id})", "code_tokens": "def __repr__ ( self ) : return str ( { 'name' : self . _name , 'watts' : self . _watts , 'type' : self . _output_type , 'id' : self . _integration_id } )", "docstring_tokens": "Returns a stringified representation of this object .", "label": 1}, {"idx": "cosqa-train-9053", "doc": "get closest value in an array python", "code": "def closest(xarr, val):\n    \"\"\" Return the index of the closest in xarr to value val \"\"\"\n    idx_closest = np.argmin(np.abs(np.array(xarr) - val))\n    return idx_closest", "code_tokens": "def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest", "docstring_tokens": "Return the index of the closest in xarr to value val", "label": 1}, {"idx": "cosqa-train-9054", "doc": "python how to make traceback error", "code": "def format_exception(e):\n    \"\"\"Returns a string containing the type and text of the exception.\n\n    \"\"\"\n    from .utils.printing import fill\n    return '\\n'.join(fill(line) for line in traceback.format_exception_only(type(e), e))", "code_tokens": "def format_exception ( e ) : from . utils . printing import fill return '\\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )", "docstring_tokens": "Returns a string containing the type and text of the exception .", "label": 0}, {"idx": "cosqa-train-9055", "doc": "get columns name of data frame in python", "code": "def get_obj_cols(df):\n    \"\"\"\n    Returns names of 'object' columns in the DataFrame.\n    \"\"\"\n    obj_cols = []\n    for idx, dt in enumerate(df.dtypes):\n        if dt == 'object' or is_category(dt):\n            obj_cols.append(df.columns.values[idx])\n\n    return obj_cols", "code_tokens": "def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols", "docstring_tokens": "Returns names of object columns in the DataFrame .", "label": 1}, {"idx": "cosqa-train-9056", "doc": "python how to make transparent hole in image", "code": "def inpaint(self):\n        \"\"\" Replace masked-out elements in an array using an iterative image inpainting algorithm. \"\"\"\n\n        import inpaint\n        filled = inpaint.replace_nans(np.ma.filled(self.raster_data, np.NAN).astype(np.float32), 3, 0.01, 2)\n        self.raster_data = np.ma.masked_invalid(filled)", "code_tokens": "def inpaint ( self ) : import inpaint filled = inpaint . replace_nans ( np . ma . filled ( self . raster_data , np . NAN ) . astype ( np . float32 ) , 3 , 0.01 , 2 ) self . raster_data = np . ma . masked_invalid ( filled )", "docstring_tokens": "Replace masked - out elements in an array using an iterative image inpainting algorithm .", "label": 1}, {"idx": "cosqa-train-9057", "doc": "get contour and fill image python", "code": "def filter_contour(imageFile, opFile):\n    \"\"\" convert an image by applying a contour \"\"\"\n    im = Image.open(imageFile)\n    im1 = im.filter(ImageFilter.CONTOUR)\n    im1.save(opFile)", "code_tokens": "def filter_contour ( imageFile , opFile ) : im = Image . open ( imageFile ) im1 = im . filter ( ImageFilter . CONTOUR ) im1 . save ( opFile )", "docstring_tokens": "convert an image by applying a contour", "label": 1}, {"idx": "cosqa-train-9058", "doc": "python how to open file using absolute path", "code": "def get_file_string(filepath):\n    \"\"\"Get string from file.\"\"\"\n    with open(os.path.abspath(filepath)) as f:\n        return f.read()", "code_tokens": "def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )", "docstring_tokens": "Get string from file .", "label": 0}, {"idx": "cosqa-train-9059", "doc": "get coordinates of box in a image python", "code": "def bbox(img):\n    \"\"\"Find the bounding box around nonzero elements in the given array\n\n    Copied from https://stackoverflow.com/a/31402351/5703449 .\n\n    Returns:\n        rowmin, rowmax, colmin, colmax\n    \"\"\"\n    rows = np.any(img, axis=1)\n    cols = np.any(img, axis=0)\n    rmin, rmax = np.where(rows)[0][[0, -1]]\n    cmin, cmax = np.where(cols)[0][[0, -1]]\n\n    return rmin, rmax, cmin, cmax", "code_tokens": "def bbox ( img ) : rows = np . any ( img , axis = 1 ) cols = np . any ( img , axis = 0 ) rmin , rmax = np . where ( rows ) [ 0 ] [ [ 0 , - 1 ] ] cmin , cmax = np . where ( cols ) [ 0 ] [ [ 0 , - 1 ] ] return rmin , rmax , cmin , cmax", "docstring_tokens": "Find the bounding box around nonzero elements in the given array", "label": 1}, {"idx": "cosqa-train-9060", "doc": "python how to open json from url", "code": "def get_jsonparsed_data(url):\n    \"\"\"Receive the content of ``url``, parse it as JSON and return the\n       object.\n    \"\"\"\n    response = urlopen(url)\n    data = response.read().decode('utf-8')\n    return json.loads(data)", "code_tokens": "def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )", "docstring_tokens": "Receive the content of url parse it as JSON and return the object .", "label": 0}, {"idx": "cosqa-train-9061", "doc": "get date diff in week python", "code": "def get_week_start_end_day():\n    \"\"\"\n    Get the week start date and end date\n    \"\"\"\n    t = date.today()\n    wd = t.weekday()\n    return (t - timedelta(wd), t + timedelta(6 - wd))", "code_tokens": "def get_week_start_end_day ( ) : t = date . today ( ) wd = t . weekday ( ) return ( t - timedelta ( wd ) , t + timedelta ( 6 - wd ) )", "docstring_tokens": "Get the week start date and end date", "label": 1}, {"idx": "cosqa-train-9062", "doc": "python how to print dictionary within a dictionary", "code": "def printdict(adict):\n    \"\"\"printdict\"\"\"\n    dlist = list(adict.keys())\n    dlist.sort()\n    for i in range(0, len(dlist)):\n        print(dlist[i], adict[dlist[i]])", "code_tokens": "def printdict ( adict ) : dlist = list ( adict . keys ( ) ) dlist . sort ( ) for i in range ( 0 , len ( dlist ) ) : print ( dlist [ i ] , adict [ dlist [ i ] ] )", "docstring_tokens": "printdict", "label": 0}, {"idx": "cosqa-train-9063", "doc": "get default python session", "code": "def _get_session():\n    \"\"\"Return (and memoize) a database session\"\"\"\n    session = getattr(g, '_session', None)\n    if session is None:\n        session = g._session = db.session()\n    return session", "code_tokens": "def _get_session ( ) : session = getattr ( g , '_session' , None ) if session is None : session = g . _session = db . session ( ) return session", "docstring_tokens": "Return ( and memoize ) a database session", "label": 0}, {"idx": "cosqa-train-9064", "doc": "python how to redirect stdout to file", "code": "def redirect_output(fileobj):\n    \"\"\"Redirect standard out to file.\"\"\"\n    old = sys.stdout\n    sys.stdout = fileobj\n    try:\n        yield fileobj\n    finally:\n        sys.stdout = old", "code_tokens": "def redirect_output ( fileobj ) : old = sys . stdout sys . stdout = fileobj try : yield fileobj finally : sys . stdout = old", "docstring_tokens": "Redirect standard out to file .", "label": 1}, {"idx": "cosqa-train-9065", "doc": "get every nth element from array python", "code": "def _nth(arr, n):\n    \"\"\"\n    Return the nth value of array\n\n    If it is missing return NaN\n    \"\"\"\n    try:\n        return arr.iloc[n]\n    except (KeyError, IndexError):\n        return np.nan", "code_tokens": "def _nth ( arr , n ) : try : return arr . iloc [ n ] except ( KeyError , IndexError ) : return np . nan", "docstring_tokens": "Return the nth value of array", "label": 1}, {"idx": "cosqa-train-9066", "doc": "python how to replace capitals with lowercase", "code": "def to_capitalized_camel_case(snake_case_string):\n    \"\"\"\n    Convert a string from snake case to camel case with the first letter capitalized. For example, \"some_var\"\n    would become \"SomeVar\".\n\n    :param snake_case_string: Snake-cased string to convert to camel case.\n    :returns: Camel-cased version of snake_case_string.\n    \"\"\"\n    parts = snake_case_string.split('_')\n    return ''.join([i.title() for i in parts])", "code_tokens": "def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )", "docstring_tokens": "Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar .", "label": 1}, {"idx": "cosqa-train-9067", "doc": "get fields of object python", "code": "def object_as_dict(obj):\n    \"\"\"Turn an SQLAlchemy model into a dict of field names and values.\n\n    Based on https://stackoverflow.com/a/37350445/1579058\n    \"\"\"\n    return {c.key: getattr(obj, c.key)\n            for c in inspect(obj).mapper.column_attrs}", "code_tokens": "def object_as_dict ( obj ) : return { c . key : getattr ( obj , c . key ) for c in inspect ( obj ) . mapper . column_attrs }", "docstring_tokens": "Turn an SQLAlchemy model into a dict of field names and values .", "label": 1}, {"idx": "cosqa-train-9068", "doc": "python how to retrieve an anchor tag", "code": "def get_anchor_href(markup):\n    \"\"\"\n    Given HTML markup, return a list of hrefs for each anchor tag.\n    \"\"\"\n    soup = BeautifulSoup(markup, 'lxml')\n    return ['%s' % link.get('href') for link in soup.find_all('a')]", "code_tokens": "def get_anchor_href ( markup ) : soup = BeautifulSoup ( markup , 'lxml' ) return [ '%s' % link . get ( 'href' ) for link in soup . find_all ( 'a' ) ]", "docstring_tokens": "Given HTML markup return a list of hrefs for each anchor tag .", "label": 1}, {"idx": "cosqa-train-9069", "doc": "get file name without extension in python", "code": "def remove_ext(fname):\n    \"\"\"Removes the extension from a filename\n    \"\"\"\n    bn = os.path.basename(fname)\n    return os.path.splitext(bn)[0]", "code_tokens": "def remove_ext ( fname ) : bn = os . path . basename ( fname ) return os . path . splitext ( bn ) [ 0 ]", "docstring_tokens": "Removes the extension from a filename", "label": 1}, {"idx": "cosqa-train-9070", "doc": "python how to return the quarter of a date", "code": "def previous_quarter(d):\n    \"\"\"\n    Retrieve the previous quarter for dt\n    \"\"\"\n    from django_toolkit.datetime_util import quarter as datetime_quarter\n    return quarter( (datetime_quarter(datetime(d.year, d.month, d.day))[0] + timedelta(days=-1)).date() )", "code_tokens": "def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )", "docstring_tokens": "Retrieve the previous quarter for dt", "label": 1}, {"idx": "cosqa-train-9071", "doc": "get file type in python", "code": "def _file_type(self, field):\n        \"\"\" Returns file type for given file field.\n        \n        Args:\n            field (str): File field\n\n        Returns:\n            string. File type\n        \"\"\"\n        type = mimetypes.guess_type(self._files[field])[0]\n        return type.encode(\"utf-8\") if isinstance(type, unicode) else str(type)", "code_tokens": "def _file_type ( self , field ) : type = mimetypes . guess_type ( self . _files [ field ] ) [ 0 ] return type . encode ( \"utf-8\" ) if isinstance ( type , unicode ) else str ( type )", "docstring_tokens": "Returns file type for given file field . Args : field ( str ) : File field", "label": 1}, {"idx": "cosqa-train-9072", "doc": "python how to save figure to pdf", "code": "def save_pdf(path):\n  \"\"\"\n  Saves a pdf of the current matplotlib figure.\n\n  :param path: str, filepath to save to\n  \"\"\"\n\n  pp = PdfPages(path)\n  pp.savefig(pyplot.gcf())\n  pp.close()", "code_tokens": "def save_pdf ( path ) : pp = PdfPages ( path ) pp . savefig ( pyplot . gcf ( ) ) pp . close ( )", "docstring_tokens": "Saves a pdf of the current matplotlib figure .", "label": 0}, {"idx": "cosqa-train-9073", "doc": "get filename of url python", "code": "def get_file_name(url):\n  \"\"\"Returns file name of file at given url.\"\"\"\n  return os.path.basename(urllib.parse.urlparse(url).path) or 'unknown_name'", "code_tokens": "def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'", "docstring_tokens": "Returns file name of file at given url .", "label": 0}, {"idx": "cosqa-train-9074", "doc": "python how to save to path in requests", "code": "def download_file(save_path, file_url):\n    \"\"\" Download file from http url link \"\"\"\n\n    r = requests.get(file_url)  # create HTTP response object\n\n    with open(save_path, 'wb') as f:\n        f.write(r.content)\n\n    return save_path", "code_tokens": "def download_file ( save_path , file_url ) : r = requests . get ( file_url ) # create HTTP response object with open ( save_path , 'wb' ) as f : f . write ( r . content ) return save_path", "docstring_tokens": "Download file from http url link", "label": 1}, {"idx": "cosqa-train-9075", "doc": "get first column array python", "code": "def get_X0(X):\n    \"\"\" Return zero-th element of a one-element data container.\n    \"\"\"\n    if pandas_available and isinstance(X, pd.DataFrame):\n        assert len(X) == 1\n        x = np.array(X.iloc[0])\n    else:\n        x, = X\n    return x", "code_tokens": "def get_X0 ( X ) : if pandas_available and isinstance ( X , pd . DataFrame ) : assert len ( X ) == 1 x = np . array ( X . iloc [ 0 ] ) else : x , = X return x", "docstring_tokens": "Return zero - th element of a one - element data container .", "label": 0}, {"idx": "cosqa-train-9076", "doc": "python how to select list of table mysql", "code": "def get_tablenames(cur):\n    \"\"\" Conveinience: \"\"\"\n    cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n    tablename_list_ = cur.fetchall()\n    tablename_list = [str(tablename[0]) for tablename in tablename_list_ ]\n    return tablename_list", "code_tokens": "def get_tablenames ( cur ) : cur . execute ( \"SELECT name FROM sqlite_master WHERE type='table'\" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list", "docstring_tokens": "Conveinience :", "label": 1}, {"idx": "cosqa-train-9077", "doc": "get index of second largest value python", "code": "def find_le(a, x):\n    \"\"\"Find rightmost value less than or equal to x.\"\"\"\n    i = bs.bisect_right(a, x)\n    if i: return i - 1\n    raise ValueError", "code_tokens": "def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError", "docstring_tokens": "Find rightmost value less than or equal to x .", "label": 0}, {"idx": "cosqa-train-9078", "doc": "python how to set proxy", "code": "def enable_proxy(self, host, port):\n        \"\"\"Enable a default web proxy\"\"\"\n\n        self.proxy = [host, _number(port)]\n        self.proxy_enabled = True", "code_tokens": "def enable_proxy ( self , host , port ) : self . proxy = [ host , _number ( port ) ] self . proxy_enabled = True", "docstring_tokens": "Enable a default web proxy", "label": 1}, {"idx": "cosqa-train-9079", "doc": "get item at index in python", "code": "def __getitem__(self, index):\n    \"\"\"Get the item at the given index.\n\n    Index is a tuple of (row, col)\n    \"\"\"\n    row, col = index\n    return self.rows[row][col]", "code_tokens": "def __getitem__ ( self , index ) : row , col = index return self . rows [ row ] [ col ]", "docstring_tokens": "Get the item at the given index .", "label": 1}, {"idx": "cosqa-train-9080", "doc": "python how to show help", "code": "def _help():\n    \"\"\" Display both SQLAlchemy and Python help statements \"\"\"\n\n    statement = '%s%s' % (shelp, phelp % ', '.join(cntx_.keys()))\n    print statement.strip()", "code_tokens": "def _help ( ) : statement = '%s%s' % ( shelp , phelp % ', ' . join ( cntx_ . keys ( ) ) ) print statement . strip ( )", "docstring_tokens": "Display both SQLAlchemy and Python help statements", "label": 1}, {"idx": "cosqa-train-9081", "doc": "get keypress out of focus python", "code": "def onkeyup(self, key, keycode, ctrl, shift, alt):\n        \"\"\"Called when user types and releases a key. \n        The widget should be able to receive the focus in order to emit the event.\n        Assign a 'tabindex' attribute to make it focusable.\n        \n        Args:\n            key (str): the character value\n            keycode (str): the numeric char code\n        \"\"\"\n        return (key, keycode, ctrl, shift, alt)", "code_tokens": "def onkeyup ( self , key , keycode , ctrl , shift , alt ) : return ( key , keycode , ctrl , shift , alt )", "docstring_tokens": "Called when user types and releases a key . The widget should be able to receive the focus in order to emit the event . Assign a tabindex attribute to make it focusable . Args : key ( str ) : the character value keycode ( str ) : the numeric char code", "label": 0}, {"idx": "cosqa-train-9082", "doc": "python how to show training time", "code": "def on_train_end(self, logs):\n        \"\"\" Print training time at end of training \"\"\"\n        duration = timeit.default_timer() - self.train_start\n        print('done, took {:.3f} seconds'.format(duration))", "code_tokens": "def on_train_end ( self , logs ) : duration = timeit . default_timer ( ) - self . train_start print ( 'done, took {:.3f} seconds' . format ( duration ) )", "docstring_tokens": "Print training time at end of training", "label": 1}, {"idx": "cosqa-train-9083", "doc": "get keywords from a sentence python", "code": "def extract_keywords_from_text(self, text):\n        \"\"\"Method to extract keywords from the text provided.\n\n        :param text: Text to extract keywords from, provided as a string.\n        \"\"\"\n        sentences = nltk.tokenize.sent_tokenize(text)\n        self.extract_keywords_from_sentences(sentences)", "code_tokens": "def extract_keywords_from_text ( self , text ) : sentences = nltk . tokenize . sent_tokenize ( text ) self . extract_keywords_from_sentences ( sentences )", "docstring_tokens": "Method to extract keywords from the text provided .", "label": 0}, {"idx": "cosqa-train-9084", "doc": "python how to simulate android operation", "code": "def pause():\n\t\"\"\"Tell iTunes to pause\"\"\"\n\n\tif not settings.platformCompatible():\n\t\treturn False\n\n\t(output, error) = subprocess.Popen([\"osascript\", \"-e\", PAUSE], stdout=subprocess.PIPE).communicate()", "code_tokens": "def pause ( ) : if not settings . platformCompatible ( ) : return False ( output , error ) = subprocess . Popen ( [ \"osascript\" , \"-e\" , PAUSE ] , stdout = subprocess . PIPE ) . communicate ( )", "docstring_tokens": "Tell iTunes to pause", "label": 0}, {"idx": "cosqa-train-9085", "doc": "get label wise top words python", "code": "def postprocessor(prediction):\n    \"\"\"Map prediction tensor to labels.\"\"\"\n    prediction = prediction.data.numpy()[0]\n    top_predictions = prediction.argsort()[-3:][::-1]\n    return [labels[prediction] for prediction in top_predictions]", "code_tokens": "def postprocessor ( prediction ) : prediction = prediction . data . numpy ( ) [ 0 ] top_predictions = prediction . argsort ( ) [ - 3 : ] [ : : - 1 ] return [ labels [ prediction ] for prediction in top_predictions ]", "docstring_tokens": "Map prediction tensor to labels .", "label": 1}, {"idx": "cosqa-train-9086", "doc": "python how to sort a list whithout changing it", "code": "def insort_no_dup(lst, item):\n    \"\"\"\n    If item is not in lst, add item to list at its sorted position\n    \"\"\"\n    import bisect\n    ix = bisect.bisect_left(lst, item)\n    if lst[ix] != item: \n        lst[ix:ix] = [item]", "code_tokens": "def insort_no_dup ( lst , item ) : import bisect ix = bisect . bisect_left ( lst , item ) if lst [ ix ] != item : lst [ ix : ix ] = [ item ]", "docstring_tokens": "If item is not in lst add item to list at its sorted position", "label": 0}, {"idx": "cosqa-train-9087", "doc": "get last item from queue python", "code": "def PopTask(self):\n    \"\"\"Retrieves and removes the first task from the heap.\n\n    Returns:\n      Task: the task or None if the heap is empty.\n    \"\"\"\n    try:\n      _, task = heapq.heappop(self._heap)\n\n    except IndexError:\n      return None\n    self._task_identifiers.remove(task.identifier)\n    return task", "code_tokens": "def PopTask ( self ) : try : _ , task = heapq . heappop ( self . _heap ) except IndexError : return None self . _task_identifiers . remove ( task . identifier ) return task", "docstring_tokens": "Retrieves and removes the first task from the heap .", "label": 1}, {"idx": "cosqa-train-9088", "doc": "python how to stop current thread", "code": "def stop(self):\n        \"\"\"Stop the progress bar.\"\"\"\n        if self._progressing:\n            self._progressing = False\n            self._thread.join()", "code_tokens": "def stop ( self ) : if self . _progressing : self . _progressing = False self . _thread . join ( )", "docstring_tokens": "Stop the progress bar .", "label": 1}, {"idx": "cosqa-train-9089", "doc": "get length of table sqlite python", "code": "def size_on_disk(self):\n        \"\"\"\n        :return: size of the entire schema in bytes\n        \"\"\"\n        return int(self.connection.query(\n            \"\"\"\n            SELECT SUM(data_length + index_length)\n            FROM information_schema.tables WHERE table_schema='{db}'\n            \"\"\".format(db=self.database)).fetchone()[0])", "code_tokens": "def size_on_disk ( self ) : return int ( self . connection . query ( \"\"\"\n            SELECT SUM(data_length + index_length)\n            FROM information_schema.tables WHERE table_schema='{db}'\n            \"\"\" . format ( db = self . database ) ) . fetchone ( ) [ 0 ] )", "docstring_tokens": ": return : size of the entire schema in bytes", "label": 1}, {"idx": "cosqa-train-9090", "doc": "python how to stop playsound", "code": "def stop(self):\n        \"\"\"Stops playback\"\"\"\n        if self.isPlaying is True:\n            self._execute(\"stop\")\n            self._changePlayingState(False)", "code_tokens": "def stop ( self ) : if self . isPlaying is True : self . _execute ( \"stop\" ) self . _changePlayingState ( False )", "docstring_tokens": "Stops playback", "label": 1}, {"idx": "cosqa-train-9091", "doc": "get list of all values of a series python", "code": "def yvals(self):\n        \"\"\"All y values\"\"\"\n        return [\n            val[1] for serie in self.series for val in serie.values\n            if val[1] is not None\n        ]", "code_tokens": "def yvals ( self ) : return [ val [ 1 ] for serie in self . series for val in serie . values if val [ 1 ] is not None ]", "docstring_tokens": "All y values", "label": 0}, {"idx": "cosqa-train-9092", "doc": "python how to store numpy array in sql database", "code": "def adapt_array(arr):\n    \"\"\"\n    Adapts a Numpy array into an ARRAY string to put into the database.\n\n    Parameters\n    ----------\n    arr: array\n        The Numpy array to be adapted into an ARRAY type that can be inserted into a SQL file.\n\n    Returns\n    -------\n    ARRAY\n            The adapted array object\n\n    \"\"\"\n    out = io.BytesIO()\n    np.save(out, arr), out.seek(0)\n    return buffer(out.read())", "code_tokens": "def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) , out . seek ( 0 ) return buffer ( out . read ( ) )", "docstring_tokens": "Adapts a Numpy array into an ARRAY string to put into the database .", "label": 0}, {"idx": "cosqa-train-9093", "doc": "get list of all youtube api python", "code": "def list_all(dev: Device):\n    \"\"\"List all available API calls.\"\"\"\n    for name, service in dev.services.items():\n        click.echo(click.style(\"\\nService %s\" % name, bold=True))\n        for method in service.methods:\n            click.echo(\"  %s\" % method.name)", "code_tokens": "def list_all ( dev : Device ) : for name , service in dev . services . items ( ) : click . echo ( click . style ( \"\\nService %s\" % name , bold = True ) ) for method in service . methods : click . echo ( \"  %s\" % method . name )", "docstring_tokens": "List all available API calls .", "label": 0}, {"idx": "cosqa-train-9094", "doc": "python how to tell if list is 2d or 3d", "code": "def _rectangular(n):\n    \"\"\"Checks to see if a 2D list is a valid 2D matrix\"\"\"\n    for i in n:\n        if len(i) != len(n[0]):\n            return False\n    return True", "code_tokens": "def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True", "docstring_tokens": "Checks to see if a 2D list is a valid 2D matrix", "label": 0}, {"idx": "cosqa-train-9095", "doc": "get list of handlers on logger python", "code": "def _get_loggers():\n    \"\"\"Return list of Logger classes.\"\"\"\n    from .. import loader\n    modules = loader.get_package_modules('logger')\n    return list(loader.get_plugins(modules, [_Logger]))", "code_tokens": "def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )", "docstring_tokens": "Return list of Logger classes .", "label": 0}, {"idx": "cosqa-train-9096", "doc": "python how to upper case first leter", "code": "def clean(some_string, uppercase=False):\n    \"\"\"\n    helper to clean up an input string\n    \"\"\"\n    if uppercase:\n        return some_string.strip().upper()\n    else:\n        return some_string.strip().lower()", "code_tokens": "def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )", "docstring_tokens": "helper to clean up an input string", "label": 1}, {"idx": "cosqa-train-9097", "doc": "get max value in counter python", "code": "def best(self):\n        \"\"\"\n        Returns the element with the highest probability.\n        \"\"\"\n        b = (-1e999999, None)\n        for k, c in iteritems(self.counts):\n            b = max(b, (c, k))\n        return b[1]", "code_tokens": "def best ( self ) : b = ( - 1e999999 , None ) for k , c in iteritems ( self . counts ) : b = max ( b , ( c , k ) ) return b [ 1 ]", "docstring_tokens": "Returns the element with the highest probability .", "label": 0}, {"idx": "cosqa-train-9098", "doc": "python how to use spines to draw the axes with arrow", "code": "def add_arrow(self, x1, y1, x2, y2, **kws):\n        \"\"\"add arrow to plot\"\"\"\n        self.panel.add_arrow(x1, y1, x2, y2, **kws)", "code_tokens": "def add_arrow ( self , x1 , y1 , x2 , y2 , * * kws ) : self . panel . add_arrow ( x1 , y1 , x2 , y2 , * * kws )", "docstring_tokens": "add arrow to plot", "label": 1}, {"idx": "cosqa-train-9099", "doc": "get microseconds seconds in python from datetime", "code": "def timestamp_to_microseconds(timestamp):\n    \"\"\"Convert a timestamp string into a microseconds value\n    :param timestamp\n    :return time in microseconds\n    \"\"\"\n    timestamp_str = datetime.datetime.strptime(timestamp, ISO_DATETIME_REGEX)\n    epoch_time_secs = calendar.timegm(timestamp_str.timetuple())\n    epoch_time_mus = epoch_time_secs * 1e6 + timestamp_str.microsecond\n    return epoch_time_mus", "code_tokens": "def timestamp_to_microseconds ( timestamp ) : timestamp_str = datetime . datetime . strptime ( timestamp , ISO_DATETIME_REGEX ) epoch_time_secs = calendar . timegm ( timestamp_str . timetuple ( ) ) epoch_time_mus = epoch_time_secs * 1e6 + timestamp_str . microsecond return epoch_time_mus", "docstring_tokens": "Convert a timestamp string into a microseconds value : param timestamp : return time in microseconds", "label": 1}, {"idx": "cosqa-train-9100", "doc": "python how to write gzip a file", "code": "def __gzip(filename):\n\t\t\"\"\" Compress a file returning the new filename (.gz)\n\t\t\"\"\"\n\t\tzipname = filename + '.gz'\n\t\tfile_pointer = open(filename,'rb')\n\t\tzip_pointer = gzip.open(zipname,'wb')\n\t\tzip_pointer.writelines(file_pointer)\n\t\tfile_pointer.close()\n\t\tzip_pointer.close()\n\t\treturn zipname", "code_tokens": "def __gzip ( filename ) : zipname = filename + '.gz' file_pointer = open ( filename , 'rb' ) zip_pointer = gzip . open ( zipname , 'wb' ) zip_pointer . writelines ( file_pointer ) file_pointer . close ( ) zip_pointer . close ( ) return zipname", "docstring_tokens": "Compress a file returning the new filename ( . gz )", "label": 1}, {"idx": "cosqa-train-9101", "doc": "get mouse coordinates python", "code": "def mouse_get_pos():\n    \"\"\"\n\n    :return:\n    \"\"\"\n    p = POINT()\n    AUTO_IT.AU3_MouseGetPos(ctypes.byref(p))\n    return p.x, p.y", "code_tokens": "def mouse_get_pos ( ) : p = POINT ( ) AUTO_IT . AU3_MouseGetPos ( ctypes . byref ( p ) ) return p . x , p . y", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-9102", "doc": "python how to write prompt that asks the user for input if the value doesnt match", "code": "def yesno(prompt):\n    \"\"\"Returns True if user answers 'y' \"\"\"\n    prompt += \" [y/n]\"\n    a = \"\"\n    while a not in [\"y\", \"n\"]:\n        a = input(prompt).lower()\n\n    return a == \"y\"", "code_tokens": "def yesno ( prompt ) : prompt += \" [y/n]\" a = \"\" while a not in [ \"y\" , \"n\" ] : a = input ( prompt ) . lower ( ) return a == \"y\"", "docstring_tokens": "Returns True if user answers y", "label": 1}, {"idx": "cosqa-train-9103", "doc": "get nth element of array python", "code": "def _nth(arr, n):\n    \"\"\"\n    Return the nth value of array\n\n    If it is missing return NaN\n    \"\"\"\n    try:\n        return arr.iloc[n]\n    except (KeyError, IndexError):\n        return np.nan", "code_tokens": "def _nth ( arr , n ) : try : return arr . iloc [ n ] except ( KeyError , IndexError ) : return np . nan", "docstring_tokens": "Return the nth value of array", "label": 1}, {"idx": "cosqa-train-9104", "doc": "python https proxy negotiate", "code": "def _prepare_proxy(self, conn):\n        \"\"\"\n        Establish tunnel connection early, because otherwise httplib\n        would improperly set Host: header to proxy's IP:port.\n        \"\"\"\n        conn.set_tunnel(self._proxy_host, self.port, self.proxy_headers)\n        conn.connect()", "code_tokens": "def _prepare_proxy ( self , conn ) : conn . set_tunnel ( self . _proxy_host , self . port , self . proxy_headers ) conn . connect ( )", "docstring_tokens": "Establish tunnel connection early because otherwise httplib would improperly set Host : header to proxy s IP : port .", "label": 1}, {"idx": "cosqa-train-9105", "doc": "get parent of woking directory file path python", "code": "def get_parent_folder_name(file_path):\n    \"\"\"Finds parent folder of file\n\n    :param file_path: path\n    :return: Name of folder container\n    \"\"\"\n    return os.path.split(os.path.split(os.path.abspath(file_path))[0])[-1]", "code_tokens": "def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]", "docstring_tokens": "Finds parent folder of file", "label": 0}, {"idx": "cosqa-train-9106", "doc": "python hyphen in thrift namespace", "code": "def sanitize_word(s):\n    \"\"\"Remove non-alphanumerical characters from metric word.\n    And trim excessive underscores.\n    \"\"\"\n    s = re.sub('[^\\w-]+', '_', s)\n    s = re.sub('__+', '_', s)\n    return s.strip('_')", "code_tokens": "def sanitize_word ( s ) : s = re . sub ( '[^\\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )", "docstring_tokens": "Remove non - alphanumerical characters from metric word . And trim excessive underscores .", "label": 1}, {"idx": "cosqa-train-9107", "doc": "get previous month python", "code": "def last_day(year=_year, month=_month):\n    \"\"\"\n    get the current month's last day\n    :param year:  default to current year\n    :param month:  default to current month\n    :return: month's last day\n    \"\"\"\n    last_day = calendar.monthrange(year, month)[1]\n    return datetime.date(year=year, month=month, day=last_day)", "code_tokens": "def last_day ( year = _year , month = _month ) : last_day = calendar . monthrange ( year , month ) [ 1 ] return datetime . date ( year = year , month = month , day = last_day )", "docstring_tokens": "get the current month s last day : param year : default to current year : param month : default to current month : return : month s last day", "label": 1}, {"idx": "cosqa-train-9108", "doc": "python if a string is hex", "code": "def is_hex_string(string):\n    \"\"\"Check if the string is only composed of hex characters.\"\"\"\n    pattern = re.compile(r'[A-Fa-f0-9]+')\n    if isinstance(string, six.binary_type):\n        string = str(string)\n    return pattern.match(string) is not None", "code_tokens": "def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None", "docstring_tokens": "Check if the string is only composed of hex characters .", "label": 0}, {"idx": "cosqa-train-9109", "doc": "get processing power from other devices in python", "code": "def get_power(self):\n        \"\"\"Check if the device is on.\"\"\"\n        power = (yield from self.handle_int(self.API.get('power')))\n        return bool(power)", "code_tokens": "def get_power ( self ) : power = ( yield from self . handle_int ( self . API . get ( 'power' ) ) ) return bool ( power )", "docstring_tokens": "Check if the device is on .", "label": 1}, {"idx": "cosqa-train-9110", "doc": "python if at last element of list iterator", "code": "def iter_with_last(iterable):\n    \"\"\"\n    :return: generator of tuples (isLastFlag, item)\n    \"\"\"\n    # Ensure it's an iterator and get the first field\n    iterable = iter(iterable)\n    prev = next(iterable)\n    for item in iterable:\n        # Lag by one item so I know I'm not at the end\n        yield False, prev\n        prev = item\n    # Last item\n    yield True, prev", "code_tokens": "def iter_with_last ( iterable ) : # Ensure it's an iterator and get the first field iterable = iter ( iterable ) prev = next ( iterable ) for item in iterable : # Lag by one item so I know I'm not at the end yield False , prev prev = item # Last item yield True , prev", "docstring_tokens": ": return : generator of tuples ( isLastFlag item )", "label": 1}, {"idx": "cosqa-train-9111", "doc": "get quarter year from date in python", "code": "def datetime_to_year_quarter(dt):\n    \"\"\"\n    Args:\n        dt: a datetime\n    Returns:\n        tuple of the datetime's year and quarter\n    \"\"\"\n    year = dt.year\n    quarter = int(math.ceil(float(dt.month)/3))\n    return (year, quarter)", "code_tokens": "def datetime_to_year_quarter ( dt ) : year = dt . year quarter = int ( math . ceil ( float ( dt . month ) / 3 ) ) return ( year , quarter )", "docstring_tokens": "Args : dt : a datetime Returns : tuple of the datetime s year and quarter", "label": 0}, {"idx": "cosqa-train-9112", "doc": "python if elemment is in list", "code": "def isin(elems, line):\n    \"\"\"Check if an element from a list is in a string.\n\n    :type elems: list\n    :type line: str\n\n    \"\"\"\n    found = False\n    for e in elems:\n        if e in line.lower():\n            found = True\n            break\n    return found", "code_tokens": "def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found", "docstring_tokens": "Check if an element from a list is in a string .", "label": 0}, {"idx": "cosqa-train-9113", "doc": "get rid of nas in python with average variable", "code": "def _aggr_mean(inList):\n  \"\"\" Returns mean of non-None elements of the list\n  \"\"\"\n  aggrSum = 0\n  nonNone = 0\n  for elem in inList:\n    if elem != SENTINEL_VALUE_FOR_MISSING_DATA:\n      aggrSum += elem\n      nonNone += 1\n  if nonNone != 0:\n    return aggrSum / nonNone\n  else:\n    return None", "code_tokens": "def _aggr_mean ( inList ) : aggrSum = 0 nonNone = 0 for elem in inList : if elem != SENTINEL_VALUE_FOR_MISSING_DATA : aggrSum += elem nonNone += 1 if nonNone != 0 : return aggrSum / nonNone else : return None", "docstring_tokens": "Returns mean of non - None elements of the list", "label": 1}, {"idx": "cosqa-train-9114", "doc": "python if file not exist then creat", "code": "def check_create_folder(filename):\n    \"\"\"Check if the folder exisits. If not, create the folder\"\"\"\n    os.makedirs(os.path.dirname(filename), exist_ok=True)", "code_tokens": "def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )", "docstring_tokens": "Check if the folder exisits . If not create the folder", "label": 1}, {"idx": "cosqa-train-9115", "doc": "get seconds past epoch python", "code": "def _dt_to_epoch(dt):\n        \"\"\"Convert datetime to epoch seconds.\"\"\"\n        try:\n            epoch = dt.timestamp()\n        except AttributeError:  # py2\n            epoch = (dt - datetime(1970, 1, 1)).total_seconds()\n        return epoch", "code_tokens": "def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch", "docstring_tokens": "Convert datetime to epoch seconds .", "label": 1}, {"idx": "cosqa-train-9116", "doc": "python if last item in list", "code": "def find_last_sublist(list_, sublist):\n    \"\"\"Given a list, find the last occurance of a sublist within it.\n\n    Returns:\n        Index where the sublist starts, or None if there is no match.\n    \"\"\"\n    for i in reversed(range(len(list_) - len(sublist) + 1)):\n        if list_[i] == sublist[0] and list_[i:i + len(sublist)] == sublist:\n            return i\n    return None", "code_tokens": "def find_last_sublist ( list_ , sublist ) : for i in reversed ( range ( len ( list_ ) - len ( sublist ) + 1 ) ) : if list_ [ i ] == sublist [ 0 ] and list_ [ i : i + len ( sublist ) ] == sublist : return i return None", "docstring_tokens": "Given a list find the last occurance of a sublist within it .", "label": 1}, {"idx": "cosqa-train-9117", "doc": "get size of numpy array python", "code": "def bytesize(arr):\n    \"\"\"\n    Returns the memory byte size of a Numpy array as an integer.\n    \"\"\"\n    byte_size = np.prod(arr.shape) * np.dtype(arr.dtype).itemsize\n    return byte_size", "code_tokens": "def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size", "docstring_tokens": "Returns the memory byte size of a Numpy array as an integer .", "label": 0}, {"idx": "cosqa-train-9118", "doc": "python if traceback then", "code": "def get_last_or_frame_exception():\n    \"\"\"Intended to be used going into post mortem routines.  If\n    sys.last_traceback is set, we will return that and assume that\n    this is what post-mortem will want. If sys.last_traceback has not\n    been set, then perhaps we *about* to raise an error and are\n    fielding an exception. So assume that sys.exc_info()[2]\n    is where we want to look.\"\"\"\n\n    try:\n        if inspect.istraceback(sys.last_traceback):\n            # We do have a traceback so prefer that.\n            return sys.last_type, sys.last_value, sys.last_traceback\n    except AttributeError:\n        pass\n    return sys.exc_info()", "code_tokens": "def get_last_or_frame_exception ( ) : try : if inspect . istraceback ( sys . last_traceback ) : # We do have a traceback so prefer that. return sys . last_type , sys . last_value , sys . last_traceback except AttributeError : pass return sys . exc_info ( )", "docstring_tokens": "Intended to be used going into post mortem routines . If sys . last_traceback is set we will return that and assume that this is what post - mortem will want . If sys . last_traceback has not been set then perhaps we * about * to raise an error and are fielding an exception . So assume that sys . exc_info () [ 2 ] is where we want to look .", "label": 1}, {"idx": "cosqa-train-9119", "doc": "python if type is numeric", "code": "def is_numeric_dtype(dtype):\n    \"\"\"Return ``True`` if ``dtype`` is a numeric type.\"\"\"\n    dtype = np.dtype(dtype)\n    return np.issubsctype(getattr(dtype, 'base', None), np.number)", "code_tokens": "def is_numeric_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . number )", "docstring_tokens": "Return True if dtype is a numeric type .", "label": 0}, {"idx": "cosqa-train-9120", "doc": "get start and end date of previous quarter in python", "code": "def previous_quarter(d):\n    \"\"\"\n    Retrieve the previous quarter for dt\n    \"\"\"\n    from django_toolkit.datetime_util import quarter as datetime_quarter\n    return quarter( (datetime_quarter(datetime(d.year, d.month, d.day))[0] + timedelta(days=-1)).date() )", "code_tokens": "def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )", "docstring_tokens": "Retrieve the previous quarter for dt", "label": 1}, {"idx": "cosqa-train-9121", "doc": "python if type of date", "code": "def is_date_type(cls):\n    \"\"\"Return True if the class is a date type.\"\"\"\n    if not isinstance(cls, type):\n        return False\n    return issubclass(cls, date) and not issubclass(cls, datetime)", "code_tokens": "def is_date_type ( cls ) : if not isinstance ( cls , type ) : return False return issubclass ( cls , date ) and not issubclass ( cls , datetime )", "docstring_tokens": "Return True if the class is a date type .", "label": 1}, {"idx": "cosqa-train-9122", "doc": "get status code of url using python", "code": "def get_url_nofollow(url):\n\t\"\"\" \n\tfunction to get return code of a url\n\n\tCredits: http://blog.jasonantman.com/2013/06/python-script-to-check-a-list-of-urls-for-return-code-and-final-return-code-if-redirected/\n\t\"\"\"\n\ttry:\n\t\tresponse = urlopen(url)\n\t\tcode = response.getcode()\n\t\treturn code\n\texcept HTTPError as e:\n\t\treturn e.code\n\texcept:\n\t\treturn 0", "code_tokens": "def get_url_nofollow ( url ) : try : response = urlopen ( url ) code = response . getcode ( ) return code except HTTPError as e : return e . code except : return 0", "docstring_tokens": "function to get return code of a url", "label": 0}, {"idx": "cosqa-train-9123", "doc": "python if val is a numerical", "code": "def _to_numeric(val):\n    \"\"\"\n    Helper function for conversion of various data types into numeric representation.\n    \"\"\"\n    if isinstance(val, (int, float, datetime.datetime, datetime.timedelta)):\n        return val\n    return float(val)", "code_tokens": "def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )", "docstring_tokens": "Helper function for conversion of various data types into numeric representation .", "label": 1}, {"idx": "cosqa-train-9124", "doc": "get the columns of database table python", "code": "def get_table_columns(dbconn, tablename):\n    \"\"\"\n    Return a list of tuples specifying the column name and type\n    \"\"\"\n    cur = dbconn.cursor()\n    cur.execute(\"PRAGMA table_info('%s');\" % tablename)\n    info = cur.fetchall()\n    cols = [(i[1], i[2]) for i in info]\n    return cols", "code_tokens": "def get_table_columns ( dbconn , tablename ) : cur = dbconn . cursor ( ) cur . execute ( \"PRAGMA table_info('%s');\" % tablename ) info = cur . fetchall ( ) cols = [ ( i [ 1 ] , i [ 2 ] ) for i in info ] return cols", "docstring_tokens": "Return a list of tuples specifying the column name and type", "label": 1}, {"idx": "cosqa-train-9125", "doc": "python ignoring blank lines in reading a file", "code": "def readline( file, skip_blank=False ):\n    \"\"\"Read a line from provided file, skipping any blank or comment lines\"\"\"\n    while 1:\n        line = file.readline()\n        #print \"every line: %r\" % line\n        if not line: return None \n        if line[0] != '#' and not ( skip_blank and line.isspace() ):\n            return line", "code_tokens": "def readline ( file , skip_blank = False ) : while 1 : line = file . readline ( ) #print \"every line: %r\" % line if not line : return None if line [ 0 ] != '#' and not ( skip_blank and line . isspace ( ) ) : return line", "docstring_tokens": "Read a line from provided file skipping any blank or comment lines", "label": 0}, {"idx": "cosqa-train-9126", "doc": "get the last line of the file python", "code": "def last(self):\n        \"\"\"Get the last object in file.\"\"\"\n        # End of file\n        self.__file.seek(0, 2)\n\n        # Get the last struct\n        data = self.get(self.length - 1)\n\n        return data", "code_tokens": "def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data", "docstring_tokens": "Get the last object in file .", "label": 1}, {"idx": "cosqa-train-9127", "doc": "python image crop boundary", "code": "def crop_box(im, box=False, **kwargs):\n    \"\"\"Uses box coordinates to crop an image without resizing it first.\"\"\"\n    if box:\n        im = im.crop(box)\n    return im", "code_tokens": "def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im", "docstring_tokens": "Uses box coordinates to crop an image without resizing it first .", "label": 0}, {"idx": "cosqa-train-9128", "doc": "python image crop non rectangular", "code": "def crop_box(im, box=False, **kwargs):\n    \"\"\"Uses box coordinates to crop an image without resizing it first.\"\"\"\n    if box:\n        im = im.crop(box)\n    return im", "code_tokens": "def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im", "docstring_tokens": "Uses box coordinates to crop an image without resizing it first .", "label": 1}, {"idx": "cosqa-train-9129", "doc": "get the type of an value python", "code": "def datatype(dbtype, description, cursor):\n    \"\"\"Google AppEngine Helper to convert a data type into a string.\"\"\"\n    dt = cursor.db.introspection.get_field_type(dbtype, description)\n    if type(dt) is tuple:\n        return dt[0]\n    else:\n        return dt", "code_tokens": "def datatype ( dbtype , description , cursor ) : dt = cursor . db . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt", "docstring_tokens": "Google AppEngine Helper to convert a data type into a string .", "label": 0}, {"idx": "cosqa-train-9130", "doc": "python image region of interest", "code": "def border(self):\n        \"\"\"Region formed by taking border elements.\n\n        :returns: :class:`jicimagelib.region.Region`\n        \"\"\"\n\n        border_array = self.bitmap - self.inner.bitmap\n        return Region(border_array)", "code_tokens": "def border ( self ) : border_array = self . bitmap - self . inner . bitmap return Region ( border_array )", "docstring_tokens": "Region formed by taking border elements .", "label": 1}, {"idx": "cosqa-train-9131", "doc": "get unique list from two lists python", "code": "def unique_list(lst):\n    \"\"\"Make a list unique, retaining order of initial appearance.\"\"\"\n    uniq = []\n    for item in lst:\n        if item not in uniq:\n            uniq.append(item)\n    return uniq", "code_tokens": "def unique_list ( lst ) : uniq = [ ] for item in lst : if item not in uniq : uniq . append ( item ) return uniq", "docstring_tokens": "Make a list unique retaining order of initial appearance .", "label": 1}, {"idx": "cosqa-train-9132", "doc": "get void pointer python", "code": "def pointer(self):\n        \"\"\"Get a ctypes void pointer to the memory mapped region.\n\n        :type: ctypes.c_void_p\n        \"\"\"\n        return ctypes.cast(ctypes.pointer(ctypes.c_uint8.from_buffer(self.mapping, 0)), ctypes.c_void_p)", "code_tokens": "def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )", "docstring_tokens": "Get a ctypes void pointer to the memory mapped region .", "label": 1}, {"idx": "cosqa-train-9133", "doc": "python imshow not showing entire picture", "code": "def display_pil_image(im):\n   \"\"\"Displayhook function for PIL Images, rendered as PNG.\"\"\"\n   from IPython.core import display\n   b = BytesIO()\n   im.save(b, format='png')\n   data = b.getvalue()\n\n   ip_img = display.Image(data=data, format='png', embed=True)\n   return ip_img._repr_png_()", "code_tokens": "def display_pil_image ( im ) : from IPython . core import display b = BytesIO ( ) im . save ( b , format = 'png' ) data = b . getvalue ( ) ip_img = display . Image ( data = data , format = 'png' , embed = True ) return ip_img . _repr_png_ ( )", "docstring_tokens": "Displayhook function for PIL Images rendered as PNG .", "label": 0}, {"idx": "cosqa-train-9134", "doc": "get window name from pid python", "code": "def getWindowPID(self, hwnd):\n        \"\"\" Gets the process ID that the specified window belongs to \"\"\"\n        pid = ctypes.c_ulong()\n        ctypes.windll.user32.GetWindowThreadProcessId(hwnd, ctypes.byref(pid))\n        return int(pid.value)", "code_tokens": "def getWindowPID ( self , hwnd ) : pid = ctypes . c_ulong ( ) ctypes . windll . user32 . GetWindowThreadProcessId ( hwnd , ctypes . byref ( pid ) ) return int ( pid . value )", "docstring_tokens": "Gets the process ID that the specified window belongs to", "label": 1}, {"idx": "cosqa-train-9135", "doc": "python increase text size", "code": "def set_font_size(self, size):\n        \"\"\"Convenience method for just changing font size.\"\"\"\n        if self.font.font_size == size:\n            pass\n        else:\n            self.font._set_size(size)", "code_tokens": "def set_font_size ( self , size ) : if self . font . font_size == size : pass else : self . font . _set_size ( size )", "docstring_tokens": "Convenience method for just changing font size .", "label": 1}, {"idx": "cosqa-train-9136", "doc": "getall predecessors of a node python", "code": "def predecessors(self, node, graph=None):\n        \"\"\" Returns a list of all predecessors of the given node \"\"\"\n        if graph is None:\n            graph = self.graph\n        return [key for key in graph if node in graph[key]]", "code_tokens": "def predecessors ( self , node , graph = None ) : if graph is None : graph = self . graph return [ key for key in graph if node in graph [ key ] ]", "docstring_tokens": "Returns a list of all predecessors of the given node", "label": 1}, {"idx": "cosqa-train-9137", "doc": "python indent block backwards", "code": "def indent(self):\n        \"\"\"\n        Begins an indented block. Must be used in a 'with' code block.\n        All calls to the logger inside of the block will be indented.\n        \"\"\"\n        blk = IndentBlock(self, self._indent)\n        self._indent += 1\n        return blk", "code_tokens": "def indent ( self ) : blk = IndentBlock ( self , self . _indent ) self . _indent += 1 return blk", "docstring_tokens": "Begins an indented block . Must be used in a with code block . All calls to the logger inside of the block will be indented .", "label": 1}, {"idx": "cosqa-train-9138", "doc": "geting unique value from a list in python", "code": "def unique_element(ll):\n    \"\"\" returns unique elements from a list preserving the original order \"\"\"\n    seen = {}\n    result = []\n    for item in ll:\n        if item in seen:\n            continue\n        seen[item] = 1\n        result.append(item)\n    return result", "code_tokens": "def unique_element ( ll ) : seen = { } result = [ ] for item in ll : if item in seen : continue seen [ item ] = 1 result . append ( item ) return result", "docstring_tokens": "returns unique elements from a list preserving the original order", "label": 0}, {"idx": "cosqa-train-9139", "doc": "python index of closest value", "code": "def closest(xarr, val):\n    \"\"\" Return the index of the closest in xarr to value val \"\"\"\n    idx_closest = np.argmin(np.abs(np.array(xarr) - val))\n    return idx_closest", "code_tokens": "def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest", "docstring_tokens": "Return the index of the closest in xarr to value val", "label": 1}, {"idx": "cosqa-train-9140", "doc": "getsize of hash key python", "code": "def hstrlen(self, name, key):\n        \"\"\"\n        Return the number of bytes stored in the value of ``key``\n        within hash ``name``\n        \"\"\"\n        with self.pipe as pipe:\n            return pipe.hstrlen(self.redis_key(name), key)", "code_tokens": "def hstrlen ( self , name , key ) : with self . pipe as pipe : return pipe . hstrlen ( self . redis_key ( name ) , key )", "docstring_tokens": "Return the number of bytes stored in the value of key within hash name", "label": 1}, {"idx": "cosqa-train-9141", "doc": "python index range of values", "code": "def _index_range(self, version, symbol, from_version=None, **kwargs):\n        \"\"\"\n        Tuple describing range to read from the ndarray - closed:open\n        \"\"\"\n        from_index = None\n        if from_version:\n            from_index = from_version['up_to']\n        return from_index, None", "code_tokens": "def _index_range ( self , version , symbol , from_version = None , * * kwargs ) : from_index = None if from_version : from_index = from_version [ 'up_to' ] return from_index , None", "docstring_tokens": "Tuple describing range to read from the ndarray - closed : open", "label": 1}, {"idx": "cosqa-train-9142", "doc": "github file upload api python", "code": "def upload_file(token, channel_name, file_name):\n    \"\"\" upload file to a channel \"\"\"\n\n    slack = Slacker(token)\n\n    slack.files.upload(file_name, channels=channel_name)", "code_tokens": "def upload_file ( token , channel_name , file_name ) : slack = Slacker ( token ) slack . files . upload ( file_name , channels = channel_name )", "docstring_tokens": "upload file to a channel", "label": 0}, {"idx": "cosqa-train-9143", "doc": "python index through lines in a file", "code": "def get_lines(handle, line):\n    \"\"\"\n    Get zero-indexed line from an open file-like.\n    \"\"\"\n    for i, l in enumerate(handle):\n        if i == line:\n            return l", "code_tokens": "def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l", "docstring_tokens": "Get zero - indexed line from an open file - like .", "label": 0}, {"idx": "cosqa-train-9144", "doc": "grab user input asynchronously python", "code": "async def async_input(prompt):\n    \"\"\"\n    Python's ``input()`` is blocking, which means the event loop we set\n    above can't be running while we're blocking there. This method will\n    let the loop run while we wait for input.\n    \"\"\"\n    print(prompt, end='', flush=True)\n    return (await loop.run_in_executor(None, sys.stdin.readline)).rstrip()", "code_tokens": "async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "docstring_tokens": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input .", "label": 1}, {"idx": "cosqa-train-9145", "doc": "python init obj from string", "code": "def loads(cls, s):\n        \"\"\"\n        Load an instance of this class from YAML.\n\n        \"\"\"\n        with closing(StringIO(s)) as fileobj:\n            return cls.load(fileobj)", "code_tokens": "def loads ( cls , s ) : with closing ( StringIO ( s ) ) as fileobj : return cls . load ( fileobj )", "docstring_tokens": "Load an instance of this class from YAML .", "label": 0}, {"idx": "cosqa-train-9146", "doc": "graph corresponding to the adjacency matrix python", "code": "def get_adjacent_matrix(self):\n        \"\"\"Get adjacency matrix.\n\n        Returns:\n            :param adj: adjacency matrix\n            :type adj: np.ndarray\n        \"\"\"\n        edges = self.edges\n        num_edges = len(edges) + 1\n        adj = np.zeros([num_edges, num_edges])\n\n        for k in range(num_edges - 1):\n            adj[edges[k].L, edges[k].R] = 1\n            adj[edges[k].R, edges[k].L] = 1\n\n        return adj", "code_tokens": "def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj", "docstring_tokens": "Get adjacency matrix .", "label": 1}, {"idx": "cosqa-train-9147", "doc": "python initial heap size set to a larger value than the maximum heap size", "code": "def heappush_max(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown_max(heap, 0, len(heap) - 1)", "code_tokens": "def heappush_max ( heap , item ) : heap . append ( item ) _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "docstring_tokens": "Push item onto heap maintaining the heap invariant .", "label": 1}, {"idx": "cosqa-train-9148", "doc": "hamming distance between two strings python", "code": "def hamming_distance(str1, str2):\n    \"\"\"Calculate the Hamming distance between two bit strings\n\n    Args:\n        str1 (str): First string.\n        str2 (str): Second string.\n    Returns:\n        int: Distance between strings.\n    Raises:\n        VisualizationError: Strings not same length\n    \"\"\"\n    if len(str1) != len(str2):\n        raise VisualizationError('Strings not same length.')\n    return sum(s1 != s2 for s1, s2 in zip(str1, str2))", "code_tokens": "def hamming_distance ( str1 , str2 ) : if len ( str1 ) != len ( str2 ) : raise VisualizationError ( 'Strings not same length.' ) return sum ( s1 != s2 for s1 , s2 in zip ( str1 , str2 ) )", "docstring_tokens": "Calculate the Hamming distance between two bit strings", "label": 0}, {"idx": "cosqa-train-9149", "doc": "python input is blocking", "code": "async def async_input(prompt):\n    \"\"\"\n    Python's ``input()`` is blocking, which means the event loop we set\n    above can't be running while we're blocking there. This method will\n    let the loop run while we wait for input.\n    \"\"\"\n    print(prompt, end='', flush=True)\n    return (await loop.run_in_executor(None, sys.stdin.readline)).rstrip()", "code_tokens": "async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "docstring_tokens": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input .", "label": 0}, {"idx": "cosqa-train-9150", "doc": "hash in python by dict", "code": "def dict_hash(dct):\n    \"\"\"Return a hash of the contents of a dictionary\"\"\"\n    dct_s = json.dumps(dct, sort_keys=True)\n\n    try:\n        m = md5(dct_s)\n    except TypeError:\n        m = md5(dct_s.encode())\n\n    return m.hexdigest()", "code_tokens": "def dict_hash ( dct ) : dct_s = json . dumps ( dct , sort_keys = True ) try : m = md5 ( dct_s ) except TypeError : m = md5 ( dct_s . encode ( ) ) return m . hexdigest ( )", "docstring_tokens": "Return a hash of the contents of a dictionary", "label": 1}, {"idx": "cosqa-train-9151", "doc": "python inspect get functions", "code": "def init_checks_registry():\n    \"\"\"Register all globally visible functions.\n\n    The first argument name is either 'physical_line' or 'logical_line'.\n    \"\"\"\n    mod = inspect.getmodule(register_check)\n    for (name, function) in inspect.getmembers(mod, inspect.isfunction):\n        register_check(function)", "code_tokens": "def init_checks_registry ( ) : mod = inspect . getmodule ( register_check ) for ( name , function ) in inspect . getmembers ( mod , inspect . isfunction ) : register_check ( function )", "docstring_tokens": "Register all globally visible functions .", "label": 0}, {"idx": "cosqa-train-9152", "doc": "hash of a tuple python", "code": "def hash_iterable(it):\n\t\"\"\"Perform a O(1) memory hash of an iterable of arbitrary length.\n\n\thash(tuple(it)) creates a temporary tuple containing all values from it\n\twhich could be a problem if it is large.\n\n\tSee discussion at:\n\thttps://groups.google.com/forum/#!msg/python-ideas/XcuC01a8SYs/e-doB9TbDwAJ\n\t\"\"\"\n\thash_value = hash(type(it))\n\tfor value in it:\n\t\thash_value = hash((hash_value, value))\n\treturn hash_value", "code_tokens": "def hash_iterable ( it ) : hash_value = hash ( type ( it ) ) for value in it : hash_value = hash ( ( hash_value , value ) ) return hash_value", "docstring_tokens": "Perform a O ( 1 ) memory hash of an iterable of arbitrary length .", "label": 1}, {"idx": "cosqa-train-9153", "doc": "python inspect stack get function name", "code": "def _module_name_from_previous_frame(num_frames_back):\n    \"\"\"\n    Returns the module name associated with a frame `num_frames_back` in the\n    call stack. This function adds 1 to account for itself, so `num_frames_back`\n    should be given relative to the caller.\n    \"\"\"\n    frm = inspect.stack()[num_frames_back + 1]\n    return inspect.getmodule(frm[0]).__name__", "code_tokens": "def _module_name_from_previous_frame ( num_frames_back ) : frm = inspect . stack ( ) [ num_frames_back + 1 ] return inspect . getmodule ( frm [ 0 ] ) . __name__", "docstring_tokens": "Returns the module name associated with a frame num_frames_back in the call stack . This function adds 1 to account for itself so num_frames_back should be given relative to the caller .", "label": 1}, {"idx": "cosqa-train-9154", "doc": "have text in different languages given them one name in python", "code": "def _multilingual(function, *args, **kwargs):\n    \"\"\" Returns the value from the function with the given name in the given language module.\n        By default, language=\"en\".\n    \"\"\"\n    return getattr(_module(kwargs.pop(\"language\", \"en\")), function)(*args, **kwargs)", "code_tokens": "def _multilingual ( function , * args , * * kwargs ) : return getattr ( _module ( kwargs . pop ( \"language\" , \"en\" ) ) , function ) ( * args , * * kwargs )", "docstring_tokens": "Returns the value from the function with the given name in the given language module . By default language = en .", "label": 0}, {"idx": "cosqa-train-9155", "doc": "python int and string dtype example", "code": "def infer_dtype_from(val, pandas_dtype=False):\n    \"\"\"\n    interpret the dtype from a scalar or array. This is a convenience\n    routines to infer dtype from a scalar or an array\n\n    Parameters\n    ----------\n    pandas_dtype : bool, default False\n        whether to infer dtype including pandas extension types.\n        If False, scalar/array belongs to pandas extension types is inferred as\n        object\n    \"\"\"\n    if is_scalar(val):\n        return infer_dtype_from_scalar(val, pandas_dtype=pandas_dtype)\n    return infer_dtype_from_array(val, pandas_dtype=pandas_dtype)", "code_tokens": "def infer_dtype_from ( val , pandas_dtype = False ) : if is_scalar ( val ) : return infer_dtype_from_scalar ( val , pandas_dtype = pandas_dtype ) return infer_dtype_from_array ( val , pandas_dtype = pandas_dtype )", "docstring_tokens": "interpret the dtype from a scalar or array . This is a convenience routines to infer dtype from a scalar or an array", "label": 1}, {"idx": "cosqa-train-9156", "doc": "hex ascii converter python escaped", "code": "def hex_escape(bin_str):\n  \"\"\"\n  Hex encode a binary string\n  \"\"\"\n  printable = string.ascii_letters + string.digits + string.punctuation + ' '\n  return ''.join(ch if ch in printable else r'0x{0:02x}'.format(ord(ch)) for ch in bin_str)", "code_tokens": "def hex_escape ( bin_str ) : printable = string . ascii_letters + string . digits + string . punctuation + ' ' return '' . join ( ch if ch in printable else r'0x{0:02x}' . format ( ord ( ch ) ) for ch in bin_str )", "docstring_tokens": "Hex encode a binary string", "label": 0}, {"idx": "cosqa-train-9157", "doc": "python int cast with default", "code": "def safe_int(val, default=None):\n    \"\"\"\n    Returns int() of val if val is not convertable to int use default\n    instead\n\n    :param val:\n    :param default:\n    \"\"\"\n\n    try:\n        val = int(val)\n    except (ValueError, TypeError):\n        val = default\n\n    return val", "code_tokens": "def safe_int ( val , default = None ) : try : val = int ( val ) except ( ValueError , TypeError ) : val = default return val", "docstring_tokens": "Returns int () of val if val is not convertable to int use default instead", "label": 1}, {"idx": "cosqa-train-9158", "doc": "hierarchical clustering python precomputed distance matrix", "code": "def allele_clusters(dists, t=0.025):\n    \"\"\"Flat clusters from distance matrix\n\n    Args:\n        dists (numpy.array): pdist distance matrix\n        t (float): fcluster (tree cutting) distance threshold\n\n    Returns:\n        dict of lists: cluster number to list of indices of distances in cluster\n    \"\"\"\n    clusters = fcluster(linkage(dists), 0.025, criterion='distance')\n    cluster_idx = defaultdict(list)\n    for idx, cl in enumerate(clusters):\n        cluster_idx[cl].append(idx)\n    return cluster_idx", "code_tokens": "def allele_clusters ( dists , t = 0.025 ) : clusters = fcluster ( linkage ( dists ) , 0.025 , criterion = 'distance' ) cluster_idx = defaultdict ( list ) for idx , cl in enumerate ( clusters ) : cluster_idx [ cl ] . append ( idx ) return cluster_idx", "docstring_tokens": "Flat clusters from distance matrix", "label": 0}, {"idx": "cosqa-train-9159", "doc": "python int round up or down", "code": "def py3round(number):\n    \"\"\"Unified rounding in all python versions.\"\"\"\n    if abs(round(number) - number) == 0.5:\n        return int(2.0 * round(number / 2.0))\n\n    return int(round(number))", "code_tokens": "def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )", "docstring_tokens": "Unified rounding in all python versions .", "label": 0}, {"idx": "cosqa-train-9160", "doc": "hot to get a file's size in python", "code": "def get_file_size(filename):\n    \"\"\"\n    Get the file size of a given file\n\n    :param filename: string: pathname of a file\n    :return: human readable filesize\n    \"\"\"\n    if os.path.isfile(filename):\n        return convert_size(os.path.getsize(filename))\n    return None", "code_tokens": "def get_file_size ( filename ) : if os . path . isfile ( filename ) : return convert_size ( os . path . getsize ( filename ) ) return None", "docstring_tokens": "Get the file size of a given file", "label": 1}, {"idx": "cosqa-train-9161", "doc": "python intersection of lines slope intercept", "code": "def nearest_intersection_idx(a, b):\n    \"\"\"Determine the index of the point just before two lines with common x values.\n\n    Parameters\n    ----------\n    a : array-like\n        1-dimensional array of y-values for line 1\n    b : array-like\n        1-dimensional array of y-values for line 2\n\n    Returns\n    -------\n        An array of indexes representing the index of the values\n        just before the intersection(s) of the two lines.\n\n    \"\"\"\n    # Difference in the two y-value sets\n    difference = a - b\n\n    # Determine the point just before the intersection of the lines\n    # Will return multiple points for multiple intersections\n    sign_change_idx, = np.nonzero(np.diff(np.sign(difference)))\n\n    return sign_change_idx", "code_tokens": "def nearest_intersection_idx ( a , b ) : # Difference in the two y-value sets difference = a - b # Determine the point just before the intersection of the lines # Will return multiple points for multiple intersections sign_change_idx , = np . nonzero ( np . diff ( np . sign ( difference ) ) ) return sign_change_idx", "docstring_tokens": "Determine the index of the point just before two lines with common x values .", "label": 1}, {"idx": "cosqa-train-9162", "doc": "hot to input complex numbers in python", "code": "def magnitude(X):\n    \"\"\"Magnitude of a complex matrix.\"\"\"\n    r = np.real(X)\n    i = np.imag(X)\n    return np.sqrt(r * r + i * i);", "code_tokens": "def magnitude ( X ) : r = np . real ( X ) i = np . imag ( X ) return np . sqrt ( r * r + i * i )", "docstring_tokens": "Magnitude of a complex matrix .", "label": 1}, {"idx": "cosqa-train-9163", "doc": "python ipaddress expand v6", "code": "def ip_address_list(ips):\n    \"\"\" IP address range validation and expansion. \"\"\"\n    # first, try it as a single IP address\n    try:\n        return ip_address(ips)\n    except ValueError:\n        pass\n    # then, consider it as an ipaddress.IPv[4|6]Network instance and expand it\n    return list(ipaddress.ip_network(u(ips)).hosts())", "code_tokens": "def ip_address_list ( ips ) : # first, try it as a single IP address try : return ip_address ( ips ) except ValueError : pass # then, consider it as an ipaddress.IPv[4|6]Network instance and expand it return list ( ipaddress . ip_network ( u ( ips ) ) . hosts ( ) )", "docstring_tokens": "IP address range validation and expansion .", "label": 0}, {"idx": "cosqa-train-9164", "doc": "how can i make python create a file", "code": "def write_file(filename, content):\n    \"\"\"Create the file with the given content\"\"\"\n    print 'Generating {0}'.format(filename)\n    with open(filename, 'wb') as out_f:\n        out_f.write(content)", "code_tokens": "def write_file ( filename , content ) : print 'Generating {0}' . format ( filename ) with open ( filename , 'wb' ) as out_f : out_f . write ( content )", "docstring_tokens": "Create the file with the given content", "label": 0}, {"idx": "cosqa-train-9165", "doc": "python is a value an int or str", "code": "def get_truetype(value):\n    \"\"\"Convert a string to a pythonized parameter.\"\"\"\n    if value in [\"true\", \"True\", \"y\", \"Y\", \"yes\"]:\n        return True\n    if value in [\"false\", \"False\", \"n\", \"N\", \"no\"]:\n        return False\n    if value.isdigit():\n        return int(value)\n    return str(value)", "code_tokens": "def get_truetype ( value ) : if value in [ \"true\" , \"True\" , \"y\" , \"Y\" , \"yes\" ] : return True if value in [ \"false\" , \"False\" , \"n\" , \"N\" , \"no\" ] : return False if value . isdigit ( ) : return int ( value ) return str ( value )", "docstring_tokens": "Convert a string to a pythonized parameter .", "label": 0}, {"idx": "cosqa-train-9166", "doc": "how can we get current month end date in python", "code": "def get_previous_month(self):\n        \"\"\"Returns date range for the previous full month.\"\"\"\n        end = utils.get_month_start() - relativedelta(days=1)\n        end = utils.to_datetime(end)\n        start = utils.get_month_start(end)\n        return start, end", "code_tokens": "def get_previous_month ( self ) : end = utils . get_month_start ( ) - relativedelta ( days = 1 ) end = utils . to_datetime ( end ) start = utils . get_month_start ( end ) return start , end", "docstring_tokens": "Returns date range for the previous full month .", "label": 0}, {"idx": "cosqa-train-9167", "doc": "python is not none list", "code": "def _not_none(items):\n    \"\"\"Whether the item is a placeholder or contains a placeholder.\"\"\"\n    if not isinstance(items, (tuple, list)):\n        items = (items,)\n    return all(item is not _none for item in items)", "code_tokens": "def _not_none ( items ) : if not isinstance ( items , ( tuple , list ) ) : items = ( items , ) return all ( item is not _none for item in items )", "docstring_tokens": "Whether the item is a placeholder or contains a placeholder .", "label": 0}, {"idx": "cosqa-train-9168", "doc": "how can you check if python is in path", "code": "def isPackage(file_path):\n    \"\"\"\n    Determine whether or not a given path is a (sub)package or not.\n    \"\"\"\n    return (os.path.isdir(file_path) and\n            os.path.isfile(os.path.join(file_path, '__init__.py')))", "code_tokens": "def isPackage ( file_path ) : return ( os . path . isdir ( file_path ) and os . path . isfile ( os . path . join ( file_path , '__init__.py' ) ) )", "docstring_tokens": "Determine whether or not a given path is a ( sub ) package or not .", "label": 1}, {"idx": "cosqa-train-9169", "doc": "python is not not none", "code": "def less_strict_bool(x):\n    \"\"\"Idempotent and None-safe version of strict_bool.\"\"\"\n    if x is None:\n        return False\n    elif x is True or x is False:\n        return x\n    else:\n        return strict_bool(x)", "code_tokens": "def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )", "docstring_tokens": "Idempotent and None - safe version of strict_bool .", "label": 1}, {"idx": "cosqa-train-9170", "doc": "how do i access an element of an array that is itself an array inpython", "code": "def poke_array(self, store, name, elemtype, elements, container, visited, _stack):\n        \"\"\"abstract method\"\"\"\n        raise NotImplementedError", "code_tokens": "def poke_array ( self , store , name , elemtype , elements , container , visited , _stack ) : raise NotImplementedError", "docstring_tokens": "abstract method", "label": 0}, {"idx": "cosqa-train-9171", "doc": "python is stdin a tty", "code": "def read_stdin():\n    \"\"\" Read text from stdin, and print a helpful message for ttys. \"\"\"\n    if sys.stdin.isatty() and sys.stdout.isatty():\n        print('\\nReading from stdin until end of file (Ctrl + D)...')\n\n    return sys.stdin.read()", "code_tokens": "def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )", "docstring_tokens": "Read text from stdin and print a helpful message for ttys .", "label": 1}, {"idx": "cosqa-train-9172", "doc": "how do i format a number to two decimals in python", "code": "def fixed(ctx, number, decimals=2, no_commas=False):\n    \"\"\"\n    Formats the given number in decimal format using a period and commas\n    \"\"\"\n    value = _round(ctx, number, decimals)\n    format_str = '{:f}' if no_commas else '{:,f}'\n    return format_str.format(value)", "code_tokens": "def fixed ( ctx , number , decimals = 2 , no_commas = False ) : value = _round ( ctx , number , decimals ) format_str = '{:f}' if no_commas else '{:,f}' return format_str . format ( value )", "docstring_tokens": "Formats the given number in decimal format using a period and commas", "label": 1}, {"idx": "cosqa-train-9173", "doc": "python items in alist that are not in the other", "code": "def __sub__(self, other):\n\t\t\"\"\"\n\t\tReturn a Cache containing the entries of self that are not in other.\n\t\t\"\"\"\n\t\treturn self.__class__([elem for elem in self if elem not in other])", "code_tokens": "def __sub__ ( self , other ) : return self . __class__ ( [ elem for elem in self if elem not in other ] )", "docstring_tokens": "Return a Cache containing the entries of self that are not in other .", "label": 1}, {"idx": "cosqa-train-9174", "doc": "how do i right justify my python list output", "code": "def add_ul(text, ul):\n    \"\"\"Adds an unordered list to the readme\"\"\"\n    text += \"\\n\"\n    for li in ul:\n        text += \"- \" + li + \"\\n\"\n    text += \"\\n\"\n\n    return text", "code_tokens": "def add_ul ( text , ul ) : text += \"\\n\" for li in ul : text += \"- \" + li + \"\\n\" text += \"\\n\" return text", "docstring_tokens": "Adds an unordered list to the readme", "label": 1}, {"idx": "cosqa-train-9175", "doc": "python iterate function call", "code": "def find_all(self, string, callback):\n\t\t\"\"\"\n\t\tWrapper on iter method, callback gets an iterator result\n\t\t\"\"\"\n\t\tfor index, output in self.iter(string):\n\t\t\tcallback(index, output)", "code_tokens": "def find_all ( self , string , callback ) : for index , output in self . iter ( string ) : callback ( index , output )", "docstring_tokens": "Wrapper on iter method callback gets an iterator result", "label": 1}, {"idx": "cosqa-train-9176", "doc": "how do i slice a list in python in constant itme", "code": "def iget_list_column_slice(list_, start=None, stop=None, stride=None):\n    \"\"\" iterator version of get_list_column \"\"\"\n    if isinstance(start, slice):\n        slice_ = start\n    else:\n        slice_ = slice(start, stop, stride)\n    return (row[slice_] for row in list_)", "code_tokens": "def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )", "docstring_tokens": "iterator version of get_list_column", "label": 1}, {"idx": "cosqa-train-9177", "doc": "python iterate over many regex sub", "code": "def _sub_patterns(patterns, text):\n    \"\"\"\n    Apply re.sub to bunch of (pattern, repl)\n    \"\"\"\n    for pattern, repl in patterns:\n        text = re.sub(pattern, repl, text)\n    return text", "code_tokens": "def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text", "docstring_tokens": "Apply re . sub to bunch of ( pattern repl )", "label": 1}, {"idx": "cosqa-train-9178", "doc": "how do i turn a python script into a callable function", "code": "def getFunction(self):\n        \"\"\"Called by remote workers. Useful to populate main module globals()\n        for interactive shells. Retrieves the serialized function.\"\"\"\n        return functionFactory(\n            self.code,\n            self.name,\n            self.defaults,\n            self.globals,\n            self.imports,\n        )", "code_tokens": "def getFunction ( self ) : return functionFactory ( self . code , self . name , self . defaults , self . globals , self . imports , )", "docstring_tokens": "Called by remote workers . Useful to populate main module globals () for interactive shells . Retrieves the serialized function .", "label": 1}, {"idx": "cosqa-train-9179", "doc": "python iterating in reverse order", "code": "def __reversed__(self):\n        \"\"\"\n        Return a reversed iterable over the items in the dictionary. Items are\n        iterated over in their reverse sort order.\n\n        Iterating views while adding or deleting entries in the dictionary may\n        raise a RuntimeError or fail to iterate over all entries.\n        \"\"\"\n        _dict = self._dict\n        return iter((key, _dict[key]) for key in reversed(self._list))", "code_tokens": "def __reversed__ ( self ) : _dict = self . _dict return iter ( ( key , _dict [ key ] ) for key in reversed ( self . _list ) )", "docstring_tokens": "Return a reversed iterable over the items in the dictionary . Items are iterated over in their reverse sort order .", "label": 1}, {"idx": "cosqa-train-9180", "doc": "how do you average the contents of a list in python", "code": "def mean(inlist):\n    \"\"\"\nReturns the arithematic mean of the values in the passed list.\nAssumes a '1D' list, but will function on the 1st dim of an array(!).\n\nUsage:   lmean(inlist)\n\"\"\"\n    sum = 0\n    for item in inlist:\n        sum = sum + item\n    return sum / float(len(inlist))", "code_tokens": "def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )", "docstring_tokens": "Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) .", "label": 0}, {"idx": "cosqa-train-9181", "doc": "python iterator get position", "code": "def index(self, elem):\n        \"\"\"Find the index of elem in the reversed iterator.\"\"\"\n        return _coconut.len(self._iter) - self._iter.index(elem) - 1", "code_tokens": "def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1", "docstring_tokens": "Find the index of elem in the reversed iterator .", "label": 1}, {"idx": "cosqa-train-9182", "doc": "how do you load numpy in python", "code": "def _openResources(self):\n        \"\"\" Uses numpy.load to open the underlying file\n        \"\"\"\n        arr = np.load(self._fileName, allow_pickle=ALLOW_PICKLE)\n        check_is_an_array(arr)\n        self._array = arr", "code_tokens": "def _openResources ( self ) : arr = np . load ( self . _fileName , allow_pickle = ALLOW_PICKLE ) check_is_an_array ( arr ) self . _array = arr", "docstring_tokens": "Uses numpy . load to open the underlying file", "label": 0}, {"idx": "cosqa-train-9183", "doc": "python iterator skip file", "code": "def _skip_frame(self):\n        \"\"\"Skip a single frame from the trajectory\"\"\"\n        size = self.read_size()\n        for i in range(size+1):\n            line = self._f.readline()\n            if len(line) == 0:\n                raise StopIteration", "code_tokens": "def _skip_frame ( self ) : size = self . read_size ( ) for i in range ( size + 1 ) : line = self . _f . readline ( ) if len ( line ) == 0 : raise StopIteration", "docstring_tokens": "Skip a single frame from the trajectory", "label": 1}, {"idx": "cosqa-train-9184", "doc": "python iterator through a file", "code": "def txt_line_iterator(path):\n  \"\"\"Iterate through lines of file.\"\"\"\n  with tf.gfile.Open(path) as f:\n    for line in f:\n      yield line.strip()", "code_tokens": "def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )", "docstring_tokens": "Iterate through lines of file .", "label": 1}, {"idx": "cosqa-train-9185", "doc": "how do you remove duplicate entries in a list in python", "code": "def unique(list):\n    \"\"\" Returns a copy of the list without duplicates.\n    \"\"\"\n    unique = []; [unique.append(x) for x in list if x not in unique]\n    return unique", "code_tokens": "def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique", "docstring_tokens": "Returns a copy of the list without duplicates .", "label": 1}, {"idx": "cosqa-train-9186", "doc": "python java stream equivalent", "code": "def load(file_object):\n  \"\"\"\n  Deserializes Java primitive data and objects serialized by ObjectOutputStream\n  from a file-like object.\n  \"\"\"\n  marshaller = JavaObjectUnmarshaller(file_object)\n  marshaller.add_transformer(DefaultObjectTransformer())\n  return marshaller.readObject()", "code_tokens": "def load ( file_object ) : marshaller = JavaObjectUnmarshaller ( file_object ) marshaller . add_transformer ( DefaultObjectTransformer ( ) ) return marshaller . readObject ( )", "docstring_tokens": "Deserializes Java primitive data and objects serialized by ObjectOutputStream from a file - like object .", "label": 0}, {"idx": "cosqa-train-9187", "doc": "how know if the box was selected in checkbox in python", "code": "def set_value(self, value):\n        \"\"\"Set value of the checkbox.\n\n        Parameters\n        ----------\n        value : bool\n            value for the checkbox\n\n        \"\"\"\n        if value:\n            self.setChecked(Qt.Checked)\n        else:\n            self.setChecked(Qt.Unchecked)", "code_tokens": "def set_value ( self , value ) : if value : self . setChecked ( Qt . Checked ) else : self . setChecked ( Qt . Unchecked )", "docstring_tokens": "Set value of the checkbox .", "label": 1}, {"idx": "cosqa-train-9188", "doc": "how set proxy for python", "code": "def enable_proxy(self, host, port):\n        \"\"\"Enable a default web proxy\"\"\"\n\n        self.proxy = [host, _number(port)]\n        self.proxy_enabled = True", "code_tokens": "def enable_proxy ( self , host , port ) : self . proxy = [ host , _number ( port ) ] self . proxy_enabled = True", "docstring_tokens": "Enable a default web proxy", "label": 1}, {"idx": "cosqa-train-9189", "doc": "python json dump order", "code": "def json_dumps(self, obj):\n        \"\"\"Serializer for consistency\"\"\"\n        return json.dumps(obj, sort_keys=True, indent=4, separators=(',', ': '))", "code_tokens": "def json_dumps ( self , obj ) : return json . dumps ( obj , sort_keys = True , indent = 4 , separators = ( ',' , ': ' ) )", "docstring_tokens": "Serializer for consistency", "label": 1}, {"idx": "cosqa-train-9190", "doc": "how similar is java to python", "code": "def java_version():\n    \"\"\"Call java and return version information.\n\n    :return unicode: Java version string\n    \"\"\"\n    result = subprocess.check_output(\n        [c.JAVA, '-version'], stderr=subprocess.STDOUT\n    )\n    first_line = result.splitlines()[0]\n    return first_line.decode()", "code_tokens": "def java_version ( ) : result = subprocess . check_output ( [ c . JAVA , '-version' ] , stderr = subprocess . STDOUT ) first_line = result . splitlines ( ) [ 0 ] return first_line . decode ( )", "docstring_tokens": "Call java and return version information .", "label": 1}, {"idx": "cosqa-train-9191", "doc": "python json load from file check file empty", "code": "def json_get_data(filename):\n    \"\"\"Get data from json file\n    \"\"\"\n    with open(filename) as fp:\n        json_data = json.load(fp)\n        return json_data\n\n    return False", "code_tokens": "def json_get_data ( filename ) : with open ( filename ) as fp : json_data = json . load ( fp ) return json_data return False", "docstring_tokens": "Get data from json file", "label": 1}, {"idx": "cosqa-train-9192", "doc": "how to 303 redirect python", "code": "def respond_redirect(self, location='/'):\n\t\t\"\"\"\n\t\tRespond to the client with a 301 message and redirect them with\n\t\ta Location header.\n\n\t\t:param str location: The new location to redirect the client to.\n\t\t\"\"\"\n\t\tself.send_response(301)\n\t\tself.send_header('Content-Length', 0)\n\t\tself.send_header('Location', location)\n\t\tself.end_headers()\n\t\treturn", "code_tokens": "def respond_redirect ( self , location = '/' ) : self . send_response ( 301 ) self . send_header ( 'Content-Length' , 0 ) self . send_header ( 'Location' , location ) self . end_headers ( ) return", "docstring_tokens": "Respond to the client with a 301 message and redirect them with a Location header .", "label": 1}, {"idx": "cosqa-train-9193", "doc": "python json timestamp to int", "code": "def _timestamp_to_json_row(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\n\n    This version returns floating-point seconds value used in row data.\n    \"\"\"\n    if isinstance(value, datetime.datetime):\n        value = _microseconds_from_datetime(value) * 1e-6\n    return value", "code_tokens": "def _timestamp_to_json_row ( value ) : if isinstance ( value , datetime . datetime ) : value = _microseconds_from_datetime ( value ) * 1e-6 return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 1}, {"idx": "cosqa-train-9194", "doc": "how to [rint without a new line python", "code": "def _screen(self, s, newline=False):\n        \"\"\"Print something on screen when self.verbose == True\"\"\"\n        if self.verbose:\n            if newline:\n                print(s)\n            else:\n                print(s, end=' ')", "code_tokens": "def _screen ( self , s , newline = False ) : if self . verbose : if newline : print ( s ) else : print ( s , end = ' ' )", "docstring_tokens": "Print something on screen when self . verbose == True", "label": 0}, {"idx": "cosqa-train-9195", "doc": "python judge file have exe permission", "code": "def chmod_add_excute(filename):\n        \"\"\"\n        Adds execute permission to file.\n        :param filename:\n        :return:\n        \"\"\"\n        st = os.stat(filename)\n        os.chmod(filename, st.st_mode | stat.S_IEXEC)", "code_tokens": "def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "docstring_tokens": "Adds execute permission to file . : param filename : : return :", "label": 1}, {"idx": "cosqa-train-9196", "doc": "how to access 2 last row of a list in python", "code": "def get_last_row(dbconn, tablename, n=1, uuid=None):\n    \"\"\"\n    Returns the last `n` rows in the table\n    \"\"\"\n    return fetch(dbconn, tablename, n, uuid, end=True)", "code_tokens": "def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )", "docstring_tokens": "Returns the last n rows in the table", "label": 0}, {"idx": "cosqa-train-9197", "doc": "python keras model save", "code": "def save_keras_definition(keras_model, path):\n    \"\"\"\n    Save a Keras model definition to JSON with given path\n    \"\"\"\n    model_json = keras_model.to_json()\n    with open(path, \"w\") as json_file:\n        json_file.write(model_json)", "code_tokens": "def save_keras_definition ( keras_model , path ) : model_json = keras_model . to_json ( ) with open ( path , \"w\" ) as json_file : json_file . write ( model_json )", "docstring_tokens": "Save a Keras model definition to JSON with given path", "label": 1}, {"idx": "cosqa-train-9198", "doc": "how to access all fields of structure in python", "code": "def fields(self):\n        \"\"\"Returns the list of field names of the model.\"\"\"\n        return (self.attributes.values() + self.lists.values()\n                + self.references.values())", "code_tokens": "def fields ( self ) : return ( self . attributes . values ( ) + self . lists . values ( ) + self . references . values ( ) )", "docstring_tokens": "Returns the list of field names of the model .", "label": 1}, {"idx": "cosqa-train-9199", "doc": "python kwargs with default value", "code": "def param (self, param, kwargs, default_value=False):\n        \"\"\"gets a param from kwargs, or uses a default_value. if found, it's\n        removed from kwargs\"\"\"\n        if param in kwargs:\n            value= kwargs[param]\n            del kwargs[param]\n        else:\n            value= default_value\n        setattr (self, param, value)", "code_tokens": "def param ( self , param , kwargs , default_value = False ) : if param in kwargs : value = kwargs [ param ] del kwargs [ param ] else : value = default_value setattr ( self , param , value )", "docstring_tokens": "gets a param from kwargs or uses a default_value . if found it s removed from kwargs", "label": 1}, {"idx": "cosqa-train-9200", "doc": "how to access bound method python", "code": "def Proxy(f):\n  \"\"\"A helper to create a proxy method in a class.\"\"\"\n\n  def Wrapped(self, *args):\n    return getattr(self, f)(*args)\n\n  return Wrapped", "code_tokens": "def Proxy ( f ) : def Wrapped ( self , * args ) : return getattr ( self , f ) ( * args ) return Wrapped", "docstring_tokens": "A helper to create a proxy method in a class .", "label": 1}, {"idx": "cosqa-train-9201", "doc": "python l2 norm array", "code": "def l2_norm(arr):\n    \"\"\"\n    The l2 norm of an array is is defined as: sqrt(||x||), where ||x|| is the\n    dot product of the vector.\n    \"\"\"\n    arr = np.asarray(arr)\n    return np.sqrt(np.dot(arr.ravel().squeeze(), arr.ravel().squeeze()))", "code_tokens": "def l2_norm ( arr ) : arr = np . asarray ( arr ) return np . sqrt ( np . dot ( arr . ravel ( ) . squeeze ( ) , arr . ravel ( ) . squeeze ( ) ) )", "docstring_tokens": "The l2 norm of an array is is defined as : sqrt ( ||x|| ) where ||x|| is the dot product of the vector .", "label": 1}, {"idx": "cosqa-train-9202", "doc": "how to acssess min using lambada in python", "code": "def SegmentMin(a, ids):\n    \"\"\"\n    Segmented min op.\n    \"\"\"\n    func = lambda idxs: np.amin(a[idxs], axis=0)\n    return seg_map(func, a, ids),", "code_tokens": "def SegmentMin ( a , ids ) : func = lambda idxs : np . amin ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,", "docstring_tokens": "Segmented min op .", "label": 1}, {"idx": "cosqa-train-9203", "doc": "python l2 norm of array", "code": "def l2_norm(arr):\n    \"\"\"\n    The l2 norm of an array is is defined as: sqrt(||x||), where ||x|| is the\n    dot product of the vector.\n    \"\"\"\n    arr = np.asarray(arr)\n    return np.sqrt(np.dot(arr.ravel().squeeze(), arr.ravel().squeeze()))", "code_tokens": "def l2_norm ( arr ) : arr = np . asarray ( arr ) return np . sqrt ( np . dot ( arr . ravel ( ) . squeeze ( ) , arr . ravel ( ) . squeeze ( ) ) )", "docstring_tokens": "The l2 norm of an array is is defined as : sqrt ( ||x|| ) where ||x|| is the dot product of the vector .", "label": 0}, {"idx": "cosqa-train-9204", "doc": "how to add a prefix to a list of strings in python", "code": "def prefix_list(self, prefix, values):\n        \"\"\"\n        Add a prefix to a list of values.\n        \"\"\"\n        return list(map(lambda value: prefix + \" \" + value, values))", "code_tokens": "def prefix_list ( self , prefix , values ) : return list ( map ( lambda value : prefix + \" \" + value , values ) )", "docstring_tokens": "Add a prefix to a list of values .", "label": 1}, {"idx": "cosqa-train-9205", "doc": "python lambda function with variable args", "code": "def make_lambda(call):\n    \"\"\"Wrap an AST Call node to lambda expression node.\n    call: ast.Call node\n    \"\"\"\n    empty_args = ast.arguments(args=[], vararg=None, kwarg=None, defaults=[])\n    return ast.Lambda(args=empty_args, body=call)", "code_tokens": "def make_lambda ( call ) : empty_args = ast . arguments ( args = [ ] , vararg = None , kwarg = None , defaults = [ ] ) return ast . Lambda ( args = empty_args , body = call )", "docstring_tokens": "Wrap an AST Call node to lambda expression node . call : ast . Call node", "label": 1}, {"idx": "cosqa-train-9206", "doc": "python lambda sort returns none", "code": "def _sort_lambda(sortedby='cpu_percent',\n                 sortedby_secondary='memory_percent'):\n    \"\"\"Return a sort lambda function for the sortedbykey\"\"\"\n    ret = None\n    if sortedby == 'io_counters':\n        ret = _sort_io_counters\n    elif sortedby == 'cpu_times':\n        ret = _sort_cpu_times\n    return ret", "code_tokens": "def _sort_lambda ( sortedby = 'cpu_percent' , sortedby_secondary = 'memory_percent' ) : ret = None if sortedby == 'io_counters' : ret = _sort_io_counters elif sortedby == 'cpu_times' : ret = _sort_cpu_times return ret", "docstring_tokens": "Return a sort lambda function for the sortedbykey", "label": 0}, {"idx": "cosqa-train-9207", "doc": "how to add entity in datastore python", "code": "def put(self, entity):\n    \"\"\"Registers entity to put to datastore.\n\n    Args:\n      entity: an entity or model instance to put.\n    \"\"\"\n    actual_entity = _normalize_entity(entity)\n    if actual_entity is None:\n      return self.ndb_put(entity)\n    self.puts.append(actual_entity)", "code_tokens": "def put ( self , entity ) : actual_entity = _normalize_entity ( entity ) if actual_entity is None : return self . ndb_put ( entity ) self . puts . append ( actual_entity )", "docstring_tokens": "Registers entity to put to datastore .", "label": 1}, {"idx": "cosqa-train-9208", "doc": "python lambda syntax example", "code": "def make_lambda(call):\n    \"\"\"Wrap an AST Call node to lambda expression node.\n    call: ast.Call node\n    \"\"\"\n    empty_args = ast.arguments(args=[], vararg=None, kwarg=None, defaults=[])\n    return ast.Lambda(args=empty_args, body=call)", "code_tokens": "def make_lambda ( call ) : empty_args = ast . arguments ( args = [ ] , vararg = None , kwarg = None , defaults = [ ] ) return ast . Lambda ( args = empty_args , body = call )", "docstring_tokens": "Wrap an AST Call node to lambda expression node . call : ast . Call node", "label": 1}, {"idx": "cosqa-train-9209", "doc": "python length of a table", "code": "def get_table_width(table):\n    \"\"\"\n    Gets the width of the table that would be printed.\n    :rtype: ``int``\n    \"\"\"\n    columns = transpose_table(prepare_rows(table))\n    widths = [max(len(cell) for cell in column) for column in columns]\n    return len('+' + '|'.join('-' * (w + 2) for w in widths) + '+')", "code_tokens": "def get_table_width ( table ) : columns = transpose_table ( prepare_rows ( table ) ) widths = [ max ( len ( cell ) for cell in column ) for column in columns ] return len ( '+' + '|' . join ( '-' * ( w + 2 ) for w in widths ) + '+' )", "docstring_tokens": "Gets the width of the table that would be printed . : rtype : int", "label": 0}, {"idx": "cosqa-train-9210", "doc": "how to add two matrix in python", "code": "def __add__(self,other):\n        \"\"\"\n            If the number of columns matches, we can concatenate two LabeldMatrices\n            with the + operator.\n        \"\"\"\n        assert self.matrix.shape[1] == other.matrix.shape[1]\n        return LabeledMatrix(np.concatenate([self.matrix,other.matrix],axis=0),self.labels)", "code_tokens": "def __add__ ( self , other ) : assert self . matrix . shape [ 1 ] == other . matrix . shape [ 1 ] return LabeledMatrix ( np . concatenate ( [ self . matrix , other . matrix ] , axis = 0 ) , self . labels )", "docstring_tokens": "If the number of columns matches we can concatenate two LabeldMatrices with the + operator .", "label": 0}, {"idx": "cosqa-train-9211", "doc": "python levenshtein distance performance", "code": "def levenshtein_distance_metric(a, b):\n    \"\"\" 1 - farthest apart (same number of words, all diff). 0 - same\"\"\"\n    return (levenshtein_distance(a, b) / (2.0 * max(len(a), len(b), 1)))", "code_tokens": "def levenshtein_distance_metric ( a , b ) : return ( levenshtein_distance ( a , b ) / ( 2.0 * max ( len ( a ) , len ( b ) , 1 ) ) )", "docstring_tokens": "1 - farthest apart ( same number of words all diff ) . 0 - same", "label": 0}, {"idx": "cosqa-train-9212", "doc": "how to avoid python auto spacing", "code": "def indent(txt, spacing=4):\n    \"\"\"\n    Indent given text using custom spacing, default is set to 4.\n    \"\"\"\n    return prefix(str(txt), ''.join([' ' for _ in range(spacing)]))", "code_tokens": "def indent ( txt , spacing = 4 ) : return prefix ( str ( txt ) , '' . join ( [ ' ' for _ in range ( spacing ) ] ) )", "docstring_tokens": "Indent given text using custom spacing default is set to 4 .", "label": 1}, {"idx": "cosqa-train-9213", "doc": "python limit decimals for created variable", "code": "def limitReal(x, max_denominator=1000000):\n    \"\"\"Creates an pysmt Real constant from x.\n\n    Args:\n        x (number): A number to be cast to a pysmt constant.\n        max_denominator (int, optional): The maximum size of the denominator.\n            Default 1000000.\n\n    Returns:\n        A Real constant with the given value and the denominator limited.\n\n    \"\"\"\n    f = Fraction(x).limit_denominator(max_denominator)\n    return Real((f.numerator, f.denominator))", "code_tokens": "def limitReal ( x , max_denominator = 1000000 ) : f = Fraction ( x ) . limit_denominator ( max_denominator ) return Real ( ( f . numerator , f . denominator ) )", "docstring_tokens": "Creates an pysmt Real constant from x .", "label": 0}, {"idx": "cosqa-train-9214", "doc": "how to bin data for histogram python", "code": "def inverseHistogram(hist, bin_range):\n    \"\"\"sample data from given histogram and min, max values within range\n\n    Returns:\n        np.array: data that would create the same histogram as given\n    \"\"\"\n    data = hist.astype(float) / np.min(hist[np.nonzero(hist)])\n    new_data = np.empty(shape=np.sum(data, dtype=int))\n    i = 0\n    xvals = np.linspace(bin_range[0], bin_range[1], len(data))\n    for d, x in zip(data, xvals):\n        new_data[i:i + d] = x\n        i += int(d)\n    return new_data", "code_tokens": "def inverseHistogram ( hist , bin_range ) : data = hist . astype ( float ) / np . min ( hist [ np . nonzero ( hist ) ] ) new_data = np . empty ( shape = np . sum ( data , dtype = int ) ) i = 0 xvals = np . linspace ( bin_range [ 0 ] , bin_range [ 1 ] , len ( data ) ) for d , x in zip ( data , xvals ) : new_data [ i : i + d ] = x i += int ( d ) return new_data", "docstring_tokens": "sample data from given histogram and min max values within range", "label": 1}, {"idx": "cosqa-train-9215", "doc": "python list behaving as array", "code": "def _listify(collection):\n        \"\"\"This is a workaround where Collections are no longer iterable\n        when using JPype.\"\"\"\n        new_list = []\n        for index in range(len(collection)):\n            new_list.append(collection[index])\n        return new_list", "code_tokens": "def _listify ( collection ) : new_list = [ ] for index in range ( len ( collection ) ) : new_list . append ( collection [ index ] ) return new_list", "docstring_tokens": "This is a workaround where Collections are no longer iterable when using JPype .", "label": 1}, {"idx": "cosqa-train-9216", "doc": "how to build a graph from a wighted adjacency matrix in python", "code": "def to_bipartite_matrix(A):\n    \"\"\"Returns the adjacency matrix of a bipartite graph whose biadjacency\n    matrix is `A`.\n\n    `A` must be a NumPy array.\n\n    If `A` has **m** rows and **n** columns, then the returned matrix has **m +\n    n** rows and columns.\n\n    \"\"\"\n    m, n = A.shape\n    return four_blocks(zeros(m, m), A, A.T, zeros(n, n))", "code_tokens": "def to_bipartite_matrix ( A ) : m , n = A . shape return four_blocks ( zeros ( m , m ) , A , A . T , zeros ( n , n ) )", "docstring_tokens": "Returns the adjacency matrix of a bipartite graph whose biadjacency matrix is A .", "label": 1}, {"idx": "cosqa-train-9217", "doc": "python list not duplicate", "code": "def dedupe_list(l):\n    \"\"\"Remove duplicates from a list preserving the order.\n\n    We might be tempted to use the list(set(l)) idiom, but it doesn't preserve\n    the order, which hinders testability and does not work for lists with\n    unhashable elements.\n    \"\"\"\n    result = []\n\n    for el in l:\n        if el not in result:\n            result.append(el)\n\n    return result", "code_tokens": "def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result", "docstring_tokens": "Remove duplicates from a list preserving the order .", "label": 1}, {"idx": "cosqa-train-9218", "doc": "how to calculate distance between two points on python 3", "code": "def _distance(coord1, coord2):\n    \"\"\"\n    Return the distance between two points, `coord1` and `coord2`. These\n    parameters are assumed to be (x, y) tuples.\n    \"\"\"\n    xdist = coord1[0] - coord2[0]\n    ydist = coord1[1] - coord2[1]\n    return sqrt(xdist*xdist + ydist*ydist)", "code_tokens": "def _distance ( coord1 , coord2 ) : xdist = coord1 [ 0 ] - coord2 [ 0 ] ydist = coord1 [ 1 ] - coord2 [ 1 ] return sqrt ( xdist * xdist + ydist * ydist )", "docstring_tokens": "Return the distance between two points coord1 and coord2 . These parameters are assumed to be ( x y ) tuples .", "label": 1}, {"idx": "cosqa-train-9219", "doc": "python list of a size instantiate", "code": "def __init__(self, capacity=10):\n        \"\"\"\n        Initialize python List with capacity of 10 or user given input.\n        Python List type is a dynamic array, so we have to restrict its\n        dynamic nature to make it work like a static array.\n        \"\"\"\n        super().__init__()\n        self._array = [None] * capacity\n        self._front = 0\n        self._rear = 0", "code_tokens": "def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0", "docstring_tokens": "Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array .", "label": 0}, {"idx": "cosqa-train-9220", "doc": "how to call a float object in python", "code": "def floor(self):\n    \"\"\"Round `x` and `y` down to integers.\"\"\"\n    return Point(int(math.floor(self.x)), int(math.floor(self.y)))", "code_tokens": "def floor ( self ) : return Point ( int ( math . floor ( self . x ) ) , int ( math . floor ( self . y ) ) )", "docstring_tokens": "Round x and y down to integers .", "label": 1}, {"idx": "cosqa-train-9221", "doc": "python list of indices of a matrix", "code": "def get_inputs_from_cm(index, cm):\n    \"\"\"Return indices of inputs to the node with the given index.\"\"\"\n    return tuple(i for i in range(cm.shape[0]) if cm[i][index])", "code_tokens": "def get_inputs_from_cm ( index , cm ) : return tuple ( i for i in range ( cm . shape [ 0 ] ) if cm [ i ] [ index ] )", "docstring_tokens": "Return indices of inputs to the node with the given index .", "label": 1}, {"idx": "cosqa-train-9222", "doc": "how to call a list element into a string python", "code": "def _make_cmd_list(cmd_list):\n    \"\"\"\n    Helper function to easily create the proper json formated string from a list of strs\n    :param cmd_list: list of strings\n    :return: str json formatted\n    \"\"\"\n    cmd = ''\n    for i in cmd_list:\n        cmd = cmd + '\"' + i + '\",'\n    cmd = cmd[:-1]\n    return cmd", "code_tokens": "def _make_cmd_list ( cmd_list ) : cmd = '' for i in cmd_list : cmd = cmd + '\"' + i + '\",' cmd = cmd [ : - 1 ] return cmd", "docstring_tokens": "Helper function to easily create the proper json formated string from a list of strs : param cmd_list : list of strings : return : str json formatted", "label": 0}, {"idx": "cosqa-train-9223", "doc": "python list of lists to tab delimited", "code": "def linedelimited (inlist,delimiter):\n    \"\"\"\nReturns a string composed of elements in inlist, with each element\nseparated by 'delimiter.'  Used by function writedelimited.  Use '\\t'\nfor tab-delimiting.\n\nUsage:   linedelimited (inlist,delimiter)\n\"\"\"\n    outstr = ''\n    for item in inlist:\n        if type(item) != StringType:\n            item = str(item)\n        outstr = outstr + item + delimiter\n    outstr = outstr[0:-1]\n    return outstr", "code_tokens": "def linedelimited ( inlist , delimiter ) : outstr = '' for item in inlist : if type ( item ) != StringType : item = str ( item ) outstr = outstr + item + delimiter outstr = outstr [ 0 : - 1 ] return outstr", "docstring_tokens": "Returns a string composed of elements in inlist with each element separated by delimiter . Used by function writedelimited . Use \\ t for tab - delimiting .", "label": 0}, {"idx": "cosqa-train-9224", "doc": "how to call a python virtual env using shebang", "code": "def vsh(cmd, *args, **kw):\n    \"\"\" Execute a command installed into the active virtualenv.\n    \"\"\"\n    args = '\" \"'.join(i.replace('\"', r'\\\"') for i in args)\n    easy.sh('\"%s\" \"%s\"' % (venv_bin(cmd), args))", "code_tokens": "def vsh ( cmd , * args , * * kw ) : args = '\" \"' . join ( i . replace ( '\"' , r'\\\"' ) for i in args ) easy . sh ( '\"%s\" \"%s\"' % ( venv_bin ( cmd ) , args ) )", "docstring_tokens": "Execute a command installed into the active virtualenv .", "label": 0}, {"idx": "cosqa-train-9225", "doc": "python list select top and bottom", "code": "def _top(self):\n        \"\"\" g \"\"\"\n        # Goto top of the list\n        self.top.body.focus_position = 2 if self.compact is False else 0\n        self.top.keypress(self.size, \"\")", "code_tokens": "def _top ( self ) : # Goto top of the list self . top . body . focus_position = 2 if self . compact is False else 0 self . top . keypress ( self . size , \"\" )", "docstring_tokens": "g", "label": 0}, {"idx": "cosqa-train-9226", "doc": "how to call help for method in python", "code": "def _help():\n    \"\"\" Display both SQLAlchemy and Python help statements \"\"\"\n\n    statement = '%s%s' % (shelp, phelp % ', '.join(cntx_.keys()))\n    print statement.strip()", "code_tokens": "def _help ( ) : statement = '%s%s' % ( shelp , phelp % ', ' . join ( cntx_ . keys ( ) ) ) print statement . strip ( )", "docstring_tokens": "Display both SQLAlchemy and Python help statements", "label": 0}, {"idx": "cosqa-train-9227", "doc": "python list the nearest", "code": "def index_nearest(value, array):\n    \"\"\"\n    expects a _n.array\n    returns the global minimum of (value-array)^2\n    \"\"\"\n\n    a = (array-value)**2\n    return index(a.min(), a)", "code_tokens": "def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )", "docstring_tokens": "expects a _n . array returns the global minimum of ( value - array ) ^2", "label": 1}, {"idx": "cosqa-train-9228", "doc": "how to cast a nontype to int in python", "code": "def safe_int_conv(number):\n    \"\"\"Safely convert a single number to integer.\"\"\"\n    try:\n        return int(np.array(number).astype(int, casting='safe'))\n    except TypeError:\n        raise ValueError('cannot safely convert {} to integer'.format(number))", "code_tokens": "def safe_int_conv ( number ) : try : return int ( np . array ( number ) . astype ( int , casting = 'safe' ) ) except TypeError : raise ValueError ( 'cannot safely convert {} to integer' . format ( number ) )", "docstring_tokens": "Safely convert a single number to integer .", "label": 1}, {"idx": "cosqa-train-9229", "doc": "python list to dict with list of keys", "code": "def list_of_lists_to_dict(l):\n    \"\"\" Convert list of key,value lists to dict\n\n    [['id', 1], ['id', 2], ['id', 3], ['foo': 4]]\n    {'id': [1, 2, 3], 'foo': [4]}\n    \"\"\"\n    d = {}\n    for key, val in l:\n        d.setdefault(key, []).append(val)\n    return d", "code_tokens": "def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d", "docstring_tokens": "Convert list of key value lists to dict", "label": 1}, {"idx": "cosqa-train-9230", "doc": "how to cast a string to int python", "code": "def get_number(s, cast=int):\n    \"\"\"\n    Try to get a number out of a string, and cast it.\n    \"\"\"\n    import string\n    d = \"\".join(x for x in str(s) if x in string.digits)\n    return cast(d)", "code_tokens": "def get_number ( s , cast = int ) : import string d = \"\" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )", "docstring_tokens": "Try to get a number out of a string and cast it .", "label": 0}, {"idx": "cosqa-train-9231", "doc": "python list to ordered dictionary", "code": "def format_result(input):\n        \"\"\"From: http://stackoverflow.com/questions/13062300/convert-a-dict-to-sorted-dict-in-python\n        \"\"\"\n        items = list(iteritems(input))\n        return OrderedDict(sorted(items, key=lambda x: x[0]))", "code_tokens": "def format_result ( input ) : items = list ( iteritems ( input ) ) return OrderedDict ( sorted ( items , key = lambda x : x [ 0 ] ) )", "docstring_tokens": "From : http : // stackoverflow . com / questions / 13062300 / convert - a - dict - to - sorted - dict - in - python", "label": 0}, {"idx": "cosqa-train-9232", "doc": "how to change a screen pixel in python", "code": "def update_screen(self):\n        \"\"\"Refresh the screen. You don't need to override this except to update only small portins of the screen.\"\"\"\n        self.clock.tick(self.FPS)\n        pygame.display.update()", "code_tokens": "def update_screen ( self ) : self . clock . tick ( self . FPS ) pygame . display . update ( )", "docstring_tokens": "Refresh the screen . You don t need to override this except to update only small portins of the screen .", "label": 1}, {"idx": "cosqa-train-9233", "doc": "python list to string comma delimited", "code": "def list_to_csv(value):\n    \"\"\"\n    Converts list to string with comma separated values. For string is no-op.\n    \"\"\"\n    if isinstance(value, (list, tuple, set)):\n        value = \",\".join(value)\n    return value", "code_tokens": "def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = \",\" . join ( value ) return value", "docstring_tokens": "Converts list to string with comma separated values . For string is no - op .", "label": 0}, {"idx": "cosqa-train-9234", "doc": "how to change a variable from a string to a number in python", "code": "def str_to_num(str_value):\n        \"\"\"Convert str_value to an int or a float, depending on the\n        numeric value represented by str_value.\n\n        \"\"\"\n        str_value = str(str_value)\n        try:\n            return int(str_value)\n        except ValueError:\n            return float(str_value)", "code_tokens": "def str_to_num ( str_value ) : str_value = str ( str_value ) try : return int ( str_value ) except ValueError : return float ( str_value )", "docstring_tokens": "Convert str_value to an int or a float depending on the numeric value represented by str_value .", "label": 1}, {"idx": "cosqa-train-9235", "doc": "python listing all enum values", "code": "def items(self):\n    \"\"\"Return a list of the (name, value) pairs of the enum.\n\n    These are returned in the order they were defined in the .proto file.\n    \"\"\"\n    return [(value_descriptor.name, value_descriptor.number)\n            for value_descriptor in self._enum_type.values]", "code_tokens": "def items ( self ) : return [ ( value_descriptor . name , value_descriptor . number ) for value_descriptor in self . _enum_type . values ]", "docstring_tokens": "Return a list of the ( name value ) pairs of the enum .", "label": 0}, {"idx": "cosqa-train-9236", "doc": "how to change aspect ratio of image with python", "code": "def resize_image_to_fit_width(image, dest_w):\n    \"\"\"\n    Resize and image to fit the passed in width, keeping the aspect ratio the same\n\n    :param image: PIL.Image\n    :param dest_w: The desired width\n    \"\"\"\n    scale_factor = dest_w / image.size[0]\n    dest_h = image.size[1] * scale_factor\n    \n    scaled_image = image.resize((int(dest_w), int(dest_h)), PIL.Image.ANTIALIAS)\n\n    return scaled_image", "code_tokens": "def resize_image_to_fit_width ( image , dest_w ) : scale_factor = dest_w / image . size [ 0 ] dest_h = image . size [ 1 ] * scale_factor scaled_image = image . resize ( ( int ( dest_w ) , int ( dest_h ) ) , PIL . Image . ANTIALIAS ) return scaled_image", "docstring_tokens": "Resize and image to fit the passed in width keeping the aspect ratio the same", "label": 1}, {"idx": "cosqa-train-9237", "doc": "python listing sqlite tables", "code": "def get_tablenames(cur):\n    \"\"\" Conveinience: \"\"\"\n    cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n    tablename_list_ = cur.fetchall()\n    tablename_list = [str(tablename[0]) for tablename in tablename_list_ ]\n    return tablename_list", "code_tokens": "def get_tablenames ( cur ) : cur . execute ( \"SELECT name FROM sqlite_master WHERE type='table'\" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list", "docstring_tokens": "Conveinience :", "label": 1}, {"idx": "cosqa-train-9238", "doc": "how to change case in a python char", "code": "def to_snake_case(name):\n    \"\"\" Given a name in camelCase return in snake_case \"\"\"\n    s1 = FIRST_CAP_REGEX.sub(r'\\1_\\2', name)\n    return ALL_CAP_REGEX.sub(r'\\1_\\2', s1).lower()", "code_tokens": "def to_snake_case ( name ) : s1 = FIRST_CAP_REGEX . sub ( r'\\1_\\2' , name ) return ALL_CAP_REGEX . sub ( r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Given a name in camelCase return in snake_case", "label": 1}, {"idx": "cosqa-train-9239", "doc": "python load image into tensorflow", "code": "def decode_example(self, example):\n    \"\"\"Reconstruct the image from the tf example.\"\"\"\n    img = tf.image.decode_image(\n        example, channels=self._shape[-1], dtype=tf.uint8)\n    img.set_shape(self._shape)\n    return img", "code_tokens": "def decode_example ( self , example ) : img = tf . image . decode_image ( example , channels = self . _shape [ - 1 ] , dtype = tf . uint8 ) img . set_shape ( self . _shape ) return img", "docstring_tokens": "Reconstruct the image from the tf example .", "label": 1}, {"idx": "cosqa-train-9240", "doc": "how to change code color in python", "code": "def stringc(text, color):\n    \"\"\"\n    Return a string with terminal colors.\n    \"\"\"\n    if has_colors:\n        text = str(text)\n\n        return \"\\033[\"+codeCodes[color]+\"m\"+text+\"\\033[0m\"\n    else:\n        return text", "code_tokens": "def stringc ( text , color ) : if has_colors : text = str ( text ) return \"\\033[\" + codeCodes [ color ] + \"m\" + text + \"\\033[0m\" else : return text", "docstring_tokens": "Return a string with terminal colors .", "label": 1}, {"idx": "cosqa-train-9241", "doc": "python load object from text file", "code": "def loads(s, model=None, parser=None):\n    \"\"\"Deserialize s (a str) to a Python object.\"\"\"\n    with StringIO(s) as f:\n        return load(f, model=model, parser=parser)", "code_tokens": "def loads ( s , model = None , parser = None ) : with StringIO ( s ) as f : return load ( f , model = model , parser = parser )", "docstring_tokens": "Deserialize s ( a str ) to a Python object .", "label": 1}, {"idx": "cosqa-train-9242", "doc": "how to change column values with boolean values in python", "code": "def _check_and_convert_bools(self):\n        \"\"\"Replace boolean variables by the characters 'F'/'T'\n        \"\"\"\n        replacements = {\n            True: 'T',\n            False: 'F',\n        }\n\n        for key in self.bools:\n            if isinstance(self[key], bool):\n                self[key] = replacements[self[key]]", "code_tokens": "def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]", "docstring_tokens": "Replace boolean variables by the characters F / T", "label": 0}, {"idx": "cosqa-train-9243", "doc": "python log base somthing else", "code": "def info(self, text):\n\t\t\"\"\" Ajout d'un message de log de type INFO \"\"\"\n\t\tself.logger.info(\"{}{}\".format(self.message_prefix, text))", "code_tokens": "def info ( self , text ) : self . logger . info ( \"{}{}\" . format ( self . message_prefix , text ) )", "docstring_tokens": "Ajout d un message de log de type INFO", "label": 0}, {"idx": "cosqa-train-9244", "doc": "how to change data type to int in python", "code": "def robust_int(v):\n    \"\"\"Parse an int robustly, ignoring commas and other cruft. \"\"\"\n\n    if isinstance(v, int):\n        return v\n\n    if isinstance(v, float):\n        return int(v)\n\n    v = str(v).replace(',', '')\n\n    if not v:\n        return None\n\n    return int(v)", "code_tokens": "def robust_int ( v ) : if isinstance ( v , int ) : return v if isinstance ( v , float ) : return int ( v ) v = str ( v ) . replace ( ',' , '' ) if not v : return None return int ( v )", "docstring_tokens": "Parse an int robustly ignoring commas and other cruft .", "label": 1}, {"idx": "cosqa-train-9245", "doc": "python logger is enabled for", "code": "def logger(message, level=10):\n    \"\"\"Handle logging.\"\"\"\n    logging.getLogger(__name__).log(level, str(message))", "code_tokens": "def logger ( message , level = 10 ) : logging . getLogger ( __name__ ) . log ( level , str ( message ) )", "docstring_tokens": "Handle logging .", "label": 1}, {"idx": "cosqa-train-9246", "doc": "how to change file extension in python", "code": "def lower_ext(abspath):\n    \"\"\"Convert file extension to lowercase.\n    \"\"\"\n    fname, ext = os.path.splitext(abspath)\n    return fname + ext.lower()", "code_tokens": "def lower_ext ( abspath ) : fname , ext = os . path . splitext ( abspath ) return fname + ext . lower ( )", "docstring_tokens": "Convert file extension to lowercase .", "label": 0}, {"idx": "cosqa-train-9247", "doc": "python logging format without newline", "code": "def write(self, text):\n        \"\"\"Write text. An additional attribute terminator with a value of\n           None is added to the logging record to indicate that StreamHandler\n           should not add a newline.\"\"\"\n        self.logger.log(self.loglevel, text, extra={'terminator': None})", "code_tokens": "def write ( self , text ) : self . logger . log ( self . loglevel , text , extra = { 'terminator' : None } )", "docstring_tokens": "Write text . An additional attribute terminator with a value of None is added to the logging record to indicate that StreamHandler should not add a newline .", "label": 0}, {"idx": "cosqa-train-9248", "doc": "how to change from float64 to float32 python", "code": "def _maybe_cast_to_float64(da):\n    \"\"\"Cast DataArrays to np.float64 if they are of type np.float32.\n\n    Parameters\n    ----------\n    da : xr.DataArray\n        Input DataArray\n\n    Returns\n    -------\n    DataArray\n    \"\"\"\n    if da.dtype == np.float32:\n        logging.warning('Datapoints were stored using the np.float32 datatype.'\n                        'For accurate reduction operations using bottleneck, '\n                        'datapoints are being cast to the np.float64 datatype.'\n                        ' For more information see: https://github.com/pydata/'\n                        'xarray/issues/1346')\n        return da.astype(np.float64)\n    else:\n        return da", "code_tokens": "def _maybe_cast_to_float64 ( da ) : if da . dtype == np . float32 : logging . warning ( 'Datapoints were stored using the np.float32 datatype.' 'For accurate reduction operations using bottleneck, ' 'datapoints are being cast to the np.float64 datatype.' ' For more information see: https://github.com/pydata/' 'xarray/issues/1346' ) return da . astype ( np . float64 ) else : return da", "docstring_tokens": "Cast DataArrays to np . float64 if they are of type np . float32 .", "label": 1}, {"idx": "cosqa-train-9249", "doc": "python loop through proxies request", "code": "def load(self):\n        \"\"\"Load proxy list from configured proxy source\"\"\"\n        self._list = self._source.load()\n        self._list_iter = itertools.cycle(self._list)", "code_tokens": "def load ( self ) : self . _list = self . _source . load ( ) self . _list_iter = itertools . cycle ( self . _list )", "docstring_tokens": "Load proxy list from configured proxy source", "label": 1}, {"idx": "cosqa-train-9250", "doc": "how to change isexecutable in linux python", "code": "def set_executable(filename):\n    \"\"\"Set the exectuable bit on the given filename\"\"\"\n    st = os.stat(filename)\n    os.chmod(filename, st.st_mode | stat.S_IEXEC)", "code_tokens": "def set_executable ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "docstring_tokens": "Set the exectuable bit on the given filename", "label": 1}, {"idx": "cosqa-train-9251", "doc": "python loop through self attributes", "code": "def dict_self(self):\n        \"\"\"Return the self object attributes not inherited as dict.\"\"\"\n        return {k: v for k, v in self.__dict__.items() if k in FSM_ATTRS}", "code_tokens": "def dict_self ( self ) : return { k : v for k , v in self . __dict__ . items ( ) if k in FSM_ATTRS }", "docstring_tokens": "Return the self object attributes not inherited as dict .", "label": 1}, {"idx": "cosqa-train-9252", "doc": "how to change the f pointer in a file in python", "code": "def writefile(openedfile, newcontents):\n    \"\"\"Set the contents of a file.\"\"\"\n    openedfile.seek(0)\n    openedfile.truncate()\n    openedfile.write(newcontents)", "code_tokens": "def writefile ( openedfile , newcontents ) : openedfile . seek ( 0 ) openedfile . truncate ( ) openedfile . write ( newcontents )", "docstring_tokens": "Set the contents of a file .", "label": 1}, {"idx": "cosqa-train-9253", "doc": "python lower case command", "code": "def to_snake_case(text):\n    \"\"\"Convert to snake case.\n\n    :param str text:\n    :rtype: str\n    :return:\n    \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def to_snake_case ( text ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert to snake case .", "label": 1}, {"idx": "cosqa-train-9254", "doc": "how to change the letter case in python", "code": "def decamelise(text):\n    \"\"\"Convert CamelCase to lower_and_underscore.\"\"\"\n    s = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s).lower()", "code_tokens": "def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s ) . lower ( )", "docstring_tokens": "Convert CamelCase to lower_and_underscore .", "label": 1}, {"idx": "cosqa-train-9255", "doc": "python lxml get node text", "code": "def _extract_node_text(node):\n    \"\"\"Extract text from a given lxml node.\"\"\"\n\n    texts = map(\n        six.text_type.strip, map(six.text_type, map(unescape, node.xpath(\".//text()\")))\n    )\n    return \" \".join(text for text in texts if text)", "code_tokens": "def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( \".//text()\" ) ) ) ) return \" \" . join ( text for text in texts if text )", "docstring_tokens": "Extract text from a given lxml node .", "label": 0}, {"idx": "cosqa-train-9256", "doc": "how to check all elements are same in list python", "code": "def _check_elements_equal(lst):\n    \"\"\"\n    Returns true if all of the elements in the list are equal.\n    \"\"\"\n    assert isinstance(lst, list), \"Input value must be a list.\"\n    return not lst or lst.count(lst[0]) == len(lst)", "code_tokens": "def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , \"Input value must be a list.\" return not lst or lst . count ( lst [ 0 ] ) == len ( lst )", "docstring_tokens": "Returns true if all of the elements in the list are equal .", "label": 0}, {"idx": "cosqa-train-9257", "doc": "python mac clipboard contents", "code": "def paste(cmd=paste_cmd, stdout=PIPE):\n    \"\"\"Returns system clipboard contents.\n    \"\"\"\n    return Popen(cmd, stdout=stdout).communicate()[0].decode('utf-8')", "code_tokens": "def paste ( cmd = paste_cmd , stdout = PIPE ) : return Popen ( cmd , stdout = stdout ) . communicate ( ) [ 0 ] . decode ( 'utf-8' )", "docstring_tokens": "Returns system clipboard contents .", "label": 1}, {"idx": "cosqa-train-9258", "doc": "how to check data type of a variable in python", "code": "def autoconvert(string):\n    \"\"\"Try to convert variables into datatypes.\"\"\"\n    for fn in (boolify, int, float):\n        try:\n            return fn(string)\n        except ValueError:\n            pass\n    return string", "code_tokens": "def autoconvert ( string ) : for fn in ( boolify , int , float ) : try : return fn ( string ) except ValueError : pass return string", "docstring_tokens": "Try to convert variables into datatypes .", "label": 0}, {"idx": "cosqa-train-9259", "doc": "python mainwindow close event", "code": "def closeEvent(self, event):\n        \"\"\" Called when closing this window.\n        \"\"\"\n        logger.debug(\"closeEvent\")\n        self.argosApplication.saveSettingsIfNeeded()\n        self.finalize()\n        self.argosApplication.removeMainWindow(self)\n        event.accept()\n        logger.debug(\"closeEvent accepted\")", "code_tokens": "def closeEvent ( self , event ) : logger . debug ( \"closeEvent\" ) self . argosApplication . saveSettingsIfNeeded ( ) self . finalize ( ) self . argosApplication . removeMainWindow ( self ) event . accept ( ) logger . debug ( \"closeEvent accepted\" )", "docstring_tokens": "Called when closing this window .", "label": 1}, {"idx": "cosqa-train-9260", "doc": "python make a cumulative sum of a list", "code": "def cumsum(inlist):\n    \"\"\"\nReturns a list consisting of the cumulative sum of the items in the\npassed list.\n\nUsage:   lcumsum(inlist)\n\"\"\"\n    newlist = copy.deepcopy(inlist)\n    for i in range(1, len(newlist)):\n        newlist[i] = newlist[i] + newlist[i - 1]\n    return newlist", "code_tokens": "def cumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist", "docstring_tokens": "Returns a list consisting of the cumulative sum of the items in the passed list .", "label": 1}, {"idx": "cosqa-train-9261", "doc": "how to check for duplicate characters in a python string", "code": "def first_unique_char(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if (len(s) == 1):\n        return 0\n    ban = []\n    for i in range(len(s)):\n        if all(s[i] != s[k] for k in range(i + 1, len(s))) == True and s[i] not in ban:\n            return i\n        else:\n            ban.append(s[i])\n    return -1", "code_tokens": "def first_unique_char ( s ) : if ( len ( s ) == 1 ) : return 0 ban = [ ] for i in range ( len ( s ) ) : if all ( s [ i ] != s [ k ] for k in range ( i + 1 , len ( s ) ) ) == True and s [ i ] not in ban : return i else : ban . append ( s [ i ] ) return - 1", "docstring_tokens": ": type s : str : rtype : int", "label": 1}, {"idx": "cosqa-train-9262", "doc": "python make a dict immutable", "code": "def make_symmetric(dict):\n    \"\"\"Makes the given dictionary symmetric. Values are assumed to be unique.\"\"\"\n    for key, value in list(dict.items()):\n        dict[value] = key\n    return dict", "code_tokens": "def make_symmetric ( dict ) : for key , value in list ( dict . items ( ) ) : dict [ value ] = key return dict", "docstring_tokens": "Makes the given dictionary symmetric . Values are assumed to be unique .", "label": 1}, {"idx": "cosqa-train-9263", "doc": "how to check if a file does not exist in python", "code": "def is_valid_file(parser, arg):\n    \"\"\"Check if arg is a valid file that already exists on the file system.\"\"\"\n    arg = os.path.abspath(arg)\n    if not os.path.exists(arg):\n        parser.error(\"The file %s does not exist!\" % arg)\n    else:\n        return arg", "code_tokens": "def is_valid_file ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . exists ( arg ) : parser . error ( \"The file %s does not exist!\" % arg ) else : return arg", "docstring_tokens": "Check if arg is a valid file that already exists on the file system .", "label": 0}, {"idx": "cosqa-train-9264", "doc": "python make a list from comma separated string", "code": "def split_elements(value):\n    \"\"\"Split a string with comma or space-separated elements into a list.\"\"\"\n    l = [v.strip() for v in value.split(',')]\n    if len(l) == 1:\n        l = value.split()\n    return l", "code_tokens": "def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l", "docstring_tokens": "Split a string with comma or space - separated elements into a list .", "label": 1}, {"idx": "cosqa-train-9265", "doc": "how to check if a json property exists in python", "code": "def task_property_present_predicate(service, task, prop):\n    \"\"\" True if the json_element passed is present for the task specified.\n    \"\"\"\n    try:\n        response = get_service_task(service, task)\n    except Exception as e:\n        pass\n\n    return (response is not None) and (prop in response)", "code_tokens": "def task_property_present_predicate ( service , task , prop ) : try : response = get_service_task ( service , task ) except Exception as e : pass return ( response is not None ) and ( prop in response )", "docstring_tokens": "True if the json_element passed is present for the task specified .", "label": 1}, {"idx": "cosqa-train-9266", "doc": "how to check if a string is present in a file if present replace else write to file in python", "code": "def _replace_file(path, content):\n  \"\"\"Writes a file if it doesn't already exist with the same content.\n\n  This is useful because cargo uses timestamps to decide whether to compile things.\"\"\"\n  if os.path.exists(path):\n    with open(path, 'r') as f:\n      if content == f.read():\n        print(\"Not overwriting {} because it is unchanged\".format(path), file=sys.stderr)\n        return\n\n  with open(path, 'w') as f:\n    f.write(content)", "code_tokens": "def _replace_file ( path , content ) : if os . path . exists ( path ) : with open ( path , 'r' ) as f : if content == f . read ( ) : print ( \"Not overwriting {} because it is unchanged\" . format ( path ) , file = sys . stderr ) return with open ( path , 'w' ) as f : f . write ( content )", "docstring_tokens": "Writes a file if it doesn t already exist with the same content .", "label": 1}, {"idx": "cosqa-train-9267", "doc": "python make all the elements in a list none", "code": "def purge_duplicates(list_in):\n    \"\"\"Remove duplicates from list while preserving order.\n\n    Parameters\n    ----------\n    list_in: Iterable\n\n    Returns\n    -------\n    list\n        List of first occurences in order\n    \"\"\"\n    _list = []\n    for item in list_in:\n        if item not in _list:\n            _list.append(item)\n    return _list", "code_tokens": "def purge_duplicates ( list_in ) : _list = [ ] for item in list_in : if item not in _list : _list . append ( item ) return _list", "docstring_tokens": "Remove duplicates from list while preserving order .", "label": 1}, {"idx": "cosqa-train-9268", "doc": "how to check if a tree is a bst in python", "code": "def get_tree_type(tree):\n    \"\"\"\n    returns the type of the (sub)tree: Root, Nucleus or Satellite\n\n    Parameters\n    ----------\n    tree : nltk.tree.ParentedTree\n        a tree representing a rhetorical structure (or a part of it)\n    \"\"\"\n    tree_type = tree.label()\n    assert tree_type in SUBTREE_TYPES, \"tree_type: {}\".format(tree_type)\n    return tree_type", "code_tokens": "def get_tree_type ( tree ) : tree_type = tree . label ( ) assert tree_type in SUBTREE_TYPES , \"tree_type: {}\" . format ( tree_type ) return tree_type", "docstring_tokens": "returns the type of the ( sub ) tree : Root Nucleus or Satellite", "label": 1}, {"idx": "cosqa-train-9269", "doc": "python make boject from string", "code": "def from_json(s):\n    \"\"\"Given a JSON-encoded message, build an object.\n\n    \"\"\"\n    d = json.loads(s)\n    sbp = SBP.from_json_dict(d)\n    return sbp", "code_tokens": "def from_json ( s ) : d = json . loads ( s ) sbp = SBP . from_json_dict ( d ) return sbp", "docstring_tokens": "Given a JSON - encoded message build an object .", "label": 1}, {"idx": "cosqa-train-9270", "doc": "how to check if a variable is iterable python", "code": "def is_iterable_but_not_string(obj):\n    \"\"\"\n    Determine whether or not obj is iterable but not a string (eg, a list, set, tuple etc).\n    \"\"\"\n    return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)", "code_tokens": "def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )", "docstring_tokens": "Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) .", "label": 1}, {"idx": "cosqa-train-9271", "doc": "python make clear interfaces", "code": "def set_interface(interface, name=''):\n    \"\"\"\n    don't want to bother with a dsn? Use this method to make an interface available\n    \"\"\"\n    global interfaces\n\n    if not interface: raise ValueError('interface is empty')\n\n    # close down the interface before we discard it\n    if name in interfaces:\n        interfaces[name].close()\n\n    interfaces[name] = interface", "code_tokens": "def set_interface ( interface , name = '' ) : global interfaces if not interface : raise ValueError ( 'interface is empty' ) # close down the interface before we discard it if name in interfaces : interfaces [ name ] . close ( ) interfaces [ name ] = interface", "docstring_tokens": "don t want to bother with a dsn? Use this method to make an interface available", "label": 1}, {"idx": "cosqa-train-9272", "doc": "how to check if arguemnts are empty in python", "code": "def _is_one_arg_pos_call(call):\n    \"\"\"Is this a call with exactly 1 argument,\n    where that argument is positional?\n    \"\"\"\n    return isinstance(call, astroid.Call) and len(call.args) == 1 and not call.keywords", "code_tokens": "def _is_one_arg_pos_call ( call ) : return isinstance ( call , astroid . Call ) and len ( call . args ) == 1 and not call . keywords", "docstring_tokens": "Is this a call with exactly 1 argument where that argument is positional?", "label": 1}, {"idx": "cosqa-train-9273", "doc": "python make function iterable", "code": "def _varargs_to_iterable_method(func):\n    \"\"\"decorator to convert a *args method to one taking a iterable\"\"\"\n    def wrapped(self, iterable, **kwargs):\n        return func(self, *iterable, **kwargs)\n    return wrapped", "code_tokens": "def _varargs_to_iterable_method ( func ) : def wrapped ( self , iterable , * * kwargs ) : return func ( self , * iterable , * * kwargs ) return wrapped", "docstring_tokens": "decorator to convert a * args method to one taking a iterable", "label": 0}, {"idx": "cosqa-train-9274", "doc": "how to check if defined python", "code": "def is_defined(self, objtxt, force_import=False):\n        \"\"\"Return True if object is defined\"\"\"\n        return self.interpreter.is_defined(objtxt, force_import)", "code_tokens": "def is_defined ( self , objtxt , force_import = False ) : return self . interpreter . is_defined ( objtxt , force_import )", "docstring_tokens": "Return True if object is defined", "label": 0}, {"idx": "cosqa-train-9275", "doc": "python make points iterable", "code": "def _iterPoints(self, **kwargs):\n        \"\"\"\n        Subclasses may override this method.\n        \"\"\"\n        points = self.points\n        count = len(points)\n        index = 0\n        while count:\n            yield points[index]\n            count -= 1\n            index += 1", "code_tokens": "def _iterPoints ( self , * * kwargs ) : points = self . points count = len ( points ) index = 0 while count : yield points [ index ] count -= 1 index += 1", "docstring_tokens": "Subclasses may override this method .", "label": 0}, {"idx": "cosqa-train-9276", "doc": "how to check if file is not empty python", "code": "def file_empty(fp):\n    \"\"\"Determine if a file is empty or not.\"\"\"\n    # for python 2 we need to use a homemade peek()\n    if six.PY2:\n        contents = fp.read()\n        fp.seek(0)\n        return not bool(contents)\n\n    else:\n        return not fp.peek()", "code_tokens": "def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )", "docstring_tokens": "Determine if a file is empty or not .", "label": 1}, {"idx": "cosqa-train-9277", "doc": "python make string html safe", "code": "def safe_quotes(text, escape_single_quotes=False):\n    \"\"\"htmlify string\"\"\"\n    if isinstance(text, str):\n        safe_text = text.replace('\"', \"&quot;\")\n        if escape_single_quotes:\n            safe_text = safe_text.replace(\"'\", \"&#92;'\")\n        return safe_text.replace('True', 'true')\n    return text", "code_tokens": "def safe_quotes ( text , escape_single_quotes = False ) : if isinstance ( text , str ) : safe_text = text . replace ( '\"' , \"&quot;\" ) if escape_single_quotes : safe_text = safe_text . replace ( \"'\" , \"&#92;'\" ) return safe_text . replace ( 'True' , 'true' ) return text", "docstring_tokens": "htmlify string", "label": 1}, {"idx": "cosqa-train-9278", "doc": "how to check if input was read python", "code": "def stdin_readable():\n    \"\"\"Determine whether stdin has any data to read.\"\"\"\n    if not WINDOWS:\n        try:\n            return bool(select([sys.stdin], [], [], 0)[0])\n        except Exception:\n            logger.log_exc()\n    try:\n        return not sys.stdin.isatty()\n    except Exception:\n        logger.log_exc()\n    return False", "code_tokens": "def stdin_readable ( ) : if not WINDOWS : try : return bool ( select ( [ sys . stdin ] , [ ] , [ ] , 0 ) [ 0 ] ) except Exception : logger . log_exc ( ) try : return not sys . stdin . isatty ( ) except Exception : logger . log_exc ( ) return False", "docstring_tokens": "Determine whether stdin has any data to read .", "label": 1}, {"idx": "cosqa-train-9279", "doc": "python make sure all words are separated by a single space", "code": "def sanitize_word(s):\n    \"\"\"Remove non-alphanumerical characters from metric word.\n    And trim excessive underscores.\n    \"\"\"\n    s = re.sub('[^\\w-]+', '_', s)\n    s = re.sub('__+', '_', s)\n    return s.strip('_')", "code_tokens": "def sanitize_word ( s ) : s = re . sub ( '[^\\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )", "docstring_tokens": "Remove non - alphanumerical characters from metric word . And trim excessive underscores .", "label": 1}, {"idx": "cosqa-train-9280", "doc": "how to check if python code is running", "code": "def IPYTHON_MAIN():\n    \"\"\"Decide if the Ipython command line is running code.\"\"\"\n    import pkg_resources\n\n    runner_frame = inspect.getouterframes(inspect.currentframe())[-2]\n    return (\n        getattr(runner_frame, \"function\", None)\n        == pkg_resources.load_entry_point(\"ipython\", \"console_scripts\", \"ipython\").__name__\n    )", "code_tokens": "def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , \"function\" , None ) == pkg_resources . load_entry_point ( \"ipython\" , \"console_scripts\" , \"ipython\" ) . __name__ )", "docstring_tokens": "Decide if the Ipython command line is running code .", "label": 1}, {"idx": "cosqa-train-9281", "doc": "python make uuid filename", "code": "def random_filename(path=None):\n    \"\"\"Make a UUID-based file name which is extremely unlikely\n    to exist already.\"\"\"\n    filename = uuid4().hex\n    if path is not None:\n        filename = os.path.join(path, filename)\n    return filename", "code_tokens": "def random_filename ( path = None ) : filename = uuid4 ( ) . hex if path is not None : filename = os . path . join ( path , filename ) return filename", "docstring_tokens": "Make a UUID - based file name which is extremely unlikely to exist already .", "label": 0}, {"idx": "cosqa-train-9282", "doc": "how to check if the pos tag is noun of a word python", "code": "def _begins_with_one_of(sentence, parts_of_speech):\n    \"\"\"Return True if the sentence or fragment begins with one of the parts of\n    speech in the list, else False\"\"\"\n    doc = nlp(sentence)\n    if doc[0].tag_ in parts_of_speech:\n        return True\n    return False", "code_tokens": "def _begins_with_one_of ( sentence , parts_of_speech ) : doc = nlp ( sentence ) if doc [ 0 ] . tag_ in parts_of_speech : return True return False", "docstring_tokens": "Return True if the sentence or fragment begins with one of the parts of speech in the list else False", "label": 1}, {"idx": "cosqa-train-9283", "doc": "python making an array into a float", "code": "def as_float_array(a):\n    \"\"\"View the quaternion array as an array of floats\n\n    This function is fast (of order 1 microsecond) because no data is\n    copied; the returned quantity is just a \"view\" of the original.\n\n    The output view has one more dimension (of size 4) than the input\n    array, but is otherwise the same shape.\n\n    \"\"\"\n    return np.asarray(a, dtype=np.quaternion).view((np.double, 4))", "code_tokens": "def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )", "docstring_tokens": "View the quaternion array as an array of floats", "label": 1}, {"idx": "cosqa-train-9284", "doc": "how to check if you've reached end of file in python", "code": "def eof(fd):\n    \"\"\"Determine if end-of-file is reached for file fd.\"\"\"\n    b = fd.read(1)\n    end = len(b) == 0\n    if not end:\n        curpos = fd.tell()\n        fd.seek(curpos - 1)\n    return end", "code_tokens": "def eof ( fd ) : b = fd . read ( 1 ) end = len ( b ) == 0 if not end : curpos = fd . tell ( ) fd . seek ( curpos - 1 ) return end", "docstring_tokens": "Determine if end - of - file is reached for file fd .", "label": 1}, {"idx": "cosqa-train-9285", "doc": "python making string lower case", "code": "def to_camel(s):\n    \"\"\"\n    :param string s: under_scored string to be CamelCased\n    :return: CamelCase version of input\n    :rtype: str\n    \"\"\"\n    # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups\n    return re.sub(r'_([a-zA-Z])', lambda m: m.group(1).upper(), '_' + s)", "code_tokens": "def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )", "docstring_tokens": ": param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str", "label": 1}, {"idx": "cosqa-train-9286", "doc": "how to check in python with slenium locator is created or not", "code": "def is_element_present(self, strategy, locator):\n        \"\"\"Checks whether an element is present.\n\n        :param strategy: Location strategy to use. See :py:class:`~selenium.webdriver.common.by.By` or :py:attr:`~pypom.splinter_driver.ALLOWED_STRATEGIES`.\n        :param locator: Location of target element.\n        :type strategy: str\n        :type locator: str\n        :return: ``True`` if element is present, else ``False``.\n        :rtype: bool\n\n        \"\"\"\n        return self.driver_adapter.is_element_present(strategy, locator, root=self.root)", "code_tokens": "def is_element_present ( self , strategy , locator ) : return self . driver_adapter . is_element_present ( strategy , locator , root = self . root )", "docstring_tokens": "Checks whether an element is present .", "label": 0}, {"idx": "cosqa-train-9287", "doc": "python map change on click", "code": "def OnDoubleClick(self, event):\n        \"\"\"Double click on a given square in the map\"\"\"\n        node = HotMapNavigator.findNodeAtPosition(self.hot_map, event.GetPosition())\n        if node:\n            wx.PostEvent( self, SquareActivationEvent( node=node, point=event.GetPosition(), map=self ) )", "code_tokens": "def OnDoubleClick ( self , event ) : node = HotMapNavigator . findNodeAtPosition ( self . hot_map , event . GetPosition ( ) ) if node : wx . PostEvent ( self , SquareActivationEvent ( node = node , point = event . GetPosition ( ) , map = self ) )", "docstring_tokens": "Double click on a given square in the map", "label": 0}, {"idx": "cosqa-train-9288", "doc": "how to check internet connection in python", "code": "def _internet_on(address):\n    \"\"\"\n    Check to see if the internet is on by pinging a set address.\n    :param address: the IP or address to hit\n    :return: a boolean - true if can be reached, false if not.\n    \"\"\"\n    try:\n        urllib2.urlopen(address, timeout=1)\n        return True\n    except urllib2.URLError as err:\n        return False", "code_tokens": "def _internet_on ( address ) : try : urllib2 . urlopen ( address , timeout = 1 ) return True except urllib2 . URLError as err : return False", "docstring_tokens": "Check to see if the internet is on by pinging a set address . : param address : the IP or address to hit : return : a boolean - true if can be reached false if not .", "label": 0}, {"idx": "cosqa-train-9289", "doc": "python masked array copy", "code": "def asMaskedArray(self):\n        \"\"\" Creates converts to a masked array\n        \"\"\"\n        return ma.masked_array(data=self.data, mask=self.mask, fill_value=self.fill_value)", "code_tokens": "def asMaskedArray ( self ) : return ma . masked_array ( data = self . data , mask = self . mask , fill_value = self . fill_value )", "docstring_tokens": "Creates converts to a masked array", "label": 1}, {"idx": "cosqa-train-9290", "doc": "how to check method obj in python", "code": "def _is_readable(self, obj):\n        \"\"\"Check if the argument is a readable file-like object.\"\"\"\n        try:\n            read = getattr(obj, 'read')\n        except AttributeError:\n            return False\n        else:\n            return is_method(read, max_arity=1)", "code_tokens": "def _is_readable ( self , obj ) : try : read = getattr ( obj , 'read' ) except AttributeError : return False else : return is_method ( read , max_arity = 1 )", "docstring_tokens": "Check if the argument is a readable file - like object .", "label": 1}, {"idx": "cosqa-train-9291", "doc": "python match any case", "code": "def _match_literal(self, a, b=None):\n        \"\"\"Match two names.\"\"\"\n\n        return a.lower() == b if not self.case_sensitive else a == b", "code_tokens": "def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b", "docstring_tokens": "Match two names .", "label": 1}, {"idx": "cosqa-train-9292", "doc": "how to check the current time in python", "code": "def stopwatch_now():\n    \"\"\"Get a timevalue for interval comparisons\n\n    When possible it is a monotonic clock to prevent backwards time issues.\n    \"\"\"\n    if six.PY2:\n        now = time.time()\n    else:\n        now = time.monotonic()\n    return now", "code_tokens": "def stopwatch_now ( ) : if six . PY2 : now = time . time ( ) else : now = time . monotonic ( ) return now", "docstring_tokens": "Get a timevalue for interval comparisons", "label": 0}, {"idx": "cosqa-train-9293", "doc": "python math normalize vector", "code": "def v_normalize(v):\n    \"\"\"\n    Normalizes the given vector.\n    \n    The vector given may have any number of dimensions.\n    \"\"\"\n    vmag = v_magnitude(v)\n    return [ v[i]/vmag  for i in range(len(v)) ]", "code_tokens": "def v_normalize ( v ) : vmag = v_magnitude ( v ) return [ v [ i ] / vmag for i in range ( len ( v ) ) ]", "docstring_tokens": "Normalizes the given vector . The vector given may have any number of dimensions .", "label": 1}, {"idx": "cosqa-train-9294", "doc": "how to check the data type of columns in python", "code": "def _validate_pos(df):\n    \"\"\"Validates the returned positional object\n    \"\"\"\n    assert isinstance(df, pd.DataFrame)\n    assert [\"seqname\", \"position\", \"strand\"] == df.columns.tolist()\n    assert df.position.dtype == np.dtype(\"int64\")\n    assert df.strand.dtype == np.dtype(\"O\")\n    assert df.seqname.dtype == np.dtype(\"O\")\n    return df", "code_tokens": "def _validate_pos ( df ) : assert isinstance ( df , pd . DataFrame ) assert [ \"seqname\" , \"position\" , \"strand\" ] == df . columns . tolist ( ) assert df . position . dtype == np . dtype ( \"int64\" ) assert df . strand . dtype == np . dtype ( \"O\" ) assert df . seqname . dtype == np . dtype ( \"O\" ) return df", "docstring_tokens": "Validates the returned positional object", "label": 1}, {"idx": "cosqa-train-9295", "doc": "python matplotlib add title to subplots", "code": "def set_title(self, title, **kwargs):\n        \"\"\"Sets the title on the underlying matplotlib AxesSubplot.\"\"\"\n        ax = self.get_axes()\n        ax.set_title(title, **kwargs)", "code_tokens": "def set_title ( self , title , * * kwargs ) : ax = self . get_axes ( ) ax . set_title ( title , * * kwargs )", "docstring_tokens": "Sets the title on the underlying matplotlib AxesSubplot .", "label": 0}, {"idx": "cosqa-train-9296", "doc": "how to check the data type of variable in python", "code": "def autoconvert(string):\n    \"\"\"Try to convert variables into datatypes.\"\"\"\n    for fn in (boolify, int, float):\n        try:\n            return fn(string)\n        except ValueError:\n            pass\n    return string", "code_tokens": "def autoconvert ( string ) : for fn in ( boolify , int , float ) : try : return fn ( string ) except ValueError : pass return string", "docstring_tokens": "Try to convert variables into datatypes .", "label": 0}, {"idx": "cosqa-train-9297", "doc": "python matplotlib axes set visable", "code": "def _axes(self):\n        \"\"\"Set the _force_vertical flag when rendering axes\"\"\"\n        self.view._force_vertical = True\n        super(HorizontalGraph, self)._axes()\n        self.view._force_vertical = False", "code_tokens": "def _axes ( self ) : self . view . _force_vertical = True super ( HorizontalGraph , self ) . _axes ( ) self . view . _force_vertical = False", "docstring_tokens": "Set the _force_vertical flag when rendering axes", "label": 1}, {"idx": "cosqa-train-9298", "doc": "how to check what libraries for python", "code": "def load_library(version):\n    \"\"\"\n    Load the correct module according to the version\n\n    :type version: ``str``\n    :param version: the version of the library to be loaded (e.g. '2.6')\n    :rtype: module object\n    \"\"\"\n    check_version(version)\n    module_name = SUPPORTED_LIBRARIES[version]\n    lib = sys.modules.get(module_name)\n    if lib is None:\n        lib = importlib.import_module(module_name)\n    return lib", "code_tokens": "def load_library ( version ) : check_version ( version ) module_name = SUPPORTED_LIBRARIES [ version ] lib = sys . modules . get ( module_name ) if lib is None : lib = importlib . import_module ( module_name ) return lib", "docstring_tokens": "Load the correct module according to the version", "label": 1}, {"idx": "cosqa-train-9299", "doc": "python matplotlib axis clear", "code": "def clear_matplotlib_ticks(self, axis=\"both\"):\n        \"\"\"Clears the default matplotlib ticks.\"\"\"\n        ax = self.get_axes()\n        plotting.clear_matplotlib_ticks(ax=ax, axis=axis)", "code_tokens": "def clear_matplotlib_ticks ( self , axis = \"both\" ) : ax = self . get_axes ( ) plotting . clear_matplotlib_ticks ( ax = ax , axis = axis )", "docstring_tokens": "Clears the default matplotlib ticks .", "label": 1}, {"idx": "cosqa-train-9300", "doc": "how to check whether a list of boolean are all true in python", "code": "def assert_exactly_one_true(bool_list):\n    \"\"\"This method asserts that only one value of the provided list is True.\n\n    :param bool_list: List of booleans to check\n    :return: True if only one value is True, False otherwise\n    \"\"\"\n    assert isinstance(bool_list, list)\n    counter = 0\n    for item in bool_list:\n        if item:\n            counter += 1\n    return counter == 1", "code_tokens": "def assert_exactly_one_true ( bool_list ) : assert isinstance ( bool_list , list ) counter = 0 for item in bool_list : if item : counter += 1 return counter == 1", "docstring_tokens": "This method asserts that only one value of the provided list is True .", "label": 0}, {"idx": "cosqa-train-9301", "doc": "python matplotlib get height of each bar", "code": "def _change_height(self, ax, new_value):\n        \"\"\"Make bars in horizontal bar chart thinner\"\"\"\n        for patch in ax.patches:\n            current_height = patch.get_height()\n            diff = current_height - new_value\n\n            # we change the bar height\n            patch.set_height(new_value)\n\n            # we recenter the bar\n            patch.set_y(patch.get_y() + diff * .5)", "code_tokens": "def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )", "docstring_tokens": "Make bars in horizontal bar chart thinner", "label": 0}, {"idx": "cosqa-train-9302", "doc": "how to check whether an item is a directory in python", "code": "def _IsDirectory(parent, item):\n  \"\"\"Helper that returns if parent/item is a directory.\"\"\"\n  return tf.io.gfile.isdir(os.path.join(parent, item))", "code_tokens": "def _IsDirectory ( parent , item ) : return tf . io . gfile . isdir ( os . path . join ( parent , item ) )", "docstring_tokens": "Helper that returns if parent / item is a directory .", "label": 0}, {"idx": "cosqa-train-9303", "doc": "python matplotlib subplot add text", "code": "def set_axis_options(self, row, column, text):\n        \"\"\"Set additionnal options as plain text.\"\"\"\n\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_axis_options(text)", "code_tokens": "def set_axis_options ( self , row , column , text ) : subplot = self . get_subplot_at ( row , column ) subplot . set_axis_options ( text )", "docstring_tokens": "Set additionnal options as plain text .", "label": 0}, {"idx": "cosqa-train-9304", "doc": "how to choose a random position in an array in python", "code": "def downsample(array, k):\n    \"\"\"Choose k random elements of array.\"\"\"\n    length = array.shape[0]\n    indices = random.sample(xrange(length), k)\n    return array[indices]", "code_tokens": "def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]", "docstring_tokens": "Choose k random elements of array .", "label": 0}, {"idx": "cosqa-train-9305", "doc": "python matrix normalize each column", "code": "def normalize(X):\n    \"\"\" equivalent to scipy.preprocessing.normalize on sparse matrices\n    , but lets avoid another depedency just for a small utility function \"\"\"\n    X = coo_matrix(X)\n    X.data = X.data / sqrt(bincount(X.row, X.data ** 2))[X.row]\n    return X", "code_tokens": "def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X", "docstring_tokens": "equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function", "label": 1}, {"idx": "cosqa-train-9306", "doc": "how to clear an entry in python", "code": "def remove(self, entry):\n        \"\"\"Removes an entry\"\"\"\n        try:\n            list = self.cache[entry.key]\n            list.remove(entry)\n        except:\n            pass", "code_tokens": "def remove ( self , entry ) : try : list = self . cache [ entry . key ] list . remove ( entry ) except : pass", "docstring_tokens": "Removes an entry", "label": 0}, {"idx": "cosqa-train-9307", "doc": "python max int from range", "code": "def max_values(args):\n    \"\"\" Return possible range for max function. \"\"\"\n    return Interval(max(x.low for x in args), max(x.high for x in args))", "code_tokens": "def max_values ( args ) : return Interval ( max ( x . low for x in args ) , max ( x . high for x in args ) )", "docstring_tokens": "Return possible range for max function .", "label": 0}, {"idx": "cosqa-train-9308", "doc": "how to clear an objecting python", "code": "def detach_all(self):\n        \"\"\"\n        Detach from all tracked classes and objects.\n        Restore the original constructors and cleanse the tracking lists.\n        \"\"\"\n        self.detach_all_classes()\n        self.objects.clear()\n        self.index.clear()\n        self._keepalive[:] = []", "code_tokens": "def detach_all ( self ) : self . detach_all_classes ( ) self . objects . clear ( ) self . index . clear ( ) self . _keepalive [ : ] = [ ]", "docstring_tokens": "Detach from all tracked classes and objects . Restore the original constructors and cleanse the tracking lists .", "label": 0}, {"idx": "cosqa-train-9309", "doc": "python md5 a file", "code": "def get_file_md5sum(path):\n    \"\"\"Calculate the MD5 hash for a file.\"\"\"\n    with open(path, 'rb') as fh:\n        h = str(hashlib.md5(fh.read()).hexdigest())\n    return h", "code_tokens": "def get_file_md5sum ( path ) : with open ( path , 'rb' ) as fh : h = str ( hashlib . md5 ( fh . read ( ) ) . hexdigest ( ) ) return h", "docstring_tokens": "Calculate the MD5 hash for a file .", "label": 1}, {"idx": "cosqa-train-9310", "doc": "how to clear directory using python", "code": "def _clear_dir(dirName):\n    \"\"\" Remove a directory and it contents. Ignore any failures.\n    \"\"\"\n    # If we got here, clear dir  \n    for fname in os.listdir(dirName):\n        try:\n            os.remove( os.path.join(dirName, fname) )\n        except Exception:\n            pass\n    try:\n        os.rmdir(dirName)\n    except Exception:\n        pass", "code_tokens": "def _clear_dir ( dirName ) : # If we got here, clear dir   for fname in os . listdir ( dirName ) : try : os . remove ( os . path . join ( dirName , fname ) ) except Exception : pass try : os . rmdir ( dirName ) except Exception : pass", "docstring_tokens": "Remove a directory and it contents . Ignore any failures .", "label": 1}, {"idx": "cosqa-train-9311", "doc": "python memory contents at ctypes address", "code": "def pointer(self):\n        \"\"\"Get a ctypes void pointer to the memory mapped region.\n\n        :type: ctypes.c_void_p\n        \"\"\"\n        return ctypes.cast(ctypes.pointer(ctypes.c_uint8.from_buffer(self.mapping, 0)), ctypes.c_void_p)", "code_tokens": "def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )", "docstring_tokens": "Get a ctypes void pointer to the memory mapped region .", "label": 0}, {"idx": "cosqa-train-9312", "doc": "how to clear log file python", "code": "def stoplog(self):\n        \"\"\" Stop logging.\n    \n        @return: 1 on success and 0 on error\n        @rtype: integer\n        \"\"\"\n        if self._file_logger:\n            self.logger.removeHandler(_file_logger)\n            self._file_logger = None\n        return 1", "code_tokens": "def stoplog ( self ) : if self . _file_logger : self . logger . removeHandler ( _file_logger ) self . _file_logger = None return 1", "docstring_tokens": "Stop logging .", "label": 0}, {"idx": "cosqa-train-9313", "doc": "python min array value of multiple values", "code": "def SegmentMin(a, ids):\n    \"\"\"\n    Segmented min op.\n    \"\"\"\n    func = lambda idxs: np.amin(a[idxs], axis=0)\n    return seg_map(func, a, ids),", "code_tokens": "def SegmentMin ( a , ids ) : func = lambda idxs : np . amin ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,", "docstring_tokens": "Segmented min op .", "label": 1}, {"idx": "cosqa-train-9314", "doc": "how to clear the shell in python", "code": "def clear():\n    \"\"\"Clears the console.\"\"\"\n    if sys.platform.startswith(\"win\"):\n        call(\"cls\", shell=True)\n    else:\n        call(\"clear\", shell=True)", "code_tokens": "def clear ( ) : if sys . platform . startswith ( \"win\" ) : call ( \"cls\" , shell = True ) else : call ( \"clear\" , shell = True )", "docstring_tokens": "Clears the console .", "label": 1}, {"idx": "cosqa-train-9315", "doc": "python minidom get value of a tag", "code": "def _get_minidom_tag_value(station, tag_name):\n    \"\"\"get a value from a tag (if it exists)\"\"\"\n    tag = station.getElementsByTagName(tag_name)[0].firstChild\n    if tag:\n        return tag.nodeValue\n\n    return None", "code_tokens": "def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None", "docstring_tokens": "get a value from a tag ( if it exists )", "label": 0}, {"idx": "cosqa-train-9316", "doc": "python mock how to patch property of an object and set value", "code": "def __setitem__(self, _ignored, return_value):\n        \"\"\"Item assignment sets the return value and removes any side effect\"\"\"\n        self.mock.return_value = return_value\n        self.mock.side_effect = None", "code_tokens": "def __setitem__ ( self , _ignored , return_value ) : self . mock . return_value = return_value self . mock . side_effect = None", "docstring_tokens": "Item assignment sets the return value and removes any side effect", "label": 1}, {"idx": "cosqa-train-9317", "doc": "how to close the serial port in python", "code": "def close(self):\n        \"\"\"Closes the serial port.\"\"\"\n        if self.pyb and self.pyb.serial:\n            self.pyb.serial.close()\n        self.pyb = None", "code_tokens": "def close ( self ) : if self . pyb and self . pyb . serial : self . pyb . serial . close ( ) self . pyb = None", "docstring_tokens": "Closes the serial port .", "label": 0}, {"idx": "cosqa-train-9318", "doc": "python mock mark a test as expected failure", "code": "def assert_called(_mock_self):\n        \"\"\"assert that the mock was called at least once\n        \"\"\"\n        self = _mock_self\n        if self.call_count == 0:\n            msg = (\"Expected '%s' to have been called.\" %\n                   self._mock_name or 'mock')\n            raise AssertionError(msg)", "code_tokens": "def assert_called ( _mock_self ) : self = _mock_self if self . call_count == 0 : msg = ( \"Expected '%s' to have been called.\" % self . _mock_name or 'mock' ) raise AssertionError ( msg )", "docstring_tokens": "assert that the mock was called at least once", "label": 1}, {"idx": "cosqa-train-9319", "doc": "how to close threads in python", "code": "def finish():\n    \"\"\"Print warning about interrupt and empty the job queue.\"\"\"\n    out.warn(\"Interrupted!\")\n    for t in threads:\n        t.stop()\n    jobs.clear()\n    out.warn(\"Waiting for download threads to finish.\")", "code_tokens": "def finish ( ) : out . warn ( \"Interrupted!\" ) for t in threads : t . stop ( ) jobs . clear ( ) out . warn ( \"Waiting for download threads to finish.\" )", "docstring_tokens": "Print warning about interrupt and empty the job queue .", "label": 1}, {"idx": "cosqa-train-9320", "doc": "python mock post request", "code": "def requests_post(url, data=None, json=None, **kwargs):\n    \"\"\"Requests-mock requests.post wrapper.\"\"\"\n    return requests_request('post', url, data=data, json=json, **kwargs)", "code_tokens": "def requests_post ( url , data = None , json = None , * * kwargs ) : return requests_request ( 'post' , url , data = data , json = json , * * kwargs )", "docstring_tokens": "Requests - mock requests . post wrapper .", "label": 1}, {"idx": "cosqa-train-9321", "doc": "how to combine value with a pair keys in array python", "code": "def from_pairs_to_array_values(pairs):\n    \"\"\"\n        Like from pairs but combines duplicate key values into arrays\n    :param pairs:\n    :return:\n    \"\"\"\n    result = {}\n    for pair in pairs:\n        result[pair[0]] = concat(prop_or([], pair[0], result), [pair[1]])\n    return result", "code_tokens": "def from_pairs_to_array_values ( pairs ) : result = { } for pair in pairs : result [ pair [ 0 ] ] = concat ( prop_or ( [ ] , pair [ 0 ] , result ) , [ pair [ 1 ] ] ) return result", "docstring_tokens": "Like from pairs but combines duplicate key values into arrays : param pairs : : return :", "label": 1}, {"idx": "cosqa-train-9322", "doc": "python modify global variable with functions", "code": "def getFunction(self):\n        \"\"\"Called by remote workers. Useful to populate main module globals()\n        for interactive shells. Retrieves the serialized function.\"\"\"\n        return functionFactory(\n            self.code,\n            self.name,\n            self.defaults,\n            self.globals,\n            self.imports,\n        )", "code_tokens": "def getFunction ( self ) : return functionFactory ( self . code , self . name , self . defaults , self . globals , self . imports , )", "docstring_tokens": "Called by remote workers . Useful to populate main module globals () for interactive shells . Retrieves the serialized function .", "label": 0}, {"idx": "cosqa-train-9323", "doc": "how to compare several strings at one time python", "code": "def compare(string1, string2):\n    \"\"\"Compare two strings while protecting against timing attacks\n\n    :param str string1: the first string\n    :param str string2: the second string\n\n    :returns: True if the strings are equal, False if not\n    :rtype: :obj:`bool`\n    \"\"\"\n    if len(string1) != len(string2):\n        return False\n    result = True\n    for c1, c2 in izip(string1, string2):\n        result &= c1 == c2\n    return result", "code_tokens": "def compare ( string1 , string2 ) : if len ( string1 ) != len ( string2 ) : return False result = True for c1 , c2 in izip ( string1 , string2 ) : result &= c1 == c2 return result", "docstring_tokens": "Compare two strings while protecting against timing attacks", "label": 1}, {"idx": "cosqa-train-9324", "doc": "python mongodb object from json", "code": "def _construct_from_json(self, rec):\n        \"\"\" Construct this Dagobah instance from a JSON document. \"\"\"\n\n        self.delete()\n\n        for required_key in ['dagobah_id', 'created_jobs']:\n            setattr(self, required_key, rec[required_key])\n\n        for job_json in rec.get('jobs', []):\n            self._add_job_from_spec(job_json)\n\n        self.commit(cascade=True)", "code_tokens": "def _construct_from_json ( self , rec ) : self . delete ( ) for required_key in [ 'dagobah_id' , 'created_jobs' ] : setattr ( self , required_key , rec [ required_key ] ) for job_json in rec . get ( 'jobs' , [ ] ) : self . _add_job_from_spec ( job_json ) self . commit ( cascade = True )", "docstring_tokens": "Construct this Dagobah instance from a JSON document .", "label": 0}, {"idx": "cosqa-train-9325", "doc": "how to control number of iterations in ref python", "code": "def benchmark(store, n=10000):\n    \"\"\"\n    Iterates over all of the referreds, and then iterates over all of the\n    referrers that refer to each one.\n\n    Fairly item instantiation heavy.\n    \"\"\"\n    R = Referrer\n\n    for referred in store.query(Referred):\n        for _reference in store.query(R, R.reference == referred):\n            pass", "code_tokens": "def benchmark ( store , n = 10000 ) : R = Referrer for referred in store . query ( Referred ) : for _reference in store . query ( R , R . reference == referred ) : pass", "docstring_tokens": "Iterates over all of the referreds and then iterates over all of the referrers that refer to each one .", "label": 0}, {"idx": "cosqa-train-9326", "doc": "python most beautiful string in the world", "code": "def beautify(string, *args, **kwargs):\n\t\"\"\"\n\t\tConvenient interface to the ecstasy package.\n\n\t\tArguments:\n\t\t\tstring (str): The string to beautify with ecstasy.\n\t\t\targs (list): The positional arguments.\n\t\t\tkwargs (dict): The keyword ('always') arguments.\n\t\"\"\"\n\n\tparser = Parser(args, kwargs)\n\treturn parser.beautify(string)", "code_tokens": "def beautify ( string , * args , * * kwargs ) : parser = Parser ( args , kwargs ) return parser . beautify ( string )", "docstring_tokens": "Convenient interface to the ecstasy package .", "label": 1}, {"idx": "cosqa-train-9327", "doc": "how to count the number of times a function is called in python", "code": "def wrap_count(method):\n    \"\"\"\n    Returns number of wraps around given method.\n    \"\"\"\n    number = 0\n    while hasattr(method, '__aspects_orig'):\n        number += 1\n        method = method.__aspects_orig\n    return number", "code_tokens": "def wrap_count ( method ) : number = 0 while hasattr ( method , '__aspects_orig' ) : number += 1 method = method . __aspects_orig return number", "docstring_tokens": "Returns number of wraps around given method .", "label": 1}, {"idx": "cosqa-train-9328", "doc": "python most common value found in a list", "code": "def _most_common(iterable):\n    \"\"\"Returns the most common element in `iterable`.\"\"\"\n    data = Counter(iterable)\n    return max(data, key=data.__getitem__)", "code_tokens": "def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )", "docstring_tokens": "Returns the most common element in iterable .", "label": 1}, {"idx": "cosqa-train-9329", "doc": "how to covert a data set to series in python", "code": "def from_series(cls, series):\n        \"\"\"Convert a pandas.Series into an xarray.DataArray.\n\n        If the series's index is a MultiIndex, it will be expanded into a\n        tensor product of one-dimensional coordinates (filling in missing\n        values with NaN). Thus this operation should be the inverse of the\n        `to_series` method.\n        \"\"\"\n        # TODO: add a 'name' parameter\n        name = series.name\n        df = pd.DataFrame({name: series})\n        ds = Dataset.from_dataframe(df)\n        return ds[name]", "code_tokens": "def from_series ( cls , series ) : # TODO: add a 'name' parameter name = series . name df = pd . DataFrame ( { name : series } ) ds = Dataset . from_dataframe ( df ) return ds [ name ]", "docstring_tokens": "Convert a pandas . Series into an xarray . DataArray .", "label": 1}, {"idx": "cosqa-train-9330", "doc": "python move to next iteration of loop without executing", "code": "def do_next(self, args):\n        \"\"\"Step over the next statement\n        \"\"\"\n        self._do_print_from_last_cmd = True\n        self._interp.step_over()\n        return True", "code_tokens": "def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "docstring_tokens": "Step over the next statement", "label": 0}, {"idx": "cosqa-train-9331", "doc": "how to create 3*2 matrix in python", "code": "def a2s(a):\n    \"\"\"\n     convert 3,3 a matrix to 6 element \"s\" list  (see Tauxe 1998)\n    \"\"\"\n    s = np.zeros((6,), 'f')  # make the a matrix\n    for i in range(3):\n        s[i] = a[i][i]\n    s[3] = a[0][1]\n    s[4] = a[1][2]\n    s[5] = a[0][2]\n    return s", "code_tokens": "def a2s ( a ) : s = np . zeros ( ( 6 , ) , 'f' ) # make the a matrix for i in range ( 3 ) : s [ i ] = a [ i ] [ i ] s [ 3 ] = a [ 0 ] [ 1 ] s [ 4 ] = a [ 1 ] [ 2 ] s [ 5 ] = a [ 0 ] [ 2 ] return s", "docstring_tokens": "convert 3 3 a matrix to 6 element s list ( see Tauxe 1998 )", "label": 1}, {"idx": "cosqa-train-9332", "doc": "python multi bracket match", "code": "def match_paren(self, tokens, item):\n        \"\"\"Matches a paren.\"\"\"\n        match, = tokens\n        return self.match(match, item)", "code_tokens": "def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "docstring_tokens": "Matches a paren .", "label": 0}, {"idx": "cosqa-train-9333", "doc": "how to create a 2d array from 1d array using ndarray in python", "code": "def _convert_to_array(array_like, dtype):\n        \"\"\"\n        Convert Matrix attributes which are array-like or buffer to array.\n        \"\"\"\n        if isinstance(array_like, bytes):\n            return np.frombuffer(array_like, dtype=dtype)\n        return np.asarray(array_like, dtype=dtype)", "code_tokens": "def _convert_to_array ( array_like , dtype ) : if isinstance ( array_like , bytes ) : return np . frombuffer ( array_like , dtype = dtype ) return np . asarray ( array_like , dtype = dtype )", "docstring_tokens": "Convert Matrix attributes which are array - like or buffer to array .", "label": 1}, {"idx": "cosqa-train-9334", "doc": "python multiple arguent lambd", "code": "def def_linear(fun):\n    \"\"\"Flags that a function is linear wrt all args\"\"\"\n    defjvp_argnum(fun, lambda argnum, g, ans, args, kwargs:\n                  fun(*subval(args, argnum, g), **kwargs))", "code_tokens": "def def_linear ( fun ) : defjvp_argnum ( fun , lambda argnum , g , ans , args , kwargs : fun ( * subval ( args , argnum , g ) , * * kwargs ) )", "docstring_tokens": "Flags that a function is linear wrt all args", "label": 0}, {"idx": "cosqa-train-9335", "doc": "how to create a dynamic dictionary with same keyword in python", "code": "def _kw(keywords):\n    \"\"\"Turn list of keywords into dictionary.\"\"\"\n    r = {}\n    for k, v in keywords:\n        r[k] = v\n    return r", "code_tokens": "def _kw ( keywords ) : r = { } for k , v in keywords : r [ k ] = v return r", "docstring_tokens": "Turn list of keywords into dictionary .", "label": 0}, {"idx": "cosqa-train-9336", "doc": "python multiple if conditions multiline", "code": "def has_multiline_items(maybe_list: Optional[Sequence[str]]):\n    \"\"\"Check whether one of the items in the list has multiple lines.\"\"\"\n    return maybe_list and any(is_multiline(item) for item in maybe_list)", "code_tokens": "def has_multiline_items ( maybe_list : Optional [ Sequence [ str ] ] ) : return maybe_list and any ( is_multiline ( item ) for item in maybe_list )", "docstring_tokens": "Check whether one of the items in the list has multiple lines .", "label": 1}, {"idx": "cosqa-train-9337", "doc": "how to create a function to return to main menu in python", "code": "def add(self, name, desc, func=None, args=None, krgs=None):\n        \"\"\"Add a menu entry.\"\"\"\n        self.entries.append(MenuEntry(name, desc, func, args or [], krgs or {}))", "code_tokens": "def add ( self , name , desc , func = None , args = None , krgs = None ) : self . entries . append ( MenuEntry ( name , desc , func , args or [ ] , krgs or { } ) )", "docstring_tokens": "Add a menu entry .", "label": 1}, {"idx": "cosqa-train-9338", "doc": "python multiple iterators one loop", "code": "def combine(self, a, b):\n        \"\"\"A generator that combines two iterables.\"\"\"\n\n        for l in (a, b):\n            for x in l:\n                yield x", "code_tokens": "def combine ( self , a , b ) : for l in ( a , b ) : for x in l : yield x", "docstring_tokens": "A generator that combines two iterables .", "label": 1}, {"idx": "cosqa-train-9339", "doc": "how to create a json string in python", "code": "def to_json(data):\n    \"\"\"Return data as a JSON string.\"\"\"\n    return json.dumps(data, default=lambda x: x.__dict__, sort_keys=True, indent=4)", "code_tokens": "def to_json ( data ) : return json . dumps ( data , default = lambda x : x . __dict__ , sort_keys = True , indent = 4 )", "docstring_tokens": "Return data as a JSON string .", "label": 0}, {"idx": "cosqa-train-9340", "doc": "python multiple returns from a function", "code": "def many_until1(these, term):\n    \"\"\"Like many_until but must consume at least one of these.\n    \"\"\"\n    first = [these()]\n    these_results, term_result = many_until(these, term)\n    return (first + these_results, term_result)", "code_tokens": "def many_until1 ( these , term ) : first = [ these ( ) ] these_results , term_result = many_until ( these , term ) return ( first + these_results , term_result )", "docstring_tokens": "Like many_until but must consume at least one of these .", "label": 0}, {"idx": "cosqa-train-9341", "doc": "how to create a max heap python", "code": "def _heapify_max(x):\n    \"\"\"Transform list into a maxheap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    for i in reversed(range(n//2)):\n        _siftup_max(x, i)", "code_tokens": "def _heapify_max ( x ) : n = len ( x ) for i in reversed ( range ( n // 2 ) ) : _siftup_max ( x , i )", "docstring_tokens": "Transform list into a maxheap in - place in O ( len ( x )) time .", "label": 1}, {"idx": "cosqa-train-9342", "doc": "python multiprocessing + process exit", "code": "def kill_mprocess(process):\n    \"\"\"kill process\n    Args:\n        process - Popen object for process\n    \"\"\"\n    if process and proc_alive(process):\n        process.terminate()\n        process.communicate()\n    return not proc_alive(process)", "code_tokens": "def kill_mprocess ( process ) : if process and proc_alive ( process ) : process . terminate ( ) process . communicate ( ) return not proc_alive ( process )", "docstring_tokens": "kill process Args : process - Popen object for process", "label": 1}, {"idx": "cosqa-train-9343", "doc": "how to create a zoom out button in tkinter python", "code": "def zoom_out(self):\n        \"\"\"Decrease zoom factor and redraw TimeLine\"\"\"\n        index = self._zoom_factors.index(self._zoom_factor)\n        if index == 0:\n            # Already zoomed out all the way\n            return\n        self._zoom_factor = self._zoom_factors[index - 1]\n        if self._zoom_factors.index(self._zoom_factor) == 0:\n            self._button_zoom_out.config(state=tk.DISABLED)\n        self._button_zoom_in.config(state=tk.NORMAL)\n        self.draw_timeline()", "code_tokens": "def zoom_out ( self ) : index = self . _zoom_factors . index ( self . _zoom_factor ) if index == 0 : # Already zoomed out all the way return self . _zoom_factor = self . _zoom_factors [ index - 1 ] if self . _zoom_factors . index ( self . _zoom_factor ) == 0 : self . _button_zoom_out . config ( state = tk . DISABLED ) self . _button_zoom_in . config ( state = tk . NORMAL ) self . draw_timeline ( )", "docstring_tokens": "Decrease zoom factor and redraw TimeLine", "label": 1}, {"idx": "cosqa-train-9344", "doc": "python multiprocessing consumer producer", "code": "def initialize_worker(self, process_num=None):\n        \"\"\"\n        reinitialize consumer for process in multiprocesing\n        \"\"\"\n        self.initialize(self.grid, self.num_of_paths, self.seed)", "code_tokens": "def initialize_worker ( self , process_num = None ) : self . initialize ( self . grid , self . num_of_paths , self . seed )", "docstring_tokens": "reinitialize consumer for process in multiprocesing", "label": 0}, {"idx": "cosqa-train-9345", "doc": "how to create an identifier python", "code": "def _unique_id(self, prefix):\n        \"\"\"\n        Generate a unique (within the graph) identifer\n        internal to graph generation.\n        \"\"\"\n        _id = self._id_gen\n        self._id_gen += 1\n        return prefix + str(_id)", "code_tokens": "def _unique_id ( self , prefix ) : _id = self . _id_gen self . _id_gen += 1 return prefix + str ( _id )", "docstring_tokens": "Generate a unique ( within the graph ) identifer internal to graph generation .", "label": 1}, {"idx": "cosqa-train-9346", "doc": "python multiprocessing pool how to get the return variable", "code": "def compute(args):\n    x, y, params = args\n    \"\"\"Callable function for the multiprocessing pool.\"\"\"\n    return x, y, mandelbrot(x, y, params)", "code_tokens": "def compute ( args ) : x , y , params = args return x , y , mandelbrot ( x , y , params )", "docstring_tokens": "Callable function for the multiprocessing pool .", "label": 1}, {"idx": "cosqa-train-9347", "doc": "how to create distance matrix in python", "code": "def get_distance_matrix(x):\n    \"\"\"Get distance matrix given a matrix. Used in testing.\"\"\"\n    square = nd.sum(x ** 2.0, axis=1, keepdims=True)\n    distance_square = square + square.transpose() - (2.0 * nd.dot(x, x.transpose()))\n    return nd.sqrt(distance_square)", "code_tokens": "def get_distance_matrix ( x ) : square = nd . sum ( x ** 2.0 , axis = 1 , keepdims = True ) distance_square = square + square . transpose ( ) - ( 2.0 * nd . dot ( x , x . transpose ( ) ) ) return nd . sqrt ( distance_square )", "docstring_tokens": "Get distance matrix given a matrix . Used in testing .", "label": 1}, {"idx": "cosqa-train-9348", "doc": "python multiprocessing pool lock manager", "code": "def compute_capture(args):\n    x, y, w, h, params = args\n    \"\"\"Callable function for the multiprocessing pool.\"\"\"\n    return x, y, mandelbrot_capture(x, y, w, h, params)", "code_tokens": "def compute_capture ( args ) : x , y , w , h , params = args return x , y , mandelbrot_capture ( x , y , w , h , params )", "docstring_tokens": "Callable function for the multiprocessing pool .", "label": 1}, {"idx": "cosqa-train-9349", "doc": "how to create empty numpy array of single list in python", "code": "def _cell(x):\n    \"\"\"translate an array x into a MATLAB cell array\"\"\"\n    x_no_none = [i if i is not None else \"\" for i in x]\n    return array(x_no_none, dtype=np_object)", "code_tokens": "def _cell ( x ) : x_no_none = [ i if i is not None else \"\" for i in x ] return array ( x_no_none , dtype = np_object )", "docstring_tokens": "translate an array x into a MATLAB cell array", "label": 0}, {"idx": "cosqa-train-9350", "doc": "python multiprocessing queue stop", "code": "def finish():\n    \"\"\"Print warning about interrupt and empty the job queue.\"\"\"\n    out.warn(\"Interrupted!\")\n    for t in threads:\n        t.stop()\n    jobs.clear()\n    out.warn(\"Waiting for download threads to finish.\")", "code_tokens": "def finish ( ) : out . warn ( \"Interrupted!\" ) for t in threads : t . stop ( ) jobs . clear ( ) out . warn ( \"Waiting for download threads to finish.\" )", "docstring_tokens": "Print warning about interrupt and empty the job queue .", "label": 1}, {"idx": "cosqa-train-9351", "doc": "how to create length without using length in python", "code": "def array_dim(arr):\n    \"\"\"Return the size of a multidimansional array.\n    \"\"\"\n    dim = []\n    while True:\n        try:\n            dim.append(len(arr))\n            arr = arr[0]\n        except TypeError:\n            return dim", "code_tokens": "def array_dim ( arr ) : dim = [ ] while True : try : dim . append ( len ( arr ) ) arr = arr [ 0 ] except TypeError : return dim", "docstring_tokens": "Return the size of a multidimansional array .", "label": 0}, {"idx": "cosqa-train-9352", "doc": "python mysql connect not working", "code": "def connect_mysql(host, port, user, password, database):\n    \"\"\"Connect to MySQL with retries.\"\"\"\n    return pymysql.connect(\n        host=host, port=port,\n        user=user, passwd=password,\n        db=database\n    )", "code_tokens": "def connect_mysql ( host , port , user , password , database ) : return pymysql . connect ( host = host , port = port , user = user , passwd = password , db = database )", "docstring_tokens": "Connect to MySQL with retries .", "label": 1}, {"idx": "cosqa-train-9353", "doc": "how to create progress bar in text widget python", "code": "def tick(self):\n        \"\"\"Add one tick to progress bar\"\"\"\n        self.current += 1\n        if self.current == self.factor:\n            sys.stdout.write('+')\n            sys.stdout.flush()\n            self.current = 0", "code_tokens": "def tick ( self ) : self . current += 1 if self . current == self . factor : sys . stdout . write ( '+' ) sys . stdout . flush ( ) self . current = 0", "docstring_tokens": "Add one tick to progress bar", "label": 1}, {"idx": "cosqa-train-9354", "doc": "python mysql connection retry", "code": "def connect_mysql(host, port, user, password, database):\n    \"\"\"Connect to MySQL with retries.\"\"\"\n    return pymysql.connect(\n        host=host, port=port,\n        user=user, passwd=password,\n        db=database\n    )", "code_tokens": "def connect_mysql ( host , port , user , password , database ) : return pymysql . connect ( host = host , port = port , user = user , passwd = password , db = database )", "docstring_tokens": "Connect to MySQL with retries .", "label": 1}, {"idx": "cosqa-train-9355", "doc": "how to create python api doc similar to javadoc", "code": "def doc_to_html(doc, doc_format=\"ROBOT\"):\n    \"\"\"Convert documentation to HTML\"\"\"\n    from robot.libdocpkg.htmlwriter import DocToHtml\n    return DocToHtml(doc_format)(doc)", "code_tokens": "def doc_to_html ( doc , doc_format = \"ROBOT\" ) : from robot . libdocpkg . htmlwriter import DocToHtml return DocToHtml ( doc_format ) ( doc )", "docstring_tokens": "Convert documentation to HTML", "label": 1}, {"idx": "cosqa-train-9356", "doc": "python nametuple to dict", "code": "def dictify(a_named_tuple):\n    \"\"\"Transform a named tuple into a dictionary\"\"\"\n    return dict((s, getattr(a_named_tuple, s)) for s in a_named_tuple._fields)", "code_tokens": "def dictify ( a_named_tuple ) : return dict ( ( s , getattr ( a_named_tuple , s ) ) for s in a_named_tuple . _fields )", "docstring_tokens": "Transform a named tuple into a dictionary", "label": 0}, {"idx": "cosqa-train-9357", "doc": "how to default a value in python 3 dictionary", "code": "def setdefault(obj, field, default):\n    \"\"\"Set an object's field to default if it doesn't have a value\"\"\"\n    setattr(obj, field, getattr(obj, field, default))", "code_tokens": "def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )", "docstring_tokens": "Set an object s field to default if it doesn t have a value", "label": 1}, {"idx": "cosqa-train-9358", "doc": "python ndarray boolean index", "code": "def maskIndex(self):\n        \"\"\" Returns a boolean index with True if the value is masked.\n\n            Always has the same shape as the maksedArray.data, event if the mask is a single boolan.\n        \"\"\"\n        if isinstance(self.mask, bool):\n            return np.full(self.data.shape, self.mask, dtype=np.bool)\n        else:\n            return self.mask", "code_tokens": "def maskIndex ( self ) : if isinstance ( self . mask , bool ) : return np . full ( self . data . shape , self . mask , dtype = np . bool ) else : return self . mask", "docstring_tokens": "Returns a boolean index with True if the value is masked .", "label": 1}, {"idx": "cosqa-train-9359", "doc": "how to define an array of undefined size in python", "code": "def __init__(self, capacity=10):\n        \"\"\"\n        Initialize python List with capacity of 10 or user given input.\n        Python List type is a dynamic array, so we have to restrict its\n        dynamic nature to make it work like a static array.\n        \"\"\"\n        super().__init__()\n        self._array = [None] * capacity\n        self._front = 0\n        self._rear = 0", "code_tokens": "def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0", "docstring_tokens": "Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array .", "label": 0}, {"idx": "cosqa-train-9360", "doc": "python ndarray get the first column", "code": "def last_item(array):\n    \"\"\"Returns the last item of an array in a list or an empty list.\"\"\"\n    if array.size == 0:\n        # work around for https://github.com/numpy/numpy/issues/5195\n        return []\n\n    indexer = (slice(-1, None),) * array.ndim\n    return np.ravel(array[indexer]).tolist()", "code_tokens": "def last_item ( array ) : if array . size == 0 : # work around for https://github.com/numpy/numpy/issues/5195 return [ ] indexer = ( slice ( - 1 , None ) , ) * array . ndim return np . ravel ( array [ indexer ] ) . tolist ( )", "docstring_tokens": "Returns the last item of an array in a list or an empty list .", "label": 0}, {"idx": "cosqa-train-9361", "doc": "how to define percentage in python", "code": "def ratio_and_percentage(current, total, time_remaining):\n    \"\"\"Returns the progress ratio and percentage.\"\"\"\n    return \"{} / {} ({}% completed)\".format(current, total, int(current / total * 100))", "code_tokens": "def ratio_and_percentage ( current , total , time_remaining ) : return \"{} / {} ({}% completed)\" . format ( current , total , int ( current / total * 100 ) )", "docstring_tokens": "Returns the progress ratio and percentage .", "label": 1}, {"idx": "cosqa-train-9362", "doc": "python nested dot notation for dictionary", "code": "def _attrprint(d, delimiter=', '):\n    \"\"\"Print a dictionary of attributes in the DOT format\"\"\"\n    return delimiter.join(('\"%s\"=\"%s\"' % item) for item in sorted(d.items()))", "code_tokens": "def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '\"%s\"=\"%s\"' % item ) for item in sorted ( d . items ( ) ) )", "docstring_tokens": "Print a dictionary of attributes in the DOT format", "label": 0}, {"idx": "cosqa-train-9363", "doc": "how to define the rbg color value in python", "code": "def set_color(self, fg=None, bg=None, intensify=False, target=sys.stdout):\n        \"\"\"Set foreground- and background colors and intensity.\"\"\"\n        raise NotImplementedError", "code_tokens": "def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError", "docstring_tokens": "Set foreground - and background colors and intensity .", "label": 0}, {"idx": "cosqa-train-9364", "doc": "python nodejs base64 decode get diffrence result", "code": "def _bytes_to_json(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\"\"\"\n    if isinstance(value, bytes):\n        value = base64.standard_b64encode(value).decode(\"ascii\")\n    return value", "code_tokens": "def _bytes_to_json ( value ) : if isinstance ( value , bytes ) : value = base64 . standard_b64encode ( value ) . decode ( \"ascii\" ) return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 0}, {"idx": "cosqa-train-9365", "doc": "how to delete an image from an image in python", "code": "def cli(env, identifier):\n    \"\"\"Delete an image.\"\"\"\n\n    image_mgr = SoftLayer.ImageManager(env.client)\n    image_id = helpers.resolve_id(image_mgr.resolve_ids, identifier, 'image')\n\n    image_mgr.delete_image(image_id)", "code_tokens": "def cli ( env , identifier ) : image_mgr = SoftLayer . ImageManager ( env . client ) image_id = helpers . resolve_id ( image_mgr . resolve_ids , identifier , 'image' ) image_mgr . delete_image ( image_id )", "docstring_tokens": "Delete an image .", "label": 1}, {"idx": "cosqa-train-9366", "doc": "python nonetype change to string", "code": "def bytes_to_str(s, encoding='utf-8'):\n    \"\"\"Returns a str if a bytes object is given.\"\"\"\n    if six.PY3 and isinstance(s, bytes):\n        return s.decode(encoding)\n    return s", "code_tokens": "def bytes_to_str ( s , encoding = 'utf-8' ) : if six . PY3 and isinstance ( s , bytes ) : return s . decode ( encoding ) return s", "docstring_tokens": "Returns a str if a bytes object is given .", "label": 0}, {"idx": "cosqa-train-9367", "doc": "how to delete previous line on python", "code": "def remove_last_line(self):\n        \"\"\"Removes the last line of the document.\"\"\"\n        editor = self._editor\n        text_cursor = editor.textCursor()\n        text_cursor.movePosition(text_cursor.End, text_cursor.MoveAnchor)\n        text_cursor.select(text_cursor.LineUnderCursor)\n        text_cursor.removeSelectedText()\n        text_cursor.deletePreviousChar()\n        editor.setTextCursor(text_cursor)", "code_tokens": "def remove_last_line ( self ) : editor = self . _editor text_cursor = editor . textCursor ( ) text_cursor . movePosition ( text_cursor . End , text_cursor . MoveAnchor ) text_cursor . select ( text_cursor . LineUnderCursor ) text_cursor . removeSelectedText ( ) text_cursor . deletePreviousChar ( ) editor . setTextCursor ( text_cursor )", "docstring_tokens": "Removes the last line of the document .", "label": 1}, {"idx": "cosqa-train-9368", "doc": "python nonetype object has no attributte", "code": "def listlike(obj):\n    \"\"\"Is an object iterable like a list (and not a string)?\"\"\"\n    \n    return hasattr(obj, \"__iter__\") \\\n    and not issubclass(type(obj), str)\\\n    and not issubclass(type(obj), unicode)", "code_tokens": "def listlike ( obj ) : return hasattr ( obj , \"__iter__\" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )", "docstring_tokens": "Is an object iterable like a list ( and not a string ) ?", "label": 1}, {"idx": "cosqa-train-9369", "doc": "how to delete python paths", "code": "def delete_all_eggs(self):\n        \"\"\" delete all the eggs in the directory specified \"\"\"\n        path_to_delete = os.path.join(self.egg_directory, \"lib\", \"python\")\n        if os.path.exists(path_to_delete):\n            shutil.rmtree(path_to_delete)", "code_tokens": "def delete_all_eggs ( self ) : path_to_delete = os . path . join ( self . egg_directory , \"lib\" , \"python\" ) if os . path . exists ( path_to_delete ) : shutil . rmtree ( path_to_delete )", "docstring_tokens": "delete all the eggs in the directory specified", "label": 1}, {"idx": "cosqa-train-9370", "doc": "python normal distribution dense function", "code": "def norm(x, mu, sigma=1.0):\n    \"\"\" Scipy norm function \"\"\"\n    return stats.norm(loc=mu, scale=sigma).pdf(x)", "code_tokens": "def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )", "docstring_tokens": "Scipy norm function", "label": 0}, {"idx": "cosqa-train-9371", "doc": "how to describe objects in python shell", "code": "def stats(self):\n        \"\"\" shotcut to pull out useful info for interactive use \"\"\"\n        printDebug(\"Classes.....: %d\" % len(self.all_classes))\n        printDebug(\"Properties..: %d\" % len(self.all_properties))", "code_tokens": "def stats ( self ) : printDebug ( \"Classes.....: %d\" % len ( self . all_classes ) ) printDebug ( \"Properties..: %d\" % len ( self . all_properties ) )", "docstring_tokens": "shotcut to pull out useful info for interactive use", "label": 0}, {"idx": "cosqa-train-9372", "doc": "python normal distribution density", "code": "def pdf(x, mu, std):\n    \"\"\"Probability density function (normal distribution)\"\"\"\n    return (1.0 / (std * sqrt(2 * pi))) * np.exp(-(x - mu) ** 2 / (2 * std ** 2))", "code_tokens": "def pdf ( x , mu , std ) : return ( 1.0 / ( std * sqrt ( 2 * pi ) ) ) * np . exp ( - ( x - mu ) ** 2 / ( 2 * std ** 2 ) )", "docstring_tokens": "Probability density function ( normal distribution )", "label": 1}, {"idx": "cosqa-train-9373", "doc": "how to detect mouse click in the graphic window in python", "code": "def on_mouse_motion(self, x, y, dx, dy):\n        \"\"\"\n        Pyglet specific mouse motion callback.\n        Forwards and traslates the event to the example\n        \"\"\"\n        # Screen coordinates relative to the lower-left corner\n        # so we have to flip the y axis to make this consistent with\n        # other window libraries\n        self.example.mouse_position_event(x, self.buffer_height - y)", "code_tokens": "def on_mouse_motion ( self , x , y , dx , dy ) : # Screen coordinates relative to the lower-left corner\n # so we have to flip the y axis to make this consistent with\n # other window libraries\n self . example . mouse_position_event ( x , self . buffer_height - y )", "docstring_tokens": "Pyglet specific mouse motion callback . Forwards and traslates the event to the example", "label": 1}, {"idx": "cosqa-train-9374", "doc": "python normalize grayscale image 0 to 1", "code": "def _normalize(mat: np.ndarray):\n    \"\"\"rescales a numpy array, so that min is 0 and max is 255\"\"\"\n    return ((mat - mat.min()) * (255 / mat.max())).astype(np.uint8)", "code_tokens": "def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )", "docstring_tokens": "rescales a numpy array so that min is 0 and max is 255", "label": 0}, {"idx": "cosqa-train-9375", "doc": "how to detect names regular expression python", "code": "def _namematcher(regex):\n    \"\"\"Checks if a target name matches with an input regular expression.\"\"\"\n\n    matcher = re_compile(regex)\n\n    def match(target):\n        target_name = getattr(target, '__name__', '')\n        result = matcher.match(target_name)\n        return result\n\n    return match", "code_tokens": "def _namematcher ( regex ) : matcher = re_compile ( regex ) def match ( target ) : target_name = getattr ( target , '__name__' , '' ) result = matcher . match ( target_name ) return result return match", "docstring_tokens": "Checks if a target name matches with an input regular expression .", "label": 1}, {"idx": "cosqa-train-9376", "doc": "python normalize grayscale image to 0 255", "code": "def normalize(im, invert=False, scale=None, dtype=np.float64):\n    \"\"\"\n    Normalize a field to a (min, max) exposure range, default is (0, 255).\n    (min, max) exposure values. Invert the image if requested.\n    \"\"\"\n    if dtype not in {np.float16, np.float32, np.float64}:\n        raise ValueError('dtype must be numpy.float16, float32, or float64.')\n    out = im.astype('float').copy()\n\n    scale = scale or (0.0, 255.0)\n    l, u = (float(i) for i in scale)\n    out = (out - l) / (u - l)\n    if invert:\n        out = -out + (out.max() + out.min())\n    return out.astype(dtype)", "code_tokens": "def normalize ( im , invert = False , scale = None , dtype = np . float64 ) : if dtype not in { np . float16 , np . float32 , np . float64 } : raise ValueError ( 'dtype must be numpy.float16, float32, or float64.' ) out = im . astype ( 'float' ) . copy ( ) scale = scale or ( 0.0 , 255.0 ) l , u = ( float ( i ) for i in scale ) out = ( out - l ) / ( u - l ) if invert : out = - out + ( out . max ( ) + out . min ( ) ) return out . astype ( dtype )", "docstring_tokens": "Normalize a field to a ( min max ) exposure range default is ( 0 255 ) . ( min max ) exposure values . Invert the image if requested .", "label": 0}, {"idx": "cosqa-train-9377", "doc": "how to detect what key someone presses in python", "code": "def read_key(suppress=False):\n    \"\"\"\n    Blocks until a keyboard event happens, then returns that event's name or,\n    if missing, its scan code.\n    \"\"\"\n    event = read_event(suppress)\n    return event.name or event.scan_code", "code_tokens": "def read_key ( suppress = False ) : event = read_event ( suppress ) return event . name or event . scan_code", "docstring_tokens": "Blocks until a keyboard event happens then returns that event s name or if missing its scan code .", "label": 1}, {"idx": "cosqa-train-9378", "doc": "python normalize text string", "code": "def normalize(self, string):\n        \"\"\"Normalize the string according to normalization list\"\"\"\n        return ''.join([self._normalize.get(x, x) for x in nfd(string)])", "code_tokens": "def normalize ( self , string ) : return '' . join ( [ self . _normalize . get ( x , x ) for x in nfd ( string ) ] )", "docstring_tokens": "Normalize the string according to normalization list", "label": 1}, {"idx": "cosqa-train-9379", "doc": "how to determine if a value is a string python", "code": "def is_string(val):\n    \"\"\"Determines whether the passed value is a string, safe for 2/3.\"\"\"\n    try:\n        basestring\n    except NameError:\n        return isinstance(val, str)\n    return isinstance(val, basestring)", "code_tokens": "def is_string ( val ) : try : basestring except NameError : return isinstance ( val , str ) return isinstance ( val , basestring )", "docstring_tokens": "Determines whether the passed value is a string safe for 2 / 3 .", "label": 1}, {"idx": "cosqa-train-9380", "doc": "python not eqaul to", "code": "def ComplementEquivalence(*args, **kwargs):\n    \"\"\"Change x != y to not(x == y).\"\"\"\n    return ast.Complement(\n        ast.Equivalence(*args, **kwargs), **kwargs)", "code_tokens": "def ComplementEquivalence ( * args , * * kwargs ) : return ast . Complement ( ast . Equivalence ( * args , * * kwargs ) , * * kwargs )", "docstring_tokens": "Change x ! = y to not ( x == y ) .", "label": 0}, {"idx": "cosqa-train-9381", "doc": "how to determine if every list entry contains cat in python", "code": "def test_for_image(self, cat, img):\n        \"\"\"Tests if image img in category cat exists\"\"\"\n        return self.test_for_category(cat) and img in self.items[cat]", "code_tokens": "def test_for_image ( self , cat , img ) : return self . test_for_category ( cat ) and img in self . items [ cat ]", "docstring_tokens": "Tests if image img in category cat exists", "label": 0}, {"idx": "cosqa-train-9382", "doc": "python not running in interactive mode", "code": "def isInteractive():\n    \"\"\"\n    A basic check of if the program is running in interactive mode\n    \"\"\"\n    if sys.stdout.isatty() and os.name != 'nt':\n        #Hopefully everything but ms supports '\\r'\n        try:\n            import threading\n        except ImportError:\n            return False\n        else:\n            return True\n    else:\n        return False", "code_tokens": "def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\\r' try : import threading except ImportError : return False else : return True else : return False", "docstring_tokens": "A basic check of if the program is running in interactive mode", "label": 0}, {"idx": "cosqa-train-9383", "doc": "how to determine whether a list is descending in python", "code": "def issorted(list_, op=operator.le):\n    \"\"\"\n    Determines if a list is sorted\n\n    Args:\n        list_ (list):\n        op (func): sorted operation (default=operator.le)\n\n    Returns:\n        bool : True if the list is sorted\n    \"\"\"\n    return all(op(list_[ix], list_[ix + 1]) for ix in range(len(list_) - 1))", "code_tokens": "def issorted ( list_ , op = operator . le ) : return all ( op ( list_ [ ix ] , list_ [ ix + 1 ] ) for ix in range ( len ( list_ ) - 1 ) )", "docstring_tokens": "Determines if a list is sorted", "label": 1}, {"idx": "cosqa-train-9384", "doc": "python np last points in an array", "code": "def other_ind(self):\n        \"\"\"last row or column of square A\"\"\"\n        return np.full(self.n_min, self.size - 1, dtype=np.int)", "code_tokens": "def other_ind ( self ) : return np . full ( self . n_min , self . size - 1 , dtype = np . int )", "docstring_tokens": "last row or column of square A", "label": 0}, {"idx": "cosqa-train-9385", "doc": "how to discretize columns in equal sized bins python", "code": "def incidence(boundary):\n    \"\"\"\n    given an Nxm matrix containing boundary info between simplices,\n    compute indidence info matrix\n    not very reusable; should probably not be in this lib\n    \"\"\"\n    return GroupBy(boundary).split(np.arange(boundary.size) // boundary.shape[1])", "code_tokens": "def incidence ( boundary ) : return GroupBy ( boundary ) . split ( np . arange ( boundary . size ) // boundary . shape [ 1 ] )", "docstring_tokens": "given an Nxm matrix containing boundary info between simplices compute indidence info matrix not very reusable ; should probably not be in this lib", "label": 1}, {"idx": "cosqa-train-9386", "doc": "python numpy arrary max along axis", "code": "def Max(a, axis, keep_dims):\n    \"\"\"\n    Max reduction op.\n    \"\"\"\n    return np.amax(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis),\n                   keepdims=keep_dims),", "code_tokens": "def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "docstring_tokens": "Max reduction op .", "label": 1}, {"idx": "cosqa-train-9387", "doc": "how to display calculation as percent python", "code": "def ratio_and_percentage(current, total, time_remaining):\n    \"\"\"Returns the progress ratio and percentage.\"\"\"\n    return \"{} / {} ({}% completed)\".format(current, total, int(current / total * 100))", "code_tokens": "def ratio_and_percentage ( current , total , time_remaining ) : return \"{} / {} ({}% completed)\" . format ( current , total , int ( current / total * 100 ) )", "docstring_tokens": "Returns the progress ratio and percentage .", "label": 1}, {"idx": "cosqa-train-9388", "doc": "python numpy gaussian fit", "code": "def fit_gaussian(samples, ddof=0):\n    \"\"\"Calculates the mean and the standard deviation of the given samples.\n\n    Args:\n        samples (ndarray): a one or two dimensional array. If one dimensional we calculate the fit using all\n            values. If two dimensional, we fit the Gaussian for every set of samples over the first dimension.\n        ddof (int): the difference degrees of freedom in the std calculation. See numpy.\n    \"\"\"\n    if len(samples.shape) == 1:\n        return np.mean(samples), np.std(samples, ddof=ddof)\n    return np.mean(samples, axis=1), np.std(samples, axis=1, ddof=ddof)", "code_tokens": "def fit_gaussian ( samples , ddof = 0 ) : if len ( samples . shape ) == 1 : return np . mean ( samples ) , np . std ( samples , ddof = ddof ) return np . mean ( samples , axis = 1 ) , np . std ( samples , axis = 1 , ddof = ddof )", "docstring_tokens": "Calculates the mean and the standard deviation of the given samples .", "label": 1}, {"idx": "cosqa-train-9389", "doc": "how to do a factorial with loops python", "code": "def computeFactorial(n):\n    \"\"\"\n    computes factorial of n\n    \"\"\"\n    sleep_walk(10)\n    ret = 1\n    for i in range(n):\n        ret = ret * (i + 1)\n    return ret", "code_tokens": "def computeFactorial ( n ) : sleep_walk ( 10 ) ret = 1 for i in range ( n ) : ret = ret * ( i + 1 ) return ret", "docstring_tokens": "computes factorial of n", "label": 0}, {"idx": "cosqa-train-9390", "doc": "python numpy matrix distance between", "code": "def get_distance_matrix(x):\n    \"\"\"Get distance matrix given a matrix. Used in testing.\"\"\"\n    square = nd.sum(x ** 2.0, axis=1, keepdims=True)\n    distance_square = square + square.transpose() - (2.0 * nd.dot(x, x.transpose()))\n    return nd.sqrt(distance_square)", "code_tokens": "def get_distance_matrix ( x ) : square = nd . sum ( x ** 2.0 , axis = 1 , keepdims = True ) distance_square = square + square . transpose ( ) - ( 2.0 * nd . dot ( x , x . transpose ( ) ) ) return nd . sqrt ( distance_square )", "docstring_tokens": "Get distance matrix given a matrix . Used in testing .", "label": 0}, {"idx": "cosqa-train-9391", "doc": "how to do a set width of string in python", "code": "def wrap(string, length, indent):\n    \"\"\" Wrap a string at a line length \"\"\"\n    newline = \"\\n\" + \" \" * indent\n    return newline.join((string[i : i + length] for i in range(0, len(string), length)))", "code_tokens": "def wrap ( string , length , indent ) : newline = \"\\n\" + \" \" * indent return newline . join ( ( string [ i : i + length ] for i in range ( 0 , len ( string ) , length ) ) )", "docstring_tokens": "Wrap a string at a line length", "label": 0}, {"idx": "cosqa-train-9392", "doc": "python numpy parse binary file", "code": "def read_numpy(fh, byteorder, dtype, count, offsetsize):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    dtype = 'b' if dtype[-1] == 's' else byteorder+dtype[-1]\n    return fh.read_array(dtype, count)", "code_tokens": "def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 1}, {"idx": "cosqa-train-9393", "doc": "how to do an inverse matrix in python sympy", "code": "def inh(table):\n    \"\"\"\n    inverse hyperbolic sine transformation\n    \"\"\"\n    t = []\n    for i in table:\n        t.append(np.ndarray.tolist(np.arcsinh(i)))\n    return t", "code_tokens": "def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "docstring_tokens": "inverse hyperbolic sine transformation", "label": 0}, {"idx": "cosqa-train-9394", "doc": "python numpy read binary array from file", "code": "def read_numpy(fh, byteorder, dtype, count, offsetsize):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    dtype = 'b' if dtype[-1] == 's' else byteorder+dtype[-1]\n    return fh.read_array(dtype, count)", "code_tokens": "def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 1}, {"idx": "cosqa-train-9395", "doc": "how to do garbage collection in python", "code": "def cleanup_storage(*args):\n    \"\"\"Clean up processes after SIGTERM or SIGINT is received.\"\"\"\n    ShardedClusters().cleanup()\n    ReplicaSets().cleanup()\n    Servers().cleanup()\n    sys.exit(0)", "code_tokens": "def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )", "docstring_tokens": "Clean up processes after SIGTERM or SIGINT is received .", "label": 1}, {"idx": "cosqa-train-9396", "doc": "python numpy string dtype", "code": "def dict_to_numpy_array(d):\n    \"\"\"\n    Convert a dict of 1d array to a numpy recarray\n    \"\"\"\n    return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))", "code_tokens": "def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )", "docstring_tokens": "Convert a dict of 1d array to a numpy recarray", "label": 1}, {"idx": "cosqa-train-9397", "doc": "how to document an enum python", "code": "def _Enum(docstring, *names):\n  \"\"\"Utility to generate enum classes used by annotations.\n\n  Args:\n    docstring: Docstring for the generated enum class.\n    *names: Enum names.\n\n  Returns:\n    A class that contains enum names as attributes.\n  \"\"\"\n  enums = dict(zip(names, range(len(names))))\n  reverse = dict((value, key) for key, value in enums.iteritems())\n  enums['reverse_mapping'] = reverse\n  enums['__doc__'] = docstring\n  return type('Enum', (object,), enums)", "code_tokens": "def _Enum ( docstring , * names ) : enums = dict ( zip ( names , range ( len ( names ) ) ) ) reverse = dict ( ( value , key ) for key , value in enums . iteritems ( ) ) enums [ 'reverse_mapping' ] = reverse enums [ '__doc__' ] = docstring return type ( 'Enum' , ( object , ) , enums )", "docstring_tokens": "Utility to generate enum classes used by annotations .", "label": 0}, {"idx": "cosqa-train-9398", "doc": "python numpy to table", "code": "def from_array(cls, arr):\n        \"\"\"Convert a structured NumPy array into a Table.\"\"\"\n        return cls().with_columns([(f, arr[f]) for f in arr.dtype.names])", "code_tokens": "def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )", "docstring_tokens": "Convert a structured NumPy array into a Table .", "label": 0}, {"idx": "cosqa-train-9399", "doc": "how to download txt file from internet in python", "code": "def get_dates_link(url):\n    \"\"\" download the dates file from the internet and parse it as a dates file\"\"\"\n    urllib.request.urlretrieve(url, \"temp.txt\")\n    dates = get_dates_file(\"temp.txt\")\n    os.remove(\"temp.txt\")\n    return dates", "code_tokens": "def get_dates_link ( url ) : urllib . request . urlretrieve ( url , \"temp.txt\" ) dates = get_dates_file ( \"temp.txt\" ) os . remove ( \"temp.txt\" ) return dates", "docstring_tokens": "download the dates file from the internet and parse it as a dates file", "label": 1}, {"idx": "cosqa-train-9400", "doc": "python numpy two matrix element wise function", "code": "def sorted_product_set(array_a, array_b):\n  \"\"\"Compute the product set of array_a and array_b and sort it.\"\"\"\n  return np.sort(\n      np.concatenate(\n          [array_a[i] * array_b for i in xrange(len(array_a))], axis=0)\n  )[::-1]", "code_tokens": "def sorted_product_set ( array_a , array_b ) : return np . sort ( np . concatenate ( [ array_a [ i ] * array_b for i in xrange ( len ( array_a ) ) ] , axis = 0 ) ) [ : : - 1 ]", "docstring_tokens": "Compute the product set of array_a and array_b and sort it .", "label": 1}, {"idx": "cosqa-train-9401", "doc": "how to edit all column width in python openpyxl", "code": "def _xls2col_widths(self, worksheet, tab):\n        \"\"\"Updates col_widths in code_array\"\"\"\n\n        for col in xrange(worksheet.ncols):\n            try:\n                xls_width = worksheet.colinfo_map[col].width\n                pys_width = self.xls_width2pys_width(xls_width)\n                self.code_array.col_widths[col, tab] = pys_width\n\n            except KeyError:\n                pass", "code_tokens": "def _xls2col_widths ( self , worksheet , tab ) : for col in xrange ( worksheet . ncols ) : try : xls_width = worksheet . colinfo_map [ col ] . width pys_width = self . xls_width2pys_width ( xls_width ) self . code_array . col_widths [ col , tab ] = pys_width except KeyError : pass", "docstring_tokens": "Updates col_widths in code_array", "label": 1}, {"idx": "cosqa-train-9402", "doc": "python object gets converted to string in list", "code": "def _tostr(self,obj):\n        \"\"\" converts a object to list, if object is a list, it creates a\n            comma seperated string.\n        \"\"\"\n        if not obj:\n            return ''\n        if isinstance(obj, list):\n            return ', '.join(map(self._tostr, obj))\n        return str(obj)", "code_tokens": "def _tostr ( self , obj ) : if not obj : return '' if isinstance ( obj , list ) : return ', ' . join ( map ( self . _tostr , obj ) ) return str ( obj )", "docstring_tokens": "converts a object to list if object is a list it creates a comma seperated string .", "label": 1}, {"idx": "cosqa-train-9403", "doc": "how to eliminate instances in python", "code": "def clear_instance(cls):\n        \"\"\"unset _instance for this class and singleton parents.\n        \"\"\"\n        if not cls.initialized():\n            return\n        for subclass in cls._walk_mro():\n            if isinstance(subclass._instance, cls):\n                # only clear instances that are instances\n                # of the calling class\n                subclass._instance = None", "code_tokens": "def clear_instance ( cls ) : if not cls . initialized ( ) : return for subclass in cls . _walk_mro ( ) : if isinstance ( subclass . _instance , cls ) : # only clear instances that are instances # of the calling class subclass . _instance = None", "docstring_tokens": "unset _instance for this class and singleton parents .", "label": 1}, {"idx": "cosqa-train-9404", "doc": "python object has no attribute 'iteritems'", "code": "def iterlists(self):\n        \"\"\"Like :meth:`items` but returns an iterator.\"\"\"\n        for key, values in dict.iteritems(self):\n            yield key, list(values)", "code_tokens": "def iterlists ( self ) : for key , values in dict . iteritems ( self ) : yield key , list ( values )", "docstring_tokens": "Like : meth : items but returns an iterator .", "label": 1}, {"idx": "cosqa-train-9405", "doc": "how to end a python session in cmd", "code": "def delete_connection():\n    \"\"\"\n    Stop and destroy Bloomberg connection\n    \"\"\"\n    if _CON_SYM_ in globals():\n        con = globals().pop(_CON_SYM_)\n        if not getattr(con, '_session').start(): con.stop()", "code_tokens": "def delete_connection ( ) : if _CON_SYM_ in globals ( ) : con = globals ( ) . pop ( _CON_SYM_ ) if not getattr ( con , '_session' ) . start ( ) : con . stop ( )", "docstring_tokens": "Stop and destroy Bloomberg connection", "label": 1}, {"idx": "cosqa-train-9406", "doc": "python object has no attribute 'pop'", "code": "def PopAttributeContainer(self):\n    \"\"\"Pops a serialized attribute container from the list.\n\n    Returns:\n      bytes: serialized attribute container data.\n    \"\"\"\n    try:\n      serialized_data = self._list.pop(0)\n      self.data_size -= len(serialized_data)\n      return serialized_data\n\n    except IndexError:\n      return None", "code_tokens": "def PopAttributeContainer ( self ) : try : serialized_data = self . _list . pop ( 0 ) self . data_size -= len ( serialized_data ) return serialized_data except IndexError : return None", "docstring_tokens": "Pops a serialized attribute container from the list .", "label": 1}, {"idx": "cosqa-train-9407", "doc": "how to exclude multiline comments in python with re", "code": "def _ignore_comments(lines_enum):\n    \"\"\"\n    Strips comments and filter empty lines.\n    \"\"\"\n    for line_number, line in lines_enum:\n        line = COMMENT_RE.sub('', line)\n        line = line.strip()\n        if line:\n            yield line_number, line", "code_tokens": "def _ignore_comments ( lines_enum ) : for line_number , line in lines_enum : line = COMMENT_RE . sub ( '' , line ) line = line . strip ( ) if line : yield line_number , line", "docstring_tokens": "Strips comments and filter empty lines .", "label": 1}, {"idx": "cosqa-train-9408", "doc": "python object is not nonetype", "code": "def listlike(obj):\n    \"\"\"Is an object iterable like a list (and not a string)?\"\"\"\n    \n    return hasattr(obj, \"__iter__\") \\\n    and not issubclass(type(obj), str)\\\n    and not issubclass(type(obj), unicode)", "code_tokens": "def listlike ( obj ) : return hasattr ( obj , \"__iter__\" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )", "docstring_tokens": "Is an object iterable like a list ( and not a string ) ?", "label": 1}, {"idx": "cosqa-train-9409", "doc": "how to exit python", "code": "def _quit(self, *args):\n        \"\"\" quit crash \"\"\"\n        self.logger.warn('Bye!')\n        sys.exit(self.exit())", "code_tokens": "def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )", "docstring_tokens": "quit crash", "label": 0}, {"idx": "cosqa-train-9410", "doc": "python object persistence to json", "code": "def to_json(obj):\n    \"\"\"Return a json string representing the python object obj.\"\"\"\n    i = StringIO.StringIO()\n    w = Writer(i, encoding='UTF-8')\n    w.write_value(obj)\n    return i.getvalue()", "code_tokens": "def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )", "docstring_tokens": "Return a json string representing the python object obj .", "label": 1}, {"idx": "cosqa-train-9411", "doc": "how to expand address ranges python", "code": "def ip_address_list(ips):\n    \"\"\" IP address range validation and expansion. \"\"\"\n    # first, try it as a single IP address\n    try:\n        return ip_address(ips)\n    except ValueError:\n        pass\n    # then, consider it as an ipaddress.IPv[4|6]Network instance and expand it\n    return list(ipaddress.ip_network(u(ips)).hosts())", "code_tokens": "def ip_address_list ( ips ) : # first, try it as a single IP address try : return ip_address ( ips ) except ValueError : pass # then, consider it as an ipaddress.IPv[4|6]Network instance and expand it return list ( ipaddress . ip_network ( u ( ips ) ) . hosts ( ) )", "docstring_tokens": "IP address range validation and expansion .", "label": 0}, {"idx": "cosqa-train-9412", "doc": "how to express login timeout in python flask", "code": "def set_timeout(scope, timeout):\n    \"\"\"\n    Defines the time after which Exscript fails if it does not receive a\n    prompt from the remote host.\n\n    :type  timeout: int\n    :param timeout: The timeout in seconds.\n    \"\"\"\n    conn = scope.get('__connection__')\n    conn.set_timeout(int(timeout[0]))\n    return True", "code_tokens": "def set_timeout ( scope , timeout ) : conn = scope . get ( '__connection__' ) conn . set_timeout ( int ( timeout [ 0 ] ) ) return True", "docstring_tokens": "Defines the time after which Exscript fails if it does not receive a prompt from the remote host .", "label": 0}, {"idx": "cosqa-train-9413", "doc": "python one hot to indices", "code": "def one_hot(x, size, dtype=np.float32):\n  \"\"\"Make a n+1 dim one-hot array from n dim int-categorical array.\"\"\"\n  return np.array(x[..., np.newaxis] == np.arange(size), dtype)", "code_tokens": "def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )", "docstring_tokens": "Make a n + 1 dim one - hot array from n dim int - categorical array .", "label": 1}, {"idx": "cosqa-train-9414", "doc": "how to fill a list one by one in python", "code": "def _fill_array_from_list(the_list, the_array):\n        \"\"\"Fill an `array` from a `list`\"\"\"\n        for i, val in enumerate(the_list):\n            the_array[i] = val\n        return the_array", "code_tokens": "def _fill_array_from_list ( the_list , the_array ) : for i , val in enumerate ( the_list ) : the_array [ i ] = val return the_array", "docstring_tokens": "Fill an array from a list", "label": 1}, {"idx": "cosqa-train-9415", "doc": "python one liner to prefix and suffix a string", "code": "def add_suffix(fullname, suffix):\n    \"\"\" Add suffix to a full file name\"\"\"\n    name, ext = os.path.splitext(fullname)\n    return name + '_' + suffix + ext", "code_tokens": "def add_suffix ( fullname , suffix ) : name , ext = os . path . splitext ( fullname ) return name + '_' + suffix + ext", "docstring_tokens": "Add suffix to a full file name", "label": 0}, {"idx": "cosqa-train-9416", "doc": "how to filter a dictionary on the basis of key in python", "code": "def filter_dict(d, keys):\n    \"\"\"\n    Creates a new dict from an existing dict that only has the given keys\n    \"\"\"\n    return {k: v for k, v in d.items() if k in keys}", "code_tokens": "def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "docstring_tokens": "Creates a new dict from an existing dict that only has the given keys", "label": 1}, {"idx": "cosqa-train-9417", "doc": "python open read will not interfere with a locked file", "code": "def lock_file(f, block=False):\n    \"\"\"\n    If block=False (the default), die hard and fast if another process has\n    already grabbed the lock for this file.\n\n    If block=True, wait for the lock to be released, then continue.\n    \"\"\"\n    try:\n        flags = fcntl.LOCK_EX\n        if not block:\n            flags |= fcntl.LOCK_NB\n        fcntl.flock(f.fileno(), flags)\n    except IOError as e:\n        if e.errno in (errno.EACCES, errno.EAGAIN):\n            raise SystemExit(\"ERROR: %s is locked by another process.\" %\n                             f.name)\n        raise", "code_tokens": "def lock_file ( f , block = False ) : try : flags = fcntl . LOCK_EX if not block : flags |= fcntl . LOCK_NB fcntl . flock ( f . fileno ( ) , flags ) except IOError as e : if e . errno in ( errno . EACCES , errno . EAGAIN ) : raise SystemExit ( \"ERROR: %s is locked by another process.\" % f . name ) raise", "docstring_tokens": "If block = False ( the default ) die hard and fast if another process has already grabbed the lock for this file .", "label": 1}, {"idx": "cosqa-train-9418", "doc": "how to fix a float error in python", "code": "def _convert_to_float_if_possible(s):\n    \"\"\"\n    A small helper function to convert a string to a numeric value\n    if appropriate\n\n    :param s: the string to be converted\n    :type s: str\n    \"\"\"\n    try:\n        ret = float(s)\n    except (ValueError, TypeError):\n        ret = s\n    return ret", "code_tokens": "def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret", "docstring_tokens": "A small helper function to convert a string to a numeric value if appropriate", "label": 0}, {"idx": "cosqa-train-9419", "doc": "python opencv rotate image 90 degree", "code": "def rotate_img(im, deg, mode=cv2.BORDER_CONSTANT, interpolation=cv2.INTER_AREA):\n    \"\"\" Rotates an image by deg degrees\n\n    Arguments:\n        deg (float): degree to rotate.\n    \"\"\"\n    r,c,*_ = im.shape\n    M = cv2.getRotationMatrix2D((c//2,r//2),deg,1)\n    return cv2.warpAffine(im,M,(c,r), borderMode=mode, flags=cv2.WARP_FILL_OUTLIERS+interpolation)", "code_tokens": "def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )", "docstring_tokens": "Rotates an image by deg degrees", "label": 0}, {"idx": "cosqa-train-9420", "doc": "how to fix a python source file", "code": "def rpc_fix_code_with_black(self, source, directory):\n        \"\"\"Formats Python code to conform to the PEP 8 style guide.\n\n        \"\"\"\n        source = get_source(source)\n        return fix_code_with_black(source, directory)", "code_tokens": "def rpc_fix_code_with_black ( self , source , directory ) : source = get_source ( source ) return fix_code_with_black ( source , directory )", "docstring_tokens": "Formats Python code to conform to the PEP 8 style guide .", "label": 1}, {"idx": "cosqa-train-9421", "doc": "python opengl get object window coordinates", "code": "def set(self):\n        \"\"\"Set the color as current OpenGL color\n        \"\"\"\n        glColor4f(self.r, self.g, self.b, self.a)", "code_tokens": "def set ( self ) : glColor4f ( self . r , self . g , self . b , self . a )", "docstring_tokens": "Set the color as current OpenGL color", "label": 0}, {"idx": "cosqa-train-9422", "doc": "how to flag deprecated function python", "code": "def warn_deprecated(message, stacklevel=2):  # pragma: no cover\n    \"\"\"Warn deprecated.\"\"\"\n\n    warnings.warn(\n        message,\n        category=DeprecationWarning,\n        stacklevel=stacklevel\n    )", "code_tokens": "def warn_deprecated ( message , stacklevel = 2 ) : # pragma: no cover warnings . warn ( message , category = DeprecationWarning , stacklevel = stacklevel )", "docstring_tokens": "Warn deprecated .", "label": 0}, {"idx": "cosqa-train-9423", "doc": "python opengl to create a 3d coordinate", "code": "def _genTex2D(self):\n        \"\"\"Generate an empty texture in OpenGL\"\"\"\n        for face in range(6):\n            gl.glTexImage2D(self.target0 + face, 0, self.internal_fmt, self.width, self.height, 0,\n                            self.pixel_fmt, gl.GL_UNSIGNED_BYTE, 0)", "code_tokens": "def _genTex2D ( self ) : for face in range ( 6 ) : gl . glTexImage2D ( self . target0 + face , 0 , self . internal_fmt , self . width , self . height , 0 , self . pixel_fmt , gl . GL_UNSIGNED_BYTE , 0 )", "docstring_tokens": "Generate an empty texture in OpenGL", "label": 1}, {"idx": "cosqa-train-9424", "doc": "how to force cursor to go to next line in python", "code": "def cursor_up(self, count=1):\n        \"\"\" (for multiline edit). Move cursor to the previous line.  \"\"\"\n        original_column = self.preferred_column or self.document.cursor_position_col\n        self.cursor_position += self.document.get_cursor_up_position(\n            count=count, preferred_column=original_column)\n\n        # Remember the original column for the next up/down movement.\n        self.preferred_column = original_column", "code_tokens": "def cursor_up ( self , count = 1 ) : original_column = self . preferred_column or self . document . cursor_position_col self . cursor_position += self . document . get_cursor_up_position ( count = count , preferred_column = original_column ) # Remember the original column for the next up/down movement. self . preferred_column = original_column", "docstring_tokens": "( for multiline edit ) . Move cursor to the previous line .", "label": 1}, {"idx": "cosqa-train-9425", "doc": "python openpyxl patternfill bgcolor", "code": "def _get_pattern(self, pys_style):\n        \"\"\"Returns xlwt.pattern for pyspread style\"\"\"\n\n        # Return None if there is no bgcolor\n        if \"bgcolor\" not in pys_style:\n            return\n\n        pattern = xlwt.Pattern()\n        pattern.pattern = xlwt.Pattern.SOLID_PATTERN\n\n        bgcolor = wx.Colour()\n        bgcolor.SetRGB(pys_style[\"bgcolor\"])\n        pattern.pattern_fore_colour = self.color2idx(*bgcolor.Get())\n\n        return pattern", "code_tokens": "def _get_pattern ( self , pys_style ) : # Return None if there is no bgcolor if \"bgcolor\" not in pys_style : return pattern = xlwt . Pattern ( ) pattern . pattern = xlwt . Pattern . SOLID_PATTERN bgcolor = wx . Colour ( ) bgcolor . SetRGB ( pys_style [ \"bgcolor\" ] ) pattern . pattern_fore_colour = self . color2idx ( * bgcolor . Get ( ) ) return pattern", "docstring_tokens": "Returns xlwt . pattern for pyspread style", "label": 1}, {"idx": "cosqa-train-9426", "doc": "how to forcibly close all threads python", "code": "def shutdown():\n    \"\"\"Manually shutdown the async API.\n\n    Cancels all related tasks and all the socket transportation.\n    \"\"\"\n    global handler, transport, protocol\n    if handler is not None:\n        handler.close()\n        transport.close()\n        handler = None\n        transport = None\n        protocol = None", "code_tokens": "def shutdown ( ) : global handler , transport , protocol if handler is not None : handler . close ( ) transport . close ( ) handler = None transport = None protocol = None", "docstring_tokens": "Manually shutdown the async API .", "label": 1}, {"idx": "cosqa-train-9427", "doc": "python os get modified time of file", "code": "def get_time(filename):\n\t\"\"\"\n\tGet the modified time for a file as a datetime instance\n\t\"\"\"\n\tts = os.stat(filename).st_mtime\n\treturn datetime.datetime.utcfromtimestamp(ts)", "code_tokens": "def get_time ( filename ) : ts = os . stat ( filename ) . st_mtime return datetime . datetime . utcfromtimestamp ( ts )", "docstring_tokens": "Get the modified time for a file as a datetime instance", "label": 1}, {"idx": "cosqa-train-9428", "doc": "how to form ordered dictionary in python", "code": "def get_order(self):\n        \"\"\"\n        Return a list of dicionaries. See `set_order`.\n        \"\"\"\n        return [dict(reverse=r[0], key=r[1]) for r in self.get_model()]", "code_tokens": "def get_order ( self ) : return [ dict ( reverse = r [ 0 ] , key = r [ 1 ] ) for r in self . get_model ( ) ]", "docstring_tokens": "Return a list of dicionaries . See set_order .", "label": 0}, {"idx": "cosqa-train-9429", "doc": "python pad image to given size", "code": "def impad_to_multiple(img, divisor, pad_val=0):\n    \"\"\"Pad an image to ensure each edge to be multiple to some number.\n\n    Args:\n        img (ndarray): Image to be padded.\n        divisor (int): Padded image edges will be multiple to divisor.\n        pad_val (number or sequence): Same as :func:`impad`.\n\n    Returns:\n        ndarray: The padded image.\n    \"\"\"\n    pad_h = int(np.ceil(img.shape[0] / divisor)) * divisor\n    pad_w = int(np.ceil(img.shape[1] / divisor)) * divisor\n    return impad(img, (pad_h, pad_w), pad_val)", "code_tokens": "def impad_to_multiple ( img , divisor , pad_val = 0 ) : pad_h = int ( np . ceil ( img . shape [ 0 ] / divisor ) ) * divisor pad_w = int ( np . ceil ( img . shape [ 1 ] / divisor ) ) * divisor return impad ( img , ( pad_h , pad_w ) , pad_val )", "docstring_tokens": "Pad an image to ensure each edge to be multiple to some number .", "label": 0}, {"idx": "cosqa-train-9430", "doc": "how to generate 25 random strings in python", "code": "def uniqueID(size=6, chars=string.ascii_uppercase + string.digits):\n    \"\"\"A quick and dirty way to get a unique string\"\"\"\n    return ''.join(random.choice(chars) for x in xrange(size))", "code_tokens": "def uniqueID ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return '' . join ( random . choice ( chars ) for x in xrange ( size ) )", "docstring_tokens": "A quick and dirty way to get a unique string", "label": 0}, {"idx": "cosqa-train-9431", "doc": "python panda entropy function", "code": "def entropy(string):\n    \"\"\"Compute entropy on the string\"\"\"\n    p, lns = Counter(string), float(len(string))\n    return -sum(count/lns * math.log(count/lns, 2) for count in p.values())", "code_tokens": "def entropy ( string ) : p , lns = Counter ( string ) , float ( len ( string ) ) return - sum ( count / lns * math . log ( count / lns , 2 ) for count in p . values ( ) )", "docstring_tokens": "Compute entropy on the string", "label": 1}, {"idx": "cosqa-train-9432", "doc": "how to generate nonce in python", "code": "def generate_nonce():\n        \"\"\" Generate nonce number \"\"\"\n        nonce = ''.join([str(randint(0, 9)) for i in range(8)])\n        return HMAC(\n            nonce.encode(),\n            \"secret\".encode(),\n            sha1\n        ).hexdigest()", "code_tokens": "def generate_nonce ( ) : nonce = '' . join ( [ str ( randint ( 0 , 9 ) ) for i in range ( 8 ) ] ) return HMAC ( nonce . encode ( ) , \"secret\" . encode ( ) , sha1 ) . hexdigest ( )", "docstring_tokens": "Generate nonce number", "label": 1}, {"idx": "cosqa-train-9433", "doc": "python parse a log file that is logging", "code": "def parse(self):\n        \"\"\"\n        Parse file specified by constructor.\n        \"\"\"\n        f = open(self.parse_log_path, \"r\")\n        self.parse2(f)\n        f.close()", "code_tokens": "def parse ( self ) : f = open ( self . parse_log_path , \"r\" ) self . parse2 ( f ) f . close ( )", "docstring_tokens": "Parse file specified by constructor .", "label": 1}, {"idx": "cosqa-train-9434", "doc": "how to get a specific key from a dictionary in python", "code": "def get_key_by_value(dictionary, search_value):\n    \"\"\"\n    searchs a value in a dicionary and returns the key of the first occurrence\n\n    :param dictionary: dictionary to search in\n    :param search_value: value to search for\n    \"\"\"\n    for key, value in dictionary.iteritems():\n        if value == search_value:\n            return ugettext(key)", "code_tokens": "def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )", "docstring_tokens": "searchs a value in a dicionary and returns the key of the first occurrence", "label": 1}, {"idx": "cosqa-train-9435", "doc": "python parse date strptime day of month no padd", "code": "def parse(self, s):\n        \"\"\"\n        Parses a date string formatted like ``YYYY-MM-DD``.\n        \"\"\"\n        return datetime.datetime.strptime(s, self.date_format).date()", "code_tokens": "def parse ( self , s ) : return datetime . datetime . strptime ( s , self . date_format ) . date ( )", "docstring_tokens": "Parses a date string formatted like YYYY - MM - DD .", "label": 1}, {"idx": "cosqa-train-9436", "doc": "how to get all the dates from a date range python", "code": "def daterange(start_date, end_date):\n    \"\"\"\n    Yield one date per day from starting date to ending date.\n\n    Args:\n        start_date (date): starting date.\n        end_date (date): ending date.\n\n    Yields:\n        date: a date for each day within the range.\n    \"\"\"\n    for n in range(int((end_date - start_date).days)):\n        yield start_date + timedelta(n)", "code_tokens": "def daterange ( start_date , end_date ) : for n in range ( int ( ( end_date - start_date ) . days ) ) : yield start_date + timedelta ( n )", "docstring_tokens": "Yield one date per day from starting date to ending date .", "label": 0}, {"idx": "cosqa-train-9437", "doc": "python parse datetime string to datetime", "code": "def parse_datetime(dt_str):\n    \"\"\"Parse datetime.\"\"\"\n    date_format = \"%Y-%m-%dT%H:%M:%S %z\"\n    dt_str = dt_str.replace(\"Z\", \" +0000\")\n    return datetime.datetime.strptime(dt_str, date_format)", "code_tokens": "def parse_datetime ( dt_str ) : date_format = \"%Y-%m-%dT%H:%M:%S %z\" dt_str = dt_str . replace ( \"Z\" , \" +0000\" ) return datetime . datetime . strptime ( dt_str , date_format )", "docstring_tokens": "Parse datetime .", "label": 1}, {"idx": "cosqa-train-9438", "doc": "how to get all true booleans in python", "code": "def visit_BoolOp(self, node):\n        \"\"\" Return type may come from any boolop operand. \"\"\"\n        return sum((self.visit(value) for value in node.values), [])", "code_tokens": "def visit_BoolOp ( self , node ) : return sum ( ( self . visit ( value ) for value in node . values ) , [ ] )", "docstring_tokens": "Return type may come from any boolop operand .", "label": 1}, {"idx": "cosqa-train-9439", "doc": "python parse http response output", "code": "def _parse_response(self, response):\n        \"\"\"\n        Parse http raw respone into python\n        dictionary object.\n        \n        :param str response: http response\n        :returns: response dict\n        :rtype: dict\n        \"\"\"\n\n        response_dict = {}\n        for line in response.splitlines():\n            key, value = response.split(\"=\", 1)\n            response_dict[key] = value\n        return response_dict", "code_tokens": "def _parse_response ( self , response ) : response_dict = { } for line in response . splitlines ( ) : key , value = response . split ( \"=\" , 1 ) response_dict [ key ] = value return response_dict", "docstring_tokens": "Parse http raw respone into python dictionary object . : param str response : http response : returns : response dict : rtype : dict", "label": 0}, {"idx": "cosqa-train-9440", "doc": "how to get an instanceid in python", "code": "def generate_unique_host_id():\n    \"\"\"Generate a unique ID, that is somewhat guaranteed to be unique among all\n    instances running at the same time.\"\"\"\n    host = \".\".join(reversed(socket.gethostname().split(\".\")))\n    pid = os.getpid()\n    return \"%s.%d\" % (host, pid)", "code_tokens": "def generate_unique_host_id ( ) : host = \".\" . join ( reversed ( socket . gethostname ( ) . split ( \".\" ) ) ) pid = os . getpid ( ) return \"%s.%d\" % ( host , pid )", "docstring_tokens": "Generate a unique ID that is somewhat guaranteed to be unique among all instances running at the same time .", "label": 1}, {"idx": "cosqa-train-9441", "doc": "python parse iso format time with timezone offset", "code": "def parse_timestamp(timestamp):\n    \"\"\"Parse ISO8601 timestamps given by github API.\"\"\"\n    dt = dateutil.parser.parse(timestamp)\n    return dt.astimezone(dateutil.tz.tzutc())", "code_tokens": "def parse_timestamp ( timestamp ) : dt = dateutil . parser . parse ( timestamp ) return dt . astimezone ( dateutil . tz . tzutc ( ) )", "docstring_tokens": "Parse ISO8601 timestamps given by github API .", "label": 1}, {"idx": "cosqa-train-9442", "doc": "how to get environment variables and its name in python", "code": "def _get_os_environ_dict(keys):\n  \"\"\"Return a dictionary of key/values from os.environ.\"\"\"\n  return {k: os.environ.get(k, _UNDEFINED) for k in keys}", "code_tokens": "def _get_os_environ_dict ( keys ) : return { k : os . environ . get ( k , _UNDEFINED ) for k in keys }", "docstring_tokens": "Return a dictionary of key / values from os . environ .", "label": 1}, {"idx": "cosqa-train-9443", "doc": "python parse rfc3339 to datetime", "code": "def rfc3339_to_datetime(data):\n    \"\"\"convert a rfc3339 date representation into a Python datetime\"\"\"\n    try:\n        ts = time.strptime(data, '%Y-%m-%d')\n        return date(*ts[:3])\n    except ValueError:\n        pass\n\n    try:\n        dt, _, tz = data.partition('Z')\n        if tz:\n            tz = offset(tz)\n        else:\n            tz = offset('00:00')\n        if '.' in dt and dt.rsplit('.', 1)[-1].isdigit():\n            ts = time.strptime(dt, '%Y-%m-%dT%H:%M:%S.%f')\n        else:\n            ts = time.strptime(dt, '%Y-%m-%dT%H:%M:%S')\n        return datetime(*ts[:6], tzinfo=tz)\n    except ValueError:\n        raise ValueError('date-time {!r} is not a valid rfc3339 date representation'.format(data))", "code_tokens": "def rfc3339_to_datetime ( data ) : try : ts = time . strptime ( data , '%Y-%m-%d' ) return date ( * ts [ : 3 ] ) except ValueError : pass try : dt , _ , tz = data . partition ( 'Z' ) if tz : tz = offset ( tz ) else : tz = offset ( '00:00' ) if '.' in dt and dt . rsplit ( '.' , 1 ) [ - 1 ] . isdigit ( ) : ts = time . strptime ( dt , '%Y-%m-%dT%H:%M:%S.%f' ) else : ts = time . strptime ( dt , '%Y-%m-%dT%H:%M:%S' ) return datetime ( * ts [ : 6 ] , tzinfo = tz ) except ValueError : raise ValueError ( 'date-time {!r} is not a valid rfc3339 date representation' . format ( data ) )", "docstring_tokens": "convert a rfc3339 date representation into a Python datetime", "label": 0}, {"idx": "cosqa-train-9444", "doc": "how to get execution time for a function in python", "code": "def timedcall(executable_function, *args):\n    \"\"\"!\n    @brief Executes specified method or function with measuring of execution time.\n    \n    @param[in] executable_function (pointer): Pointer to function or method.\n    @param[in] args (*): Arguments of called function or method.\n    \n    @return (tuple) Execution time and result of execution of function or method (execution_time, result_execution).\n    \n    \"\"\"\n    \n    time_start = time.clock();\n    result = executable_function(*args);\n    time_end = time.clock();\n    \n    return (time_end - time_start, result);", "code_tokens": "def timedcall ( executable_function , * args ) : time_start = time . clock ( ) result = executable_function ( * args ) time_end = time . clock ( ) return ( time_end - time_start , result )", "docstring_tokens": "!", "label": 0}, {"idx": "cosqa-train-9445", "doc": "python parse yaml get", "code": "def _ParseYamlFromFile(filedesc):\n  \"\"\"Parses given YAML file.\"\"\"\n  content = filedesc.read()\n  return yaml.Parse(content) or collections.OrderedDict()", "code_tokens": "def _ParseYamlFromFile ( filedesc ) : content = filedesc . read ( ) return yaml . Parse ( content ) or collections . OrderedDict ( )", "docstring_tokens": "Parses given YAML file .", "label": 1}, {"idx": "cosqa-train-9446", "doc": "how to get firstname in language python", "code": "def get_first_lang():\n    \"\"\"Get the first lang of Accept-Language Header.\n    \"\"\"\n    request_lang = request.headers.get('Accept-Language').split(',')\n    if request_lang:\n        lang = locale.normalize(request_lang[0]).split('.')[0]\n    else:\n        lang = False\n    return lang", "code_tokens": "def get_first_lang ( ) : request_lang = request . headers . get ( 'Accept-Language' ) . split ( ',' ) if request_lang : lang = locale . normalize ( request_lang [ 0 ] ) . split ( '.' ) [ 0 ] else : lang = False return lang", "docstring_tokens": "Get the first lang of Accept - Language Header .", "label": 0}, {"idx": "cosqa-train-9447", "doc": "python pass string list to c++ ctypes", "code": "def from_pystr_to_cstr(data):\n    \"\"\"Convert a list of Python str to C pointer\n\n    Parameters\n    ----------\n    data : list\n        list of str\n    \"\"\"\n\n    if not isinstance(data, list):\n        raise NotImplementedError\n    pointers = (ctypes.c_char_p * len(data))()\n    if PY3:\n        data = [bytes(d, 'utf-8') for d in data]\n    else:\n        data = [d.encode('utf-8') if isinstance(d, unicode) else d  # pylint: disable=undefined-variable\n                for d in data]\n    pointers[:] = data\n    return pointers", "code_tokens": "def from_pystr_to_cstr ( data ) : if not isinstance ( data , list ) : raise NotImplementedError pointers = ( ctypes . c_char_p * len ( data ) ) ( ) if PY3 : data = [ bytes ( d , 'utf-8' ) for d in data ] else : data = [ d . encode ( 'utf-8' ) if isinstance ( d , unicode ) else d # pylint: disable=undefined-variable for d in data ] pointers [ : ] = data return pointers", "docstring_tokens": "Convert a list of Python str to C pointer", "label": 0}, {"idx": "cosqa-train-9448", "doc": "how to get key corresponding to a value in dictionary python", "code": "def get_key_by_value(dictionary, search_value):\n    \"\"\"\n    searchs a value in a dicionary and returns the key of the first occurrence\n\n    :param dictionary: dictionary to search in\n    :param search_value: value to search for\n    \"\"\"\n    for key, value in dictionary.iteritems():\n        if value == search_value:\n            return ugettext(key)", "code_tokens": "def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )", "docstring_tokens": "searchs a value in a dicionary and returns the key of the first occurrence", "label": 1}, {"idx": "cosqa-train-9449", "doc": "python paste clipboard text", "code": "def osx_clipboard_get():\n    \"\"\" Get the clipboard's text on OS X.\n    \"\"\"\n    p = subprocess.Popen(['pbpaste', '-Prefer', 'ascii'],\n        stdout=subprocess.PIPE)\n    text, stderr = p.communicate()\n    # Text comes in with old Mac \\r line endings. Change them to \\n.\n    text = text.replace('\\r', '\\n')\n    return text", "code_tokens": "def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \\r line endings. Change them to \\n. text = text . replace ( '\\r' , '\\n' ) return text", "docstring_tokens": "Get the clipboard s text on OS X .", "label": 0}, {"idx": "cosqa-train-9450", "doc": "how to get mouse pos in python", "code": "def get_mouse_location(self):\n        \"\"\"\n        Get the current mouse location (coordinates and screen number).\n\n        :return: a namedtuple with ``x``, ``y`` and ``screen_num`` fields\n        \"\"\"\n        x = ctypes.c_int(0)\n        y = ctypes.c_int(0)\n        screen_num = ctypes.c_int(0)\n        _libxdo.xdo_get_mouse_location(\n            self._xdo, ctypes.byref(x), ctypes.byref(y),\n            ctypes.byref(screen_num))\n        return mouse_location(x.value, y.value, screen_num.value)", "code_tokens": "def get_mouse_location ( self ) : x = ctypes . c_int ( 0 ) y = ctypes . c_int ( 0 ) screen_num = ctypes . c_int ( 0 ) _libxdo . xdo_get_mouse_location ( self . _xdo , ctypes . byref ( x ) , ctypes . byref ( y ) , ctypes . byref ( screen_num ) ) return mouse_location ( x . value , y . value , screen_num . value )", "docstring_tokens": "Get the current mouse location ( coordinates and screen number ) .", "label": 1}, {"idx": "cosqa-train-9451", "doc": "python pathlib get parent directory of file", "code": "def get_parent_dir(name):\n    \"\"\"Get the parent directory of a filename.\"\"\"\n    parent_dir = os.path.dirname(os.path.dirname(name))\n    if parent_dir:\n        return parent_dir\n    return os.path.abspath('.')", "code_tokens": "def get_parent_dir ( name ) : parent_dir = os . path . dirname ( os . path . dirname ( name ) ) if parent_dir : return parent_dir return os . path . abspath ( '.' )", "docstring_tokens": "Get the parent directory of a filename .", "label": 1}, {"idx": "cosqa-train-9452", "doc": "how to get mouse x and y individually in python", "code": "def get_mouse_location(self):\n        \"\"\"\n        Get the current mouse location (coordinates and screen number).\n\n        :return: a namedtuple with ``x``, ``y`` and ``screen_num`` fields\n        \"\"\"\n        x = ctypes.c_int(0)\n        y = ctypes.c_int(0)\n        screen_num = ctypes.c_int(0)\n        _libxdo.xdo_get_mouse_location(\n            self._xdo, ctypes.byref(x), ctypes.byref(y),\n            ctypes.byref(screen_num))\n        return mouse_location(x.value, y.value, screen_num.value)", "code_tokens": "def get_mouse_location ( self ) : x = ctypes . c_int ( 0 ) y = ctypes . c_int ( 0 ) screen_num = ctypes . c_int ( 0 ) _libxdo . xdo_get_mouse_location ( self . _xdo , ctypes . byref ( x ) , ctypes . byref ( y ) , ctypes . byref ( screen_num ) ) return mouse_location ( x . value , y . value , screen_num . value )", "docstring_tokens": "Get the current mouse location ( coordinates and screen number ) .", "label": 1}, {"idx": "cosqa-train-9453", "doc": "python pdb set trace stop", "code": "def set_trace():\n    \"\"\"Start a Pdb instance at the calling frame, with stdout routed to sys.__stdout__.\"\"\"\n    # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py\n    pdb.Pdb(stdout=sys.__stdout__).set_trace(sys._getframe().f_back)", "code_tokens": "def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )", "docstring_tokens": "Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ .", "label": 0}, {"idx": "cosqa-train-9454", "doc": "how to get normal of a vector python", "code": "def mag(z):\n    \"\"\"Get the magnitude of a vector.\"\"\"\n    if isinstance(z[0], np.ndarray):\n        return np.array(list(map(np.linalg.norm, z)))\n    else:\n        return np.linalg.norm(z)", "code_tokens": "def mag ( z ) : if isinstance ( z [ 0 ] , np . ndarray ) : return np . array ( list ( map ( np . linalg . norm , z ) ) ) else : return np . linalg . norm ( z )", "docstring_tokens": "Get the magnitude of a vector .", "label": 0}, {"idx": "cosqa-train-9455", "doc": "python pdf file size is 0", "code": "def dimensions(path):\n    \"\"\"Get width and height of a PDF\"\"\"\n    pdf = PdfFileReader(path)\n    size = pdf.getPage(0).mediaBox\n    return {'w': float(size[2]), 'h': float(size[3])}", "code_tokens": "def dimensions ( path ) : pdf = PdfFileReader ( path ) size = pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "docstring_tokens": "Get width and height of a PDF", "label": 0}, {"idx": "cosqa-train-9456", "doc": "how to get python dictionary key", "code": "def get_from_human_key(self, key):\n        \"\"\"Return the key (aka database value) of a human key (aka Python identifier).\"\"\"\n        if key in self._identifier_map:\n            return self._identifier_map[key]\n        raise KeyError(key)", "code_tokens": "def get_from_human_key ( self , key ) : if key in self . _identifier_map : return self . _identifier_map [ key ] raise KeyError ( key )", "docstring_tokens": "Return the key ( aka database value ) of a human key ( aka Python identifier ) .", "label": 0}, {"idx": "cosqa-train-9457", "doc": "python pdf object has no attribute 'pagebufferwidth'", "code": "def dimensions(path):\n    \"\"\"Get width and height of a PDF\"\"\"\n    pdf = PdfFileReader(path)\n    size = pdf.getPage(0).mediaBox\n    return {'w': float(size[2]), 'h': float(size[3])}", "code_tokens": "def dimensions ( path ) : pdf = PdfFileReader ( path ) size = pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "docstring_tokens": "Get width and height of a PDF", "label": 1}, {"idx": "cosqa-train-9458", "doc": "how to get python to round using intgers to the nearest decimal tenth", "code": "def round_to_float(number, precision):\n    \"\"\"Round a float to a precision\"\"\"\n    rounded = Decimal(str(floor((number + precision / 2) // precision))\n                      ) * Decimal(str(precision))\n    return float(rounded)", "code_tokens": "def round_to_float ( number , precision ) : rounded = Decimal ( str ( floor ( ( number + precision / 2 ) // precision ) ) ) * Decimal ( str ( precision ) ) return float ( rounded )", "docstring_tokens": "Round a float to a precision", "label": 1}, {"idx": "cosqa-train-9459", "doc": "python percentile of a list of values", "code": "def percentile(values, k):\n    \"\"\"Find the percentile of a list of values.\n\n    :param list values: The list of values to find the percentile of\n    :param int k: The percentile to find\n    :rtype: float or int\n\n    \"\"\"\n    if not values:\n        return None\n    values.sort()\n    index = (len(values) * (float(k) / 100)) - 1\n    return values[int(math.ceil(index))]", "code_tokens": "def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]", "docstring_tokens": "Find the percentile of a list of values .", "label": 1}, {"idx": "cosqa-train-9460", "doc": "how to get schema of json in python", "code": "def document(schema):\n    \"\"\"Print a documented teleport version of the schema.\"\"\"\n    teleport_schema = from_val(schema)\n    return json.dumps(teleport_schema, sort_keys=True, indent=2)", "code_tokens": "def document ( schema ) : teleport_schema = from_val ( schema ) return json . dumps ( teleport_schema , sort_keys = True , indent = 2 )", "docstring_tokens": "Print a documented teleport version of the schema .", "label": 1}, {"idx": "cosqa-train-9461", "doc": "python pick closest value from list", "code": "def get_closest_index(myList, myNumber):\n    \"\"\"\n    Assumes myList is sorted. Returns closest value to myNumber.\n    If two numbers are equally close, return the smallest number.\n\n    Parameters\n    ----------\n    myList : array\n        The list in which to find the closest value to myNumber\n    myNumber : float\n        The number to find the closest to in MyList\n\n    Returns\n    -------\n    closest_values_index : int\n        The index in the array of the number closest to myNumber in myList\n    \"\"\"\n    closest_values_index = _np.where(self.time == take_closest(myList, myNumber))[0][0]\n    return closest_values_index", "code_tokens": "def get_closest_index ( myList , myNumber ) : closest_values_index = _np . where ( self . time == take_closest ( myList , myNumber ) ) [ 0 ] [ 0 ] return closest_values_index", "docstring_tokens": "Assumes myList is sorted . Returns closest value to myNumber . If two numbers are equally close return the smallest number .", "label": 1}, {"idx": "cosqa-train-9462", "doc": "how to get screen resolution in python", "code": "def getScreenDims(self):\n        \"\"\"returns a tuple that contains (screen_width,screen_height)\n        \"\"\"\n        width = ale_lib.getScreenWidth(self.obj)\n        height = ale_lib.getScreenHeight(self.obj)\n        return (width,height)", "code_tokens": "def getScreenDims ( self ) : width = ale_lib . getScreenWidth ( self . obj ) height = ale_lib . getScreenHeight ( self . obj ) return ( width , height )", "docstring_tokens": "returns a tuple that contains ( screen_width screen_height )", "label": 1}, {"idx": "cosqa-train-9463", "doc": "python pika stop consume", "code": "def on_stop(self):\n        \"\"\"\n        stop publisher\n        \"\"\"\n        LOGGER.debug(\"zeromq.Publisher.on_stop\")\n        self.zmqsocket.close()\n        self.zmqcontext.destroy()", "code_tokens": "def on_stop ( self ) : LOGGER . debug ( \"zeromq.Publisher.on_stop\" ) self . zmqsocket . close ( ) self . zmqcontext . destroy ( )", "docstring_tokens": "stop publisher", "label": 0}, {"idx": "cosqa-train-9464", "doc": "how to get spaces in strings in python", "code": "def strip_spaces(x):\n    \"\"\"\n    Strips spaces\n    :param x:\n    :return:\n    \"\"\"\n    x = x.replace(b' ', b'')\n    x = x.replace(b'\\t', b'')\n    return x", "code_tokens": "def strip_spaces ( x ) : x = x . replace ( b' ' , b'' ) x = x . replace ( b'\\t' , b'' ) return x", "docstring_tokens": "Strips spaces : param x : : return :", "label": 0}, {"idx": "cosqa-train-9465", "doc": "python pil padding img", "code": "def __call__(self, img):\n        \"\"\"\n        Args:\n            img (PIL Image): Image to be padded.\n\n        Returns:\n            PIL Image: Padded image.\n        \"\"\"\n        return F.pad(img, self.padding, self.fill, self.padding_mode)", "code_tokens": "def __call__ ( self , img ) : return F . pad ( img , self . padding , self . fill , self . padding_mode )", "docstring_tokens": "Args : img ( PIL Image ) : Image to be padded .", "label": 1}, {"idx": "cosqa-train-9466", "doc": "how to get specific indexes of a string python", "code": "def get_substring_idxs(substr, string):\n    \"\"\"\n    Return a list of indexes of substr. If substr not found, list is\n    empty.\n\n    Arguments:\n        substr (str): Substring to match.\n        string (str): String to match in.\n\n    Returns:\n        list of int: Start indices of substr.\n    \"\"\"\n    return [match.start() for match in re.finditer(substr, string)]", "code_tokens": "def get_substring_idxs ( substr , string ) : return [ match . start ( ) for match in re . finditer ( substr , string ) ]", "docstring_tokens": "Return a list of indexes of substr . If substr not found list is empty .", "label": 0}, {"idx": "cosqa-train-9467", "doc": "python play music sped up", "code": "def pause(self):\n        \"\"\"Pause the music\"\"\"\n        mixer.music.pause()\n        self.pause_time = self.get_time()\n        self.paused = True", "code_tokens": "def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True", "docstring_tokens": "Pause the music", "label": 0}, {"idx": "cosqa-train-9468", "doc": "how to get specify shape python", "code": "def out_shape_from_array(arr):\n    \"\"\"Get the output shape from an array.\"\"\"\n    arr = np.asarray(arr)\n    if arr.ndim == 1:\n        return arr.shape\n    else:\n        return (arr.shape[1],)", "code_tokens": "def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "docstring_tokens": "Get the output shape from an array .", "label": 0}, {"idx": "cosqa-train-9469", "doc": "python plot named colormap", "code": "def add_matplotlib_cmap(cm, name=None):\n    \"\"\"Add a matplotlib colormap.\"\"\"\n    global cmaps\n    cmap = matplotlib_to_ginga_cmap(cm, name=name)\n    cmaps[cmap.name] = cmap", "code_tokens": "def add_matplotlib_cmap ( cm , name = None ) : global cmaps cmap = matplotlib_to_ginga_cmap ( cm , name = name ) cmaps [ cmap . name ] = cmap", "docstring_tokens": "Add a matplotlib colormap .", "label": 1}, {"idx": "cosqa-train-9470", "doc": "how to get the accuracy score in python", "code": "def accuracy(self):\n        \"\"\"Calculates accuracy\n\n        :return: Accuracy\n        \"\"\"\n        true_pos = self.matrix[0][0]\n        false_pos = self.matrix[1][0]\n        false_neg = self.matrix[0][1]\n        true_neg = self.matrix[1][1]\n\n        num = 1.0 * (true_pos + true_neg)\n        den = true_pos + true_neg + false_pos + false_neg\n\n        return divide(num, den)", "code_tokens": "def accuracy ( self ) : true_pos = self . matrix [ 0 ] [ 0 ] false_pos = self . matrix [ 1 ] [ 0 ] false_neg = self . matrix [ 0 ] [ 1 ] true_neg = self . matrix [ 1 ] [ 1 ] num = 1.0 * ( true_pos + true_neg ) den = true_pos + true_neg + false_pos + false_neg return divide ( num , den )", "docstring_tokens": "Calculates accuracy", "label": 1}, {"idx": "cosqa-train-9471", "doc": "python plotting 0 1 array with time", "code": "def stackplot(marray, seconds=None, start_time=None, ylabels=None):\n    \"\"\"\n    will plot a stack of traces one above the other assuming\n    marray.shape = numRows, numSamples\n    \"\"\"\n    tarray = np.transpose(marray)\n    stackplot_t(tarray, seconds=seconds, start_time=start_time, ylabels=ylabels)\n    plt.show()", "code_tokens": "def stackplot ( marray , seconds = None , start_time = None , ylabels = None ) : tarray = np . transpose ( marray ) stackplot_t ( tarray , seconds = seconds , start_time = start_time , ylabels = ylabels ) plt . show ( )", "docstring_tokens": "will plot a stack of traces one above the other assuming marray . shape = numRows numSamples", "label": 1}, {"idx": "cosqa-train-9472", "doc": "how to get the actual object using object id in python", "code": "def get_obj(ref):\n    \"\"\"Get object from string reference.\"\"\"\n    oid = int(ref)\n    return server.id2ref.get(oid) or server.id2obj[oid]", "code_tokens": "def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]", "docstring_tokens": "Get object from string reference .", "label": 1}, {"idx": "cosqa-train-9473", "doc": "python pool async map", "code": "def asyncStarCmap(asyncCallable, iterable):\n    \"\"\"itertools.starmap for deferred callables using cooperative multitasking\n    \"\"\"\n    results = []\n    yield coopStar(asyncCallable, results.append, iterable)\n    returnValue(results)", "code_tokens": "def asyncStarCmap ( asyncCallable , iterable ) : results = [ ] yield coopStar ( asyncCallable , results . append , iterable ) returnValue ( results )", "docstring_tokens": "itertools . starmap for deferred callables using cooperative multitasking", "label": 0}, {"idx": "cosqa-train-9474", "doc": "how to get the db size in python", "code": "def size_on_disk(self):\n        \"\"\"\n        :return: size of the entire schema in bytes\n        \"\"\"\n        return int(self.connection.query(\n            \"\"\"\n            SELECT SUM(data_length + index_length)\n            FROM information_schema.tables WHERE table_schema='{db}'\n            \"\"\".format(db=self.database)).fetchone()[0])", "code_tokens": "def size_on_disk ( self ) : return int ( self . connection . query ( \"\"\"\n            SELECT SUM(data_length + index_length)\n            FROM information_schema.tables WHERE table_schema='{db}'\n            \"\"\" . format ( db = self . database ) ) . fetchone ( ) [ 0 ] )", "docstring_tokens": ": return : size of the entire schema in bytes", "label": 1}, {"idx": "cosqa-train-9475", "doc": "python pool close doesn't work", "code": "def _ReturnConnection(self):\n\t\t\"\"\"\n\t\tReturns a connection back to the pool\n\t\t\n\t\t@author: Nick Verbeck\n\t\t@since: 9/7/2008\n\t\t\"\"\"\n\t\tif self.conn is not None:\n\t\t\tif self.connInfo.commitOnEnd is True or self.commitOnEnd is True:\n\t\t\t\tself.conn.Commit()\n\t\t\t\t\t\n\t\t\tPool().returnConnection(self.conn)\n\t\t\tself.conn = None", "code_tokens": "def _ReturnConnection ( self ) : if self . conn is not None : if self . connInfo . commitOnEnd is True or self . commitOnEnd is True : self . conn . Commit ( ) Pool ( ) . returnConnection ( self . conn ) self . conn = None", "docstring_tokens": "Returns a connection back to the pool", "label": 0}, {"idx": "cosqa-train-9476", "doc": "how to get the index of a value in python", "code": "def get_list_index(lst, index_or_name):\n    \"\"\"\n    Return the index of an element in the list.\n\n    Args:\n        lst (list): The list.\n        index_or_name (int or str): The value of the reference element, or directly its numeric index.\n\n    Returns:\n        (int) The index of the element in the list.\n    \"\"\"\n    if isinstance(index_or_name, six.integer_types):\n        return index_or_name\n\n    return lst.index(index_or_name)", "code_tokens": "def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )", "docstring_tokens": "Return the index of an element in the list .", "label": 0}, {"idx": "cosqa-train-9477", "doc": "python popen git tag", "code": "def git_tag(tag):\n    \"\"\"Tags the current version.\"\"\"\n    print('Tagging \"{}\"'.format(tag))\n    msg = '\"Released version {}\"'.format(tag)\n    Popen(['git', 'tag', '-s', '-m', msg, tag]).wait()", "code_tokens": "def git_tag ( tag ) : print ( 'Tagging \"{}\"' . format ( tag ) ) msg = '\"Released version {}\"' . format ( tag ) Popen ( [ 'git' , 'tag' , '-s' , '-m' , msg , tag ] ) . wait ( )", "docstring_tokens": "Tags the current version .", "label": 1}, {"idx": "cosqa-train-9478", "doc": "how to get the index of the current item in a for loop django python", "code": "def end_index(self):\n        \"\"\"\n        Returns the 1-based index of the last object on this page,\n        relative to total objects found (hits).\n        \"\"\"\n        return ((self.number - 1) * self.paginator.per_page +\n            len(self.object_list))", "code_tokens": "def end_index ( self ) : return ( ( self . number - 1 ) * self . paginator . per_page + len ( self . object_list ) )", "docstring_tokens": "Returns the 1 - based index of the last object on this page relative to total objects found ( hits ) .", "label": 0}, {"idx": "cosqa-train-9479", "doc": "python post call using requests", "code": "def make_post_request(self, url, auth, json_payload):\n        \"\"\"This function executes the request with the provided\n        json payload and return the json response\"\"\"\n        response = requests.post(url, auth=auth, json=json_payload)\n        return response.json()", "code_tokens": "def make_post_request ( self , url , auth , json_payload ) : response = requests . post ( url , auth = auth , json = json_payload ) return response . json ( )", "docstring_tokens": "This function executes the request with the provided json payload and return the json response", "label": 0}, {"idx": "cosqa-train-9480", "doc": "how to get the length of a word in python using len", "code": "def display_len(text):\n    \"\"\"\n    Get the display length of a string. This can differ from the character\n    length if the string contains wide characters.\n    \"\"\"\n    text = unicodedata.normalize('NFD', text)\n    return sum(char_width(char) for char in text)", "code_tokens": "def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )", "docstring_tokens": "Get the display length of a string . This can differ from the character length if the string contains wide characters .", "label": 0}, {"idx": "cosqa-train-9481", "doc": "how to get the value of a header in python requests", "code": "def get_from_headers(request, key):\n    \"\"\"Try to read a value named ``key`` from the headers.\n    \"\"\"\n    value = request.headers.get(key)\n    return to_native(value)", "code_tokens": "def get_from_headers ( request , key ) : value = request . headers . get ( key ) return to_native ( value )", "docstring_tokens": "Try to read a value named key from the headers .", "label": 1}, {"idx": "cosqa-train-9482", "doc": "python pprint orders dictionary", "code": "def pprint_for_ordereddict():\n    \"\"\"\n    Context manager that causes pprint() to print OrderedDict objects as nicely\n    as standard Python dictionary objects.\n    \"\"\"\n    od_saved = OrderedDict.__repr__\n    try:\n        OrderedDict.__repr__ = dict.__repr__\n        yield\n    finally:\n        OrderedDict.__repr__ = od_saved", "code_tokens": "def pprint_for_ordereddict ( ) : od_saved = OrderedDict . __repr__ try : OrderedDict . __repr__ = dict . __repr__ yield finally : OrderedDict . __repr__ = od_saved", "docstring_tokens": "Context manager that causes pprint () to print OrderedDict objects as nicely as standard Python dictionary objects .", "label": 1}, {"idx": "cosqa-train-9483", "doc": "how to get the white background on python'", "code": "def set_color(self, fg=None, bg=None, intensify=False, target=sys.stdout):\n        \"\"\"Set foreground- and background colors and intensity.\"\"\"\n        raise NotImplementedError", "code_tokens": "def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError", "docstring_tokens": "Set foreground - and background colors and intensity .", "label": 1}, {"idx": "cosqa-train-9484", "doc": "python pretty print file", "code": "def csvpretty(csvfile: csvfile=sys.stdin):\n    \"\"\" Pretty print a CSV file. \"\"\"\n    shellish.tabulate(csv.reader(csvfile))", "code_tokens": "def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )", "docstring_tokens": "Pretty print a CSV file .", "label": 1}, {"idx": "cosqa-train-9485", "doc": "how to get unique list from list of list in python", "code": "def uniquify_list(L):\n    \"\"\"Same order unique list using only a list compression.\"\"\"\n    return [e for i, e in enumerate(L) if L.index(e) == i]", "code_tokens": "def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]", "docstring_tokens": "Same order unique list using only a list compression .", "label": 1}, {"idx": "cosqa-train-9486", "doc": "python prettyprint object with str", "code": "def _get_pretty_string(obj):\n    \"\"\"Return a prettier version of obj\n\n    Parameters\n    ----------\n    obj : object\n        Object to pretty print\n\n    Returns\n    -------\n    s : str\n        Pretty print object repr\n    \"\"\"\n    sio = StringIO()\n    pprint.pprint(obj, stream=sio)\n    return sio.getvalue()", "code_tokens": "def _get_pretty_string ( obj ) : sio = StringIO ( ) pprint . pprint ( obj , stream = sio ) return sio . getvalue ( )", "docstring_tokens": "Return a prettier version of obj", "label": 1}, {"idx": "cosqa-train-9487", "doc": "how to get unique value in a list in python", "code": "def unique_element(ll):\n    \"\"\" returns unique elements from a list preserving the original order \"\"\"\n    seen = {}\n    result = []\n    for item in ll:\n        if item in seen:\n            continue\n        seen[item] = 1\n        result.append(item)\n    return result", "code_tokens": "def unique_element ( ll ) : seen = { } result = [ ] for item in ll : if item in seen : continue seen [ item ] = 1 result . append ( item ) return result", "docstring_tokens": "returns unique elements from a list preserving the original order", "label": 0}, {"idx": "cosqa-train-9488", "doc": "python prettyxml remove carrige returns", "code": "def pp_xml(body):\n    \"\"\"Pretty print format some XML so it's readable.\"\"\"\n    pretty = xml.dom.minidom.parseString(body)\n    return pretty.toprettyxml(indent=\"  \")", "code_tokens": "def pp_xml ( body ) : pretty = xml . dom . minidom . parseString ( body ) return pretty . toprettyxml ( indent = \"  \" )", "docstring_tokens": "Pretty print format some XML so it s readable .", "label": 1}, {"idx": "cosqa-train-9489", "doc": "how to get unit vector of two matrice using python", "code": "def get_mi_vec(slab):\n    \"\"\"\n    Convenience function which returns the unit vector aligned\n    with the miller index.\n    \"\"\"\n    mvec = np.cross(slab.lattice.matrix[0], slab.lattice.matrix[1])\n    return mvec / np.linalg.norm(mvec)", "code_tokens": "def get_mi_vec ( slab ) : mvec = np . cross ( slab . lattice . matrix [ 0 ] , slab . lattice . matrix [ 1 ] ) return mvec / np . linalg . norm ( mvec )", "docstring_tokens": "Convenience function which returns the unit vector aligned with the miller index .", "label": 0}, {"idx": "cosqa-train-9490", "doc": "python print all attributes of instance", "code": "def print_param_values(self_):\n        \"\"\"Print the values of all this object's Parameters.\"\"\"\n        self = self_.self\n        for name,val in self.param.get_param_values():\n            print('%s.%s = %s' % (self.name,name,val))", "code_tokens": "def print_param_values ( self_ ) : self = self_ . self for name , val in self . param . get_param_values ( ) : print ( '%s.%s = %s' % ( self . name , name , val ) )", "docstring_tokens": "Print the values of all this object s Parameters .", "label": 1}, {"idx": "cosqa-train-9491", "doc": "how to get weekdays date between a range python", "code": "def get_week_start_end_day():\n    \"\"\"\n    Get the week start date and end date\n    \"\"\"\n    t = date.today()\n    wd = t.weekday()\n    return (t - timedelta(wd), t + timedelta(6 - wd))", "code_tokens": "def get_week_start_end_day ( ) : t = date . today ( ) wd = t . weekday ( ) return ( t - timedelta ( wd ) , t + timedelta ( 6 - wd ) )", "docstring_tokens": "Get the week start date and end date", "label": 1}, {"idx": "cosqa-train-9492", "doc": "python print avoid linespace", "code": "def raw_print(*args, **kw):\n    \"\"\"Raw print to sys.__stdout__, otherwise identical interface to print().\"\"\"\n\n    print(*args, sep=kw.get('sep', ' '), end=kw.get('end', '\\n'),\n          file=sys.__stdout__)\n    sys.__stdout__.flush()", "code_tokens": "def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )", "docstring_tokens": "Raw print to sys . __stdout__ otherwise identical interface to print () .", "label": 1}, {"idx": "cosqa-train-9493", "doc": "how to get your screen dimensions in python", "code": "def get_screen_resolution(self):\n        \"\"\"Return the screen resolution of the primary screen.\"\"\"\n        widget = QDesktopWidget()\n        geometry = widget.availableGeometry(widget.primaryScreen())\n        return geometry.width(), geometry.height()", "code_tokens": "def get_screen_resolution ( self ) : widget = QDesktopWidget ( ) geometry = widget . availableGeometry ( widget . primaryScreen ( ) ) return geometry . width ( ) , geometry . height ( )", "docstring_tokens": "Return the screen resolution of the primary screen .", "label": 1}, {"idx": "cosqa-train-9494", "doc": "python print bold red text", "code": "def info(txt):\n    \"\"\"Print, emphasized 'neutral', the given 'txt' message\"\"\"\n\n    print(\"%s# %s%s%s\" % (PR_EMPH_CC, get_time_stamp(), txt, PR_NC))\n    sys.stdout.flush()", "code_tokens": "def info ( txt ) : print ( \"%s# %s%s%s\" % ( PR_EMPH_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "docstring_tokens": "Print emphasized neutral the given txt message", "label": 1}, {"idx": "cosqa-train-9495", "doc": "how to give text on python color", "code": "def stringc(text, color):\n    \"\"\"\n    Return a string with terminal colors.\n    \"\"\"\n    if has_colors:\n        text = str(text)\n\n        return \"\\033[\"+codeCodes[color]+\"m\"+text+\"\\033[0m\"\n    else:\n        return text", "code_tokens": "def stringc ( text , color ) : if has_colors : text = str ( text ) return \"\\033[\" + codeCodes [ color ] + \"m\" + text + \"\\033[0m\" else : return text", "docstring_tokens": "Return a string with terminal colors .", "label": 0}, {"idx": "cosqa-train-9496", "doc": "python print colored json", "code": "def _format_json(data, theme):\n    \"\"\"Pretty print a dict as a JSON, with colors if pygments is present.\"\"\"\n    output = json.dumps(data, indent=2, sort_keys=True)\n\n    if pygments and sys.stdout.isatty():\n        style = get_style_by_name(theme)\n        formatter = Terminal256Formatter(style=style)\n        return pygments.highlight(output, JsonLexer(), formatter)\n\n    return output", "code_tokens": "def _format_json ( data , theme ) : output = json . dumps ( data , indent = 2 , sort_keys = True ) if pygments and sys . stdout . isatty ( ) : style = get_style_by_name ( theme ) formatter = Terminal256Formatter ( style = style ) return pygments . highlight ( output , JsonLexer ( ) , formatter ) return output", "docstring_tokens": "Pretty print a dict as a JSON with colors if pygments is present .", "label": 0}, {"idx": "cosqa-train-9497", "doc": "how to go back up a line ouput python 3", "code": "def move_page_bottom(self):\n        \"\"\"\n        Move the cursor to the last item on the page.\n        \"\"\"\n        self.nav.page_index = self.content.range[1]\n        self.nav.cursor_index = 0\n        self.nav.inverted = True", "code_tokens": "def move_page_bottom ( self ) : self . nav . page_index = self . content . range [ 1 ] self . nav . cursor_index = 0 self . nav . inverted = True", "docstring_tokens": "Move the cursor to the last item on the page .", "label": 1}, {"idx": "cosqa-train-9498", "doc": "python print how long a method takes to run", "code": "def timeit(output):\n    \"\"\"\n    If output is string, then print the string and also time used\n    \"\"\"\n    b = time.time()\n    yield\n    print output, 'time used: %.3fs' % (time.time()-b)", "code_tokens": "def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )", "docstring_tokens": "If output is string then print the string and also time used", "label": 0}, {"idx": "cosqa-train-9499", "doc": "how to go through every element if a tree structure in python", "code": "def empty_tree(input_list):\n    \"\"\"Recursively iterate through values in nested lists.\"\"\"\n    for item in input_list:\n        if not isinstance(item, list) or not empty_tree(item):\n            return False\n    return True", "code_tokens": "def empty_tree ( input_list ) : for item in input_list : if not isinstance ( item , list ) or not empty_tree ( item ) : return False return True", "docstring_tokens": "Recursively iterate through values in nested lists .", "label": 1}, {"idx": "cosqa-train-9500", "doc": "python print results of query loop", "code": "def print_runs(query):\n    \"\"\" Print all rows in this result query. \"\"\"\n\n    if query is None:\n        return\n\n    for tup in query:\n        print((\"{0} @ {1} - {2} id: {3} group: {4}\".format(\n            tup.end, tup.experiment_name, tup.project_name,\n            tup.experiment_group, tup.run_group)))", "code_tokens": "def print_runs ( query ) : if query is None : return for tup in query : print ( ( \"{0} @ {1} - {2} id: {3} group: {4}\" . format ( tup . end , tup . experiment_name , tup . project_name , tup . experiment_group , tup . run_group ) ) )", "docstring_tokens": "Print all rows in this result query .", "label": 1}, {"idx": "cosqa-train-9501", "doc": "how to gracefully handle timeout http python", "code": "def wait_for_url(url, timeout=DEFAULT_TIMEOUT):\n    \"\"\"\n    Return True if connection to the host and port specified in url\n    is successful within the timeout.\n\n    @param url: str: connection url for a TCP service\n    @param timeout: int: length of time in seconds to try to connect before giving up\n    @raise RuntimeError: if no port is given or can't be guessed via the scheme\n    @return: bool\n    \"\"\"\n    service = ServiceURL(url, timeout)\n    return service.wait()", "code_tokens": "def wait_for_url ( url , timeout = DEFAULT_TIMEOUT ) : service = ServiceURL ( url , timeout ) return service . wait ( )", "docstring_tokens": "Return True if connection to the host and port specified in url is successful within the timeout .", "label": 0}, {"idx": "cosqa-train-9502", "doc": "python print right allign float", "code": "def print_float(self, value, decimal_digits=2, justify_right=True):\n        \"\"\"Print a numeric value to the display.  If value is negative\n        it will be printed with a leading minus sign.  Decimal digits is the\n        desired number of digits after the decimal point.\n        \"\"\"\n        format_string = '{{0:0.{0}F}}'.format(decimal_digits)\n        self.print_number_str(format_string.format(value), justify_right)", "code_tokens": "def print_float ( self , value , decimal_digits = 2 , justify_right = True ) : format_string = '{{0:0.{0}F}}' . format ( decimal_digits ) self . print_number_str ( format_string . format ( value ) , justify_right )", "docstring_tokens": "Print a numeric value to the display . If value is negative it will be printed with a leading minus sign . Decimal digits is the desired number of digits after the decimal point .", "label": 1}, {"idx": "cosqa-train-9503", "doc": "how to hash a dictionary python", "code": "def dict_hash(dct):\n    \"\"\"Return a hash of the contents of a dictionary\"\"\"\n    dct_s = json.dumps(dct, sort_keys=True)\n\n    try:\n        m = md5(dct_s)\n    except TypeError:\n        m = md5(dct_s.encode())\n\n    return m.hexdigest()", "code_tokens": "def dict_hash ( dct ) : dct_s = json . dumps ( dct , sort_keys = True ) try : m = md5 ( dct_s ) except TypeError : m = md5 ( dct_s . encode ( ) ) return m . hexdigest ( )", "docstring_tokens": "Return a hash of the contents of a dictionary", "label": 0}, {"idx": "cosqa-train-9504", "doc": "python print stream docker log", "code": "def _stream_docker_logs(self):\n        \"\"\"Stream stdout and stderr from the task container to this\n        process's stdout and stderr, respectively.\n        \"\"\"\n        thread = threading.Thread(target=self._stderr_stream_worker)\n        thread.start()\n        for line in self.docker_client.logs(self.container, stdout=True,\n                                            stderr=False, stream=True):\n            sys.stdout.write(line)\n        thread.join()", "code_tokens": "def _stream_docker_logs ( self ) : thread = threading . Thread ( target = self . _stderr_stream_worker ) thread . start ( ) for line in self . docker_client . logs ( self . container , stdout = True , stderr = False , stream = True ) : sys . stdout . write ( line ) thread . join ( )", "docstring_tokens": "Stream stdout and stderr from the task container to this process s stdout and stderr respectively .", "label": 1}, {"idx": "cosqa-train-9505", "doc": "how to have the program run after 3 seconds in python", "code": "def test3():\n    \"\"\"Test the multiprocess\n    \"\"\"\n    import time\n    \n    p = MVisionProcess()\n    p.start()\n    time.sleep(5)\n    p.stop()", "code_tokens": "def test3 ( ) : import time p = MVisionProcess ( ) p . start ( ) time . sleep ( 5 ) p . stop ( )", "docstring_tokens": "Test the multiprocess", "label": 1}, {"idx": "cosqa-train-9506", "doc": "python print tuple elements in one line", "code": "def _tuple_repr(data):\n    \"\"\"Return a repr() for a list/tuple\"\"\"\n    if len(data) == 1:\n        return \"(%s,)\" % rpr(data[0])\n    else:\n        return \"(%s)\" % \", \".join([rpr(x) for x in data])", "code_tokens": "def _tuple_repr ( data ) : if len ( data ) == 1 : return \"(%s,)\" % rpr ( data [ 0 ] ) else : return \"(%s)\" % \", \" . join ( [ rpr ( x ) for x in data ] )", "docstring_tokens": "Return a repr () for a list / tuple", "label": 1}, {"idx": "cosqa-train-9507", "doc": "how to hide shell in python", "code": "def disown(cmd):\n    \"\"\"Call a system command in the background,\n       disown it and hide it's output.\"\"\"\n    subprocess.Popen(cmd,\n                     stdout=subprocess.DEVNULL,\n                     stderr=subprocess.DEVNULL)", "code_tokens": "def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "docstring_tokens": "Call a system command in the background disown it and hide it s output .", "label": 1}, {"idx": "cosqa-train-9508", "doc": "python printing without spaces", "code": "def pprint(o, stream=None, indent=1, width=80, depth=None):\n    \"\"\"Pretty-print a Python o to a stream [default is sys.stdout].\"\"\"\n    printer = PrettyPrinter(\n        stream=stream, indent=indent, width=width, depth=depth)\n    printer.pprint(o)", "code_tokens": "def pprint ( o , stream = None , indent = 1 , width = 80 , depth = None ) : printer = PrettyPrinter ( stream = stream , indent = indent , width = width , depth = depth ) printer . pprint ( o )", "docstring_tokens": "Pretty - print a Python o to a stream [ default is sys . stdout ] .", "label": 0}, {"idx": "cosqa-train-9509", "doc": "how to highlight in python", "code": "def get_highlighted_code(name, code, type='terminal'):\n    \"\"\"\n    If pygments are available on the system\n    then returned output is colored. Otherwise\n    unchanged content is returned.\n    \"\"\"\n    import logging\n    try:\n        import pygments\n        pygments\n    except ImportError:\n        return code\n    from pygments import highlight\n    from pygments.lexers import guess_lexer_for_filename, ClassNotFound\n    from pygments.formatters import TerminalFormatter\n\n    try:\n        lexer = guess_lexer_for_filename(name, code)\n        formatter = TerminalFormatter()\n        content = highlight(code, lexer, formatter)\n    except ClassNotFound:\n        logging.debug(\"Couldn't guess Lexer, will not use pygments.\")\n        content = code\n    return content", "code_tokens": "def get_highlighted_code ( name , code , type = 'terminal' ) : import logging try : import pygments pygments except ImportError : return code from pygments import highlight from pygments . lexers import guess_lexer_for_filename , ClassNotFound from pygments . formatters import TerminalFormatter try : lexer = guess_lexer_for_filename ( name , code ) formatter = TerminalFormatter ( ) content = highlight ( code , lexer , formatter ) except ClassNotFound : logging . debug ( \"Couldn't guess Lexer, will not use pygments.\" ) content = code return content", "docstring_tokens": "If pygments are available on the system then returned output is colored . Otherwise unchanged content is returned .", "label": 0}, {"idx": "cosqa-train-9510", "doc": "python private variable uppercase", "code": "def to_camel_case(snake_case_string):\n    \"\"\"\n    Convert a string from snake case to camel case. For example, \"some_var\" would become \"someVar\".\n\n    :param snake_case_string: Snake-cased string to convert to camel case.\n    :returns: Camel-cased version of snake_case_string.\n    \"\"\"\n    parts = snake_case_string.lstrip('_').split('_')\n    return parts[0] + ''.join([i.title() for i in parts[1:]])", "code_tokens": "def to_camel_case ( snake_case_string ) : parts = snake_case_string . lstrip ( '_' ) . split ( '_' ) return parts [ 0 ] + '' . join ( [ i . title ( ) for i in parts [ 1 : ] ] )", "docstring_tokens": "Convert a string from snake case to camel case . For example some_var would become someVar .", "label": 0}, {"idx": "cosqa-train-9511", "doc": "how to identify a number in a tuple in python", "code": "def version_triple(tag):\n    \"\"\"\n    returns: a triple of integers from a version tag\n    \"\"\"\n    groups = re.match(r'v?(\\d+)\\.(\\d+)\\.(\\d+)', tag).groups()\n    return tuple(int(n) for n in groups)", "code_tokens": "def version_triple ( tag ) : groups = re . match ( r'v?(\\d+)\\.(\\d+)\\.(\\d+)' , tag ) . groups ( ) return tuple ( int ( n ) for n in groups )", "docstring_tokens": "returns : a triple of integers from a version tag", "label": 1}, {"idx": "cosqa-train-9512", "doc": "python process exited before it can make", "code": "def kill_mprocess(process):\n    \"\"\"kill process\n    Args:\n        process - Popen object for process\n    \"\"\"\n    if process and proc_alive(process):\n        process.terminate()\n        process.communicate()\n    return not proc_alive(process)", "code_tokens": "def kill_mprocess ( process ) : if process and proc_alive ( process ) : process . terminate ( ) process . communicate ( ) return not proc_alive ( process )", "docstring_tokens": "kill process Args : process - Popen object for process", "label": 0}, {"idx": "cosqa-train-9513", "doc": "how to identify encoding of a file in python", "code": "def detect(filename, include_confidence=False):\n    \"\"\"\n    Detect the encoding of a file.\n\n    Returns only the predicted current encoding as a string.\n\n    If `include_confidence` is True, \n    Returns tuple containing: (str encoding, float confidence)\n    \"\"\"\n    f = open(filename)\n    detection = chardet.detect(f.read())\n    f.close()\n    encoding = detection.get('encoding')\n    confidence = detection.get('confidence')\n    if include_confidence:\n        return (encoding, confidence)\n    return encoding", "code_tokens": "def detect ( filename , include_confidence = False ) : f = open ( filename ) detection = chardet . detect ( f . read ( ) ) f . close ( ) encoding = detection . get ( 'encoding' ) confidence = detection . get ( 'confidence' ) if include_confidence : return ( encoding , confidence ) return encoding", "docstring_tokens": "Detect the encoding of a file .", "label": 0}, {"idx": "cosqa-train-9514", "doc": "python program cartesian coordinates", "code": "def get_lons_from_cartesian(x__, y__):\n    \"\"\"Get longitudes from cartesian coordinates.\n    \"\"\"\n    return rad2deg(arccos(x__ / sqrt(x__ ** 2 + y__ ** 2))) * sign(y__)", "code_tokens": "def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )", "docstring_tokens": "Get longitudes from cartesian coordinates .", "label": 1}, {"idx": "cosqa-train-9515", "doc": "how to identify the index of an element of a set in python", "code": "def find_geom(geom, geoms):\n    \"\"\"\n    Returns the index of a geometry in a list of geometries avoiding\n    expensive equality checks of `in` operator.\n    \"\"\"\n    for i, g in enumerate(geoms):\n        if g is geom:\n            return i", "code_tokens": "def find_geom ( geom , geoms ) : for i , g in enumerate ( geoms ) : if g is geom : return i", "docstring_tokens": "Returns the index of a geometry in a list of geometries avoiding expensive equality checks of in operator .", "label": 1}, {"idx": "cosqa-train-9516", "doc": "python program for price and percentage", "code": "def average_price(quantity_1, price_1, quantity_2, price_2):\n    \"\"\"Calculates the average price between two asset states.\"\"\"\n    return (quantity_1 * price_1 + quantity_2 * price_2) / \\\n            (quantity_1 + quantity_2)", "code_tokens": "def average_price ( quantity_1 , price_1 , quantity_2 , price_2 ) : return ( quantity_1 * price_1 + quantity_2 * price_2 ) / ( quantity_1 + quantity_2 )", "docstring_tokens": "Calculates the average price between two asset states .", "label": 1}, {"idx": "cosqa-train-9517", "doc": "how to ietrate in a byte type object in python", "code": "def _from_bytes(bytes, byteorder=\"big\", signed=False):\n    \"\"\"This is the same functionality as ``int.from_bytes`` in python 3\"\"\"\n    return int.from_bytes(bytes, byteorder=byteorder, signed=signed)", "code_tokens": "def _from_bytes ( bytes , byteorder = \"big\" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )", "docstring_tokens": "This is the same functionality as int . from_bytes in python 3", "label": 0}, {"idx": "cosqa-train-9518", "doc": "python progress bar for a line", "code": "def tick(self):\n        \"\"\"Add one tick to progress bar\"\"\"\n        self.current += 1\n        if self.current == self.factor:\n            sys.stdout.write('+')\n            sys.stdout.flush()\n            self.current = 0", "code_tokens": "def tick ( self ) : self . current += 1 if self . current == self . factor : sys . stdout . write ( '+' ) sys . stdout . flush ( ) self . current = 0", "docstring_tokens": "Add one tick to progress bar", "label": 0}, {"idx": "cosqa-train-9519", "doc": "how to implement a macro in python", "code": "def define_macro(self, name, themacro):\n        \"\"\"Define a new macro\n\n        Parameters\n        ----------\n        name : str\n            The name of the macro.\n        themacro : str or Macro\n            The action to do upon invoking the macro.  If a string, a new\n            Macro object is created by passing the string to it.\n        \"\"\"\n\n        from IPython.core import macro\n\n        if isinstance(themacro, basestring):\n            themacro = macro.Macro(themacro)\n        if not isinstance(themacro, macro.Macro):\n            raise ValueError('A macro must be a string or a Macro instance.')\n        self.user_ns[name] = themacro", "code_tokens": "def define_macro ( self , name , themacro ) : from IPython . core import macro if isinstance ( themacro , basestring ) : themacro = macro . Macro ( themacro ) if not isinstance ( themacro , macro . Macro ) : raise ValueError ( 'A macro must be a string or a Macro instance.' ) self . user_ns [ name ] = themacro", "docstring_tokens": "Define a new macro", "label": 1}, {"idx": "cosqa-train-9520", "doc": "python property by string name", "code": "def get_propety_by_name(pif, name):\n    \"\"\"Get a property by name\"\"\"\n    warn(\"This method has been deprecated in favor of get_property_by_name\")\n    return next((x for x in pif.properties if x.name == name), None)", "code_tokens": "def get_propety_by_name ( pif , name ) : warn ( \"This method has been deprecated in favor of get_property_by_name\" ) return next ( ( x for x in pif . properties if x . name == name ) , None )", "docstring_tokens": "Get a property by name", "label": 1}, {"idx": "cosqa-train-9521", "doc": "how to incorporate string input in function python", "code": "def get_input(input_func, input_str):\n    \"\"\"\n    Get input from the user given an input function and an input string\n    \"\"\"\n    val = input_func(\"Please enter your {0}: \".format(input_str))\n    while not val or not len(val.strip()):\n        val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))\n    return val", "code_tokens": "def get_input ( input_func , input_str ) : val = input_func ( \"Please enter your {0}: \" . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( \"You didn't enter a valid {0}, please try again: \" . format ( input_str ) ) return val", "docstring_tokens": "Get input from the user given an input function and an input string", "label": 0}, {"idx": "cosqa-train-9522", "doc": "python property instead of plain method", "code": "def _set_property(self, val, *args):\n        \"\"\"Private method that sets the value currently of the property\"\"\"\n        val = UserClassAdapter._set_property(self, val, *args)\n        if val:\n            Adapter._set_property(self, val, *args)\n        return val", "code_tokens": "def _set_property ( self , val , * args ) : val = UserClassAdapter . _set_property ( self , val , * args ) if val : Adapter . _set_property ( self , val , * args ) return val", "docstring_tokens": "Private method that sets the value currently of the property", "label": 1}, {"idx": "cosqa-train-9523", "doc": "how to increase the pixel size in python opencv", "code": "def screen_cv2(self):\n        \"\"\"cv2 Image of current window screen\"\"\"\n        pil_image = self.screen.convert('RGB')\n        cv2_image = np.array(pil_image)\n        pil_image.close()\n        # Convert RGB to BGR \n        cv2_image = cv2_image[:, :, ::-1]\n        return cv2_image", "code_tokens": "def screen_cv2 ( self ) : pil_image = self . screen . convert ( 'RGB' ) cv2_image = np . array ( pil_image ) pil_image . close ( ) # Convert RGB to BGR \n cv2_image = cv2_image [ : , : , : : - 1 ] return cv2_image", "docstring_tokens": "cv2 Image of current window screen", "label": 1}, {"idx": "cosqa-train-9524", "doc": "python property to ensure function is also loaded once the first time it is called", "code": "def lazy_property(function):\n    \"\"\"Cache the first return value of a function for all subsequent calls.\n\n    This decorator is usefull for argument-less functions that behave more\n    like a global or static property that should be calculated once, but\n    lazily (i.e. only if requested).\n    \"\"\"\n    cached_val = []\n    def _wrapper(*args):\n        try:\n            return cached_val[0]\n        except IndexError:\n            ret_val = function(*args)\n            cached_val.append(ret_val)\n            return ret_val\n    return _wrapper", "code_tokens": "def lazy_property ( function ) : cached_val = [ ] def _wrapper ( * args ) : try : return cached_val [ 0 ] except IndexError : ret_val = function ( * args ) cached_val . append ( ret_val ) return ret_val return _wrapper", "docstring_tokens": "Cache the first return value of a function for all subsequent calls .", "label": 1}, {"idx": "cosqa-train-9525", "doc": "how to increase the value of a key in python", "code": "def incr(self, key, incr_by=1):\n        \"\"\"Increment the key by the given amount.\"\"\"\n        return self.database.hincrby(self.key, key, incr_by)", "code_tokens": "def incr ( self , key , incr_by = 1 ) : return self . database . hincrby ( self . key , key , incr_by )", "docstring_tokens": "Increment the key by the given amount .", "label": 1}, {"idx": "cosqa-train-9526", "doc": "python protobuffer read proto file", "code": "def read_proto_object(fobj, klass):\n    \"\"\"Read a block of data and parse using the given protobuf object.\"\"\"\n    log.debug('%s chunk', klass.__name__)\n    obj = klass()\n    obj.ParseFromString(read_block(fobj))\n    log.debug('Header: %s', str(obj))\n    return obj", "code_tokens": "def read_proto_object ( fobj , klass ) : log . debug ( '%s chunk' , klass . __name__ ) obj = klass ( ) obj . ParseFromString ( read_block ( fobj ) ) log . debug ( 'Header: %s' , str ( obj ) ) return obj", "docstring_tokens": "Read a block of data and parse using the given protobuf object .", "label": 1}, {"idx": "cosqa-train-9527", "doc": "how to indicate file is in same directory python load pickle", "code": "def load(filename):\n    \"\"\"\n    Load the state from the given file, moving to the file's directory during\n    load (temporarily, moving back after loaded)\n\n    Parameters\n    ----------\n    filename : string\n        name of the file to open, should be a .pkl file\n    \"\"\"\n    path, name = os.path.split(filename)\n    path = path or '.'\n\n    with util.indir(path):\n        return pickle.load(open(name, 'rb'))", "code_tokens": "def load ( filename ) : path , name = os . path . split ( filename ) path = path or '.' with util . indir ( path ) : return pickle . load ( open ( name , 'rb' ) )", "docstring_tokens": "Load the state from the given file moving to the file s directory during load ( temporarily moving back after loaded )", "label": 1}, {"idx": "cosqa-train-9528", "doc": "python proxy http tunnel", "code": "def _prepare_proxy(self, conn):\n        \"\"\"\n        Establish tunnel connection early, because otherwise httplib\n        would improperly set Host: header to proxy's IP:port.\n        \"\"\"\n        conn.set_tunnel(self._proxy_host, self.port, self.proxy_headers)\n        conn.connect()", "code_tokens": "def _prepare_proxy ( self , conn ) : conn . set_tunnel ( self . _proxy_host , self . port , self . proxy_headers ) conn . connect ( )", "docstring_tokens": "Establish tunnel connection early because otherwise httplib would improperly set Host : header to proxy s IP : port .", "label": 1}, {"idx": "cosqa-train-9529", "doc": "how to indicate the highest count in python", "code": "def best(self):\n        \"\"\"\n        Returns the element with the highest probability.\n        \"\"\"\n        b = (-1e999999, None)\n        for k, c in iteritems(self.counts):\n            b = max(b, (c, k))\n        return b[1]", "code_tokens": "def best ( self ) : b = ( - 1e999999 , None ) for k , c in iteritems ( self . counts ) : b = max ( b , ( c , k ) ) return b [ 1 ]", "docstring_tokens": "Returns the element with the highest probability .", "label": 0}, {"idx": "cosqa-train-9530", "doc": "python put functions in iterable", "code": "def map(cls, iterable, func, *a, **kw):\n    \"\"\"\n    Iterable-first replacement of Python's built-in `map()` function.\n    \"\"\"\n\n    return cls(func(x, *a, **kw) for x in iterable)", "code_tokens": "def map ( cls , iterable , func , * a , * * kw ) : return cls ( func ( x , * a , * * kw ) for x in iterable )", "docstring_tokens": "Iterable - first replacement of Python s built - in map () function .", "label": 1}, {"idx": "cosqa-train-9531", "doc": "how to insert indent symbol python", "code": "def indent(self, message):\n        \"\"\"\n        Sets the indent for standardized output\n        :param message: (str)\n        :return: (str)\n        \"\"\"\n        indent = self.indent_char * self.indent_size\n        return indent + message", "code_tokens": "def indent ( self , message ) : indent = self . indent_char * self . indent_size return indent + message", "docstring_tokens": "Sets the indent for standardized output : param message : ( str ) : return : ( str )", "label": 1}, {"idx": "cosqa-train-9532", "doc": "python pymongo insert without duplicatte", "code": "def insert_one(self, mongo_collection, doc, mongo_db=None, **kwargs):\n        \"\"\"\n        Inserts a single document into a mongo collection\n        https://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.insert_one\n        \"\"\"\n        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)\n\n        return collection.insert_one(doc, **kwargs)", "code_tokens": "def insert_one ( self , mongo_collection , doc , mongo_db = None , * * kwargs ) : collection = self . get_collection ( mongo_collection , mongo_db = mongo_db ) return collection . insert_one ( doc , * * kwargs )", "docstring_tokens": "Inserts a single document into a mongo collection https : // api . mongodb . com / python / current / api / pymongo / collection . html#pymongo . collection . Collection . insert_one", "label": 1}, {"idx": "cosqa-train-9533", "doc": "how to instanticate a bytes like object python", "code": "def loadb(b):\n    \"\"\"Deserialize ``b`` (instance of ``bytes``) to a Python object.\"\"\"\n    assert isinstance(b, (bytes, bytearray))\n    return std_json.loads(b.decode('utf-8'))", "code_tokens": "def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )", "docstring_tokens": "Deserialize b ( instance of bytes ) to a Python object .", "label": 0}, {"idx": "cosqa-train-9534", "doc": "python pytest assert called once", "code": "def assert_called_once(_mock_self):\n        \"\"\"assert that the mock was called only once.\n        \"\"\"\n        self = _mock_self\n        if not self.call_count == 1:\n            msg = (\"Expected '%s' to have been called once. Called %s times.\" %\n                   (self._mock_name or 'mock', self.call_count))\n            raise AssertionError(msg)", "code_tokens": "def assert_called_once ( _mock_self ) : self = _mock_self if not self . call_count == 1 : msg = ( \"Expected '%s' to have been called once. Called %s times.\" % ( self . _mock_name or 'mock' , self . call_count ) ) raise AssertionError ( msg )", "docstring_tokens": "assert that the mock was called only once .", "label": 1}, {"idx": "cosqa-train-9535", "doc": "how to inverse the elements of alist in python", "code": "def unique_inverse(item_list):\n    \"\"\"\n    Like np.unique(item_list, return_inverse=True)\n    \"\"\"\n    import utool as ut\n    unique_items = ut.unique(item_list)\n    inverse = list_alignment(unique_items, item_list)\n    return unique_items, inverse", "code_tokens": "def unique_inverse ( item_list ) : import utool as ut unique_items = ut . unique ( item_list ) inverse = list_alignment ( unique_items , item_list ) return unique_items , inverse", "docstring_tokens": "Like np . unique ( item_list return_inverse = True )", "label": 1}, {"idx": "cosqa-train-9536", "doc": "python random char gener", "code": "def generate_random_string(chars=7):\n    \"\"\"\n\n    :param chars:\n    :return:\n    \"\"\"\n    return u\"\".join(random.sample(string.ascii_letters * 2 + string.digits, chars))", "code_tokens": "def generate_random_string ( chars = 7 ) : return u\"\" . join ( random . sample ( string . ascii_letters * 2 + string . digits , chars ) )", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-9537", "doc": "python random gaussian distribution noise", "code": "def rlognormal(mu, tau, size=None):\n    \"\"\"\n    Return random lognormal variates.\n    \"\"\"\n\n    return np.random.lognormal(mu, np.sqrt(1. / tau), size)", "code_tokens": "def rlognormal ( mu , tau , size = None ) : return np . random . lognormal ( mu , np . sqrt ( 1. / tau ) , size )", "docstring_tokens": "Return random lognormal variates .", "label": 1}, {"idx": "cosqa-train-9538", "doc": "how to kill a python script ctrl", "code": "def cli_command_quit(self, msg):\n        \"\"\"\\\n        kills the child and exits\n        \"\"\"\n        if self.state == State.RUNNING and self.sprocess and self.sprocess.proc:\n            self.sprocess.proc.kill()\n        else:\n            sys.exit(0)", "code_tokens": "def cli_command_quit ( self , msg ) : if self . state == State . RUNNING and self . sprocess and self . sprocess . proc : self . sprocess . proc . kill ( ) else : sys . exit ( 0 )", "docstring_tokens": "\\ kills the child and exits", "label": 1}, {"idx": "cosqa-train-9539", "doc": "python random int not including 0", "code": "def positive_integer(anon, obj, field, val):\n    \"\"\"\n    Returns a random positive integer (for a Django PositiveIntegerField)\n    \"\"\"\n    return anon.faker.positive_integer(field=field)", "code_tokens": "def positive_integer ( anon , obj , field , val ) : return anon . faker . positive_integer ( field = field )", "docstring_tokens": "Returns a random positive integer ( for a Django PositiveIntegerField )", "label": 1}, {"idx": "cosqa-train-9540", "doc": "how to kill the process in linux using python", "code": "def kill_process_children(pid):\n    \"\"\"Find and kill child processes of a process.\n\n    :param pid: PID of parent process (process ID)\n    :return: Nothing\n    \"\"\"\n    if sys.platform == \"darwin\":\n        kill_process_children_osx(pid)\n    elif sys.platform == \"linux\":\n        kill_process_children_unix(pid)\n    else:\n        pass", "code_tokens": "def kill_process_children ( pid ) : if sys . platform == \"darwin\" : kill_process_children_osx ( pid ) elif sys . platform == \"linux\" : kill_process_children_unix ( pid ) else : pass", "docstring_tokens": "Find and kill child processes of a process .", "label": 1}, {"idx": "cosqa-train-9541", "doc": "python random integer without replacement", "code": "def positive_integer(anon, obj, field, val):\n    \"\"\"\n    Returns a random positive integer (for a Django PositiveIntegerField)\n    \"\"\"\n    return anon.faker.positive_integer(field=field)", "code_tokens": "def positive_integer ( anon , obj , field , val ) : return anon . faker . positive_integer ( field = field )", "docstring_tokens": "Returns a random positive integer ( for a Django PositiveIntegerField )", "label": 0}, {"idx": "cosqa-train-9542", "doc": "how to know how large a python array is", "code": "def bytesize(arr):\n    \"\"\"\n    Returns the memory byte size of a Numpy array as an integer.\n    \"\"\"\n    byte_size = np.prod(arr.shape) * np.dtype(arr.dtype).itemsize\n    return byte_size", "code_tokens": "def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size", "docstring_tokens": "Returns the memory byte size of a Numpy array as an integer .", "label": 1}, {"idx": "cosqa-train-9543", "doc": "python range function stack overflow", "code": "def LinSpace(start, stop, num):\n    \"\"\"\n    Linspace op.\n    \"\"\"\n    return np.linspace(start, stop, num=num, dtype=np.float32),", "code_tokens": "def LinSpace ( start , stop , num ) : return np . linspace ( start , stop , num = num , dtype = np . float32 ) ,", "docstring_tokens": "Linspace op .", "label": 1}, {"idx": "cosqa-train-9544", "doc": "how to know the data type of a object in python", "code": "def is_integer(obj):\n    \"\"\"Is this an integer.\n\n    :param object obj:\n    :return:\n    \"\"\"\n    if PYTHON3:\n        return isinstance(obj, int)\n    return isinstance(obj, (int, long))", "code_tokens": "def is_integer ( obj ) : if PYTHON3 : return isinstance ( obj , int ) return isinstance ( obj , ( int , long ) )", "docstring_tokens": "Is this an integer .", "label": 1}, {"idx": "cosqa-train-9545", "doc": "python read all text from url", "code": "def url_read_text(url, verbose=True):\n    r\"\"\"\n    Directly reads text data from url\n    \"\"\"\n    data = url_read(url, verbose)\n    text = data.decode('utf8')\n    return text", "code_tokens": "def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text", "docstring_tokens": "r Directly reads text data from url", "label": 0}, {"idx": "cosqa-train-9546", "doc": "how to know the datatype of each column python", "code": "def _get_column_types(self, data):\n        \"\"\"Get a list of the data types for each column in *data*.\"\"\"\n        columns = list(zip_longest(*data))\n        return [self._get_column_type(column) for column in columns]", "code_tokens": "def _get_column_types ( self , data ) : columns = list ( zip_longest ( * data ) ) return [ self . _get_column_type ( column ) for column in columns ]", "docstring_tokens": "Get a list of the data types for each column in * data * .", "label": 0}, {"idx": "cosqa-train-9547", "doc": "python read binary file with integer and float", "code": "def _fast_read(self, infile):\n        \"\"\"Function for fast reading from sensor files.\"\"\"\n        infile.seek(0)\n        return(int(infile.read().decode().strip()))", "code_tokens": "def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )", "docstring_tokens": "Function for fast reading from sensor files .", "label": 1}, {"idx": "cosqa-train-9548", "doc": "how to know the type of python variable", "code": "def get_var_type(self, name):\n        \"\"\"\n        Return type string, compatible with numpy.\n        \"\"\"\n        name = create_string_buffer(name)\n        type_ = create_string_buffer(MAXSTRLEN)\n        self.library.get_var_type.argtypes = [c_char_p, c_char_p]\n        self.library.get_var_type(name, type_)\n        return type_.value", "code_tokens": "def get_var_type ( self , name ) : name = create_string_buffer ( name ) type_ = create_string_buffer ( MAXSTRLEN ) self . library . get_var_type . argtypes = [ c_char_p , c_char_p ] self . library . get_var_type ( name , type_ ) return type_ . value", "docstring_tokens": "Return type string compatible with numpy .", "label": 0}, {"idx": "cosqa-train-9549", "doc": "python read bytes into array", "code": "def be_array_from_bytes(fmt, data):\n    \"\"\"\n    Reads an array from bytestring with big-endian data.\n    \"\"\"\n    arr = array.array(str(fmt), data)\n    return fix_byteorder(arr)", "code_tokens": "def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )", "docstring_tokens": "Reads an array from bytestring with big - endian data .", "label": 1}, {"idx": "cosqa-train-9550", "doc": "how to limit 5 results in python list", "code": "def paginate(self, request, offset=0, limit=None):\n        \"\"\"Paginate queryset.\"\"\"\n        return self.collection.offset(offset).limit(limit), self.collection.count()", "code_tokens": "def paginate ( self , request , offset = 0 , limit = None ) : return self . collection . offset ( offset ) . limit ( limit ) , self . collection . count ( )", "docstring_tokens": "Paginate queryset .", "label": 1}, {"idx": "cosqa-train-9551", "doc": "python read database into numpy", "code": "def convert_array(array):\n    \"\"\"\n    Converts an ARRAY string stored in the database back into a Numpy array.\n\n    Parameters\n    ----------\n    array: ARRAY\n        The array object to be converted back into a Numpy array.\n\n    Returns\n    -------\n    array\n            The converted Numpy array.\n\n    \"\"\"\n    out = io.BytesIO(array)\n    out.seek(0)\n    return np.load(out)", "code_tokens": "def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )", "docstring_tokens": "Converts an ARRAY string stored in the database back into a Numpy array .", "label": 1}, {"idx": "cosqa-train-9552", "doc": "how to load a matlab file into python h5py", "code": "def _load_data(filepath):\n  \"\"\"Loads the images and latent values into Numpy arrays.\"\"\"\n  with h5py.File(filepath, \"r\") as h5dataset:\n    image_array = np.array(h5dataset[\"images\"])\n    # The 'label' data set in the hdf5 file actually contains the float values\n    # and not the class labels.\n    values_array = np.array(h5dataset[\"labels\"])\n  return image_array, values_array", "code_tokens": "def _load_data ( filepath ) : with h5py . File ( filepath , \"r\" ) as h5dataset : image_array = np . array ( h5dataset [ \"images\" ] ) # The 'label' data set in the hdf5 file actually contains the float values # and not the class labels. values_array = np . array ( h5dataset [ \"labels\" ] ) return image_array , values_array", "docstring_tokens": "Loads the images and latent values into Numpy arrays .", "label": 0}, {"idx": "cosqa-train-9553", "doc": "python read dot file", "code": "def graph_from_dot_file(path):\n    \"\"\"Load graph as defined by a DOT file.\n    \n    The file is assumed to be in DOT format. It will\n    be loaded, parsed and a Dot class will be returned, \n    representing the graph.\n    \"\"\"\n    \n    fd = file(path, 'rb')\n    data = fd.read()\n    fd.close()\n    \n    return graph_from_dot_data(data)", "code_tokens": "def graph_from_dot_file ( path ) : fd = file ( path , 'rb' ) data = fd . read ( ) fd . close ( ) return graph_from_dot_data ( data )", "docstring_tokens": "Load graph as defined by a DOT file . The file is assumed to be in DOT format . It will be loaded parsed and a Dot class will be returned representing the graph .", "label": 1}, {"idx": "cosqa-train-9554", "doc": "how to load mnist dataset in python from skikit", "code": "def get_mnist(data_type=\"train\", location=\"/tmp/mnist\"):\n    \"\"\"\n    Get mnist dataset with features and label as ndarray.\n    Data would be downloaded automatically if it doesn't present at the specific location.\n\n    :param data_type: \"train\" for training data and \"test\" for testing data.\n    :param location: Location to store mnist dataset.\n    :return: (features: ndarray, label: ndarray)\n    \"\"\"\n    X, Y = mnist.read_data_sets(location, data_type)\n    return X, Y + 1", "code_tokens": "def get_mnist ( data_type = \"train\" , location = \"/tmp/mnist\" ) : X , Y = mnist . read_data_sets ( location , data_type ) return X , Y + 1", "docstring_tokens": "Get mnist dataset with features and label as ndarray . Data would be downloaded automatically if it doesn t present at the specific location .", "label": 0}, {"idx": "cosqa-train-9555", "doc": "python read file and conver to string", "code": "def file_to_str(fname):\n    \"\"\"\n    Read a file into a string\n    PRE: fname is a small file (to avoid hogging memory and its discontents)\n    \"\"\"\n    data = None\n    # rU = read with Universal line terminator\n    with open(fname, 'rU') as fd:\n        data = fd.read()\n    return data", "code_tokens": "def file_to_str ( fname ) : data = None # rU = read with Universal line terminator with open ( fname , 'rU' ) as fd : data = fd . read ( ) return data", "docstring_tokens": "Read a file into a string PRE : fname is a small file ( to avoid hogging memory and its discontents )", "label": 1}, {"idx": "cosqa-train-9556", "doc": "how to load rds file in python 3", "code": "def load_graph_from_rdf(fname):\n    \"\"\" reads an RDF file into a graph \"\"\"\n    print(\"reading RDF from \" + fname + \"....\")\n    store = Graph()\n    store.parse(fname, format=\"n3\")\n    print(\"Loaded \" + str(len(store)) + \" tuples\")\n    return store", "code_tokens": "def load_graph_from_rdf ( fname ) : print ( \"reading RDF from \" + fname + \"....\" ) store = Graph ( ) store . parse ( fname , format = \"n3\" ) print ( \"Loaded \" + str ( len ( store ) ) + \" tuples\" ) return store", "docstring_tokens": "reads an RDF file into a graph", "label": 1}, {"idx": "cosqa-train-9557", "doc": "python read file bytes to array", "code": "def read_numpy(fh, byteorder, dtype, count, offsetsize):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    dtype = 'b' if dtype[-1] == 's' else byteorder+dtype[-1]\n    return fh.read_array(dtype, count)", "code_tokens": "def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 0}, {"idx": "cosqa-train-9558", "doc": "how to make a function in python to take the average of list numbers", "code": "def calc_list_average(l):\n    \"\"\"\n    Calculates the average value of a list of numbers\n    Returns a float\n    \"\"\"\n    total = 0.0\n    for value in l:\n        total += value\n    return total / len(l)", "code_tokens": "def calc_list_average ( l ) : total = 0.0 for value in l : total += value return total / len ( l )", "docstring_tokens": "Calculates the average value of a list of numbers Returns a float", "label": 1}, {"idx": "cosqa-train-9559", "doc": "python read file slow", "code": "def _fast_read(self, infile):\n        \"\"\"Function for fast reading from sensor files.\"\"\"\n        infile.seek(0)\n        return(int(infile.read().decode().strip()))", "code_tokens": "def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )", "docstring_tokens": "Function for fast reading from sensor files .", "label": 0}, {"idx": "cosqa-train-9560", "doc": "how to make a function iterable in python", "code": "def map(cls, iterable, func, *a, **kw):\n    \"\"\"\n    Iterable-first replacement of Python's built-in `map()` function.\n    \"\"\"\n\n    return cls(func(x, *a, **kw) for x in iterable)", "code_tokens": "def map ( cls , iterable , func , * a , * * kw ) : return cls ( func ( x , * a , * * kw ) for x in iterable )", "docstring_tokens": "Iterable - first replacement of Python s built - in map () function .", "label": 1}, {"idx": "cosqa-train-9561", "doc": "python read file specific content", "code": "def read(fname):\n    \"\"\"Quick way to read a file content.\"\"\"\n    content = None\n    with open(os.path.join(here, fname)) as f:\n        content = f.read()\n    return content", "code_tokens": "def read ( fname ) : content = None with open ( os . path . join ( here , fname ) ) as f : content = f . read ( ) return content", "docstring_tokens": "Quick way to read a file content .", "label": 1}, {"idx": "cosqa-train-9562", "doc": "how to make a input to have no spaces in python\\", "code": "def pass_from_pipe(cls):\n        \"\"\"Return password from pipe if not on TTY, else False.\n        \"\"\"\n        is_pipe = not sys.stdin.isatty()\n        return is_pipe and cls.strip_last_newline(sys.stdin.read())", "code_tokens": "def pass_from_pipe ( cls ) : is_pipe = not sys . stdin . isatty ( ) return is_pipe and cls . strip_last_newline ( sys . stdin . read ( ) )", "docstring_tokens": "Return password from pipe if not on TTY else False .", "label": 1}, {"idx": "cosqa-train-9563", "doc": "python read file with enumerate", "code": "def _fast_read(self, infile):\n        \"\"\"Function for fast reading from sensor files.\"\"\"\n        infile.seek(0)\n        return(int(infile.read().decode().strip()))", "code_tokens": "def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )", "docstring_tokens": "Function for fast reading from sensor files .", "label": 0}, {"idx": "cosqa-train-9564", "doc": "how to make a list from what a cursor sees python", "code": "def INIT_LIST_EXPR(self, cursor):\n        \"\"\"Returns a list of literal values.\"\"\"\n        values = [self.parse_cursor(child)\n                  for child in list(cursor.get_children())]\n        return values", "code_tokens": "def INIT_LIST_EXPR ( self , cursor ) : values = [ self . parse_cursor ( child ) for child in list ( cursor . get_children ( ) ) ] return values", "docstring_tokens": "Returns a list of literal values .", "label": 1}, {"idx": "cosqa-train-9565", "doc": "python read from stdin without enter", "code": "def read_stdin():\n    \"\"\" Read text from stdin, and print a helpful message for ttys. \"\"\"\n    if sys.stdin.isatty() and sys.stdout.isatty():\n        print('\\nReading from stdin until end of file (Ctrl + D)...')\n\n    return sys.stdin.read()", "code_tokens": "def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )", "docstring_tokens": "Read text from stdin and print a helpful message for ttys .", "label": 1}, {"idx": "cosqa-train-9566", "doc": "how to make a plane in vtk python", "code": "def _generate_plane(normal, origin):\n    \"\"\" Returns a vtk.vtkPlane \"\"\"\n    plane = vtk.vtkPlane()\n    plane.SetNormal(normal[0], normal[1], normal[2])\n    plane.SetOrigin(origin[0], origin[1], origin[2])\n    return plane", "code_tokens": "def _generate_plane ( normal , origin ) : plane = vtk . vtkPlane ( ) plane . SetNormal ( normal [ 0 ] , normal [ 1 ] , normal [ 2 ] ) plane . SetOrigin ( origin [ 0 ] , origin [ 1 ] , origin [ 2 ] ) return plane", "docstring_tokens": "Returns a vtk . vtkPlane", "label": 0}, {"idx": "cosqa-train-9567", "doc": "python read text file without comments", "code": "def parse_comments_for_file(filename):\n    \"\"\"\n    Return a list of all parsed comments in a file.  Mostly for testing &\n    interactive use.\n    \"\"\"\n    return [parse_comment(strip_stars(comment), next_line)\n            for comment, next_line in get_doc_comments(read_file(filename))]", "code_tokens": "def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]", "docstring_tokens": "Return a list of all parsed comments in a file . Mostly for testing & interactive use .", "label": 1}, {"idx": "cosqa-train-9568", "doc": "how to make a python bot run continuously", "code": "def run(self, forever=True):\n        \"\"\"start the bot\"\"\"\n        loop = self.create_connection()\n        self.add_signal_handlers()\n        if forever:\n            loop.run_forever()", "code_tokens": "def run ( self , forever = True ) : loop = self . create_connection ( ) self . add_signal_handlers ( ) if forever : loop . run_forever ( )", "docstring_tokens": "start the bot", "label": 1}, {"idx": "cosqa-train-9569", "doc": "python read tiff image as an array", "code": "def ReadTif(tifFile):\n        \"\"\"Reads a tif file to a 2D NumPy array\"\"\"\n        img = Image.open(tifFile)\n        img = np.array(img)\n        return img", "code_tokens": "def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img", "docstring_tokens": "Reads a tif file to a 2D NumPy array", "label": 1}, {"idx": "cosqa-train-9570", "doc": "how to make a python code delete itself without a window popping up", "code": "def cleanup(self):\n        \"\"\"Forcefully delete objects from memory\n\n        In an ideal world, this shouldn't be necessary. Garbage\n        collection guarantees that anything without reference\n        is automatically removed.\n\n        However, because this application is designed to be run\n        multiple times from the same interpreter process, extra\n        case must be taken to ensure there are no memory leaks.\n\n        Explicitly deleting objects shines a light on where objects\n        may still be referenced in the form of an error. No errors\n        means this was uneccesary, but that's ok.\n\n        \"\"\"\n\n        for instance in self.context:\n            del(instance)\n\n        for plugin in self.plugins:\n            del(plugin)", "code_tokens": "def cleanup ( self ) : for instance in self . context : del ( instance ) for plugin in self . plugins : del ( plugin )", "docstring_tokens": "Forcefully delete objects from memory", "label": 1}, {"idx": "cosqa-train-9571", "doc": "python recursion sum of the left leaves", "code": "def compute_depth(self):\n        \"\"\"\n        Recursively computes true depth of the subtree. Should only\n        be needed for debugging. Unless something is wrong, the\n        depth field should reflect the correct depth of the subtree.\n        \"\"\"\n        left_depth = self.left_node.compute_depth() if self.left_node else 0\n        right_depth = self.right_node.compute_depth() if self.right_node else 0\n        return 1 + max(left_depth, right_depth)", "code_tokens": "def compute_depth ( self ) : left_depth = self . left_node . compute_depth ( ) if self . left_node else 0 right_depth = self . right_node . compute_depth ( ) if self . right_node else 0 return 1 + max ( left_depth , right_depth )", "docstring_tokens": "Recursively computes true depth of the subtree . Should only be needed for debugging . Unless something is wrong the depth field should reflect the correct depth of the subtree .", "label": 1}, {"idx": "cosqa-train-9572", "doc": "how to make a python code to exit", "code": "def fail(message=None, exit_status=None):\n    \"\"\"Prints the specified message and exits the program with the specified\n    exit status.\n\n    \"\"\"\n    print('Error:', message, file=sys.stderr)\n    sys.exit(exit_status or 1)", "code_tokens": "def fail ( message = None , exit_status = None ) : print ( 'Error:' , message , file = sys . stderr ) sys . exit ( exit_status or 1 )", "docstring_tokens": "Prints the specified message and exits the program with the specified exit status .", "label": 0}, {"idx": "cosqa-train-9573", "doc": "python redirect output to both file and stdout", "code": "def redirect_output(fileobj):\n    \"\"\"Redirect standard out to file.\"\"\"\n    old = sys.stdout\n    sys.stdout = fileobj\n    try:\n        yield fileobj\n    finally:\n        sys.stdout = old", "code_tokens": "def redirect_output ( fileobj ) : old = sys . stdout sys . stdout = fileobj try : yield fileobj finally : sys . stdout = old", "docstring_tokens": "Redirect standard out to file .", "label": 1}, {"idx": "cosqa-train-9574", "doc": "how to make a python list in yaml", "code": "def convert_to_yaml(\n        name, value, indentation, indexOfColon, show_multi_line_character):\n    \"\"\"converts a value list into yaml syntax\n    :param name: name of object (example: phone)\n    :type name: str\n    :param value: object contents\n    :type value: str, list(str), list(list(str))\n    :param indentation: indent all by number of spaces\n    :type indentation: int\n    :param indexOfColon: use to position : at the name string (-1 for no space)\n    :type indexOfColon: int\n    :param show_multi_line_character: option to hide \"|\"\n    :type show_multi_line_character: boolean\n    :returns: yaml formatted string array of name, value pair\n    :rtype: list(str)\n    \"\"\"\n    strings = []\n    if isinstance(value, list):\n        # special case for single item lists:\n        if len(value) == 1 \\\n                and isinstance(value[0], str):\n            # value = [\"string\"] should not be converted to\n            # name:\n            #   - string\n            # but to \"name: string\" instead\n            value = value[0]\n        elif len(value) == 1 \\\n                and isinstance(value[0], list) \\\n                and len(value[0]) == 1 \\\n                and isinstance(value[0][0], str):\n            # same applies to value = [[\"string\"]]\n            value = value[0][0]\n    if isinstance(value, str):\n        strings.append(\"%s%s%s: %s\" % (\n            ' ' * indentation, name, ' ' * (indexOfColon-len(name)),\n            indent_multiline_string(value, indentation+4,\n                                    show_multi_line_character)))\n    elif isinstance(value, list):\n        strings.append(\"%s%s%s: \" % (\n            ' ' * indentation, name, ' ' * (indexOfColon-len(name))))\n        for outer in value:\n            # special case for single item sublists\n            if isinstance(outer, list) \\\n                    and len(outer) == 1 \\\n                    and isinstance(outer[0], str):\n                # outer = [\"string\"] should not be converted to\n                # -\n                #   - string\n                # but to \"- string\" instead\n                outer = outer[0]\n            if isinstance(outer, str):\n                strings.append(\"%s- %s\" % (\n                    ' ' * (indentation+4), indent_multiline_string(\n                        outer, indentation+8, show_multi_line_character)))\n            elif isinstance(outer, list):\n                strings.append(\"%s- \" % (' ' * (indentation+4)))\n                for inner in outer:\n                    if isinstance(inner, str):\n                        strings.append(\"%s- %s\" % (\n                            ' ' * (indentation+8), indent_multiline_string(\n                                inner, indentation+12,\n                                show_multi_line_character)))\n    return strings", "code_tokens": "def convert_to_yaml ( name , value , indentation , indexOfColon , show_multi_line_character ) : strings = [ ] if isinstance ( value , list ) : # special case for single item lists: if len ( value ) == 1 and isinstance ( value [ 0 ] , str ) : # value = [\"string\"] should not be converted to # name: #   - string # but to \"name: string\" instead value = value [ 0 ] elif len ( value ) == 1 and isinstance ( value [ 0 ] , list ) and len ( value [ 0 ] ) == 1 and isinstance ( value [ 0 ] [ 0 ] , str ) : # same applies to value = [[\"string\"]] value = value [ 0 ] [ 0 ] if isinstance ( value , str ) : strings . append ( \"%s%s%s: %s\" % ( ' ' * indentation , name , ' ' * ( indexOfColon - len ( name ) ) , indent_multiline_string ( value , indentation + 4 , show_multi_line_character ) ) ) elif isinstance ( value , list ) : strings . append ( \"%s%s%s: \" % ( ' ' * indentation , name , ' ' * ( indexOfColon - len ( name ) ) ) ) for outer in value : # special case for single item sublists if isinstance ( outer , list ) and len ( outer ) == 1 and isinstance ( outer [ 0 ] , str ) : # outer = [\"string\"] should not be converted to # - #   - string # but to \"- string\" instead outer = outer [ 0 ] if isinstance ( outer , str ) : strings . append ( \"%s- %s\" % ( ' ' * ( indentation + 4 ) , indent_multiline_string ( outer , indentation + 8 , show_multi_line_character ) ) ) elif isinstance ( outer , list ) : strings . append ( \"%s- \" % ( ' ' * ( indentation + 4 ) ) ) for inner in outer : if isinstance ( inner , str ) : strings . append ( \"%s- %s\" % ( ' ' * ( indentation + 8 ) , indent_multiline_string ( inner , indentation + 12 , show_multi_line_character ) ) ) return strings", "docstring_tokens": "converts a value list into yaml syntax : param name : name of object ( example : phone ) : type name : str : param value : object contents : type value : str list ( str ) list ( list ( str )) : param indentation : indent all by number of spaces : type indentation : int : param indexOfColon : use to position : at the name string ( - 1 for no space ) : type indexOfColon : int : param show_multi_line_character : option to hide | : type show_multi_line_character : boolean : returns : yaml formatted string array of name value pair : rtype : list ( str )", "label": 0}, {"idx": "cosqa-train-9575", "doc": "python redirect stdout contextmanager", "code": "def __exit__(self, *args):\n        \"\"\"Redirect stdout back to the original stdout.\"\"\"\n        sys.stdout = self._orig\n        self._devnull.close()", "code_tokens": "def __exit__ ( self , * args ) : sys . stdout = self . _orig self . _devnull . close ( )", "docstring_tokens": "Redirect stdout back to the original stdout .", "label": 1}, {"idx": "cosqa-train-9576", "doc": "how to make a python loop pause", "code": "def main(idle):\n    \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"\n    while True:\n\n        LOG.debug(\"Sleeping for {0} seconds.\".format(idle))\n        time.sleep(idle)", "code_tokens": "def main ( idle ) : while True : LOG . debug ( \"Sleeping for {0} seconds.\" . format ( idle ) ) time . sleep ( idle )", "docstring_tokens": "Any normal python logic which runs a loop . Can take arguments .", "label": 0}, {"idx": "cosqa-train-9577", "doc": "python redirect stdout to both buffer a logger at the same time", "code": "def disable_stdout_buffering():\n    \"\"\"This turns off stdout buffering so that outputs are immediately\n    materialized and log messages show up before the program exits\"\"\"\n    stdout_orig = sys.stdout\n    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)\n    # NOTE(brandyn): This removes the original stdout\n    return stdout_orig", "code_tokens": "def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig", "docstring_tokens": "This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits", "label": 1}, {"idx": "cosqa-train-9578", "doc": "how to make a simple exit in python", "code": "def safe_exit(output):\n    \"\"\"exit without breaking pipes.\"\"\"\n    try:\n        sys.stdout.write(output)\n        sys.stdout.flush()\n    except IOError:\n        pass", "code_tokens": "def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass", "docstring_tokens": "exit without breaking pipes .", "label": 1}, {"idx": "cosqa-train-9579", "doc": "python redis get value", "code": "def _internal_kv_get(key):\n    \"\"\"Fetch the value of a binary key.\"\"\"\n\n    worker = ray.worker.get_global_worker()\n    if worker.mode == ray.worker.LOCAL_MODE:\n        return _local.get(key)\n\n    return worker.redis_client.hget(key, \"value\")", "code_tokens": "def _internal_kv_get ( key ) : worker = ray . worker . get_global_worker ( ) if worker . mode == ray . worker . LOCAL_MODE : return _local . get ( key ) return worker . redis_client . hget ( key , \"value\" )", "docstring_tokens": "Fetch the value of a binary key .", "label": 1}, {"idx": "cosqa-train-9580", "doc": "python redis list pop sequence", "code": "def rpop(self, key):\n        \"\"\"Emulate lpop.\"\"\"\n        redis_list = self._get_list(key, 'RPOP')\n\n        if self._encode(key) not in self.redis:\n            return None\n\n        try:\n            value = redis_list.pop()\n            if len(redis_list) == 0:\n                self.delete(key)\n            return value\n        except (IndexError):\n            # Redis returns nil if popping from an empty list\n            return None", "code_tokens": "def rpop ( self , key ) : redis_list = self . _get_list ( key , 'RPOP' ) if self . _encode ( key ) not in self . redis : return None try : value = redis_list . pop ( ) if len ( redis_list ) == 0 : self . delete ( key ) return value except ( IndexError ) : # Redis returns nil if popping from an empty list return None", "docstring_tokens": "Emulate lpop .", "label": 0}, {"idx": "cosqa-train-9581", "doc": "how to make a string in python capitalize", "code": "def to_capitalized_camel_case(snake_case_string):\n    \"\"\"\n    Convert a string from snake case to camel case with the first letter capitalized. For example, \"some_var\"\n    would become \"SomeVar\".\n\n    :param snake_case_string: Snake-cased string to convert to camel case.\n    :returns: Camel-cased version of snake_case_string.\n    \"\"\"\n    parts = snake_case_string.split('_')\n    return ''.join([i.title() for i in parts])", "code_tokens": "def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )", "docstring_tokens": "Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar .", "label": 1}, {"idx": "cosqa-train-9582", "doc": "python redis qeuue blocked", "code": "def exists(self):\n        \"\"\"\n        Returns true if the job is still running or zero-os still knows about this job ID\n\n        After a job is finished, a job remains on zero-os for max of 5min where you still can read the job result\n        after the 5 min is gone, the job result is no more fetchable\n        :return: bool\n        \"\"\"\n        r = self._client._redis\n        flag = '{}:flag'.format(self._queue)\n        return bool(r.exists(flag))", "code_tokens": "def exists ( self ) : r = self . _client . _redis flag = '{}:flag' . format ( self . _queue ) return bool ( r . exists ( flag ) )", "docstring_tokens": "Returns true if the job is still running or zero - os still knows about this job ID", "label": 1}, {"idx": "cosqa-train-9583", "doc": "how to make a toggle button in python", "code": "def disable(self):\n        \"\"\"\n        Disable the button, if in non-expert mode;\n        unset its activity flag come-what-may.\n        \"\"\"\n        if not self._expert:\n            self.config(state='disable')\n        self._active = False", "code_tokens": "def disable ( self ) : if not self . _expert : self . config ( state = 'disable' ) self . _active = False", "docstring_tokens": "Disable the button if in non - expert mode ; unset its activity flag come - what - may .", "label": 0}, {"idx": "cosqa-train-9584", "doc": "python redis set function", "code": "def __setitem__(self, field, value):\n        \"\"\" :see::meth:RedisMap.__setitem__ \"\"\"\n        return self._client.hset(self.key_prefix, field, self._dumps(value))", "code_tokens": "def __setitem__ ( self , field , value ) : return self . _client . hset ( self . key_prefix , field , self . _dumps ( value ) )", "docstring_tokens": ": see :: meth : RedisMap . __setitem__", "label": 0}, {"idx": "cosqa-train-9585", "doc": "how to make alternate elements of a matrix to 1 in python", "code": "def normalize_matrix(matrix):\n  \"\"\"Fold all values of the matrix into [0, 1].\"\"\"\n  abs_matrix = np.abs(matrix.copy())\n  return abs_matrix / abs_matrix.max()", "code_tokens": "def normalize_matrix ( matrix ) : abs_matrix = np . abs ( matrix . copy ( ) ) return abs_matrix / abs_matrix . max ( )", "docstring_tokens": "Fold all values of the matrix into [ 0 1 ] .", "label": 1}, {"idx": "cosqa-train-9586", "doc": "python reflection get type from string", "code": "def construct_from_string(cls, string):\n        \"\"\"\n        Construction from a string, raise a TypeError if not\n        possible\n        \"\"\"\n        if string == cls.name:\n            return cls()\n        raise TypeError(\"Cannot construct a '{}' from \"\n                        \"'{}'\".format(cls, string))", "code_tokens": "def construct_from_string ( cls , string ) : if string == cls . name : return cls ( ) raise TypeError ( \"Cannot construct a '{}' from \" \"'{}'\" . format ( cls , string ) )", "docstring_tokens": "Construction from a string raise a TypeError if not possible", "label": 0}, {"idx": "cosqa-train-9587", "doc": "how to make arrays into floats python", "code": "def as_float_array(a):\n    \"\"\"View the quaternion array as an array of floats\n\n    This function is fast (of order 1 microsecond) because no data is\n    copied; the returned quantity is just a \"view\" of the original.\n\n    The output view has one more dimension (of size 4) than the input\n    array, but is otherwise the same shape.\n\n    \"\"\"\n    return np.asarray(a, dtype=np.quaternion).view((np.double, 4))", "code_tokens": "def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )", "docstring_tokens": "View the quaternion array as an array of floats", "label": 1}, {"idx": "cosqa-train-9588", "doc": "python reflection invoke method by name", "code": "def FindMethodByName(self, name):\n    \"\"\"Searches for the specified method, and returns its descriptor.\"\"\"\n    for method in self.methods:\n      if name == method.name:\n        return method\n    return None", "code_tokens": "def FindMethodByName ( self , name ) : for method in self . methods : if name == method . name : return method return None", "docstring_tokens": "Searches for the specified method and returns its descriptor .", "label": 1}, {"idx": "cosqa-train-9589", "doc": "how to make colorbar on python", "code": "def colorbar(height, length, colormap):\n    \"\"\"Return the channels of a colorbar.\n    \"\"\"\n    cbar = np.tile(np.arange(length) * 1.0 / (length - 1), (height, 1))\n    cbar = (cbar * (colormap.values.max() - colormap.values.min())\n            + colormap.values.min())\n\n    return colormap.colorize(cbar)", "code_tokens": "def colorbar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . colorize ( cbar )", "docstring_tokens": "Return the channels of a colorbar .", "label": 1}, {"idx": "cosqa-train-9590", "doc": "python regex get domain from url", "code": "def parse_domain(url):\n    \"\"\" parse the domain from the url \"\"\"\n    domain_match = lib.DOMAIN_REGEX.match(url)\n    if domain_match:\n        return domain_match.group()", "code_tokens": "def parse_domain ( url ) : domain_match = lib . DOMAIN_REGEX . match ( url ) if domain_match : return domain_match . group ( )", "docstring_tokens": "parse the domain from the url", "label": 0}, {"idx": "cosqa-train-9591", "doc": "how to make conda default python environment", "code": "def create_conda_env(sandbox_dir, env_name, dependencies, options=()):\n    \"\"\"\n    Create a conda environment inside the current sandbox for the given list of dependencies and options.\n\n    Parameters\n    ----------\n    sandbox_dir : str\n    env_name : str\n    dependencies : list\n        List of conda specs\n    options\n        List of additional options to pass to conda.  Things like [\"-c\", \"conda-forge\"]\n\n    Returns\n    -------\n    (env_dir, env_name)\n    \"\"\"\n\n    env_dir = os.path.join(sandbox_dir, env_name)\n    cmdline = [\"conda\", \"create\", \"--yes\", \"--copy\", \"--quiet\", \"-p\", env_dir] + list(options) + dependencies\n\n    log.info(\"Creating conda environment: \")\n    log.info(\"  command line: %s\", cmdline)\n    subprocess.check_call(cmdline, stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n    log.debug(\"Environment created\")\n\n    return env_dir, env_name", "code_tokens": "def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ \"conda\" , \"create\" , \"--yes\" , \"--copy\" , \"--quiet\" , \"-p\" , env_dir ] + list ( options ) + dependencies log . info ( \"Creating conda environment: \" ) log . info ( \"  command line: %s\" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( \"Environment created\" ) return env_dir , env_name", "docstring_tokens": "Create a conda environment inside the current sandbox for the given list of dependencies and options .", "label": 1}, {"idx": "cosqa-train-9592", "doc": "python regex replace with count", "code": "def subn_filter(s, find, replace, count=0):\n    \"\"\"A non-optimal implementation of a regex filter\"\"\"\n    return re.gsub(find, replace, count, s)", "code_tokens": "def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )", "docstring_tokens": "A non - optimal implementation of a regex filter", "label": 1}, {"idx": "cosqa-train-9593", "doc": "how to make custom windows error with python", "code": "def add_str(window, line_num, str):\n    \"\"\" attempt to draw str on screen and ignore errors if they occur \"\"\"\n    try:\n        window.addstr(line_num, 0, str)\n    except curses.error:\n        pass", "code_tokens": "def add_str ( window , line_num , str ) : try : window . addstr ( line_num , 0 , str ) except curses . error : pass", "docstring_tokens": "attempt to draw str on screen and ignore errors if they occur", "label": 1}, {"idx": "cosqa-train-9594", "doc": "python regex s deprecated", "code": "def _cached_search_compile(pattern, re_verbose, re_version, pattern_type):\n    \"\"\"Cached search compile.\"\"\"\n\n    return _bregex_parse._SearchParser(pattern, re_verbose, re_version).parse()", "code_tokens": "def _cached_search_compile ( pattern , re_verbose , re_version , pattern_type ) : return _bregex_parse . _SearchParser ( pattern , re_verbose , re_version ) . parse ( )", "docstring_tokens": "Cached search compile .", "label": 1}, {"idx": "cosqa-train-9595", "doc": "how to make dictionary from dynamic path string python3", "code": "def parse_path(path):\n    \"\"\"Parse path string.\"\"\"\n    version, project = path[1:].split('/')\n    return dict(version=int(version), project=project)", "code_tokens": "def parse_path ( path ) : version , project = path [ 1 : ] . split ( '/' ) return dict ( version = int ( version ) , project = project )", "docstring_tokens": "Parse path string .", "label": 1}, {"idx": "cosqa-train-9596", "doc": "python regexpression not match comment", "code": "def _match_space_at_line(line):\n    \"\"\"Return a re.match object if an empty comment was found on line.\"\"\"\n    regex = re.compile(r\"^{0}$\".format(_MDL_COMMENT))\n    return regex.match(line)", "code_tokens": "def _match_space_at_line ( line ) : regex = re . compile ( r\"^{0}$\" . format ( _MDL_COMMENT ) ) return regex . match ( line )", "docstring_tokens": "Return a re . match object if an empty comment was found on line .", "label": 1}, {"idx": "cosqa-train-9597", "doc": "how to make everything in a list a string in python", "code": "def commajoin_as_strings(iterable):\n    \"\"\" Join the given iterable with ',' \"\"\"\n    return _(u',').join((six.text_type(i) for i in iterable))", "code_tokens": "def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )", "docstring_tokens": "Join the given iterable with", "label": 0}, {"idx": "cosqa-train-9598", "doc": "python remove all comments from c", "code": "def CleanseComments(line):\n  \"\"\"Removes //-comments and single-line C-style /* */ comments.\n\n  Args:\n    line: A line of C++ source.\n\n  Returns:\n    The line with single-line comments removed.\n  \"\"\"\n  commentpos = line.find('//')\n  if commentpos != -1 and not IsCppString(line[:commentpos]):\n    line = line[:commentpos].rstrip()\n  # get rid of /* ... */\n  return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS.sub('', line)", "code_tokens": "def CleanseComments ( line ) : commentpos = line . find ( '//' ) if commentpos != - 1 and not IsCppString ( line [ : commentpos ] ) : line = line [ : commentpos ] . rstrip ( ) # get rid of /* ... */ return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS . sub ( '' , line )", "docstring_tokens": "Removes // - comments and single - line C - style / * * / comments .", "label": 1}, {"idx": "cosqa-train-9599", "doc": "how to make f string colors python", "code": "def colorize(string, color, *args, **kwargs):\n    \"\"\"\n    Implements string formatting along with color specified in colorama.Fore\n    \"\"\"\n    string = string.format(*args, **kwargs)\n    return color + string + colorama.Fore.RESET", "code_tokens": "def colorize ( string , color , * args , * * kwargs ) : string = string . format ( * args , * * kwargs ) return color + string + colorama . Fore . RESET", "docstring_tokens": "Implements string formatting along with color specified in colorama . Fore", "label": 0}, {"idx": "cosqa-train-9600", "doc": "python remove all letters from string", "code": "def unaccentuate(s):\n    \"\"\" Replace accentuated chars in string by their non accentuated equivalent. \"\"\"\n    return \"\".join(c for c in unicodedata.normalize(\"NFKD\", s) if not unicodedata.combining(c))", "code_tokens": "def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "docstring_tokens": "Replace accentuated chars in string by their non accentuated equivalent .", "label": 0}, {"idx": "cosqa-train-9601", "doc": "how to make gradient in python", "code": "def compute_gradient(self):\n        \"\"\"Compute the gradient of the current model using the training set\n        \"\"\"\n        delta = self.predict(self.X) - self.y\n        return delta.dot(self.X) / len(self.X)", "code_tokens": "def compute_gradient ( self ) : delta = self . predict ( self . X ) - self . y return delta . dot ( self . X ) / len ( self . X )", "docstring_tokens": "Compute the gradient of the current model using the training set", "label": 1}, {"idx": "cosqa-train-9602", "doc": "python remove all non alphanumeric", "code": "def strip_accents(string):\n    \"\"\"\n    Strip all the accents from the string\n    \"\"\"\n    return u''.join(\n        (character for character in unicodedata.normalize('NFD', string)\n         if unicodedata.category(character) != 'Mn'))", "code_tokens": "def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )", "docstring_tokens": "Strip all the accents from the string", "label": 0}, {"idx": "cosqa-train-9603", "doc": "how to make matrix in python 3,7", "code": "def a2s(a):\n    \"\"\"\n     convert 3,3 a matrix to 6 element \"s\" list  (see Tauxe 1998)\n    \"\"\"\n    s = np.zeros((6,), 'f')  # make the a matrix\n    for i in range(3):\n        s[i] = a[i][i]\n    s[3] = a[0][1]\n    s[4] = a[1][2]\n    s[5] = a[0][2]\n    return s", "code_tokens": "def a2s ( a ) : s = np . zeros ( ( 6 , ) , 'f' ) # make the a matrix for i in range ( 3 ) : s [ i ] = a [ i ] [ i ] s [ 3 ] = a [ 0 ] [ 1 ] s [ 4 ] = a [ 1 ] [ 2 ] s [ 5 ] = a [ 0 ] [ 2 ] return s", "docstring_tokens": "convert 3 3 a matrix to 6 element s list ( see Tauxe 1998 )", "label": 0}, {"idx": "cosqa-train-9604", "doc": "python remove file permission deny", "code": "def make_file_read_only(file_path):\n    \"\"\"\n    Removes the write permissions for the given file for owner, groups and others.\n\n    :param file_path: The file whose privileges are revoked.\n    :raise FileNotFoundError: If the given file does not exist.\n    \"\"\"\n    old_permissions = os.stat(file_path).st_mode\n    os.chmod(file_path, old_permissions & ~WRITE_PERMISSIONS)", "code_tokens": "def make_file_read_only ( file_path ) : old_permissions = os . stat ( file_path ) . st_mode os . chmod ( file_path , old_permissions & ~ WRITE_PERMISSIONS )", "docstring_tokens": "Removes the write permissions for the given file for owner groups and others .", "label": 1}, {"idx": "cosqa-train-9605", "doc": "how to make multiline comment in python", "code": "def comment (self, s, **args):\n        \"\"\"Write DOT comment.\"\"\"\n        self.write(u\"// \")\n        self.writeln(s=s, **args)", "code_tokens": "def comment ( self , s , * * args ) : self . write ( u\"// \" ) self . writeln ( s = s , * * args )", "docstring_tokens": "Write DOT comment .", "label": 1}, {"idx": "cosqa-train-9606", "doc": "python remove from a dict if key is not present", "code": "def rm_keys_from_dict(d, keys):\n    \"\"\"\n    Given a dictionary and a key list, remove any data in the dictionary with the given keys.\n\n    :param dict d: Metadata\n    :param list keys: Keys to be removed\n    :return dict d: Metadata\n    \"\"\"\n    # Loop for each key given\n    for key in keys:\n        # Is the key in the dictionary?\n        if key in d:\n            try:\n                d.pop(key, None)\n            except KeyError:\n                # Not concerned with an error. Keep going.\n                pass\n    return d", "code_tokens": "def rm_keys_from_dict ( d , keys ) : # Loop for each key given for key in keys : # Is the key in the dictionary? if key in d : try : d . pop ( key , None ) except KeyError : # Not concerned with an error. Keep going. pass return d", "docstring_tokens": "Given a dictionary and a key list remove any data in the dictionary with the given keys .", "label": 0}, {"idx": "cosqa-train-9607", "doc": "how to make python datetime object timezone aware", "code": "def to_pydatetime(self):\n        \"\"\"\n        Converts datetimeoffset object into Python's datetime.datetime object\n        @return: time zone aware datetime.datetime\n        \"\"\"\n        dt = datetime.datetime.combine(self._date.to_pydate(), self._time.to_pytime())\n        from .tz import FixedOffsetTimezone\n        return dt.replace(tzinfo=_utc).astimezone(FixedOffsetTimezone(self._offset))", "code_tokens": "def to_pydatetime ( self ) : dt = datetime . datetime . combine ( self . _date . to_pydate ( ) , self . _time . to_pytime ( ) ) from . tz import FixedOffsetTimezone return dt . replace ( tzinfo = _utc ) . astimezone ( FixedOffsetTimezone ( self . _offset ) )", "docstring_tokens": "Converts datetimeoffset object into Python s datetime . datetime object", "label": 1}, {"idx": "cosqa-train-9608", "doc": "python remove from a list and return list", "code": "def remove_elements(target, indices):\n    \"\"\"Remove multiple elements from a list and return result.\n    This implementation is faster than the alternative below.\n    Also note the creation of a new list to avoid altering the\n    original. We don't have any current use for the original\n    intact list, but may in the future...\"\"\"\n\n    copied = list(target)\n\n    for index in reversed(indices):\n        del copied[index]\n    return copied", "code_tokens": "def remove_elements ( target , indices ) : copied = list ( target ) for index in reversed ( indices ) : del copied [ index ] return copied", "docstring_tokens": "Remove multiple elements from a list and return result . This implementation is faster than the alternative below . Also note the creation of a new list to avoid altering the original . We don t have any current use for the original intact list but may in the future ...", "label": 1}, {"idx": "cosqa-train-9609", "doc": "how to make python tables larger", "code": "def get_table(ports):\n    \"\"\"\n    This function returns a pretty table used to display the port results.\n\n    :param ports: list of found ports\n    :return: the table to display\n    \"\"\"\n    table = PrettyTable([\"Name\", \"Port\", \"Protocol\", \"Description\"])\n    table.align[\"Name\"] = \"l\"\n    table.align[\"Description\"] = \"l\"\n    table.padding_width = 1\n\n    for port in ports:\n        table.add_row(port)\n\n    return table", "code_tokens": "def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "docstring_tokens": "This function returns a pretty table used to display the port results .", "label": 0}, {"idx": "cosqa-train-9610", "doc": "python remove guid from file name", "code": "def abfIDfromFname(fname):\n    \"\"\"given a filename, return the ABFs ID string.\"\"\"\n    fname=os.path.abspath(fname)\n    basename=os.path.basename(fname)\n    return os.path.splitext(basename)[0]", "code_tokens": "def abfIDfromFname ( fname ) : fname = os . path . abspath ( fname ) basename = os . path . basename ( fname ) return os . path . splitext ( basename ) [ 0 ]", "docstring_tokens": "given a filename return the ABFs ID string .", "label": 0}, {"idx": "cosqa-train-9611", "doc": "how to make str to dict in python", "code": "def str_dict(some_dict):\n    \"\"\"Convert dict of ascii str/unicode to dict of str, if necessary\"\"\"\n    return {str(k): str(v) for k, v in some_dict.items()}", "code_tokens": "def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }", "docstring_tokens": "Convert dict of ascii str / unicode to dict of str if necessary", "label": 0}, {"idx": "cosqa-train-9612", "doc": "python remove item from apt cache", "code": "def __delitem__(self, resource):\n        \"\"\"Remove resource instance from internal cache\"\"\"\n        self.__caches[type(resource)].pop(resource.get_cache_internal_key(), None)", "code_tokens": "def __delitem__ ( self , resource ) : self . __caches [ type ( resource ) ] . pop ( resource . get_cache_internal_key ( ) , None )", "docstring_tokens": "Remove resource instance from internal cache", "label": 1}, {"idx": "cosqa-train-9613", "doc": "how to make string imput upper case in python 3", "code": "def clean(some_string, uppercase=False):\n    \"\"\"\n    helper to clean up an input string\n    \"\"\"\n    if uppercase:\n        return some_string.strip().upper()\n    else:\n        return some_string.strip().lower()", "code_tokens": "def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )", "docstring_tokens": "helper to clean up an input string", "label": 1}, {"idx": "cosqa-train-9614", "doc": "python remove items from wrapper", "code": "def cleanwrap(func):\n    \"\"\" Wrapper for Zotero._cleanup\n    \"\"\"\n\n    def enc(self, *args, **kwargs):\n        \"\"\" Send each item to _cleanup() \"\"\"\n        return (func(self, item, **kwargs) for item in args)\n\n    return enc", "code_tokens": "def cleanwrap ( func ) : def enc ( self , * args , * * kwargs ) : \"\"\" Send each item to _cleanup() \"\"\" return ( func ( self , item , * * kwargs ) for item in args ) return enc", "docstring_tokens": "Wrapper for Zotero . _cleanup", "label": 0}, {"idx": "cosqa-train-9615", "doc": "how to merge one dict with another python", "code": "def dict_merge(set1, set2):\n    \"\"\"Joins two dictionaries.\"\"\"\n    return dict(list(set1.items()) + list(set2.items()))", "code_tokens": "def dict_merge ( set1 , set2 ) : return dict ( list ( set1 . items ( ) ) + list ( set2 . items ( ) ) )", "docstring_tokens": "Joins two dictionaries .", "label": 0}, {"idx": "cosqa-train-9616", "doc": "python remove non letters in string", "code": "def clean(self, text):\n        \"\"\"Remove all unwanted characters from text.\"\"\"\n        return ''.join([c for c in text if c in self.alphabet])", "code_tokens": "def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )", "docstring_tokens": "Remove all unwanted characters from text .", "label": 1}, {"idx": "cosqa-train-9617", "doc": "python remove none values from a list", "code": "def filter_none(list_of_points):\n    \"\"\"\n    \n    :param list_of_points: \n    :return: list_of_points with None's removed\n    \"\"\"\n    remove_elementnone = filter(lambda p: p is not None, list_of_points)\n    remove_sublistnone = filter(lambda p: not contains_none(p), remove_elementnone)\n    return list(remove_sublistnone)", "code_tokens": "def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "docstring_tokens": ": param list_of_points : : return : list_of_points with None s removed", "label": 1}, {"idx": "cosqa-train-9618", "doc": "how to move legend to left side python", "code": "def mpl_outside_legend(ax, **kwargs):\n    \"\"\" Places a legend box outside a matplotlib Axes instance. \"\"\"\n    box = ax.get_position()\n    ax.set_position([box.x0, box.y0, box.width * 0.75, box.height])\n    # Put a legend to the right of the current axis\n    ax.legend(loc='upper left', bbox_to_anchor=(1, 1), **kwargs)", "code_tokens": "def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )", "docstring_tokens": "Places a legend box outside a matplotlib Axes instance .", "label": 1}, {"idx": "cosqa-train-9619", "doc": "how to move the location of the legend in a python graph", "code": "def mpl_outside_legend(ax, **kwargs):\n    \"\"\" Places a legend box outside a matplotlib Axes instance. \"\"\"\n    box = ax.get_position()\n    ax.set_position([box.x0, box.y0, box.width * 0.75, box.height])\n    # Put a legend to the right of the current axis\n    ax.legend(loc='upper left', bbox_to_anchor=(1, 1), **kwargs)", "code_tokens": "def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )", "docstring_tokens": "Places a legend box outside a matplotlib Axes instance .", "label": 1}, {"idx": "cosqa-train-9620", "doc": "python remove plus sign from a string", "code": "def slugify(string):\n    \"\"\"\n    Removes non-alpha characters, and converts spaces to hyphens. Useful for making file names.\n\n\n    Source: http://stackoverflow.com/questions/5574042/string-slugification-in-python\n    \"\"\"\n    string = re.sub('[^\\w .-]', '', string)\n    string = string.replace(\" \", \"-\")\n    return string", "code_tokens": "def slugify ( string ) : string = re . sub ( '[^\\w .-]' , '' , string ) string = string . replace ( \" \" , \"-\" ) return string", "docstring_tokens": "Removes non - alpha characters and converts spaces to hyphens . Useful for making file names . Source : http : // stackoverflow . com / questions / 5574042 / string - slugification - in - python", "label": 0}, {"idx": "cosqa-train-9621", "doc": "how to multiply list element in python", "code": "def multiply(self, number):\n        \"\"\"Return a Vector as the product of the vector and a real number.\"\"\"\n        return self.from_list([x * number for x in self.to_list()])", "code_tokens": "def multiply ( self , number ) : return self . from_list ( [ x * number for x in self . to_list ( ) ] )", "docstring_tokens": "Return a Vector as the product of the vector and a real number .", "label": 0}, {"idx": "cosqa-train-9622", "doc": "python remove repeated whitespace", "code": "def text_remove_empty_lines(text):\n    \"\"\"\n    Whitespace normalization:\n\n      - Strip empty lines\n      - Strip trailing whitespace\n    \"\"\"\n    lines = [ line.rstrip()  for line in text.splitlines()  if line.strip() ]\n    return \"\\n\".join(lines)", "code_tokens": "def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return \"\\n\" . join ( lines )", "docstring_tokens": "Whitespace normalization :", "label": 1}, {"idx": "cosqa-train-9623", "doc": "how to name a file property in python", "code": "def get_property(self, filename):\n        \"\"\"Opens the file and reads the value\"\"\"\n\n        with open(self.filepath(filename)) as f:\n            return f.read().strip()", "code_tokens": "def get_property ( self , filename ) : with open ( self . filepath ( filename ) ) as f : return f . read ( ) . strip ( )", "docstring_tokens": "Opens the file and reads the value", "label": 1}, {"idx": "cosqa-train-9624", "doc": "python remove space elements from list", "code": "def remove_bad(string):\n    \"\"\"\n    remove problem characters from string\n    \"\"\"\n    remove = [':', ',', '(', ')', ' ', '|', ';', '\\'']\n    for c in remove:\n        string = string.replace(c, '_')\n    return string", "code_tokens": "def remove_bad ( string ) : remove = [ ':' , ',' , '(' , ')' , ' ' , '|' , ';' , '\\'' ] for c in remove : string = string . replace ( c , '_' ) return string", "docstring_tokens": "remove problem characters from string", "label": 1}, {"idx": "cosqa-train-9625", "doc": "how to name a member dynamically python", "code": "def get_member(thing_obj, member_string):\n    \"\"\"Get a member from an object by (string) name\"\"\"\n    mems = {x[0]: x[1] for x in inspect.getmembers(thing_obj)}\n    if member_string in mems:\n        return mems[member_string]", "code_tokens": "def get_member ( thing_obj , member_string ) : mems = { x [ 0 ] : x [ 1 ] for x in inspect . getmembers ( thing_obj ) } if member_string in mems : return mems [ member_string ]", "docstring_tokens": "Get a member from an object by ( string ) name", "label": 1}, {"idx": "cosqa-train-9626", "doc": "python render sympy latex", "code": "def print_latex(o):\n    \"\"\"A function to generate the latex representation of sympy\n    expressions.\"\"\"\n    if can_print_latex(o):\n        s = latex(o, mode='plain')\n        s = s.replace('\\\\dag','\\\\dagger')\n        s = s.strip('$')\n        return '$$%s$$' % s\n    # Fallback to the string printer\n    return None", "code_tokens": "def print_latex ( o ) : if can_print_latex ( o ) : s = latex ( o , mode = 'plain' ) s = s . replace ( '\\\\dag' , '\\\\dagger' ) s = s . strip ( '$' ) return '$$%s$$' % s # Fallback to the string printer return None", "docstring_tokens": "A function to generate the latex representation of sympy expressions .", "label": 1}, {"idx": "cosqa-train-9627", "doc": "how to open a compiled python file in idle", "code": "def get_code(module):\n    \"\"\"\n    Compile and return a Module's code object.\n    \"\"\"\n    fp = open(module.path)\n    try:\n        return compile(fp.read(), str(module.name), 'exec')\n    finally:\n        fp.close()", "code_tokens": "def get_code ( module ) : fp = open ( module . path ) try : return compile ( fp . read ( ) , str ( module . name ) , 'exec' ) finally : fp . close ( )", "docstring_tokens": "Compile and return a Module s code object .", "label": 0}, {"idx": "cosqa-train-9628", "doc": "python reorder a list using an array of indices", "code": "def unsort_vector(data, indices_of_increasing):\n    \"\"\"Upermutate 1-D data that is sorted by indices_of_increasing.\"\"\"\n    return numpy.array([data[indices_of_increasing.index(i)] for i in range(len(data))])", "code_tokens": "def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )", "docstring_tokens": "Upermutate 1 - D data that is sorted by indices_of_increasing .", "label": 0}, {"idx": "cosqa-train-9629", "doc": "how to open a file using an abolute path python", "code": "def fopenat(base_fd, path):\n    \"\"\"\n    Does openat read-only, then does fdopen to get a file object\n    \"\"\"\n\n    return os.fdopen(openat(base_fd, path, os.O_RDONLY), 'rb')", "code_tokens": "def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )", "docstring_tokens": "Does openat read - only then does fdopen to get a file object", "label": 1}, {"idx": "cosqa-train-9630", "doc": "python replace blank values in a column", "code": "def stringify_col(df, col_name):\n    \"\"\"\n    Take a dataframe and string-i-fy a column of values.\n    Turn nan/None into \"\" and all other values into strings.\n\n    Parameters\n    ----------\n    df : dataframe\n    col_name : string\n    \"\"\"\n    df = df.copy()\n    df[col_name] = df[col_name].fillna(\"\")\n    df[col_name] = df[col_name].astype(str)\n    return df", "code_tokens": "def stringify_col ( df , col_name ) : df = df . copy ( ) df [ col_name ] = df [ col_name ] . fillna ( \"\" ) df [ col_name ] = df [ col_name ] . astype ( str ) return df", "docstring_tokens": "Take a dataframe and string - i - fy a column of values . Turn nan / None into and all other values into strings .", "label": 0}, {"idx": "cosqa-train-9631", "doc": "how to open an xlsx in python", "code": "def _openpyxl_read_xl(xl_path: str):\n    \"\"\" Use openpyxl to read an Excel file. \"\"\"\n    try:\n        wb = load_workbook(filename=xl_path, read_only=True)\n    except:\n        raise\n    else:\n        return wb", "code_tokens": "def _openpyxl_read_xl ( xl_path : str ) : try : wb = load_workbook ( filename = xl_path , read_only = True ) except : raise else : return wb", "docstring_tokens": "Use openpyxl to read an Excel file .", "label": 1}, {"idx": "cosqa-train-9632", "doc": "python replace characters with %", "code": "def quote(s, unsafe='/'):\n    \"\"\"Pass in a dictionary that has unsafe characters as the keys, and the percent\n    encoded value as the value.\"\"\"\n    res = s.replace('%', '%25')\n    for c in unsafe:\n        res = res.replace(c, '%' + (hex(ord(c)).upper())[2:])\n    return res", "code_tokens": "def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res", "docstring_tokens": "Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value .", "label": 1}, {"idx": "cosqa-train-9633", "doc": "how to open file with full permission in python", "code": "def fopenat(base_fd, path):\n    \"\"\"\n    Does openat read-only, then does fdopen to get a file object\n    \"\"\"\n\n    return os.fdopen(openat(base_fd, path, os.O_RDONLY), 'rb')", "code_tokens": "def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )", "docstring_tokens": "Does openat read - only then does fdopen to get a file object", "label": 0}, {"idx": "cosqa-train-9634", "doc": "python replace every letter for", "code": "def dashrepl(value):\n    \"\"\"\n    Replace any non-word characters with a dash.\n    \"\"\"\n    patt = re.compile(r'\\W', re.UNICODE)\n    return re.sub(patt, '-', value)", "code_tokens": "def dashrepl ( value ) : patt = re . compile ( r'\\W' , re . UNICODE ) return re . sub ( patt , '-' , value )", "docstring_tokens": "Replace any non - word characters with a dash .", "label": 1}, {"idx": "cosqa-train-9635", "doc": "how to open protobuf in python", "code": "def read_proto_object(fobj, klass):\n    \"\"\"Read a block of data and parse using the given protobuf object.\"\"\"\n    log.debug('%s chunk', klass.__name__)\n    obj = klass()\n    obj.ParseFromString(read_block(fobj))\n    log.debug('Header: %s', str(obj))\n    return obj", "code_tokens": "def read_proto_object ( fobj , klass ) : log . debug ( '%s chunk' , klass . __name__ ) obj = klass ( ) obj . ParseFromString ( read_block ( fobj ) ) log . debug ( 'Header: %s' , str ( obj ) ) return obj", "docstring_tokens": "Read a block of data and parse using the given protobuf object .", "label": 1}, {"idx": "cosqa-train-9636", "doc": "python replace multiple whitespaces", "code": "def normalize_value(text):\n    \"\"\"\n    This removes newlines and multiple spaces from a string.\n    \"\"\"\n    result = text.replace('\\n', ' ')\n    result = re.subn('[ ]{2,}', ' ', result)[0]\n    return result", "code_tokens": "def normalize_value ( text ) : result = text . replace ( '\\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result", "docstring_tokens": "This removes newlines and multiple spaces from a string .", "label": 1}, {"idx": "cosqa-train-9637", "doc": "how to overload constructor python", "code": "def __init__(self, find, subcon):\n        \"\"\"Initialize.\"\"\"\n        Subconstruct.__init__(self, subcon)\n        self.find = find", "code_tokens": "def __init__ ( self , find , subcon ) : Subconstruct . __init__ ( self , subcon ) self . find = find", "docstring_tokens": "Initialize .", "label": 1}, {"idx": "cosqa-train-9638", "doc": "python replace non letter symbols", "code": "def dashrepl(value):\n    \"\"\"\n    Replace any non-word characters with a dash.\n    \"\"\"\n    patt = re.compile(r'\\W', re.UNICODE)\n    return re.sub(patt, '-', value)", "code_tokens": "def dashrepl ( value ) : patt = re . compile ( r'\\W' , re . UNICODE ) return re . sub ( patt , '-' , value )", "docstring_tokens": "Replace any non - word characters with a dash .", "label": 0}, {"idx": "cosqa-train-9639", "doc": "how to parse an error in python try", "code": "def clean_error(err):\n    \"\"\"\n    Take stderr bytes returned from MicroPython and attempt to create a\n    non-verbose error message.\n    \"\"\"\n    if err:\n        decoded = err.decode('utf-8')\n        try:\n            return decoded.split('\\r\\n')[-2]\n        except Exception:\n            return decoded\n    return 'There was an error.'", "code_tokens": "def clean_error ( err ) : if err : decoded = err . decode ( 'utf-8' ) try : return decoded . split ( '\\r\\n' ) [ - 2 ] except Exception : return decoded return 'There was an error.'", "docstring_tokens": "Take stderr bytes returned from MicroPython and attempt to create a non - verbose error message .", "label": 1}, {"idx": "cosqa-train-9640", "doc": "python replace substitute text in string", "code": "def fmt_subst(regex, subst):\n    \"\"\"Replace regex with string.\"\"\"\n    return lambda text: re.sub(regex, subst, text) if text else text", "code_tokens": "def fmt_subst ( regex , subst ) : return lambda text : re . sub ( regex , subst , text ) if text else text", "docstring_tokens": "Replace regex with string .", "label": 1}, {"idx": "cosqa-train-9641", "doc": "how to parse response python application/zip", "code": "def _gzip(self, response):\n        \"\"\"Apply gzip compression to a response.\"\"\"\n        bytesio = six.BytesIO()\n        with gzip.GzipFile(fileobj=bytesio, mode='w') as gz:\n            gz.write(response)\n        return bytesio.getvalue()", "code_tokens": "def _gzip ( self , response ) : bytesio = six . BytesIO ( ) with gzip . GzipFile ( fileobj = bytesio , mode = 'w' ) as gz : gz . write ( response ) return bytesio . getvalue ( )", "docstring_tokens": "Apply gzip compression to a response .", "label": 0}, {"idx": "cosqa-train-9642", "doc": "python replace tabs by spaces in string", "code": "def replace_tab_indent(s, replace=\"    \"):\n    \"\"\"\n    :param str s: string with tabs\n    :param str replace: e.g. 4 spaces\n    :rtype: str\n    \"\"\"\n    prefix = get_indent_prefix(s)\n    return prefix.replace(\"\\t\", replace) + s[len(prefix):]", "code_tokens": "def replace_tab_indent ( s , replace = \"    \" ) : prefix = get_indent_prefix ( s ) return prefix . replace ( \"\\t\" , replace ) + s [ len ( prefix ) : ]", "docstring_tokens": ": param str s : string with tabs : param str replace : e . g . 4 spaces : rtype : str", "label": 1}, {"idx": "cosqa-train-9643", "doc": "how to parse string to date fromat in python", "code": "def convert_time_string(date_str):\n    \"\"\" Change a date string from the format 2018-08-15T23:55:17 into a datetime object \"\"\"\n    dt, _, _ = date_str.partition(\".\")\n    dt = datetime.strptime(dt, \"%Y-%m-%dT%H:%M:%S\")\n    return dt", "code_tokens": "def convert_time_string ( date_str ) : dt , _ , _ = date_str . partition ( \".\" ) dt = datetime . strptime ( dt , \"%Y-%m-%dT%H:%M:%S\" ) return dt", "docstring_tokens": "Change a date string from the format 2018 - 08 - 15T23 : 55 : 17 into a datetime object", "label": 1}, {"idx": "cosqa-train-9644", "doc": "python request input with default value", "code": "def get(key, default=None):\n    \"\"\" return the key from the request\n    \"\"\"\n    data = get_form() or get_query_string()\n    return data.get(key, default)", "code_tokens": "def get ( key , default = None ) : data = get_form ( ) or get_query_string ( ) return data . get ( key , default )", "docstring_tokens": "return the key from the request", "label": 0}, {"idx": "cosqa-train-9645", "doc": "how to pass a date format in python variable", "code": "def stringToDate(fmt=\"%Y-%m-%d\"):\n    \"\"\"returns a function to convert a string to a datetime.date instance\n    using the formatting string fmt as in time.strftime\"\"\"\n    import time\n    import datetime\n    def conv_func(s):\n        return datetime.date(*time.strptime(s,fmt)[:3])\n    return conv_func", "code_tokens": "def stringToDate ( fmt = \"%Y-%m-%d\" ) : import time import datetime def conv_func ( s ) : return datetime . date ( * time . strptime ( s , fmt ) [ : 3 ] ) return conv_func", "docstring_tokens": "returns a function to convert a string to a datetime . date instance using the formatting string fmt as in time . strftime", "label": 1}, {"idx": "cosqa-train-9646", "doc": "python request session get url", "code": "def _get_url(url):\n    \"\"\"Retrieve requested URL\"\"\"\n    try:\n        data = HTTP_SESSION.get(url, stream=True)\n        data.raise_for_status()\n    except requests.exceptions.RequestException as exc:\n        raise FetcherException(exc)\n\n    return data", "code_tokens": "def _get_url ( url ) : try : data = HTTP_SESSION . get ( url , stream = True ) data . raise_for_status ( ) except requests . exceptions . RequestException as exc : raise FetcherException ( exc ) return data", "docstring_tokens": "Retrieve requested URL", "label": 1}, {"idx": "cosqa-train-9647", "doc": "how to pass javascript value to python", "code": "def eval_script(self, expr):\n    \"\"\" Evaluates a piece of Javascript in the context of the current page and\n    returns its value. \"\"\"\n    ret = self.conn.issue_command(\"Evaluate\", expr)\n    return json.loads(\"[%s]\" % ret)[0]", "code_tokens": "def eval_script ( self , expr ) : ret = self . conn . issue_command ( \"Evaluate\" , expr ) return json . loads ( \"[%s]\" % ret ) [ 0 ]", "docstring_tokens": "Evaluates a piece of Javascript in the context of the current page and returns its value .", "label": 1}, {"idx": "cosqa-train-9648", "doc": "python requests add basic auth", "code": "def set_basic_auth(self, username, password):\n        \"\"\"\n        Set authenatication.\n        \"\"\"\n        from requests.auth import HTTPBasicAuth\n        self.auth = HTTPBasicAuth(username, password)\n        return self", "code_tokens": "def set_basic_auth ( self , username , password ) : from requests . auth import HTTPBasicAuth self . auth = HTTPBasicAuth ( username , password ) return self", "docstring_tokens": "Set authenatication .", "label": 1}, {"idx": "cosqa-train-9649", "doc": "how to pass json in body in http post request from python", "code": "def set_json_item(key, value):\n    \"\"\" manipulate json data on the fly\n    \"\"\"\n    data = get_json()\n    data[key] = value\n\n    request = get_request()\n    request[\"BODY\"] = json.dumps(data)", "code_tokens": "def set_json_item ( key , value ) : data = get_json ( ) data [ key ] = value request = get_request ( ) request [ \"BODY\" ] = json . dumps ( data )", "docstring_tokens": "manipulate json data on the fly", "label": 1}, {"idx": "cosqa-train-9650", "doc": "python requests browser language accept en", "code": "def localeselector():\n    \"\"\"Default locale selector used in abilian applications.\"\"\"\n    # if a user is logged in, use the locale from the user settings\n    user = getattr(g, \"user\", None)\n    if user is not None:\n        locale = getattr(user, \"locale\", None)\n        if locale:\n            return locale\n\n    # Otherwise, try to guess the language from the user accept header the browser\n    # transmits.  By default we support en/fr. The best match wins.\n    return request.accept_languages.best_match(\n        current_app.config[\"BABEL_ACCEPT_LANGUAGES\"]\n    )", "code_tokens": "def localeselector ( ) : # if a user is logged in, use the locale from the user settings user = getattr ( g , \"user\" , None ) if user is not None : locale = getattr ( user , \"locale\" , None ) if locale : return locale # Otherwise, try to guess the language from the user accept header the browser # transmits.  By default we support en/fr. The best match wins. return request . accept_languages . best_match ( current_app . config [ \"BABEL_ACCEPT_LANGUAGES\" ] )", "docstring_tokens": "Default locale selector used in abilian applications .", "label": 0}, {"idx": "cosqa-train-9651", "doc": "how to pass response as xml type in python", "code": "def xml(cls, res, *args, **kwargs):\n        \"\"\"Parses XML from a response.\"\"\"\n        return parse_xml(res.text, *args, **kwargs)", "code_tokens": "def xml ( cls , res , * args , * * kwargs ) : return parse_xml ( res . text , * args , * * kwargs )", "docstring_tokens": "Parses XML from a response .", "label": 0}, {"idx": "cosqa-train-9652", "doc": "python requests consume paginated api", "code": "def _iter_response(self, url, params=None):\n        \"\"\"Return an enumerable that iterates through a multi-page API request\"\"\"\n        if params is None:\n            params = {}\n        params['page_number'] = 1\n\n        # Last page lists itself as next page\n        while True:\n            response = self._request(url, params)\n\n            for item in response['result_data']:\n                yield item\n\n            # Last page lists itself as next page\n            if response['service_meta']['next_page_number'] == params['page_number']:\n                break\n\n            params['page_number'] += 1", "code_tokens": "def _iter_response ( self , url , params = None ) : if params is None : params = { } params [ 'page_number' ] = 1 # Last page lists itself as next page while True : response = self . _request ( url , params ) for item in response [ 'result_data' ] : yield item # Last page lists itself as next page if response [ 'service_meta' ] [ 'next_page_number' ] == params [ 'page_number' ] : break params [ 'page_number' ] += 1", "docstring_tokens": "Return an enumerable that iterates through a multi - page API request", "label": 0}, {"idx": "cosqa-train-9653", "doc": "how to pass sys argv to another function in python", "code": "def aug_sysargv(cmdstr):\n    \"\"\" DEBUG FUNC modify argv to look like you ran a command \"\"\"\n    import shlex\n    argv = shlex.split(cmdstr)\n    sys.argv.extend(argv)", "code_tokens": "def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )", "docstring_tokens": "DEBUG FUNC modify argv to look like you ran a command", "label": 1}, {"idx": "cosqa-train-9654", "doc": "python requests dump session cookies", "code": "def save_session_to_file(self, sessionfile):\n        \"\"\"Not meant to be used directly, use :meth:`Instaloader.save_session_to_file`.\"\"\"\n        pickle.dump(requests.utils.dict_from_cookiejar(self._session.cookies), sessionfile)", "code_tokens": "def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )", "docstring_tokens": "Not meant to be used directly use : meth : Instaloader . save_session_to_file .", "label": 1}, {"idx": "cosqa-train-9655", "doc": "how to pick out vocab of a file python", "code": "def load_from_file(cls, filename_prefix):\n    \"\"\"Extracts list of subwords from file.\"\"\"\n    filename = cls._filename(filename_prefix)\n    lines, _ = cls._read_lines_from_file(filename)\n    # Strip wrapping single quotes\n    vocab_list = [line[1:-1] for line in lines]\n    return cls(vocab_list=vocab_list)", "code_tokens": "def load_from_file ( cls , filename_prefix ) : filename = cls . _filename ( filename_prefix ) lines , _ = cls . _read_lines_from_file ( filename ) # Strip wrapping single quotes vocab_list = [ line [ 1 : - 1 ] for line in lines ] return cls ( vocab_list = vocab_list )", "docstring_tokens": "Extracts list of subwords from file .", "label": 0}, {"idx": "cosqa-train-9656", "doc": "python requests failing after a couple of times", "code": "def _wait_for_response(self):\n\t\t\"\"\"\n\t\tWait until the user accepted or rejected the request\n\t\t\"\"\"\n\t\twhile not self.server.response_code:\n\t\t\ttime.sleep(2)\n\t\ttime.sleep(5)\n\t\tself.server.shutdown()", "code_tokens": "def _wait_for_response ( self ) : while not self . server . response_code : time . sleep ( 2 ) time . sleep ( 5 ) self . server . shutdown ( )", "docstring_tokens": "Wait until the user accepted or rejected the request", "label": 1}, {"idx": "cosqa-train-9657", "doc": "how to place figures into one figure after figure is made python", "code": "def plot_and_save(self, **kwargs):\n        \"\"\"Used when the plot method defined does not create a figure nor calls save_plot\n        Then the plot method has to use self.fig\"\"\"\n        self.fig = pyplot.figure()\n        self.plot()\n        self.axes = pyplot.gca()\n        self.save_plot(self.fig, self.axes, **kwargs)\n        pyplot.close(self.fig)", "code_tokens": "def plot_and_save ( self , * * kwargs ) : self . fig = pyplot . figure ( ) self . plot ( ) self . axes = pyplot . gca ( ) self . save_plot ( self . fig , self . axes , * * kwargs ) pyplot . close ( self . fig )", "docstring_tokens": "Used when the plot method defined does not create a figure nor calls save_plot Then the plot method has to use self . fig", "label": 1}, {"idx": "cosqa-train-9658", "doc": "python requests logging not work", "code": "def process_request(self, request, response):\n        \"\"\"Logs the basic endpoint requested\"\"\"\n        self.logger.info('Requested: {0} {1} {2}'.format(request.method, request.relative_uri, request.content_type))", "code_tokens": "def process_request ( self , request , response ) : self . logger . info ( 'Requested: {0} {1} {2}' . format ( request . method , request . relative_uri , request . content_type ) )", "docstring_tokens": "Logs the basic endpoint requested", "label": 1}, {"idx": "cosqa-train-9659", "doc": "python requests set maximum retries", "code": "def request(method, url, **kwargs):\n    \"\"\"\n    Wrapper for the `requests.request()` function.\n    It accepts the same arguments as the original, plus an optional `retries`\n    that overrides the default retry mechanism.\n    \"\"\"\n    retries = kwargs.pop('retries', None)\n    with Session(retries=retries) as session:\n        return session.request(method=method, url=url, **kwargs)", "code_tokens": "def request ( method , url , * * kwargs ) : retries = kwargs . pop ( 'retries' , None ) with Session ( retries = retries ) as session : return session . request ( method = method , url = url , * * kwargs )", "docstring_tokens": "Wrapper for the requests . request () function . It accepts the same arguments as the original plus an optional retries that overrides the default retry mechanism .", "label": 1}, {"idx": "cosqa-train-9660", "doc": "how to prevent a file from modifying python", "code": "def make_file_readable (filename):\n    \"\"\"Make file user readable if it is not a link.\"\"\"\n    if not os.path.islink(filename):\n        util.set_mode(filename, stat.S_IRUSR)", "code_tokens": "def make_file_readable ( filename ) : if not os . path . islink ( filename ) : util . set_mode ( filename , stat . S_IRUSR )", "docstring_tokens": "Make file user readable if it is not a link .", "label": 1}, {"idx": "cosqa-train-9661", "doc": "python requestscookiejar retrive cookie", "code": "def parse_cookies(self, req, name, field):\n        \"\"\"Pull the value from the cookiejar.\"\"\"\n        return core.get_value(req.COOKIES, name, field)", "code_tokens": "def parse_cookies ( self , req , name , field ) : return core . get_value ( req . COOKIES , name , field )", "docstring_tokens": "Pull the value from the cookiejar .", "label": 0}, {"idx": "cosqa-train-9662", "doc": "how to print a prompt and read stdin python", "code": "def read_stdin():\n    \"\"\" Read text from stdin, and print a helpful message for ttys. \"\"\"\n    if sys.stdin.isatty() and sys.stdout.isatty():\n        print('\\nReading from stdin until end of file (Ctrl + D)...')\n\n    return sys.stdin.read()", "code_tokens": "def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )", "docstring_tokens": "Read text from stdin and print a helpful message for ttys .", "label": 1}, {"idx": "cosqa-train-9663", "doc": "python restful how to process errors", "code": "def handle_errors(resp):\n    \"\"\"raise a descriptive exception on a \"bad request\" response\"\"\"\n    if resp.status_code == 400:\n        raise ApiException(json.loads(resp.content).get('message'))\n    return resp", "code_tokens": "def handle_errors ( resp ) : if resp . status_code == 400 : raise ApiException ( json . loads ( resp . content ) . get ( 'message' ) ) return resp", "docstring_tokens": "raise a descriptive exception on a bad request response", "label": 1}, {"idx": "cosqa-train-9664", "doc": "how to print enum key if you know the value in python", "code": "def _dump_enum(self, e, top=''):\n        \"\"\"Dump single enum type.\n        \n        Keyword arguments:\n        top -- top namespace\n        \"\"\"\n        self._print()\n        self._print('enum {} {{'.format(e.name))\n        self.defines.append('{}.{}'.format(top,e.name))\n        \n        self.tabs+=1\n        for v in e.value:\n            self._print('{} = {};'.format(v.name, v.number))\n        self.tabs-=1\n        self._print('}')", "code_tokens": "def _dump_enum ( self , e , top = '' ) : self . _print ( ) self . _print ( 'enum {} {{' . format ( e . name ) ) self . defines . append ( '{}.{}' . format ( top , e . name ) ) self . tabs += 1 for v in e . value : self . _print ( '{} = {};' . format ( v . name , v . number ) ) self . tabs -= 1 self . _print ( '}' )", "docstring_tokens": "Dump single enum type . Keyword arguments : top -- top namespace", "label": 1}, {"idx": "cosqa-train-9665", "doc": "python retrieve filter from log handler", "code": "async def handle(self, record):\n        \"\"\"\n        Call the handlers for the specified record.\n\n        This method is used for unpickled records received from a socket, as\n        well as those created locally. Logger-level filtering is applied.\n        \"\"\"\n        if (not self.disabled) and self.filter(record):\n            await self.callHandlers(record)", "code_tokens": "async def handle ( self , record ) : if ( not self . disabled ) and self . filter ( record ) : await self . callHandlers ( record )", "docstring_tokens": "Call the handlers for the specified record .", "label": 1}, {"idx": "cosqa-train-9666", "doc": "how to print multiple lists as a table python", "code": "def __print_table(table):\n        \"\"\"Print a list in tabular format\n        Based on https://stackoverflow.com/a/8356620\"\"\"\n\n        col_width = [max(len(x) for x in col) for col in zip(*table)]\n        print(\"| \" + \" | \".join(\"{:{}}\".format(x, col_width[i])\n                                for i, x in enumerate(table[0])) + \" |\")\n        print(\"| \" + \" | \".join(\"{:{}}\".format('-' * col_width[i], col_width[i])\n                                for i, x in enumerate(table[0])) + \" |\")\n        for line in table[1:]:\n            print(\"| \" + \" | \".join(\"{:{}}\".format(x, col_width[i])\n                                    for i, x in enumerate(line)) + \" |\")", "code_tokens": "def __print_table ( table ) : col_width = [ max ( len ( x ) for x in col ) for col in zip ( * table ) ] print ( \"| \" + \" | \" . join ( \"{:{}}\" . format ( x , col_width [ i ] ) for i , x in enumerate ( table [ 0 ] ) ) + \" |\" ) print ( \"| \" + \" | \" . join ( \"{:{}}\" . format ( '-' * col_width [ i ] , col_width [ i ] ) for i , x in enumerate ( table [ 0 ] ) ) + \" |\" ) for line in table [ 1 : ] : print ( \"| \" + \" | \" . join ( \"{:{}}\" . format ( x , col_width [ i ] ) for i , x in enumerate ( line ) ) + \" |\" )", "docstring_tokens": "Print a list in tabular format Based on https : // stackoverflow . com / a / 8356620", "label": 1}, {"idx": "cosqa-train-9667", "doc": "python return all indices given a value", "code": "def index(m, val):\n    \"\"\"\n    Return the indices of all the ``val`` in ``m``\n    \"\"\"\n    mm = np.array(m)\n    idx_tuple = np.where(mm == val)\n    idx = idx_tuple[0].tolist()\n\n    return idx", "code_tokens": "def index ( m , val ) : mm = np . array ( m ) idx_tuple = np . where ( mm == val ) idx = idx_tuple [ 0 ] . tolist ( ) return idx", "docstring_tokens": "Return the indices of all the val in m", "label": 0}, {"idx": "cosqa-train-9668", "doc": "how to print out data type of a column python", "code": "def _get_column_types(self, data):\n        \"\"\"Get a list of the data types for each column in *data*.\"\"\"\n        columns = list(zip_longest(*data))\n        return [self._get_column_type(column) for column in columns]", "code_tokens": "def _get_column_types ( self , data ) : columns = list ( zip_longest ( * data ) ) return [ self . _get_column_type ( column ) for column in columns ]", "docstring_tokens": "Get a list of the data types for each column in * data * .", "label": 0}, {"idx": "cosqa-train-9669", "doc": "python return all the index of a sub string", "code": "def get_substring_idxs(substr, string):\n    \"\"\"\n    Return a list of indexes of substr. If substr not found, list is\n    empty.\n\n    Arguments:\n        substr (str): Substring to match.\n        string (str): String to match in.\n\n    Returns:\n        list of int: Start indices of substr.\n    \"\"\"\n    return [match.start() for match in re.finditer(substr, string)]", "code_tokens": "def get_substring_idxs ( substr , string ) : return [ match . start ( ) for match in re . finditer ( substr , string ) ]", "docstring_tokens": "Return a list of indexes of substr . If substr not found list is empty .", "label": 1}, {"idx": "cosqa-train-9670", "doc": "how to print out the type of a vraible in python", "code": "def typename(obj):\n    \"\"\"Returns the type of obj as a string. More descriptive and specific than\n    type(obj), and safe for any object, unlike __class__.\"\"\"\n    if hasattr(obj, '__class__'):\n        return getattr(obj, '__class__').__name__\n    else:\n        return type(obj).__name__", "code_tokens": "def typename ( obj ) : if hasattr ( obj , '__class__' ) : return getattr ( obj , '__class__' ) . __name__ else : return type ( obj ) . __name__", "docstring_tokens": "Returns the type of obj as a string . More descriptive and specific than type ( obj ) and safe for any object unlike __class__ .", "label": 0}, {"idx": "cosqa-train-9671", "doc": "python return results from external command", "code": "def call_out(command):\n  \"\"\"\n  Run the given command (with shell=False) and return a tuple of\n  (int returncode, str output). Strip the output of enclosing whitespace.\n  \"\"\"\n  # start external command process\n  p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n  # get outputs\n  out, _ = p.communicate()\n\n  return p.returncode, out.strip()", "code_tokens": "def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "docstring_tokens": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace .", "label": 0}, {"idx": "cosqa-train-9672", "doc": "how to print recursive depth python", "code": "def print_item_with_children(ac, classes, level):\n    \"\"\" Print the given item and all children items \"\"\"\n    print_row(ac.id, ac.name, f\"{ac.allocation:,.2f}\", level)\n    print_children_recursively(classes, ac, level + 1)", "code_tokens": "def print_item_with_children ( ac , classes , level ) : print_row ( ac . id , ac . name , f\"{ac.allocation:,.2f}\" , level ) print_children_recursively ( classes , ac , level + 1 )", "docstring_tokens": "Print the given item and all children items", "label": 0}, {"idx": "cosqa-train-9673", "doc": "python return the two closest values of an array", "code": "def closest(xarr, val):\n    \"\"\" Return the index of the closest in xarr to value val \"\"\"\n    idx_closest = np.argmin(np.abs(np.array(xarr) - val))\n    return idx_closest", "code_tokens": "def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest", "docstring_tokens": "Return the index of the closest in xarr to value val", "label": 1}, {"idx": "cosqa-train-9674", "doc": "how to print red error in python", "code": "def print_failure_message(message):\n    \"\"\"Print a message indicating failure in red color to STDERR.\n\n    :param message: the message to print\n    :type message: :class:`str`\n    \"\"\"\n    try:\n        import colorama\n\n        print(colorama.Fore.RED + message + colorama.Fore.RESET,\n              file=sys.stderr)\n    except ImportError:\n        print(message, file=sys.stderr)", "code_tokens": "def print_failure_message ( message ) : try : import colorama print ( colorama . Fore . RED + message + colorama . Fore . RESET , file = sys . stderr ) except ImportError : print ( message , file = sys . stderr )", "docstring_tokens": "Print a message indicating failure in red color to STDERR .", "label": 1}, {"idx": "cosqa-train-9675", "doc": "python return vector of max indexs", "code": "def MultiArgMax(x):\n  \"\"\"\n  Get tuple (actually a generator) of indices where the max value of\n  array x occurs. Requires that x have a max() method, as x.max()\n  (in the case of NumPy) is much faster than max(x).\n  For a simpler, faster argmax when there is only a single maximum entry,\n  or when knowing only the first index where the maximum occurs,\n  call argmax() on a NumPy array.\n\n  :param x: Any sequence that has a max() method.\n  :returns: Generator with the indices where the max value occurs.\n  \"\"\"\n  m = x.max()\n  return (i for i, v in enumerate(x) if v == m)", "code_tokens": "def MultiArgMax ( x ) : m = x . max ( ) return ( i for i , v in enumerate ( x ) if v == m )", "docstring_tokens": "Get tuple ( actually a generator ) of indices where the max value of array x occurs . Requires that x have a max () method as x . max () ( in the case of NumPy ) is much faster than max ( x ) . For a simpler faster argmax when there is only a single maximum entry or when knowing only the first index where the maximum occurs call argmax () on a NumPy array .", "label": 1}, {"idx": "cosqa-train-9676", "doc": "how to put a button in python treeview", "code": "def register_view(self, view):\n        \"\"\"Register callbacks for button press events and selection changed\"\"\"\n        super(ListViewController, self).register_view(view)\n        self.tree_view.connect('button_press_event', self.mouse_click)", "code_tokens": "def register_view ( self , view ) : super ( ListViewController , self ) . register_view ( view ) self . tree_view . connect ( 'button_press_event' , self . mouse_click )", "docstring_tokens": "Register callbacks for button press events and selection changed", "label": 0}, {"idx": "cosqa-train-9677", "doc": "python rewind to start of file", "code": "def rewindbody(self):\n        \"\"\"Rewind the file to the start of the body (if seekable).\"\"\"\n        if not self.seekable:\n            raise IOError, \"unseekable file\"\n        self.fp.seek(self.startofbody)", "code_tokens": "def rewindbody ( self ) : if not self . seekable : raise IOError , \"unseekable file\" self . fp . seek ( self . startofbody )", "docstring_tokens": "Rewind the file to the start of the body ( if seekable ) .", "label": 0}, {"idx": "cosqa-train-9678", "doc": "how to put a string in a yaml file python", "code": "def generate_yaml_file(filename, contents):\n    \"\"\"Creates a yaml file with the given content.\"\"\"\n    with open(filename, 'w') as file:\n        file.write(yaml.dump(contents, default_flow_style=False))", "code_tokens": "def generate_yaml_file ( filename , contents ) : with open ( filename , 'w' ) as file : file . write ( yaml . dump ( contents , default_flow_style = False ) )", "docstring_tokens": "Creates a yaml file with the given content .", "label": 1}, {"idx": "cosqa-train-9679", "doc": "python right trim string", "code": "def _trim(self, somestr):\n        \"\"\" Trim left-right given string \"\"\"\n        tmp = RE_LSPACES.sub(\"\", somestr)\n        tmp = RE_TSPACES.sub(\"\", tmp)\n        return str(tmp)", "code_tokens": "def _trim ( self , somestr ) : tmp = RE_LSPACES . sub ( \"\" , somestr ) tmp = RE_TSPACES . sub ( \"\" , tmp ) return str ( tmp )", "docstring_tokens": "Trim left - right given string", "label": 1}, {"idx": "cosqa-train-9680", "doc": "how to put useragent in webbrowser python", "code": "def copy_user_agent_from_driver(self):\n        \"\"\" Updates requests' session user-agent with the driver's user agent\n\n        This method will start the browser process if its not already running.\n        \"\"\"\n        selenium_user_agent = self.driver.execute_script(\"return navigator.userAgent;\")\n        self.headers.update({\"user-agent\": selenium_user_agent})", "code_tokens": "def copy_user_agent_from_driver ( self ) : selenium_user_agent = self . driver . execute_script ( \"return navigator.userAgent;\" ) self . headers . update ( { \"user-agent\" : selenium_user_agent } )", "docstring_tokens": "Updates requests session user - agent with the driver s user agent", "label": 1}, {"idx": "cosqa-train-9681", "doc": "python rolling average by window interval not data points", "code": "def movingaverage(arr, window):\n    \"\"\"\n    Calculates the moving average (\"rolling mean\") of an array\n    of a certain window size.\n    \"\"\"\n    m = np.ones(int(window)) / int(window)\n    return scipy.ndimage.convolve1d(arr, m, axis=0, mode='reflect')", "code_tokens": "def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )", "docstring_tokens": "Calculates the moving average ( rolling mean ) of an array of a certain window size .", "label": 1}, {"idx": "cosqa-train-9682", "doc": "how to raise exponents in python", "code": "def raise_(exception=ABSENT, *args, **kwargs):\n    \"\"\"Raise (or re-raises) an exception.\n\n    :param exception: Exception object to raise, or an exception class.\n                      In the latter case, remaining arguments are passed\n                      to the exception's constructor.\n                      If omitted, the currently handled exception is re-raised.\n    \"\"\"\n    if exception is ABSENT:\n        raise\n    else:\n        if inspect.isclass(exception):\n            raise exception(*args, **kwargs)\n        else:\n            if args or kwargs:\n                raise TypeError(\"can't pass arguments along with \"\n                                \"exception object to raise_()\")\n            raise exception", "code_tokens": "def raise_ ( exception = ABSENT , * args , * * kwargs ) : if exception is ABSENT : raise else : if inspect . isclass ( exception ) : raise exception ( * args , * * kwargs ) else : if args or kwargs : raise TypeError ( \"can't pass arguments along with \" \"exception object to raise_()\" ) raise exception", "docstring_tokens": "Raise ( or re - raises ) an exception .", "label": 1}, {"idx": "cosqa-train-9683", "doc": "python rotate an array into a circle", "code": "def rotateImage(image, angle):\n    \"\"\"\n        rotates a 2d array to a multiple of 90 deg.\n        0 = default\n        1 = 90 deg. cw\n        2 = 180 deg.\n        3 = 90 deg. ccw\n    \"\"\"\n    image = [list(row) for row in image]\n\n    for n in range(angle % 4):\n        image = list(zip(*image[::-1]))\n\n    return image", "code_tokens": "def rotateImage ( image , angle ) : image = [ list ( row ) for row in image ] for n in range ( angle % 4 ) : image = list ( zip ( * image [ : : - 1 ] ) ) return image", "docstring_tokens": "rotates a 2d array to a multiple of 90 deg . 0 = default 1 = 90 deg . cw 2 = 180 deg . 3 = 90 deg . ccw", "label": 1}, {"idx": "cosqa-train-9684", "doc": "how to randomly select elemts of a list without repeating them in python", "code": "def rand_elem(seq, n=None):\n    \"\"\"returns a random element from seq n times. If n is None, it continues indefinitly\"\"\"\n    return map(random.choice, repeat(seq, n) if n is not None else repeat(seq))", "code_tokens": "def rand_elem ( seq , n = None ) : return map ( random . choice , repeat ( seq , n ) if n is not None else repeat ( seq ) )", "docstring_tokens": "returns a random element from seq n times . If n is None it continues indefinitly", "label": 1}, {"idx": "cosqa-train-9685", "doc": "python round do with precision", "code": "def round_to_float(number, precision):\n    \"\"\"Round a float to a precision\"\"\"\n    rounded = Decimal(str(floor((number + precision / 2) // precision))\n                      ) * Decimal(str(precision))\n    return float(rounded)", "code_tokens": "def round_to_float ( number , precision ) : rounded = Decimal ( str ( floor ( ( number + precision / 2 ) // precision ) ) ) * Decimal ( str ( precision ) ) return float ( rounded )", "docstring_tokens": "Round a float to a precision", "label": 0}, {"idx": "cosqa-train-9686", "doc": "python round to decimal places", "code": "def round_to_float(number, precision):\n    \"\"\"Round a float to a precision\"\"\"\n    rounded = Decimal(str(floor((number + precision / 2) // precision))\n                      ) * Decimal(str(precision))\n    return float(rounded)", "code_tokens": "def round_to_float ( number , precision ) : rounded = Decimal ( str ( floor ( ( number + precision / 2 ) // precision ) ) ) * Decimal ( str ( precision ) ) return float ( rounded )", "docstring_tokens": "Round a float to a precision", "label": 1}, {"idx": "cosqa-train-9687", "doc": "python round to significant figures", "code": "def round_figures(x, n):\n    \"\"\"Returns x rounded to n significant figures.\"\"\"\n    return round(x, int(n - math.ceil(math.log10(abs(x)))))", "code_tokens": "def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )", "docstring_tokens": "Returns x rounded to n significant figures .", "label": 1}, {"idx": "cosqa-train-9688", "doc": "how to read a file in as integers only in python", "code": "def _fast_read(self, infile):\n        \"\"\"Function for fast reading from sensor files.\"\"\"\n        infile.seek(0)\n        return(int(infile.read().decode().strip()))", "code_tokens": "def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )", "docstring_tokens": "Function for fast reading from sensor files .", "label": 0}, {"idx": "cosqa-train-9689", "doc": "python run code before exit", "code": "def call_and_exit(self, cmd, shell=True):\n        \"\"\"Run the *cmd* and exit with the proper exit code.\"\"\"\n        sys.exit(subprocess.call(cmd, shell=shell))", "code_tokens": "def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )", "docstring_tokens": "Run the * cmd * and exit with the proper exit code .", "label": 0}, {"idx": "cosqa-train-9690", "doc": "how to read a file in python as numpy ndarray", "code": "def read_numpy(fd, byte_order, dtype, count):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    return numpy.fromfile(fd, byte_order+dtype[-1], count)", "code_tokens": "def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 0}, {"idx": "cosqa-train-9691", "doc": "python run github rest api create pull request", "code": "def get_pull_request(project, num, auth=False):\n    \"\"\"get pull request info  by number\n    \"\"\"\n    url = \"https://api.github.com/repos/{project}/pulls/{num}\".format(project=project, num=num)\n    if auth:\n        header = make_auth_header()\n    else:\n        header = None\n    response = requests.get(url, headers=header)\n    response.raise_for_status()\n    return json.loads(response.text, object_hook=Obj)", "code_tokens": "def get_pull_request ( project , num , auth = False ) : url = \"https://api.github.com/repos/{project}/pulls/{num}\" . format ( project = project , num = num ) if auth : header = make_auth_header ( ) else : header = None response = requests . get ( url , headers = header ) response . raise_for_status ( ) return json . loads ( response . text , object_hook = Obj )", "docstring_tokens": "get pull request info by number", "label": 1}, {"idx": "cosqa-train-9692", "doc": "how to read a pickle file in python", "code": "def unpickle_file(picklefile, **kwargs):\n    \"\"\"Helper function to unpickle data from `picklefile`.\"\"\"\n    with open(picklefile, 'rb') as f:\n        return pickle.load(f, **kwargs)", "code_tokens": "def unpickle_file ( picklefile , * * kwargs ) : with open ( picklefile , 'rb' ) as f : return pickle . load ( f , * * kwargs )", "docstring_tokens": "Helper function to unpickle data from picklefile .", "label": 0}, {"idx": "cosqa-train-9693", "doc": "python run individual unit test", "code": "def test():  # pragma: no cover\n    \"\"\"Execute the unit tests on an installed copy of unyt.\n\n    Note that this function requires pytest to run. If pytest is not\n    installed this function will raise ImportError.\n    \"\"\"\n    import pytest\n    import os\n\n    pytest.main([os.path.dirname(os.path.abspath(__file__))])", "code_tokens": "def test ( ) : # pragma: no cover import pytest import os pytest . main ( [ os . path . dirname ( os . path . abspath ( __file__ ) ) ] )", "docstring_tokens": "Execute the unit tests on an installed copy of unyt .", "label": 0}, {"idx": "cosqa-train-9694", "doc": "how to read an html as a plain text in python", "code": "def html_to_text(content):\n    \"\"\" Converts html content to plain text \"\"\"\n    text = None\n    h2t = html2text.HTML2Text()\n    h2t.ignore_links = False\n    text = h2t.handle(content)\n    return text", "code_tokens": "def html_to_text ( content ) : text = None h2t = html2text . HTML2Text ( ) h2t . ignore_links = False text = h2t . handle ( content ) return text", "docstring_tokens": "Converts html content to plain text", "label": 0}, {"idx": "cosqa-train-9695", "doc": "python s3 get objecs based using prefix", "code": "def list_blobs(self, prefix=''):\n    \"\"\"Lists names of all blobs by their prefix.\"\"\"\n    return [b.name for b in self.bucket.list_blobs(prefix=prefix)]", "code_tokens": "def list_blobs ( self , prefix = '' ) : return [ b . name for b in self . bucket . list_blobs ( prefix = prefix ) ]", "docstring_tokens": "Lists names of all blobs by their prefix .", "label": 1}, {"idx": "cosqa-train-9696", "doc": "how to read an image file into python using its path", "code": "def load_image(fname):\n    \"\"\" read an image from file - PIL doesnt close nicely \"\"\"\n    with open(fname, \"rb\") as f:\n        i = Image.open(fname)\n        #i.load()\n        return i", "code_tokens": "def load_image ( fname ) : with open ( fname , \"rb\" ) as f : i = Image . open ( fname ) #i.load() return i", "docstring_tokens": "read an image from file - PIL doesnt close nicely", "label": 1}, {"idx": "cosqa-train-9697", "doc": "python sanic change all object id to string", "code": "def generate_id(self, obj):\n        \"\"\"Generate unique document id for ElasticSearch.\"\"\"\n        object_type = type(obj).__name__.lower()\n        return '{}_{}'.format(object_type, self.get_object_id(obj))", "code_tokens": "def generate_id ( self , obj ) : object_type = type ( obj ) . __name__ . lower ( ) return '{}_{}' . format ( object_type , self . get_object_id ( obj ) )", "docstring_tokens": "Generate unique document id for ElasticSearch .", "label": 1}, {"idx": "cosqa-train-9698", "doc": "how to read contents of a numpy file with python", "code": "def read_numpy(fd, byte_order, dtype, count):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    return numpy.fromfile(fd, byte_order+dtype[-1], count)", "code_tokens": "def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 1}, {"idx": "cosqa-train-9699", "doc": "python save a file as save as", "code": "def pickle_save(thing,fname):\n    \"\"\"save something to a pickle file\"\"\"\n    pickle.dump(thing, open(fname,\"wb\"),pickle.HIGHEST_PROTOCOL)\n    return thing", "code_tokens": "def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , \"wb\" ) , pickle . HIGHEST_PROTOCOL ) return thing", "docstring_tokens": "save something to a pickle file", "label": 1}, {"idx": "cosqa-train-9700", "doc": "how to read index of specific line in python", "code": "def get_lines(handle, line):\n    \"\"\"\n    Get zero-indexed line from an open file-like.\n    \"\"\"\n    for i, l in enumerate(handle):\n        if i == line:\n            return l", "code_tokens": "def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l", "docstring_tokens": "Get zero - indexed line from an open file - like .", "label": 1}, {"idx": "cosqa-train-9701", "doc": "python save animation list object has no attribute set animated", "code": "def save(self, *args, **kwargs):\n        \"\"\"Saves an animation\n\n        A wrapper around :meth:`matplotlib.animation.Animation.save`\n        \"\"\"\n        self.timeline.index -= 1  # required for proper starting point for save\n        self.animation.save(*args, **kwargs)", "code_tokens": "def save ( self , * args , * * kwargs ) : self . timeline . index -= 1 # required for proper starting point for save self . animation . save ( * args , * * kwargs )", "docstring_tokens": "Saves an animation", "label": 1}, {"idx": "cosqa-train-9702", "doc": "how to read numbers in a list as integers in python", "code": "def lengths_offsets(value):\n    \"\"\"Split the given comma separated value to multiple integer values. \"\"\"\n    values = []\n    for item in value.split(','):\n        item = int(item)\n        values.append(item)\n    return values", "code_tokens": "def lengths_offsets ( value ) : values = [ ] for item in value . split ( ',' ) : item = int ( item ) values . append ( item ) return values", "docstring_tokens": "Split the given comma separated value to multiple integer values .", "label": 1}, {"idx": "cosqa-train-9703", "doc": "python save ndarray to json", "code": "def deserialize_ndarray_npy(d):\n    \"\"\"\n    Deserializes a JSONified :obj:`numpy.ndarray` that was created using numpy's\n    :obj:`save` function.\n\n    Args:\n        d (:obj:`dict`): A dictionary representation of an :obj:`ndarray` object, created\n            using :obj:`numpy.save`.\n\n    Returns:\n        An :obj:`ndarray` object.\n    \"\"\"\n    with io.BytesIO() as f:\n        f.write(json.loads(d['npy']).encode('latin-1'))\n        f.seek(0)\n        return np.load(f)", "code_tokens": "def deserialize_ndarray_npy ( d ) : with io . BytesIO ( ) as f : f . write ( json . loads ( d [ 'npy' ] ) . encode ( 'latin-1' ) ) f . seek ( 0 ) return np . load ( f )", "docstring_tokens": "Deserializes a JSONified : obj : numpy . ndarray that was created using numpy s : obj : save function .", "label": 1}, {"idx": "cosqa-train-9704", "doc": "how to reference today's date in python", "code": "def created_today(self):\n        \"\"\"Return True if created today.\"\"\"\n        if self.datetime.date() == datetime.today().date():\n            return True\n        return False", "code_tokens": "def created_today ( self ) : if self . datetime . date ( ) == datetime . today ( ) . date ( ) : return True return False", "docstring_tokens": "Return True if created today .", "label": 1}, {"idx": "cosqa-train-9705", "doc": "python save numpy array to database", "code": "def adapt_array(arr):\n    \"\"\"\n    Adapts a Numpy array into an ARRAY string to put into the database.\n\n    Parameters\n    ----------\n    arr: array\n        The Numpy array to be adapted into an ARRAY type that can be inserted into a SQL file.\n\n    Returns\n    -------\n    ARRAY\n            The adapted array object\n\n    \"\"\"\n    out = io.BytesIO()\n    np.save(out, arr), out.seek(0)\n    return buffer(out.read())", "code_tokens": "def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) , out . seek ( 0 ) return buffer ( out . read ( ) )", "docstring_tokens": "Adapts a Numpy array into an ARRAY string to put into the database .", "label": 0}, {"idx": "cosqa-train-9706", "doc": "how to remove accent in python", "code": "def unaccentuate(s):\n    \"\"\" Replace accentuated chars in string by their non accentuated equivalent. \"\"\"\n    return \"\".join(c for c in unicodedata.normalize(\"NFKD\", s) if not unicodedata.combining(c))", "code_tokens": "def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "docstring_tokens": "Replace accentuated chars in string by their non accentuated equivalent .", "label": 1}, {"idx": "cosqa-train-9707", "doc": "python save numpy array to postgresql", "code": "def adapt_array(arr):\n    \"\"\"\n    Adapts a Numpy array into an ARRAY string to put into the database.\n\n    Parameters\n    ----------\n    arr: array\n        The Numpy array to be adapted into an ARRAY type that can be inserted into a SQL file.\n\n    Returns\n    -------\n    ARRAY\n            The adapted array object\n\n    \"\"\"\n    out = io.BytesIO()\n    np.save(out, arr), out.seek(0)\n    return buffer(out.read())", "code_tokens": "def adapt_array ( arr ) : out = io . BytesIO ( ) np . save ( out , arr ) , out . seek ( 0 ) return buffer ( out . read ( ) )", "docstring_tokens": "Adapts a Numpy array into an ARRAY string to put into the database .", "label": 1}, {"idx": "cosqa-train-9708", "doc": "how to remove all python environment", "code": "def delete_all_eggs(self):\n        \"\"\" delete all the eggs in the directory specified \"\"\"\n        path_to_delete = os.path.join(self.egg_directory, \"lib\", \"python\")\n        if os.path.exists(path_to_delete):\n            shutil.rmtree(path_to_delete)", "code_tokens": "def delete_all_eggs ( self ) : path_to_delete = os . path . join ( self . egg_directory , \"lib\" , \"python\" ) if os . path . exists ( path_to_delete ) : shutil . rmtree ( path_to_delete )", "docstring_tokens": "delete all the eggs in the directory specified", "label": 1}, {"idx": "cosqa-train-9709", "doc": "python save this session", "code": "def save_session_to_file(self, sessionfile):\n        \"\"\"Not meant to be used directly, use :meth:`Instaloader.save_session_to_file`.\"\"\"\n        pickle.dump(requests.utils.dict_from_cookiejar(self._session.cookies), sessionfile)", "code_tokens": "def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )", "docstring_tokens": "Not meant to be used directly use : meth : Instaloader . save_session_to_file .", "label": 0}, {"idx": "cosqa-train-9710", "doc": "how to remove an instance from a list python", "code": "def pop():\n        \"\"\"Remove instance from instance list\"\"\"\n        pid = os.getpid()\n        thread = threading.current_thread()\n        Wdb._instances.pop((pid, thread))", "code_tokens": "def pop ( ) : pid = os . getpid ( ) thread = threading . current_thread ( ) Wdb . _instances . pop ( ( pid , thread ) )", "docstring_tokens": "Remove instance from instance list", "label": 0}, {"idx": "cosqa-train-9711", "doc": "python save variable into a file", "code": "def save(variable, filename):\n    \"\"\"Save variable on given path using Pickle\n    \n    Args:\n        variable: what to save\n        path (str): path of the output\n    \"\"\"\n    fileObj = open(filename, 'wb')\n    pickle.dump(variable, fileObj)\n    fileObj.close()", "code_tokens": "def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )", "docstring_tokens": "Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output", "label": 1}, {"idx": "cosqa-train-9712", "doc": "how to remove duplicated from a list in python", "code": "def unique(list):\n    \"\"\" Returns a copy of the list without duplicates.\n    \"\"\"\n    unique = []; [unique.append(x) for x in list if x not in unique]\n    return unique", "code_tokens": "def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique", "docstring_tokens": "Returns a copy of the list without duplicates .", "label": 0}, {"idx": "cosqa-train-9713", "doc": "python saving json to file", "code": "def save(self, fname):\n        \"\"\" Saves the dictionary in json format\n        :param fname: file to save to\n        \"\"\"\n        with open(fname, 'wb') as f:\n            json.dump(self, f)", "code_tokens": "def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )", "docstring_tokens": "Saves the dictionary in json format : param fname : file to save to", "label": 1}, {"idx": "cosqa-train-9714", "doc": "how to remove duplicates from a queryset in python models", "code": "def fast_distinct(self):\n        \"\"\"\n        Because standard distinct used on the all fields are very slow and works only with PostgreSQL database\n        this method provides alternative to the standard distinct method.\n        :return: qs with unique objects\n        \"\"\"\n        return self.model.objects.filter(pk__in=self.values_list('pk', flat=True))", "code_tokens": "def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )", "docstring_tokens": "Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects", "label": 0}, {"idx": "cosqa-train-9715", "doc": "python says string is nonetype", "code": "def isString(s):\n    \"\"\"Convenience method that works with all 2.x versions of Python\n    to determine whether or not something is stringlike.\"\"\"\n    try:\n        return isinstance(s, unicode) or isinstance(s, basestring)\n    except NameError:\n        return isinstance(s, str)", "code_tokens": "def isString ( s ) : try : return isinstance ( s , unicode ) or isinstance ( s , basestring ) except NameError : return isinstance ( s , str )", "docstring_tokens": "Convenience method that works with all 2 . x versions of Python to determine whether or not something is stringlike .", "label": 0}, {"idx": "cosqa-train-9716", "doc": "how to remove duplicates without changing order in python", "code": "def remove_dups(seq):\n    \"\"\"remove duplicates from a sequence, preserving order\"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "remove duplicates from a sequence preserving order", "label": 0}, {"idx": "cosqa-train-9717", "doc": "python scatter plot color by catergoral", "code": "def plot_target(target, ax):\n    \"\"\"Ajoute la target au plot\"\"\"\n    ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)", "code_tokens": "def plot_target ( target , ax ) : ax . scatter ( target [ 0 ] , target [ 1 ] , target [ 2 ] , c = \"red\" , s = 80 )", "docstring_tokens": "Ajoute la target au plot", "label": 0}, {"idx": "cosqa-train-9718", "doc": "how to remove empty elements in a list python", "code": "def unique(seq):\n    \"\"\"Return the unique elements of a collection even if those elements are\n       unhashable and unsortable, like dicts and sets\"\"\"\n    cleaned = []\n    for each in seq:\n        if each not in cleaned:\n            cleaned.append(each)\n    return cleaned", "code_tokens": "def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned", "docstring_tokens": "Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets", "label": 1}, {"idx": "cosqa-train-9719", "doc": "python script to close browser", "code": "def kill(self):\n        \"\"\"Kill the browser.\n\n        This is useful when the browser is stuck.\n        \"\"\"\n        if self.process:\n            self.process.kill()\n            self.process.wait()", "code_tokens": "def kill ( self ) : if self . process : self . process . kill ( ) self . process . wait ( )", "docstring_tokens": "Kill the browser .", "label": 1}, {"idx": "cosqa-train-9720", "doc": "how to remove json formate for python and make into dictionary", "code": "def _unjsonify(x, isattributes=False):\n    \"\"\"Convert JSON string to an ordered defaultdict.\"\"\"\n    if isattributes:\n        obj = json.loads(x)\n        return dict_class(obj)\n    return json.loads(x)", "code_tokens": "def _unjsonify ( x , isattributes = False ) : if isattributes : obj = json . loads ( x ) return dict_class ( obj ) return json . loads ( x )", "docstring_tokens": "Convert JSON string to an ordered defaultdict .", "label": 1}, {"idx": "cosqa-train-9721", "doc": "python script to delete s3 files", "code": "def delete_s3_bucket(client, resource):\n    \"\"\"Delete an S3 bucket\n\n    This function will try to delete an S3 bucket\n\n    Args:\n        client (:obj:`boto3.session.Session.client`): A boto3 client object\n        resource (:obj:`Resource`): The resource object to terminate\n\n    Returns:\n        `ActionStatus`\n    \"\"\"\n\n    if dbconfig.get('enable_delete_s3_buckets', NS_AUDITOR_REQUIRED_TAGS, False):\n        client.delete_bucket(Bucket=resource.id)\n    return ActionStatus.SUCCEED, resource.metrics()", "code_tokens": "def delete_s3_bucket ( client , resource ) : if dbconfig . get ( 'enable_delete_s3_buckets' , NS_AUDITOR_REQUIRED_TAGS , False ) : client . delete_bucket ( Bucket = resource . id ) return ActionStatus . SUCCEED , resource . metrics ( )", "docstring_tokens": "Delete an S3 bucket", "label": 0}, {"idx": "cosqa-train-9722", "doc": "python script to releasing the stdout", "code": "def safe_exit(output):\n    \"\"\"exit without breaking pipes.\"\"\"\n    try:\n        sys.stdout.write(output)\n        sys.stdout.flush()\n    except IOError:\n        pass", "code_tokens": "def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass", "docstring_tokens": "exit without breaking pipes .", "label": 1}, {"idx": "cosqa-train-9723", "doc": "how to remove repeated numbers in a list in python", "code": "def dedupe_list(seq):\n    \"\"\"\n    Utility function to remove duplicates from a list\n    :param seq: The sequence (list) to deduplicate\n    :return: A list with original duplicates removed\n    \"\"\"\n    seen = set()\n    return [x for x in seq if not (x in seen or seen.add(x))]", "code_tokens": "def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed", "label": 1}, {"idx": "cosqa-train-9724", "doc": "python script to send multiple pdf attachments", "code": "async def send_files_preconf(filepaths, config_path=CONFIG_PATH):\n    \"\"\"Send files using the config.ini settings.\n\n    Args:\n        filepaths (list(str)): A list of filepaths.\n    \"\"\"\n    config = read_config(config_path)\n    subject = \"PDF files from pdfebc\"\n    message = \"\"\n    await send_with_attachments(subject, message, filepaths, config)", "code_tokens": "async def send_files_preconf ( filepaths , config_path = CONFIG_PATH ) : config = read_config ( config_path ) subject = \"PDF files from pdfebc\" message = \"\" await send_with_attachments ( subject , message , filepaths , config )", "docstring_tokens": "Send files using the config . ini settings .", "label": 1}, {"idx": "cosqa-train-9725", "doc": "how to remove something from an item python", "code": "def remove_item(self, item):\n        \"\"\"\n        Remove (and un-index) an object\n\n        :param item: object to remove\n        :type item: alignak.objects.item.Item\n        :return: None\n        \"\"\"\n        self.unindex_item(item)\n        self.items.pop(item.uuid, None)", "code_tokens": "def remove_item ( self , item ) : self . unindex_item ( item ) self . items . pop ( item . uuid , None )", "docstring_tokens": "Remove ( and un - index ) an object", "label": 1}, {"idx": "cosqa-train-9726", "doc": "python scrollbar 2 canvas", "code": "def _set_scroll_v(self, *args):\n        \"\"\"Scroll both categories Canvas and scrolling container\"\"\"\n        self._canvas_categories.yview(*args)\n        self._canvas_scroll.yview(*args)", "code_tokens": "def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "docstring_tokens": "Scroll both categories Canvas and scrolling container", "label": 1}, {"idx": "cosqa-train-9727", "doc": "how to remove specific letters from a string in python", "code": "def _sanitize(text):\n    \"\"\"Return sanitized Eidos text field for human readability.\"\"\"\n    d = {'-LRB-': '(', '-RRB-': ')'}\n    return re.sub('|'.join(d.keys()), lambda m: d[m.group(0)], text)", "code_tokens": "def _sanitize ( text ) : d = { '-LRB-' : '(' , '-RRB-' : ')' } return re . sub ( '|' . join ( d . keys ( ) ) , lambda m : d [ m . group ( 0 ) ] , text )", "docstring_tokens": "Return sanitized Eidos text field for human readability .", "label": 1}, {"idx": "cosqa-train-9728", "doc": "python seconds to hours minutes", "code": "def time2seconds(t):\n    \"\"\"Returns seconds since 0h00.\"\"\"\n    return t.hour * 3600 + t.minute * 60 + t.second + float(t.microsecond) / 1e6", "code_tokens": "def time2seconds ( t ) : return t . hour * 3600 + t . minute * 60 + t . second + float ( t . microsecond ) / 1e6", "docstring_tokens": "Returns seconds since 0h00 .", "label": 1}, {"idx": "cosqa-train-9729", "doc": "how to remove url from a string in python", "code": "def strip_querystring(url):\n    \"\"\"Remove the querystring from the end of a URL.\"\"\"\n    p = six.moves.urllib.parse.urlparse(url)\n    return p.scheme + \"://\" + p.netloc + p.path", "code_tokens": "def strip_querystring ( url ) : p = six . moves . urllib . parse . urlparse ( url ) return p . scheme + \"://\" + p . netloc + p . path", "docstring_tokens": "Remove the querystring from the end of a URL .", "label": 1}, {"idx": "cosqa-train-9730", "doc": "python see all attributes of a object", "code": "def dict_from_object(obj: object):\n    \"\"\"Convert a object into dictionary with all of its readable attributes.\"\"\"\n\n    # If object is a dict instance, no need to convert.\n    return (obj if isinstance(obj, dict)\n            else {attr: getattr(obj, attr)\n                  for attr in dir(obj) if not attr.startswith('_')})", "code_tokens": "def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )", "docstring_tokens": "Convert a object into dictionary with all of its readable attributes .", "label": 0}, {"idx": "cosqa-train-9731", "doc": "how to replace \\ in pythong", "code": "def format_screen(strng):\n    \"\"\"Format a string for screen printing.\n\n    This removes some latex-type format codes.\"\"\"\n    # Paragraph continue\n    par_re = re.compile(r'\\\\$',re.MULTILINE)\n    strng = par_re.sub('',strng)\n    return strng", "code_tokens": "def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng", "docstring_tokens": "Format a string for screen printing .", "label": 1}, {"idx": "cosqa-train-9732", "doc": "python select count(*) from a table", "code": "def count_rows(self, table_name):\n        \"\"\"Return the number of entries in a table by counting them.\"\"\"\n        self.table_must_exist(table_name)\n        query = \"SELECT COUNT (*) FROM `%s`\" % table_name.lower()\n        self.own_cursor.execute(query)\n        return int(self.own_cursor.fetchone()[0])", "code_tokens": "def count_rows ( self , table_name ) : self . table_must_exist ( table_name ) query = \"SELECT COUNT (*) FROM `%s`\" % table_name . lower ( ) self . own_cursor . execute ( query ) return int ( self . own_cursor . fetchone ( ) [ 0 ] )", "docstring_tokens": "Return the number of entries in a table by counting them .", "label": 1}, {"idx": "cosqa-train-9733", "doc": "how to replace each value in a column with its log base python", "code": "def log_normalize(data):\n    \"\"\"Perform log transform log(x + 1).\n    \n    Parameters\n    ----------\n    data : array_like\n    \n    \"\"\"\n    if sp.issparse(data):\n        data = data.copy()\n        data.data = np.log2(data.data + 1)\n        return data\n\n    return np.log2(data.astype(np.float64) + 1)", "code_tokens": "def log_normalize ( data ) : if sp . issparse ( data ) : data = data . copy ( ) data . data = np . log2 ( data . data + 1 ) return data return np . log2 ( data . astype ( np . float64 ) + 1 )", "docstring_tokens": "Perform log transform log ( x + 1 ) . Parameters ---------- data : array_like", "label": 0}, {"idx": "cosqa-train-9734", "doc": "python seleniuim scroll into view", "code": "def scroll_element_into_view(self):\n        \"\"\"Scroll element into view\n\n        :returns: page element instance\n        \"\"\"\n        x = self.web_element.location['x']\n        y = self.web_element.location['y']\n        self.driver.execute_script('window.scrollTo({0}, {1})'.format(x, y))\n        return self", "code_tokens": "def scroll_element_into_view ( self ) : x = self . web_element . location [ 'x' ] y = self . web_element . location [ 'y' ] self . driver . execute_script ( 'window.scrollTo({0}, {1})' . format ( x , y ) ) return self", "docstring_tokens": "Scroll element into view", "label": 1}, {"idx": "cosqa-train-9735", "doc": "how to replace multiple with one in python", "code": "def _replace(self, data, replacements):\n        \"\"\"\n        Given a list of 2-tuples (find, repl) this function performs all\n        replacements on the input and returns the result.\n        \"\"\"\n        for find, repl in replacements:\n            data = data.replace(find, repl)\n        return data", "code_tokens": "def _replace ( self , data , replacements ) : for find , repl in replacements : data = data . replace ( find , repl ) return data", "docstring_tokens": "Given a list of 2 - tuples ( find repl ) this function performs all replacements on the input and returns the result .", "label": 1}, {"idx": "cosqa-train-9736", "doc": "python send data between threads", "code": "async def send(self, data):\n        \"\"\" Add data to send queue. \"\"\"\n        self.writer.write(data)\n        await self.writer.drain()", "code_tokens": "async def send ( self , data ) : self . writer . write ( data ) await self . writer . drain ( )", "docstring_tokens": "Add data to send queue .", "label": 0}, {"idx": "cosqa-train-9737", "doc": "python separate string by comma into list", "code": "def split_elements(value):\n    \"\"\"Split a string with comma or space-separated elements into a list.\"\"\"\n    l = [v.strip() for v in value.split(',')]\n    if len(l) == 1:\n        l = value.split()\n    return l", "code_tokens": "def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l", "docstring_tokens": "Split a string with comma or space - separated elements into a list .", "label": 1}, {"idx": "cosqa-train-9738", "doc": "how to reset iterator python", "code": "def reset(self):\n\t\t\"\"\"\n\t\tResets the iterator to the start.\n\n\t\tAny remaining values in the current iteration are discarded.\n\t\t\"\"\"\n\t\tself.__iterator, self.__saved = itertools.tee(self.__saved)", "code_tokens": "def reset ( self ) : self . __iterator , self . __saved = itertools . tee ( self . __saved )", "docstring_tokens": "Resets the iterator to the start .", "label": 0}, {"idx": "cosqa-train-9739", "doc": "python serializers django foreign keys", "code": "def get_serializable_data_for_fields(model):\n    \"\"\"\n    Return a serialised version of the model's fields which exist as local database\n    columns (i.e. excluding m2m and incoming foreign key relations)\n    \"\"\"\n    pk_field = model._meta.pk\n    # If model is a child via multitable inheritance, use parent's pk\n    while pk_field.remote_field and pk_field.remote_field.parent_link:\n        pk_field = pk_field.remote_field.model._meta.pk\n\n    obj = {'pk': get_field_value(pk_field, model)}\n\n    for field in model._meta.fields:\n        if field.serialize:\n            obj[field.name] = get_field_value(field, model)\n\n    return obj", "code_tokens": "def get_serializable_data_for_fields ( model ) : pk_field = model . _meta . pk # If model is a child via multitable inheritance, use parent's pk while pk_field . remote_field and pk_field . remote_field . parent_link : pk_field = pk_field . remote_field . model . _meta . pk obj = { 'pk' : get_field_value ( pk_field , model ) } for field in model . _meta . fields : if field . serialize : obj [ field . name ] = get_field_value ( field , model ) return obj", "docstring_tokens": "Return a serialised version of the model s fields which exist as local database columns ( i . e . excluding m2m and incoming foreign key relations )", "label": 1}, {"idx": "cosqa-train-9740", "doc": "how to restart program automatically python", "code": "def restart_program():\n    \"\"\"\n    DOES NOT WORK WELL WITH MOPIDY\n    Hack from\n    https://www.daniweb.com/software-development/python/code/260268/restart-your-python-program\n    to support updating the settings, since mopidy is not able to do that yet\n    Restarts the current program\n    Note: this function does not return. Any cleanup action (like\n    saving data) must be done before calling this function\n    \"\"\"\n\n    python = sys.executable\n    os.execl(python, python, * sys.argv)", "code_tokens": "def restart_program ( ) : python = sys . executable os . execl ( python , python , * sys . argv )", "docstring_tokens": "DOES NOT WORK WELL WITH MOPIDY Hack from https : // www . daniweb . com / software - development / python / code / 260268 / restart - your - python - program to support updating the settings since mopidy is not able to do that yet Restarts the current program Note : this function does not return . Any cleanup action ( like saving data ) must be done before calling this function", "label": 1}, {"idx": "cosqa-train-9741", "doc": "python set a method to none", "code": "def RemoveMethod(self, function):\n        \"\"\"\n        Removes the specified function's MethodWrapper from the\n        added_methods list, so we don't re-bind it when making a clone.\n        \"\"\"\n        self.added_methods = [dm for dm in self.added_methods if not dm.method is function]", "code_tokens": "def RemoveMethod ( self , function ) : self . added_methods = [ dm for dm in self . added_methods if not dm . method is function ]", "docstring_tokens": "Removes the specified function s MethodWrapper from the added_methods list so we don t re - bind it when making a clone .", "label": 0}, {"idx": "cosqa-train-9742", "doc": "how to retrieve s3 file data using its key using python", "code": "def read_key(self, key, bucket_name=None):\n        \"\"\"\n        Reads a key from S3\n\n        :param key: S3 key that will point to the file\n        :type key: str\n        :param bucket_name: Name of the bucket in which the file is stored\n        :type bucket_name: str\n        \"\"\"\n\n        obj = self.get_key(key, bucket_name)\n        return obj.get()['Body'].read().decode('utf-8')", "code_tokens": "def read_key ( self , key , bucket_name = None ) : obj = self . get_key ( key , bucket_name ) return obj . get ( ) [ 'Body' ] . read ( ) . decode ( 'utf-8' )", "docstring_tokens": "Reads a key from S3", "label": 1}, {"idx": "cosqa-train-9743", "doc": "python set axis range", "code": "def ylim(self, low, high, index=1):\n        \"\"\"Set yaxis limits.\n\n        Parameters\n        ----------\n        low : number\n        high : number\n        index : int, optional\n\n        Returns\n        -------\n        Chart\n\n        \"\"\"\n        self.layout['yaxis' + str(index)]['range'] = [low, high]\n        return self", "code_tokens": "def ylim ( self , low , high , index = 1 ) : self . layout [ 'yaxis' + str ( index ) ] [ 'range' ] = [ low , high ] return self", "docstring_tokens": "Set yaxis limits .", "label": 1}, {"idx": "cosqa-train-9744", "doc": "how to return the most common value in a list python", "code": "def mostCommonItem(lst):\n    \"\"\"Choose the most common item from the list, or the first item if all\n    items are unique.\"\"\"\n    # This elegant solution from: http://stackoverflow.com/a/1518632/1760218\n    lst = [l for l in lst if l]\n    if lst:\n        return max(set(lst), key=lst.count)\n    else:\n        return None", "code_tokens": "def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None", "docstring_tokens": "Choose the most common item from the list or the first item if all items are unique .", "label": 1}, {"idx": "cosqa-train-9745", "doc": "python set default file path", "code": "def copy_default_data_file(filename, module=None):\n    \"\"\"Copies file from default data directory to local directory.\"\"\"\n    if module is None:\n        module = __get_filetypes_module()\n    fullpath = get_default_data_path(filename, module=module)\n    shutil.copy(fullpath, \".\")", "code_tokens": "def copy_default_data_file ( filename , module = None ) : if module is None : module = __get_filetypes_module ( ) fullpath = get_default_data_path ( filename , module = module ) shutil . copy ( fullpath , \".\" )", "docstring_tokens": "Copies file from default data directory to local directory .", "label": 1}, {"idx": "cosqa-train-9746", "doc": "how to reuse python logging config", "code": "def set_logging_config(log_level, handlers):\n    \"\"\"Set python logging library config.\n\n    Run this ONCE at the start of your process. It formats the python logging\n    module's output.\n    Defaults logging level to INFO = 20)\n    \"\"\"\n    logging.basicConfig(\n        format='%(asctime)s %(levelname)s:%(name)s:%(funcName)s: %(message)s',\n        datefmt='%Y-%m-%d %H:%M:%S',\n        level=log_level,\n        handlers=handlers)", "code_tokens": "def set_logging_config ( log_level , handlers ) : logging . basicConfig ( format = '%(asctime)s %(levelname)s:%(name)s:%(funcName)s: %(message)s' , datefmt = '%Y-%m-%d %H:%M:%S' , level = log_level , handlers = handlers )", "docstring_tokens": "Set python logging library config .", "label": 1}, {"idx": "cosqa-train-9747", "doc": "python set limits on x axis", "code": "def set_xlimits(self, min=None, max=None):\n        \"\"\"Set limits for the x-axis.\n\n        :param min: minimum value to be displayed.  If None, it will be\n            calculated.\n        :param max: maximum value to be displayed.  If None, it will be\n            calculated.\n\n        \"\"\"\n        self.limits['xmin'] = min\n        self.limits['xmax'] = max", "code_tokens": "def set_xlimits ( self , min = None , max = None ) : self . limits [ 'xmin' ] = min self . limits [ 'xmax' ] = max", "docstring_tokens": "Set limits for the x - axis .", "label": 1}, {"idx": "cosqa-train-9748", "doc": "how to reverse the movement of a sprite in python", "code": "def move_back(self, dt):\n        \"\"\" If called after an update, the sprite can move back\n        \"\"\"\n        self._position = self._old_position\n        self.rect.topleft = self._position\n        self.feet.midbottom = self.rect.midbottom", "code_tokens": "def move_back ( self , dt ) : self . _position = self . _old_position self . rect . topleft = self . _position self . feet . midbottom = self . rect . midbottom", "docstring_tokens": "If called after an update the sprite can move back", "label": 1}, {"idx": "cosqa-train-9749", "doc": "python set local image url", "code": "def get_local_image(self, src):\n        \"\"\"\\\n        returns the bytes of the image file on disk\n        \"\"\"\n        return ImageUtils.store_image(self.fetcher, self.article.link_hash, src, self.config)", "code_tokens": "def get_local_image ( self , src ) : return ImageUtils . store_image ( self . fetcher , self . article . link_hash , src , self . config )", "docstring_tokens": "\\ returns the bytes of the image file on disk", "label": 0}, {"idx": "cosqa-train-9750", "doc": "how to rotate an array by 63 degrees in python", "code": "def rotateImage(image, angle):\n    \"\"\"\n        rotates a 2d array to a multiple of 90 deg.\n        0 = default\n        1 = 90 deg. cw\n        2 = 180 deg.\n        3 = 90 deg. ccw\n    \"\"\"\n    image = [list(row) for row in image]\n\n    for n in range(angle % 4):\n        image = list(zip(*image[::-1]))\n\n    return image", "code_tokens": "def rotateImage ( image , angle ) : image = [ list ( row ) for row in image ] for n in range ( angle % 4 ) : image = list ( zip ( * image [ : : - 1 ] ) ) return image", "docstring_tokens": "rotates a 2d array to a multiple of 90 deg . 0 = default 1 = 90 deg . cw 2 = 180 deg . 3 = 90 deg . ccw", "label": 0}, {"idx": "cosqa-train-9751", "doc": "python set output to true", "code": "def auto():\n\t\"\"\"set colouring on if STDOUT is a terminal device, off otherwise\"\"\"\n\ttry:\n\t\tStyle.enabled = False\n\t\tStyle.enabled = sys.stdout.isatty()\n\texcept (AttributeError, TypeError):\n\t\tpass", "code_tokens": "def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass", "docstring_tokens": "set colouring on if STDOUT is a terminal device off otherwise", "label": 1}, {"idx": "cosqa-train-9752", "doc": "how to rotate array 180 in python numpy", "code": "def rotateImage(image, angle):\n    \"\"\"\n        rotates a 2d array to a multiple of 90 deg.\n        0 = default\n        1 = 90 deg. cw\n        2 = 180 deg.\n        3 = 90 deg. ccw\n    \"\"\"\n    image = [list(row) for row in image]\n\n    for n in range(angle % 4):\n        image = list(zip(*image[::-1]))\n\n    return image", "code_tokens": "def rotateImage ( image , angle ) : image = [ list ( row ) for row in image ] for n in range ( angle % 4 ) : image = list ( zip ( * image [ : : - 1 ] ) ) return image", "docstring_tokens": "rotates a 2d array to a multiple of 90 deg . 0 = default 1 = 90 deg . cw 2 = 180 deg . 3 = 90 deg . ccw", "label": 0}, {"idx": "cosqa-train-9753", "doc": "python set randome state", "code": "def reseed_random(seed):\n    \"\"\"Reseed factory.fuzzy's random generator.\"\"\"\n    r = random.Random(seed)\n    random_internal_state = r.getstate()\n    set_random_state(random_internal_state)", "code_tokens": "def reseed_random ( seed ) : r = random . Random ( seed ) random_internal_state = r . getstate ( ) set_random_state ( random_internal_state )", "docstring_tokens": "Reseed factory . fuzzy s random generator .", "label": 1}, {"idx": "cosqa-train-9754", "doc": "how to round decimals up in python", "code": "def price_rounding(price, decimals=2):\n    \"\"\"Takes a decimal price and rounds to a number of decimal places\"\"\"\n    try:\n        exponent = D('.' + decimals * '0')\n    except InvalidOperation:\n        # Currencies with no decimal places, ex. JPY, HUF\n        exponent = D()\n    return price.quantize(exponent, rounding=ROUND_UP)", "code_tokens": "def price_rounding ( price , decimals = 2 ) : try : exponent = D ( '.' + decimals * '0' ) except InvalidOperation : # Currencies with no decimal places, ex. JPY, HUF exponent = D ( ) return price . quantize ( exponent , rounding = ROUND_UP )", "docstring_tokens": "Takes a decimal price and rounds to a number of decimal places", "label": 1}, {"idx": "cosqa-train-9755", "doc": "python settrace stack frame", "code": "def __run(self):\n    \"\"\"Hacked run function, which installs the trace.\"\"\"\n    sys.settrace(self.globaltrace)\n    self.__run_backup()\n    self.run = self.__run_backup", "code_tokens": "def __run ( self ) : sys . settrace ( self . globaltrace ) self . __run_backup ( ) self . run = self . __run_backup", "docstring_tokens": "Hacked run function which installs the trace .", "label": 1}, {"idx": "cosqa-train-9756", "doc": "how to round off the values stored in a list in python", "code": "def round_data(filter_data):\n    \"\"\" round the data\"\"\"\n    for index, _ in enumerate(filter_data):\n        filter_data[index][0] = round(filter_data[index][0] / 100.0) * 100.0\n    return filter_data", "code_tokens": "def round_data ( filter_data ) : for index , _ in enumerate ( filter_data ) : filter_data [ index ] [ 0 ] = round ( filter_data [ index ] [ 0 ] / 100.0 ) * 100.0 return filter_data", "docstring_tokens": "round the data", "label": 0}, {"idx": "cosqa-train-9757", "doc": "python sha1 of file different", "code": "def _sha1_for_file(filename):\n    \"\"\"Return sha1 for contents of filename.\"\"\"\n    with open(filename, \"rb\") as fileobj:\n        contents = fileobj.read()\n        return hashlib.sha1(contents).hexdigest()", "code_tokens": "def _sha1_for_file ( filename ) : with open ( filename , \"rb\" ) as fileobj : contents = fileobj . read ( ) return hashlib . sha1 ( contents ) . hexdigest ( )", "docstring_tokens": "Return sha1 for contents of filename .", "label": 0}, {"idx": "cosqa-train-9758", "doc": "how to round up an intager in python", "code": "def image_load_time(self):\n        \"\"\"\n        Returns aggregate image load time for all pages.\n        \"\"\"\n        load_times = self.get_load_times('image')\n        return round(mean(load_times), self.decimal_precision)", "code_tokens": "def image_load_time ( self ) : load_times = self . get_load_times ( 'image' ) return round ( mean ( load_times ) , self . decimal_precision )", "docstring_tokens": "Returns aggregate image load time for all pages .", "label": 1}, {"idx": "cosqa-train-9759", "doc": "python short cut to get cursor to end of line", "code": "def _go_to_line(editor, line):\n    \"\"\"\n    Move cursor to this line in the current buffer.\n    \"\"\"\n    b = editor.application.current_buffer\n    b.cursor_position = b.document.translate_row_col_to_index(max(0, int(line) - 1), 0)", "code_tokens": "def _go_to_line ( editor , line ) : b = editor . application . current_buffer b . cursor_position = b . document . translate_row_col_to_index ( max ( 0 , int ( line ) - 1 ) , 0 )", "docstring_tokens": "Move cursor to this line in the current buffer .", "label": 1}, {"idx": "cosqa-train-9760", "doc": "how to run a loop moving background on idle python", "code": "def main(idle):\n    \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"\n    while True:\n\n        LOG.debug(\"Sleeping for {0} seconds.\".format(idle))\n        time.sleep(idle)", "code_tokens": "def main ( idle ) : while True : LOG . debug ( \"Sleeping for {0} seconds.\" . format ( idle ) ) time . sleep ( idle )", "docstring_tokens": "Any normal python logic which runs a loop . Can take arguments .", "label": 0}, {"idx": "cosqa-train-9761", "doc": "python show the last 300 records in a data frame", "code": "def get_last_row(dbconn, tablename, n=1, uuid=None):\n    \"\"\"\n    Returns the last `n` rows in the table\n    \"\"\"\n    return fetch(dbconn, tablename, n, uuid, end=True)", "code_tokens": "def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )", "docstring_tokens": "Returns the last n rows in the table", "label": 1}, {"idx": "cosqa-train-9762", "doc": "how to run python unittest cmd", "code": "def test():  # pragma: no cover\n    \"\"\"Execute the unit tests on an installed copy of unyt.\n\n    Note that this function requires pytest to run. If pytest is not\n    installed this function will raise ImportError.\n    \"\"\"\n    import pytest\n    import os\n\n    pytest.main([os.path.dirname(os.path.abspath(__file__))])", "code_tokens": "def test ( ) : # pragma: no cover import pytest import os pytest . main ( [ os . path . dirname ( os . path . abspath ( __file__ ) ) ] )", "docstring_tokens": "Execute the unit tests on an installed copy of unyt .", "label": 1}, {"idx": "cosqa-train-9763", "doc": "python show time passed in days hours minutes seconds", "code": "def pprint(self, seconds):\n        \"\"\"\n        Pretty Prints seconds as Hours:Minutes:Seconds.MilliSeconds\n\n        :param seconds:  The time in seconds.\n        \"\"\"\n        return (\"%d:%02d:%02d.%03d\", reduce(lambda ll, b: divmod(ll[0], b) + ll[1:], [(seconds * 1000,), 1000, 60, 60]))", "code_tokens": "def pprint ( self , seconds ) : return ( \"%d:%02d:%02d.%03d\" , reduce ( lambda ll , b : divmod ( ll [ 0 ] , b ) + ll [ 1 : ] , [ ( seconds * 1000 , ) , 1000 , 60 , 60 ] ) )", "docstring_tokens": "Pretty Prints seconds as Hours : Minutes : Seconds . MilliSeconds", "label": 1}, {"idx": "cosqa-train-9764", "doc": "how to save a file from an api token python", "code": "def update_token_tempfile(token):\n    \"\"\"\n    Example of function for token update\n    \"\"\"\n    with open(tmp, 'w') as f:\n        f.write(json.dumps(token, indent=4))", "code_tokens": "def update_token_tempfile ( token ) : with open ( tmp , 'w' ) as f : f . write ( json . dumps ( token , indent = 4 ) )", "docstring_tokens": "Example of function for token update", "label": 0}, {"idx": "cosqa-train-9765", "doc": "python sigint kill blocking master process", "code": "def process_kill(pid, sig=None):\n    \"\"\"Send signal to process.\n    \"\"\"\n    sig = sig or signal.SIGTERM\n    os.kill(pid, sig)", "code_tokens": "def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )", "docstring_tokens": "Send signal to process .", "label": 1}, {"idx": "cosqa-train-9766", "doc": "how to save a file on your coumpter given a url python", "code": "def download_file(save_path, file_url):\n    \"\"\" Download file from http url link \"\"\"\n\n    r = requests.get(file_url)  # create HTTP response object\n\n    with open(save_path, 'wb') as f:\n        f.write(r.content)\n\n    return save_path", "code_tokens": "def download_file ( save_path , file_url ) : r = requests . get ( file_url ) # create HTTP response object with open ( save_path , 'wb' ) as f : f . write ( r . content ) return save_path", "docstring_tokens": "Download file from http url link", "label": 1}, {"idx": "cosqa-train-9767", "doc": "python single byte to int", "code": "def string_to_int( s ):\n  \"\"\"Convert a string of bytes into an integer, as per X9.62.\"\"\"\n  result = 0\n  for c in s:\n    if not isinstance(c, int): c = ord( c )\n    result = 256 * result + c\n  return result", "code_tokens": "def string_to_int ( s ) : result = 0 for c in s : if not isinstance ( c , int ) : c = ord ( c ) result = 256 * result + c return result", "docstring_tokens": "Convert a string of bytes into an integer as per X9 . 62 .", "label": 1}, {"idx": "cosqa-train-9768", "doc": "how to save audio as wave file python", "code": "def write_wave(path, audio, sample_rate):\n    \"\"\"Writes a .wav file.\n\n    Takes path, PCM audio data, and sample rate.\n    \"\"\"\n    with contextlib.closing(wave.open(path, 'wb')) as wf:\n        wf.setnchannels(1)\n        wf.setsampwidth(2)\n        wf.setframerate(sample_rate)\n        wf.writeframes(audio)", "code_tokens": "def write_wave ( path , audio , sample_rate ) : with contextlib . closing ( wave . open ( path , 'wb' ) ) as wf : wf . setnchannels ( 1 ) wf . setsampwidth ( 2 ) wf . setframerate ( sample_rate ) wf . writeframes ( audio )", "docstring_tokens": "Writes a . wav file .", "label": 1}, {"idx": "cosqa-train-9769", "doc": "python singleton lazy initialize", "code": "def singleton_per_scope(_cls, _scope=None, _renew=False, *args, **kwargs):\n    \"\"\"Instanciate a singleton per scope.\"\"\"\n\n    result = None\n\n    singletons = SINGLETONS_PER_SCOPES.setdefault(_scope, {})\n\n    if _renew or _cls not in singletons:\n        singletons[_cls] = _cls(*args, **kwargs)\n\n    result = singletons[_cls]\n\n    return result", "code_tokens": "def singleton_per_scope ( _cls , _scope = None , _renew = False , * args , * * kwargs ) : result = None singletons = SINGLETONS_PER_SCOPES . setdefault ( _scope , { } ) if _renew or _cls not in singletons : singletons [ _cls ] = _cls ( * args , * * kwargs ) result = singletons [ _cls ] return result", "docstring_tokens": "Instanciate a singleton per scope .", "label": 0}, {"idx": "cosqa-train-9770", "doc": "how to save variable to text file python", "code": "def save(variable, filename):\n    \"\"\"Save variable on given path using Pickle\n    \n    Args:\n        variable: what to save\n        path (str): path of the output\n    \"\"\"\n    fileObj = open(filename, 'wb')\n    pickle.dump(variable, fileObj)\n    fileObj.close()", "code_tokens": "def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )", "docstring_tokens": "Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output", "label": 1}, {"idx": "cosqa-train-9771", "doc": "python size of numpy array in memory", "code": "def array_bytes(array):\n    \"\"\" Estimates the memory of the supplied array in bytes \"\"\"\n    return np.product(array.shape)*np.dtype(array.dtype).itemsize", "code_tokens": "def array_bytes ( array ) : return np . product ( array . shape ) * np . dtype ( array . dtype ) . itemsize", "docstring_tokens": "Estimates the memory of the supplied array in bytes", "label": 1}, {"idx": "cosqa-train-9772", "doc": "how to see all python functions", "code": "def functions(self):\n        \"\"\"\n        A list of functions declared or defined in this module.\n        \"\"\"\n        return [v for v in self.globals.values()\n                if isinstance(v, values.Function)]", "code_tokens": "def functions ( self ) : return [ v for v in self . globals . values ( ) if isinstance ( v , values . Function ) ]", "docstring_tokens": "A list of functions declared or defined in this module .", "label": 1}, {"idx": "cosqa-train-9773", "doc": "python skip to next item", "code": "def skip(self, n):\n        \"\"\"Skip the specified number of elements in the list.\n\n        If the number skipped is greater than the number of elements in\n        the list, hasNext() becomes false and available() returns zero\n        as there are no more elements to retrieve.\n\n        arg:    n (cardinal): the number of elements to skip\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        try:\n            self._iter_object.skip(n)\n        except AttributeError:\n            for i in range(0, n):\n                self.next()", "code_tokens": "def skip ( self , n ) : try : self . _iter_object . skip ( n ) except AttributeError : for i in range ( 0 , n ) : self . next ( )", "docstring_tokens": "Skip the specified number of elements in the list .", "label": 1}, {"idx": "cosqa-train-9774", "doc": "how to see all python versions", "code": "def all_versions(req):\n    \"\"\"Get all versions of req from PyPI.\"\"\"\n    import requests\n    url = \"https://pypi.python.org/pypi/\" + req + \"/json\"\n    return tuple(requests.get(url).json()[\"releases\"].keys())", "code_tokens": "def all_versions ( req ) : import requests url = \"https://pypi.python.org/pypi/\" + req + \"/json\" return tuple ( requests . get ( url ) . json ( ) [ \"releases\" ] . keys ( ) )", "docstring_tokens": "Get all versions of req from PyPI .", "label": 1}, {"idx": "cosqa-train-9775", "doc": "python slice column numbers", "code": "def getcolslice(self, blc, trc, inc=[], startrow=0, nrow=-1, rowincr=1):\n        \"\"\"Get a slice from a table column holding arrays.\n        (see :func:`table.getcolslice`)\"\"\"\n        return self._table.getcolslice(self._column, blc, trc, inc, startrow, nrow, rowincr)", "code_tokens": "def getcolslice ( self , blc , trc , inc = [ ] , startrow = 0 , nrow = - 1 , rowincr = 1 ) : return self . _table . getcolslice ( self . _column , blc , trc , inc , startrow , nrow , rowincr )", "docstring_tokens": "Get a slice from a table column holding arrays . ( see : func : table . getcolslice )", "label": 1}, {"idx": "cosqa-train-9776", "doc": "how to see all variables in python", "code": "def caller_locals():\n    \"\"\"Get the local variables in the caller's frame.\"\"\"\n    import inspect\n    frame = inspect.currentframe()\n    try:\n        return frame.f_back.f_back.f_locals\n    finally:\n        del frame", "code_tokens": "def caller_locals ( ) : import inspect frame = inspect . currentframe ( ) try : return frame . f_back . f_back . f_locals finally : del frame", "docstring_tokens": "Get the local variables in the caller s frame .", "label": 1}, {"idx": "cosqa-train-9777", "doc": "python slice notation same as golang", "code": "def is_full_slice(obj, l):\n    \"\"\"\n    We have a full length slice.\n    \"\"\"\n    return (isinstance(obj, slice) and obj.start == 0 and obj.stop == l and\n            obj.step is None)", "code_tokens": "def is_full_slice ( obj , l ) : return ( isinstance ( obj , slice ) and obj . start == 0 and obj . stop == l and obj . step is None )", "docstring_tokens": "We have a full length slice .", "label": 1}, {"idx": "cosqa-train-9778", "doc": "how to see common elements in a set python", "code": "def compare(dicts):\n    \"\"\"Compare by iteration\"\"\"\n\n    common_members = {}\n    common_keys = reduce(lambda x, y: x & y, map(dict.keys, dicts))\n    for k in common_keys:\n        common_members[k] = list(\n            reduce(lambda x, y: x & y, [set(d[k]) for d in dicts]))\n\n    return common_members", "code_tokens": "def compare ( dicts ) : common_members = { } common_keys = reduce ( lambda x , y : x & y , map ( dict . keys , dicts ) ) for k in common_keys : common_members [ k ] = list ( reduce ( lambda x , y : x & y , [ set ( d [ k ] ) for d in dicts ] ) ) return common_members", "docstring_tokens": "Compare by iteration", "label": 1}, {"idx": "cosqa-train-9779", "doc": "python smooth an array", "code": "def smooth_array(array, amount=1):\n    \"\"\"\n\n    Returns the nearest-neighbor (+/- amount) smoothed array.\n    This does not modify the array or slice off the funny end points.\n\n    \"\"\"\n    if amount==0: return array\n\n    # we have to store the old values in a temp array to keep the\n    # smoothing from affecting the smoothing\n    new_array = _n.array(array)\n\n    for n in range(len(array)):\n        new_array[n] = smooth(array, n, amount)\n\n    return new_array", "code_tokens": "def smooth_array ( array , amount = 1 ) : if amount == 0 : return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n . array ( array ) for n in range ( len ( array ) ) : new_array [ n ] = smooth ( array , n , amount ) return new_array", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-9780", "doc": "how to see how similar two images are in python", "code": "def _sim_fill(r1, r2, imsize):\n    \"\"\"\n        calculate the fill similarity over the image\n    \"\"\"\n    bbsize = (\n        (max(r1[\"max_x\"], r2[\"max_x\"]) - min(r1[\"min_x\"], r2[\"min_x\"]))\n        * (max(r1[\"max_y\"], r2[\"max_y\"]) - min(r1[\"min_y\"], r2[\"min_y\"]))\n    )\n    return 1.0 - (bbsize - r1[\"size\"] - r2[\"size\"]) / imsize", "code_tokens": "def _sim_fill ( r1 , r2 , imsize ) : bbsize = ( ( max ( r1 [ \"max_x\" ] , r2 [ \"max_x\" ] ) - min ( r1 [ \"min_x\" ] , r2 [ \"min_x\" ] ) ) * ( max ( r1 [ \"max_y\" ] , r2 [ \"max_y\" ] ) - min ( r1 [ \"min_y\" ] , r2 [ \"min_y\" ] ) ) ) return 1.0 - ( bbsize - r1 [ \"size\" ] - r2 [ \"size\" ] ) / imsize", "docstring_tokens": "calculate the fill similarity over the image", "label": 1}, {"idx": "cosqa-train-9781", "doc": "python socket restart after close", "code": "def shutdown(self):\n        \"\"\"close socket, immediately.\"\"\"\n        if self.sock:\n            self.sock.close()\n            self.sock = None\n            self.connected = False", "code_tokens": "def shutdown ( self ) : if self . sock : self . sock . close ( ) self . sock = None self . connected = False", "docstring_tokens": "close socket immediately .", "label": 1}, {"idx": "cosqa-train-9782", "doc": "how to see python code line by line", "code": "def runcode(code):\n\t\"\"\"Run the given code line by line with printing, as list of lines, and return variable 'ans'.\"\"\"\n\tfor line in code:\n\t\tprint('# '+line)\n\t\texec(line,globals())\n\tprint('# return ans')\n\treturn ans", "code_tokens": "def runcode ( code ) : for line in code : print ( '# ' + line ) exec ( line , globals ( ) ) print ( '# return ans' ) return ans", "docstring_tokens": "Run the given code line by line with printing as list of lines and return variable ans .", "label": 1}, {"idx": "cosqa-train-9783", "doc": "python socketio and flask socketio", "code": "def run(context, port):\n    \"\"\" Run the Webserver/SocketIO and app\n    \"\"\"\n    global ctx\n    ctx = context\n    app.run(port=port)", "code_tokens": "def run ( context , port ) : global ctx ctx = context app . run ( port = port )", "docstring_tokens": "Run the Webserver / SocketIO and app", "label": 1}, {"idx": "cosqa-train-9784", "doc": "how to segment object from image using pil in python", "code": "def region_from_segment(image, segment):\n    \"\"\"given a segment (rectangle) and an image, returns it's corresponding subimage\"\"\"\n    x, y, w, h = segment\n    return image[y:y + h, x:x + w]", "code_tokens": "def region_from_segment ( image , segment ) : x , y , w , h = segment return image [ y : y + h , x : x + w ]", "docstring_tokens": "given a segment ( rectangle ) and an image returns it s corresponding subimage", "label": 1}, {"idx": "cosqa-train-9785", "doc": "python solve matrix unknowns on both sides", "code": "def MatrixSolve(a, rhs, adj):\n    \"\"\"\n    Matrix solve op.\n    \"\"\"\n    return np.linalg.solve(a if not adj else _adjoint(a), rhs),", "code_tokens": "def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,", "docstring_tokens": "Matrix solve op .", "label": 1}, {"idx": "cosqa-train-9786", "doc": "how to select n elements randomly from a list python", "code": "def rand_elem(seq, n=None):\n    \"\"\"returns a random element from seq n times. If n is None, it continues indefinitly\"\"\"\n    return map(random.choice, repeat(seq, n) if n is not None else repeat(seq))", "code_tokens": "def rand_elem ( seq , n = None ) : return map ( random . choice , repeat ( seq , n ) if n is not None else repeat ( seq ) )", "docstring_tokens": "returns a random element from seq n times . If n is None it continues indefinitly", "label": 1}, {"idx": "cosqa-train-9787", "doc": "python sortlevels in multi index by list", "code": "def sortlevel(self, level=None, ascending=True, sort_remaining=None):\n        \"\"\"\n        For internal compatibility with with the Index API.\n\n        Sort the Index. This is for compat with MultiIndex\n\n        Parameters\n        ----------\n        ascending : boolean, default True\n            False to sort in descending order\n\n        level, sort_remaining are compat parameters\n\n        Returns\n        -------\n        Index\n        \"\"\"\n        return self.sort_values(return_indexer=True, ascending=ascending)", "code_tokens": "def sortlevel ( self , level = None , ascending = True , sort_remaining = None ) : return self . sort_values ( return_indexer = True , ascending = ascending )", "docstring_tokens": "For internal compatibility with with the Index API .", "label": 0}, {"idx": "cosqa-train-9788", "doc": "how to set a default value if no value given in a setter function for a clas python", "code": "def set_default(self_,param_name,value):\n        \"\"\"\n        Set the default value of param_name.\n\n        Equivalent to setting param_name on the class.\n        \"\"\"\n        cls = self_.cls\n        setattr(cls,param_name,value)", "code_tokens": "def set_default ( self_ , param_name , value ) : cls = self_ . cls setattr ( cls , param_name , value )", "docstring_tokens": "Set the default value of param_name .", "label": 0}, {"idx": "cosqa-train-9789", "doc": "python spacing after for", "code": "def _write_separator(self):\n        \"\"\"\n        Inserts a horizontal (commented) line tot the generated code.\n        \"\"\"\n        tmp = self._page_width - ((4 * self.__indent_level) + 2)\n        self._write_line('# ' + ('-' * tmp))", "code_tokens": "def _write_separator ( self ) : tmp = self . _page_width - ( ( 4 * self . __indent_level ) + 2 ) self . _write_line ( '# ' + ( '-' * tmp ) )", "docstring_tokens": "Inserts a horizontal ( commented ) line tot the generated code .", "label": 1}, {"idx": "cosqa-train-9790", "doc": "how to set a python function to have a start time", "code": "def run_test(func, fobj):\n    \"\"\"Run func with argument fobj and measure execution time.\n    @param  func:   function for test\n    @param  fobj:   data for test\n    @return:        execution time\n    \"\"\"\n    gc.disable()\n    try:\n        begin = time.time()\n        func(fobj)\n        end = time.time()\n    finally:\n        gc.enable()\n    return end - begin", "code_tokens": "def run_test ( func , fobj ) : gc . disable ( ) try : begin = time . time ( ) func ( fobj ) end = time . time ( ) finally : gc . enable ( ) return end - begin", "docstring_tokens": "Run func with argument fobj and measure execution time .", "label": 1}, {"idx": "cosqa-train-9791", "doc": "python specify a type literal", "code": "def visit_Str(self, node):\n        \"\"\" Set the pythonic string type. \"\"\"\n        self.result[node] = self.builder.NamedType(pytype_to_ctype(str))", "code_tokens": "def visit_Str ( self , node ) : self . result [ node ] = self . builder . NamedType ( pytype_to_ctype ( str ) )", "docstring_tokens": "Set the pythonic string type .", "label": 1}, {"idx": "cosqa-train-9792", "doc": "how to set a tuple as a paramter in python", "code": "def as_tuple(self, value):\n        \"\"\"Utility function which converts lists to tuples.\"\"\"\n        if isinstance(value, list):\n            value = tuple(value)\n        return value", "code_tokens": "def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value", "docstring_tokens": "Utility function which converts lists to tuples .", "label": 0}, {"idx": "cosqa-train-9793", "doc": "python splinter choose combobox", "code": "def onchange(self, value):\n        \"\"\"Called when a new DropDownItem gets selected.\n        \"\"\"\n        log.debug('combo box. selected %s' % value)\n        self.select_by_value(value)\n        return (value, )", "code_tokens": "def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )", "docstring_tokens": "Called when a new DropDownItem gets selected .", "label": 1}, {"idx": "cosqa-train-9794", "doc": "how to set a variable with a color python", "code": "def write_color(string, name, style='normal', when='auto'):\n    \"\"\" Write the given colored string to standard out. \"\"\"\n    write(color(string, name, style, when))", "code_tokens": "def write_color ( string , name , style = 'normal' , when = 'auto' ) : write ( color ( string , name , style , when ) )", "docstring_tokens": "Write the given colored string to standard out .", "label": 0}, {"idx": "cosqa-train-9795", "doc": "python split a list at each word", "code": "def tokenize_list(self, text):\n        \"\"\"\n        Split a text into separate words.\n        \"\"\"\n        return [self.get_record_token(record) for record in self.analyze(text)]", "code_tokens": "def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]", "docstring_tokens": "Split a text into separate words .", "label": 1}, {"idx": "cosqa-train-9796", "doc": "how to set an image as background in python'", "code": "def copy_image_on_background(image, color=WHITE):\n    \"\"\"\n    Create a new image by copying the image on a *color* background.\n\n    Args:\n        image (PIL.Image.Image): Image to copy\n        color (tuple): Background color usually WHITE or BLACK\n\n    Returns:\n        PIL.Image.Image\n\n    \"\"\"\n    background = Image.new(\"RGB\", image.size, color)\n    background.paste(image, mask=image.split()[3])\n    return background", "code_tokens": "def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( \"RGB\" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background", "docstring_tokens": "Create a new image by copying the image on a * color * background .", "label": 1}, {"idx": "cosqa-train-9797", "doc": "python split iterate by size", "code": "def partition(a, sz): \n    \"\"\"splits iterables a in equal parts of size sz\"\"\"\n    return [a[i:i+sz] for i in range(0, len(a), sz)]", "code_tokens": "def partition ( a , sz ) : return [ a [ i : i + sz ] for i in range ( 0 , len ( a ) , sz ) ]", "docstring_tokens": "splits iterables a in equal parts of size sz", "label": 1}, {"idx": "cosqa-train-9798", "doc": "how to set global variable by name in python", "code": "def get_var(name, factory=None):\n    \"\"\"Gets a global variable given its name.\n\n    If factory is not None and the variable is not set, factory\n    is a callable that will set the variable.\n\n    If not set, returns None.\n    \"\"\"\n    if name not in _VARS and factory is not None:\n        _VARS[name] = factory()\n    return _VARS.get(name)", "code_tokens": "def get_var ( name , factory = None ) : if name not in _VARS and factory is not None : _VARS [ name ] = factory ( ) return _VARS . get ( name )", "docstring_tokens": "Gets a global variable given its name .", "label": 1}, {"idx": "cosqa-train-9799", "doc": "python split list into sublists on token", "code": "def tokenize_list(self, text):\n        \"\"\"\n        Split a text into separate words.\n        \"\"\"\n        return [self.get_record_token(record) for record in self.analyze(text)]", "code_tokens": "def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]", "docstring_tokens": "Split a text into separate words .", "label": 1}, {"idx": "cosqa-train-9800", "doc": "how to set limits in python on plot", "code": "def set_xlimits_widgets(self, set_min=True, set_max=True):\n        \"\"\"Populate axis limits GUI with current plot values.\"\"\"\n        xmin, xmax = self.tab_plot.ax.get_xlim()\n        if set_min:\n            self.w.x_lo.set_text('{0}'.format(xmin))\n        if set_max:\n            self.w.x_hi.set_text('{0}'.format(xmax))", "code_tokens": "def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )", "docstring_tokens": "Populate axis limits GUI with current plot values .", "label": 1}, {"idx": "cosqa-train-9801", "doc": "python split prefix from suffix", "code": "def parse_prefix(identifier):\n    \"\"\"\n    Parse identifier such as a|c|le|d|li|re|or|AT4G00480.1 and return\n    tuple of prefix string (separated at '|') and suffix (AGI identifier)\n    \"\"\"\n    pf, id = (), identifier\n    if \"|\" in identifier:\n        pf, id = tuple(identifier.split('|')[:-1]), identifier.split('|')[-1]\n\n    return pf, id", "code_tokens": "def parse_prefix ( identifier ) : pf , id = ( ) , identifier if \"|\" in identifier : pf , id = tuple ( identifier . split ( '|' ) [ : - 1 ] ) , identifier . split ( '|' ) [ - 1 ] return pf , id", "docstring_tokens": "Parse identifier such as a|c|le|d|li|re|or|AT4G00480 . 1 and return tuple of prefix string ( separated at | ) and suffix ( AGI identifier )", "label": 0}, {"idx": "cosqa-train-9802", "doc": "how to set str into float python", "code": "def covstr(s):\n  \"\"\" convert string to int or float. \"\"\"\n  try:\n    ret = int(s)\n  except ValueError:\n    ret = float(s)\n  return ret", "code_tokens": "def covstr ( s ) : try : ret = int ( s ) except ValueError : ret = float ( s ) return ret", "docstring_tokens": "convert string to int or float .", "label": 0}, {"idx": "cosqa-train-9803", "doc": "python split string by len list", "code": "def split_len(s, length):\n    \"\"\"split string *s* into list of strings no longer than *length*\"\"\"\n    return [s[i:i+length] for i in range(0, len(s), length)]", "code_tokens": "def split_len ( s , length ) : return [ s [ i : i + length ] for i in range ( 0 , len ( s ) , length ) ]", "docstring_tokens": "split string * s * into list of strings no longer than * length *", "label": 1}, {"idx": "cosqa-train-9804", "doc": "how to set the precision of a float python", "code": "def round_to_int(number, precision):\n    \"\"\"Round a number to a precision\"\"\"\n    precision = int(precision)\n    rounded = (int(number) + precision / 2) // precision * precision\n    return rounded", "code_tokens": "def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded", "docstring_tokens": "Round a number to a precision", "label": 1}, {"idx": "cosqa-train-9805", "doc": "python split words in to list", "code": "def tokenize_list(self, text):\n        \"\"\"\n        Split a text into separate words.\n        \"\"\"\n        return [self.get_record_token(record) for record in self.analyze(text)]", "code_tokens": "def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]", "docstring_tokens": "Split a text into separate words .", "label": 1}, {"idx": "cosqa-train-9806", "doc": "how to set y axis limits in python", "code": "def set_ylim(self, xlims, dx, xscale, reverse=False):\n        \"\"\"Set y limits for plot.\n\n        This will set the limits for the y axis\n        for the specific plot.\n\n        Args:\n            ylims (len-2 list of floats): The limits for the axis.\n            dy (float): Amount to increment by between the limits.\n            yscale (str): Scale of the axis. Either `log` or `lin`.\n            reverse (bool, optional): If True, reverse the axis tick marks. Default is False.\n\n        \"\"\"\n        self._set_axis_limits('y', xlims, dx, xscale, reverse)\n        return", "code_tokens": "def set_ylim ( self , xlims , dx , xscale , reverse = False ) : self . _set_axis_limits ( 'y' , xlims , dx , xscale , reverse ) return", "docstring_tokens": "Set y limits for plot .", "label": 1}, {"idx": "cosqa-train-9807", "doc": "python sqlalchemy compile to raw sql", "code": "def compile(expr, params=None):\n    \"\"\"\n    Force compilation of expression for the SQLite target\n    \"\"\"\n    from ibis.sql.alchemy import to_sqlalchemy\n\n    return to_sqlalchemy(expr, dialect.make_context(params=params))", "code_tokens": "def compile ( expr , params = None ) : from ibis . sql . alchemy import to_sqlalchemy return to_sqlalchemy ( expr , dialect . make_context ( params = params ) )", "docstring_tokens": "Force compilation of expression for the SQLite target", "label": 1}, {"idx": "cosqa-train-9808", "doc": "how to shift print to left or right in python", "code": "def set_left_to_right(self):\n        \"\"\"Set text direction left to right.\"\"\"\n        self.displaymode |= LCD_ENTRYLEFT\n        self.write8(LCD_ENTRYMODESET | self.displaymode)", "code_tokens": "def set_left_to_right ( self ) : self . displaymode |= LCD_ENTRYLEFT self . write8 ( LCD_ENTRYMODESET | self . displaymode )", "docstring_tokens": "Set text direction left to right .", "label": 1}, {"idx": "cosqa-train-9809", "doc": "python sqlalchemy create database and tables", "code": "def createdb():\n    \"\"\"Create database tables from sqlalchemy models\"\"\"\n    manager.db.engine.echo = True\n    manager.db.create_all()\n    set_alembic_revision()", "code_tokens": "def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )", "docstring_tokens": "Create database tables from sqlalchemy models", "label": 1}, {"idx": "cosqa-train-9810", "doc": "how to show area of shapes in an image python", "code": "def get_shape(img):\n    \"\"\"Return the shape of img.\n\n    Paramerers\n    -----------\n    img:\n\n    Returns\n    -------\n    shape: tuple\n    \"\"\"\n    if hasattr(img, 'shape'):\n        shape = img.shape\n    else:\n        shape = img.get_data().shape\n    return shape", "code_tokens": "def get_shape ( img ) : if hasattr ( img , 'shape' ) : shape = img . shape else : shape = img . get_data ( ) . shape return shape", "docstring_tokens": "Return the shape of img .", "label": 1}, {"idx": "cosqa-train-9811", "doc": "python sqlalchemy delete row", "code": "def locked_delete(self):\n        \"\"\"Delete credentials from the SQLAlchemy datastore.\"\"\"\n        filters = {self.key_name: self.key_value}\n        self.session.query(self.model_class).filter_by(**filters).delete()", "code_tokens": "def locked_delete ( self ) : filters = { self . key_name : self . key_value } self . session . query ( self . model_class ) . filter_by ( * * filters ) . delete ( )", "docstring_tokens": "Delete credentials from the SQLAlchemy datastore .", "label": 0}, {"idx": "cosqa-train-9812", "doc": "python sqlite build a dictonary", "code": "def sqliteRowsToDicts(sqliteRows):\n    \"\"\"\n    Unpacks sqlite rows as returned by fetchall\n    into an array of simple dicts.\n\n    :param sqliteRows: array of rows returned from fetchall DB call\n    :return:  array of dicts, keyed by the column names.\n    \"\"\"\n    return map(lambda r: dict(zip(r.keys(), r)), sqliteRows)", "code_tokens": "def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )", "docstring_tokens": "Unpacks sqlite rows as returned by fetchall into an array of simple dicts .", "label": 0}, {"idx": "cosqa-train-9813", "doc": "how to show error msg in else python", "code": "def print_error(msg):\n    \"\"\" Print an error message \"\"\"\n    if IS_POSIX:\n        print(u\"%s[ERRO] %s%s\" % (ANSI_ERROR, msg, ANSI_END))\n    else:\n        print(u\"[ERRO] %s\" % (msg))", "code_tokens": "def print_error ( msg ) : if IS_POSIX : print ( u\"%s[ERRO] %s%s\" % ( ANSI_ERROR , msg , ANSI_END ) ) else : print ( u\"[ERRO] %s\" % ( msg ) )", "docstring_tokens": "Print an error message", "label": 1}, {"idx": "cosqa-train-9814", "doc": "python square but keep negative", "code": "def Softsign(a):\n    \"\"\"\n    Softsign op.\n    \"\"\"\n    return np.divide(a, np.add(np.abs(a), 1)),", "code_tokens": "def Softsign ( a ) : return np . divide ( a , np . add ( np . abs ( a ) , 1 ) ) ,", "docstring_tokens": "Softsign op .", "label": 0}, {"idx": "cosqa-train-9815", "doc": "how to show progress bar in python for some code", "code": "def progressbar(total, pos, msg=\"\"):\n    \"\"\"\n    Given a total and a progress position, output a progress bar\n    to stderr. It is important to not output anything else while\n    using this, as it relies soley on the behavior of carriage\n    return (\\\\r).\n\n    Can also take an optioal message to add after the\n    progressbar. It must not contain newlines.\n\n    The progress bar will look something like this:\n\n    [099/500][=========...............................] ETA: 13:36:59\n\n    Of course, the ETA part should be supplied be the calling\n    function.\n    \"\"\"\n    width = get_terminal_size()[0] - 40\n    rel_pos = int(float(pos) / total * width)\n    bar = ''.join([\"=\" * rel_pos, \".\" * (width - rel_pos)])\n\n    # Determine how many digits in total (base 10)\n    digits_total = len(str(total))\n    fmt_width = \"%0\" + str(digits_total) + \"d\"\n    fmt = \"\\r[\" + fmt_width + \"/\" + fmt_width + \"][%s] %s\"\n\n    progress_stream.write(fmt % (pos, total, bar, msg))", "code_tokens": "def progressbar ( total , pos , msg = \"\" ) : width = get_terminal_size ( ) [ 0 ] - 40 rel_pos = int ( float ( pos ) / total * width ) bar = '' . join ( [ \"=\" * rel_pos , \".\" * ( width - rel_pos ) ] ) # Determine how many digits in total (base 10) digits_total = len ( str ( total ) ) fmt_width = \"%0\" + str ( digits_total ) + \"d\" fmt = \"\\r[\" + fmt_width + \"/\" + fmt_width + \"][%s] %s\" progress_stream . write ( fmt % ( pos , total , bar , msg ) )", "docstring_tokens": "Given a total and a progress position output a progress bar to stderr . It is important to not output anything else while using this as it relies soley on the behavior of carriage return ( \\\\ r ) .", "label": 0}, {"idx": "cosqa-train-9816", "doc": "python ssh stdin is not a tty", "code": "def intty(cls):\n        \"\"\" Check if we are in a tty. \"\"\"\n        # XXX: temporary hack until we can detect if we are in a pipe or not\n        return True\n\n        if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty():\n            return True\n\n        return False", "code_tokens": "def intty ( cls ) : # XXX: temporary hack until we can detect if we are in a pipe or not return True if hasattr ( sys . stdout , 'isatty' ) and sys . stdout . isatty ( ) : return True return False", "docstring_tokens": "Check if we are in a tty .", "label": 1}, {"idx": "cosqa-train-9817", "doc": "how to show shape of a variable in python", "code": "def get_grid_spatial_dimensions(self, variable):\n        \"\"\"Returns (width, height) for the given variable\"\"\"\n\n        data = self.open_dataset(self.service).variables[variable.variable]\n        dimensions = list(data.dimensions)\n        return data.shape[dimensions.index(variable.x_dimension)], data.shape[dimensions.index(variable.y_dimension)]", "code_tokens": "def get_grid_spatial_dimensions ( self , variable ) : data = self . open_dataset ( self . service ) . variables [ variable . variable ] dimensions = list ( data . dimensions ) return data . shape [ dimensions . index ( variable . x_dimension ) ] , data . shape [ dimensions . index ( variable . y_dimension ) ]", "docstring_tokens": "Returns ( width height ) for the given variable", "label": 1}, {"idx": "cosqa-train-9818", "doc": "python stack information accessing caller's variables", "code": "def extract_module_locals(depth=0):\n    \"\"\"Returns (module, locals) of the funciton `depth` frames away from the caller\"\"\"\n    f = sys._getframe(depth + 1)\n    global_ns = f.f_globals\n    module = sys.modules[global_ns['__name__']]\n    return (module, f.f_locals)", "code_tokens": "def extract_module_locals ( depth = 0 ) : f = sys . _getframe ( depth + 1 ) global_ns = f . f_globals module = sys . modules [ global_ns [ '__name__' ] ] return ( module , f . f_locals )", "docstring_tokens": "Returns ( module locals ) of the funciton depth frames away from the caller", "label": 1}, {"idx": "cosqa-train-9819", "doc": "how to show spectogram in python", "code": "def show(self, title=''):\n        \"\"\"\n        Display Bloch sphere and corresponding data sets.\n        \"\"\"\n        self.render(title=title)\n        if self.fig:\n            plt.show(self.fig)", "code_tokens": "def show ( self , title = '' ) : self . render ( title = title ) if self . fig : plt . show ( self . fig )", "docstring_tokens": "Display Bloch sphere and corresponding data sets .", "label": 0}, {"idx": "cosqa-train-9820", "doc": "python stack on list of columns", "code": "def column_stack_2d(data):\n    \"\"\"Perform column-stacking on a list of 2d data blocks.\"\"\"\n    return list(list(itt.chain.from_iterable(_)) for _ in zip(*data))", "code_tokens": "def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )", "docstring_tokens": "Perform column - stacking on a list of 2d data blocks .", "label": 0}, {"idx": "cosqa-train-9821", "doc": "how to show text on edge in networkx python", "code": "def info(docgraph):\n    \"\"\"print node and edge statistics of a document graph\"\"\"\n    print networkx.info(docgraph), '\\n'\n    node_statistics(docgraph)\n    print\n    edge_statistics(docgraph)", "code_tokens": "def info ( docgraph ) : print networkx . info ( docgraph ) , '\\n' node_statistics ( docgraph ) print edge_statistics ( docgraph )", "docstring_tokens": "print node and edge statistics of a document graph", "label": 0}, {"idx": "cosqa-train-9822", "doc": "python standard deviation function numpy", "code": "def _std(self,x):\n        \"\"\"\n        Compute standard deviation with ddof degrees of freedom\n        \"\"\"\n        return np.nanstd(x.values,ddof=self._ddof)", "code_tokens": "def _std ( self , x ) : return np . nanstd ( x . values , ddof = self . _ddof )", "docstring_tokens": "Compute standard deviation with ddof degrees of freedom", "label": 0}, {"idx": "cosqa-train-9823", "doc": "how to show type in python", "code": "def getTypeStr(_type):\n  r\"\"\"Gets the string representation of the given type.\n  \"\"\"\n  if isinstance(_type, CustomType):\n    return str(_type)\n\n  if hasattr(_type, '__name__'):\n    return _type.__name__\n\n  return ''", "code_tokens": "def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''", "docstring_tokens": "r Gets the string representation of the given type .", "label": 1}, {"idx": "cosqa-train-9824", "doc": "python standard deviation of a signal", "code": "def circstd(dts, axis=2):\n    \"\"\"Circular standard deviation\"\"\"\n    R = np.abs(np.exp(1.0j * dts).mean(axis=axis))\n    return np.sqrt(-2.0 * np.log(R))", "code_tokens": "def circstd ( dts , axis = 2 ) : R = np . abs ( np . exp ( 1.0j * dts ) . mean ( axis = axis ) ) return np . sqrt ( - 2.0 * np . log ( R ) )", "docstring_tokens": "Circular standard deviation", "label": 0}, {"idx": "cosqa-train-9825", "doc": "how to show x axis clear in mathplot python in scatterplot", "code": "def clear_matplotlib_ticks(self, axis=\"both\"):\n        \"\"\"Clears the default matplotlib ticks.\"\"\"\n        ax = self.get_axes()\n        plotting.clear_matplotlib_ticks(ax=ax, axis=axis)", "code_tokens": "def clear_matplotlib_ticks ( self , axis = \"both\" ) : ax = self . get_axes ( ) plotting . clear_matplotlib_ticks ( ax = ax , axis = axis )", "docstring_tokens": "Clears the default matplotlib ticks .", "label": 0}, {"idx": "cosqa-train-9826", "doc": "python stdin read blocking", "code": "def _read_stdin():\n    \"\"\"\n    Generator for reading from standard input in nonblocking mode.\n\n    Other ways of reading from ``stdin`` in python waits, until the buffer is\n    big enough, or until EOF character is sent.\n\n    This functions yields immediately after each line.\n    \"\"\"\n    line = sys.stdin.readline()\n    while line:\n        yield line\n        line = sys.stdin.readline()", "code_tokens": "def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )", "docstring_tokens": "Generator for reading from standard input in nonblocking mode .", "label": 1}, {"idx": "cosqa-train-9827", "doc": "how to shuffle all arrays the same way python", "code": "def _shuffle(data, idx):\n    \"\"\"Shuffle the data.\"\"\"\n    shuffle_data = []\n\n    for idx_k, idx_v in data:\n        shuffle_data.append((idx_k, mx.ndarray.array(idx_v.asnumpy()[idx], idx_v.context)))\n\n    return shuffle_data", "code_tokens": "def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data", "docstring_tokens": "Shuffle the data .", "label": 0}, {"idx": "cosqa-train-9828", "doc": "python stdout to screen", "code": "def _stdout_raw(self, s):\n        \"\"\"Writes the string to stdout\"\"\"\n        print(s, end='', file=sys.stdout)\n        sys.stdout.flush()", "code_tokens": "def _stdout_raw ( self , s ) : print ( s , end = '' , file = sys . stdout ) sys . stdout . flush ( )", "docstring_tokens": "Writes the string to stdout", "label": 0}, {"idx": "cosqa-train-9829", "doc": "how to shut down proccess in linux with python code", "code": "def stop(pid):\n    \"\"\"Shut down a specific process.\n\n    Args:\n      pid: the pid of the process to shutdown.\n    \"\"\"\n    if psutil.pid_exists(pid):\n      try:\n        p = psutil.Process(pid)\n        p.kill()\n      except Exception:\n        pass", "code_tokens": "def stop ( pid ) : if psutil . pid_exists ( pid ) : try : p = psutil . Process ( pid ) p . kill ( ) except Exception : pass", "docstring_tokens": "Shut down a specific process .", "label": 1}, {"idx": "cosqa-train-9830", "doc": "python stop celery task", "code": "def stop_containers(self):\n        \"\"\" Stops all containers used by this instance of the backend.\n        \"\"\"\n        while len(self._containers):\n            container = self._containers.pop()\n            try:\n                container.kill(signal.SIGKILL)\n            except docker.errors.APIError:  # probably doesn't exist anymore\n                pass", "code_tokens": "def stop_containers ( self ) : while len ( self . _containers ) : container = self . _containers . pop ( ) try : container . kill ( signal . SIGKILL ) except docker . errors . APIError : # probably doesn't exist anymore pass", "docstring_tokens": "Stops all containers used by this instance of the backend .", "label": 1}, {"idx": "cosqa-train-9831", "doc": "how to slice column python", "code": "def getcolslice(self, blc, trc, inc=[], startrow=0, nrow=-1, rowincr=1):\n        \"\"\"Get a slice from a table column holding arrays.\n        (see :func:`table.getcolslice`)\"\"\"\n        return self._table.getcolslice(self._column, blc, trc, inc, startrow, nrow, rowincr)", "code_tokens": "def getcolslice ( self , blc , trc , inc = [ ] , startrow = 0 , nrow = - 1 , rowincr = 1 ) : return self . _table . getcolslice ( self . _column , blc , trc , inc , startrow , nrow , rowincr )", "docstring_tokens": "Get a slice from a table column holding arrays . ( see : func : table . getcolslice )", "label": 1}, {"idx": "cosqa-train-9832", "doc": "python stops working with tensorflow", "code": "def unit_ball_L2(shape):\n  \"\"\"A tensorflow variable tranfomed to be constrained in a L2 unit ball.\n\n  EXPERIMENTAL: Do not use for adverserial examples if you need to be confident\n  they are strong attacks. We are not yet confident in this code.\n  \"\"\"\n  x = tf.Variable(tf.zeros(shape))\n  return constrain_L2(x)", "code_tokens": "def unit_ball_L2 ( shape ) : x = tf . Variable ( tf . zeros ( shape ) ) return constrain_L2 ( x )", "docstring_tokens": "A tensorflow variable tranfomed to be constrained in a L2 unit ball .", "label": 0}, {"idx": "cosqa-train-9833", "doc": "how to smooth function in python", "code": "def smooth_array(array, amount=1):\n    \"\"\"\n\n    Returns the nearest-neighbor (+/- amount) smoothed array.\n    This does not modify the array or slice off the funny end points.\n\n    \"\"\"\n    if amount==0: return array\n\n    # we have to store the old values in a temp array to keep the\n    # smoothing from affecting the smoothing\n    new_array = _n.array(array)\n\n    for n in range(len(array)):\n        new_array[n] = smooth(array, n, amount)\n\n    return new_array", "code_tokens": "def smooth_array ( array , amount = 1 ) : if amount == 0 : return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n . array ( array ) for n in range ( len ( array ) ) : new_array [ n ] = smooth ( array , n , amount ) return new_array", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-9834", "doc": "python store files in s3 buckets and retrieve files from aws s3 buckets", "code": "def s3(ctx, bucket_name, data_file, region):\n    \"\"\"Use the S3 SWAG backend.\"\"\"\n    if not ctx.data_file:\n        ctx.data_file = data_file\n\n    if not ctx.bucket_name:\n        ctx.bucket_name = bucket_name\n\n    if not ctx.region:\n        ctx.region = region\n\n    ctx.type = 's3'", "code_tokens": "def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'", "docstring_tokens": "Use the S3 SWAG backend .", "label": 0}, {"idx": "cosqa-train-9835", "doc": "how to sort a list in alphabetic order python", "code": "def natural_sort(list, key=lambda s:s):\n    \"\"\"\n    Sort the list into natural alphanumeric order.\n    \"\"\"\n    def get_alphanum_key_func(key):\n        convert = lambda text: int(text) if text.isdigit() else text\n        return lambda s: [convert(c) for c in re.split('([0-9]+)', key(s))]\n    sort_key = get_alphanum_key_func(key)\n    list.sort(key=sort_key)", "code_tokens": "def natural_sort ( list , key = lambda s : s ) : def get_alphanum_key_func ( key ) : convert = lambda text : int ( text ) if text . isdigit ( ) else text return lambda s : [ convert ( c ) for c in re . split ( '([0-9]+)' , key ( s ) ) ] sort_key = get_alphanum_key_func ( key ) list . sort ( key = sort_key )", "docstring_tokens": "Sort the list into natural alphanumeric order .", "label": 1}, {"idx": "cosqa-train-9836", "doc": "python str to object reference eval", "code": "def get_obj(ref):\n    \"\"\"Get object from string reference.\"\"\"\n    oid = int(ref)\n    return server.id2ref.get(oid) or server.id2obj[oid]", "code_tokens": "def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]", "docstring_tokens": "Get object from string reference .", "label": 1}, {"idx": "cosqa-train-9837", "doc": "how to sorted python list self", "code": "def sort_by_name(self):\n        \"\"\"Sort list elements by name.\"\"\"\n        super(JSSObjectList, self).sort(key=lambda k: k.name)", "code_tokens": "def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )", "docstring_tokens": "Sort list elements by name .", "label": 0}, {"idx": "cosqa-train-9838", "doc": "python stream json to a file", "code": "def _serialize_json(obj, fp):\n    \"\"\" Serialize ``obj`` as a JSON formatted stream to ``fp`` \"\"\"\n    json.dump(obj, fp, indent=4, default=serialize)", "code_tokens": "def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )", "docstring_tokens": "Serialize obj as a JSON formatted stream to fp", "label": 1}, {"idx": "cosqa-train-9839", "doc": "how to specify distance metric for k means in python", "code": "def get_distance(F, x):\n    \"\"\"Helper function for margin-based loss. Return a distance matrix given a matrix.\"\"\"\n    n = x.shape[0]\n\n    square = F.sum(x ** 2.0, axis=1, keepdims=True)\n    distance_square = square + square.transpose() - (2.0 * F.dot(x, x.transpose()))\n\n    # Adding identity to make sqrt work.\n    return F.sqrt(distance_square + F.array(np.identity(n)))", "code_tokens": "def get_distance ( F , x ) : n = x . shape [ 0 ] square = F . sum ( x ** 2.0 , axis = 1 , keepdims = True ) distance_square = square + square . transpose ( ) - ( 2.0 * F . dot ( x , x . transpose ( ) ) ) # Adding identity to make sqrt work. return F . sqrt ( distance_square + F . array ( np . identity ( n ) ) )", "docstring_tokens": "Helper function for margin - based loss . Return a distance matrix given a matrix .", "label": 0}, {"idx": "cosqa-train-9840", "doc": "python string converstions dictionary", "code": "def str_dict(some_dict):\n    \"\"\"Convert dict of ascii str/unicode to dict of str, if necessary\"\"\"\n    return {str(k): str(v) for k, v in some_dict.items()}", "code_tokens": "def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }", "docstring_tokens": "Convert dict of ascii str / unicode to dict of str if necessary", "label": 0}, {"idx": "cosqa-train-9841", "doc": "how to split large list to small lists in python", "code": "def chunked(l, n):\n    \"\"\"Chunk one big list into few small lists.\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunked ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Chunk one big list into few small lists .", "label": 0}, {"idx": "cosqa-train-9842", "doc": "python string for path on windows", "code": "def escapePathForShell(path):\n\t\t\"\"\"\n\t\tEscapes a filesystem path for use as a command-line argument\n\t\t\"\"\"\n\t\tif platform.system() == 'Windows':\n\t\t\treturn '\"{}\"'.format(path.replace('\"', '\"\"'))\n\t\telse:\n\t\t\treturn shellescape.quote(path)", "code_tokens": "def escapePathForShell ( path ) : if platform . system ( ) == 'Windows' : return '\"{}\"' . format ( path . replace ( '\"' , '\"\"' ) ) else : return shellescape . quote ( path )", "docstring_tokens": "Escapes a filesystem path for use as a command - line argument", "label": 1}, {"idx": "cosqa-train-9843", "doc": "how to split the iterator object into chunks python", "code": "def chunks(iterable, size=1):\n    \"\"\"Splits iterator in chunks.\"\"\"\n    iterator = iter(iterable)\n\n    for element in iterator:\n        yield chain([element], islice(iterator, size - 1))", "code_tokens": "def chunks ( iterable , size = 1 ) : iterator = iter ( iterable ) for element in iterator : yield chain ( [ element ] , islice ( iterator , size - 1 ) )", "docstring_tokens": "Splits iterator in chunks .", "label": 1}, {"idx": "cosqa-train-9844", "doc": "python string hamming distance fast", "code": "def hamming(s, t):\n    \"\"\"\n    Calculate the Hamming distance between two strings. From Wikipedia article: Iterative with two matrix rows.\n\n    :param s: string 1\n    :type s: str\n    :param t: string 2\n    :type s: str\n    :return: Hamming distance\n    :rtype: float\n    \"\"\"\n    if len(s) != len(t):\n        raise ValueError('Hamming distance needs strings of equal length.')\n    return sum(s_ != t_ for s_, t_ in zip(s, t))", "code_tokens": "def hamming ( s , t ) : if len ( s ) != len ( t ) : raise ValueError ( 'Hamming distance needs strings of equal length.' ) return sum ( s_ != t_ for s_ , t_ in zip ( s , t ) )", "docstring_tokens": "Calculate the Hamming distance between two strings . From Wikipedia article : Iterative with two matrix rows .", "label": 1}, {"idx": "cosqa-train-9845", "doc": "how to split words in a list in python", "code": "def tokenize_list(self, text):\n        \"\"\"\n        Split a text into separate words.\n        \"\"\"\n        return [self.get_record_token(record) for record in self.analyze(text)]", "code_tokens": "def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]", "docstring_tokens": "Split a text into separate words .", "label": 0}, {"idx": "cosqa-train-9846", "doc": "python string is bool", "code": "def FromString(self, string):\n    \"\"\"Parse a bool from a string.\"\"\"\n    if string.lower() in (\"false\", \"no\", \"n\"):\n      return False\n\n    if string.lower() in (\"true\", \"yes\", \"y\"):\n      return True\n\n    raise TypeValueError(\"%s is not recognized as a boolean value.\" % string)", "code_tokens": "def FromString ( self , string ) : if string . lower ( ) in ( \"false\" , \"no\" , \"n\" ) : return False if string . lower ( ) in ( \"true\" , \"yes\" , \"y\" ) : return True raise TypeValueError ( \"%s is not recognized as a boolean value.\" % string )", "docstring_tokens": "Parse a bool from a string .", "label": 1}, {"idx": "cosqa-train-9847", "doc": "how to sql escape string python", "code": "def _escape(s):\n    \"\"\" Helper method that escapes parameters to a SQL query. \"\"\"\n    e = s\n    e = e.replace('\\\\', '\\\\\\\\')\n    e = e.replace('\\n', '\\\\n')\n    e = e.replace('\\r', '\\\\r')\n    e = e.replace(\"'\", \"\\\\'\")\n    e = e.replace('\"', '\\\\\"')\n    return e", "code_tokens": "def _escape ( s ) : e = s e = e . replace ( '\\\\' , '\\\\\\\\' ) e = e . replace ( '\\n' , '\\\\n' ) e = e . replace ( '\\r' , '\\\\r' ) e = e . replace ( \"'\" , \"\\\\'\" ) e = e . replace ( '\"' , '\\\\\"' ) return e", "docstring_tokens": "Helper method that escapes parameters to a SQL query .", "label": 0}, {"idx": "cosqa-train-9848", "doc": "python string of bytes to numpy", "code": "def convert_array(array):\n    \"\"\"\n    Converts an ARRAY string stored in the database back into a Numpy array.\n\n    Parameters\n    ----------\n    array: ARRAY\n        The array object to be converted back into a Numpy array.\n\n    Returns\n    -------\n    array\n            The converted Numpy array.\n\n    \"\"\"\n    out = io.BytesIO(array)\n    out.seek(0)\n    return np.load(out)", "code_tokens": "def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )", "docstring_tokens": "Converts an ARRAY string stored in the database back into a Numpy array .", "label": 0}, {"idx": "cosqa-train-9849", "doc": "how to standardize an array in python", "code": "def normalize_array(lst):\n    \"\"\"Normalizes list\n\n    :param lst: Array of floats\n    :return: Normalized (in [0, 1]) input array\n    \"\"\"\n    np_arr = np.array(lst)\n    x_normalized = np_arr / np_arr.max(axis=0)\n    return list(x_normalized)", "code_tokens": "def normalize_array ( lst ) : np_arr = np . array ( lst ) x_normalized = np_arr / np_arr . max ( axis = 0 ) return list ( x_normalized )", "docstring_tokens": "Normalizes list", "label": 1}, {"idx": "cosqa-train-9850", "doc": "python string remove substring at begin", "code": "def _clip(sid, prefix):\n    \"\"\"Clips a prefix from the beginning of a string if it exists.\"\"\"\n    return sid[len(prefix):] if sid.startswith(prefix) else sid", "code_tokens": "def _clip ( sid , prefix ) : return sid [ len ( prefix ) : ] if sid . startswith ( prefix ) else sid", "docstring_tokens": "Clips a prefix from the beginning of a string if it exists .", "label": 1}, {"idx": "cosqa-train-9851", "doc": "how to stop asking for input python", "code": "def pause(msg=\"Press Enter to Continue...\"):\n    \"\"\"press to continue\"\"\"\n    print('\\n' + Fore.YELLOW + msg + Fore.RESET, end='')\n    input()", "code_tokens": "def pause ( msg = \"Press Enter to Continue...\" ) : print ( '\\n' + Fore . YELLOW + msg + Fore . RESET , end = '' ) input ( )", "docstring_tokens": "press to continue", "label": 1}, {"idx": "cosqa-train-9852", "doc": "python string split to small chunks", "code": "def schunk(string, size):\n    \"\"\"Splits string into n sized chunks.\"\"\"\n    return [string[i:i+size] for i in range(0, len(string), size)]", "code_tokens": "def schunk ( string , size ) : return [ string [ i : i + size ] for i in range ( 0 , len ( string ) , size ) ]", "docstring_tokens": "Splits string into n sized chunks .", "label": 1}, {"idx": "cosqa-train-9853", "doc": "how to stop function after attempts in python", "code": "def retry_on_signal(function):\n    \"\"\"Retries function until it doesn't raise an EINTR error\"\"\"\n    while True:\n        try:\n            return function()\n        except EnvironmentError, e:\n            if e.errno != errno.EINTR:\n                raise", "code_tokens": "def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise", "docstring_tokens": "Retries function until it doesn t raise an EINTR error", "label": 1}, {"idx": "cosqa-train-9854", "doc": "python string strip whitespace docs", "code": "def format_doc_text(text):\n    \"\"\"\n    A very thin wrapper around textwrap.fill to consistently wrap documentation text\n    for display in a command line environment. The text is wrapped to 99 characters with an\n    indentation depth of 4 spaces. Each line is wrapped independently in order to preserve\n    manually added line breaks.\n\n    :param text: The text to format, it is cleaned by inspect.cleandoc.\n    :return: The formatted doc text.\n    \"\"\"\n\n    return '\\n'.join(\n        textwrap.fill(line, width=99, initial_indent='    ', subsequent_indent='    ')\n        for line in inspect.cleandoc(text).splitlines())", "code_tokens": "def format_doc_text ( text ) : return '\\n' . join ( textwrap . fill ( line , width = 99 , initial_indent = '    ' , subsequent_indent = '    ' ) for line in inspect . cleandoc ( text ) . splitlines ( ) )", "docstring_tokens": "A very thin wrapper around textwrap . fill to consistently wrap documentation text for display in a command line environment . The text is wrapped to 99 characters with an indentation depth of 4 spaces . Each line is wrapped independently in order to preserve manually added line breaks .", "label": 1}, {"idx": "cosqa-train-9855", "doc": "how to stop python pool gracefully with keyboard inturrupt", "code": "def terminate(self):\n        \"\"\"Terminate the pool immediately.\"\"\"\n        if self._pool is not None:\n            self._pool.terminate()\n            self._pool.join()\n            self._pool = None", "code_tokens": "def terminate ( self ) : if self . _pool is not None : self . _pool . terminate ( ) self . _pool . join ( ) self . _pool = None", "docstring_tokens": "Terminate the pool immediately .", "label": 1}, {"idx": "cosqa-train-9856", "doc": "python string to ctype", "code": "def c_str(string):\n    \"\"\"\"Convert a python string to C string.\"\"\"\n    if not isinstance(string, str):\n        string = string.decode('ascii')\n    return ctypes.c_char_p(string.encode('utf-8'))", "code_tokens": "def c_str ( string ) : if not isinstance ( string , str ) : string = string . decode ( 'ascii' ) return ctypes . c_char_p ( string . encode ( 'utf-8' ) )", "docstring_tokens": "Convert a python string to C string .", "label": 1}, {"idx": "cosqa-train-9857", "doc": "how to stop streaming data python", "code": "def stop(self):\n        \"\"\"Stop stream.\"\"\"\n        if self.stream and self.stream.session.state != STATE_STOPPED:\n            self.stream.stop()", "code_tokens": "def stop ( self ) : if self . stream and self . stream . session . state != STATE_STOPPED : self . stream . stop ( )", "docstring_tokens": "Stop stream .", "label": 1}, {"idx": "cosqa-train-9858", "doc": "python strip ' ' from list", "code": "def clean_strings(iterable):\n    \"\"\"\n    Take a list of strings and clear whitespace \n    on each one. If a value in the list is not a \n    string pass it through untouched.\n\n    Args:\n        iterable: mixed list\n\n    Returns: \n        mixed list\n    \"\"\"\n    retval = []\n    for val in iterable:\n        try:\n            retval.append(val.strip())\n        except(AttributeError):\n            retval.append(val)\n    return retval", "code_tokens": "def clean_strings ( iterable ) : retval = [ ] for val in iterable : try : retval . append ( val . strip ( ) ) except ( AttributeError ) : retval . append ( val ) return retval", "docstring_tokens": "Take a list of strings and clear whitespace on each one . If a value in the list is not a string pass it through untouched .", "label": 1}, {"idx": "cosqa-train-9859", "doc": "how to strip quotes from a list of strings in python", "code": "def delimited(items, character='|'):\n    \"\"\"Returns a character delimited version of the provided list as a Python string\"\"\"\n    return '|'.join(items) if type(items) in (list, tuple, set) else items", "code_tokens": "def delimited ( items , character = '|' ) : return '|' . join ( items ) if type ( items ) in ( list , tuple , set ) else items", "docstring_tokens": "Returns a character delimited version of the provided list as a Python string", "label": 1}, {"idx": "cosqa-train-9860", "doc": "python subplot2grid x limit only", "code": "def set_xlimits(self, row, column, min=None, max=None):\n        \"\"\"Set x-axis limits of a subplot.\n\n        :param row,column: specify the subplot.\n        :param min: minimal axis value\n        :param max: maximum axis value\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_xlimits(min, max)", "code_tokens": "def set_xlimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_xlimits ( min , max )", "docstring_tokens": "Set x - axis limits of a subplot .", "label": 1}, {"idx": "cosqa-train-9861", "doc": "how to take a transpose of a matrix python", "code": "def transpose(table):\n    \"\"\"\n    transpose matrix\n    \"\"\"\n    t = []\n    for i in range(0, len(table[0])):\n        t.append([row[i] for row in table])\n    return t", "code_tokens": "def transpose ( table ) : t = [ ] for i in range ( 0 , len ( table [ 0 ] ) ) : t . append ( [ row [ i ] for row in table ] ) return t", "docstring_tokens": "transpose matrix", "label": 1}, {"idx": "cosqa-train-9862", "doc": "python subprocess run command in background", "code": "def execute_in_background(self):\n        \"\"\"Executes a (shell) command in the background\n\n        :return: the process' pid\n        \"\"\"\n        # http://stackoverflow.com/questions/1605520\n        args = shlex.split(self.cmd)\n        p = Popen(args)\n        return p.pid", "code_tokens": "def execute_in_background ( self ) : # http://stackoverflow.com/questions/1605520 args = shlex . split ( self . cmd ) p = Popen ( args ) return p . pid", "docstring_tokens": "Executes a ( shell ) command in the background", "label": 0}, {"idx": "cosqa-train-9863", "doc": "how to take input from stdin in python", "code": "def standard_input():\n    \"\"\"Generator that yields lines from standard input.\"\"\"\n    with click.get_text_stream(\"stdin\") as stdin:\n        while stdin.readable():\n            line = stdin.readline()\n            if line:\n                yield line.strip().encode(\"utf-8\")", "code_tokens": "def standard_input ( ) : with click . get_text_stream ( \"stdin\" ) as stdin : while stdin . readable ( ) : line = stdin . readline ( ) if line : yield line . strip ( ) . encode ( \"utf-8\" )", "docstring_tokens": "Generator that yields lines from standard input .", "label": 1}, {"idx": "cosqa-train-9864", "doc": "python subprocess send stdin", "code": "def correspond(text):\n    \"\"\"Communicate with the child process without closing stdin.\"\"\"\n    subproc.stdin.write(text)\n    subproc.stdin.flush()\n    return drain()", "code_tokens": "def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )", "docstring_tokens": "Communicate with the child process without closing stdin .", "label": 0}, {"idx": "cosqa-train-9865", "doc": "how to tell if a file line is blank in python", "code": "def file_empty(fp):\n    \"\"\"Determine if a file is empty or not.\"\"\"\n    # for python 2 we need to use a homemade peek()\n    if six.PY2:\n        contents = fp.read()\n        fp.seek(0)\n        return not bool(contents)\n\n    else:\n        return not fp.peek()", "code_tokens": "def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )", "docstring_tokens": "Determine if a file is empty or not .", "label": 0}, {"idx": "cosqa-train-9866", "doc": "python substract timedelta from datetime64", "code": "def datetime64_to_datetime(dt):\n    \"\"\" convert numpy's datetime64 to datetime \"\"\"\n    dt64 = np.datetime64(dt)\n    ts = (dt64 - np.datetime64('1970-01-01T00:00:00')) / np.timedelta64(1, 's')\n    return datetime.datetime.utcfromtimestamp(ts)", "code_tokens": "def datetime64_to_datetime ( dt ) : dt64 = np . datetime64 ( dt ) ts = ( dt64 - np . datetime64 ( '1970-01-01T00:00:00' ) ) / np . timedelta64 ( 1 , 's' ) return datetime . datetime . utcfromtimestamp ( ts )", "docstring_tokens": "convert numpy s datetime64 to datetime", "label": 0}, {"idx": "cosqa-train-9867", "doc": "how to tell if a python script has admin privaliges", "code": "def is_admin(self):\n        \"\"\"Is the user a system administrator\"\"\"\n        return self.role == self.roles.administrator.value and self.state == State.approved", "code_tokens": "def is_admin ( self ) : return self . role == self . roles . administrator . value and self . state == State . approved", "docstring_tokens": "Is the user a system administrator", "label": 0}, {"idx": "cosqa-train-9868", "doc": "python substring index of", "code": "def get_substring_idxs(substr, string):\n    \"\"\"\n    Return a list of indexes of substr. If substr not found, list is\n    empty.\n\n    Arguments:\n        substr (str): Substring to match.\n        string (str): String to match in.\n\n    Returns:\n        list of int: Start indices of substr.\n    \"\"\"\n    return [match.start() for match in re.finditer(substr, string)]", "code_tokens": "def get_substring_idxs ( substr , string ) : return [ match . start ( ) for match in re . finditer ( substr , string ) ]", "docstring_tokens": "Return a list of indexes of substr . If substr not found list is empty .", "label": 1}, {"idx": "cosqa-train-9869", "doc": "how to tell if a string contains something python", "code": "def is_identifier(string):\n    \"\"\"Check if string could be a valid python identifier\n\n    :param string: string to be tested\n    :returns: True if string can be a python identifier, False otherwise\n    :rtype: bool\n    \"\"\"\n    matched = PYTHON_IDENTIFIER_RE.match(string)\n    return bool(matched) and not keyword.iskeyword(string)", "code_tokens": "def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )", "docstring_tokens": "Check if string could be a valid python identifier", "label": 1}, {"idx": "cosqa-train-9870", "doc": "python switch on enum type", "code": "def is_enum_type(type_):\n    \"\"\" Checks if the given type is an enum type.\n\n    :param type_: The type to check\n    :return: True if the type is a enum type, otherwise False\n    :rtype: bool\n    \"\"\"\n\n    return isinstance(type_, type) and issubclass(type_, tuple(_get_types(Types.ENUM)))", "code_tokens": "def is_enum_type ( type_ ) : return isinstance ( type_ , type ) and issubclass ( type_ , tuple ( _get_types ( Types . ENUM ) ) )", "docstring_tokens": "Checks if the given type is an enum type .", "label": 1}, {"idx": "cosqa-train-9871", "doc": "how to tell if its an email using regex python", "code": "def is_valid_email(email):\n    \"\"\"\n    Check if email is valid\n    \"\"\"\n    pattern = re.compile(r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+')\n    return bool(pattern.match(email))", "code_tokens": "def is_valid_email ( email ) : pattern = re . compile ( r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+' ) return bool ( pattern . match ( email ) )", "docstring_tokens": "Check if email is valid", "label": 1}, {"idx": "cosqa-train-9872", "doc": "python syntax to access the memory address", "code": "def get_memory(self, mode):\n        \"\"\"Return a smt bit vector that represents a memory location.\n        \"\"\"\n        mem = {\n            \"pre\": self._translator.get_memory_init(),\n            \"post\": self._translator.get_memory_curr(),\n        }\n\n        return mem[mode]", "code_tokens": "def get_memory ( self , mode ) : mem = { \"pre\" : self . _translator . get_memory_init ( ) , \"post\" : self . _translator . get_memory_curr ( ) , } return mem [ mode ]", "docstring_tokens": "Return a smt bit vector that represents a memory location .", "label": 1}, {"idx": "cosqa-train-9873", "doc": "how to tell what type of data object is in python", "code": "def is_integer(obj):\n    \"\"\"Is this an integer.\n\n    :param object obj:\n    :return:\n    \"\"\"\n    if PYTHON3:\n        return isinstance(obj, int)\n    return isinstance(obj, (int, long))", "code_tokens": "def is_integer ( obj ) : if PYTHON3 : return isinstance ( obj , int ) return isinstance ( obj , ( int , long ) )", "docstring_tokens": "Is this an integer .", "label": 1}, {"idx": "cosqa-train-9874", "doc": "python sys argv append", "code": "def aug_sysargv(cmdstr):\n    \"\"\" DEBUG FUNC modify argv to look like you ran a command \"\"\"\n    import shlex\n    argv = shlex.split(cmdstr)\n    sys.argv.extend(argv)", "code_tokens": "def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )", "docstring_tokens": "DEBUG FUNC modify argv to look like you ran a command", "label": 1}, {"idx": "cosqa-train-9875", "doc": "how to test atexit python", "code": "def exit(exit_code=0):\n  r\"\"\"A function to support exiting from exit hooks.\n\n  Could also be used to exit from the calling scripts in a thread safe manner.\n  \"\"\"\n  core.processExitHooks()\n\n  if state.isExitHooked and not hasattr(sys, 'exitfunc'): # The function is called from the exit hook\n    sys.stderr.flush()\n    sys.stdout.flush()\n    os._exit(exit_code) #pylint: disable=W0212\n\n  sys.exit(exit_code)", "code_tokens": "def exit ( exit_code = 0 ) : core . processExitHooks ( ) if state . isExitHooked and not hasattr ( sys , 'exitfunc' ) : # The function is called from the exit hook sys . stderr . flush ( ) sys . stdout . flush ( ) os . _exit ( exit_code ) #pylint: disable=W0212 sys . exit ( exit_code )", "docstring_tokens": "r A function to support exiting from exit hooks .", "label": 1}, {"idx": "cosqa-train-9876", "doc": "python sys argv space in args", "code": "def aug_sysargv(cmdstr):\n    \"\"\" DEBUG FUNC modify argv to look like you ran a command \"\"\"\n    import shlex\n    argv = shlex.split(cmdstr)\n    sys.argv.extend(argv)", "code_tokens": "def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )", "docstring_tokens": "DEBUG FUNC modify argv to look like you ran a command", "label": 0}, {"idx": "cosqa-train-9877", "doc": "how to test if a list is sorted in python", "code": "def issorted(list_, op=operator.le):\n    \"\"\"\n    Determines if a list is sorted\n\n    Args:\n        list_ (list):\n        op (func): sorted operation (default=operator.le)\n\n    Returns:\n        bool : True if the list is sorted\n    \"\"\"\n    return all(op(list_[ix], list_[ix + 1]) for ix in range(len(list_) - 1))", "code_tokens": "def issorted ( list_ , op = operator . le ) : return all ( op ( list_ [ ix ] , list_ [ ix + 1 ] ) for ix in range ( len ( list_ ) - 1 ) )", "docstring_tokens": "Determines if a list is sorted", "label": 0}, {"idx": "cosqa-train-9878", "doc": "python sys stdin read enter", "code": "def read_stdin():\n    \"\"\" Read text from stdin, and print a helpful message for ttys. \"\"\"\n    if sys.stdin.isatty() and sys.stdout.isatty():\n        print('\\nReading from stdin until end of file (Ctrl + D)...')\n\n    return sys.stdin.read()", "code_tokens": "def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )", "docstring_tokens": "Read text from stdin and print a helpful message for ttys .", "label": 1}, {"idx": "cosqa-train-9879", "doc": "how to test if two arrays are equal python", "code": "def numpy_aware_eq(a, b):\n    \"\"\"Return whether two objects are equal via recursion, using\n    :func:`numpy.array_equal` for comparing numpy arays.\n    \"\"\"\n    if isinstance(a, np.ndarray) or isinstance(b, np.ndarray):\n        return np.array_equal(a, b)\n    if ((isinstance(a, Iterable) and isinstance(b, Iterable)) and\n            not isinstance(a, str) and not isinstance(b, str)):\n        if len(a) != len(b):\n            return False\n        return all(numpy_aware_eq(x, y) for x, y in zip(a, b))\n    return a == b", "code_tokens": "def numpy_aware_eq ( a , b ) : if isinstance ( a , np . ndarray ) or isinstance ( b , np . ndarray ) : return np . array_equal ( a , b ) if ( ( isinstance ( a , Iterable ) and isinstance ( b , Iterable ) ) and not isinstance ( a , str ) and not isinstance ( b , str ) ) : if len ( a ) != len ( b ) : return False return all ( numpy_aware_eq ( x , y ) for x , y in zip ( a , b ) ) return a == b", "docstring_tokens": "Return whether two objects are equal via recursion using : func : numpy . array_equal for comparing numpy arays .", "label": 1}, {"idx": "cosqa-train-9880", "doc": "python sys stdout write new line", "code": "def println(msg):\n    \"\"\"\n    Convenience function to print messages on a single line in the terminal\n    \"\"\"\n    sys.stdout.write(msg)\n    sys.stdout.flush()\n    sys.stdout.write('\\x08' * len(msg))\n    sys.stdout.flush()", "code_tokens": "def println ( msg ) : sys . stdout . write ( msg ) sys . stdout . flush ( ) sys . stdout . write ( '\\x08' * len ( msg ) ) sys . stdout . flush ( )", "docstring_tokens": "Convenience function to print messages on a single line in the terminal", "label": 1}, {"idx": "cosqa-train-9881", "doc": "how to test tensorflow python", "code": "def main(argv=None):\n  \"\"\"Run a Tensorflow model on the Iris dataset.\"\"\"\n  args = parse_arguments(sys.argv if argv is None else argv)\n\n  tf.logging.set_verbosity(tf.logging.INFO)\n  learn_runner.run(\n      experiment_fn=get_experiment_fn(args),\n      output_dir=args.job_dir)", "code_tokens": "def main ( argv = None ) : args = parse_arguments ( sys . argv if argv is None else argv ) tf . logging . set_verbosity ( tf . logging . INFO ) learn_runner . run ( experiment_fn = get_experiment_fn ( args ) , output_dir = args . job_dir )", "docstring_tokens": "Run a Tensorflow model on the Iris dataset .", "label": 0}, {"idx": "cosqa-train-9882", "doc": "python table into dictionary of lists", "code": "def row_to_dict(row):\n    \"\"\"Convert a table row to a dictionary.\"\"\"\n    o = {}\n    for colname in row.colnames:\n\n        if isinstance(row[colname], np.string_) and row[colname].dtype.kind in ['S', 'U']:\n            o[colname] = str(row[colname])\n        else:\n            o[colname] = row[colname]\n\n    return o", "code_tokens": "def row_to_dict ( row ) : o = { } for colname in row . colnames : if isinstance ( row [ colname ] , np . string_ ) and row [ colname ] . dtype . kind in [ 'S' , 'U' ] : o [ colname ] = str ( row [ colname ] ) else : o [ colname ] = row [ colname ] return o", "docstring_tokens": "Convert a table row to a dictionary .", "label": 1}, {"idx": "cosqa-train-9883", "doc": "how to transform a string in a float python", "code": "def energy_string_to_float( string ):\n    \"\"\"\n    Convert a string of a calculation energy, e.g. '-1.2345 eV' to a float.\n\n    Args:\n        string (str): The string to convert.\n  \n    Return\n        (float) \n    \"\"\"\n    energy_re = re.compile( \"(-?\\d+\\.\\d+)\" )\n    return float( energy_re.match( string ).group(0) )", "code_tokens": "def energy_string_to_float ( string ) : energy_re = re . compile ( \"(-?\\d+\\.\\d+)\" ) return float ( energy_re . match ( string ) . group ( 0 ) )", "docstring_tokens": "Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float .", "label": 1}, {"idx": "cosqa-train-9884", "doc": "python table select top row and column", "code": "def table_top_abs(self):\n        \"\"\"Returns the absolute position of table top\"\"\"\n        table_height = np.array([0, 0, self.table_full_size[2]])\n        return string_to_array(self.floor.get(\"pos\")) + table_height", "code_tokens": "def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( \"pos\" ) ) + table_height", "docstring_tokens": "Returns the absolute position of table top", "label": 0}, {"idx": "cosqa-train-9885", "doc": "how to traverse tree in python", "code": "def walk_tree(root):\n    \"\"\"Pre-order depth-first\"\"\"\n    yield root\n\n    for child in root.children:\n        for el in walk_tree(child):\n            yield el", "code_tokens": "def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el", "docstring_tokens": "Pre - order depth - first", "label": 1}, {"idx": "cosqa-train-9886", "doc": "python take n elements from list", "code": "def chunk_list(l, n):\n    \"\"\"Return `n` size lists from a given list `l`\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Return n size lists from a given list l", "label": 1}, {"idx": "cosqa-train-9887", "doc": "how to turn a range into a slice python", "code": "def make_slice_strings(cls, slice_key):\n        \"\"\"\n        Converts the given slice key to start and size query parts.\n        \"\"\"\n        start = slice_key.start\n        size = slice_key.stop - start\n        return (str(start), str(size))", "code_tokens": "def make_slice_strings ( cls , slice_key ) : start = slice_key . start size = slice_key . stop - start return ( str ( start ) , str ( size ) )", "docstring_tokens": "Converts the given slice key to start and size query parts .", "label": 0}, {"idx": "cosqa-train-9888", "doc": "python tell if is callable", "code": "def is_callable_tag(tag):\n    \"\"\" Determine whether :tag: is a valid callable string tag.\n\n    String is assumed to be valid callable if it starts with '{{'\n    and ends with '}}'.\n\n    :param tag: String name of tag.\n    \"\"\"\n    return (isinstance(tag, six.string_types) and\n            tag.strip().startswith('{{') and\n            tag.strip().endswith('}}'))", "code_tokens": "def is_callable_tag ( tag ) : return ( isinstance ( tag , six . string_types ) and tag . strip ( ) . startswith ( '{{' ) and tag . strip ( ) . endswith ( '}}' ) )", "docstring_tokens": "Determine whether : tag : is a valid callable string tag .", "label": 1}, {"idx": "cosqa-train-9889", "doc": "how to turn a string into a dictionary with values python", "code": "def list_string_to_dict(string):\n    \"\"\"Inputs ``['a', 'b', 'c']``, returns ``{'a': 0, 'b': 1, 'c': 2}``.\"\"\"\n    dictionary = {}\n    for idx, c in enumerate(string):\n        dictionary.update({c: idx})\n    return dictionary", "code_tokens": "def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary", "docstring_tokens": "Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } .", "label": 1}, {"idx": "cosqa-train-9890", "doc": "python tell windows or linux", "code": "def is_unix_style(flags):\n    \"\"\"Check if we should use Unix style.\"\"\"\n\n    return (util.platform() != \"windows\" or (not bool(flags & REALPATH) and get_case(flags))) and not flags & _FORCEWIN", "code_tokens": "def is_unix_style ( flags ) : return ( util . platform ( ) != \"windows\" or ( not bool ( flags & REALPATH ) and get_case ( flags ) ) ) and not flags & _FORCEWIN", "docstring_tokens": "Check if we should use Unix style .", "label": 1}, {"idx": "cosqa-train-9891", "doc": "how to turn array into a table python", "code": "def from_array(cls, arr):\n        \"\"\"Convert a structured NumPy array into a Table.\"\"\"\n        return cls().with_columns([(f, arr[f]) for f in arr.dtype.names])", "code_tokens": "def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )", "docstring_tokens": "Convert a structured NumPy array into a Table .", "label": 1}, {"idx": "cosqa-train-9892", "doc": "python tensorflow object detection gpu slow ingrestion", "code": "def afx_small():\n  \"\"\"Small transformer model with small batch size for fast step times.\"\"\"\n  hparams = transformer.transformer_tpu()\n  hparams.filter_size = 1024\n  hparams.num_heads = 4\n  hparams.num_hidden_layers = 3\n  hparams.batch_size = 512\n  return hparams", "code_tokens": "def afx_small ( ) : hparams = transformer . transformer_tpu ( ) hparams . filter_size = 1024 hparams . num_heads = 4 hparams . num_hidden_layers = 3 hparams . batch_size = 512 return hparams", "docstring_tokens": "Small transformer model with small batch size for fast step times .", "label": 1}, {"idx": "cosqa-train-9893", "doc": "how to turn numpy array into python string", "code": "def _array2cstr(arr):\n    \"\"\" Serializes a numpy array to a compressed base64 string \"\"\"\n    out = StringIO()\n    np.save(out, arr)\n    return b64encode(out.getvalue())", "code_tokens": "def _array2cstr ( arr ) : out = StringIO ( ) np . save ( out , arr ) return b64encode ( out . getvalue ( ) )", "docstring_tokens": "Serializes a numpy array to a compressed base64 string", "label": 1}, {"idx": "cosqa-train-9894", "doc": "python tensorflow object detection with self dataset", "code": "def get_example_features(example):\n  \"\"\"Returns the non-sequence features from the provided example.\"\"\"\n  return (example.features.feature if isinstance(example, tf.train.Example)\n          else example.context.feature)", "code_tokens": "def get_example_features ( example ) : return ( example . features . feature if isinstance ( example , tf . train . Example ) else example . context . feature )", "docstring_tokens": "Returns the non - sequence features from the provided example .", "label": 1}, {"idx": "cosqa-train-9895", "doc": "how to turn python list to rdd", "code": "def _to_java_object_rdd(rdd):\n    \"\"\" Return a JavaRDD of Object by unpickling\n\n    It will convert each Python object into Java object by Pyrolite, whenever the\n    RDD is serialized in batch or not.\n    \"\"\"\n    rdd = rdd._reserialize(AutoBatchedSerializer(PickleSerializer()))\n    return rdd.ctx._jvm.org.apache.spark.mllib.api.python.SerDe.pythonToJava(rdd._jrdd, True)", "code_tokens": "def _to_java_object_rdd ( rdd ) : rdd = rdd . _reserialize ( AutoBatchedSerializer ( PickleSerializer ( ) ) ) return rdd . ctx . _jvm . org . apache . spark . mllib . api . python . SerDe . pythonToJava ( rdd . _jrdd , True )", "docstring_tokens": "Return a JavaRDD of Object by unpickling", "label": 1}, {"idx": "cosqa-train-9896", "doc": "python test a string is valid path", "code": "def _is_path(s):\n    \"\"\"Return whether an object is a path.\"\"\"\n    if isinstance(s, string_types):\n        try:\n            return op.exists(s)\n        except (OSError, ValueError):\n            return False\n    else:\n        return False", "code_tokens": "def _is_path ( s ) : if isinstance ( s , string_types ) : try : return op . exists ( s ) except ( OSError , ValueError ) : return False else : return False", "docstring_tokens": "Return whether an object is a path .", "label": 0}, {"idx": "cosqa-train-9897", "doc": "how to type infinity in python", "code": "def _safe_db(num, den):\n    \"\"\"Properly handle the potential +Inf db SIR instead of raising a\n    RuntimeWarning.\n    \"\"\"\n    if den == 0:\n        return np.inf\n    return 10 * np.log10(num / den)", "code_tokens": "def _safe_db ( num , den ) : if den == 0 : return np . inf return 10 * np . log10 ( num / den )", "docstring_tokens": "Properly handle the potential + Inf db SIR instead of raising a RuntimeWarning .", "label": 0}, {"idx": "cosqa-train-9898", "doc": "python test if object has attribute attribute", "code": "def hasattrs(object, *names):\n    \"\"\"\n    Takes in an object and a variable length amount of named attributes,\n    and checks to see if the object has each property. If any of the\n    attributes are missing, this returns false.\n\n    :param object: an object that may or may not contain the listed attributes\n    :param names: a variable amount of attribute names to check for\n    :return: True if the object contains each named attribute, false otherwise\n    \"\"\"\n    for name in names:\n        if not hasattr(object, name):\n            return False\n    return True", "code_tokens": "def hasattrs ( object , * names ) : for name in names : if not hasattr ( object , name ) : return False return True", "docstring_tokens": "Takes in an object and a variable length amount of named attributes and checks to see if the object has each property . If any of the attributes are missing this returns false .", "label": 0}, {"idx": "cosqa-train-9899", "doc": "how to type logarithms into python", "code": "def log(x):\n    \"\"\"\n    Natural logarithm\n    \"\"\"\n    if isinstance(x, UncertainFunction):\n        mcpts = np.log(x._mcpts)\n        return UncertainFunction(mcpts)\n    else:\n        return np.log(x)", "code_tokens": "def log ( x ) : if isinstance ( x , UncertainFunction ) : mcpts = np . log ( x . _mcpts ) return UncertainFunction ( mcpts ) else : return np . log ( x )", "docstring_tokens": "Natural logarithm", "label": 1}, {"idx": "cosqa-train-9900", "doc": "python test logical type", "code": "def isnumber(*args):\n    \"\"\"Checks if value is an integer, long integer or float.\n\n    NOTE: Treats booleans as numbers, where True=1 and False=0.\n    \"\"\"\n    return all(map(lambda c: isinstance(c, int) or isinstance(c, float), args))", "code_tokens": "def isnumber ( * args ) : return all ( map ( lambda c : isinstance ( c , int ) or isinstance ( c , float ) , args ) )", "docstring_tokens": "Checks if value is an integer long integer or float .", "label": 1}, {"idx": "cosqa-train-9901", "doc": "how to update screen in python", "code": "def update_screen(self):\n        \"\"\"Refresh the screen. You don't need to override this except to update only small portins of the screen.\"\"\"\n        self.clock.tick(self.FPS)\n        pygame.display.update()", "code_tokens": "def update_screen ( self ) : self . clock . tick ( self . FPS ) pygame . display . update ( )", "docstring_tokens": "Refresh the screen . You don t need to override this except to update only small portins of the screen .", "label": 1}, {"idx": "cosqa-train-9902", "doc": "python test mock propertymock setter", "code": "def mock_add_spec(self, spec, spec_set=False):\n        \"\"\"Add a spec to a mock. `spec` can either be an object or a\n        list of strings. Only attributes on the `spec` can be fetched as\n        attributes from the mock.\n\n        If `spec_set` is True then only attributes on the spec can be set.\"\"\"\n        self._mock_add_spec(spec, spec_set)\n        self._mock_set_magics()", "code_tokens": "def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )", "docstring_tokens": "Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock .", "label": 0}, {"idx": "cosqa-train-9903", "doc": "how to use access token oauth python", "code": "def fetch_token(self, **kwargs):\n        \"\"\"Exchange a code (and 'state' token) for a bearer token\"\"\"\n        return super(AsanaOAuth2Session, self).fetch_token(self.token_url, client_secret=self.client_secret, **kwargs)", "code_tokens": "def fetch_token ( self , * * kwargs ) : return super ( AsanaOAuth2Session , self ) . fetch_token ( self . token_url , client_secret = self . client_secret , * * kwargs )", "docstring_tokens": "Exchange a code ( and state token ) for a bearer token", "label": 1}, {"idx": "cosqa-train-9904", "doc": "python test nose output", "code": "def test(nose_argsuments):\n    \"\"\" Run application tests \"\"\"\n    from nose import run\n\n    params = ['__main__', '-c', 'nose.ini']\n    params.extend(nose_argsuments)\n    run(argv=params)", "code_tokens": "def test ( nose_argsuments ) : from nose import run params = [ '__main__' , '-c' , 'nose.ini' ] params . extend ( nose_argsuments ) run ( argv = params )", "docstring_tokens": "Run application tests", "label": 0}, {"idx": "cosqa-train-9905", "doc": "how to use different gpu in python tensorflow", "code": "def transformer_tpu_1b():\n  \"\"\"Hparams for machine translation with ~1.1B parameters.\"\"\"\n  hparams = transformer_tpu()\n  hparams.hidden_size = 2048\n  hparams.filter_size = 8192\n  hparams.num_hidden_layers = 8\n  # smaller batch size to avoid OOM\n  hparams.batch_size = 1024\n  hparams.activation_dtype = \"bfloat16\"\n  hparams.weight_dtype = \"bfloat16\"\n  # maximize number of parameters relative to computation by not sharing.\n  hparams.shared_embedding_and_softmax_weights = False\n  return hparams", "code_tokens": "def transformer_tpu_1b ( ) : hparams = transformer_tpu ( ) hparams . hidden_size = 2048 hparams . filter_size = 8192 hparams . num_hidden_layers = 8 # smaller batch size to avoid OOM hparams . batch_size = 1024 hparams . activation_dtype = \"bfloat16\" hparams . weight_dtype = \"bfloat16\" # maximize number of parameters relative to computation by not sharing. hparams . shared_embedding_and_softmax_weights = False return hparams", "docstring_tokens": "Hparams for machine translation with ~1 . 1B parameters .", "label": 0}, {"idx": "cosqa-train-9906", "doc": "python test telnet port only", "code": "def test():\n    \"\"\"Test program for telnetlib.\n\n    Usage: python telnetlib.py [-d] ... [host [port]]\n\n    Default host is localhost; default port is 23.\n\n    \"\"\"\n    debuglevel = 0\n    while sys.argv[1:] and sys.argv[1] == '-d':\n        debuglevel = debuglevel + 1\n        del sys.argv[1]\n    host = 'localhost'\n    if sys.argv[1:]:\n        host = sys.argv[1]\n    port = 0\n    if sys.argv[2:]:\n        portstr = sys.argv[2]\n        try:\n            port = int(portstr)\n        except ValueError:\n            port = socket.getservbyname(portstr, 'tcp')\n    tn = Telnet()\n    tn.set_debuglevel(debuglevel)\n    tn.open(host, port)\n    tn.interact()\n    tn.close()", "code_tokens": "def test ( ) : debuglevel = 0 while sys . argv [ 1 : ] and sys . argv [ 1 ] == '-d' : debuglevel = debuglevel + 1 del sys . argv [ 1 ] host = 'localhost' if sys . argv [ 1 : ] : host = sys . argv [ 1 ] port = 0 if sys . argv [ 2 : ] : portstr = sys . argv [ 2 ] try : port = int ( portstr ) except ValueError : port = socket . getservbyname ( portstr , 'tcp' ) tn = Telnet ( ) tn . set_debuglevel ( debuglevel ) tn . open ( host , port ) tn . interact ( ) tn . close ( )", "docstring_tokens": "Test program for telnetlib .", "label": 1}, {"idx": "cosqa-train-9907", "doc": "how to use python function in tensorflow", "code": "def _float_feature(value):\n  \"\"\"Wrapper for inserting float features into Example proto.\"\"\"\n  if not isinstance(value, list):\n    value = [value]\n  return tf.train.Feature(float_list=tf.train.FloatList(value=value))", "code_tokens": "def _float_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( float_list = tf . train . FloatList ( value = value ) )", "docstring_tokens": "Wrapper for inserting float features into Example proto .", "label": 1}, {"idx": "cosqa-train-9908", "doc": "python test the type of input", "code": "def assert_valid_input(cls, tag):\n        \"\"\"Check if valid input tag or document.\"\"\"\n\n        # Fail on unexpected types.\n        if not cls.is_tag(tag):\n            raise TypeError(\"Expected a BeautifulSoup 'Tag', but instead recieved type {}\".format(type(tag)))", "code_tokens": "def assert_valid_input ( cls , tag ) : # Fail on unexpected types. if not cls . is_tag ( tag ) : raise TypeError ( \"Expected a BeautifulSoup 'Tag', but instead recieved type {}\" . format ( type ( tag ) ) )", "docstring_tokens": "Check if valid input tag or document .", "label": 1}, {"idx": "cosqa-train-9909", "doc": "how to validate xml against xsd in python", "code": "def str_is_well_formed(xml_str):\n    \"\"\"\n  Args:\n    xml_str : str\n      DataONE API XML doc.\n\n  Returns:\n    bool: **True** if XML doc is well formed.\n  \"\"\"\n    try:\n        str_to_etree(xml_str)\n    except xml.etree.ElementTree.ParseError:\n        return False\n    else:\n        return True", "code_tokens": "def str_is_well_formed ( xml_str ) : try : str_to_etree ( xml_str ) except xml . etree . ElementTree . ParseError : return False else : return True", "docstring_tokens": "Args : xml_str : str DataONE API XML doc .", "label": 1}, {"idx": "cosqa-train-9910", "doc": "python test truth value of list", "code": "def assert_exactly_one_true(bool_list):\n    \"\"\"This method asserts that only one value of the provided list is True.\n\n    :param bool_list: List of booleans to check\n    :return: True if only one value is True, False otherwise\n    \"\"\"\n    assert isinstance(bool_list, list)\n    counter = 0\n    for item in bool_list:\n        if item:\n            counter += 1\n    return counter == 1", "code_tokens": "def assert_exactly_one_true ( bool_list ) : assert isinstance ( bool_list , list ) counter = 0 for item in bool_list : if item : counter += 1 return counter == 1", "docstring_tokens": "This method asserts that only one value of the provided list is True .", "label": 1}, {"idx": "cosqa-train-9911", "doc": "how to verify that a url is valid in python", "code": "def url_syntax_check(url):  # pragma: no cover\n    \"\"\"\n    Check the syntax of the given URL.\n\n    :param url: The URL to check the syntax for.\n    :type url: str\n\n    :return: The syntax validity.\n    :rtype: bool\n\n    .. warning::\n        If an empty or a non-string :code:`url` is given, we return :code:`None`.\n    \"\"\"\n\n    if url and isinstance(url, str):\n        # The given URL is not empty nor None.\n        # and\n        # * The given URL is a string.\n\n        # We silently load the configuration.\n        load_config(True)\n\n        return Check(url).is_url_valid()\n\n    # We return None, there is nothing to check.\n    return None", "code_tokens": "def url_syntax_check ( url ) : # pragma: no cover if url and isinstance ( url , str ) : # The given URL is not empty nor None. # and # * The given URL is a string. # We silently load the configuration. load_config ( True ) return Check ( url ) . is_url_valid ( ) # We return None, there is nothing to check. return None", "docstring_tokens": "Check the syntax of the given URL .", "label": 1}, {"idx": "cosqa-train-9912", "doc": "python the scope of setting random seed", "code": "def reseed_random(seed):\n    \"\"\"Reseed factory.fuzzy's random generator.\"\"\"\n    r = random.Random(seed)\n    random_internal_state = r.getstate()\n    set_random_state(random_internal_state)", "code_tokens": "def reseed_random ( seed ) : r = random . Random ( seed ) random_internal_state = r . getstate ( ) set_random_state ( random_internal_state )", "docstring_tokens": "Reseed factory . fuzzy s random generator .", "label": 1}, {"idx": "cosqa-train-9913", "doc": "how to write a fits file python 3", "code": "def write_fits(data, header, file_name):\n    \"\"\"\n    Combine data and a fits header to write a fits file.\n\n    Parameters\n    ----------\n    data : numpy.ndarray\n        The data to be written.\n\n    header : astropy.io.fits.hduheader\n        The header for the fits file.\n\n    file_name : string\n        The file to write\n\n    Returns\n    -------\n    None\n    \"\"\"\n    hdu = fits.PrimaryHDU(data)\n    hdu.header = header\n    hdulist = fits.HDUList([hdu])\n    hdulist.writeto(file_name, overwrite=True)\n    logging.info(\"Wrote {0}\".format(file_name))\n    return", "code_tokens": "def write_fits ( data , header , file_name ) : hdu = fits . PrimaryHDU ( data ) hdu . header = header hdulist = fits . HDUList ( [ hdu ] ) hdulist . writeto ( file_name , overwrite = True ) logging . info ( \"Wrote {0}\" . format ( file_name ) ) return", "docstring_tokens": "Combine data and a fits header to write a fits file .", "label": 1}, {"idx": "cosqa-train-9914", "doc": "python thread stop self", "code": "def stop(self):\n    \"\"\" Stops the playing thread and close \"\"\"\n    with self.lock:\n      self.halting = True\n      self.go.clear()", "code_tokens": "def stop ( self ) : with self . lock : self . halting = True self . go . clear ( )", "docstring_tokens": "Stops the playing thread and close", "label": 1}, {"idx": "cosqa-train-9915", "doc": "how to write and save html file in python", "code": "def _save_file(self, filename, contents):\n        \"\"\"write the html file contents to disk\"\"\"\n        with open(filename, 'w') as f:\n            f.write(contents)", "code_tokens": "def _save_file ( self , filename , contents ) : with open ( filename , 'w' ) as f : f . write ( contents )", "docstring_tokens": "write the html file contents to disk", "label": 0}, {"idx": "cosqa-train-9916", "doc": "python threading clean up threads", "code": "def shutdown(self):\n        \"\"\"\n        shutdown: to be run by atexit handler. All open connection are closed.\n        \"\"\"\n        self.run_clean_thread = False\n        self.cleanup(True)\n        if self.cleaner_thread.isAlive():\n            self.cleaner_thread.join()", "code_tokens": "def shutdown ( self ) : self . run_clean_thread = False self . cleanup ( True ) if self . cleaner_thread . isAlive ( ) : self . cleaner_thread . join ( )", "docstring_tokens": "shutdown : to be run by atexit handler . All open connection are closed .", "label": 1}, {"idx": "cosqa-train-9917", "doc": "how to write code for complex number in python", "code": "def part(z, s):\n    r\"\"\"Get the real or imaginary part of a complex number.\"\"\"\n    if sage_included:\n        if s == 1: return np.real(z)\n        elif s == -1: return np.imag(z)\n        elif s == 0:\n            return z\n    else:\n        if s == 1: return z.real\n        elif s == -1: return z.imag\n        elif s == 0: return z", "code_tokens": "def part ( z , s ) : if sage_included : if s == 1 : return np . real ( z ) elif s == - 1 : return np . imag ( z ) elif s == 0 : return z else : if s == 1 : return z . real elif s == - 1 : return z . imag elif s == 0 : return z", "docstring_tokens": "r Get the real or imaginary part of a complex number .", "label": 0}, {"idx": "cosqa-train-9918", "doc": "python time stampe type to datetime type", "code": "def convert_tstamp(response):\n\t\"\"\"\n\tConvert a Stripe API timestamp response (unix epoch) to a native datetime.\n\n\t:rtype: datetime\n\t\"\"\"\n\tif response is None:\n\t\t# Allow passing None to convert_tstamp()\n\t\treturn response\n\n\t# Overrides the set timezone to UTC - I think...\n\ttz = timezone.utc if settings.USE_TZ else None\n\n\treturn datetime.datetime.fromtimestamp(response, tz)", "code_tokens": "def convert_tstamp ( response ) : if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = timezone . utc if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz )", "docstring_tokens": "Convert a Stripe API timestamp response ( unix epoch ) to a native datetime .", "label": 1}, {"idx": "cosqa-train-9919", "doc": "how to write headers for a column in python", "code": "def printheader(h=None):\n    \"\"\"Print the header for the CSV table.\"\"\"\n    writer = csv.writer(sys.stdout)\n    writer.writerow(header_fields(h))", "code_tokens": "def printheader ( h = None ) : writer = csv . writer ( sys . stdout ) writer . writerow ( header_fields ( h ) )", "docstring_tokens": "Print the header for the CSV table .", "label": 1}, {"idx": "cosqa-train-9920", "doc": "python timestamp remove timezone", "code": "def convert_tstamp(response):\n\t\"\"\"\n\tConvert a Stripe API timestamp response (unix epoch) to a native datetime.\n\n\t:rtype: datetime\n\t\"\"\"\n\tif response is None:\n\t\t# Allow passing None to convert_tstamp()\n\t\treturn response\n\n\t# Overrides the set timezone to UTC - I think...\n\ttz = timezone.utc if settings.USE_TZ else None\n\n\treturn datetime.datetime.fromtimestamp(response, tz)", "code_tokens": "def convert_tstamp ( response ) : if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = timezone . utc if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz )", "docstring_tokens": "Convert a Stripe API timestamp response ( unix epoch ) to a native datetime .", "label": 1}, {"idx": "cosqa-train-9921", "doc": "how to zip folders into a zipfile with python", "code": "def extract_zip(zip_path, target_folder):\n    \"\"\"\n    Extract the content of the zip-file at `zip_path` into `target_folder`.\n    \"\"\"\n    with zipfile.ZipFile(zip_path) as archive:\n        archive.extractall(target_folder)", "code_tokens": "def extract_zip ( zip_path , target_folder ) : with zipfile . ZipFile ( zip_path ) as archive : archive . extractall ( target_folder )", "docstring_tokens": "Extract the content of the zip - file at zip_path into target_folder .", "label": 0}, {"idx": "cosqa-train-9922", "doc": "python timestamp seconds to datetime", "code": "def date_to_timestamp(date):\n    \"\"\"\n        date to unix timestamp in milliseconds\n    \"\"\"\n    date_tuple = date.timetuple()\n    timestamp = calendar.timegm(date_tuple) * 1000\n    return timestamp", "code_tokens": "def date_to_timestamp ( date ) : date_tuple = date . timetuple ( ) timestamp = calendar . timegm ( date_tuple ) * 1000 return timestamp", "docstring_tokens": "date to unix timestamp in milliseconds", "label": 1}, {"idx": "cosqa-train-9923", "doc": "how use python ctypes byref and pointer", "code": "def POINTER(obj):\n    \"\"\"\n    Create ctypes pointer to object.\n\n    Notes\n    -----\n    This function converts None to a real NULL pointer because of bug\n    in how ctypes handles None on 64-bit platforms.\n\n    \"\"\"\n\n    p = ctypes.POINTER(obj)\n    if not isinstance(p.from_param, classmethod):\n        def from_param(cls, x):\n            if x is None:\n                return cls()\n            else:\n                return x\n        p.from_param = classmethod(from_param)\n\n    return p", "code_tokens": "def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p", "docstring_tokens": "Create ctypes pointer to object .", "label": 1}, {"idx": "cosqa-train-9924", "doc": "python timezone no utcoffset", "code": "def current_offset(local_tz=None):\n    \"\"\"\n    Returns current utcoffset for a timezone. Uses\n    DEFAULT_LOCAL_TZ by default. That value can be\n    changed at runtime using the func below.\n    \"\"\"\n    if local_tz is None:\n        local_tz = DEFAULT_LOCAL_TZ\n    dt = local_tz.localize(datetime.now())\n    return dt.utcoffset()", "code_tokens": "def current_offset ( local_tz = None ) : if local_tz is None : local_tz = DEFAULT_LOCAL_TZ dt = local_tz . localize ( datetime . now ( ) ) return dt . utcoffset ( )", "docstring_tokens": "Returns current utcoffset for a timezone . Uses DEFAULT_LOCAL_TZ by default . That value can be changed at runtime using the func below .", "label": 1}, {"idx": "cosqa-train-9925", "doc": "howto delete object on image using python", "code": "def delete(self, id):\n        \"\"\"\n        Deletes an \"object\" (line, triangle, image, etc) from the drawing.\n\n        :param int id:\n            The id of the object.\n        \"\"\"\n        if id in self._images.keys():\n            del self._images[id]\n        self.tk.delete(id)", "code_tokens": "def delete ( self , id ) : if id in self . _images . keys ( ) : del self . _images [ id ] self . tk . delete ( id )", "docstring_tokens": "Deletes an object ( line triangle image etc ) from the drawing .", "label": 1}, {"idx": "cosqa-train-9926", "doc": "python title string not of from", "code": "def _format_title_string(self, title_string):\n        \"\"\" format mpv's title \"\"\"\n        return self._title_string_format_text_tag(title_string.replace(self.icy_tokkens[0], self.icy_title_prefix))", "code_tokens": "def _format_title_string ( self , title_string ) : return self . _title_string_format_text_tag ( title_string . replace ( self . icy_tokkens [ 0 ] , self . icy_title_prefix ) )", "docstring_tokens": "format mpv s title", "label": 1}, {"idx": "cosqa-train-9927", "doc": "idex of max in an array python", "code": "def SegmentMax(a, ids):\n    \"\"\"\n    Segmented max op.\n    \"\"\"\n    func = lambda idxs: np.amax(a[idxs], axis=0)\n    return seg_map(func, a, ids),", "code_tokens": "def SegmentMax ( a , ids ) : func = lambda idxs : np . amax ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,", "docstring_tokens": "Segmented max op .", "label": 1}, {"idx": "cosqa-train-9928", "doc": "python tk select a folder", "code": "def on_source_directory_chooser_clicked(self):\n        \"\"\"Autoconnect slot activated when tbSourceDir is clicked.\"\"\"\n\n        title = self.tr('Set the source directory for script and scenario')\n        self.choose_directory(self.source_directory, title)", "code_tokens": "def on_source_directory_chooser_clicked ( self ) : title = self . tr ( 'Set the source directory for script and scenario' ) self . choose_directory ( self . source_directory , title )", "docstring_tokens": "Autoconnect slot activated when tbSourceDir is clicked .", "label": 0}, {"idx": "cosqa-train-9929", "doc": "if attribute is calable python", "code": "def call_on_if_def(obj, attr_name, callable, default, *args, **kwargs):\n    \"\"\"Calls the provided callable on the provided attribute of ``obj`` if it is defined.\n\n    If not, returns default.\n    \"\"\"\n    try:\n        attr = getattr(obj, attr_name)\n    except AttributeError:\n        return default\n    else:\n        return callable(attr, *args, **kwargs)", "code_tokens": "def call_on_if_def ( obj , attr_name , callable , default , * args , * * kwargs ) : try : attr = getattr ( obj , attr_name ) except AttributeError : return default else : return callable ( attr , * args , * * kwargs )", "docstring_tokens": "Calls the provided callable on the provided attribute of obj if it is defined .", "label": 0}, {"idx": "cosqa-train-9930", "doc": "python tkinter canvas get scrollregion", "code": "def set_scrollregion(self, event=None):\n        \"\"\" Set the scroll region on the canvas\"\"\"\n        self.canvas.configure(scrollregion=self.canvas.bbox('all'))", "code_tokens": "def set_scrollregion ( self , event = None ) : self . canvas . configure ( scrollregion = self . canvas . bbox ( 'all' ) )", "docstring_tokens": "Set the scroll region on the canvas", "label": 1}, {"idx": "cosqa-train-9931", "doc": "if column exists python", "code": "def column_exists(cr, table, column):\n    \"\"\" Check whether a certain column exists \"\"\"\n    cr.execute(\n        'SELECT count(attname) FROM pg_attribute '\n        'WHERE attrelid = '\n        '( SELECT oid FROM pg_class WHERE relname = %s ) '\n        'AND attname = %s',\n        (table, column))\n    return cr.fetchone()[0] == 1", "code_tokens": "def column_exists ( cr , table , column ) : cr . execute ( 'SELECT count(attname) FROM pg_attribute ' 'WHERE attrelid = ' '( SELECT oid FROM pg_class WHERE relname = %s ) ' 'AND attname = %s' , ( table , column ) ) return cr . fetchone ( ) [ 0 ] == 1", "docstring_tokens": "Check whether a certain column exists", "label": 1}, {"idx": "cosqa-train-9932", "doc": "if file is not exist then create in python", "code": "def check_create_folder(filename):\n    \"\"\"Check if the folder exisits. If not, create the folder\"\"\"\n    os.makedirs(os.path.dirname(filename), exist_ok=True)", "code_tokens": "def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )", "docstring_tokens": "Check if the folder exisits . If not create the folder", "label": 0}, {"idx": "cosqa-train-9933", "doc": "python tkinter popup window with scrollbar", "code": "def restore_scrollbar_position(self):\n        \"\"\"Restoring scrollbar position after main window is visible\"\"\"\n        scrollbar_pos = self.get_option('scrollbar_position', None)\n        if scrollbar_pos is not None:\n            self.explorer.treewidget.set_scrollbar_position(scrollbar_pos)", "code_tokens": "def restore_scrollbar_position ( self ) : scrollbar_pos = self . get_option ( 'scrollbar_position' , None ) if scrollbar_pos is not None : self . explorer . treewidget . set_scrollbar_position ( scrollbar_pos )", "docstring_tokens": "Restoring scrollbar position after main window is visible", "label": 0}, {"idx": "cosqa-train-9934", "doc": "if matching a keyword store line to variable python", "code": "def matching_line(lines, keyword):\n    \"\"\" Returns the first matching line in a list of lines.\n    @see match()\n    \"\"\"\n    for line in lines:\n        matching = match(line,keyword)\n        if matching != None:\n            return matching\n    return None", "code_tokens": "def matching_line ( lines , keyword ) : for line in lines : matching = match ( line , keyword ) if matching != None : return matching return None", "docstring_tokens": "Returns the first matching line in a list of lines .", "label": 1}, {"idx": "cosqa-train-9935", "doc": "python tkinter sunken scrollbar", "code": "def __grid_widgets(self):\n        \"\"\"Places all the child widgets in the appropriate positions.\"\"\"\n        scrollbar_column = 0 if self.__compound is tk.LEFT else 2\n        self._canvas.grid(row=0, column=1, sticky=\"nswe\")\n        self._scrollbar.grid(row=0, column=scrollbar_column, sticky=\"ns\")", "code_tokens": "def __grid_widgets ( self ) : scrollbar_column = 0 if self . __compound is tk . LEFT else 2 self . _canvas . grid ( row = 0 , column = 1 , sticky = \"nswe\" ) self . _scrollbar . grid ( row = 0 , column = scrollbar_column , sticky = \"ns\" )", "docstring_tokens": "Places all the child widgets in the appropriate positions .", "label": 1}, {"idx": "cosqa-train-9936", "doc": "if syntax with multiple conditions for python 3", "code": "def _if(ctx, logical_test, value_if_true=0, value_if_false=False):\n    \"\"\"\n    Returns one value if the condition evaluates to TRUE, and another value if it evaluates to FALSE\n    \"\"\"\n    return value_if_true if conversions.to_boolean(logical_test, ctx) else value_if_false", "code_tokens": "def _if ( ctx , logical_test , value_if_true = 0 , value_if_false = False ) : return value_if_true if conversions . to_boolean ( logical_test , ctx ) else value_if_false", "docstring_tokens": "Returns one value if the condition evaluates to TRUE and another value if it evaluates to FALSE", "label": 1}, {"idx": "cosqa-train-9937", "doc": "python to dict if only one item", "code": "def multidict_to_dict(d):\n    \"\"\"\n    Turns a werkzeug.MultiDict or django.MultiValueDict into a dict with\n    list values\n    :param d: a MultiDict or MultiValueDict instance\n    :return: a dict instance\n    \"\"\"\n    return dict((k, v[0] if len(v) == 1 else v) for k, v in iterlists(d))", "code_tokens": "def multidict_to_dict ( d ) : return dict ( ( k , v [ 0 ] if len ( v ) == 1 else v ) for k , v in iterlists ( d ) )", "docstring_tokens": "Turns a werkzeug . MultiDict or django . MultiValueDict into a dict with list values : param d : a MultiDict or MultiValueDict instance : return : a dict instance", "label": 1}, {"idx": "cosqa-train-9938", "doc": "if user redirect python form security", "code": "def form_valid(self, form):\n        \"\"\"Security check complete. Log the user in.\"\"\"\n        auth_login(self.request, form.get_user())\n        return HttpResponseRedirect(self.get_success_url())", "code_tokens": "def form_valid ( self , form ) : auth_login ( self . request , form . get_user ( ) ) return HttpResponseRedirect ( self . get_success_url ( ) )", "docstring_tokens": "Security check complete . Log the user in .", "label": 0}, {"idx": "cosqa-train-9939", "doc": "python to normalize an array", "code": "def normalize_array(lst):\n    \"\"\"Normalizes list\n\n    :param lst: Array of floats\n    :return: Normalized (in [0, 1]) input array\n    \"\"\"\n    np_arr = np.array(lst)\n    x_normalized = np_arr / np_arr.max(axis=0)\n    return list(x_normalized)", "code_tokens": "def normalize_array ( lst ) : np_arr = np . array ( lst ) x_normalized = np_arr / np_arr . max ( axis = 0 ) return list ( x_normalized )", "docstring_tokens": "Normalizes list", "label": 0}, {"idx": "cosqa-train-9940", "doc": "iinitiliazing a veriable as array in python", "code": "def is_int_vector(l):\n    r\"\"\"Checks if l is a numpy array of integers\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 1 and (l.dtype.kind == 'i' or l.dtype.kind == 'u'):\n            return True\n    return False", "code_tokens": "def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False", "docstring_tokens": "r Checks if l is a numpy array of integers", "label": 1}, {"idx": "cosqa-train-9941", "doc": "python to voltdb timestamp", "code": "def convert_timestamp(timestamp):\n    \"\"\"\n    Converts bokehJS timestamp to datetime64.\n    \"\"\"\n    datetime = dt.datetime.utcfromtimestamp(timestamp/1000.)\n    return np.datetime64(datetime.replace(tzinfo=None))", "code_tokens": "def convert_timestamp ( timestamp ) : datetime = dt . datetime . utcfromtimestamp ( timestamp / 1000. ) return np . datetime64 ( datetime . replace ( tzinfo = None ) )", "docstring_tokens": "Converts bokehJS timestamp to datetime64 .", "label": 0}, {"idx": "cosqa-train-9942", "doc": "image segmentation data augment python", "code": "def region_from_segment(image, segment):\n    \"\"\"given a segment (rectangle) and an image, returns it's corresponding subimage\"\"\"\n    x, y, w, h = segment\n    return image[y:y + h, x:x + w]", "code_tokens": "def region_from_segment ( image , segment ) : x , y , w , h = segment return image [ y : y + h , x : x + w ]", "docstring_tokens": "given a segment ( rectangle ) and an image returns it s corresponding subimage", "label": 0}, {"idx": "cosqa-train-9943", "doc": "python trace function calls", "code": "def __run(self):\n    \"\"\"Hacked run function, which installs the trace.\"\"\"\n    sys.settrace(self.globaltrace)\n    self.__run_backup()\n    self.run = self.__run_backup", "code_tokens": "def __run ( self ) : sys . settrace ( self . globaltrace ) self . __run_backup ( ) self . run = self . __run_backup", "docstring_tokens": "Hacked run function which installs the trace .", "label": 1}, {"idx": "cosqa-train-9944", "doc": "implement 2d convolution python", "code": "def conv1x1(in_planes, out_planes, stride=1):\n    \"\"\"1x1 convolution\"\"\"\n    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)", "code_tokens": "def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )", "docstring_tokens": "1x1 convolution", "label": 1}, {"idx": "cosqa-train-9945", "doc": "python traceback get string", "code": "def format_exc(*exc_info):\n    \"\"\"Show exception with traceback.\"\"\"\n    typ, exc, tb = exc_info or sys.exc_info()\n    error = traceback.format_exception(typ, exc, tb)\n    return \"\".join(error)", "code_tokens": "def format_exc ( * exc_info ) : typ , exc , tb = exc_info or sys . exc_info ( ) error = traceback . format_exception ( typ , exc , tb ) return \"\" . join ( error )", "docstring_tokens": "Show exception with traceback .", "label": 1}, {"idx": "cosqa-train-9946", "doc": "imshow aspect ratio python", "code": "def image_set_aspect(aspect=1.0, axes=\"gca\"):\n    \"\"\"\n    sets the aspect ratio of the current zoom level of the imshow image\n    \"\"\"\n    if axes is \"gca\": axes = _pylab.gca()\n\n    e = axes.get_images()[0].get_extent()\n    axes.set_aspect(abs((e[1]-e[0])/(e[3]-e[2]))/aspect)", "code_tokens": "def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "docstring_tokens": "sets the aspect ratio of the current zoom level of the imshow image", "label": 0}, {"idx": "cosqa-train-9947", "doc": "python traceback to string", "code": "def str_traceback(error, tb):\n    \"\"\"Returns a string representation of the traceback.\n    \"\"\"\n    if not isinstance(tb, types.TracebackType):\n        return tb\n\n    return ''.join(traceback.format_exception(error.__class__, error, tb))", "code_tokens": "def str_traceback ( error , tb ) : if not isinstance ( tb , types . TracebackType ) : return tb return '' . join ( traceback . format_exception ( error . __class__ , error , tb ) )", "docstring_tokens": "Returns a string representation of the traceback .", "label": 1}, {"idx": "cosqa-train-9948", "doc": "in a python range how to set a step that increases by 1", "code": "def stepBy(self, steps):\n        \"\"\"steps value up/down by a single step. Single step is defined in singleStep().\n\n        Args:\n            steps (int): positiv int steps up, negativ steps down\n        \"\"\"\n        self.setValue(self.value() + steps*self.singleStep())", "code_tokens": "def stepBy ( self , steps ) : self . setValue ( self . value ( ) + steps * self . singleStep ( ) )", "docstring_tokens": "steps value up / down by a single step . Single step is defined in singleStep () .", "label": 1}, {"idx": "cosqa-train-9949", "doc": "python transpose first column", "code": "def sf01(arr):\n    \"\"\"\n    swap and then flatten axes 0 and 1\n    \"\"\"\n    s = arr.shape\n    return arr.swapaxes(0, 1).reshape(s[0] * s[1], *s[2:])", "code_tokens": "def sf01 ( arr ) : s = arr . shape return arr . swapaxes ( 0 , 1 ) . reshape ( s [ 0 ] * s [ 1 ] , * s [ 2 : ] )", "docstring_tokens": "swap and then flatten axes 0 and 1", "label": 0}, {"idx": "cosqa-train-9950", "doc": "in python differentiate pass and comment line", "code": "def _match_space_at_line(line):\n    \"\"\"Return a re.match object if an empty comment was found on line.\"\"\"\n    regex = re.compile(r\"^{0}$\".format(_MDL_COMMENT))\n    return regex.match(line)", "code_tokens": "def _match_space_at_line ( line ) : regex = re . compile ( r\"^{0}$\" . format ( _MDL_COMMENT ) ) return regex . match ( line )", "docstring_tokens": "Return a re . match object if an empty comment was found on line .", "label": 0}, {"idx": "cosqa-train-9951", "doc": "python tree max depth", "code": "def min_depth(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if root is None:\n        return 0\n    if root.left is not None or root.right is not None:\n        return max(self.minDepth(root.left), self.minDepth(root.right))+1\n    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1", "code_tokens": "def min_depth ( self , root ) : if root is None : return 0 if root . left is not None or root . right is not None : return max ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1 return min ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1", "docstring_tokens": ": type root : TreeNode : rtype : int", "label": 0}, {"idx": "cosqa-train-9952", "doc": "in python, what does tell method of a file object do", "code": "def is_filelike(ob):\n    \"\"\"Check for filelikeness of an object.\n\n    Needed to distinguish it from file names.\n    Returns true if it has a read or a write method.\n    \"\"\"\n    if hasattr(ob, 'read') and callable(ob.read):\n        return True\n\n    if hasattr(ob, 'write') and callable(ob.write):\n        return True\n\n    return False", "code_tokens": "def is_filelike ( ob ) : if hasattr ( ob , 'read' ) and callable ( ob . read ) : return True if hasattr ( ob , 'write' ) and callable ( ob . write ) : return True return False", "docstring_tokens": "Check for filelikeness of an object .", "label": 1}, {"idx": "cosqa-train-9953", "doc": "python trim whitespaces in between words", "code": "def handle_whitespace(text):\n    r\"\"\"Handles whitespace cleanup.\n\n    Tabs are \"smartly\" retabbed (see sub_retab). Lines that contain\n    only whitespace are truncated to a single newline.\n    \"\"\"\n    text = re_retab.sub(sub_retab, text)\n    text = re_whitespace.sub('', text).strip()\n    return text", "code_tokens": "def handle_whitespace ( text ) : text = re_retab . sub ( sub_retab , text ) text = re_whitespace . sub ( '' , text ) . strip ( ) return text", "docstring_tokens": "r Handles whitespace cleanup .", "label": 1}, {"idx": "cosqa-train-9954", "doc": "inbuilt dummy veriable creation function in python", "code": "def simple_generate(cls, create, **kwargs):\n        \"\"\"Generate a new instance.\n\n        The instance will be either 'built' or 'created'.\n\n        Args:\n            create (bool): whether to 'build' or 'create' the instance.\n\n        Returns:\n            object: the generated instance\n        \"\"\"\n        strategy = enums.CREATE_STRATEGY if create else enums.BUILD_STRATEGY\n        return cls.generate(strategy, **kwargs)", "code_tokens": "def simple_generate ( cls , create , * * kwargs ) : strategy = enums . CREATE_STRATEGY if create else enums . BUILD_STRATEGY return cls . generate ( strategy , * * kwargs )", "docstring_tokens": "Generate a new instance .", "label": 1}, {"idx": "cosqa-train-9955", "doc": "python troposphere s3 session role principal", "code": "def s3(ctx, bucket_name, data_file, region):\n    \"\"\"Use the S3 SWAG backend.\"\"\"\n    if not ctx.data_file:\n        ctx.data_file = data_file\n\n    if not ctx.bucket_name:\n        ctx.bucket_name = bucket_name\n\n    if not ctx.region:\n        ctx.region = region\n\n    ctx.type = 's3'", "code_tokens": "def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'", "docstring_tokens": "Use the S3 SWAG backend .", "label": 0}, {"idx": "cosqa-train-9956", "doc": "index of an element in a list in python", "code": "def binSearch(arr, val):\n  \"\"\" \n  Function for running binary search on a sorted list.\n\n  :param arr: (list) a sorted list of integers to search\n  :param val: (int)  a integer to search for in the sorted array\n  :returns: (int) the index of the element if it is found and -1 otherwise.\n  \"\"\"\n  i = bisect_left(arr, val)\n  if i != len(arr) and arr[i] == val:\n    return i\n  return -1", "code_tokens": "def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1", "docstring_tokens": "Function for running binary search on a sorted list .", "label": 1}, {"idx": "cosqa-train-9957", "doc": "python try block create a scope", "code": "def __init__(self, scope, parent):\n        \"\"\"Constructor for try block structures.\n\n        Args:\n            scope (CodeEntity): The program scope where this object belongs.\n            parent (CodeEntity): This object's parent in the program tree.\n        \"\"\"\n        CodeStatement.__init__(self, scope, parent)\n        self.body = CodeBlock(scope, self, explicit=True)\n        self.catches = []\n        self.finally_body = CodeBlock(scope, self, explicit=True)", "code_tokens": "def __init__ ( self , scope , parent ) : CodeStatement . __init__ ( self , scope , parent ) self . body = CodeBlock ( scope , self , explicit = True ) self . catches = [ ] self . finally_body = CodeBlock ( scope , self , explicit = True )", "docstring_tokens": "Constructor for try block structures .", "label": 1}, {"idx": "cosqa-train-9958", "doc": "index python parantheses or brackets", "code": "def match_paren(self, tokens, item):\n        \"\"\"Matches a paren.\"\"\"\n        match, = tokens\n        return self.match(match, item)", "code_tokens": "def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "docstring_tokens": "Matches a paren .", "label": 0}, {"idx": "cosqa-train-9959", "doc": "python try excpetion finally block", "code": "def eintr_retry(exc_type, f, *args, **kwargs):\n    \"\"\"Calls a function.  If an error of the given exception type with\n    interrupted system call (EINTR) occurs calls the function again.\n    \"\"\"\n    while True:\n        try:\n            return f(*args, **kwargs)\n        except exc_type as exc:\n            if exc.errno != EINTR:\n                raise\n        else:\n            break", "code_tokens": "def eintr_retry ( exc_type , f , * args , * * kwargs ) : while True : try : return f ( * args , * * kwargs ) except exc_type as exc : if exc . errno != EINTR : raise else : break", "docstring_tokens": "Calls a function . If an error of the given exception type with interrupted system call ( EINTR ) occurs calls the function again .", "label": 1}, {"idx": "cosqa-train-9960", "doc": "instance attribute not recognized python", "code": "def fval(self, instance):\n        \"\"\"return the raw value that this property is holding internally for instance\"\"\"\n        try:\n            val = instance.__dict__[self.instance_field_name]\n        except KeyError as e:\n            #raise AttributeError(str(e))\n            val = None\n\n        return val", "code_tokens": "def fval ( self , instance ) : try : val = instance . __dict__ [ self . instance_field_name ] except KeyError as e : #raise AttributeError(str(e)) val = None return val", "docstring_tokens": "return the raw value that this property is holding internally for instance", "label": 0}, {"idx": "cosqa-train-9961", "doc": "python try in a loop", "code": "def retry_on_signal(function):\n    \"\"\"Retries function until it doesn't raise an EINTR error\"\"\"\n    while True:\n        try:\n            return function()\n        except EnvironmentError, e:\n            if e.errno != errno.EINTR:\n                raise", "code_tokens": "def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise", "docstring_tokens": "Retries function until it doesn t raise an EINTR error", "label": 0}, {"idx": "cosqa-train-9962", "doc": "integrate python code ito html", "code": "def  make_html_code( self, lines ):\n        \"\"\" convert a code sequence to HTML \"\"\"\n        line = code_header + '\\n'\n        for l in lines:\n            line = line + html_quote( l ) + '\\n'\n\n        return line + code_footer", "code_tokens": "def make_html_code ( self , lines ) : line = code_header + '\\n' for l in lines : line = line + html_quote ( l ) + '\\n' return line + code_footer", "docstring_tokens": "convert a code sequence to HTML", "label": 1}, {"idx": "cosqa-train-9963", "doc": "python tuple print string", "code": "def _tuple_repr(data):\n    \"\"\"Return a repr() for a list/tuple\"\"\"\n    if len(data) == 1:\n        return \"(%s,)\" % rpr(data[0])\n    else:\n        return \"(%s)\" % \", \".join([rpr(x) for x in data])", "code_tokens": "def _tuple_repr ( data ) : if len ( data ) == 1 : return \"(%s,)\" % rpr ( data [ 0 ] ) else : return \"(%s)\" % \", \" . join ( [ rpr ( x ) for x in data ] )", "docstring_tokens": "Return a repr () for a list / tuple", "label": 0}, {"idx": "cosqa-train-9964", "doc": "interchange axis histogram in python", "code": "def _histplot_op(ax, data, **kwargs):\n    \"\"\"Add a histogram for the data to the axes.\"\"\"\n    bins = get_bins(data)\n    ax.hist(data, bins=bins, align=\"left\", density=True, **kwargs)\n    return ax", "code_tokens": "def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "docstring_tokens": "Add a histogram for the data to the axes .", "label": 1}, {"idx": "cosqa-train-9965", "doc": "python turn a string into a tuple", "code": "def ver_to_tuple(value):\n    \"\"\"\n    Convert version like string to a tuple of integers.\n    \"\"\"\n    return tuple(int(_f) for _f in re.split(r'\\D+', value) if _f)", "code_tokens": "def ver_to_tuple ( value ) : return tuple ( int ( _f ) for _f in re . split ( r'\\D+' , value ) if _f )", "docstring_tokens": "Convert version like string to a tuple of integers .", "label": 1}, {"idx": "cosqa-train-9966", "doc": "invalid syntax python slice", "code": "def is_full_slice(obj, l):\n    \"\"\"\n    We have a full length slice.\n    \"\"\"\n    return (isinstance(obj, slice) and obj.start == 0 and obj.stop == l and\n            obj.step is None)", "code_tokens": "def is_full_slice ( obj , l ) : return ( isinstance ( obj , slice ) and obj . start == 0 and obj . stop == l and obj . step is None )", "docstring_tokens": "We have a full length slice .", "label": 1}, {"idx": "cosqa-train-9967", "doc": "python turn all nested object to dict", "code": "def as_dict(self):\n        \"\"\"Return all child objects in nested dict.\"\"\"\n        dicts = [x.as_dict for x in self.children]\n        return {'{0} {1}'.format(self.name, self.value): dicts}", "code_tokens": "def as_dict ( self ) : dicts = [ x . as_dict for x in self . children ] return { '{0} {1}' . format ( self . name , self . value ) : dicts }", "docstring_tokens": "Return all child objects in nested dict .", "label": 1}, {"idx": "cosqa-train-9968", "doc": "invert key value pairs dictionary python", "code": "def invertDictMapping(d):\n    \"\"\" Invert mapping of dictionary (i.e. map values to list of keys) \"\"\"\n    inv_map = {}\n    for k, v in d.items():\n        inv_map[v] = inv_map.get(v, [])\n        inv_map[v].append(k)\n    return inv_map", "code_tokens": "def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map", "docstring_tokens": "Invert mapping of dictionary ( i . e . map values to list of keys )", "label": 1}, {"idx": "cosqa-train-9969", "doc": "python turn array into sentence", "code": "def one_hot2string(arr, vocab):\n    \"\"\"Convert a one-hot encoded array back to string\n    \"\"\"\n    tokens = one_hot2token(arr)\n    indexToLetter = _get_index_dict(vocab)\n\n    return [''.join([indexToLetter[x] for x in row]) for row in tokens]", "code_tokens": "def one_hot2string ( arr , vocab ) : tokens = one_hot2token ( arr ) indexToLetter = _get_index_dict ( vocab ) return [ '' . join ( [ indexToLetter [ x ] for x in row ] ) for row in tokens ]", "docstring_tokens": "Convert a one - hot encoded array back to string", "label": 0}, {"idx": "cosqa-train-9970", "doc": "is nargs allowed in custom action argparse python", "code": "def __init__(self, name, flag, **kwargs):\n    \"\"\"\n    Argument class constructor, should be used inside a class that inherits the BaseAction class.\n\n    :param name(str): the optional argument name to be used with two slahes (--cmd)\n    :param flag(str): a short flag for the argument (-c)\n    :param \\*\\*kwargs: all keywords arguments supported for argparse actions.\n    \"\"\"\n    self.name = name\n    self.flag = flag\n    self.options = kwargs", "code_tokens": "def __init__ ( self , name , flag , * * kwargs ) : self . name = name self . flag = flag self . options = kwargs", "docstring_tokens": "Argument class constructor should be used inside a class that inherits the BaseAction class .", "label": 1}, {"idx": "cosqa-train-9971", "doc": "python turn dic into string", "code": "def stringify_dict_contents(dct):\n    \"\"\"Turn dict keys and values into native strings.\"\"\"\n    return {\n        str_if_nested_or_str(k): str_if_nested_or_str(v)\n        for k, v in dct.items()\n    }", "code_tokens": "def stringify_dict_contents ( dct ) : return { str_if_nested_or_str ( k ) : str_if_nested_or_str ( v ) for k , v in dct . items ( ) }", "docstring_tokens": "Turn dict keys and values into native strings .", "label": 1}, {"idx": "cosqa-train-9972", "doc": "is there any python function to check for nan valu", "code": "def reduce_fn(x):\n    \"\"\"\n    Aggregation function to get the first non-zero value.\n    \"\"\"\n    values = x.values if pd and isinstance(x, pd.Series) else x\n    for v in values:\n        if not is_nan(v):\n            return v\n    return np.NaN", "code_tokens": "def reduce_fn ( x ) : values = x . values if pd and isinstance ( x , pd . Series ) else x for v in values : if not is_nan ( v ) : return v return np . NaN", "docstring_tokens": "Aggregation function to get the first non - zero value .", "label": 1}, {"idx": "cosqa-train-9973", "doc": "python turn list to rdd", "code": "def _to_java_object_rdd(rdd):\n    \"\"\" Return an JavaRDD of Object by unpickling\n\n    It will convert each Python object into Java object by Pyrolite, whenever the\n    RDD is serialized in batch or not.\n    \"\"\"\n    rdd = rdd._reserialize(AutoBatchedSerializer(PickleSerializer()))\n    return rdd.ctx._jvm.org.apache.spark.ml.python.MLSerDe.pythonToJava(rdd._jrdd, True)", "code_tokens": "def _to_java_object_rdd ( rdd ) : rdd = rdd . _reserialize ( AutoBatchedSerializer ( PickleSerializer ( ) ) ) return rdd . ctx . _jvm . org . apache . spark . ml . python . MLSerDe . pythonToJava ( rdd . _jrdd , True )", "docstring_tokens": "Return an JavaRDD of Object by unpickling", "label": 1}, {"idx": "cosqa-train-9974", "doc": "is there any wrapper that can ensure to use matlab's functions in python", "code": "def run_func(self, func_path, *func_args, **kwargs):\n        \"\"\"Run a function in Matlab and return the result.\n\n        Parameters\n        ----------\n        func_path: str\n            Name of function to run or a path to an m-file.\n        func_args: object, optional\n            Function args to send to the function.\n        nargout: int, optional\n            Desired number of return arguments.\n        kwargs:\n            Keyword arguments are passed to Matlab in the form [key, val] so\n            that matlab.plot(x, y, '--', LineWidth=2) would be translated into\n            plot(x, y, '--', 'LineWidth', 2)\n\n        Returns\n        -------\n        Result dictionary with keys: 'message', 'result', and 'success'\n        \"\"\"\n        if not self.started:\n            raise ValueError('Session not started, use start()')\n\n        nargout = kwargs.pop('nargout', 1)\n        func_args += tuple(item for pair in zip(kwargs.keys(), kwargs.values())\n                           for item in pair)\n        dname = os.path.dirname(func_path)\n        fname = os.path.basename(func_path)\n        func_name, ext = os.path.splitext(fname)\n        if ext and not ext == '.m':\n            raise TypeError('Need to give path to .m file')\n        return self._json_response(cmd='eval',\n                                   func_name=func_name,\n                                   func_args=func_args or '',\n                                   dname=dname,\n                                   nargout=nargout)", "code_tokens": "def run_func ( self , func_path , * func_args , * * kwargs ) : if not self . started : raise ValueError ( 'Session not started, use start()' ) nargout = kwargs . pop ( 'nargout' , 1 ) func_args += tuple ( item for pair in zip ( kwargs . keys ( ) , kwargs . values ( ) ) for item in pair ) dname = os . path . dirname ( func_path ) fname = os . path . basename ( func_path ) func_name , ext = os . path . splitext ( fname ) if ext and not ext == '.m' : raise TypeError ( 'Need to give path to .m file' ) return self . _json_response ( cmd = 'eval' , func_name = func_name , func_args = func_args or '' , dname = dname , nargout = nargout )", "docstring_tokens": "Run a function in Matlab and return the result .", "label": 1}, {"idx": "cosqa-train-9975", "doc": "python turn self into list", "code": "def as_list(self):\n        \"\"\"Return all child objects in nested lists of strings.\"\"\"\n        return [self.name, self.value, [x.as_list for x in self.children]]", "code_tokens": "def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]", "docstring_tokens": "Return all child objects in nested lists of strings .", "label": 1}, {"idx": "cosqa-train-9976", "doc": "is using relative path safe python", "code": "def fixpath(path):\n    \"\"\"Uniformly format a path.\"\"\"\n    return os.path.normpath(os.path.realpath(os.path.expanduser(path)))", "code_tokens": "def fixpath ( path ) : return os . path . normpath ( os . path . realpath ( os . path . expanduser ( path ) ) )", "docstring_tokens": "Uniformly format a path .", "label": 0}, {"idx": "cosqa-train-9977", "doc": "python two range union", "code": "def __or__(self, other):\n        \"\"\"Return the union of two RangeSets as a new RangeSet.\n\n        (I.e. all elements that are in either set.)\n        \"\"\"\n        if not isinstance(other, set):\n            return NotImplemented\n        return self.union(other)", "code_tokens": "def __or__ ( self , other ) : if not isinstance ( other , set ) : return NotImplemented return self . union ( other )", "docstring_tokens": "Return the union of two RangeSets as a new RangeSet .", "label": 1}, {"idx": "cosqa-train-9978", "doc": "iterate ndarray without loop python", "code": "def _npiter(arr):\n    \"\"\"Wrapper for iterating numpy array\"\"\"\n    for a in np.nditer(arr, flags=[\"refs_ok\"]):\n        c = a.item()\n        if c is not None:\n            yield c", "code_tokens": "def _npiter ( arr ) : for a in np . nditer ( arr , flags = [ \"refs_ok\" ] ) : c = a . item ( ) if c is not None : yield c", "docstring_tokens": "Wrapper for iterating numpy array", "label": 0}, {"idx": "cosqa-train-9979", "doc": "python two vector multiply", "code": "def dot_v2(vec1, vec2):\n    \"\"\"Return the dot product of two vectors\"\"\"\n\n    return vec1.x * vec2.x + vec1.y * vec2.y", "code_tokens": "def dot_v2 ( vec1 , vec2 ) : return vec1 . x * vec2 . x + vec1 . y * vec2 . y", "docstring_tokens": "Return the dot product of two vectors", "label": 1}, {"idx": "cosqa-train-9980", "doc": "iterate through files in a directory python\\", "code": "def search_script_directory(self, path):\n        \"\"\"\n        Recursively loop through a directory to find all python\n        script files. When one is found, it is analyzed for import statements\n        :param path: string\n        :return: generator\n        \"\"\"\n        for subdir, dirs, files in os.walk(path):\n            for file_name in files:\n                if file_name.endswith(\".py\"):\n                    self.search_script_file(subdir, file_name)", "code_tokens": "def search_script_directory ( self , path ) : for subdir , dirs , files in os . walk ( path ) : for file_name in files : if file_name . endswith ( \".py\" ) : self . search_script_file ( subdir , file_name )", "docstring_tokens": "Recursively loop through a directory to find all python script files . When one is found it is analyzed for import statements : param path : string : return : generator", "label": 1}, {"idx": "cosqa-train-9981", "doc": "python type hinting return method", "code": "def parse_parameter(value):\n    \"\"\"\n    @return: The best approximation of a type of the given value.\n    \"\"\"\n    if any((isinstance(value, float), isinstance(value, int), isinstance(value, bool))):\n        return value\n\n    try:\n        return int(value)\n    except ValueError:\n        try:\n            return float(value)\n        except ValueError:\n            if value in string_aliases.true_boolean_aliases:\n                return True\n            elif value in string_aliases.false_boolean_aliases:\n                return False\n            else:\n                return str(value)", "code_tokens": "def parse_parameter ( value ) : if any ( ( isinstance ( value , float ) , isinstance ( value , int ) , isinstance ( value , bool ) ) ) : return value try : return int ( value ) except ValueError : try : return float ( value ) except ValueError : if value in string_aliases . true_boolean_aliases : return True elif value in string_aliases . false_boolean_aliases : return False else : return str ( value )", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-9982", "doc": "iterating over indices of a string in python", "code": "def get_substring_idxs(substr, string):\n    \"\"\"\n    Return a list of indexes of substr. If substr not found, list is\n    empty.\n\n    Arguments:\n        substr (str): Substring to match.\n        string (str): String to match in.\n\n    Returns:\n        list of int: Start indices of substr.\n    \"\"\"\n    return [match.start() for match in re.finditer(substr, string)]", "code_tokens": "def get_substring_idxs ( substr , string ) : return [ match . start ( ) for match in re . finditer ( substr , string ) ]", "docstring_tokens": "Return a list of indexes of substr . If substr not found list is empty .", "label": 0}, {"idx": "cosqa-train-9983", "doc": "python type is a type", "code": "def is_type(value):\n        \"\"\"Determine if value is an instance or subclass of the class Type.\"\"\"\n        if isinstance(value, type):\n            return issubclass(value, Type)\n        return isinstance(value, Type)", "code_tokens": "def is_type ( value ) : if isinstance ( value , type ) : return issubclass ( value , Type ) return isinstance ( value , Type )", "docstring_tokens": "Determine if value is an instance or subclass of the class Type .", "label": 0}, {"idx": "cosqa-train-9984", "doc": "iterating through values to produce a final sum in a database python", "code": "def query_sum(queryset, field):\n    \"\"\"\n    Let the DBMS perform a sum on a queryset\n    \"\"\"\n    return queryset.aggregate(s=models.functions.Coalesce(models.Sum(field), 0))['s']", "code_tokens": "def query_sum ( queryset , field ) : return queryset . aggregate ( s = models . functions . Coalesce ( models . Sum ( field ) , 0 ) ) [ 's' ]", "docstring_tokens": "Let the DBMS perform a sum on a queryset", "label": 1}, {"idx": "cosqa-train-9985", "doc": "python underscore to camelcase", "code": "def to_pascal_case(s):\n    \"\"\"Transform underscore separated string to pascal case\n\n    \"\"\"\n    return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())", "code_tokens": "def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )", "docstring_tokens": "Transform underscore separated string to pascal case", "label": 1}, {"idx": "cosqa-train-9986", "doc": "iterator is past the end python", "code": "def __next__(self):\n    \"\"\"Pop the head off the iterator and return it.\"\"\"\n    res = self._head\n    self._fill()\n    if res is None:\n      raise StopIteration()\n    return res", "code_tokens": "def __next__ ( self ) : res = self . _head self . _fill ( ) if res is None : raise StopIteration ( ) return res", "docstring_tokens": "Pop the head off the iterator and return it .", "label": 1}, {"idx": "cosqa-train-9987", "doc": "ive packet capture and create pcap using pyshark in python", "code": "def wireshark(pktlist, *args):\n    \"\"\"Run wireshark on a list of packets\"\"\"\n    fname = get_temp_file()\n    wrpcap(fname, pktlist)\n    subprocess.Popen([conf.prog.wireshark, \"-r\", fname] + list(args))", "code_tokens": "def wireshark ( pktlist , * args ) : fname = get_temp_file ( ) wrpcap ( fname , pktlist ) subprocess . Popen ( [ conf . prog . wireshark , \"-r\" , fname ] + list ( args ) )", "docstring_tokens": "Run wireshark on a list of packets", "label": 0}, {"idx": "cosqa-train-9988", "doc": "jacobian of function in python", "code": "def jac(x,a):\n    \"\"\" Jacobian matrix given Christophe's suggestion of f \"\"\"\n    return (x-a) / np.sqrt(((x-a)**2).sum(1))[:,np.newaxis]", "code_tokens": "def jac ( x , a ) : return ( x - a ) / np . sqrt ( ( ( x - a ) ** 2 ) . sum ( 1 ) ) [ : , np . newaxis ]", "docstring_tokens": "Jacobian matrix given Christophe s suggestion of f", "label": 1}, {"idx": "cosqa-train-9989", "doc": "python unit test rebuild project", "code": "def autobuild_python_test(path):\n    \"\"\"Add pytest unit tests to be built as part of build/test/output.\"\"\"\n\n    env = Environment(tools=[])\n    target = env.Command(['build/test/output/pytest.log'], [path],\n                         action=env.Action(run_pytest, \"Running python unit tests\"))\n    env.AlwaysBuild(target)", "code_tokens": "def autobuild_python_test ( path ) : env = Environment ( tools = [ ] ) target = env . Command ( [ 'build/test/output/pytest.log' ] , [ path ] , action = env . Action ( run_pytest , \"Running python unit tests\" ) ) env . AlwaysBuild ( target )", "docstring_tokens": "Add pytest unit tests to be built as part of build / test / output .", "label": 1}, {"idx": "cosqa-train-9990", "doc": "java api to run python code", "code": "def test_python_java_rt():\n    \"\"\" Run Python test cases against Java runtime classes. \"\"\"\n    sub_env = {'PYTHONPATH': _build_dir()}\n\n    log.info('Executing Python unit tests (against Java runtime classes)...')\n    return jpyutil._execute_python_scripts(python_java_rt_tests,\n                                           env=sub_env)", "code_tokens": "def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )", "docstring_tokens": "Run Python test cases against Java runtime classes .", "label": 0}, {"idx": "cosqa-train-9991", "doc": "python unittest assertregex caseinsesitive", "code": "def raises_regex(self, expected_exception, expected_regexp):\n        \"\"\"\n        Ensures preceding predicates (specifically, :meth:`called_with()`) result in *expected_exception* being raised,\n        and the string representation of *expected_exception* must match regular expression *expected_regexp*.\n        \"\"\"\n        return unittest_case.assertRaisesRegexp(expected_exception, expected_regexp, self._orig_subject,\n                                                *self._args, **self._kwargs)", "code_tokens": "def raises_regex ( self , expected_exception , expected_regexp ) : return unittest_case . assertRaisesRegexp ( expected_exception , expected_regexp , self . _orig_subject , * self . _args , * * self . _kwargs )", "docstring_tokens": "Ensures preceding predicates ( specifically : meth : called_with () ) result in * expected_exception * being raised and the string representation of * expected_exception * must match regular expression * expected_regexp * .", "label": 1}, {"idx": "cosqa-train-9992", "doc": "java compress and python zlib compress result don't be same", "code": "def compressBuffer(buffer):\n    \"\"\"\n    Note that this code compresses into a buffer held in memory, rather\n    than a disk file. This is done through the use of cStringIO.StringIO().\n    \"\"\"\n    # http://jython.xhaus.com/http-compression-in-python-and-jython/\n    zbuf = cStringIO.StringIO()\n    zfile = gzip.GzipFile(mode='wb', fileobj=zbuf, compresslevel=9)\n    zfile.write(buffer)\n    zfile.close()\n    return zbuf.getvalue()", "code_tokens": "def compressBuffer ( buffer ) : # http://jython.xhaus.com/http-compression-in-python-and-jython/ zbuf = cStringIO . StringIO ( ) zfile = gzip . GzipFile ( mode = 'wb' , fileobj = zbuf , compresslevel = 9 ) zfile . write ( buffer ) zfile . close ( ) return zbuf . getvalue ( )", "docstring_tokens": "Note that this code compresses into a buffer held in memory rather than a disk file . This is done through the use of cStringIO . StringIO () .", "label": 0}, {"idx": "cosqa-train-9993", "doc": "python unittest make tests discoverable", "code": "def test():\n    \"\"\"Run the unit tests.\"\"\"\n    import unittest\n    tests = unittest.TestLoader().discover('tests')\n    unittest.TextTestRunner(verbosity=2).run(tests)", "code_tokens": "def test ( ) : import unittest tests = unittest . TestLoader ( ) . discover ( 'tests' ) unittest . TextTestRunner ( verbosity = 2 ) . run ( tests )", "docstring_tokens": "Run the unit tests .", "label": 1}, {"idx": "cosqa-train-9994", "doc": "java runtime calling python script", "code": "def test_python_java_rt():\n    \"\"\" Run Python test cases against Java runtime classes. \"\"\"\n    sub_env = {'PYTHONPATH': _build_dir()}\n\n    log.info('Executing Python unit tests (against Java runtime classes)...')\n    return jpyutil._execute_python_scripts(python_java_rt_tests,\n                                           env=sub_env)", "code_tokens": "def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )", "docstring_tokens": "Run Python test cases against Java runtime classes .", "label": 0}, {"idx": "cosqa-train-9995", "doc": "javascript equivalent libraries for python", "code": "def import_js(path, lib_name, globals):\n    \"\"\"Imports from javascript source file.\n      globals is your globals()\"\"\"\n    with codecs.open(path_as_local(path), \"r\", \"utf-8\") as f:\n        js = f.read()\n    e = EvalJs()\n    e.execute(js)\n    var = e.context['var']\n    globals[lib_name] = var.to_python()", "code_tokens": "def import_js ( path , lib_name , globals ) : with codecs . open ( path_as_local ( path ) , \"r\" , \"utf-8\" ) as f : js = f . read ( ) e = EvalJs ( ) e . execute ( js ) var = e . context [ 'var' ] globals [ lib_name ] = var . to_python ( )", "docstring_tokens": "Imports from javascript source file . globals is your globals ()", "label": 0}, {"idx": "cosqa-train-9996", "doc": "python unresolved reference local folder", "code": "def import_path(self):\n    \"\"\"The full remote import path as used in import statements in `.go` source files.\"\"\"\n    return os.path.join(self.remote_root, self.pkg) if self.pkg else self.remote_root", "code_tokens": "def import_path ( self ) : return os . path . join ( self . remote_root , self . pkg ) if self . pkg else self . remote_root", "docstring_tokens": "The full remote import path as used in import statements in . go source files .", "label": 0}, {"idx": "cosqa-train-9997", "doc": "jinja template not found python", "code": "def sbatch_template(self):\n        \"\"\":return Jinja sbatch template for the current tag\"\"\"\n        template = self.sbatch_template_str\n        if template.startswith('#!'):\n            # script is embedded in YAML\n            return jinja_environment.from_string(template)\n        return jinja_environment.get_template(template)", "code_tokens": "def sbatch_template ( self ) : template = self . sbatch_template_str if template . startswith ( '#!' ) : # script is embedded in YAML return jinja_environment . from_string ( template ) return jinja_environment . get_template ( template )", "docstring_tokens": ": return Jinja sbatch template for the current tag", "label": 1}, {"idx": "cosqa-train-9998", "doc": "python unsupported operand types for *", "code": "def __init__(self,operand,operator,**args):\n        \"\"\"\n        Accepts a NumberGenerator operand, an operator, and\n        optional arguments to be provided to the operator when calling\n        it on the operand.\n        \"\"\"\n        # Note that it's currently not possible to set\n        # parameters in the superclass when creating an instance,\n        # because **args is used by this class itself.\n        super(UnaryOperator,self).__init__()\n\n        self.operand=operand\n        self.operator=operator\n        self.args=args", "code_tokens": "def __init__ ( self , operand , operator , * * args ) : # Note that it's currently not possible to set # parameters in the superclass when creating an instance, # because **args is used by this class itself. super ( UnaryOperator , self ) . __init__ ( ) self . operand = operand self . operator = operator self . args = args", "docstring_tokens": "Accepts a NumberGenerator operand an operator and optional arguments to be provided to the operator when calling it on the operand .", "label": 1}, {"idx": "cosqa-train-9999", "doc": "join list of strings with character python", "code": "def delimited(items, character='|'):\n    \"\"\"Returns a character delimited version of the provided list as a Python string\"\"\"\n    return '|'.join(items) if type(items) in (list, tuple, set) else items", "code_tokens": "def delimited ( items , character = '|' ) : return '|' . join ( items ) if type ( items ) in ( list , tuple , set ) else items", "docstring_tokens": "Returns a character delimited version of the provided list as a Python string", "label": 1}, {"idx": "cosqa-train-10000", "doc": "python update dict multiple values", "code": "def update(self, other_dict):\n        \"\"\"update() extends rather than replaces existing key lists.\"\"\"\n        for key, value in iter_multi_items(other_dict):\n            MultiDict.add(self, key, value)", "code_tokens": "def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )", "docstring_tokens": "update () extends rather than replaces existing key lists .", "label": 1}, {"idx": "cosqa-train-10001", "doc": "join list of value sinto a string python", "code": "def vectorize(values):\n    \"\"\"\n    Takes a value or list of values and returns a single result, joined by \",\"\n    if necessary.\n    \"\"\"\n    if isinstance(values, list):\n        return ','.join(str(v) for v in values)\n    return values", "code_tokens": "def vectorize ( values ) : if isinstance ( values , list ) : return ',' . join ( str ( v ) for v in values ) return values", "docstring_tokens": "Takes a value or list of values and returns a single result joined by if necessary .", "label": 0}, {"idx": "cosqa-train-10002", "doc": "python update dict using variable", "code": "def update(self, params):\n        \"\"\"Update the dev_info data from a dictionary.\n\n        Only updates if it already exists in the device.\n        \"\"\"\n        dev_info = self.json_state.get('deviceInfo')\n        dev_info.update({k: params[k] for k in params if dev_info.get(k)})", "code_tokens": "def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )", "docstring_tokens": "Update the dev_info data from a dictionary .", "label": 0}, {"idx": "cosqa-train-10003", "doc": "json to a table view in python", "code": "def index():\n    \"\"\" Display productpage with normal user and test user buttons\"\"\"\n    global productpage\n\n    table = json2html.convert(json = json.dumps(productpage),\n                              table_attributes=\"class=\\\"table table-condensed table-bordered table-hover\\\"\")\n\n    return render_template('index.html', serviceTable=table)", "code_tokens": "def index ( ) : global productpage table = json2html . convert ( json = json . dumps ( productpage ) , table_attributes = \"class=\\\"table table-condensed table-bordered table-hover\\\"\" ) return render_template ( 'index.html' , serviceTable = table )", "docstring_tokens": "Display productpage with normal user and test user buttons", "label": 1}, {"idx": "cosqa-train-10004", "doc": "python updating a property in a dict", "code": "def set_property(self, key, value):\n        \"\"\"\n        Update only one property in the dict\n        \"\"\"\n        self.properties[key] = value\n        self.sync_properties()", "code_tokens": "def set_property ( self , key , value ) : self . properties [ key ] = value self . sync_properties ( )", "docstring_tokens": "Update only one property in the dict", "label": 1}, {"idx": "cosqa-train-10005", "doc": "kafka python consumer not working", "code": "def _spawn_kafka_consumer_thread(self):\n        \"\"\"Spawns a kafka continuous consumer thread\"\"\"\n        self.logger.debug(\"Spawn kafka consumer thread\"\"\")\n        self._consumer_thread = Thread(target=self._consumer_loop)\n        self._consumer_thread.setDaemon(True)\n        self._consumer_thread.start()", "code_tokens": "def _spawn_kafka_consumer_thread ( self ) : self . logger . debug ( \"Spawn kafka consumer thread\" \"\" ) self . _consumer_thread = Thread ( target = self . _consumer_loop ) self . _consumer_thread . setDaemon ( True ) self . _consumer_thread . start ( )", "docstring_tokens": "Spawns a kafka continuous consumer thread", "label": 1}, {"idx": "cosqa-train-10006", "doc": "python url without openning browser window", "code": "def url(self):\n        \"\"\" The url of this window \"\"\"\n        with switch_window(self._browser, self.name):\n            return self._browser.url", "code_tokens": "def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "docstring_tokens": "The url of this window", "label": 1}, {"idx": "cosqa-train-10007", "doc": "keep track of how long a function has been running python", "code": "def timeit(method):\n    \"\"\"\n    A Python decorator for printing out the execution time for a function.\n\n    Adapted from:\n    www.andreas-jung.com/contents/a-python-decorator-for-measuring-the-execution-time-of-methods\n    \"\"\"\n    def timed(*args, **kw):\n        time_start = time.time()\n        result = method(*args, **kw)\n        time_end = time.time()\n        print('timeit: %r %2.2f sec (%r, %r) ' % (method.__name__, time_end-time_start, str(args)[:20], kw))\n        return result\n\n    return timed", "code_tokens": "def timeit ( method ) : def timed ( * args , * * kw ) : time_start = time . time ( ) result = method ( * args , * * kw ) time_end = time . time ( ) print ( 'timeit: %r %2.2f sec (%r, %r) ' % ( method . __name__ , time_end - time_start , str ( args ) [ : 20 ] , kw ) ) return result return timed", "docstring_tokens": "A Python decorator for printing out the execution time for a function .", "label": 1}, {"idx": "cosqa-train-10008", "doc": "python urllib get file size", "code": "def server(self):\n        \"\"\"Returns the size of remote files\n        \"\"\"\n        try:\n            tar = urllib2.urlopen(self.registry)\n            meta = tar.info()\n            return int(meta.getheaders(\"Content-Length\")[0])\n        except (urllib2.URLError, IndexError):\n            return \" \"", "code_tokens": "def server ( self ) : try : tar = urllib2 . urlopen ( self . registry ) meta = tar . info ( ) return int ( meta . getheaders ( \"Content-Length\" ) [ 0 ] ) except ( urllib2 . URLError , IndexError ) : return \" \"", "docstring_tokens": "Returns the size of remote files", "label": 1}, {"idx": "cosqa-train-10009", "doc": "kill a task in python", "code": "async def stop(self):\n        \"\"\"Stop the current task process.\n\n        Starts with SIGTERM, gives the process 1 second to terminate, then kills it\n        \"\"\"\n        # negate pid so that signals apply to process group\n        pgid = -self.process.pid\n        try:\n            os.kill(pgid, signal.SIGTERM)\n            await asyncio.sleep(1)\n            os.kill(pgid, signal.SIGKILL)\n        except (OSError, ProcessLookupError):\n            return", "code_tokens": "async def stop ( self ) : # negate pid so that signals apply to process group pgid = - self . process . pid try : os . kill ( pgid , signal . SIGTERM ) await asyncio . sleep ( 1 ) os . kill ( pgid , signal . SIGKILL ) except ( OSError , ProcessLookupError ) : return", "docstring_tokens": "Stop the current task process .", "label": 0}, {"idx": "cosqa-train-10010", "doc": "python urllib quote plus", "code": "def escape(s):\n    \"\"\"Escape a URL including any /.\"\"\"\n    if not isinstance(s, bytes):\n        s = s.encode('utf-8')\n    return quote(s, safe='~')", "code_tokens": "def escape ( s ) : if not isinstance ( s , bytes ) : s = s . encode ( 'utf-8' ) return quote ( s , safe = '~' )", "docstring_tokens": "Escape a URL including any / .", "label": 0}, {"idx": "cosqa-train-10011", "doc": "kill all python instances", "code": "def cleanup_storage(*args):\n    \"\"\"Clean up processes after SIGTERM or SIGINT is received.\"\"\"\n    ShardedClusters().cleanup()\n    ReplicaSets().cleanup()\n    Servers().cleanup()\n    sys.exit(0)", "code_tokens": "def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )", "docstring_tokens": "Clean up processes after SIGTERM or SIGINT is received .", "label": 0}, {"idx": "cosqa-train-10012", "doc": "python urlparse query string", "code": "def get_url_args(url):\n    \"\"\" Returns a dictionary from a URL params \"\"\"\n    url_data = urllib.parse.urlparse(url)\n    arg_dict = urllib.parse.parse_qs(url_data.query)\n    return arg_dict", "code_tokens": "def get_url_args ( url ) : url_data = urllib . parse . urlparse ( url ) arg_dict = urllib . parse . parse_qs ( url_data . query ) return arg_dict", "docstring_tokens": "Returns a dictionary from a URL params", "label": 0}, {"idx": "cosqa-train-10013", "doc": "kill all python processes from python", "code": "def kill_all(self, kill_signal, kill_shell=False):\n        \"\"\"Kill all running processes.\"\"\"\n        for key in self.processes.keys():\n            self.kill_process(key, kill_signal, kill_shell)", "code_tokens": "def kill_all ( self , kill_signal , kill_shell = False ) : for key in self . processes . keys ( ) : self . kill_process ( key , kill_signal , kill_shell )", "docstring_tokens": "Kill all running processes .", "label": 0}, {"idx": "cosqa-train-10014", "doc": "python use default arg", "code": "def arg_default(*args, **kwargs):\n    \"\"\"Return default argument value as given by argparse's add_argument().\n\n    The argument is passed through a mocked-up argument parser. This way, we\n    get default parameters even if the feature is called directly and not\n    through the CLI.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(*args, **kwargs)\n    args = vars(parser.parse_args([]))\n    _, default = args.popitem()\n    return default", "code_tokens": "def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default", "docstring_tokens": "Return default argument value as given by argparse s add_argument () .", "label": 1}, {"idx": "cosqa-train-10015", "doc": "kwargs inside contructor python", "code": "def updateFromKwargs(self, properties, kwargs, collector, **unused):\n        \"\"\"Primary entry point to turn 'kwargs' into 'properties'\"\"\"\n        properties[self.name] = self.getFromKwargs(kwargs)", "code_tokens": "def updateFromKwargs ( self , properties , kwargs , collector , * * unused ) : properties [ self . name ] = self . getFromKwargs ( kwargs )", "docstring_tokens": "Primary entry point to turn kwargs into properties", "label": 1}, {"idx": "cosqa-train-10016", "doc": "python use pretty print to set encoding of json", "code": "def dumps(obj):\n    \"\"\"Outputs json with formatting edits + object handling.\"\"\"\n    return json.dumps(obj, indent=4, sort_keys=True, cls=CustomEncoder)", "code_tokens": "def dumps ( obj ) : return json . dumps ( obj , indent = 4 , sort_keys = True , cls = CustomEncoder )", "docstring_tokens": "Outputs json with formatting edits + object handling .", "label": 1}, {"idx": "cosqa-train-10017", "doc": "l2 norm for array python", "code": "def l2_norm(arr):\n    \"\"\"\n    The l2 norm of an array is is defined as: sqrt(||x||), where ||x|| is the\n    dot product of the vector.\n    \"\"\"\n    arr = np.asarray(arr)\n    return np.sqrt(np.dot(arr.ravel().squeeze(), arr.ravel().squeeze()))", "code_tokens": "def l2_norm ( arr ) : arr = np . asarray ( arr ) return np . sqrt ( np . dot ( arr . ravel ( ) . squeeze ( ) , arr . ravel ( ) . squeeze ( ) ) )", "docstring_tokens": "The l2 norm of an array is is defined as : sqrt ( ||x|| ) where ||x|| is the dot product of the vector .", "label": 1}, {"idx": "cosqa-train-10018", "doc": "python using or operation with in", "code": "def notin(arg, values):\n    \"\"\"\n    Like isin, but checks whether this expression's value(s) are not\n    contained in the passed values. See isin docs for full usage.\n    \"\"\"\n    op = ops.NotContains(arg, values)\n    return op.to_expr()", "code_tokens": "def notin ( arg , values ) : op = ops . NotContains ( arg , values ) return op . to_expr ( )", "docstring_tokens": "Like isin but checks whether this expression s value ( s ) are not contained in the passed values . See isin docs for full usage .", "label": 1}, {"idx": "cosqa-train-10019", "doc": "legend title showing up as none python", "code": "def remove_legend(ax=None):\n    \"\"\"Remove legend for axes or gca.\n\n    See http://osdir.com/ml/python.matplotlib.general/2005-07/msg00285.html\n    \"\"\"\n    from pylab import gca, draw\n    if ax is None:\n        ax = gca()\n    ax.legend_ = None\n    draw()", "code_tokens": "def remove_legend ( ax = None ) : from pylab import gca , draw if ax is None : ax = gca ( ) ax . legend_ = None draw ( )", "docstring_tokens": "Remove legend for axes or gca .", "label": 1}, {"idx": "cosqa-train-10020", "doc": "python utc time to local time", "code": "def datetime_local_to_utc(local):\n    \"\"\"\n    Simple function to convert naive :std:`datetime.datetime` object containing\n    local time to a naive :std:`datetime.datetime` object with UTC time.\n    \"\"\"\n    timestamp = time.mktime(local.timetuple())\n    return datetime.datetime.utcfromtimestamp(timestamp)", "code_tokens": "def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )", "docstring_tokens": "Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time .", "label": 1}, {"idx": "cosqa-train-10021", "doc": "letter count in a string stored in a dictionary python", "code": "def _letter_map(word):\n    \"\"\"Creates a map of letter use in a word.\n\n    Args:\n        word: a string to create a letter map from\n\n    Returns:\n        a dictionary of {letter: integer count of letter in word}\n    \"\"\"\n\n    lmap = {}\n    for letter in word:\n        try:\n            lmap[letter] += 1\n        except KeyError:\n            lmap[letter] = 1\n    return lmap", "code_tokens": "def _letter_map ( word ) : lmap = { } for letter in word : try : lmap [ letter ] += 1 except KeyError : lmap [ letter ] = 1 return lmap", "docstring_tokens": "Creates a map of letter use in a word .", "label": 1}, {"idx": "cosqa-train-10022", "doc": "python utf8 decode base64 decoded string", "code": "def decode_unicode_string(string):\n    \"\"\"\n    Decode string encoded by `unicode_string`\n    \"\"\"\n    if string.startswith('[BASE64-DATA]') and string.endswith('[/BASE64-DATA]'):\n        return base64.b64decode(string[len('[BASE64-DATA]'):-len('[/BASE64-DATA]')])\n    return string", "code_tokens": "def decode_unicode_string ( string ) : if string . startswith ( '[BASE64-DATA]' ) and string . endswith ( '[/BASE64-DATA]' ) : return base64 . b64decode ( string [ len ( '[BASE64-DATA]' ) : - len ( '[/BASE64-DATA]' ) ] ) return string", "docstring_tokens": "Decode string encoded by unicode_string", "label": 1}, {"idx": "cosqa-train-10023", "doc": "limit y axis plot python", "code": "def set_ylimits(self, row, column, min=None, max=None):\n        \"\"\"Set y-axis limits of a subplot.\n\n        :param row,column: specify the subplot.\n        :param min: minimal axis value\n        :param max: maximum axis value\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_ylimits(min, max)", "code_tokens": "def set_ylimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_ylimits ( min , max )", "docstring_tokens": "Set y - axis limits of a subplot .", "label": 1}, {"idx": "cosqa-train-10024", "doc": "python uuid to base64", "code": "def generate_uuid():\n    \"\"\"Generate a UUID.\"\"\"\n    r_uuid = base64.urlsafe_b64encode(uuid.uuid4().bytes)\n    return r_uuid.decode().replace('=', '')", "code_tokens": "def generate_uuid ( ) : r_uuid = base64 . urlsafe_b64encode ( uuid . uuid4 ( ) . bytes ) return r_uuid . decode ( ) . replace ( '=' , '' )", "docstring_tokens": "Generate a UUID .", "label": 0}, {"idx": "cosqa-train-10025", "doc": "lines that start with exactly 7 spaces are treated as comments python", "code": "def _match_space_at_line(line):\n    \"\"\"Return a re.match object if an empty comment was found on line.\"\"\"\n    regex = re.compile(r\"^{0}$\".format(_MDL_COMMENT))\n    return regex.match(line)", "code_tokens": "def _match_space_at_line ( line ) : regex = re . compile ( r\"^{0}$\" . format ( _MDL_COMMENT ) ) return regex . match ( line )", "docstring_tokens": "Return a re . match object if an empty comment was found on line .", "label": 1}, {"idx": "cosqa-train-10026", "doc": "python validate argv given", "code": "def email_type(arg):\n\t\"\"\"An argparse type representing an email address.\"\"\"\n\tif not is_valid_email_address(arg):\n\t\traise argparse.ArgumentTypeError(\"{0} is not a valid email address\".format(repr(arg)))\n\treturn arg", "code_tokens": "def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( \"{0} is not a valid email address\" . format ( repr ( arg ) ) ) return arg", "docstring_tokens": "An argparse type representing an email address .", "label": 1}, {"idx": "cosqa-train-10027", "doc": "linux python ioctl modify ip", "code": "def get_ip_address(ifname):\n    \"\"\" Hack to get IP address from the interface \"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    return socket.inet_ntoa(fcntl.ioctl(\n        s.fileno(),\n        0x8915,  # SIOCGIFADDR\n        struct.pack('256s', ifname[:15])\n    )[20:24])", "code_tokens": "def get_ip_address ( ifname ) : s = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) return socket . inet_ntoa ( fcntl . ioctl ( s . fileno ( ) , 0x8915 , # SIOCGIFADDR struct . pack ( '256s' , ifname [ : 15 ] ) ) [ 20 : 24 ] )", "docstring_tokens": "Hack to get IP address from the interface", "label": 0}, {"idx": "cosqa-train-10028", "doc": "python validate json is list or dictionary", "code": "def is_valid(data):\n        \"\"\"\n        Checks if the input data is a Swagger document\n\n        :param dict data: Data to be validated\n        :return: True, if data is a Swagger\n        \"\"\"\n        return bool(data) and \\\n            isinstance(data, dict) and \\\n            bool(data.get(\"swagger\")) and \\\n            isinstance(data.get('paths'), dict)", "code_tokens": "def is_valid ( data ) : return bool ( data ) and isinstance ( data , dict ) and bool ( data . get ( \"swagger\" ) ) and isinstance ( data . get ( 'paths' ) , dict )", "docstring_tokens": "Checks if the input data is a Swagger document", "label": 0}, {"idx": "cosqa-train-10029", "doc": "linux python make symlink", "code": "def symlink(source, destination):\n    \"\"\"Create a symbolic link\"\"\"\n    log(\"Symlinking {} as {}\".format(source, destination))\n    cmd = [\n        'ln',\n        '-sf',\n        source,\n        destination,\n    ]\n    subprocess.check_call(cmd)", "code_tokens": "def symlink ( source , destination ) : log ( \"Symlinking {} as {}\" . format ( source , destination ) ) cmd = [ 'ln' , '-sf' , source , destination , ] subprocess . check_call ( cmd )", "docstring_tokens": "Create a symbolic link", "label": 1}, {"idx": "cosqa-train-10030", "doc": "python validate list has at least one", "code": "def _check_list_len(row, length):\n        \"\"\"\n        Sanity check for csv parser\n        :param row\n        :param length\n        :return:None\n        \"\"\"\n        if len(row) != length:\n            raise Exception(\n                \"row length does not match expected length of \" +\n                str(length) + \"\\nrow: \" + str(row))", "code_tokens": "def _check_list_len ( row , length ) : if len ( row ) != length : raise Exception ( \"row length does not match expected length of \" + str ( length ) + \"\\nrow: \" + str ( row ) )", "docstring_tokens": "Sanity check for csv parser : param row : param length : return : None", "label": 1}, {"idx": "cosqa-train-10031", "doc": "list dictionary scala python", "code": "def get_python_dict(scala_map):\n    \"\"\"Return a dict from entries in a scala.collection.immutable.Map\"\"\"\n    python_dict = {}\n    keys = get_python_list(scala_map.keys().toList())\n    for key in keys:\n        python_dict[key] = scala_map.apply(key)\n    return python_dict", "code_tokens": "def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict", "docstring_tokens": "Return a dict from entries in a scala . collection . immutable . Map", "label": 1}, {"idx": "cosqa-train-10032", "doc": "python variable adb shell getprop", "code": "def getprop(self, prop_name):\n        \"\"\"Get a property of the device.\n\n        This is a convenience wrapper for \"adb shell getprop xxx\".\n\n        Args:\n            prop_name: A string that is the name of the property to get.\n\n        Returns:\n            A string that is the value of the property, or None if the property\n            doesn't exist.\n        \"\"\"\n        return self.shell(\n            ['getprop', prop_name],\n            timeout=DEFAULT_GETPROP_TIMEOUT_SEC).decode('utf-8').strip()", "code_tokens": "def getprop ( self , prop_name ) : return self . shell ( [ 'getprop' , prop_name ] , timeout = DEFAULT_GETPROP_TIMEOUT_SEC ) . decode ( 'utf-8' ) . strip ( )", "docstring_tokens": "Get a property of the device .", "label": 0}, {"idx": "cosqa-train-10033", "doc": "list in python are immutable", "code": "def dedupe_list(l):\n    \"\"\"Remove duplicates from a list preserving the order.\n\n    We might be tempted to use the list(set(l)) idiom, but it doesn't preserve\n    the order, which hinders testability and does not work for lists with\n    unhashable elements.\n    \"\"\"\n    result = []\n\n    for el in l:\n        if el not in result:\n            result.append(el)\n\n    return result", "code_tokens": "def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result", "docstring_tokens": "Remove duplicates from a list preserving the order .", "label": 1}, {"idx": "cosqa-train-10034", "doc": "python variable input add to list", "code": "def add_input_variable(self, var):\n        \"\"\"Adds the argument variable as one of the input variable\"\"\"\n        assert(isinstance(var, Variable))\n        self.input_variable_list.append(var)", "code_tokens": "def add_input_variable ( self , var ) : assert ( isinstance ( var , Variable ) ) self . input_variable_list . append ( var )", "docstring_tokens": "Adds the argument variable as one of the input variable", "label": 1}, {"idx": "cosqa-train-10035", "doc": "list into dictionary in python", "code": "def list2dict(lst):\n    \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"\n\n    dic = {}\n    for k,v in lst: dic[k] = v\n    return dic", "code_tokens": "def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic", "docstring_tokens": "Takes a list of ( key value ) pairs and turns it into a dict .", "label": 1}, {"idx": "cosqa-train-10036", "doc": "python vector from two points", "code": "def dot_v2(vec1, vec2):\n    \"\"\"Return the dot product of two vectors\"\"\"\n\n    return vec1.x * vec2.x + vec1.y * vec2.y", "code_tokens": "def dot_v2 ( vec1 , vec2 ) : return vec1 . x * vec2 . x + vec1 . y * vec2 . y", "docstring_tokens": "Return the dot product of two vectors", "label": 1}, {"idx": "cosqa-train-10037", "doc": "load json data from file in python", "code": "def open_json(file_name):\n    \"\"\"\n    returns json contents as string\n    \"\"\"\n    with open(file_name, \"r\") as json_data:\n        data = json.load(json_data)\n        return data", "code_tokens": "def open_json ( file_name ) : with open ( file_name , \"r\" ) as json_data : data = json . load ( json_data ) return data", "docstring_tokens": "returns json contents as string", "label": 0}, {"idx": "cosqa-train-10038", "doc": "python vector two points", "code": "def dot_v2(vec1, vec2):\n    \"\"\"Return the dot product of two vectors\"\"\"\n\n    return vec1.x * vec2.x + vec1.y * vec2.y", "code_tokens": "def dot_v2 ( vec1 , vec2 ) : return vec1 . x * vec2 . x + vec1 . y * vec2 . y", "docstring_tokens": "Return the dot product of two vectors", "label": 0}, {"idx": "cosqa-train-10039", "doc": "load json with chinese characters in python", "code": "def load_jsonf(fpath, encoding):\n    \"\"\"\n    :param unicode fpath:\n    :param unicode encoding:\n    :rtype: dict | list\n    \"\"\"\n    with codecs.open(fpath, encoding=encoding) as f:\n        return json.load(f)", "code_tokens": "def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )", "docstring_tokens": ": param unicode fpath : : param unicode encoding : : rtype : dict | list", "label": 1}, {"idx": "cosqa-train-10040", "doc": "python verify text in alert window", "code": "def check_alert(self, text):\n    \"\"\"\n    Assert an alert is showing with the given text.\n    \"\"\"\n\n    try:\n        alert = Alert(world.browser)\n        if alert.text != text:\n            raise AssertionError(\n                \"Alert text expected to be {!r}, got {!r}.\".format(\n                    text, alert.text))\n    except WebDriverException:\n        # PhantomJS is kinda poor\n        pass", "code_tokens": "def check_alert ( self , text ) : try : alert = Alert ( world . browser ) if alert . text != text : raise AssertionError ( \"Alert text expected to be {!r}, got {!r}.\" . format ( text , alert . text ) ) except WebDriverException : # PhantomJS is kinda poor pass", "docstring_tokens": "Assert an alert is showing with the given text .", "label": 1}, {"idx": "cosqa-train-10041", "doc": "logarithmic scale python plots", "code": "def glog(x,l = 2):\n    \"\"\"\n    Generalised logarithm\n\n    :param x: number\n    :param p: number added befor logarithm \n\n    \"\"\"\n    return np.log((x+np.sqrt(x**2+l**2))/2)/np.log(l)", "code_tokens": "def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )", "docstring_tokens": "Generalised logarithm", "label": 0}, {"idx": "cosqa-train-10042", "doc": "python view it size must be a divisor of the total size", "code": "def size(self):\n        \"\"\"Return the viewable size of the Table as @tuple (x,y)\"\"\"\n        width = max(\n            map(lambda x: x.size()[0], self.sections.itervalues()))\n\n        height = sum(\n            map(lambda x: x.size()[1], self.sections.itervalues()))\n\n        return width, height", "code_tokens": "def size ( self ) : width = max ( map ( lambda x : x . size ( ) [ 0 ] , self . sections . itervalues ( ) ) ) height = sum ( map ( lambda x : x . size ( ) [ 1 ] , self . sections . itervalues ( ) ) ) return width , height", "docstring_tokens": "Return the viewable size of the Table as", "label": 0}, {"idx": "cosqa-train-10043", "doc": "logger stops logging after requests python", "code": "def should_skip_logging(func):\n    \"\"\"\n    Should we skip logging for this handler?\n\n    \"\"\"\n    disabled = strtobool(request.headers.get(\"x-request-nolog\", \"false\"))\n    return disabled or getattr(func, SKIP_LOGGING, False)", "code_tokens": "def should_skip_logging ( func ) : disabled = strtobool ( request . headers . get ( \"x-request-nolog\" , \"false\" ) ) return disabled or getattr ( func , SKIP_LOGGING , False )", "docstring_tokens": "Should we skip logging for this handler?", "label": 1}, {"idx": "cosqa-train-10044", "doc": "python view vector to azimuth elevation", "code": "def world_to_view(v):\n    \"\"\"world coords to view coords; v an eu.Vector2, returns (float, float)\"\"\"\n    return v.x * config.scale_x, v.y * config.scale_y", "code_tokens": "def world_to_view ( v ) : return v . x * config . scale_x , v . y * config . scale_y", "docstring_tokens": "world coords to view coords ; v an eu . Vector2 returns ( float float )", "label": 0}, {"idx": "cosqa-train-10045", "doc": "lognormal regression random effects python", "code": "def lognorm(x, mu, sigma=1.0):\n    \"\"\" Log-normal function from scipy \"\"\"\n    return stats.lognorm(sigma, scale=mu).pdf(x)", "code_tokens": "def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )", "docstring_tokens": "Log - normal function from scipy", "label": 1}, {"idx": "cosqa-train-10046", "doc": "python virtualenv deactivate with delete", "code": "def rm(venv_name):\n    \"\"\" Removes the venv by name \"\"\"\n    inenv = InenvManager()\n    venv = inenv.get_venv(venv_name)\n    click.confirm(\"Delete dir {}\".format(venv.path))\n    shutil.rmtree(venv.path)", "code_tokens": "def rm ( venv_name ) : inenv = InenvManager ( ) venv = inenv . get_venv ( venv_name ) click . confirm ( \"Delete dir {}\" . format ( venv . path ) ) shutil . rmtree ( venv . path )", "docstring_tokens": "Removes the venv by name", "label": 1}, {"idx": "cosqa-train-10047", "doc": "macos python appkit windowsid", "code": "def setAsApplication(myappid):\n    \"\"\"\n    Tells Windows this is an independent application with an unique icon on task bar.\n\n    id is an unique string to identify this application, like: 'mycompany.myproduct.subproduct.version'\n    \"\"\"\n\n    if os.name == 'nt':\n        import ctypes\n        ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)", "code_tokens": "def setAsApplication ( myappid ) : if os . name == 'nt' : import ctypes ctypes . windll . shell32 . SetCurrentProcessExplicitAppUserModelID ( myappid )", "docstring_tokens": "Tells Windows this is an independent application with an unique icon on task bar .", "label": 1}, {"idx": "cosqa-train-10048", "doc": "python virtualenv how to deactivate", "code": "def _disable_venv(self, env):\n        \"\"\"\n        Disable virtualenv and venv in the environment.\n        \"\"\"\n        venv = env.pop('VIRTUAL_ENV', None)\n        if venv:\n            venv_path, sep, env['PATH'] = env['PATH'].partition(os.pathsep)", "code_tokens": "def _disable_venv ( self , env ) : venv = env . pop ( 'VIRTUAL_ENV' , None ) if venv : venv_path , sep , env [ 'PATH' ] = env [ 'PATH' ] . partition ( os . pathsep )", "docstring_tokens": "Disable virtualenv and venv in the environment .", "label": 0}, {"idx": "cosqa-train-10049", "doc": "python weak reference to bound method", "code": "def attr_cache_clear(self):\n        node = extract_node(\"\"\"def cache_clear(self): pass\"\"\")\n        return BoundMethod(proxy=node, bound=self._instance.parent.scope())", "code_tokens": "def attr_cache_clear ( self ) : node = extract_node ( \"\"\"def cache_clear(self): pass\"\"\" ) return BoundMethod ( proxy = node , bound = self . _instance . parent . scope ( ) )", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-10050", "doc": "make a list into a set that maintains order python", "code": "def unique_everseen(seq):\n    \"\"\"Solution found here : http://stackoverflow.com/questions/480214/how-do-you-remove-duplicates-from-a-list-in-python-whilst-preserving-order\"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def unique_everseen ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "Solution found here : http : // stackoverflow . com / questions / 480214 / how - do - you - remove - duplicates - from - a - list - in - python - whilst - preserving - order", "label": 0}, {"idx": "cosqa-train-10051", "doc": "python web form automate javascript", "code": "def submit_by_selector(self, selector):\n    \"\"\"Submit the form matching the CSS selector.\"\"\"\n    elem = find_element_by_jquery(world.browser, selector)\n    elem.submit()", "code_tokens": "def submit_by_selector ( self , selector ) : elem = find_element_by_jquery ( world . browser , selector ) elem . submit ( )", "docstring_tokens": "Submit the form matching the CSS selector .", "label": 0}, {"idx": "cosqa-train-10052", "doc": "make a list into dictionary python", "code": "def list2dict(lst):\n    \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"\n\n    dic = {}\n    for k,v in lst: dic[k] = v\n    return dic", "code_tokens": "def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic", "docstring_tokens": "Takes a list of ( key value ) pairs and turns it into a dict .", "label": 0}, {"idx": "cosqa-train-10053", "doc": "python webdriver click not clickable", "code": "def click(self):\n        \"\"\"Click the element\n\n        :returns: page element instance\n        \"\"\"\n        try:\n            self.wait_until_clickable().web_element.click()\n        except StaleElementReferenceException:\n            # Retry if element has changed\n            self.web_element.click()\n        return self", "code_tokens": "def click ( self ) : try : self . wait_until_clickable ( ) . web_element . click ( ) except StaleElementReferenceException : # Retry if element has changed self . web_element . click ( ) return self", "docstring_tokens": "Click the element", "label": 1}, {"idx": "cosqa-train-10054", "doc": "make a list of the unique letters used in a sentence python", "code": "def make_unique_ngrams(s, n):\n    \"\"\"Make a set of unique n-grams from a string.\"\"\"\n    return set(s[i:i + n] for i in range(len(s) - n + 1))", "code_tokens": "def make_unique_ngrams ( s , n ) : return set ( s [ i : i + n ] for i in range ( len ( s ) - n + 1 ) )", "docstring_tokens": "Make a set of unique n - grams from a string .", "label": 1}, {"idx": "cosqa-train-10055", "doc": "python webdriver not detectable", "code": "def is_webdriver_ios(webdriver):\n        \"\"\"\n        Check if a web driver if mobile.\n\n        Args:\n            webdriver (WebDriver): Selenium webdriver.\n\n        \"\"\"\n        browser = webdriver.capabilities['browserName']\n\n        if (browser == u('iPhone') or \n            browser == u('iPad')):\n            return True\n        else:\n            return False", "code_tokens": "def is_webdriver_ios ( webdriver ) : browser = webdriver . capabilities [ 'browserName' ] if ( browser == u ( 'iPhone' ) or browser == u ( 'iPad' ) ) : return True else : return False", "docstring_tokens": "Check if a web driver if mobile .", "label": 0}, {"idx": "cosqa-train-10056", "doc": "make a pd from a list python", "code": "def to_dataframe(products):\n        \"\"\"Return the products from a query response as a Pandas DataFrame\n        with the values in their appropriate Python types.\n        \"\"\"\n        try:\n            import pandas as pd\n        except ImportError:\n            raise ImportError(\"to_dataframe requires the optional dependency Pandas.\")\n\n        return pd.DataFrame.from_dict(products, orient='index')", "code_tokens": "def to_dataframe ( products ) : try : import pandas as pd except ImportError : raise ImportError ( \"to_dataframe requires the optional dependency Pandas.\" ) return pd . DataFrame . from_dict ( products , orient = 'index' )", "docstring_tokens": "Return the products from a query response as a Pandas DataFrame with the values in their appropriate Python types .", "label": 1}, {"idx": "cosqa-train-10057", "doc": "python webserver run a background thread", "code": "def start(self):\n        \"\"\"Create a background thread for httpd and serve 'forever'\"\"\"\n        self._process = threading.Thread(target=self._background_runner)\n        self._process.start()", "code_tokens": "def start ( self ) : self . _process = threading . Thread ( target = self . _background_runner ) self . _process . start ( )", "docstring_tokens": "Create a background thread for httpd and serve forever", "label": 0}, {"idx": "cosqa-train-10058", "doc": "make each list element a string python", "code": "def commajoin_as_strings(iterable):\n    \"\"\" Join the given iterable with ',' \"\"\"\n    return _(u',').join((six.text_type(i) for i in iterable))", "code_tokens": "def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )", "docstring_tokens": "Join the given iterable with", "label": 1}, {"idx": "cosqa-train-10059", "doc": "python websocket server restablish connection", "code": "def disconnect(self):\n        \"\"\"\n        Closes the connection.\n        \"\"\"\n        self.logger.debug('Close connection...')\n\n        self.auto_reconnect = False\n\n        if self.websocket is not None:\n            self.websocket.close()", "code_tokens": "def disconnect ( self ) : self . logger . debug ( 'Close connection...' ) self . auto_reconnect = False if self . websocket is not None : self . websocket . close ( )", "docstring_tokens": "Closes the connection .", "label": 1}, {"idx": "cosqa-train-10060", "doc": "make list of arrays a single array python", "code": "def pack_triples_numpy(triples):\n    \"\"\"Packs a list of triple indexes into a 2D numpy array.\"\"\"\n    if len(triples) == 0:\n        return np.array([], dtype=np.int64)\n    return np.stack(list(map(_transform_triple_numpy, triples)), axis=0)", "code_tokens": "def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )", "docstring_tokens": "Packs a list of triple indexes into a 2D numpy array .", "label": 0}, {"idx": "cosqa-train-10061", "doc": "python websocket stream remove delay", "code": "def settimeout(self, timeout):\n        \"\"\"\n        Set the timeout to the websocket.\n\n        timeout: timeout time(second).\n        \"\"\"\n        self.sock_opt.timeout = timeout\n        if self.sock:\n            self.sock.settimeout(timeout)", "code_tokens": "def settimeout ( self , timeout ) : self . sock_opt . timeout = timeout if self . sock : self . sock . settimeout ( timeout )", "docstring_tokens": "Set the timeout to the websocket .", "label": 1}, {"idx": "cosqa-train-10062", "doc": "make random subset from table python", "code": "def select_random(engine, table_or_columns, limit=5):\n    \"\"\"\n    Randomly select some rows from table.\n    \"\"\"\n    s = select(table_or_columns).order_by(func.random()).limit(limit)\n    return engine.execute(s).fetchall()", "code_tokens": "def select_random ( engine , table_or_columns , limit = 5 ) : s = select ( table_or_columns ) . order_by ( func . random ( ) ) . limit ( limit ) return engine . execute ( s ) . fetchall ( )", "docstring_tokens": "Randomly select some rows from table .", "label": 1}, {"idx": "cosqa-train-10063", "doc": "python websocket trapping connection refused", "code": "def _ws_on_close(self, ws: websocket.WebSocketApp):\n        \"\"\"Callback for closing the websocket connection\n\n        Args:\n            ws: websocket connection (now closed)\n        \"\"\"\n        self.connected = False\n        self.logger.error('Websocket closed')\n        self._reconnect_websocket()", "code_tokens": "def _ws_on_close ( self , ws : websocket . WebSocketApp ) : self . connected = False self . logger . error ( 'Websocket closed' ) self . _reconnect_websocket ( )", "docstring_tokens": "Callback for closing the websocket connection", "label": 0}, {"idx": "cosqa-train-10064", "doc": "make string capitalized python", "code": "def classnameify(s):\n  \"\"\"\n  Makes a classname\n  \"\"\"\n  return ''.join(w if w in ACRONYMS else w.title() for w in s.split('_'))", "code_tokens": "def classnameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '_' ) )", "docstring_tokens": "Makes a classname", "label": 0}, {"idx": "cosqa-train-10065", "doc": "python whether a file exist", "code": "def _file_exists(path, filename):\n  \"\"\"Checks if the filename exists under the path.\"\"\"\n  return os.path.isfile(os.path.join(path, filename))", "code_tokens": "def _file_exists ( path , filename ) : return os . path . isfile ( os . path . join ( path , filename ) )", "docstring_tokens": "Checks if the filename exists under the path .", "label": 1}, {"idx": "cosqa-train-10066", "doc": "make top row headers python", "code": "def top(n, width=WIDTH, style=STYLE):\n    \"\"\"Prints the top row of a table\"\"\"\n    return hrule(n, width, linestyle=STYLES[style].top)", "code_tokens": "def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )", "docstring_tokens": "Prints the top row of a table", "label": 1}, {"idx": "cosqa-train-10067", "doc": "python white space in path", "code": "def join_field(path):\n    \"\"\"\n    RETURN field SEQUENCE AS STRING\n    \"\"\"\n    output = \".\".join([f.replace(\".\", \"\\\\.\") for f in path if f != None])\n    return output if output else \".\"", "code_tokens": "def join_field ( path ) : output = \".\" . join ( [ f . replace ( \".\" , \"\\\\.\" ) for f in path if f != None ] ) return output if output else \".\"", "docstring_tokens": "RETURN field SEQUENCE AS STRING", "label": 1}, {"idx": "cosqa-train-10068", "doc": "make wpf ui for ironpython", "code": "def create_widget(self):\n        \"\"\" Create the toolkit widget for the proxy object.\n        \"\"\"\n        d = self.declaration\n        button_type = UIButton.UIButtonTypeSystem if d.flat else UIButton.UIButtonTypeRoundedRect\n        self.widget = UIButton(buttonWithType=button_type)", "code_tokens": "def create_widget ( self ) : d = self . declaration button_type = UIButton . UIButtonTypeSystem if d . flat else UIButton . UIButtonTypeRoundedRect self . widget = UIButton ( buttonWithType = button_type )", "docstring_tokens": "Create the toolkit widget for the proxy object .", "label": 1}, {"idx": "cosqa-train-10069", "doc": "python window close button", "code": "def closing_plugin(self, cancelable=False):\n        \"\"\"Perform actions before parent main window is closed\"\"\"\n        self.dialog_manager.close_all()\n        self.shell.exit_interpreter()\n        return True", "code_tokens": "def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True", "docstring_tokens": "Perform actions before parent main window is closed", "label": 1}, {"idx": "cosqa-train-10070", "doc": "making dictionary from list and conditionals python", "code": "def atom_criteria(*params):\n    \"\"\"An auxiliary function to construct a dictionary of Criteria\"\"\"\n    result = {}\n    for index, param in enumerate(params):\n        if param is None:\n            continue\n        elif isinstance(param, int):\n            result[index] = HasAtomNumber(param)\n        else:\n            result[index] = param\n    return result", "code_tokens": "def atom_criteria ( * params ) : result = { } for index , param in enumerate ( params ) : if param is None : continue elif isinstance ( param , int ) : result [ index ] = HasAtomNumber ( param ) else : result [ index ] = param return result", "docstring_tokens": "An auxiliary function to construct a dictionary of Criteria", "label": 1}, {"idx": "cosqa-train-10071", "doc": "python windows file paths fix function", "code": "def normalize_path(filename):\n    \"\"\"Normalize a file/dir name for comparison purposes\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.normpath(_cygwin_patch(filename))))", "code_tokens": "def normalize_path ( filename ) : return os . path . normcase ( os . path . realpath ( os . path . normpath ( _cygwin_patch ( filename ) ) ) )", "docstring_tokens": "Normalize a file / dir name for comparison purposes", "label": 1}, {"idx": "cosqa-train-10072", "doc": "manhattan distance in python using longitude and latitude", "code": "def _manhattan_distance(vec_a, vec_b):\n    \"\"\"Return manhattan distance between two lists of numbers.\"\"\"\n    if len(vec_a) != len(vec_b):\n        raise ValueError('len(vec_a) must equal len(vec_b)')\n    return sum(map(lambda a, b: abs(a - b), vec_a, vec_b))", "code_tokens": "def _manhattan_distance ( vec_a , vec_b ) : if len ( vec_a ) != len ( vec_b ) : raise ValueError ( 'len(vec_a) must equal len(vec_b)' ) return sum ( map ( lambda a , b : abs ( a - b ) , vec_a , vec_b ) )", "docstring_tokens": "Return manhattan distance between two lists of numbers .", "label": 1}, {"idx": "cosqa-train-10073", "doc": "python working with yaml", "code": "def show(config):\n    \"\"\"Show revision list\"\"\"\n    with open(config, 'r'):\n        main.show(yaml.load(open(config)))", "code_tokens": "def show ( config ) : with open ( config , 'r' ) : main . show ( yaml . load ( open ( config ) ) )", "docstring_tokens": "Show revision list", "label": 1}, {"idx": "cosqa-train-10074", "doc": "manhattan distance two points python", "code": "def _manhattan_distance(vec_a, vec_b):\n    \"\"\"Return manhattan distance between two lists of numbers.\"\"\"\n    if len(vec_a) != len(vec_b):\n        raise ValueError('len(vec_a) must equal len(vec_b)')\n    return sum(map(lambda a, b: abs(a - b), vec_a, vec_b))", "code_tokens": "def _manhattan_distance ( vec_a , vec_b ) : if len ( vec_a ) != len ( vec_b ) : raise ValueError ( 'len(vec_a) must equal len(vec_b)' ) return sum ( map ( lambda a , b : abs ( a - b ) , vec_a , vec_b ) )", "docstring_tokens": "Return manhattan distance between two lists of numbers .", "label": 1}, {"idx": "cosqa-train-10075", "doc": "python worksheet column index not an int in range", "code": "def x_values_ref(self, series):\n        \"\"\"\n        The Excel worksheet reference to the X values for this chart (not\n        including the column label).\n        \"\"\"\n        top_row = self.series_table_row_offset(series) + 2\n        bottom_row = top_row + len(series) - 1\n        return \"Sheet1!$A$%d:$A$%d\" % (top_row, bottom_row)", "code_tokens": "def x_values_ref ( self , series ) : top_row = self . series_table_row_offset ( series ) + 2 bottom_row = top_row + len ( series ) - 1 return \"Sheet1!$A$%d:$A$%d\" % ( top_row , bottom_row )", "docstring_tokens": "The Excel worksheet reference to the X values for this chart ( not including the column label ) .", "label": 1}, {"idx": "cosqa-train-10076", "doc": "map async function python", "code": "def asyncStarCmap(asyncCallable, iterable):\n    \"\"\"itertools.starmap for deferred callables using cooperative multitasking\n    \"\"\"\n    results = []\n    yield coopStar(asyncCallable, results.append, iterable)\n    returnValue(results)", "code_tokens": "def asyncStarCmap ( asyncCallable , iterable ) : results = [ ] yield coopStar ( asyncCallable , results . append , iterable ) returnValue ( results )", "docstring_tokens": "itertools . starmap for deferred callables using cooperative multitasking", "label": 1}, {"idx": "cosqa-train-10077", "doc": "python wrap (s,w) print", "code": "def _wrap(text, columns=80):\n    \"\"\"\n    Own \"dumb\" reimplementation of textwrap.wrap().\n\n    This is because calling .wrap() on bigger strings can take a LOT of\n    processor power. And I mean like 8 seconds of 3GHz CPU just to wrap 20kB of\n    text without spaces.\n\n    Args:\n        text (str): Text to wrap.\n        columns (int): Wrap after `columns` characters.\n\n    Returns:\n        str: Wrapped text.\n    \"\"\"\n    out = []\n    for cnt, char in enumerate(text):\n        out.append(char)\n\n        if (cnt + 1) % columns == 0:\n            out.append(\"\\n\")\n\n    return \"\".join(out)", "code_tokens": "def _wrap ( text , columns = 80 ) : out = [ ] for cnt , char in enumerate ( text ) : out . append ( char ) if ( cnt + 1 ) % columns == 0 : out . append ( \"\\n\" ) return \"\" . join ( out )", "docstring_tokens": "Own dumb reimplementation of textwrap . wrap () .", "label": 1}, {"idx": "cosqa-train-10078", "doc": "map numerical values to colormap numbers python", "code": "def sample_colormap(cmap_name, n_samples):\n    \"\"\"\n    Sample a colormap from matplotlib\n    \"\"\"\n    colors = []\n    colormap = cm.cmap_d[cmap_name]\n    for i in np.linspace(0, 1, n_samples):\n        colors.append(colormap(i))\n\n    return colors", "code_tokens": "def sample_colormap ( cmap_name , n_samples ) : colors = [ ] colormap = cm . cmap_d [ cmap_name ] for i in np . linspace ( 0 , 1 , n_samples ) : colors . append ( colormap ( i ) ) return colors", "docstring_tokens": "Sample a colormap from matplotlib", "label": 1}, {"idx": "cosqa-train-10079", "doc": "python write dict to yaml", "code": "def write_dict_to_yaml(dictionary, path, **kwargs):\n    \"\"\"\n    Writes a dictionary to a yaml file\n    :param dictionary:  the dictionary to be written\n    :param path: the absolute path of the target yaml file\n    :param kwargs: optional additional parameters for dumper\n    \"\"\"\n    with open(path, 'w') as f:\n        yaml.dump(dictionary, f, indent=4, **kwargs)", "code_tokens": "def write_dict_to_yaml ( dictionary , path , * * kwargs ) : with open ( path , 'w' ) as f : yaml . dump ( dictionary , f , indent = 4 , * * kwargs )", "docstring_tokens": "Writes a dictionary to a yaml file : param dictionary : the dictionary to be written : param path : the absolute path of the target yaml file : param kwargs : optional additional parameters for dumper", "label": 1}, {"idx": "cosqa-train-10080", "doc": "mark specific piint on graph python", "code": "def page_guiref(arg_s=None):\n    \"\"\"Show a basic reference about the GUI Console.\"\"\"\n    from IPython.core import page\n    page.page(gui_reference, auto_html=True)", "code_tokens": "def page_guiref ( arg_s = None ) : from IPython . core import page page . page ( gui_reference , auto_html = True )", "docstring_tokens": "Show a basic reference about the GUI Console .", "label": 0}, {"idx": "cosqa-train-10081", "doc": "python write fits header to new fits", "code": "def write_fits(self, fitsfile):\n        \"\"\"Write the ROI model to a FITS file.\"\"\"\n\n        tab = self.create_table()\n        hdu_data = fits.table_to_hdu(tab)\n        hdus = [fits.PrimaryHDU(), hdu_data]\n        fits_utils.write_hdus(hdus, fitsfile)", "code_tokens": "def write_fits ( self , fitsfile ) : tab = self . create_table ( ) hdu_data = fits . table_to_hdu ( tab ) hdus = [ fits . PrimaryHDU ( ) , hdu_data ] fits_utils . write_hdus ( hdus , fitsfile )", "docstring_tokens": "Write the ROI model to a FITS file .", "label": 0}, {"idx": "cosqa-train-10082", "doc": "markdown to confluence converter python", "code": "def md_to_text(content):\n    \"\"\" Converts markdown content to text \"\"\"\n    text = None\n    html = markdown.markdown(content)\n    if html:\n        text = html_to_text(content)\n    return text", "code_tokens": "def md_to_text ( content ) : text = None html = markdown . markdown ( content ) if html : text = html_to_text ( content ) return text", "docstring_tokens": "Converts markdown content to text", "label": 1}, {"idx": "cosqa-train-10083", "doc": "python write stdout encoding", "code": "def imp_print(self, text, end):\n\t\t\"\"\"Directly send utf8 bytes to stdout\"\"\"\n\t\tsys.stdout.write((text + end).encode(\"utf-8\"))", "code_tokens": "def imp_print ( self , text , end ) : sys . stdout . write ( ( text + end ) . encode ( \"utf-8\" ) )", "docstring_tokens": "Directly send utf8 bytes to stdout", "label": 1}, {"idx": "cosqa-train-10084", "doc": "match key and values from different dictionary in python", "code": "def intersect(d1, d2):\n    \"\"\"Intersect dictionaries d1 and d2 by key *and* value.\"\"\"\n    return dict((k, d1[k]) for k in d1 if k in d2 and d1[k] == d2[k])", "code_tokens": "def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )", "docstring_tokens": "Intersect dictionaries d1 and d2 by key * and * value .", "label": 1}, {"idx": "cosqa-train-10085", "doc": "python xml remove whitespaces", "code": "def cleanup_nodes(doc):\n    \"\"\"\n    Remove text nodes containing only whitespace\n    \"\"\"\n    for node in doc.documentElement.childNodes:\n        if node.nodeType == Node.TEXT_NODE and node.nodeValue.isspace():\n            doc.documentElement.removeChild(node)\n    return doc", "code_tokens": "def cleanup_nodes ( doc ) : for node in doc . documentElement . childNodes : if node . nodeType == Node . TEXT_NODE and node . nodeValue . isspace ( ) : doc . documentElement . removeChild ( node ) return doc", "docstring_tokens": "Remove text nodes containing only whitespace", "label": 0}, {"idx": "cosqa-train-10086", "doc": "matching dictionaries with slightly different keys python", "code": "def intersect(d1, d2):\n    \"\"\"Intersect dictionaries d1 and d2 by key *and* value.\"\"\"\n    return dict((k, d1[k]) for k in d1 if k in d2 and d1[k] == d2[k])", "code_tokens": "def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )", "docstring_tokens": "Intersect dictionaries d1 and d2 by key * and * value .", "label": 1}, {"idx": "cosqa-train-10087", "doc": "python xml schema except validate", "code": "def validate(self, xml_input):\n        \"\"\"\n        This method validate the parsing and schema, return a boolean\n        \"\"\"\n        parsed_xml = etree.parse(self._handle_xml(xml_input))\n        try:\n            return self.xmlschema.validate(parsed_xml)\n        except AttributeError:\n            raise CannotValidate('Set XSD to validate the XML')", "code_tokens": "def validate ( self , xml_input ) : parsed_xml = etree . parse ( self . _handle_xml ( xml_input ) ) try : return self . xmlschema . validate ( parsed_xml ) except AttributeError : raise CannotValidate ( 'Set XSD to validate the XML' )", "docstring_tokens": "This method validate the parsing and schema return a boolean", "label": 0}, {"idx": "cosqa-train-10088", "doc": "matrix data frame in python", "code": "def load_data(filename):\n    \"\"\"\n    :rtype : numpy matrix\n    \"\"\"\n    data = pandas.read_csv(filename, header=None, delimiter='\\t', skiprows=9)\n    return data.as_matrix()", "code_tokens": "def load_data ( filename ) : data = pandas . read_csv ( filename , header = None , delimiter = '\\t' , skiprows = 9 ) return data . as_matrix ( )", "docstring_tokens": ": rtype : numpy matrix", "label": 1}, {"idx": "cosqa-train-10089", "doc": "python yaml dump indentation", "code": "def print_yaml(o):\n    \"\"\"Pretty print an object as YAML.\"\"\"\n    print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))", "code_tokens": "def print_yaml ( o ) : print ( yaml . dump ( o , default_flow_style = False , indent = 4 , encoding = 'utf-8' ) )", "docstring_tokens": "Pretty print an object as YAML .", "label": 1}, {"idx": "cosqa-train-10090", "doc": "max heap insert python", "code": "def heappush_max(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown_max(heap, 0, len(heap) - 1)", "code_tokens": "def heappush_max ( heap , item ) : heap . append ( item ) _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "docstring_tokens": "Push item onto heap maintaining the heap invariant .", "label": 1}, {"idx": "cosqa-train-10091", "doc": "python yaml dump to variable", "code": "def yaml_to_param(obj, name):\n\t\"\"\"\n\tReturn the top-level element of a document sub-tree containing the\n\tYAML serialization of a Python object.\n\t\"\"\"\n\treturn from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))", "code_tokens": "def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "docstring_tokens": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object .", "label": 0}, {"idx": "cosqa-train-10092", "doc": "python yaml dump with order", "code": "def print_yaml(o):\n    \"\"\"Pretty print an object as YAML.\"\"\"\n    print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))", "code_tokens": "def print_yaml ( o ) : print ( yaml . dump ( o , default_flow_style = False , indent = 4 , encoding = 'utf-8' ) )", "docstring_tokens": "Pretty print an object as YAML .", "label": 1}, {"idx": "cosqa-train-10093", "doc": "max value stack python", "code": "def heappop_max(heap):\n    \"\"\"Maxheap version of a heappop.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup_max(heap, 0)\n        return returnitem\n    return lastelt", "code_tokens": "def heappop_max ( heap ) : lastelt = heap . pop ( ) # raises appropriate IndexError if heap is empty if heap : returnitem = heap [ 0 ] heap [ 0 ] = lastelt _siftup_max ( heap , 0 ) return returnitem return lastelt", "docstring_tokens": "Maxheap version of a heappop .", "label": 0}, {"idx": "cosqa-train-10094", "doc": "python yaml expected single document", "code": "def yaml_to_param(obj, name):\n\t\"\"\"\n\tReturn the top-level element of a document sub-tree containing the\n\tYAML serialization of a Python object.\n\t\"\"\"\n\treturn from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))", "code_tokens": "def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "docstring_tokens": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object .", "label": 1}, {"idx": "cosqa-train-10095", "doc": "maximization problem python scipy", "code": "def softmax(xs):\n    \"\"\"Stable implementation of the softmax function.\"\"\"\n    ys = xs - np.max(xs)\n    exps = np.exp(ys)\n    return exps / exps.sum(axis=0)", "code_tokens": "def softmax ( xs ) : ys = xs - np . max ( xs ) exps = np . exp ( ys ) return exps / exps . sum ( axis = 0 )", "docstring_tokens": "Stable implementation of the softmax function .", "label": 0}, {"idx": "cosqa-train-10096", "doc": "python yield unsupported operand type(s)", "code": "def visit_BinOp(self, node):\n        \"\"\" Return type depend from both operand of the binary operation. \"\"\"\n        args = [self.visit(arg) for arg in (node.left, node.right)]\n        return list({frozenset.union(*x) for x in itertools.product(*args)})", "code_tokens": "def visit_BinOp ( self , node ) : args = [ self . visit ( arg ) for arg in ( node . left , node . right ) ] return list ( { frozenset . union ( * x ) for x in itertools . product ( * args ) } )", "docstring_tokens": "Return type depend from both operand of the binary operation .", "label": 1}, {"idx": "cosqa-train-10097", "doc": "maximum list depth python", "code": "def maxlevel(lst):\n    \"\"\"Return maximum nesting depth\"\"\"\n    maxlev = 0\n    def f(lst, level):\n        nonlocal maxlev\n        if isinstance(lst, list):\n            level += 1\n            maxlev = max(level, maxlev)\n            for item in lst:\n                f(item, level)\n    f(lst, 0)\n    return maxlev", "code_tokens": "def maxlevel ( lst ) : maxlev = 0 def f ( lst , level ) : nonlocal maxlev if isinstance ( lst , list ) : level += 1 maxlev = max ( level , maxlev ) for item in lst : f ( item , level ) f ( lst , 0 ) return maxlev", "docstring_tokens": "Return maximum nesting depth", "label": 1}, {"idx": "cosqa-train-10098", "doc": "python zero width whitespace", "code": "def get_indentation(line):\n    \"\"\"Return leading whitespace.\"\"\"\n    if line.strip():\n        non_whitespace_index = len(line) - len(line.lstrip())\n        return line[:non_whitespace_index]\n    else:\n        return ''", "code_tokens": "def get_indentation ( line ) : if line . strip ( ) : non_whitespace_index = len ( line ) - len ( line . lstrip ( ) ) return line [ : non_whitespace_index ] else : return ''", "docstring_tokens": "Return leading whitespace .", "label": 1}, {"idx": "cosqa-train-10099", "doc": "maximum size of a bytes object python", "code": "def read_bytes(fo, writer_schema=None, reader_schema=None):\n    \"\"\"Bytes are encoded as a long followed by that many bytes of data.\"\"\"\n    size = read_long(fo)\n    return fo.read(size)", "code_tokens": "def read_bytes ( fo , writer_schema = None , reader_schema = None ) : size = read_long ( fo ) return fo . read ( size )", "docstring_tokens": "Bytes are encoded as a long followed by that many bytes of data .", "label": 1}, {"idx": "cosqa-train-10100", "doc": "python zipfile without folder structure", "code": "def extract_zip(zip_path, target_folder):\n    \"\"\"\n    Extract the content of the zip-file at `zip_path` into `target_folder`.\n    \"\"\"\n    with zipfile.ZipFile(zip_path) as archive:\n        archive.extractall(target_folder)", "code_tokens": "def extract_zip ( zip_path , target_folder ) : with zipfile . ZipFile ( zip_path ) as archive : archive . extractall ( target_folder )", "docstring_tokens": "Extract the content of the zip - file at zip_path into target_folder .", "label": 0}, {"idx": "cosqa-train-10101", "doc": "measure object dimension in python", "code": "def included_length(self):\n        \"\"\"Surveyed length, not including \"excluded\" shots\"\"\"\n        return sum([shot.length for shot in self.shots if shot.is_included])", "code_tokens": "def included_length ( self ) : return sum ( [ shot . length for shot in self . shots if shot . is_included ] )", "docstring_tokens": "Surveyed length not including excluded shots", "label": 1}, {"idx": "cosqa-train-10102", "doc": "python zlib decompress stream inflate", "code": "def load_streams(chunks):\n    \"\"\"\n    Given a gzipped stream of data, yield streams of decompressed data.\n    \"\"\"\n    chunks = peekable(chunks)\n    while chunks:\n        if six.PY3:\n            dc = zlib.decompressobj(wbits=zlib.MAX_WBITS | 16)\n        else:\n            dc = zlib.decompressobj(zlib.MAX_WBITS | 16)\n        yield load_stream(dc, chunks)\n        if dc.unused_data:\n            chunks = peekable(itertools.chain((dc.unused_data,), chunks))", "code_tokens": "def load_streams ( chunks ) : chunks = peekable ( chunks ) while chunks : if six . PY3 : dc = zlib . decompressobj ( wbits = zlib . MAX_WBITS | 16 ) else : dc = zlib . decompressobj ( zlib . MAX_WBITS | 16 ) yield load_stream ( dc , chunks ) if dc . unused_data : chunks = peekable ( itertools . chain ( ( dc . unused_data , ) , chunks ) )", "docstring_tokens": "Given a gzipped stream of data yield streams of decompressed data .", "label": 0}, {"idx": "cosqa-train-10103", "doc": "measure time of code python", "code": "def timeit(output):\n    \"\"\"\n    If output is string, then print the string and also time used\n    \"\"\"\n    b = time.time()\n    yield\n    print output, 'time used: %.3fs' % (time.time()-b)", "code_tokens": "def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )", "docstring_tokens": "If output is string then print the string and also time used", "label": 1}, {"idx": "cosqa-train-10104", "doc": "python zlib streaming compress", "code": "def compress(data, **kwargs):\n    \"\"\"zlib.compress(data, **kwargs)\n    \n    \"\"\" + zopfli.__COMPRESSOR_DOCSTRING__  + \"\"\"\n    Returns:\n      String containing a zlib container\n    \"\"\"\n    kwargs['gzip_mode'] = 0\n    return zopfli.zopfli.compress(data, **kwargs)", "code_tokens": "def compress ( data , * * kwargs ) : \"\"\"zlib.compress(data, **kwargs)\n    \n    \"\"\" + zopfli . __COMPRESSOR_DOCSTRING__ + \"\"\"\n    Returns:\n      String containing a zlib container\n    \"\"\" kwargs [ 'gzip_mode' ] = 0 return zopfli . zopfli . compress ( data , * * kwargs )", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-10105", "doc": "measure time of function in python", "code": "def memory_usage(method):\n  \"\"\"Log memory usage before and after a method.\"\"\"\n  def wrapper(*args, **kwargs):\n    logging.info('Memory before method %s is %s.',\n                 method.__name__, runtime.memory_usage().current())\n    result = method(*args, **kwargs)\n    logging.info('Memory after method %s is %s',\n                 method.__name__, runtime.memory_usage().current())\n    return result\n  return wrapper", "code_tokens": "def memory_usage ( method ) : def wrapper ( * args , * * kwargs ) : logging . info ( 'Memory before method %s is %s.' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) result = method ( * args , * * kwargs ) logging . info ( 'Memory after method %s is %s' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) return result return wrapper", "docstring_tokens": "Log memory usage before and after a method .", "label": 1}, {"idx": "cosqa-train-10106", "doc": "python2 stdout color windows", "code": "def auto():\n\t\"\"\"set colouring on if STDOUT is a terminal device, off otherwise\"\"\"\n\ttry:\n\t\tStyle.enabled = False\n\t\tStyle.enabled = sys.stdout.isatty()\n\texcept (AttributeError, TypeError):\n\t\tpass", "code_tokens": "def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass", "docstring_tokens": "set colouring on if STDOUT is a terminal device off otherwise", "label": 1}, {"idx": "cosqa-train-10107", "doc": "median of list values python", "code": "def getMedian(numericValues):\n    \"\"\"\n    Gets the median of a list of values\n    Returns a float/int\n    \"\"\"\n    theValues = sorted(numericValues)\n\n    if len(theValues) % 2 == 1:\n        return theValues[(len(theValues) + 1) / 2 - 1]\n    else:\n        lower = theValues[len(theValues) / 2 - 1]\n        upper = theValues[len(theValues) / 2]\n\n        return (float(lower + upper)) / 2", "code_tokens": "def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2", "docstring_tokens": "Gets the median of a list of values Returns a float / int", "label": 0}, {"idx": "cosqa-train-10108", "doc": "python3 add default value to input", "code": "def input_int_default(question=\"\", default=0):\n    \"\"\"A function that works for both, Python 2.x and Python 3.x.\n       It asks the user for input and returns it as a string.\n    \"\"\"\n    answer = input_string(question)\n    if answer == \"\" or answer == \"yes\":\n        return default\n    else:\n        return int(answer)", "code_tokens": "def input_int_default ( question = \"\" , default = 0 ) : answer = input_string ( question ) if answer == \"\" or answer == \"yes\" : return default else : return int ( answer )", "docstring_tokens": "A function that works for both Python 2 . x and Python 3 . x . It asks the user for input and returns it as a string .", "label": 1}, {"idx": "cosqa-train-10109", "doc": "merge a bunch of list pythons", "code": "def listunion(ListOfLists):\n    \"\"\"\n    Take the union of a list of lists.\n\n    Take a Python list of Python lists::\n\n            [[l11,l12, ...], [l21,l22, ...], ... , [ln1, ln2, ...]]\n\n    and return the aggregated list::\n\n            [l11,l12, ..., l21, l22 , ...]\n\n    For a list of two lists, e.g. `[a, b]`, this is like::\n\n            a.extend(b)\n\n    **Parameters**\n\n            **ListOfLists** :  Python list\n\n                    Python list of Python lists.\n\n    **Returns**\n\n            **u** :  Python list\n\n                    Python list created by taking the union of the\n                    lists in `ListOfLists`.\n\n    \"\"\"\n    u = []\n    for s in ListOfLists:\n        if s != None:\n            u.extend(s)\n    return u", "code_tokens": "def listunion ( ListOfLists ) : u = [ ] for s in ListOfLists : if s != None : u . extend ( s ) return u", "docstring_tokens": "Take the union of a list of lists .", "label": 0}, {"idx": "cosqa-train-10110", "doc": "python3 apply function to iterable", "code": "def force_iterable(f):\n    \"\"\"Will make any functions return an iterable objects by wrapping its result in a list.\"\"\"\n    def wrapper(*args, **kwargs):\n        r = f(*args, **kwargs)\n        if hasattr(r, '__iter__'):\n            return r\n        else:\n            return [r]\n    return wrapper", "code_tokens": "def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper", "docstring_tokens": "Will make any functions return an iterable objects by wrapping its result in a list .", "label": 0}, {"idx": "cosqa-train-10111", "doc": "merge keys python two dicts", "code": "def dict_merge(set1, set2):\n    \"\"\"Joins two dictionaries.\"\"\"\n    return dict(list(set1.items()) + list(set2.items()))", "code_tokens": "def dict_merge ( set1 , set2 ) : return dict ( list ( set1 . items ( ) ) + list ( set2 . items ( ) ) )", "docstring_tokens": "Joins two dictionaries .", "label": 1}, {"idx": "cosqa-train-10112", "doc": "python3 async blocking function", "code": "def asynchronous(function, event):\n    \"\"\"\n    Runs the function asynchronously taking care of exceptions.\n    \"\"\"\n    thread = Thread(target=synchronous, args=(function, event))\n    thread.daemon = True\n    thread.start()", "code_tokens": "def asynchronous ( function , event ) : thread = Thread ( target = synchronous , args = ( function , event ) ) thread . daemon = True thread . start ( )", "docstring_tokens": "Runs the function asynchronously taking care of exceptions .", "label": 1}, {"idx": "cosqa-train-10113", "doc": "merge with two different keys name in python", "code": "def dictmerge(x, y):\n    \"\"\"\n    merge two dictionaries\n    \"\"\"\n    z = x.copy()\n    z.update(y)\n    return z", "code_tokens": "def dictmerge ( x , y ) : z = x . copy ( ) z . update ( y ) return z", "docstring_tokens": "merge two dictionaries", "label": 0}, {"idx": "cosqa-train-10114", "doc": "python3 bytes string encoding", "code": "def to_bytes(value):\n    \"\"\" str to bytes (py3k) \"\"\"\n    vtype = type(value)\n\n    if vtype == bytes or vtype == type(None):\n        return value\n\n    try:\n        return vtype.encode(value)\n    except UnicodeEncodeError:\n        pass\n    return value", "code_tokens": "def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value", "docstring_tokens": "str to bytes ( py3k )", "label": 1}, {"idx": "cosqa-train-10115", "doc": "modify element in pymongo python", "code": "def upsert_single(db, collection, object, match_params=None):\n        \"\"\"\n        Wrapper for pymongo.update_one()\n        :param db: db connection\n        :param collection: collection to update\n        :param object: the modifications to apply\n        :param match_params: a query that matches the documents to update\n        :return: id of updated document\n        \"\"\"\n        return str(db[collection].update_one(match_params, {\"$set\": object}, upsert=True).upserted_id)", "code_tokens": "def upsert_single ( db , collection , object , match_params = None ) : return str ( db [ collection ] . update_one ( match_params , { \"$set\" : object } , upsert = True ) . upserted_id )", "docstring_tokens": "Wrapper for pymongo . update_one () : param db : db connection : param collection : collection to update : param object : the modifications to apply : param match_params : a query that matches the documents to update : return : id of updated document", "label": 0}, {"idx": "cosqa-train-10116", "doc": "python3 bytes to signed int", "code": "def bin_to_int(string):\n    \"\"\"Convert a one element byte string to signed int for python 2 support.\"\"\"\n    if isinstance(string, str):\n        return struct.unpack(\"b\", string)[0]\n    else:\n        return struct.unpack(\"b\", bytes([string]))[0]", "code_tokens": "def bin_to_int ( string ) : if isinstance ( string , str ) : return struct . unpack ( \"b\" , string ) [ 0 ] else : return struct . unpack ( \"b\" , bytes ( [ string ] ) ) [ 0 ]", "docstring_tokens": "Convert a one element byte string to signed int for python 2 support .", "label": 1}, {"idx": "cosqa-train-10117", "doc": "most second most recent file python", "code": "def newest_file(file_iterable):\n  \"\"\"\n  Returns the name of the newest file given an iterable of file names.\n\n  \"\"\"\n  return max(file_iterable, key=lambda fname: os.path.getmtime(fname))", "code_tokens": "def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )", "docstring_tokens": "Returns the name of the newest file given an iterable of file names .", "label": 0}, {"idx": "cosqa-train-10118", "doc": "python3 check whether a path is valid", "code": "def is_valid_folder(parser, arg):\n    \"\"\"Check if arg is a valid file that already exists on the file system.\"\"\"\n    arg = os.path.abspath(arg)\n    if not os.path.isdir(arg):\n        parser.error(\"The folder %s does not exist!\" % arg)\n    else:\n        return arg", "code_tokens": "def is_valid_folder ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . isdir ( arg ) : parser . error ( \"The folder %s does not exist!\" % arg ) else : return arg", "docstring_tokens": "Check if arg is a valid file that already exists on the file system .", "label": 1}, {"idx": "cosqa-train-10119", "doc": "motion blur gaussian blur image python", "code": "def GaussianBlur(X, ksize_width, ksize_height, sigma_x, sigma_y):\n    \"\"\"Apply Gaussian blur to the given data.\n\n    Args:\n        X: data to blur\n        kernel_size: Gaussian kernel size\n        stddev: Gaussian kernel standard deviation (in both X and Y directions)\n    \"\"\"\n    return image_transform(\n        X,\n        cv2.GaussianBlur,\n        ksize=(ksize_width, ksize_height),\n        sigmaX=sigma_x,\n        sigmaY=sigma_y\n    )", "code_tokens": "def GaussianBlur ( X , ksize_width , ksize_height , sigma_x , sigma_y ) : return image_transform ( X , cv2 . GaussianBlur , ksize = ( ksize_width , ksize_height ) , sigmaX = sigma_x , sigmaY = sigma_y )", "docstring_tokens": "Apply Gaussian blur to the given data .", "label": 1}, {"idx": "cosqa-train-10120", "doc": "python3 create md5 hash", "code": "def md5_string(s):\n    \"\"\"\n    Shortcut to create md5 hash\n    :param s:\n    :return:\n    \"\"\"\n    m = hashlib.md5()\n    m.update(s)\n    return str(m.hexdigest())", "code_tokens": "def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )", "docstring_tokens": "Shortcut to create md5 hash : param s : : return :", "label": 1}, {"idx": "cosqa-train-10121", "doc": "move the slug python", "code": "def set_slug(apps, schema_editor, class_name):\n    \"\"\"\n    Create a slug for each Work already in the DB.\n    \"\"\"\n    Cls = apps.get_model('spectator_events', class_name)\n\n    for obj in Cls.objects.all():\n        obj.slug = generate_slug(obj.pk)\n        obj.save(update_fields=['slug'])", "code_tokens": "def set_slug ( apps , schema_editor , class_name ) : Cls = apps . get_model ( 'spectator_events' , class_name ) for obj in Cls . objects . all ( ) : obj . slug = generate_slug ( obj . pk ) obj . save ( update_fields = [ 'slug' ] )", "docstring_tokens": "Create a slug for each Work already in the DB .", "label": 1}, {"idx": "cosqa-train-10122", "doc": "python3 ctypes return float array", "code": "def cfloat32_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes float pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_float)):\n        return np.fromiter(cptr, dtype=np.float32, count=length)\n    else:\n        raise RuntimeError('Expected float pointer')", "code_tokens": "def cfloat32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_float ) ) : return np . fromiter ( cptr , dtype = np . float32 , count = length ) else : raise RuntimeError ( 'Expected float pointer' )", "docstring_tokens": "Convert a ctypes float pointer array to a numpy array .", "label": 1}, {"idx": "cosqa-train-10123", "doc": "moving average based on previous data python", "code": "def moving_average(a, n):\n    \"\"\"Moving average over one-dimensional array.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        One-dimensional array.\n    n : int\n        Number of entries to average over. n=2 means averaging over the currrent\n        the previous entry.\n\n    Returns\n    -------\n    An array view storing the moving average.\n    \"\"\"\n    ret = np.cumsum(a, dtype=float)\n    ret[n:] = ret[n:] - ret[:-n]\n    return ret[n - 1:] / n", "code_tokens": "def moving_average ( a , n ) : ret = np . cumsum ( a , dtype = float ) ret [ n : ] = ret [ n : ] - ret [ : - n ] return ret [ n - 1 : ] / n", "docstring_tokens": "Moving average over one - dimensional array .", "label": 0}, {"idx": "cosqa-train-10124", "doc": "python3 daemon handling sigkill", "code": "def sigterm(self, signum, frame):\n        \"\"\"\n        These actions will be done after SIGTERM.\n        \"\"\"\n        self.logger.warning(\"Caught signal %s. Stopping daemon.\" % signum)\n        sys.exit(0)", "code_tokens": "def sigterm ( self , signum , frame ) : self . logger . warning ( \"Caught signal %s. Stopping daemon.\" % signum ) sys . exit ( 0 )", "docstring_tokens": "These actions will be done after SIGTERM .", "label": 1}, {"idx": "cosqa-train-10125", "doc": "moving to parent directory in python", "code": "def go_to_parent_directory(self):\n        \"\"\"Go to parent directory\"\"\"\n        self.chdir(osp.abspath(osp.join(getcwd_or_home(), os.pardir)))", "code_tokens": "def go_to_parent_directory ( self ) : self . chdir ( osp . abspath ( osp . join ( getcwd_or_home ( ) , os . pardir ) ) )", "docstring_tokens": "Go to parent directory", "label": 0}, {"idx": "cosqa-train-10126", "doc": "python3 decode bytes as string", "code": "def to_bytes(value):\n    \"\"\" str to bytes (py3k) \"\"\"\n    vtype = type(value)\n\n    if vtype == bytes or vtype == type(None):\n        return value\n\n    try:\n        return vtype.encode(value)\n    except UnicodeEncodeError:\n        pass\n    return value", "code_tokens": "def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value", "docstring_tokens": "str to bytes ( py3k )", "label": 1}, {"idx": "cosqa-train-10127", "doc": "multiple return values of a function python", "code": "def many_until1(these, term):\n    \"\"\"Like many_until but must consume at least one of these.\n    \"\"\"\n    first = [these()]\n    these_results, term_result = many_until(these, term)\n    return (first + these_results, term_result)", "code_tokens": "def many_until1 ( these , term ) : first = [ these ( ) ] these_results , term_result = many_until ( these , term ) return ( first + these_results , term_result )", "docstring_tokens": "Like many_until but must consume at least one of these .", "label": 1}, {"idx": "cosqa-train-10128", "doc": "python3 enum check value", "code": "def is_enum_type(type_):\n    \"\"\" Checks if the given type is an enum type.\n\n    :param type_: The type to check\n    :return: True if the type is a enum type, otherwise False\n    :rtype: bool\n    \"\"\"\n\n    return isinstance(type_, type) and issubclass(type_, tuple(_get_types(Types.ENUM)))", "code_tokens": "def is_enum_type ( type_ ) : return isinstance ( type_ , type ) and issubclass ( type_ , tuple ( _get_types ( Types . ENUM ) ) )", "docstring_tokens": "Checks if the given type is an enum type .", "label": 1}, {"idx": "cosqa-train-10129", "doc": "multiple returns for function python", "code": "def many_until1(these, term):\n    \"\"\"Like many_until but must consume at least one of these.\n    \"\"\"\n    first = [these()]\n    these_results, term_result = many_until(these, term)\n    return (first + these_results, term_result)", "code_tokens": "def many_until1 ( these , term ) : first = [ these ( ) ] these_results , term_result = many_until ( these , term ) return ( first + these_results , term_result )", "docstring_tokens": "Like many_until but must consume at least one of these .", "label": 1}, {"idx": "cosqa-train-10130", "doc": "python3 extending an empty diff results in none type", "code": "def default_diff(latest_config, current_config):\n    \"\"\"Determine if two revisions have actually changed.\"\"\"\n    # Pop off the fields we don't care about:\n    pop_no_diff_fields(latest_config, current_config)\n\n    diff = DeepDiff(\n        latest_config,\n        current_config,\n        ignore_order=True\n    )\n    return diff", "code_tokens": "def default_diff ( latest_config , current_config ) : # Pop off the fields we don't care about: pop_no_diff_fields ( latest_config , current_config ) diff = DeepDiff ( latest_config , current_config , ignore_order = True ) return diff", "docstring_tokens": "Determine if two revisions have actually changed .", "label": 1}, {"idx": "cosqa-train-10131", "doc": "multiple text files word count for each file python", "code": "def count_words(file):\n  \"\"\" Counts the word frequences in a list of sentences.\n\n  Note:\n    This is a helper function for parallel execution of `Vocabulary.from_text`\n    method.\n  \"\"\"\n  c = Counter()\n  with open(file, 'r') as f:\n    for l in f:\n      words = l.strip().split()\n      c.update(words)\n  return c", "code_tokens": "def count_words ( file ) : c = Counter ( ) with open ( file , 'r' ) as f : for l in f : words = l . strip ( ) . split ( ) c . update ( words ) return c", "docstring_tokens": "Counts the word frequences in a list of sentences .", "label": 1}, {"idx": "cosqa-train-10132", "doc": "python3 how to set a dictionary item to a value or a default", "code": "def setdefault(obj, field, default):\n    \"\"\"Set an object's field to default if it doesn't have a value\"\"\"\n    setattr(obj, field, getattr(obj, field, default))", "code_tokens": "def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )", "docstring_tokens": "Set an object s field to default if it doesn t have a value", "label": 1}, {"idx": "cosqa-train-10133", "doc": "nested arugment comma separtaed parentheses matcher python", "code": "def match_paren(self, tokens, item):\n        \"\"\"Matches a paren.\"\"\"\n        match, = tokens\n        return self.match(match, item)", "code_tokens": "def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "docstring_tokens": "Matches a paren .", "label": 0}, {"idx": "cosqa-train-10134", "doc": "python3 logger timedrotatingfilehandler rotate failed", "code": "def init_rotating_logger(level, logfile, max_files, max_bytes):\n  \"\"\"Initializes a rotating logger\n\n  It also makes sure that any StreamHandler is removed, so as to avoid stdout/stderr\n  constipation issues\n  \"\"\"\n  logging.basicConfig()\n\n  root_logger = logging.getLogger()\n  log_format = \"[%(asctime)s] [%(levelname)s] %(filename)s: %(message)s\"\n\n  root_logger.setLevel(level)\n  handler = RotatingFileHandler(logfile, maxBytes=max_bytes, backupCount=max_files)\n  handler.setFormatter(logging.Formatter(fmt=log_format, datefmt=date_format))\n  root_logger.addHandler(handler)\n\n  for handler in root_logger.handlers:\n    root_logger.debug(\"Associated handlers - \" + str(handler))\n    if isinstance(handler, logging.StreamHandler):\n      root_logger.debug(\"Removing StreamHandler: \" + str(handler))\n      root_logger.handlers.remove(handler)", "code_tokens": "def init_rotating_logger ( level , logfile , max_files , max_bytes ) : logging . basicConfig ( ) root_logger = logging . getLogger ( ) log_format = \"[%(asctime)s] [%(levelname)s] %(filename)s: %(message)s\" root_logger . setLevel ( level ) handler = RotatingFileHandler ( logfile , maxBytes = max_bytes , backupCount = max_files ) handler . setFormatter ( logging . Formatter ( fmt = log_format , datefmt = date_format ) ) root_logger . addHandler ( handler ) for handler in root_logger . handlers : root_logger . debug ( \"Associated handlers - \" + str ( handler ) ) if isinstance ( handler , logging . StreamHandler ) : root_logger . debug ( \"Removing StreamHandler: \" + str ( handler ) ) root_logger . handlers . remove ( handler )", "docstring_tokens": "Initializes a rotating logger", "label": 0}, {"idx": "cosqa-train-10135", "doc": "ngram implementation example for matching 2 sentences python", "code": "def word_matches(s1, s2, n=3):\n    \"\"\"\n        Word-level n-grams that match between two strings\n\n        Args:\n            s1: a string\n            s2: another string\n            n: an int for the n in n-gram\n\n        Returns:\n            set: the n-grams found in both strings\n    \"\"\"\n    return __matches(s1, s2, word_ngrams, n=n)", "code_tokens": "def word_matches ( s1 , s2 , n = 3 ) : return __matches ( s1 , s2 , word_ngrams , n = n )", "docstring_tokens": "Word - level n - grams that match between two strings", "label": 1}, {"idx": "cosqa-train-10136", "doc": "python3 logging add blank line", "code": "def write(self, text):\n        \"\"\"Write text. An additional attribute terminator with a value of\n           None is added to the logging record to indicate that StreamHandler\n           should not add a newline.\"\"\"\n        self.logger.log(self.loglevel, text, extra={'terminator': None})", "code_tokens": "def write ( self , text ) : self . logger . log ( self . loglevel , text , extra = { 'terminator' : None } )", "docstring_tokens": "Write text . An additional attribute terminator with a value of None is added to the logging record to indicate that StreamHandler should not add a newline .", "label": 0}, {"idx": "cosqa-train-10137", "doc": "no of records updated from executemany python", "code": "def _executemany(self, cursor, query, parameters):\n        \"\"\"The function is mostly useful for commands that update the database:\n           any result set returned by the query is discarded.\"\"\"\n        try:\n            self._log(query)\n            cursor.executemany(query, parameters)\n        except OperationalError as e:  # pragma: no cover\n            logging.error('Error connecting to PostgreSQL on %s, e', self.host, e)\n            self.close()\n            raise", "code_tokens": "def _executemany ( self , cursor , query , parameters ) : try : self . _log ( query ) cursor . executemany ( query , parameters ) except OperationalError as e : # pragma: no cover logging . error ( 'Error connecting to PostgreSQL on %s, e' , self . host , e ) self . close ( ) raise", "docstring_tokens": "The function is mostly useful for commands that update the database : any result set returned by the query is discarded .", "label": 0}, {"idx": "cosqa-train-10138", "doc": "python3 object of type 'bytes' is not json serializable base64", "code": "def _bytes_to_json(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\"\"\"\n    if isinstance(value, bytes):\n        value = base64.standard_b64encode(value).decode(\"ascii\")\n    return value", "code_tokens": "def _bytes_to_json ( value ) : if isinstance ( value , bytes ) : value = base64 . standard_b64encode ( value ) . decode ( \"ascii\" ) return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 1}, {"idx": "cosqa-train-10139", "doc": "nonblocking serial read in python", "code": "async def readline(self):\n        \"\"\"\n        This is an asyncio adapted version of pyserial read.\n        It provides a non-blocking read and returns a line of data read.\n\n        :return: A line of data\n        \"\"\"\n        future = asyncio.Future()\n        data_available = False\n        while True:\n            if not data_available:\n                if not self.my_serial.inWaiting():\n                    await asyncio.sleep(self.sleep_tune)\n                else:\n                    data_available = True\n                    data = self.my_serial.readline()\n                    future.set_result(data)\n            else:\n                if not future.done():\n                    await asyncio.sleep(self.sleep_tune)\n                else:\n                    return future.result()", "code_tokens": "async def readline ( self ) : future = asyncio . Future ( ) data_available = False while True : if not data_available : if not self . my_serial . inWaiting ( ) : await asyncio . sleep ( self . sleep_tune ) else : data_available = True data = self . my_serial . readline ( ) future . set_result ( data ) else : if not future . done ( ) : await asyncio . sleep ( self . sleep_tune ) else : return future . result ( )", "docstring_tokens": "This is an asyncio adapted version of pyserial read . It provides a non - blocking read and returns a line of data read .", "label": 1}, {"idx": "cosqa-train-10140", "doc": "python3 parse a substring to datetime in a string", "code": "def parse_date(s):\n    \"\"\"Fast %Y-%m-%d parsing.\"\"\"\n    try:\n        return datetime.date(int(s[:4]), int(s[5:7]), int(s[8:10]))\n    except ValueError:  # other accepted format used in one-day data set\n        return datetime.datetime.strptime(s, '%d %B %Y').date()", "code_tokens": "def parse_date ( s ) : try : return datetime . date ( int ( s [ : 4 ] ) , int ( s [ 5 : 7 ] ) , int ( s [ 8 : 10 ] ) ) except ValueError : # other accepted format used in one-day data set return datetime . datetime . strptime ( s , '%d %B %Y' ) . date ( )", "docstring_tokens": "Fast %Y - %m - %d parsing .", "label": 1}, {"idx": "cosqa-train-10141", "doc": "normal distribution python pdf", "code": "def EvalGaussianPdf(x, mu, sigma):\n    \"\"\"Computes the unnormalized PDF of the normal distribution.\n\n    x: value\n    mu: mean\n    sigma: standard deviation\n    \n    returns: float probability density\n    \"\"\"\n    return scipy.stats.norm.pdf(x, mu, sigma)", "code_tokens": "def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )", "docstring_tokens": "Computes the unnormalized PDF of the normal distribution .", "label": 1}, {"idx": "cosqa-train-10142", "doc": "python3 read buffer from binary file", "code": "def read_string(buff, byteorder='big'):\n    \"\"\"Read a string from a file-like object.\"\"\"\n    length = read_numeric(USHORT, buff, byteorder)\n    return buff.read(length).decode('utf-8')", "code_tokens": "def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )", "docstring_tokens": "Read a string from a file - like object .", "label": 0}, {"idx": "cosqa-train-10143", "doc": "normalize 1d array python", "code": "def _normalize_abmn(abmn):\n    \"\"\"return a normalized version of abmn\n    \"\"\"\n    abmn_2d = np.atleast_2d(abmn)\n    abmn_normalized = np.hstack((\n        np.sort(abmn_2d[:, 0:2], axis=1),\n        np.sort(abmn_2d[:, 2:4], axis=1),\n    ))\n    return abmn_normalized", "code_tokens": "def _normalize_abmn ( abmn ) : abmn_2d = np . atleast_2d ( abmn ) abmn_normalized = np . hstack ( ( np . sort ( abmn_2d [ : , 0 : 2 ] , axis = 1 ) , np . sort ( abmn_2d [ : , 2 : 4 ] , axis = 1 ) , ) ) return abmn_normalized", "docstring_tokens": "return a normalized version of abmn", "label": 0}, {"idx": "cosqa-train-10144", "doc": "python3 redirect stdout to memory", "code": "def disable_stdout_buffering():\n    \"\"\"This turns off stdout buffering so that outputs are immediately\n    materialized and log messages show up before the program exits\"\"\"\n    stdout_orig = sys.stdout\n    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)\n    # NOTE(brandyn): This removes the original stdout\n    return stdout_orig", "code_tokens": "def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig", "docstring_tokens": "This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits", "label": 1}, {"idx": "cosqa-train-10145", "doc": "normalize a row python numpy array", "code": "def denorm(self,arr):\n        \"\"\"Reverse the normalization done to a batch of images.\n\n        Arguments:\n            arr: of shape/size (N,3,sz,sz)\n        \"\"\"\n        if type(arr) is not np.ndarray: arr = to_np(arr)\n        if len(arr.shape)==3: arr = arr[None]\n        return self.transform.denorm(np.rollaxis(arr,1,4))", "code_tokens": "def denorm ( self , arr ) : if type ( arr ) is not np . ndarray : arr = to_np ( arr ) if len ( arr . shape ) == 3 : arr = arr [ None ] return self . transform . denorm ( np . rollaxis ( arr , 1 , 4 ) )", "docstring_tokens": "Reverse the normalization done to a batch of images .", "label": 0}, {"idx": "cosqa-train-10146", "doc": "python3 socket how to test if port in use before binding to it", "code": "def pick_unused_port(self):\n    \"\"\" Pick an unused port. There is a slight chance that this wont work. \"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.bind(('127.0.0.1', 0))\n    _, port = s.getsockname()\n    s.close()\n    return port", "code_tokens": "def pick_unused_port ( self ) : s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) s . bind ( ( '127.0.0.1' , 0 ) ) _ , port = s . getsockname ( ) s . close ( ) return port", "docstring_tokens": "Pick an unused port . There is a slight chance that this wont work .", "label": 0}, {"idx": "cosqa-train-10147", "doc": "not a gzipped file python", "code": "def is_gzipped_fastq(file_name):\n    \"\"\"\n    Determine whether indicated file appears to be a gzipped FASTQ.\n\n    :param str file_name: Name/path of file to check as gzipped FASTQ.\n    :return bool: Whether indicated file appears to be in gzipped FASTQ format.\n    \"\"\"\n    _, ext = os.path.splitext(file_name)\n    return file_name.endswith(\".fastq.gz\") or file_name.endswith(\".fq.gz\")", "code_tokens": "def is_gzipped_fastq ( file_name ) : _ , ext = os . path . splitext ( file_name ) return file_name . endswith ( \".fastq.gz\" ) or file_name . endswith ( \".fq.gz\" )", "docstring_tokens": "Determine whether indicated file appears to be a gzipped FASTQ .", "label": 0}, {"idx": "cosqa-train-10148", "doc": "python3 string default bytes", "code": "def to_bytes(value):\n    \"\"\" str to bytes (py3k) \"\"\"\n    vtype = type(value)\n\n    if vtype == bytes or vtype == type(None):\n        return value\n\n    try:\n        return vtype.encode(value)\n    except UnicodeEncodeError:\n        pass\n    return value", "code_tokens": "def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value", "docstring_tokens": "str to bytes ( py3k )", "label": 1}, {"idx": "cosqa-train-10149", "doc": "not allow duplicates in python list", "code": "def dedup_list(l):\n    \"\"\"Given a list (l) will removing duplicates from the list,\n       preserving the original order of the list. Assumes that\n       the list entrie are hashable.\"\"\"\n    dedup = set()\n    return [ x for x in l if not (x in dedup or dedup.add(x))]", "code_tokens": "def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]", "docstring_tokens": "Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable .", "label": 1}, {"idx": "cosqa-train-10150", "doc": "python3 utf8 not as default", "code": "def safe_unicode(string):\n    \"\"\"If Python 2, replace non-ascii characters and return encoded string.\"\"\"\n    if not PY3:\n        uni = string.replace(u'\\u2019', \"'\")\n        return uni.encode('utf-8')\n        \n    return string", "code_tokens": "def safe_unicode ( string ) : if not PY3 : uni = string . replace ( u'\\u2019' , \"'\" ) return uni . encode ( 'utf-8' ) return string", "docstring_tokens": "If Python 2 replace non - ascii characters and return encoded string .", "label": 0}, {"idx": "cosqa-train-10151", "doc": "not case sensitive string compare, python", "code": "def is_equal_strings_ignore_case(first, second):\n    \"\"\"The function compares strings ignoring case\"\"\"\n    if first and second:\n        return first.upper() == second.upper()\n    else:\n        return not (first or second)", "code_tokens": "def is_equal_strings_ignore_case ( first , second ) : if first and second : return first . upper ( ) == second . upper ( ) else : return not ( first or second )", "docstring_tokens": "The function compares strings ignoring case", "label": 1}, {"idx": "cosqa-train-10152", "doc": "pythonconvert any type to string", "code": "def check_str(obj):\n        \"\"\" Returns a string for various input types \"\"\"\n        if isinstance(obj, str):\n            return obj\n        if isinstance(obj, float):\n            return str(int(obj))\n        else:\n            return str(obj)", "code_tokens": "def check_str ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , float ) : return str ( int ( obj ) ) else : return str ( obj )", "docstring_tokens": "Returns a string for various input types", "label": 1}, {"idx": "cosqa-train-10153", "doc": "not generate random file name in python", "code": "def get_incomplete_path(filename):\n  \"\"\"Returns a temporary filename based on filename.\"\"\"\n  random_suffix = \"\".join(\n      random.choice(string.ascii_uppercase + string.digits) for _ in range(6))\n  return filename + \".incomplete\" + random_suffix", "code_tokens": "def get_incomplete_path ( filename ) : random_suffix = \"\" . join ( random . choice ( string . ascii_uppercase + string . digits ) for _ in range ( 6 ) ) return filename + \".incomplete\" + random_suffix", "docstring_tokens": "Returns a temporary filename based on filename .", "label": 0}, {"idx": "cosqa-train-10154", "doc": "pythond datetime from isoformat to datetime object", "code": "def iso_to_datetime(date):\n    \"\"\" Convert ISO 8601 time format to datetime format\n\n    This function converts a date in ISO format, e.g. ``2017-09-14`` to a `datetime` instance, e.g.\n    ``datetime.datetime(2017,9,14,0,0)``\n\n    :param date: date in ISO 8601 format\n    :type date: str\n    :return: datetime instance\n    :rtype: datetime\n    \"\"\"\n    chunks = list(map(int, date.split('T')[0].split('-')))\n    return datetime.datetime(chunks[0], chunks[1], chunks[2])", "code_tokens": "def iso_to_datetime ( date ) : chunks = list ( map ( int , date . split ( 'T' ) [ 0 ] . split ( '-' ) ) ) return datetime . datetime ( chunks [ 0 ] , chunks [ 1 ] , chunks [ 2 ] )", "docstring_tokens": "Convert ISO 8601 time format to datetime format", "label": 0}, {"idx": "cosqa-train-10155", "doc": "np array of list of lists python", "code": "def _to_array(value):\n    \"\"\"As a convenience, turn Python lists and tuples into NumPy arrays.\"\"\"\n    if isinstance(value, (tuple, list)):\n        return array(value)\n    elif isinstance(value, (float, int)):\n        return np.float64(value)\n    else:\n        return value", "code_tokens": "def _to_array ( value ) : if isinstance ( value , ( tuple , list ) ) : return array ( value ) elif isinstance ( value , ( float , int ) ) : return np . float64 ( value ) else : return value", "docstring_tokens": "As a convenience turn Python lists and tuples into NumPy arrays .", "label": 1}, {"idx": "cosqa-train-10156", "doc": "pythong concat two list of lists remove duplicats", "code": "def unique_deps(deps):\n    \"\"\"Remove duplicities from deps list of the lists\"\"\"\n    deps.sort()\n    return list(k for k, _ in itertools.groupby(deps))", "code_tokens": "def unique_deps ( deps ) : deps . sort ( ) return list ( k for k , _ in itertools . groupby ( deps ) )", "docstring_tokens": "Remove duplicities from deps list of the lists", "label": 1}, {"idx": "cosqa-train-10157", "doc": "numpy float64 compare with python", "code": "def is_float_array(val):\n    \"\"\"\n    Checks whether a variable is a numpy float array.\n\n    Parameters\n    ----------\n    val\n        The variable to check.\n\n    Returns\n    -------\n    bool\n        True if the variable is a numpy float array. Otherwise False.\n\n    \"\"\"\n    return is_np_array(val) and issubclass(val.dtype.type, np.floating)", "code_tokens": "def is_float_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . floating )", "docstring_tokens": "Checks whether a variable is a numpy float array .", "label": 1}, {"idx": "cosqa-train-10158", "doc": "query all global constants in a python file", "code": "def _get_all_constants():\n    \"\"\"\n    Get list of all uppercase, non-private globals (doesn't start with ``_``).\n\n    Returns:\n        list: Uppercase names defined in `globals()` (variables from this \\\n              module).\n    \"\"\"\n    return [\n        key for key in globals().keys()\n        if all([\n            not key.startswith(\"_\"),          # publicly accesible\n            key.upper() == key,               # uppercase\n            type(globals()[key]) in _ALLOWED  # and with type from _ALLOWED\n        ])\n    ]", "code_tokens": "def _get_all_constants ( ) : return [ key for key in globals ( ) . keys ( ) if all ( [ not key . startswith ( \"_\" ) , # publicly accesible key . upper ( ) == key , # uppercase type ( globals ( ) [ key ] ) in _ALLOWED # and with type from _ALLOWED ] ) ]", "docstring_tokens": "Get list of all uppercase non - private globals ( doesn t start with _ ) .", "label": 1}, {"idx": "cosqa-train-10159", "doc": "numpy max along axis in python", "code": "def Max(a, axis, keep_dims):\n    \"\"\"\n    Max reduction op.\n    \"\"\"\n    return np.amax(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis),\n                   keepdims=keep_dims),", "code_tokens": "def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "docstring_tokens": "Max reduction op .", "label": 1}, {"idx": "cosqa-train-10160", "doc": "query on multiple things python mongo", "code": "def find_one(cls, *args, **kw):\n\t\t\"\"\"Get a single document from the collection this class is bound to.\n\t\t\n\t\tAdditional arguments are processed according to `_prepare_find` prior to passing to PyMongo, where positional\n\t\tparameters are interpreted as query fragments, parametric keyword arguments combined, and other keyword\n\t\targuments passed along with minor transformation.\n\t\t\n\t\tAutomatically calls `to_mongo` with the retrieved data.\n\t\t\n\t\thttps://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.find_one\n\t\t\"\"\"\n\t\t\n\t\tif len(args) == 1 and not isinstance(args[0], Filter):\n\t\t\targs = (getattr(cls, cls.__pk__) == args[0], )\n\t\t\n\t\tDoc, collection, query, options = cls._prepare_find(*args, **kw)\n\t\tresult = Doc.from_mongo(collection.find_one(query, **options))\n\t\t\n\t\treturn result", "code_tokens": "def find_one ( cls , * args , * * kw ) : if len ( args ) == 1 and not isinstance ( args [ 0 ] , Filter ) : args = ( getattr ( cls , cls . __pk__ ) == args [ 0 ] , ) Doc , collection , query , options = cls . _prepare_find ( * args , * * kw ) result = Doc . from_mongo ( collection . find_one ( query , * * options ) ) return result", "docstring_tokens": "Get a single document from the collection this class is bound to . Additional arguments are processed according to _prepare_find prior to passing to PyMongo where positional parameters are interpreted as query fragments parametric keyword arguments combined and other keyword arguments passed along with minor transformation . Automatically calls to_mongo with the retrieved data . https : // api . mongodb . com / python / current / api / pymongo / collection . html#pymongo . collection . Collection . find_one", "label": 1}, {"idx": "cosqa-train-10161", "doc": "object is not subscriptable python parsing config file", "code": "def _config_parse(self):\n        \"\"\"Replacer oslo_config.cfg.ConfigParser.parse for in-memory cfg.\"\"\"\n        res = super(cfg.ConfigParser, self).parse(Backend._config_string_io)\n        return res", "code_tokens": "def _config_parse ( self ) : res = super ( cfg . ConfigParser , self ) . parse ( Backend . _config_string_io ) return res", "docstring_tokens": "Replacer oslo_config . cfg . ConfigParser . parse for in - memory cfg .", "label": 1}, {"idx": "cosqa-train-10162", "doc": "random noise bandwidth python", "code": "def normal_noise(points):\n    \"\"\"Init a noise variable.\"\"\"\n    return np.random.rand(1) * np.random.randn(points, 1) \\\n        + random.sample([2, -2], 1)", "code_tokens": "def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "docstring_tokens": "Init a noise variable .", "label": 1}, {"idx": "cosqa-train-10163", "doc": "object with commas turned into list python", "code": "def seq_to_str(obj, sep=\",\"):\n    \"\"\"\n    Given a sequence convert it to a comma separated string.\n    If, however, the argument is a single object, return its string\n    representation.\n    \"\"\"\n    if isinstance(obj, string_classes):\n        return obj\n    elif isinstance(obj, (list, tuple)):\n        return sep.join([str(x) for x in obj])\n    else:\n        return str(obj)", "code_tokens": "def seq_to_str ( obj , sep = \",\" ) : if isinstance ( obj , string_classes ) : return obj elif isinstance ( obj , ( list , tuple ) ) : return sep . join ( [ str ( x ) for x in obj ] ) else : return str ( obj )", "docstring_tokens": "Given a sequence convert it to a comma separated string . If however the argument is a single object return its string representation .", "label": 1}, {"idx": "cosqa-train-10164", "doc": "random string different length python", "code": "def gen_random_string(str_len):\n    \"\"\" generate random string with specified length\n    \"\"\"\n    return ''.join(\n        random.choice(string.ascii_letters + string.digits) for _ in range(str_len))", "code_tokens": "def gen_random_string ( str_len ) : return '' . join ( random . choice ( string . ascii_letters + string . digits ) for _ in range ( str_len ) )", "docstring_tokens": "generate random string with specified length", "label": 1}, {"idx": "cosqa-train-10165", "doc": "one dimensional convolution python", "code": "def conv1x1(in_planes, out_planes, stride=1):\n    \"\"\"1x1 convolution\"\"\"\n    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)", "code_tokens": "def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )", "docstring_tokens": "1x1 convolution", "label": 0}, {"idx": "cosqa-train-10166", "doc": "random string of 5 characters inn python", "code": "def gen_random_string(str_len):\n    \"\"\" generate random string with specified length\n    \"\"\"\n    return ''.join(\n        random.choice(string.ascii_letters + string.digits) for _ in range(str_len))", "code_tokens": "def gen_random_string ( str_len ) : return '' . join ( random . choice ( string . ascii_letters + string . digits ) for _ in range ( str_len ) )", "docstring_tokens": "generate random string with specified length", "label": 1}, {"idx": "cosqa-train-10167", "doc": "one hot encoding python encoder if label is a list", "code": "def one_hot_encoding(input_tensor, num_labels):\n    \"\"\" One-hot encode labels from input \"\"\"\n    xview = input_tensor.view(-1, 1).to(torch.long)\n\n    onehot = torch.zeros(xview.size(0), num_labels, device=input_tensor.device, dtype=torch.float)\n    onehot.scatter_(1, xview, 1)\n    return onehot.view(list(input_tensor.shape) + [-1])", "code_tokens": "def one_hot_encoding ( input_tensor , num_labels ) : xview = input_tensor . view ( - 1 , 1 ) . to ( torch . long ) onehot = torch . zeros ( xview . size ( 0 ) , num_labels , device = input_tensor . device , dtype = torch . float ) onehot . scatter_ ( 1 , xview , 1 ) return onehot . view ( list ( input_tensor . shape ) + [ - 1 ] )", "docstring_tokens": "One - hot encode labels from input", "label": 1}, {"idx": "cosqa-train-10168", "doc": "random uniform sample between a range in python", "code": "def runiform(lower, upper, size=None):\n    \"\"\"\n    Random uniform variates.\n    \"\"\"\n    return np.random.uniform(lower, upper, size)", "code_tokens": "def runiform ( lower , upper , size = None ) : return np . random . uniform ( lower , upper , size )", "docstring_tokens": "Random uniform variates .", "label": 0}, {"idx": "cosqa-train-10169", "doc": "online python to c++ code converter", "code": "def rpc_fix_code(self, source, directory):\n        \"\"\"Formats Python code to conform to the PEP 8 style guide.\n\n        \"\"\"\n        source = get_source(source)\n        return fix_code(source, directory)", "code_tokens": "def rpc_fix_code ( self , source , directory ) : source = get_source ( source ) return fix_code ( source , directory )", "docstring_tokens": "Formats Python code to conform to the PEP 8 style guide .", "label": 1}, {"idx": "cosqa-train-10170", "doc": "range with two auguments python", "code": "def overlap(intv1, intv2):\n    \"\"\"Overlaping of two intervals\"\"\"\n    return max(0, min(intv1[1], intv2[1]) - max(intv1[0], intv2[0]))", "code_tokens": "def overlap ( intv1 , intv2 ) : return max ( 0 , min ( intv1 [ 1 ] , intv2 [ 1 ] ) - max ( intv1 [ 0 ] , intv2 [ 0 ] ) )", "docstring_tokens": "Overlaping of two intervals", "label": 0}, {"idx": "cosqa-train-10171", "doc": "only current date python datetime", "code": "def created_today(self):\n        \"\"\"Return True if created today.\"\"\"\n        if self.datetime.date() == datetime.today().date():\n            return True\n        return False", "code_tokens": "def created_today ( self ) : if self . datetime . date ( ) == datetime . today ( ) . date ( ) : return True return False", "docstring_tokens": "Return True if created today .", "label": 1}, {"idx": "cosqa-train-10172", "doc": "rather than returning the singleton object, the enum is returning the vlaues in python", "code": "def items(cls):\n        \"\"\"\n        All values for this enum\n        :return: list of tuples\n\n        \"\"\"\n        return [\n            cls.PRECIPITATION,\n            cls.WIND,\n            cls.TEMPERATURE,\n            cls.PRESSURE\n        ]", "code_tokens": "def items ( cls ) : return [ cls . PRECIPITATION , cls . WIND , cls . TEMPERATURE , cls . PRESSURE ]", "docstring_tokens": "All values for this enum : return : list of tuples", "label": 0}, {"idx": "cosqa-train-10173", "doc": "only want root info displayed by logger python", "code": "def log(logger, level, message):\n    \"\"\"Logs message to stderr if logging isn't initialized.\"\"\"\n\n    if logger.parent.name != 'root':\n        logger.log(level, message)\n    else:\n        print(message, file=sys.stderr)", "code_tokens": "def log ( logger , level , message ) : if logger . parent . name != 'root' : logger . log ( level , message ) else : print ( message , file = sys . stderr )", "docstring_tokens": "Logs message to stderr if logging isn t initialized .", "label": 0}, {"idx": "cosqa-train-10174", "doc": "read a list of tuples from a file python", "code": "def readTuple(self, line, n=3):\n        \"\"\" Reads a tuple of numbers. e.g. vertices, normals or teture coords.\n        \"\"\"\n        numbers = [num for num in line.split(' ') if num]\n        return [float(num) for num in numbers[1:n + 1]]", "code_tokens": "def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]", "docstring_tokens": "Reads a tuple of numbers . e . g . vertices normals or teture coords .", "label": 1}, {"idx": "cosqa-train-10175", "doc": "open a file in encoding in python", "code": "def read_string_from_file(path, encoding=\"utf8\"):\n  \"\"\"\n  Read entire contents of file into a string.\n  \"\"\"\n  with codecs.open(path, \"rb\", encoding=encoding) as f:\n    value = f.read()\n  return value", "code_tokens": "def read_string_from_file ( path , encoding = \"utf8\" ) : with codecs . open ( path , \"rb\" , encoding = encoding ) as f : value = f . read ( ) return value", "docstring_tokens": "Read entire contents of file into a string .", "label": 1}, {"idx": "cosqa-train-10176", "doc": "read huge text file in chunks python", "code": "def filechunk(f, chunksize):\n    \"\"\"Iterator that allow for piecemeal processing of a file.\"\"\"\n    while True:\n        chunk = tuple(itertools.islice(f, chunksize))\n        if not chunk:\n            return\n        yield np.loadtxt(iter(chunk), dtype=np.float64)", "code_tokens": "def filechunk ( f , chunksize ) : while True : chunk = tuple ( itertools . islice ( f , chunksize ) ) if not chunk : return yield np . loadtxt ( iter ( chunk ) , dtype = np . float64 )", "docstring_tokens": "Iterator that allow for piecemeal processing of a file .", "label": 1}, {"idx": "cosqa-train-10177", "doc": "open file in python encoding", "code": "def read_string_from_file(path, encoding=\"utf8\"):\n  \"\"\"\n  Read entire contents of file into a string.\n  \"\"\"\n  with codecs.open(path, \"rb\", encoding=encoding) as f:\n    value = f.read()\n  return value", "code_tokens": "def read_string_from_file ( path , encoding = \"utf8\" ) : with codecs . open ( path , \"rb\" , encoding = encoding ) as f : value = f . read ( ) return value", "docstring_tokens": "Read entire contents of file into a string .", "label": 1}, {"idx": "cosqa-train-10178", "doc": "read json different encoding python", "code": "def load_jsonf(fpath, encoding):\n    \"\"\"\n    :param unicode fpath:\n    :param unicode encoding:\n    :rtype: dict | list\n    \"\"\"\n    with codecs.open(fpath, encoding=encoding) as f:\n        return json.load(f)", "code_tokens": "def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )", "docstring_tokens": ": param unicode fpath : : param unicode encoding : : rtype : dict | list", "label": 0}, {"idx": "cosqa-train-10179", "doc": "open file in python using encoding", "code": "def read_string_from_file(path, encoding=\"utf8\"):\n  \"\"\"\n  Read entire contents of file into a string.\n  \"\"\"\n  with codecs.open(path, \"rb\", encoding=encoding) as f:\n    value = f.read()\n  return value", "code_tokens": "def read_string_from_file ( path , encoding = \"utf8\" ) : with codecs . open ( path , \"rb\" , encoding = encoding ) as f : value = f . read ( ) return value", "docstring_tokens": "Read entire contents of file into a string .", "label": 1}, {"idx": "cosqa-train-10180", "doc": "read json from url python", "code": "def get_jsonparsed_data(url):\n    \"\"\"Receive the content of ``url``, parse it as JSON and return the\n       object.\n    \"\"\"\n    response = urlopen(url)\n    data = response.read().decode('utf-8')\n    return json.loads(data)", "code_tokens": "def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )", "docstring_tokens": "Receive the content of url parse it as JSON and return the object .", "label": 0}, {"idx": "cosqa-train-10181", "doc": "open file on different encodings in python", "code": "def open_with_encoding(filename, encoding, mode='r'):\n    \"\"\"Return opened file with a specific encoding.\"\"\"\n    return io.open(filename, mode=mode, encoding=encoding,\n                   newline='')", "code_tokens": "def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )", "docstring_tokens": "Return opened file with a specific encoding .", "label": 1}, {"idx": "cosqa-train-10182", "doc": "read text and count word occurrences save to dictionary python", "code": "def count_words(file):\n  \"\"\" Counts the word frequences in a list of sentences.\n\n  Note:\n    This is a helper function for parallel execution of `Vocabulary.from_text`\n    method.\n  \"\"\"\n  c = Counter()\n  with open(file, 'r') as f:\n    for l in f:\n      words = l.strip().split()\n      c.update(words)\n  return c", "code_tokens": "def count_words ( file ) : c = Counter ( ) with open ( file , 'r' ) as f : for l in f : words = l . strip ( ) . split ( ) c . update ( words ) return c", "docstring_tokens": "Counts the word frequences in a list of sentences .", "label": 0}, {"idx": "cosqa-train-10183", "doc": "open up pages document in python", "code": "def Output(self):\n    \"\"\"Output all sections of the page.\"\"\"\n    self.Open()\n    self.Header()\n    self.Body()\n    self.Footer()", "code_tokens": "def Output ( self ) : self . Open ( ) self . Header ( ) self . Body ( ) self . Footer ( )", "docstring_tokens": "Output all sections of the page .", "label": 1}, {"idx": "cosqa-train-10184", "doc": "read utf8 file in python", "code": "def read_utf8(fh, byteorder, dtype, count, offsetsize):\n    \"\"\"Read tag data from file and return as unicode string.\"\"\"\n    return fh.read(count).decode('utf-8')", "code_tokens": "def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )", "docstring_tokens": "Read tag data from file and return as unicode string .", "label": 1}, {"idx": "cosqa-train-10185", "doc": "open url in chrome in python webbrowser", "code": "def url(self):\n        \"\"\" The url of this window \"\"\"\n        with switch_window(self._browser, self.name):\n            return self._browser.url", "code_tokens": "def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "docstring_tokens": "The url of this window", "label": 0}, {"idx": "cosqa-train-10186", "doc": "reading a file content in python", "code": "def read(fname):\n    \"\"\"Quick way to read a file content.\"\"\"\n    content = None\n    with open(os.path.join(here, fname)) as f:\n        content = f.read()\n    return content", "code_tokens": "def read ( fname ) : content = None with open ( os . path . join ( here , fname ) ) as f : content = f . read ( ) return content", "docstring_tokens": "Quick way to read a file content .", "label": 1}, {"idx": "cosqa-train-10187", "doc": "open with encoding python", "code": "def load_jsonf(fpath, encoding):\n    \"\"\"\n    :param unicode fpath:\n    :param unicode encoding:\n    :rtype: dict | list\n    \"\"\"\n    with codecs.open(fpath, encoding=encoding) as f:\n        return json.load(f)", "code_tokens": "def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )", "docstring_tokens": ": param unicode fpath : : param unicode encoding : : rtype : dict | list", "label": 1}, {"idx": "cosqa-train-10188", "doc": "reading an h5 file with python h5py", "code": "def h5ToDict(h5, readH5pyDataset=True):\n    \"\"\" Read a hdf5 file into a dictionary \"\"\"\n    h = h5py.File(h5, \"r\")\n    ret = unwrapArray(h, recursive=True, readH5pyDataset=readH5pyDataset)\n    if readH5pyDataset: h.close()\n    return ret", "code_tokens": "def h5ToDict ( h5 , readH5pyDataset = True ) : h = h5py . File ( h5 , \"r\" ) ret = unwrapArray ( h , recursive = True , readH5pyDataset = readH5pyDataset ) if readH5pyDataset : h . close ( ) return ret", "docstring_tokens": "Read a hdf5 file into a dictionary", "label": 0}, {"idx": "cosqa-train-10189", "doc": "opencv python normalize intensity of 3d image", "code": "def min_max_normalize(img):\n    \"\"\"Centre and normalize a given array.\n\n    Parameters:\n    ----------\n    img: np.ndarray\n\n    \"\"\"\n\n    min_img = img.min()\n    max_img = img.max()\n\n    return (img - min_img) / (max_img - min_img)", "code_tokens": "def min_max_normalize ( img ) : min_img = img . min ( ) max_img = img . max ( ) return ( img - min_img ) / ( max_img - min_img )", "docstring_tokens": "Centre and normalize a given array .", "label": 0}, {"idx": "cosqa-train-10190", "doc": "reading data out of hdf5 matlab files python", "code": "def _load_data(filepath):\n  \"\"\"Loads the images and latent values into Numpy arrays.\"\"\"\n  with h5py.File(filepath, \"r\") as h5dataset:\n    image_array = np.array(h5dataset[\"images\"])\n    # The 'label' data set in the hdf5 file actually contains the float values\n    # and not the class labels.\n    values_array = np.array(h5dataset[\"labels\"])\n  return image_array, values_array", "code_tokens": "def _load_data ( filepath ) : with h5py . File ( filepath , \"r\" ) as h5dataset : image_array = np . array ( h5dataset [ \"images\" ] ) # The 'label' data set in the hdf5 file actually contains the float values # and not the class labels. values_array = np . array ( h5dataset [ \"labels\" ] ) return image_array , values_array", "docstring_tokens": "Loads the images and latent values into Numpy arrays .", "label": 1}, {"idx": "cosqa-train-10191", "doc": "opencv python rotate image centet", "code": "def rotate_img(im, deg, mode=cv2.BORDER_CONSTANT, interpolation=cv2.INTER_AREA):\n    \"\"\" Rotates an image by deg degrees\n\n    Arguments:\n        deg (float): degree to rotate.\n    \"\"\"\n    r,c,*_ = im.shape\n    M = cv2.getRotationMatrix2D((c//2,r//2),deg,1)\n    return cv2.warpAffine(im,M,(c,r), borderMode=mode, flags=cv2.WARP_FILL_OUTLIERS+interpolation)", "code_tokens": "def rotate_img ( im , deg , mode = cv2 . BORDER_CONSTANT , interpolation = cv2 . INTER_AREA ) : r , c ,  * _ = im . shape M = cv2 . getRotationMatrix2D ( ( c // 2 , r // 2 ) , deg , 1 ) return cv2 . warpAffine ( im , M , ( c , r ) , borderMode = mode , flags = cv2 . WARP_FILL_OUTLIERS + interpolation )", "docstring_tokens": "Rotates an image by deg degrees", "label": 1}, {"idx": "cosqa-train-10192", "doc": "receive aspect ration of images python", "code": "def image_set_aspect(aspect=1.0, axes=\"gca\"):\n    \"\"\"\n    sets the aspect ratio of the current zoom level of the imshow image\n    \"\"\"\n    if axes is \"gca\": axes = _pylab.gca()\n\n    e = axes.get_images()[0].get_extent()\n    axes.set_aspect(abs((e[1]-e[0])/(e[3]-e[2]))/aspect)", "code_tokens": "def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "docstring_tokens": "sets the aspect ratio of the current zoom level of the imshow image", "label": 1}, {"idx": "cosqa-train-10193", "doc": "opening a geojson file in python", "code": "def _loadfilepath(self, filepath, **kwargs):\n        \"\"\"This loads a geojson file into a geojson python\n        dictionary using the json module.\n        \n        Note: to load with a different text encoding use the encoding argument.\n        \"\"\"\n        with open(filepath, \"r\") as f:\n            data = json.load(f, **kwargs)\n        return data", "code_tokens": "def _loadfilepath ( self , filepath , * * kwargs ) : with open ( filepath , \"r\" ) as f : data = json . load ( f , * * kwargs ) return data", "docstring_tokens": "This loads a geojson file into a geojson python dictionary using the json module . Note : to load with a different text encoding use the encoding argument .", "label": 0}, {"idx": "cosqa-train-10194", "doc": "receive request param in python django", "code": "def parse_querystring(self, req, name, field):\n        \"\"\"Pull a querystring value from the request.\"\"\"\n        return core.get_value(req.args, name, field)", "code_tokens": "def parse_querystring ( self , req , name , field ) : return core . get_value ( req . args , name , field )", "docstring_tokens": "Pull a querystring value from the request .", "label": 0}, {"idx": "cosqa-train-10195", "doc": "or two series of boolean python", "code": "def _or(ctx, *logical):\n    \"\"\"\n    Returns TRUE if any argument is TRUE\n    \"\"\"\n    for arg in logical:\n        if conversions.to_boolean(arg, ctx):\n            return True\n    return False", "code_tokens": "def _or ( ctx , * logical ) : for arg in logical : if conversions . to_boolean ( arg , ctx ) : return True return False", "docstring_tokens": "Returns TRUE if any argument is TRUE", "label": 1}, {"idx": "cosqa-train-10196", "doc": "record training time python", "code": "def on_train_end(self, logs):\n        \"\"\" Print training time at end of training \"\"\"\n        duration = timeit.default_timer() - self.train_start\n        print('done, took {:.3f} seconds'.format(duration))", "code_tokens": "def on_train_end ( self , logs ) : duration = timeit . default_timer ( ) - self . train_start print ( 'done, took {:.3f} seconds' . format ( duration ) )", "docstring_tokens": "Print training time at end of training", "label": 1}, {"idx": "cosqa-train-10197", "doc": "os python remove dir recursively", "code": "def rrmdir(directory):\n    \"\"\"\n    Recursivly delete a directory\n\n    :param directory: directory to remove\n    \"\"\"\n    for root, dirs, files in os.walk(directory, topdown=False):\n        for name in files:\n            os.remove(os.path.join(root, name))\n        for name in dirs:\n            os.rmdir(os.path.join(root, name))\n    os.rmdir(directory)", "code_tokens": "def rrmdir ( directory ) : for root , dirs , files in os . walk ( directory , topdown = False ) : for name in files : os . remove ( os . path . join ( root , name ) ) for name in dirs : os . rmdir ( os . path . join ( root , name ) ) os . rmdir ( directory )", "docstring_tokens": "Recursivly delete a directory", "label": 1}, {"idx": "cosqa-train-10198", "doc": "recursively unzip files even if duplicate filenames python", "code": "def extract_all(zipfile, dest_folder):\n    \"\"\"\n    reads the zip file, determines compression\n    and unzips recursively until source files \n    are extracted \n    \"\"\"\n    z = ZipFile(zipfile)\n    print(z)\n    z.extract(dest_folder)", "code_tokens": "def extract_all ( zipfile , dest_folder ) : z = ZipFile ( zipfile ) print ( z ) z . extract ( dest_folder )", "docstring_tokens": "reads the zip file determines compression and unzips recursively until source files are extracted", "label": 1}, {"idx": "cosqa-train-10199", "doc": "output ascii text in python", "code": "def imp_print(self, text, end):\n\t\t\"\"\"Directly send utf8 bytes to stdout\"\"\"\n\t\tsys.stdout.write((text + end).encode(\"utf-8\"))", "code_tokens": "def imp_print ( self , text , end ) : sys . stdout . write ( ( text + end ) . encode ( \"utf-8\" ) )", "docstring_tokens": "Directly send utf8 bytes to stdout", "label": 1}, {"idx": "cosqa-train-10200", "doc": "redefining paramets in a function python", "code": "def trigger(self, target: str, trigger: str, parameters: Dict[str, Any]={}):\n\t\t\"\"\"Calls the specified Trigger of another Area with the optionally given parameters.\n\n\t\tArgs:\n\t\t\ttarget: The name of the target Area.\n\t\t\ttrigger: The name of the Trigger.\n\t\t\tparameters: The parameters of the function call.\n\t\t\"\"\"\n\t\tpass", "code_tokens": "def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass", "docstring_tokens": "Calls the specified Trigger of another Area with the optionally given parameters .", "label": 0}, {"idx": "cosqa-train-10201", "doc": "parse a env file in python", "code": "def create_env(env_file):\n    \"\"\"Create environ dictionary from current os.environ and\n    variables got from given `env_file`\"\"\"\n\n    environ = {}\n    with open(env_file, 'r') as f:\n        for line in f.readlines():\n            line = line.rstrip(os.linesep)\n            if '=' not in line:\n                continue\n            if line.startswith('#'):\n                continue\n            key, value = line.split('=', 1)\n            environ[key] = parse_value(value)\n    return environ", "code_tokens": "def create_env ( env_file ) : environ = { } with open ( env_file , 'r' ) as f : for line in f . readlines ( ) : line = line . rstrip ( os . linesep ) if '=' not in line : continue if line . startswith ( '#' ) : continue key , value = line . split ( '=' , 1 ) environ [ key ] = parse_value ( value ) return environ", "docstring_tokens": "Create environ dictionary from current os . environ and variables got from given env_file", "label": 1}, {"idx": "cosqa-train-10202", "doc": "redirect stdout to both buffer a logger at the same time python2", "code": "def disable_stdout_buffering():\n    \"\"\"This turns off stdout buffering so that outputs are immediately\n    materialized and log messages show up before the program exits\"\"\"\n    stdout_orig = sys.stdout\n    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)\n    # NOTE(brandyn): This removes the original stdout\n    return stdout_orig", "code_tokens": "def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig", "docstring_tokens": "This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits", "label": 1}, {"idx": "cosqa-train-10203", "doc": "parse a lambda expression in python at runtime", "code": "def make_lambda(call):\n    \"\"\"Wrap an AST Call node to lambda expression node.\n    call: ast.Call node\n    \"\"\"\n    empty_args = ast.arguments(args=[], vararg=None, kwarg=None, defaults=[])\n    return ast.Lambda(args=empty_args, body=call)", "code_tokens": "def make_lambda ( call ) : empty_args = ast . arguments ( args = [ ] , vararg = None , kwarg = None , defaults = [ ] ) return ast . Lambda ( args = empty_args , body = call )", "docstring_tokens": "Wrap an AST Call node to lambda expression node . call : ast . Call node", "label": 1}, {"idx": "cosqa-train-10204", "doc": "remove a item in a series by its index python", "code": "def DeleteIndex(self, index):\n        \"\"\"\n        Remove a spent coin based on its index.\n\n        Args:\n            index (int):\n        \"\"\"\n        to_remove = None\n        for i in self.Items:\n            if i.index == index:\n                to_remove = i\n\n        if to_remove:\n            self.Items.remove(to_remove)", "code_tokens": "def DeleteIndex ( self , index ) : to_remove = None for i in self . Items : if i . index == index : to_remove = i if to_remove : self . Items . remove ( to_remove )", "docstring_tokens": "Remove a spent coin based on its index .", "label": 1}, {"idx": "cosqa-train-10205", "doc": "parse wrong date format python", "code": "def parse(self, s):\n        \"\"\"\n        Parses a date string formatted like ``YYYY-MM-DD``.\n        \"\"\"\n        return datetime.datetime.strptime(s, self.date_format).date()", "code_tokens": "def parse ( self , s ) : return datetime . datetime . strptime ( s , self . date_format ) . date ( )", "docstring_tokens": "Parses a date string formatted like YYYY - MM - DD .", "label": 1}, {"idx": "cosqa-train-10206", "doc": "remove a key from objecy python", "code": "def delete_entry(self, key):\n        \"\"\"Delete an object from the redis table\"\"\"\n        pipe = self.client.pipeline()\n        pipe.srem(self.keys_container, key)\n        pipe.delete(key)\n        pipe.execute()", "code_tokens": "def delete_entry ( self , key ) : pipe = self . client . pipeline ( ) pipe . srem ( self . keys_container , key ) pipe . delete ( key ) pipe . execute ( )", "docstring_tokens": "Delete an object from the redis table", "label": 0}, {"idx": "cosqa-train-10207", "doc": "remove all characters in string in python", "code": "def drop_bad_characters(text):\n    \"\"\"Takes a text and drops all non-printable and non-ascii characters and\n    also any whitespace characters that aren't space.\n\n    :arg str text: the text to fix\n\n    :returns: text with all bad characters dropped\n\n    \"\"\"\n    # Strip all non-ascii and non-printable characters\n    text = ''.join([c for c in text if c in ALLOWED_CHARS])\n    return text", "code_tokens": "def drop_bad_characters ( text ) : # Strip all non-ascii and non-printable characters text = '' . join ( [ c for c in text if c in ALLOWED_CHARS ] ) return text", "docstring_tokens": "Takes a text and drops all non - printable and non - ascii characters and also any whitespace characters that aren t space .", "label": 1}, {"idx": "cosqa-train-10208", "doc": "pass iterable to sum python", "code": "def _accumulate(sequence, func):\n    \"\"\"\n    Python2 accumulate implementation taken from\n    https://docs.python.org/3/library/itertools.html#itertools.accumulate\n    \"\"\"\n    iterator = iter(sequence)\n    total = next(iterator)\n    yield total\n    for element in iterator:\n        total = func(total, element)\n        yield total", "code_tokens": "def _accumulate ( sequence , func ) : iterator = iter ( sequence ) total = next ( iterator ) yield total for element in iterator : total = func ( total , element ) yield total", "docstring_tokens": "Python2 accumulate implementation taken from https : // docs . python . org / 3 / library / itertools . html#itertools . accumulate", "label": 1}, {"idx": "cosqa-train-10209", "doc": "passing encode in a function python 3", "code": "def StreamWrite(stream, *obj):\n    \"\"\"Writes Python object to Skype application stream.\"\"\"\n    stream.Write(base64.encodestring(pickle.dumps(obj)))", "code_tokens": "def StreamWrite ( stream , * obj ) : stream . Write ( base64 . encodestring ( pickle . dumps ( obj ) ) )", "docstring_tokens": "Writes Python object to Skype application stream .", "label": 0}, {"idx": "cosqa-train-10210", "doc": "remove characters from string except for python", "code": "def strip_accents(text):\n    \"\"\"\n    Strip agents from a string.\n    \"\"\"\n\n    normalized_str = unicodedata.normalize('NFD', text)\n\n    return ''.join([\n        c for c in normalized_str if unicodedata.category(c) != 'Mn'])", "code_tokens": "def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "docstring_tokens": "Strip agents from a string .", "label": 1}, {"idx": "cosqa-train-10211", "doc": "passing json as function params in python", "code": "def dict_jsonp(param):\n    \"\"\"Convert the parameter into a dictionary before calling jsonp, if it's not already one\"\"\"\n    if not isinstance(param, dict):\n        param = dict(param)\n    return jsonp(param)", "code_tokens": "def dict_jsonp ( param ) : if not isinstance ( param , dict ) : param = dict ( param ) return jsonp ( param )", "docstring_tokens": "Convert the parameter into a dictionary before calling jsonp if it s not already one", "label": 0}, {"idx": "cosqa-train-10212", "doc": "remove comma from object in python", "code": "def seq_to_str(obj, sep=\",\"):\n    \"\"\"\n    Given a sequence convert it to a comma separated string.\n    If, however, the argument is a single object, return its string\n    representation.\n    \"\"\"\n    if isinstance(obj, string_classes):\n        return obj\n    elif isinstance(obj, (list, tuple)):\n        return sep.join([str(x) for x in obj])\n    else:\n        return str(obj)", "code_tokens": "def seq_to_str ( obj , sep = \",\" ) : if isinstance ( obj , string_classes ) : return obj elif isinstance ( obj , ( list , tuple ) ) : return sep . join ( [ str ( x ) for x in obj ] ) else : return str ( obj )", "docstring_tokens": "Given a sequence convert it to a comma separated string . If however the argument is a single object return its string representation .", "label": 1}, {"idx": "cosqa-train-10213", "doc": "passing json object in python response", "code": "def json_response(data, status=200):\n    \"\"\"Return a JsonResponse. Make sure you have django installed first.\"\"\"\n    from django.http import JsonResponse\n    return JsonResponse(data=data, status=status, safe=isinstance(data, dict))", "code_tokens": "def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )", "docstring_tokens": "Return a JsonResponse . Make sure you have django installed first .", "label": 0}, {"idx": "cosqa-train-10214", "doc": "remove comma in a list in python", "code": "def __normalize_list(self, msg):\n        \"\"\"Split message to list by commas and trim whitespace.\"\"\"\n        if isinstance(msg, list):\n            msg = \"\".join(msg)\n        return list(map(lambda x: x.strip(), msg.split(\",\")))", "code_tokens": "def __normalize_list ( self , msg ) : if isinstance ( msg , list ) : msg = \"\" . join ( msg ) return list ( map ( lambda x : x . strip ( ) , msg . split ( \",\" ) ) )", "docstring_tokens": "Split message to list by commas and trim whitespace .", "label": 0}, {"idx": "cosqa-train-10215", "doc": "password validation python regular expression", "code": "def is_password_valid(password):\n    \"\"\"\n    Check if a password is valid\n    \"\"\"\n    pattern = re.compile(r\"^.{4,75}$\")\n    return bool(pattern.match(password))", "code_tokens": "def is_password_valid ( password ) : pattern = re . compile ( r\"^.{4,75}$\" ) return bool ( pattern . match ( password ) )", "docstring_tokens": "Check if a password is valid", "label": 1}, {"idx": "cosqa-train-10216", "doc": "remove comment from block of codepython", "code": "def filter_lines_from_comments(lines):\n    \"\"\" Filter the lines from comments and non code lines. \"\"\"\n    for line_nb, raw_line in enumerate(lines):\n        clean_line = remove_comments_from_line(raw_line)\n        if clean_line == '':\n            continue\n        yield line_nb, clean_line, raw_line", "code_tokens": "def filter_lines_from_comments ( lines ) : for line_nb , raw_line in enumerate ( lines ) : clean_line = remove_comments_from_line ( raw_line ) if clean_line == '' : continue yield line_nb , clean_line , raw_line", "docstring_tokens": "Filter the lines from comments and non code lines .", "label": 0}, {"idx": "cosqa-train-10217", "doc": "past python git clone", "code": "def mkhead(repo, path):\n    \"\"\":return: New branch/head instance\"\"\"\n    return git.Head(repo, git.Head.to_full_path(path))", "code_tokens": "def mkhead ( repo , path ) : return git . Head ( repo , git . Head . to_full_path ( path ) )", "docstring_tokens": ": return : New branch / head instance", "label": 1}, {"idx": "cosqa-train-10218", "doc": "remove duplicate list in python", "code": "def unique(list):\n    \"\"\" Returns a copy of the list without duplicates.\n    \"\"\"\n    unique = []; [unique.append(x) for x in list if x not in unique]\n    return unique", "code_tokens": "def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique", "docstring_tokens": "Returns a copy of the list without duplicates .", "label": 1}, {"idx": "cosqa-train-10219", "doc": "place dot in string in python", "code": "def _dotify(cls, data):\n    \"\"\"Add dots.\"\"\"\n    return ''.join(char if char in cls.PRINTABLE_DATA else '.' for char in data)", "code_tokens": "def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )", "docstring_tokens": "Add dots .", "label": 1}, {"idx": "cosqa-train-10220", "doc": "remove element from series in python", "code": "def remove_series(self, series):\n        \"\"\"Removes a :py:class:`.Series` from the chart.\n\n        :param Series series: The :py:class:`.Series` to remove.\n        :raises ValueError: if you try to remove the last\\\n        :py:class:`.Series`.\"\"\"\n\n        if len(self.all_series()) == 1:\n            raise ValueError(\"Cannot remove last series from %s\" % str(self))\n        self._all_series.remove(series)\n        series._chart = None", "code_tokens": "def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( \"Cannot remove last series from %s\" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None", "docstring_tokens": "Removes a : py : class : . Series from the chart .", "label": 0}, {"idx": "cosqa-train-10221", "doc": "please add timezone info to timestamps python", "code": "def parse_timestamp(timestamp):\n    \"\"\"Parse ISO8601 timestamps given by github API.\"\"\"\n    dt = dateutil.parser.parse(timestamp)\n    return dt.astimezone(dateutil.tz.tzutc())", "code_tokens": "def parse_timestamp ( timestamp ) : dt = dateutil . parser . parse ( timestamp ) return dt . astimezone ( dateutil . tz . tzutc ( ) )", "docstring_tokens": "Parse ISO8601 timestamps given by github API .", "label": 1}, {"idx": "cosqa-train-10222", "doc": "remove emptu cells in python", "code": "def drop_empty(rows):\n    \"\"\"Transpose the columns into rows, remove all of the rows that are empty after the first cell, then\n    transpose back. The result is that columns that have a header but no data in the body are removed, assuming\n    the header is the first row. \"\"\"\n    return zip(*[col for col in zip(*rows) if bool(filter(bool, col[1:]))])", "code_tokens": "def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )", "docstring_tokens": "Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row .", "label": 1}, {"idx": "cosqa-train-10223", "doc": "plot a specific range matplotlib python", "code": "def highlight_region(plt, start_x, end_x):\n  \"\"\"\n  Highlight a region on the chart between the specified start and end x-co-ordinates.\n  param pyplot plt: matplotlibk pyplot which contains the charts to be highlighted\n  param string start_x : epoch time millis\n  param string end_x : epoch time millis\n  \"\"\"\n  start_x = convert_to_mdate(start_x)\n  end_x = convert_to_mdate(end_x)\n  plt.axvspan(start_x, end_x, color=CONSTANTS.HIGHLIGHT_COLOR, alpha=CONSTANTS.HIGHLIGHT_ALPHA)", "code_tokens": "def highlight_region ( plt , start_x , end_x ) : start_x = convert_to_mdate ( start_x ) end_x = convert_to_mdate ( end_x ) plt . axvspan ( start_x , end_x , color = CONSTANTS . HIGHLIGHT_COLOR , alpha = CONSTANTS . HIGHLIGHT_ALPHA )", "docstring_tokens": "Highlight a region on the chart between the specified start and end x - co - ordinates . param pyplot plt : matplotlibk pyplot which contains the charts to be highlighted param string start_x : epoch time millis param string end_x : epoch time millis", "label": 0}, {"idx": "cosqa-train-10224", "doc": "remove empty entry list python", "code": "def unique(transactions):\n    \"\"\" Remove any duplicate entries. \"\"\"\n    seen = set()\n    # TODO: Handle comments\n    return [x for x in transactions if not (x in seen or seen.add(x))]", "code_tokens": "def unique ( transactions ) : seen = set ( ) # TODO: Handle comments return [ x for x in transactions if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Remove any duplicate entries .", "label": 1}, {"idx": "cosqa-train-10225", "doc": "plot boxplot for entire dataset python", "code": "def compute_boxplot(self, series):\n        \"\"\"\n        Compute boxplot for given pandas Series.\n        \"\"\"\n        from matplotlib.cbook import boxplot_stats\n        series = series[series.notnull()]\n        if len(series.values) == 0:\n            return {}\n        elif not is_numeric_dtype(series):\n            return self.non_numeric_stats(series)\n        stats = boxplot_stats(list(series.values))[0]\n        stats['count'] = len(series.values)\n        stats['fliers'] = \"|\".join(map(str, stats['fliers']))\n        return stats", "code_tokens": "def compute_boxplot ( self , series ) : from matplotlib . cbook import boxplot_stats series = series [ series . notnull ( ) ] if len ( series . values ) == 0 : return { } elif not is_numeric_dtype ( series ) : return self . non_numeric_stats ( series ) stats = boxplot_stats ( list ( series . values ) ) [ 0 ] stats [ 'count' ] = len ( series . values ) stats [ 'fliers' ] = \"|\" . join ( map ( str , stats [ 'fliers' ] ) ) return stats", "docstring_tokens": "Compute boxplot for given pandas Series .", "label": 0}, {"idx": "cosqa-train-10226", "doc": "remove first instance of a space in string python", "code": "def uncomment_line(line, prefix):\n    \"\"\"Remove prefix (and space) from line\"\"\"\n    if not prefix:\n        return line\n    if line.startswith(prefix + ' '):\n        return line[len(prefix) + 1:]\n    if line.startswith(prefix):\n        return line[len(prefix):]\n    return line", "code_tokens": "def uncomment_line ( line , prefix ) : if not prefix : return line if line . startswith ( prefix + ' ' ) : return line [ len ( prefix ) + 1 : ] if line . startswith ( prefix ) : return line [ len ( prefix ) : ] return line", "docstring_tokens": "Remove prefix ( and space ) from line", "label": 1}, {"idx": "cosqa-train-10227", "doc": "remove ite spaces python", "code": "def strip_spaces(x):\n    \"\"\"\n    Strips spaces\n    :param x:\n    :return:\n    \"\"\"\n    x = x.replace(b' ', b'')\n    x = x.replace(b'\\t', b'')\n    return x", "code_tokens": "def strip_spaces ( x ) : x = x . replace ( b' ' , b'' ) x = x . replace ( b'\\t' , b'' ) return x", "docstring_tokens": "Strips spaces : param x : : return :", "label": 1}, {"idx": "cosqa-train-10228", "doc": "plot linear regression python on existing plot", "code": "def _linear_seaborn_(self, label=None, style=None, opts=None):\n        \"\"\"\n        Returns a Seaborn linear regression plot\n        \"\"\"\n        xticks, yticks = self._get_ticks(opts)\n        try:\n            fig = sns.lmplot(self.x, self.y, data=self.df)\n            fig = self._set_with_height(fig, opts)\n            return fig\n        except Exception as e:\n            self.err(e, self.linear_,\n                     \"Can not draw linear regression chart\")", "code_tokens": "def _linear_seaborn_ ( self , label = None , style = None , opts = None ) : xticks , yticks = self . _get_ticks ( opts ) try : fig = sns . lmplot ( self . x , self . y , data = self . df ) fig = self . _set_with_height ( fig , opts ) return fig except Exception as e : self . err ( e , self . linear_ , \"Can not draw linear regression chart\" )", "docstring_tokens": "Returns a Seaborn linear regression plot", "label": 1}, {"idx": "cosqa-train-10229", "doc": "remove item from python dictionary list", "code": "def pop (self, key):\n        \"\"\"Remove key from dict and return value.\"\"\"\n        if key in self._keys:\n            self._keys.remove(key)\n        super(ListDict, self).pop(key)", "code_tokens": "def pop ( self , key ) : if key in self . _keys : self . _keys . remove ( key ) super ( ListDict , self ) . pop ( key )", "docstring_tokens": "Remove key from dict and return value .", "label": 1}, {"idx": "cosqa-train-10230", "doc": "plot tree from random forest python", "code": "def draw_tree(t, df, size=10, ratio=0.6, precision=0):\n    \"\"\" Draws a representation of a random forest in IPython.\n    Parameters:\n    -----------\n    t: The tree you wish to draw\n    df: The data used to train the tree. This is used to get the names of the features.\n    \"\"\"\n    s=export_graphviz(t, out_file=None, feature_names=df.columns, filled=True,\n                      special_characters=True, rotate=True, precision=precision)\n    IPython.display.display(graphviz.Source(re.sub('Tree {',\n       f'Tree {{ size={size}; ratio={ratio}', s)))", "code_tokens": "def draw_tree ( t , df , size = 10 , ratio = 0.6 , precision = 0 ) : s = export_graphviz ( t , out_file = None , feature_names = df . columns , filled = True , special_characters = True , rotate = True , precision = precision ) IPython . display . display ( graphviz . Source ( re . sub ( 'Tree {' , f'Tree {{ size={size}; ratio={ratio}' , s ) ) )", "docstring_tokens": "Draws a representation of a random forest in IPython . Parameters : ----------- t : The tree you wish to draw df : The data used to train the tree . This is used to get the names of the features .", "label": 1}, {"idx": "cosqa-train-10231", "doc": "remove last item from array python", "code": "def remove_last_entry(self):\n        \"\"\"Remove the last NoteContainer in the Bar.\"\"\"\n        self.current_beat -= 1.0 / self.bar[-1][1]\n        self.bar = self.bar[:-1]\n        return self.current_beat", "code_tokens": "def remove_last_entry ( self ) : self . current_beat -= 1.0 / self . bar [ - 1 ] [ 1 ] self . bar = self . bar [ : - 1 ] return self . current_beat", "docstring_tokens": "Remove the last NoteContainer in the Bar .", "label": 1}, {"idx": "cosqa-train-10232", "doc": "plotting confusion matrix in python", "code": "def confusion_matrix(self):\n        \"\"\"Confusion matrix plot\n        \"\"\"\n        return plot.confusion_matrix(self.y_true, self.y_pred,\n                                     self.target_names, ax=_gen_ax())", "code_tokens": "def confusion_matrix ( self ) : return plot . confusion_matrix ( self . y_true , self . y_pred , self . target_names , ax = _gen_ax ( ) )", "docstring_tokens": "Confusion matrix plot", "label": 1}, {"idx": "cosqa-train-10233", "doc": "remove namespace from xml tag python", "code": "def strip_xml_namespace(root):\n    \"\"\"Strip out namespace data from an ElementTree.\n\n    This function is recursive and will traverse all\n    subnodes to the root element\n\n    @param root: the root element\n\n    @return: the same root element, minus namespace\n    \"\"\"\n    try:\n        root.tag = root.tag.split('}')[1]\n    except IndexError:\n        pass\n\n    for element in root.getchildren():\n        strip_xml_namespace(element)", "code_tokens": "def strip_xml_namespace ( root ) : try : root . tag = root . tag . split ( '}' ) [ 1 ] except IndexError : pass for element in root . getchildren ( ) : strip_xml_namespace ( element )", "docstring_tokens": "Strip out namespace data from an ElementTree .", "label": 1}, {"idx": "cosqa-train-10234", "doc": "precision of ints in python", "code": "def round_to_int(number, precision):\n    \"\"\"Round a number to a precision\"\"\"\n    precision = int(precision)\n    rounded = (int(number) + precision / 2) // precision * precision\n    return rounded", "code_tokens": "def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded", "docstring_tokens": "Round a number to a precision", "label": 1}, {"idx": "cosqa-train-10235", "doc": "remove occurrences in list python", "code": "def unique(input_list):\n    \"\"\"\n    Return a list of unique items (similar to set functionality).\n\n    Parameters\n    ----------\n    input_list : list\n        A list containg some items that can occur more than once.\n\n    Returns\n    -------\n    list\n        A list with only unique occurances of an item.\n\n    \"\"\"\n    output = []\n    for item in input_list:\n        if item not in output:\n            output.append(item)\n    return output", "code_tokens": "def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output", "docstring_tokens": "Return a list of unique items ( similar to set functionality ) .", "label": 0}, {"idx": "cosqa-train-10236", "doc": "pretty is not defined python", "code": "def pprint(obj, verbose=False, max_width=79, newline='\\n'):\n    \"\"\"\n    Like `pretty` but print to stdout.\n    \"\"\"\n    printer = RepresentationPrinter(sys.stdout, verbose, max_width, newline)\n    printer.pretty(obj)\n    printer.flush()\n    sys.stdout.write(newline)\n    sys.stdout.flush()", "code_tokens": "def pprint ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )", "docstring_tokens": "Like pretty but print to stdout .", "label": 1}, {"idx": "cosqa-train-10237", "doc": "remove same elements in a list in python", "code": "def distinct(l):\n    \"\"\"\n    Return a list where the duplicates have been removed.\n\n    Args:\n        l (list): the list to filter.\n\n    Returns:\n        list: the same list without duplicates.\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return (_ for _ in l if not (_ in seen or seen_add(_)))", "code_tokens": "def distinct ( l ) : seen = set ( ) seen_add = seen . add return ( _ for _ in l if not ( _ in seen or seen_add ( _ ) ) )", "docstring_tokens": "Return a list where the duplicates have been removed .", "label": 0}, {"idx": "cosqa-train-10238", "doc": "remove tabs and new lines before and after string element python", "code": "def _breakRemNewlines(tag):\n\t\"\"\"non-recursively break spaces and remove newlines in the tag\"\"\"\n\tfor i,c in enumerate(tag.contents):\n\t\tif type(c) != bs4.element.NavigableString:\n\t\t\tcontinue\n\t\tc.replace_with(re.sub(r' {2,}', ' ', c).replace('\\n',''))", "code_tokens": "def _breakRemNewlines ( tag ) : for i , c in enumerate ( tag . contents ) : if type ( c ) != bs4 . element . NavigableString : continue c . replace_with ( re . sub ( r' {2,}' , ' ' , c ) . replace ( '\\n' , '' ) )", "docstring_tokens": "non - recursively break spaces and remove newlines in the tag", "label": 1}, {"idx": "cosqa-train-10239", "doc": "print as formatted table python", "code": "def get_table(ports):\n    \"\"\"\n    This function returns a pretty table used to display the port results.\n\n    :param ports: list of found ports\n    :return: the table to display\n    \"\"\"\n    table = PrettyTable([\"Name\", \"Port\", \"Protocol\", \"Description\"])\n    table.align[\"Name\"] = \"l\"\n    table.align[\"Description\"] = \"l\"\n    table.padding_width = 1\n\n    for port in ports:\n        table.add_row(port)\n\n    return table", "code_tokens": "def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "docstring_tokens": "This function returns a pretty table used to display the port results .", "label": 0}, {"idx": "cosqa-train-10240", "doc": "remove whitespaces in string python", "code": "def text_cleanup(data, key, last_type):\n    \"\"\" I strip extra whitespace off multi-line strings if they are ready to be stripped!\"\"\"\n    if key in data and last_type == STRING_TYPE:\n        data[key] = data[key].strip()\n    return data", "code_tokens": "def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data", "docstring_tokens": "I strip extra whitespace off multi - line strings if they are ready to be stripped!", "label": 1}, {"idx": "cosqa-train-10241", "doc": "print object as string python", "code": "def __repr__(self):\n        \"\"\"Return string representation of object.\"\"\"\n        return str(self.__class__) + '(' + ', '.join([list.__repr__(d) for d in self.data]) + ')'", "code_tokens": "def __repr__ ( self ) : return str ( self . __class__ ) + '(' + ', ' . join ( [ list . __repr__ ( d ) for d in self . data ] ) + ')'", "docstring_tokens": "Return string representation of object .", "label": 0}, {"idx": "cosqa-train-10242", "doc": "replace all non alpha in python", "code": "def dashrepl(value):\n    \"\"\"\n    Replace any non-word characters with a dash.\n    \"\"\"\n    patt = re.compile(r'\\W', re.UNICODE)\n    return re.sub(patt, '-', value)", "code_tokens": "def dashrepl ( value ) : patt = re . compile ( r'\\W' , re . UNICODE ) return re . sub ( patt , '-' , value )", "docstring_tokens": "Replace any non - word characters with a dash .", "label": 1}, {"idx": "cosqa-train-10243", "doc": "print to cerr in python", "code": "def print_err(*args, end='\\n'):\n    \"\"\"Similar to print, but prints to stderr.\n    \"\"\"\n    print(*args, end=end, file=sys.stderr)\n    sys.stderr.flush()", "code_tokens": "def print_err ( * args , end = '\\n' ) : print ( * args , end = end , file = sys . stderr ) sys . stderr . flush ( )", "docstring_tokens": "Similar to print but prints to stderr .", "label": 1}, {"idx": "cosqa-train-10244", "doc": "replace every upper and lower letter in python", "code": "def decamelise(text):\n    \"\"\"Convert CamelCase to lower_and_underscore.\"\"\"\n    s = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s).lower()", "code_tokens": "def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s ) . lower ( )", "docstring_tokens": "Convert CamelCase to lower_and_underscore .", "label": 1}, {"idx": "cosqa-train-10245", "doc": "printing object variable in python", "code": "def prnt(self):\n        \"\"\"\n        Prints DB data representation of the object.\n        \"\"\"\n        print(\"= = = =\\n\\n%s object key: \\033[32m%s\\033[0m\" % (self.__class__.__name__, self.key))\n        pprnt(self._data or self.clean_value())", "code_tokens": "def prnt ( self ) : print ( \"= = = =\\n\\n%s object key: \\033[32m%s\\033[0m\" % ( self . __class__ . __name__ , self . key ) ) pprnt ( self . _data or self . clean_value ( ) )", "docstring_tokens": "Prints DB data representation of the object .", "label": 1}, {"idx": "cosqa-train-10246", "doc": "replace function for text file in python", "code": "def replace_all(filepath, searchExp, replaceExp):\n    \"\"\"\n    Replace all the ocurrences (in a file) of a string with another value.\n    \"\"\"\n    for line in fileinput.input(filepath, inplace=1):\n        if searchExp in line:\n            line = line.replace(searchExp, replaceExp)\n        sys.stdout.write(line)", "code_tokens": "def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )", "docstring_tokens": "Replace all the ocurrences ( in a file ) of a string with another value .", "label": 1}, {"idx": "cosqa-train-10247", "doc": "printing the name of an enum in python", "code": "def EnumValueName(self, enum, value):\n    \"\"\"Returns the string name of an enum value.\n\n    This is just a small helper method to simplify a common operation.\n\n    Args:\n      enum: string name of the Enum.\n      value: int, value of the enum.\n\n    Returns:\n      string name of the enum value.\n\n    Raises:\n      KeyError if either the Enum doesn't exist or the value is not a valid\n        value for the enum.\n    \"\"\"\n    return self.enum_types_by_name[enum].values_by_number[value].name", "code_tokens": "def EnumValueName ( self , enum , value ) : return self . enum_types_by_name [ enum ] . values_by_number [ value ] . name", "docstring_tokens": "Returns the string name of an enum value .", "label": 0}, {"idx": "cosqa-train-10248", "doc": "replace in string list comprehension python", "code": "def replace_list(items, match, replacement):\n    \"\"\"Replaces occurrences of a match string in a given list of strings and returns\n    a list of new strings. The match string can be a regex expression.\n\n    Args:\n        items (list):       the list of strings to modify.\n        match (str):        the search expression.\n        replacement (str):  the string to replace with.\n    \"\"\"\n    return [replace(item, match, replacement) for item in items]", "code_tokens": "def replace_list ( items , match , replacement ) : return [ replace ( item , match , replacement ) for item in items ]", "docstring_tokens": "Replaces occurrences of a match string in a given list of strings and returns a list of new strings . The match string can be a regex expression .", "label": 0}, {"idx": "cosqa-train-10249", "doc": "produce list of unique values in python data frame frequencies", "code": "def get_unique_indices(df, axis=1):\n    \"\"\"\n\n    :param df:\n    :param axis:\n    :return:\n    \"\"\"\n    return dict(zip(df.columns.names, dif.columns.levels))", "code_tokens": "def get_unique_indices ( df , axis = 1 ) : return dict ( zip ( df . columns . names , dif . columns . levels ) )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-10250", "doc": "replace number with month in python", "code": "def replace_month_abbr_with_num(date_str, lang=DEFAULT_DATE_LANG):\n    \"\"\"Replace month strings occurrences with month number.\"\"\"\n    num, abbr = get_month_from_date_str(date_str, lang)\n    return re.sub(abbr, str(num), date_str, flags=re.IGNORECASE)", "code_tokens": "def replace_month_abbr_with_num ( date_str , lang = DEFAULT_DATE_LANG ) : num , abbr = get_month_from_date_str ( date_str , lang ) return re . sub ( abbr , str ( num ) , date_str , flags = re . IGNORECASE )", "docstring_tokens": "Replace month strings occurrences with month number .", "label": 1}, {"idx": "cosqa-train-10251", "doc": "python 'axessubplot' object is not subscriptable", "code": "def get_subplot_at(self, row, column):\n        \"\"\"Return the subplot at row, column position.\n\n        :param row,column: specify the subplot.\n\n        \"\"\"\n        idx = row * self.columns + column\n        return self.subplots[idx]", "code_tokens": "def get_subplot_at ( self , row , column ) : idx = row * self . columns + column return self . subplots [ idx ]", "docstring_tokens": "Return the subplot at row column position .", "label": 0}, {"idx": "cosqa-train-10252", "doc": "replace slashes with hyphens python string", "code": "def slugify(string):\n    \"\"\"\n    Removes non-alpha characters, and converts spaces to hyphens. Useful for making file names.\n\n\n    Source: http://stackoverflow.com/questions/5574042/string-slugification-in-python\n    \"\"\"\n    string = re.sub('[^\\w .-]', '', string)\n    string = string.replace(\" \", \"-\")\n    return string", "code_tokens": "def slugify ( string ) : string = re . sub ( '[^\\w .-]' , '' , string ) string = string . replace ( \" \" , \"-\" ) return string", "docstring_tokens": "Removes non - alpha characters and converts spaces to hyphens . Useful for making file names . Source : http : // stackoverflow . com / questions / 5574042 / string - slugification - in - python", "label": 0}, {"idx": "cosqa-train-10253", "doc": "python 'namespace' object is not iterable", "code": "def __add_namespaceinfo(self, ni):\n        \"\"\"Internal method to directly add a _NamespaceInfo object to this\n        set.  No sanity checks are done (e.g. checking for prefix conflicts),\n        so be sure to do it yourself before calling this.\"\"\"\n        self.__ns_uri_map[ni.uri] = ni\n        for prefix in ni.prefixes:\n            self.__prefix_map[prefix] = ni", "code_tokens": "def __add_namespaceinfo ( self , ni ) : self . __ns_uri_map [ ni . uri ] = ni for prefix in ni . prefixes : self . __prefix_map [ prefix ] = ni", "docstring_tokens": "Internal method to directly add a _NamespaceInfo object to this set . No sanity checks are done ( e . g . checking for prefix conflicts ) so be sure to do it yourself before calling this .", "label": 1}, {"idx": "cosqa-train-10254", "doc": "replacing value with nan conditional in python", "code": "def _replace_nan(a, val):\n    \"\"\"\n    replace nan in a by val, and returns the replaced array and the nan\n    position\n    \"\"\"\n    mask = isnull(a)\n    return where_method(val, mask, a), mask", "code_tokens": "def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask", "docstring_tokens": "replace nan in a by val and returns the replaced array and the nan position", "label": 1}, {"idx": "cosqa-train-10255", "doc": "python 'nonetype' object has no attribute 'xenapi'", "code": "def request_type(self):\n        \"\"\"Retrieve the type of the request, by fetching it from\n        `xenon.proto.xenon_pb2`.\"\"\"\n        if self.static and not self.uses_request:\n            return getattr(xenon_pb2, 'Empty')\n\n        if not self.uses_request:\n            return None\n\n        return getattr(xenon_pb2, self.request_name)", "code_tokens": "def request_type ( self ) : if self . static and not self . uses_request : return getattr ( xenon_pb2 , 'Empty' ) if not self . uses_request : return None return getattr ( xenon_pb2 , self . request_name )", "docstring_tokens": "Retrieve the type of the request by fetching it from xenon . proto . xenon_pb2 .", "label": 0}, {"idx": "cosqa-train-10256", "doc": "reset method for iterator python", "code": "def reset(self):\n\t\t\"\"\"\n\t\tResets the iterator to the start.\n\n\t\tAny remaining values in the current iteration are discarded.\n\t\t\"\"\"\n\t\tself.__iterator, self.__saved = itertools.tee(self.__saved)", "code_tokens": "def reset ( self ) : self . __iterator , self . __saved = itertools . tee ( self . __saved )", "docstring_tokens": "Resets the iterator to the start .", "label": 0}, {"idx": "cosqa-train-10257", "doc": "python 'resource' has no attribute 'getpagesize'", "code": "def peak_memory_usage():\n    \"\"\"Return peak memory usage in MB\"\"\"\n    if sys.platform.startswith('win'):\n        p = psutil.Process()\n        return p.memory_info().peak_wset / 1024 / 1024\n\n    mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss\n    factor_mb = 1 / 1024\n    if sys.platform == 'darwin':\n        factor_mb = 1 / (1024 * 1024)\n    return mem * factor_mb", "code_tokens": "def peak_memory_usage ( ) : if sys . platform . startswith ( 'win' ) : p = psutil . Process ( ) return p . memory_info ( ) . peak_wset / 1024 / 1024 mem = resource . getrusage ( resource . RUSAGE_SELF ) . ru_maxrss factor_mb = 1 / 1024 if sys . platform == 'darwin' : factor_mb = 1 / ( 1024 * 1024 ) return mem * factor_mb", "docstring_tokens": "Return peak memory usage in MB", "label": 1}, {"idx": "cosqa-train-10258", "doc": "reset only one multiindex python", "code": "def cmd_reindex():\n    \"\"\"Uses CREATE INDEX CONCURRENTLY to create a duplicate index, then tries to swap the new index for the original.\n\n    The index swap is done using a short lock timeout to prevent it from interfering with running queries. Retries until\n    the rename succeeds.\n    \"\"\"\n    db = connect(args.database)\n    for idx in args.indexes:\n        pg_reindex(db, idx)", "code_tokens": "def cmd_reindex ( ) : db = connect ( args . database ) for idx in args . indexes : pg_reindex ( db , idx )", "docstring_tokens": "Uses CREATE INDEX CONCURRENTLY to create a duplicate index then tries to swap the new index for the original .", "label": 0}, {"idx": "cosqa-train-10259", "doc": "python 'worksheet' object is not callable", "code": "def add_chart(self, chart, row, col):\n        \"\"\"\n        Adds a chart to the worksheet at (row, col).\n\n        :param xltable.Chart Chart: chart to add to the workbook.\n        :param int row: Row to add the chart at.\n        \"\"\"\n        self.__charts.append((chart, (row, col)))", "code_tokens": "def add_chart ( self , chart , row , col ) : self . __charts . append ( ( chart , ( row , col ) ) )", "docstring_tokens": "Adds a chart to the worksheet at ( row col ) .", "label": 1}, {"idx": "cosqa-train-10260", "doc": "response status 404 python", "code": "def raise_for_not_ok_status(response):\n    \"\"\"\n    Raises a `requests.exceptions.HTTPError` if the response has a non-200\n    status code.\n    \"\"\"\n    if response.code != OK:\n        raise HTTPError('Non-200 response code (%s) for url: %s' % (\n            response.code, uridecode(response.request.absoluteURI)))\n\n    return response", "code_tokens": "def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response", "docstring_tokens": "Raises a requests . exceptions . HTTPError if the response has a non - 200 status code .", "label": 1}, {"idx": "cosqa-train-10261", "doc": "python 2 arraysreshape into 3 dimensional", "code": "def make_2d(ary):\n    \"\"\"Convert any array into a 2d numpy array.\n\n    In case the array is already more than 2 dimensional, will ravel the\n    dimensions after the first.\n    \"\"\"\n    dim_0, *_ = np.atleast_1d(ary).shape\n    return ary.reshape(dim_0, -1, order=\"F\")", "code_tokens": "def make_2d ( ary ) : dim_0 ,  * _ = np . atleast_1d ( ary ) . shape return ary . reshape ( dim_0 , - 1 , order = \"F\" )", "docstring_tokens": "Convert any array into a 2d numpy array .", "label": 1}, {"idx": "cosqa-train-10262", "doc": "restricting input of python function to listlike", "code": "def flatten(l, types=(list, float)):\n    \"\"\"\n    Flat nested list of lists into a single list.\n    \"\"\"\n    l = [item if isinstance(item, types) else [item] for item in l]\n    return [item for sublist in l for item in sublist]", "code_tokens": "def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Flat nested list of lists into a single list .", "label": 1}, {"idx": "cosqa-train-10263", "doc": "python 2 function return null while it should return int", "code": "def _check_for_int(x):\n    \"\"\"\n    This is a compatibility function that takes a C{float} and converts it to an\n    C{int} if the values are equal.\n    \"\"\"\n    try:\n        y = int(x)\n    except (OverflowError, ValueError):\n        pass\n    else:\n        # There is no way in AMF0 to distinguish between integers and floats\n        if x == x and y == x:\n            return y\n\n    return x", "code_tokens": "def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x", "docstring_tokens": "This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal .", "label": 1}, {"idx": "cosqa-train-10264", "doc": "retrieve function name python", "code": "def get_func_name(func):\n    \"\"\"Return a name which includes the module name and function name.\"\"\"\n    func_name = getattr(func, '__name__', func.__class__.__name__)\n    module_name = func.__module__\n\n    if module_name is not None:\n        module_name = func.__module__\n        return '{}.{}'.format(module_name, func_name)\n\n    return func_name", "code_tokens": "def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name", "docstring_tokens": "Return a name which includes the module name and function name .", "label": 1}, {"idx": "cosqa-train-10265", "doc": "python 2 write json object to file", "code": "def _serialize_json(obj, fp):\n    \"\"\" Serialize ``obj`` as a JSON formatted stream to ``fp`` \"\"\"\n    json.dump(obj, fp, indent=4, default=serialize)", "code_tokens": "def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )", "docstring_tokens": "Serialize obj as a JSON formatted stream to fp", "label": 1}, {"idx": "cosqa-train-10266", "doc": "retrieving file location of python script", "code": "def getScriptLocation():\n\t\"\"\"Helper function to get the location of a Python file.\"\"\"\n\tlocation = os.path.abspath(\"./\")\n\tif __file__.rfind(\"/\") != -1:\n\t\tlocation = __file__[:__file__.rfind(\"/\")]\n\treturn location", "code_tokens": "def getScriptLocation ( ) : location = os . path . abspath ( \"./\" ) if __file__ . rfind ( \"/\" ) != - 1 : location = __file__ [ : __file__ . rfind ( \"/\" ) ] return location", "docstring_tokens": "Helper function to get the location of a Python file .", "label": 1}, {"idx": "cosqa-train-10267", "doc": "python 2d array of lists numpy", "code": "def A(*a):\n    \"\"\"convert iterable object into numpy array\"\"\"\n    return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "code_tokens": "def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]", "docstring_tokens": "convert iterable object into numpy array", "label": 0}, {"idx": "cosqa-train-10268", "doc": "retrrieve item from priorityqueue without priority python", "code": "def get_item_from_queue(Q, timeout=0.01):\n    \"\"\" Attempts to retrieve an item from the queue Q. If Q is\n        empty, None is returned.\n\n        Blocks for 'timeout' seconds in case the queue is empty,\n        so don't use this method for speedy retrieval of multiple\n        items (use get_all_from_queue for that).\n    \"\"\"\n    try:\n        item = Q.get(True, 0.01)\n    except Queue.Empty:\n        return None\n\n    return item", "code_tokens": "def get_item_from_queue ( Q , timeout = 0.01 ) : try : item = Q . get ( True , 0.01 ) except Queue . Empty : return None return item", "docstring_tokens": "Attempts to retrieve an item from the queue Q . If Q is empty None is returned . Blocks for timeout seconds in case the queue is empty so don t use this method for speedy retrieval of multiple items ( use get_all_from_queue for that ) .", "label": 0}, {"idx": "cosqa-train-10269", "doc": "python 2d array of objects", "code": "def vec(self):\n        \"\"\":obj:`numpy.ndarray` : Vector representation for this camera.\n        \"\"\"\n        return np.r_[self.fx, self.fy, self.cx, self.cy, self.skew, self.height, self.width]", "code_tokens": "def vec ( self ) : return np . r_ [ self . fx , self . fy , self . cx , self . cy , self . skew , self . height , self . width ]", "docstring_tokens": ": obj : numpy . ndarray : Vector representation for this camera .", "label": 1}, {"idx": "cosqa-train-10270", "doc": "return docstring python as help", "code": "def help_for_command(command):\n    \"\"\"Get the help text (signature + docstring) for a command (function).\"\"\"\n    help_text = pydoc.text.document(command)\n    # remove backspaces\n    return re.subn('.\\\\x08', '', help_text)[0]", "code_tokens": "def help_for_command ( command ) : help_text = pydoc . text . document ( command ) # remove backspaces return re . subn ( '.\\\\x08' , '' , help_text ) [ 0 ]", "docstring_tokens": "Get the help text ( signature + docstring ) for a command ( function ) .", "label": 1}, {"idx": "cosqa-train-10271", "doc": "python 3 a build string from iterable", "code": "def commajoin_as_strings(iterable):\n    \"\"\" Join the given iterable with ',' \"\"\"\n    return _(u',').join((six.text_type(i) for i in iterable))", "code_tokens": "def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )", "docstring_tokens": "Join the given iterable with", "label": 1}, {"idx": "cosqa-train-10272", "doc": "return indice in matrix python", "code": "def kindex(matrix, k):\n    \"\"\" Returns indices to select the kth nearest neighbour\"\"\"\n\n    ix = (np.arange(len(matrix)), matrix.argsort(axis=0)[k])\n    return ix", "code_tokens": "def kindex ( matrix , k ) : ix = ( np . arange ( len ( matrix ) ) , matrix . argsort ( axis = 0 ) [ k ] ) return ix", "docstring_tokens": "Returns indices to select the kth nearest neighbour", "label": 1}, {"idx": "cosqa-train-10273", "doc": "python 3 check file permissions", "code": "def check_permission_safety(path):\n    \"\"\"Check if the file at the given path is safe to use as a state file.\n\n    This checks that group and others have no permissions on the file and that the current user is\n    the owner.\n    \"\"\"\n    f_stats = os.stat(path)\n    return (f_stats.st_mode & (stat.S_IRWXG | stat.S_IRWXO)) == 0 and f_stats.st_uid == os.getuid()", "code_tokens": "def check_permission_safety ( path ) : f_stats = os . stat ( path ) return ( f_stats . st_mode & ( stat . S_IRWXG | stat . S_IRWXO ) ) == 0 and f_stats . st_uid == os . getuid ( )", "docstring_tokens": "Check if the file at the given path is safe to use as a state file .", "label": 0}, {"idx": "cosqa-train-10274", "doc": "python 3 datetime fromtimestamp", "code": "def timestamp_to_datetime(timestamp):\n    \"\"\"Convert an ARF timestamp to a datetime.datetime object (naive local time)\"\"\"\n    from datetime import datetime, timedelta\n    obj = datetime.fromtimestamp(timestamp[0])\n    return obj + timedelta(microseconds=int(timestamp[1]))", "code_tokens": "def timestamp_to_datetime ( timestamp ) : from datetime import datetime , timedelta obj = datetime . fromtimestamp ( timestamp [ 0 ] ) return obj + timedelta ( microseconds = int ( timestamp [ 1 ] ) )", "docstring_tokens": "Convert an ARF timestamp to a datetime . datetime object ( naive local time )", "label": 1}, {"idx": "cosqa-train-10275", "doc": "return nan values of a column in data frame python", "code": "def reduce_fn(x):\n    \"\"\"\n    Aggregation function to get the first non-zero value.\n    \"\"\"\n    values = x.values if pd and isinstance(x, pd.Series) else x\n    for v in values:\n        if not is_nan(v):\n            return v\n    return np.NaN", "code_tokens": "def reduce_fn ( x ) : values = x . values if pd and isinstance ( x , pd . Series ) else x for v in values : if not is_nan ( v ) : return v return np . NaN", "docstring_tokens": "Aggregation function to get the first non - zero value .", "label": 1}, {"idx": "cosqa-train-10276", "doc": "python 3 define length of an arr", "code": "def array_dim(arr):\n    \"\"\"Return the size of a multidimansional array.\n    \"\"\"\n    dim = []\n    while True:\n        try:\n            dim.append(len(arr))\n            arr = arr[0]\n        except TypeError:\n            return dim", "code_tokens": "def array_dim ( arr ) : dim = [ ] while True : try : dim . append ( len ( arr ) ) arr = arr [ 0 ] except TypeError : return dim", "docstring_tokens": "Return the size of a multidimansional array .", "label": 0}, {"idx": "cosqa-train-10277", "doc": "return only unique items from list python", "code": "def unique_items(seq):\n    \"\"\"Return the unique items from iterable *seq* (in order).\"\"\"\n    seen = set()\n    return [x for x in seq if not (x in seen or seen.add(x))]", "code_tokens": "def unique_items ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Return the unique items from iterable * seq * ( in order ) .", "label": 1}, {"idx": "cosqa-train-10278", "doc": "python 3 float 2 decimal points round", "code": "def py3round(number):\n    \"\"\"Unified rounding in all python versions.\"\"\"\n    if abs(round(number) - number) == 0.5:\n        return int(2.0 * round(number / 2.0))\n\n    return int(round(number))", "code_tokens": "def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )", "docstring_tokens": "Unified rounding in all python versions .", "label": 1}, {"idx": "cosqa-train-10279", "doc": "return render function python django", "code": "def render_template(content, context):\n    \"\"\" renders context aware template \"\"\"\n    rendered = Template(content).render(Context(context))\n    return rendered", "code_tokens": "def render_template ( content , context ) : rendered = Template ( content ) . render ( Context ( context ) ) return rendered", "docstring_tokens": "renders context aware template", "label": 1}, {"idx": "cosqa-train-10280", "doc": "python 3 get basename of url", "code": "def get_file_name(url):\n  \"\"\"Returns file name of file at given url.\"\"\"\n  return os.path.basename(urllib.parse.urlparse(url).path) or 'unknown_name'", "code_tokens": "def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'", "docstring_tokens": "Returns file name of file at given url .", "label": 1}, {"idx": "cosqa-train-10281", "doc": "return something from an environment variable from python", "code": "def _get_env(self, env_var):\n        \"\"\"Helper to read an environment variable\n        \"\"\"\n        value = os.environ.get(env_var)\n        if not value:\n            raise ValueError('Missing environment variable:%s' % env_var)\n        return value", "code_tokens": "def _get_env ( self , env_var ) : value = os . environ . get ( env_var ) if not value : raise ValueError ( 'Missing environment variable:%s' % env_var ) return value", "docstring_tokens": "Helper to read an environment variable", "label": 1}, {"idx": "cosqa-train-10282", "doc": "python 3 how to color code", "code": "def stringc(text, color):\n    \"\"\"\n    Return a string with terminal colors.\n    \"\"\"\n    if has_colors:\n        text = str(text)\n\n        return \"\\033[\"+codeCodes[color]+\"m\"+text+\"\\033[0m\"\n    else:\n        return text", "code_tokens": "def stringc ( text , color ) : if has_colors : text = str ( text ) return \"\\033[\" + codeCodes [ color ] + \"m\" + text + \"\\033[0m\" else : return text", "docstring_tokens": "Return a string with terminal colors .", "label": 0}, {"idx": "cosqa-train-10283", "doc": "return true if integer, false if not python", "code": "def is_int(value):\n    \"\"\"Return `True` if ``value`` is an integer.\"\"\"\n    if isinstance(value, bool):\n        return False\n    try:\n        int(value)\n        return True\n    except (ValueError, TypeError):\n        return False", "code_tokens": "def is_int ( value ) : if isinstance ( value , bool ) : return False try : int ( value ) return True except ( ValueError , TypeError ) : return False", "docstring_tokens": "Return True if value is an integer .", "label": 1}, {"idx": "cosqa-train-10284", "doc": "python 3 int round up", "code": "def py3round(number):\n    \"\"\"Unified rounding in all python versions.\"\"\"\n    if abs(round(number) - number) == 0.5:\n        return int(2.0 * round(number / 2.0))\n\n    return int(round(number))", "code_tokens": "def py3round ( number ) : if abs ( round ( number ) - number ) == 0.5 : return int ( 2.0 * round ( number / 2.0 ) ) return int ( round ( number ) )", "docstring_tokens": "Unified rounding in all python versions .", "label": 0}, {"idx": "cosqa-train-10285", "doc": "return unique list vlaues python", "code": "def get_uniques(l):\n    \"\"\" Returns a list with no repeated elements.\n    \"\"\"\n    result = []\n\n    for i in l:\n        if i not in result:\n            result.append(i)\n\n    return result", "code_tokens": "def get_uniques ( l ) : result = [ ] for i in l : if i not in result : result . append ( i ) return result", "docstring_tokens": "Returns a list with no repeated elements .", "label": 1}, {"idx": "cosqa-train-10286", "doc": "python 3 md5hash file", "code": "def md5_hash_file(fh):\n    \"\"\"Return the md5 hash of the given file-object\"\"\"\n    md5 = hashlib.md5()\n    while True:\n        data = fh.read(8192)\n        if not data:\n            break\n        md5.update(data)\n    return md5.hexdigest()", "code_tokens": "def md5_hash_file ( fh ) : md5 = hashlib . md5 ( ) while True : data = fh . read ( 8192 ) if not data : break md5 . update ( data ) return md5 . hexdigest ( )", "docstring_tokens": "Return the md5 hash of the given file - object", "label": 1}, {"idx": "cosqa-train-10287", "doc": "returning multiple values in a queue python multiprocesss", "code": "def create(parallel):\n    \"\"\"Create a queue based on the provided parallel arguments.\n\n    TODO Startup/tear-down. Currently using default queue for testing\n    \"\"\"\n    queue = {k: v for k, v in parallel.items() if k in [\"queue\", \"cores_per_job\", \"mem\"]}\n    yield queue", "code_tokens": "def create ( parallel ) : queue = { k : v for k , v in parallel . items ( ) if k in [ \"queue\" , \"cores_per_job\" , \"mem\" ] } yield queue", "docstring_tokens": "Create a queue based on the provided parallel arguments .", "label": 1}, {"idx": "cosqa-train-10288", "doc": "python 3 print excetion message", "code": "def format_exc(limit=None):\n    \"\"\"Like print_exc() but return a string. Backport for Python 2.3.\"\"\"\n    try:\n        etype, value, tb = sys.exc_info()\n        return ''.join(traceback.format_exception(etype, value, tb, limit))\n    finally:\n        etype = value = tb = None", "code_tokens": "def format_exc ( limit = None ) : try : etype , value , tb = sys . exc_info ( ) return '' . join ( traceback . format_exception ( etype , value , tb , limit ) ) finally : etype = value = tb = None", "docstring_tokens": "Like print_exc () but return a string . Backport for Python 2 . 3 .", "label": 1}, {"idx": "cosqa-train-10289", "doc": "rotation transform on 2d array in python", "code": "def create_rot2d(angle):\n    \"\"\"Create 2D rotation matrix\"\"\"\n    ca = math.cos(angle)\n    sa = math.sin(angle)\n    return np.array([[ca, -sa], [sa, ca]])", "code_tokens": "def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )", "docstring_tokens": "Create 2D rotation matrix", "label": 0}, {"idx": "cosqa-train-10290", "doc": "python 3 regular expression to validate email", "code": "def is_valid_email(email):\n    \"\"\"\n    Check if email is valid\n    \"\"\"\n    pattern = re.compile(r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+')\n    return bool(pattern.match(email))", "code_tokens": "def is_valid_email ( email ) : pattern = re . compile ( r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+' ) return bool ( pattern . match ( email ) )", "docstring_tokens": "Check if email is valid", "label": 0}, {"idx": "cosqa-train-10291", "doc": "round to significant digits in python", "code": "def round_figures(x, n):\n    \"\"\"Returns x rounded to n significant figures.\"\"\"\n    return round(x, int(n - math.ceil(math.log10(abs(x)))))", "code_tokens": "def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )", "docstring_tokens": "Returns x rounded to n significant figures .", "label": 0}, {"idx": "cosqa-train-10292", "doc": "python 3 replace every n instacnesstring", "code": "def subn_filter(s, find, replace, count=0):\n    \"\"\"A non-optimal implementation of a regex filter\"\"\"\n    return re.gsub(find, replace, count, s)", "code_tokens": "def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )", "docstring_tokens": "A non - optimal implementation of a regex filter", "label": 1}, {"idx": "cosqa-train-10293", "doc": "round to zero decimals python", "code": "def price_rounding(price, decimals=2):\n    \"\"\"Takes a decimal price and rounds to a number of decimal places\"\"\"\n    try:\n        exponent = D('.' + decimals * '0')\n    except InvalidOperation:\n        # Currencies with no decimal places, ex. JPY, HUF\n        exponent = D()\n    return price.quantize(exponent, rounding=ROUND_UP)", "code_tokens": "def price_rounding ( price , decimals = 2 ) : try : exponent = D ( '.' + decimals * '0' ) except InvalidOperation : # Currencies with no decimal places, ex. JPY, HUF exponent = D ( ) return price . quantize ( exponent , rounding = ROUND_UP )", "docstring_tokens": "Takes a decimal price and rounds to a number of decimal places", "label": 1}, {"idx": "cosqa-train-10294", "doc": "python 3 validate iterable type", "code": "def is_iterable(value):\n    \"\"\"must be an iterable (list, array, tuple)\"\"\"\n    return isinstance(value, np.ndarray) or isinstance(value, list) or isinstance(value, tuple), value", "code_tokens": "def is_iterable ( value ) : return isinstance ( value , np . ndarray ) or isinstance ( value , list ) or isinstance ( value , tuple ) , value", "docstring_tokens": "must be an iterable ( list array tuple )", "label": 1}, {"idx": "cosqa-train-10295", "doc": "ruemel yaml read file python", "code": "def getYamlDocument(filePath):\n    \"\"\"\n    Return a yaml file's contents as a dictionary\n    \"\"\"\n    with open(filePath) as stream:\n        doc = yaml.load(stream)\n        return doc", "code_tokens": "def getYamlDocument ( filePath ) : with open ( filePath ) as stream : doc = yaml . load ( stream ) return doc", "docstring_tokens": "Return a yaml file s contents as a dictionary", "label": 1}, {"idx": "cosqa-train-10296", "doc": "python 3 xml pretty", "code": "def pp_xml(body):\n    \"\"\"Pretty print format some XML so it's readable.\"\"\"\n    pretty = xml.dom.minidom.parseString(body)\n    return pretty.toprettyxml(indent=\"  \")", "code_tokens": "def pp_xml ( body ) : pretty = xml . dom . minidom . parseString ( body ) return pretty . toprettyxml ( indent = \"  \" )", "docstring_tokens": "Pretty print format some XML so it s readable .", "label": 1}, {"idx": "cosqa-train-10297", "doc": "run a python script jquery", "code": "def safe_execute_script(driver, script):\n    \"\"\" When executing a script that contains a jQuery command,\n        it's important that the jQuery library has been loaded first.\n        This method will load jQuery if it wasn't already loaded. \"\"\"\n    try:\n        driver.execute_script(script)\n    except Exception:\n        # The likely reason this fails is because: \"jQuery is not defined\"\n        activate_jquery(driver)  # It's a good thing we can define it here\n        driver.execute_script(script)", "code_tokens": "def safe_execute_script ( driver , script ) : try : driver . execute_script ( script ) except Exception : # The likely reason this fails is because: \"jQuery is not defined\" activate_jquery ( driver ) # It's a good thing we can define it here driver . execute_script ( script )", "docstring_tokens": "When executing a script that contains a jQuery command it s important that the jQuery library has been loaded first . This method will load jQuery if it wasn t already loaded .", "label": 0}, {"idx": "cosqa-train-10298", "doc": "python 3d array rotation", "code": "def create_rot2d(angle):\n    \"\"\"Create 2D rotation matrix\"\"\"\n    ca = math.cos(angle)\n    sa = math.sin(angle)\n    return np.array([[ca, -sa], [sa, ca]])", "code_tokens": "def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )", "docstring_tokens": "Create 2D rotation matrix", "label": 0}, {"idx": "cosqa-train-10299", "doc": "run ansible playbook from python with host pass as variable", "code": "def callPlaybook(self, playbook, ansibleArgs, wait=True, tags=[\"all\"]):\n        \"\"\"\n        Run a playbook.\n\n        :param playbook: An Ansible playbook to run.\n        :param ansibleArgs: Arguments to pass to the playbook.\n        :param wait: Wait for the play to finish if true.\n        :param tags: Control tags for the play.\n        \"\"\"\n        playbook = os.path.join(self.playbooks, playbook)  # Path to playbook being executed\n        verbosity = \"-vvvvv\" if logger.isEnabledFor(logging.DEBUG) else \"-v\"\n        command = [\"ansible-playbook\", verbosity, \"--tags\", \",\".join(tags), \"--extra-vars\"]\n        command.append(\" \".join([\"=\".join(i) for i in ansibleArgs.items()]))  # Arguments being passed to playbook\n        command.append(playbook)\n\n        logger.debug(\"Executing Ansible call `%s`\", \" \".join(command))\n        p = subprocess.Popen(command)\n        if wait:\n            p.communicate()\n            if p.returncode != 0:\n                # FIXME: parse error codes\n                raise RuntimeError(\"Ansible reported an error when executing playbook %s\" % playbook)", "code_tokens": "def callPlaybook ( self , playbook , ansibleArgs , wait = True , tags = [ \"all\" ] ) : playbook = os . path . join ( self . playbooks , playbook ) # Path to playbook being executed verbosity = \"-vvvvv\" if logger . isEnabledFor ( logging . DEBUG ) else \"-v\" command = [ \"ansible-playbook\" , verbosity , \"--tags\" , \",\" . join ( tags ) , \"--extra-vars\" ] command . append ( \" \" . join ( [ \"=\" . join ( i ) for i in ansibleArgs . items ( ) ] ) ) # Arguments being passed to playbook command . append ( playbook ) logger . debug ( \"Executing Ansible call `%s`\" , \" \" . join ( command ) ) p = subprocess . Popen ( command ) if wait : p . communicate ( ) if p . returncode != 0 : # FIXME: parse error codes raise RuntimeError ( \"Ansible reported an error when executing playbook %s\" % playbook )", "docstring_tokens": "Run a playbook .", "label": 1}, {"idx": "cosqa-train-10300", "doc": "python a list of all constants", "code": "def _get_all_constants():\n    \"\"\"\n    Get list of all uppercase, non-private globals (doesn't start with ``_``).\n\n    Returns:\n        list: Uppercase names defined in `globals()` (variables from this \\\n              module).\n    \"\"\"\n    return [\n        key for key in globals().keys()\n        if all([\n            not key.startswith(\"_\"),          # publicly accesible\n            key.upper() == key,               # uppercase\n            type(globals()[key]) in _ALLOWED  # and with type from _ALLOWED\n        ])\n    ]", "code_tokens": "def _get_all_constants ( ) : return [ key for key in globals ( ) . keys ( ) if all ( [ not key . startswith ( \"_\" ) , # publicly accesible key . upper ( ) == key , # uppercase type ( globals ( ) [ key ] ) in _ALLOWED # and with type from _ALLOWED ] ) ]", "docstring_tokens": "Get list of all uppercase non - private globals ( doesn t start with _ ) .", "label": 1}, {"idx": "cosqa-train-10301", "doc": "run python file in java using runtime", "code": "def test_python_java_rt():\n    \"\"\" Run Python test cases against Java runtime classes. \"\"\"\n    sub_env = {'PYTHONPATH': _build_dir()}\n\n    log.info('Executing Python unit tests (against Java runtime classes)...')\n    return jpyutil._execute_python_scripts(python_java_rt_tests,\n                                           env=sub_env)", "code_tokens": "def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )", "docstring_tokens": "Run Python test cases against Java runtime classes .", "label": 1}, {"idx": "cosqa-train-10302", "doc": "python access fillable fields in pdf", "code": "def security(self):\n        \"\"\"Print security object information for a pdf document\"\"\"\n        return {k: v for i in self.pdf.resolvedObjects.items() for k, v in i[1].items()}", "code_tokens": "def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "docstring_tokens": "Print security object information for a pdf document", "label": 0}, {"idx": "cosqa-train-10303", "doc": "run python funcntion for only x seconds", "code": "def set(self, f):\n        \"\"\"Call a function after a delay, unless another function is set\n        in the meantime.\"\"\"\n        self.stop()\n        self._create_timer(f)\n        self.start()", "code_tokens": "def set ( self , f ) : self . stop ( ) self . _create_timer ( f ) self . start ( )", "docstring_tokens": "Call a function after a delay unless another function is set in the meantime .", "label": 0}, {"idx": "cosqa-train-10304", "doc": "python access next item in a for loop from current iteration", "code": "def next(self):\n        \"\"\"Get the next value in the page.\"\"\"\n        item = six.next(self._item_iter)\n        result = self._item_to_value(self._parent, item)\n        # Since we've successfully got the next value from the\n        # iterator, we update the number of remaining.\n        self._remaining -= 1\n        return result", "code_tokens": "def next ( self ) : item = six . next ( self . _item_iter ) result = self . _item_to_value ( self . _parent , item ) # Since we've successfully got the next value from the # iterator, we update the number of remaining. self . _remaining -= 1 return result", "docstring_tokens": "Get the next value in the page .", "label": 0}, {"idx": "cosqa-train-10305", "doc": "run the python script without pytest", "code": "def test():  # pragma: no cover\n    \"\"\"Execute the unit tests on an installed copy of unyt.\n\n    Note that this function requires pytest to run. If pytest is not\n    installed this function will raise ImportError.\n    \"\"\"\n    import pytest\n    import os\n\n    pytest.main([os.path.dirname(os.path.abspath(__file__))])", "code_tokens": "def test ( ) : # pragma: no cover import pytest import os pytest . main ( [ os . path . dirname ( os . path . abspath ( __file__ ) ) ] )", "docstring_tokens": "Execute the unit tests on an installed copy of unyt .", "label": 0}, {"idx": "cosqa-train-10306", "doc": "python access object properties as dict", "code": "def _to_json(self):\n        \"\"\" Gets a dict of this object's properties so that it can be used to send a dump to the client \"\"\"\n        return dict(( (k, v) for k, v in self.__dict__.iteritems() if k != 'server'))", "code_tokens": "def _to_json ( self ) : return dict ( ( ( k , v ) for k , v in self . __dict__ . iteritems ( ) if k != 'server' ) )", "docstring_tokens": "Gets a dict of this object s properties so that it can be used to send a dump to the client", "label": 0}, {"idx": "cosqa-train-10307", "doc": "running a def a specified amount of time python 3", "code": "def seconds(num):\n    \"\"\"\n    Pause for this many seconds\n    \"\"\"\n    now = pytime.time()\n    end = now + num\n    until(end)", "code_tokens": "def seconds ( num ) : now = pytime . time ( ) end = now + num until ( end )", "docstring_tokens": "Pause for this many seconds", "label": 1}, {"idx": "cosqa-train-10308", "doc": "python access second element of each array", "code": "def A(*a):\n    \"\"\"convert iterable object into numpy array\"\"\"\n    return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "code_tokens": "def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]", "docstring_tokens": "convert iterable object into numpy array", "label": 0}, {"idx": "cosqa-train-10309", "doc": "running python by code block on spyder", "code": "def test():        \n    \"\"\"Local test.\"\"\"\n    from spyder.utils.qthelpers import qapplication\n    app = qapplication()\n    dlg = ProjectDialog(None)\n    dlg.show()\n    sys.exit(app.exec_())", "code_tokens": "def test ( ) : from spyder . utils . qthelpers import qapplication app = qapplication ( ) dlg = ProjectDialog ( None ) dlg . show ( ) sys . exit ( app . exec_ ( ) )", "docstring_tokens": "Local test .", "label": 1}, {"idx": "cosqa-train-10310", "doc": "python active window title", "code": "def title(self):\n        \"\"\" The title of this window \"\"\"\n        with switch_window(self._browser, self.name):\n            return self._browser.title", "code_tokens": "def title ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . title", "docstring_tokens": "The title of this window", "label": 1}, {"idx": "cosqa-train-10311", "doc": "s3 boto3 python create object", "code": "def get_key(self, key, bucket_name=None):\n        \"\"\"\n        Returns a boto3.s3.Object\n\n        :param key: the path to the key\n        :type key: str\n        :param bucket_name: the name of the bucket\n        :type bucket_name: str\n        \"\"\"\n        if not bucket_name:\n            (bucket_name, key) = self.parse_s3_url(key)\n\n        obj = self.get_resource_type('s3').Object(bucket_name, key)\n        obj.load()\n        return obj", "code_tokens": "def get_key ( self , key , bucket_name = None ) : if not bucket_name : ( bucket_name , key ) = self . parse_s3_url ( key ) obj = self . get_resource_type ( 's3' ) . Object ( bucket_name , key ) obj . load ( ) return obj", "docstring_tokens": "Returns a boto3 . s3 . Object", "label": 0}, {"idx": "cosqa-train-10312", "doc": "python add a colormap width", "code": "def add_matplotlib_cmap(cm, name=None):\n    \"\"\"Add a matplotlib colormap.\"\"\"\n    global cmaps\n    cmap = matplotlib_to_ginga_cmap(cm, name=name)\n    cmaps[cmap.name] = cmap", "code_tokens": "def add_matplotlib_cmap ( cm , name = None ) : global cmaps cmap = matplotlib_to_ginga_cmap ( cm , name = name ) cmaps [ cmap . name ] = cmap", "docstring_tokens": "Add a matplotlib colormap .", "label": 1}, {"idx": "cosqa-train-10313", "doc": "save http get to file python", "code": "def download_file(save_path, file_url):\n    \"\"\" Download file from http url link \"\"\"\n\n    r = requests.get(file_url)  # create HTTP response object\n\n    with open(save_path, 'wb') as f:\n        f.write(r.content)\n\n    return save_path", "code_tokens": "def download_file ( save_path , file_url ) : r = requests . get ( file_url ) # create HTTP response object with open ( save_path , 'wb' ) as f : f . write ( r . content ) return save_path", "docstring_tokens": "Download file from http url link", "label": 1}, {"idx": "cosqa-train-10314", "doc": "python add boolean to string", "code": "def _encode_bool(name, value, dummy0, dummy1):\n    \"\"\"Encode a python boolean (True/False).\"\"\"\n    return b\"\\x08\" + name + (value and b\"\\x01\" or b\"\\x00\")", "code_tokens": "def _encode_bool ( name , value , dummy0 , dummy1 ) : return b\"\\x08\" + name + ( value and b\"\\x01\" or b\"\\x00\" )", "docstring_tokens": "Encode a python boolean ( True / False ) .", "label": 0}, {"idx": "cosqa-train-10315", "doc": "save numpy data to json python", "code": "def save_json(object, handle, indent=2):\n    \"\"\"Save object as json on CNS.\"\"\"\n    obj_json = json.dumps(object, indent=indent, cls=NumpyJSONEncoder)\n    handle.write(obj_json)", "code_tokens": "def save_json ( object , handle , indent = 2 ) : obj_json = json . dumps ( object , indent = indent , cls = NumpyJSONEncoder ) handle . write ( obj_json )", "docstring_tokens": "Save object as json on CNS .", "label": 0}, {"idx": "cosqa-train-10316", "doc": "python add items to iterable object", "code": "def extend(self, iterable):\n        \"\"\"Extend the list by appending all the items in the given list.\"\"\"\n        return super(Collection, self).extend(\n            self._ensure_iterable_is_valid(iterable))", "code_tokens": "def extend ( self , iterable ) : return super ( Collection , self ) . extend ( self . _ensure_iterable_is_valid ( iterable ) )", "docstring_tokens": "Extend the list by appending all the items in the given list .", "label": 1}, {"idx": "cosqa-train-10317", "doc": "save python graphviz as jpeg", "code": "def _text_to_graphiz(self, text):\n        \"\"\"create a graphviz graph from text\"\"\"\n        dot = Source(text, format='svg')\n        return dot.pipe().decode('utf-8')", "code_tokens": "def _text_to_graphiz ( self , text ) : dot = Source ( text , format = 'svg' ) return dot . pipe ( ) . decode ( 'utf-8' )", "docstring_tokens": "create a graphviz graph from text", "label": 1}, {"idx": "cosqa-train-10318", "doc": "python add path to modle", "code": "def _load_mod_ui_libraries(self, path):\n        \"\"\"\n        :param Path path:\n        \"\"\"\n        path = path / Path('mod')\n        sys.path.append(str(path))", "code_tokens": "def _load_mod_ui_libraries ( self , path ) : path = path / Path ( 'mod' ) sys . path . append ( str ( path ) )", "docstring_tokens": ": param Path path :", "label": 1}, {"idx": "cosqa-train-10319", "doc": "scala equivileant of python dictionary", "code": "def get_python_dict(scala_map):\n    \"\"\"Return a dict from entries in a scala.collection.immutable.Map\"\"\"\n    python_dict = {}\n    keys = get_python_list(scala_map.keys().toList())\n    for key in keys:\n        python_dict[key] = scala_map.apply(key)\n    return python_dict", "code_tokens": "def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict", "docstring_tokens": "Return a dict from entries in a scala . collection . immutable . Map", "label": 1}, {"idx": "cosqa-train-10320", "doc": "python add property from kwargs", "code": "def update(self, **kwargs):\n    \"\"\"Creates or updates a property for the instance for each parameter.\"\"\"\n    for key, value in kwargs.items():\n      setattr(self, key, value)", "code_tokens": "def update ( self , * * kwargs ) : for key , value in kwargs . items ( ) : setattr ( self , key , value )", "docstring_tokens": "Creates or updates a property for the instance for each parameter .", "label": 1}, {"idx": "cosqa-train-10321", "doc": "screen height and width python frame", "code": "def get_screen_resolution(self):\n        \"\"\"Return the screen resolution of the primary screen.\"\"\"\n        widget = QDesktopWidget()\n        geometry = widget.availableGeometry(widget.primaryScreen())\n        return geometry.width(), geometry.height()", "code_tokens": "def get_screen_resolution ( self ) : widget = QDesktopWidget ( ) geometry = widget . availableGeometry ( widget . primaryScreen ( ) ) return geometry . width ( ) , geometry . height ( )", "docstring_tokens": "Return the screen resolution of the primary screen .", "label": 1}, {"idx": "cosqa-train-10322", "doc": "python adjacency matrix dict", "code": "def get_adjacent_matrix(self):\n        \"\"\"Get adjacency matrix.\n\n        Returns:\n            :param adj: adjacency matrix\n            :type adj: np.ndarray\n        \"\"\"\n        edges = self.edges\n        num_edges = len(edges) + 1\n        adj = np.zeros([num_edges, num_edges])\n\n        for k in range(num_edges - 1):\n            adj[edges[k].L, edges[k].R] = 1\n            adj[edges[k].R, edges[k].L] = 1\n\n        return adj", "code_tokens": "def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj", "docstring_tokens": "Get adjacency matrix .", "label": 1}, {"idx": "cosqa-train-10323", "doc": "select 50 items randomnly from list python", "code": "def get_randomized_guid_sample(self, item_count):\n        \"\"\" Fetch a subset of randomzied GUIDs from the whitelist \"\"\"\n        dataset = self.get_whitelist()\n        random.shuffle(dataset)\n        return dataset[:item_count]", "code_tokens": "def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]", "docstring_tokens": "Fetch a subset of randomzied GUIDs from the whitelist", "label": 1}, {"idx": "cosqa-train-10324", "doc": "python adjust data to normal distribution", "code": "def normalize(data):\n    \"\"\"Normalize the data to be in the [0, 1] range.\n\n    :param data:\n    :return: normalized data\n    \"\"\"\n    out_data = data.copy()\n\n    for i, sample in enumerate(out_data):\n        out_data[i] /= sum(out_data[i])\n\n    return out_data", "code_tokens": "def normalize ( data ) : out_data = data . copy ( ) for i , sample in enumerate ( out_data ) : out_data [ i ] /= sum ( out_data [ i ] ) return out_data", "docstring_tokens": "Normalize the data to be in the [ 0 1 ] range .", "label": 1}, {"idx": "cosqa-train-10325", "doc": "select elements from a list, then delete these elements in the original list python", "code": "def remove_elements(target, indices):\n    \"\"\"Remove multiple elements from a list and return result.\n    This implementation is faster than the alternative below.\n    Also note the creation of a new list to avoid altering the\n    original. We don't have any current use for the original\n    intact list, but may in the future...\"\"\"\n\n    copied = list(target)\n\n    for index in reversed(indices):\n        del copied[index]\n    return copied", "code_tokens": "def remove_elements ( target , indices ) : copied = list ( target ) for index in reversed ( indices ) : del copied [ index ] return copied", "docstring_tokens": "Remove multiple elements from a list and return result . This implementation is faster than the alternative below . Also note the creation of a new list to avoid altering the original . We don t have any current use for the original intact list but may in the future ...", "label": 1}, {"idx": "cosqa-train-10326", "doc": "python agg max of one column, return value for that", "code": "def get_max(qs, field):\n    \"\"\"\n    get max for queryset.\n\n    qs: queryset\n    field: The field name to max.\n    \"\"\"\n    max_field = '%s__max' % field\n    num = qs.aggregate(Max(field))[max_field]\n    return num if num else 0", "code_tokens": "def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0", "docstring_tokens": "get max for queryset .", "label": 0}, {"idx": "cosqa-train-10327", "doc": "select last row in python", "code": "def get_last(self, table=None):\n        \"\"\"Just the last entry.\"\"\"\n        if table is None: table = self.main_table\n        query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table\n        return self.own_cursor.execute(query).fetchone()", "code_tokens": "def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )", "docstring_tokens": "Just the last entry .", "label": 0}, {"idx": "cosqa-train-10328", "doc": "python alembic get table", "code": "def find_model_by_table_name(name):\n    \"\"\"Find a model reference by its table name\"\"\"\n\n    for model in ModelBase._decl_class_registry.values():\n        if hasattr(model, '__table__') and model.__table__.fullname == name:\n            return model\n    return None", "code_tokens": "def find_model_by_table_name ( name ) : for model in ModelBase . _decl_class_registry . values ( ) : if hasattr ( model , '__table__' ) and model . __table__ . fullname == name : return model return None", "docstring_tokens": "Find a model reference by its table name", "label": 1}, {"idx": "cosqa-train-10329", "doc": "select values that are not null python", "code": "def selectnotnone(table, field, complement=False):\n    \"\"\"Select rows where the given field is not `None`.\"\"\"\n\n    return select(table, field, lambda v: v is not None,\n                  complement=complement)", "code_tokens": "def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )", "docstring_tokens": "Select rows where the given field is not None .", "label": 0}, {"idx": "cosqa-train-10330", "doc": "python and bounding box column in pdf", "code": "def calculate_bounding_box_from_image(im, curr_page):\n    \"\"\"This function uses a PIL routine to get the bounding box of the rendered\n    image.\"\"\"\n    xMax, y_max = im.size\n    bounding_box = im.getbbox() # note this uses ltrb convention\n    if not bounding_box:\n        #print(\"\\nWarning: could not calculate a bounding box for this page.\"\n        #      \"\\nAn empty page is assumed.\", file=sys.stderr)\n        bounding_box = (xMax/2, y_max/2, xMax/2, y_max/2)\n\n    bounding_box = list(bounding_box) # make temporarily mutable\n\n    # Compensate for reversal of the image y convention versus PDF.\n    bounding_box[1] = y_max - bounding_box[1]\n    bounding_box[3] = y_max - bounding_box[3]\n\n    full_page_box = curr_page.mediaBox # should have been set already to chosen box\n\n    # Convert pixel units to PDF's bp units.\n    convert_x = float(full_page_box.getUpperRight_x()\n                     - full_page_box.getLowerLeft_x()) / xMax\n    convert_y = float(full_page_box.getUpperRight_y()\n                     - full_page_box.getLowerLeft_y()) / y_max\n\n    # Get final box; note conversion to lower-left point, upper-right point format.\n    final_box = [\n        bounding_box[0] * convert_x,\n        bounding_box[3] * convert_y,\n        bounding_box[2] * convert_x,\n        bounding_box[1] * convert_y]\n\n    return final_box", "code_tokens": "def calculate_bounding_box_from_image ( im , curr_page ) : xMax , y_max = im . size bounding_box = im . getbbox ( ) # note this uses ltrb convention if not bounding_box : #print(\"\\nWarning: could not calculate a bounding box for this page.\" #      \"\\nAn empty page is assumed.\", file=sys.stderr) bounding_box = ( xMax / 2 , y_max / 2 , xMax / 2 , y_max / 2 ) bounding_box = list ( bounding_box ) # make temporarily mutable # Compensate for reversal of the image y convention versus PDF. bounding_box [ 1 ] = y_max - bounding_box [ 1 ] bounding_box [ 3 ] = y_max - bounding_box [ 3 ] full_page_box = curr_page . mediaBox # should have been set already to chosen box # Convert pixel units to PDF's bp units. convert_x = float ( full_page_box . getUpperRight_x ( ) - full_page_box . getLowerLeft_x ( ) ) / xMax convert_y = float ( full_page_box . getUpperRight_y ( ) - full_page_box . getLowerLeft_y ( ) ) / y_max # Get final box; note conversion to lower-left point, upper-right point format. final_box = [ bounding_box [ 0 ] * convert_x , bounding_box [ 3 ] * convert_y , bounding_box [ 2 ] * convert_x , bounding_box [ 1 ] * convert_y ] return final_box", "docstring_tokens": "This function uses a PIL routine to get the bounding box of the rendered image .", "label": 1}, {"idx": "cosqa-train-10331", "doc": "python angle using 3 points", "code": "def angle(x0, y0, x1, y1):\n    \"\"\" Returns the angle between two points.\n    \"\"\"\n    return degrees(atan2(y1-y0, x1-x0))", "code_tokens": "def angle ( x0 , y0 , x1 , y1 ) : return degrees ( atan2 ( y1 - y0 , x1 - x0 ) )", "docstring_tokens": "Returns the angle between two points .", "label": 0}, {"idx": "cosqa-train-10332", "doc": "serving a python page as an index", "code": "def server(request):\n    \"\"\"\n    Respond to requests for the server's primary web page.\n    \"\"\"\n    return direct_to_template(\n        request,\n        'server/index.html',\n        {'user_url': getViewURL(request, idPage),\n         'server_xrds_url': getViewURL(request, idpXrds),\n         })", "code_tokens": "def server ( request ) : return direct_to_template ( request , 'server/index.html' , { 'user_url' : getViewURL ( request , idPage ) , 'server_xrds_url' : getViewURL ( request , idpXrds ) , } )", "docstring_tokens": "Respond to requests for the server s primary web page .", "label": 1}, {"idx": "cosqa-train-10333", "doc": "python ansi color windows", "code": "def ansi(color, text):\n    \"\"\"Wrap text in an ansi escape sequence\"\"\"\n    code = COLOR_CODES[color]\n    return '\\033[1;{0}m{1}{2}'.format(code, text, RESET_TERM)", "code_tokens": "def ansi ( color , text ) : code = COLOR_CODES [ color ] return '\\033[1;{0}m{1}{2}' . format ( code , text , RESET_TERM )", "docstring_tokens": "Wrap text in an ansi escape sequence", "label": 0}, {"idx": "cosqa-train-10334", "doc": "set a pixel python", "code": "def setPixel(self, x, y, color):\n        \"\"\"Set the pixel at (x,y) to the integers in sequence 'color'.\"\"\"\n        return _fitz.Pixmap_setPixel(self, x, y, color)", "code_tokens": "def setPixel ( self , x , y , color ) : return _fitz . Pixmap_setPixel ( self , x , y , color )", "docstring_tokens": "Set the pixel at ( x y ) to the integers in sequence color .", "label": 1}, {"idx": "cosqa-train-10335", "doc": "python append prefix to each line in string", "code": "def uncomment_line(line, prefix):\n    \"\"\"Remove prefix (and space) from line\"\"\"\n    if not prefix:\n        return line\n    if line.startswith(prefix + ' '):\n        return line[len(prefix) + 1:]\n    if line.startswith(prefix):\n        return line[len(prefix):]\n    return line", "code_tokens": "def uncomment_line ( line , prefix ) : if not prefix : return line if line . startswith ( prefix + ' ' ) : return line [ len ( prefix ) + 1 : ] if line . startswith ( prefix ) : return line [ len ( prefix ) : ] return line", "docstring_tokens": "Remove prefix ( and space ) from line", "label": 0}, {"idx": "cosqa-train-10336", "doc": "set axis limits example python", "code": "def _set_axis_limits(self, which, lims, d, scale, reverse=False):\n        \"\"\"Private method for setting axis limits.\n\n        Sets the axis limits on each axis for an individual plot.\n\n        Args:\n            which (str): The indicator of which part of the plots\n                to adjust. This currently handles `x` and `y`.\n            lims (len-2 list of floats): The limits for the axis.\n            d (float): Amount to increment by between the limits.\n            scale (str): Scale of the axis. Either `log` or `lin`.\n            reverse (bool, optional): If True, reverse the axis tick marks. Default is False.\n\n        \"\"\"\n        setattr(self.limits, which + 'lims', lims)\n        setattr(self.limits, 'd' + which, d)\n        setattr(self.limits, which + 'scale', scale)\n\n        if reverse:\n            setattr(self.limits, 'reverse_' + which + '_axis', True)\n        return", "code_tokens": "def _set_axis_limits ( self , which , lims , d , scale , reverse = False ) : setattr ( self . limits , which + 'lims' , lims ) setattr ( self . limits , 'd' + which , d ) setattr ( self . limits , which + 'scale' , scale ) if reverse : setattr ( self . limits , 'reverse_' + which + '_axis' , True ) return", "docstring_tokens": "Private method for setting axis limits .", "label": 1}, {"idx": "cosqa-train-10337", "doc": "python append table from another table", "code": "def __add__(self, other):\n        \"\"\"Merges two with identical columns.\"\"\"\n\n        new_table = copy.copy(self)\n        for row in other:\n            new_table.Append(row)\n\n        return new_table", "code_tokens": "def __add__ ( self , other ) : new_table = copy . copy ( self ) for row in other : new_table . Append ( row ) return new_table", "docstring_tokens": "Merges two with identical columns .", "label": 1}, {"idx": "cosqa-train-10338", "doc": "set call on iterable python", "code": "def map(cls, iterable, func, *a, **kw):\n    \"\"\"\n    Iterable-first replacement of Python's built-in `map()` function.\n    \"\"\"\n\n    return cls(func(x, *a, **kw) for x in iterable)", "code_tokens": "def map ( cls , iterable , func , * a , * * kw ) : return cls ( func ( x , * a , * * kw ) for x in iterable )", "docstring_tokens": "Iterable - first replacement of Python s built - in map () function .", "label": 1}, {"idx": "cosqa-train-10339", "doc": "python apply function to data frame", "code": "def transform(self, df):\n        \"\"\"\n        Transforms a DataFrame in place. Computes all outputs of the DataFrame.\n\n        Args:\n            df (pandas.DataFrame): DataFrame to transform.\n        \"\"\"\n        for name, function in self.outputs:\n            df[name] = function(df)", "code_tokens": "def transform ( self , df ) : for name , function in self . outputs : df [ name ] = function ( df )", "docstring_tokens": "Transforms a DataFrame in place . Computes all outputs of the DataFrame .", "label": 1}, {"idx": "cosqa-train-10340", "doc": "set content type python requests", "code": "def content_type(self, data):\n        \"\"\"The Content-Type header value for this request.\"\"\"\n        self._content_type = str(data)\n        self.add_header('Content-Type', str(data))", "code_tokens": "def content_type ( self , data ) : self . _content_type = str ( data ) self . add_header ( 'Content-Type' , str ( data ) )", "docstring_tokens": "The Content - Type header value for this request .", "label": 0}, {"idx": "cosqa-train-10341", "doc": "python apply iterate the 1st row twice", "code": "def peekiter(iterable):\n    \"\"\"Return first row and also iterable with same items as original\"\"\"\n    it = iter(iterable)\n    one = next(it)\n\n    def gen():\n        \"\"\"Generator that returns first and proxy other items from source\"\"\"\n        yield one\n        while True:\n            yield next(it)\n    return (one, gen())", "code_tokens": "def peekiter ( iterable ) : it = iter ( iterable ) one = next ( it ) def gen ( ) : \"\"\"Generator that returns first and proxy other items from source\"\"\" yield one while True : yield next ( it ) return ( one , gen ( ) )", "docstring_tokens": "Return first row and also iterable with same items as original", "label": 1}, {"idx": "cosqa-train-10342", "doc": "set date to 1st of the current month python", "code": "def monthly(date=datetime.date.today()):\n    \"\"\"\n    Take a date object and return the first day of the month.\n    \"\"\"\n    return datetime.date(date.year, date.month, 1)", "code_tokens": "def monthly ( date = datetime . date . today ( ) ) : return datetime . date ( date . year , date . month , 1 )", "docstring_tokens": "Take a date object and return the first day of the month .", "label": 1}, {"idx": "cosqa-train-10343", "doc": "python argparse how to check if default is used", "code": "def set_default(self, section, option,\n                    default):\n        \"\"\"If the option did not exist, create a default value.\"\"\"\n        if not self.parser.has_option(section, option):\n            self.parser.set(section, option, default)", "code_tokens": "def set_default ( self , section , option , default ) : if not self . parser . has_option ( section , option ) : self . parser . set ( section , option , default )", "docstring_tokens": "If the option did not exist create a default value .", "label": 1}, {"idx": "cosqa-train-10344", "doc": "set default arg to a value def python", "code": "def arg_default(*args, **kwargs):\n    \"\"\"Return default argument value as given by argparse's add_argument().\n\n    The argument is passed through a mocked-up argument parser. This way, we\n    get default parameters even if the feature is called directly and not\n    through the CLI.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(*args, **kwargs)\n    args = vars(parser.parse_args([]))\n    _, default = args.popitem()\n    return default", "code_tokens": "def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default", "docstring_tokens": "Return default argument value as given by argparse s add_argument () .", "label": 1}, {"idx": "cosqa-train-10345", "doc": "python argparse subparser type of subparser", "code": "def set_subparsers_args(self, *args, **kwargs):\n        \"\"\"\n        Sets args and kwargs that are passed when creating a subparsers group\n        in an argparse.ArgumentParser i.e. when calling\n        argparser.ArgumentParser.add_subparsers\n        \"\"\"\n        self.subparsers_args = args\n        self.subparsers_kwargs = kwargs", "code_tokens": "def set_subparsers_args ( self , * args , * * kwargs ) : self . subparsers_args = args self . subparsers_kwargs = kwargs", "docstring_tokens": "Sets args and kwargs that are passed when creating a subparsers group in an argparse . ArgumentParser i . e . when calling argparser . ArgumentParser . add_subparsers", "label": 1}, {"idx": "cosqa-train-10346", "doc": "set output activation function different from input python", "code": "def softplus(attrs, inputs, proto_obj):\n    \"\"\"Applies the sofplus activation function element-wise to the input.\"\"\"\n    new_attrs = translation_utils._add_extra_attributes(attrs, {'act_type' : 'softrelu'})\n    return 'Activation', new_attrs, inputs", "code_tokens": "def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs", "docstring_tokens": "Applies the sofplus activation function element - wise to the input .", "label": 1}, {"idx": "cosqa-train-10347", "doc": "python argparse test default", "code": "def cli_parse(parser):\n    \"\"\"Add method specific options to CLI parser.\n\n    Parameters\n    ----------\n    parser : argparse object\n\n    Returns\n    ----------\n    Updated argparse object\n    \"\"\"\n    parser.add_argument('-n', '--samples', type=int, required=True,\n                        help='Number of Samples')\n    return parser", "code_tokens": "def cli_parse ( parser ) : parser . add_argument ( '-n' , '--samples' , type = int , required = True , help = 'Number of Samples' ) return parser", "docstring_tokens": "Add method specific options to CLI parser . Parameters ---------- parser : argparse object Returns ---------- Updated argparse object", "label": 0}, {"idx": "cosqa-train-10348", "doc": "set python default proxy", "code": "def enable_proxy(self, host, port):\n        \"\"\"Enable a default web proxy\"\"\"\n\n        self.proxy = [host, _number(port)]\n        self.proxy_enabled = True", "code_tokens": "def enable_proxy ( self , host , port ) : self . proxy = [ host , _number ( port ) ] self . proxy_enabled = True", "docstring_tokens": "Enable a default web proxy", "label": 1}, {"idx": "cosqa-train-10349", "doc": "python argsparse default value", "code": "def args_update(self):\n        \"\"\"Update the argparser namespace with any data from configuration file.\"\"\"\n        for key, value in self._config_data.items():\n            setattr(self._default_args, key, value)", "code_tokens": "def args_update ( self ) : for key , value in self . _config_data . items ( ) : setattr ( self . _default_args , key , value )", "docstring_tokens": "Update the argparser namespace with any data from configuration file .", "label": 1}, {"idx": "cosqa-train-10350", "doc": "python array index of nearest", "code": "def find_nearest_index(arr, value):\n    \"\"\"For a given value, the function finds the nearest value\n    in the array and returns its index.\"\"\"\n    arr = np.array(arr)\n    index = (abs(arr-value)).argmin()\n    return index", "code_tokens": "def find_nearest_index ( arr , value ) : arr = np . array ( arr ) index = ( abs ( arr - value ) ) . argmin ( ) return index", "docstring_tokens": "For a given value the function finds the nearest value in the array and returns its index .", "label": 1}, {"idx": "cosqa-train-10351", "doc": "set s axis limits in python matplotlib", "code": "def _set_axis_limits(self, which, lims, d, scale, reverse=False):\n        \"\"\"Private method for setting axis limits.\n\n        Sets the axis limits on each axis for an individual plot.\n\n        Args:\n            which (str): The indicator of which part of the plots\n                to adjust. This currently handles `x` and `y`.\n            lims (len-2 list of floats): The limits for the axis.\n            d (float): Amount to increment by between the limits.\n            scale (str): Scale of the axis. Either `log` or `lin`.\n            reverse (bool, optional): If True, reverse the axis tick marks. Default is False.\n\n        \"\"\"\n        setattr(self.limits, which + 'lims', lims)\n        setattr(self.limits, 'd' + which, d)\n        setattr(self.limits, which + 'scale', scale)\n\n        if reverse:\n            setattr(self.limits, 'reverse_' + which + '_axis', True)\n        return", "code_tokens": "def _set_axis_limits ( self , which , lims , d , scale , reverse = False ) : setattr ( self . limits , which + 'lims' , lims ) setattr ( self . limits , 'd' + which , d ) setattr ( self . limits , which + 'scale' , scale ) if reverse : setattr ( self . limits , 'reverse_' + which + '_axis' , True ) return", "docstring_tokens": "Private method for setting axis limits .", "label": 1}, {"idx": "cosqa-train-10352", "doc": "python array map to a dict", "code": "def to_dicts(recarray):\n    \"\"\"convert record array to a dictionaries\"\"\"\n    for rec in recarray:\n        yield dict(zip(recarray.dtype.names, rec.tolist()))", "code_tokens": "def to_dicts ( recarray ) : for rec in recarray : yield dict ( zip ( recarray . dtype . names , rec . tolist ( ) ) )", "docstring_tokens": "convert record array to a dictionaries", "label": 1}, {"idx": "cosqa-train-10353", "doc": "set varaible to line number in python", "code": "def mark(self, lineno, count=1):\n        \"\"\"Mark a given source line as executed count times.\n\n        Multiple calls to mark for the same lineno add up.\n        \"\"\"\n        self.sourcelines[lineno] = self.sourcelines.get(lineno, 0) + count", "code_tokens": "def mark ( self , lineno , count = 1 ) : self . sourcelines [ lineno ] = self . sourcelines . get ( lineno , 0 ) + count", "docstring_tokens": "Mark a given source line as executed count times .", "label": 1}, {"idx": "cosqa-train-10354", "doc": "python array mask matlab", "code": "def asMaskedArray(self):\n        \"\"\" Creates converts to a masked array\n        \"\"\"\n        return ma.masked_array(data=self.data, mask=self.mask, fill_value=self.fill_value)", "code_tokens": "def asMaskedArray ( self ) : return ma . masked_array ( data = self . data , mask = self . mask , fill_value = self . fill_value )", "docstring_tokens": "Creates converts to a masked array", "label": 0}, {"idx": "cosqa-train-10355", "doc": "set window title python", "code": "def title(msg):\n    \"\"\"Sets the title of the console window.\"\"\"\n    if sys.platform.startswith(\"win\"):\n        ctypes.windll.kernel32.SetConsoleTitleW(tounicode(msg))", "code_tokens": "def title ( msg ) : if sys . platform . startswith ( \"win\" ) : ctypes . windll . kernel32 . SetConsoleTitleW ( tounicode ( msg ) )", "docstring_tokens": "Sets the title of the console window .", "label": 0}, {"idx": "cosqa-train-10356", "doc": "python array shape detection", "code": "def out_shape_from_array(arr):\n    \"\"\"Get the output shape from an array.\"\"\"\n    arr = np.asarray(arr)\n    if arr.ndim == 1:\n        return arr.shape\n    else:\n        return (arr.shape[1],)", "code_tokens": "def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "docstring_tokens": "Get the output shape from an array .", "label": 1}, {"idx": "cosqa-train-10357", "doc": "shortest distance to line python", "code": "def distance_to_line(a, b, p):\n    \"\"\"Closest distance between a line segment and a point\n\n    Args:\n        a ([float, float]): x and y coordinates. Line start\n        b ([float, float]): x and y coordinates. Line end\n        p ([float, float]): x and y coordinates. Point to compute the distance\n    Returns:\n        float\n    \"\"\"\n    return distance(closest_point(a, b, p), p)", "code_tokens": "def distance_to_line ( a , b , p ) : return distance ( closest_point ( a , b , p ) , p )", "docstring_tokens": "Closest distance between a line segment and a point", "label": 1}, {"idx": "cosqa-train-10358", "doc": "python array to dic", "code": "def to_dicts(recarray):\n    \"\"\"convert record array to a dictionaries\"\"\"\n    for rec in recarray:\n        yield dict(zip(recarray.dtype.names, rec.tolist()))", "code_tokens": "def to_dicts ( recarray ) : for rec in recarray : yield dict ( zip ( recarray . dtype . names , rec . tolist ( ) ) )", "docstring_tokens": "convert record array to a dictionaries", "label": 1}, {"idx": "cosqa-train-10359", "doc": "python array to numpy array pickling is disabled", "code": "def _openResources(self):\n        \"\"\" Uses numpy.load to open the underlying file\n        \"\"\"\n        arr = np.load(self._fileName, allow_pickle=ALLOW_PICKLE)\n        check_is_an_array(arr)\n        self._array = arr", "code_tokens": "def _openResources ( self ) : arr = np . load ( self . _fileName , allow_pickle = ALLOW_PICKLE ) check_is_an_array ( arr ) self . _array = arr", "docstring_tokens": "Uses numpy . load to open the underlying file", "label": 0}, {"idx": "cosqa-train-10360", "doc": "show python interactive window not there", "code": "def page_guiref(arg_s=None):\n    \"\"\"Show a basic reference about the GUI Console.\"\"\"\n    from IPython.core import page\n    page.page(gui_reference, auto_html=True)", "code_tokens": "def page_guiref ( arg_s = None ) : from IPython . core import page page . page ( gui_reference , auto_html = True )", "docstring_tokens": "Show a basic reference about the GUI Console .", "label": 0}, {"idx": "cosqa-train-10361", "doc": "python array with one dimension", "code": "def _transform_triple_numpy(x):\n    \"\"\"Transform triple index into a 1-D numpy array.\"\"\"\n    return np.array([x.head, x.relation, x.tail], dtype=np.int64)", "code_tokens": "def _transform_triple_numpy ( x ) : return np . array ( [ x . head , x . relation , x . tail ] , dtype = np . int64 )", "docstring_tokens": "Transform triple index into a 1 - D numpy array .", "label": 0}, {"idx": "cosqa-train-10362", "doc": "shuffle then unshuffle data python", "code": "def _shuffle(data, idx):\n    \"\"\"Shuffle the data.\"\"\"\n    shuffle_data = []\n\n    for idx_k, idx_v in data:\n        shuffle_data.append((idx_k, mx.ndarray.array(idx_v.asnumpy()[idx], idx_v.context)))\n\n    return shuffle_data", "code_tokens": "def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data", "docstring_tokens": "Shuffle the data .", "label": 0}, {"idx": "cosqa-train-10363", "doc": "python ask default intent", "code": "def yn_prompt(msg, default=True):\n    \"\"\"\n    Prompts the user for yes or no.\n    \"\"\"\n    ret = custom_prompt(msg, [\"y\", \"n\"], \"y\" if default else \"n\")\n    if ret == \"y\":\n        return True\n    return False", "code_tokens": "def yn_prompt ( msg , default = True ) : ret = custom_prompt ( msg , [ \"y\" , \"n\" ] , \"y\" if default else \"n\" ) if ret == \"y\" : return True return False", "docstring_tokens": "Prompts the user for yes or no .", "label": 1}, {"idx": "cosqa-train-10364", "doc": "single color format string python", "code": "def colorize(string, color, *args, **kwargs):\n    \"\"\"\n    Implements string formatting along with color specified in colorama.Fore\n    \"\"\"\n    string = string.format(*args, **kwargs)\n    return color + string + colorama.Fore.RESET", "code_tokens": "def colorize ( string , color , * args , * * kwargs ) : string = string . format ( * args , * * kwargs ) return color + string + colorama . Fore . RESET", "docstring_tokens": "Implements string formatting along with color specified in colorama . Fore", "label": 0}, {"idx": "cosqa-train-10365", "doc": "python ask player to play again", "code": "def toggle_pause(self):\n        \"\"\"Toggle pause mode\"\"\"\n        self.controller.playing = not self.controller.playing\n        self.music.toggle_pause()", "code_tokens": "def toggle_pause ( self ) : self . controller . playing = not self . controller . playing self . music . toggle_pause ( )", "docstring_tokens": "Toggle pause mode", "label": 0}, {"idx": "cosqa-train-10366", "doc": "size of one pixel python", "code": "def get_combined_size(tiles):\n    \"\"\"Calculate combined size of tiles.\"\"\"\n    # TODO: Refactor calculating layout to avoid repetition.\n    columns, rows = calc_columns_rows(len(tiles))\n    tile_size = tiles[0].image.size\n    return (tile_size[0] * columns, tile_size[1] * rows)", "code_tokens": "def get_combined_size ( tiles ) : # TODO: Refactor calculating layout to avoid repetition. columns , rows = calc_columns_rows ( len ( tiles ) ) tile_size = tiles [ 0 ] . image . size return ( tile_size [ 0 ] * columns , tile_size [ 1 ] * rows )", "docstring_tokens": "Calculate combined size of tiles .", "label": 1}, {"idx": "cosqa-train-10367", "doc": "python ask user to exit", "code": "def exit(self):\n        \"\"\"Handle interactive exit.\n\n        This method calls the ask_exit callback.\"\"\"\n        if self.confirm_exit:\n            if self.ask_yes_no('Do you really want to exit ([y]/n)?','y'):\n                self.ask_exit()\n        else:\n            self.ask_exit()", "code_tokens": "def exit ( self ) : if self . confirm_exit : if self . ask_yes_no ( 'Do you really want to exit ([y]/n)?' , 'y' ) : self . ask_exit ( ) else : self . ask_exit ( )", "docstring_tokens": "Handle interactive exit .", "label": 0}, {"idx": "cosqa-train-10368", "doc": "skip to the end of a line index python", "code": "def _skip_frame(self):\n        \"\"\"Skip a single frame from the trajectory\"\"\"\n        size = self.read_size()\n        for i in range(size+1):\n            line = self._f.readline()\n            if len(line) == 0:\n                raise StopIteration", "code_tokens": "def _skip_frame ( self ) : size = self . read_size ( ) for i in range ( size + 1 ) : line = self . _f . readline ( ) if len ( line ) == 0 : raise StopIteration", "docstring_tokens": "Skip a single frame from the trajectory", "label": 1}, {"idx": "cosqa-train-10369", "doc": "python assert is iterable", "code": "def assert_iter(**kw):\n    \"\"\"\n    Asserts if a given values implements a valid iterable interface.\n\n    Arguments:\n        **kw (mixed): value to check if it is an iterable.\n\n    Raises:\n        TypeError: if assertion fails.\n    \"\"\"\n    for name, value in kw.items():\n        if not isiter(value):\n            raise TypeError(\n                'paco: {} must be an iterable object'.format(name))", "code_tokens": "def assert_iter ( * * kw ) : for name , value in kw . items ( ) : if not isiter ( value ) : raise TypeError ( 'paco: {} must be an iterable object' . format ( name ) )", "docstring_tokens": "Asserts if a given values implements a valid iterable interface .", "label": 1}, {"idx": "cosqa-train-10370", "doc": "sleep holding up python", "code": "def test3():\n    \"\"\"Test the multiprocess\n    \"\"\"\n    import time\n    \n    p = MVisionProcess()\n    p.start()\n    time.sleep(5)\n    p.stop()", "code_tokens": "def test3 ( ) : import time p = MVisionProcess ( ) p . start ( ) time . sleep ( 5 ) p . stop ( )", "docstring_tokens": "Test the multiprocess", "label": 1}, {"idx": "cosqa-train-10371", "doc": "python assert list equal fail", "code": "def expect_all(a, b):\n    \"\"\"\\\n    Asserts that two iterables contain the same values.\n    \"\"\"\n    assert all(_a == _b for _a, _b in zip_longest(a, b))", "code_tokens": "def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )", "docstring_tokens": "\\ Asserts that two iterables contain the same values .", "label": 0}, {"idx": "cosqa-train-10372", "doc": "slicing string into sentences in python", "code": "def tokenize(self, s):\n        \"\"\"Return a list of token strings from the given sentence.\n\n        :param string s: The sentence string to tokenize.\n        :rtype: iter(str)\n        \"\"\"\n        return [s[start:end] for start, end in self.span_tokenize(s)]", "code_tokens": "def tokenize ( self , s ) : return [ s [ start : end ] for start , end in self . span_tokenize ( s ) ]", "docstring_tokens": "Return a list of token strings from the given sentence .", "label": 1}, {"idx": "cosqa-train-10373", "doc": "python assertisnone assertequals test", "code": "def assert_is_not(expected, actual, message=None, extra=None):\n    \"\"\"Raises an AssertionError if expected is actual.\"\"\"\n    assert expected is not actual, _assert_fail_message(\n        message, expected, actual, \"is\", extra\n    )", "code_tokens": "def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , \"is\" , extra )", "docstring_tokens": "Raises an AssertionError if expected is actual .", "label": 0}, {"idx": "cosqa-train-10374", "doc": "sort an array with indices python", "code": "def argsort_indices(a, axis=-1):\n    \"\"\"Like argsort, but returns an index suitable for sorting the\n    the original array even if that array is multidimensional\n    \"\"\"\n    a = np.asarray(a)\n    ind = list(np.ix_(*[np.arange(d) for d in a.shape]))\n    ind[axis] = a.argsort(axis)\n    return tuple(ind)", "code_tokens": "def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )", "docstring_tokens": "Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional", "label": 1}, {"idx": "cosqa-train-10375", "doc": "python asyncio nonblocking io", "code": "def StringIO(*args, **kwargs):\n    \"\"\"StringIO constructor shim for the async wrapper.\"\"\"\n    raw = sync_io.StringIO(*args, **kwargs)\n    return AsyncStringIOWrapper(raw)", "code_tokens": "def StringIO ( * args , * * kwargs ) : raw = sync_io . StringIO ( * args , * * kwargs ) return AsyncStringIOWrapper ( raw )", "docstring_tokens": "StringIO constructor shim for the async wrapper .", "label": 1}, {"idx": "cosqa-train-10376", "doc": "sort arrays by an index in python", "code": "def unsort_vector(data, indices_of_increasing):\n    \"\"\"Upermutate 1-D data that is sorted by indices_of_increasing.\"\"\"\n    return numpy.array([data[indices_of_increasing.index(i)] for i in range(len(data))])", "code_tokens": "def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )", "docstring_tokens": "Upermutate 1 - D data that is sorted by indices_of_increasing .", "label": 0}, {"idx": "cosqa-train-10377", "doc": "python asynico run until done", "code": "async def wait_and_quit(loop):\n\t\"\"\"Wait until all task are executed.\"\"\"\n\tfrom pylp.lib.tasks import running\n\tif running:\n\t\tawait asyncio.wait(map(lambda runner: runner.future, running))", "code_tokens": "async def wait_and_quit ( loop ) : from pylp . lib . tasks import running if running : await asyncio . wait ( map ( lambda runner : runner . future , running ) )", "docstring_tokens": "Wait until all task are executed .", "label": 1}, {"idx": "cosqa-train-10378", "doc": "python auto resize column", "code": "def _resizeColumnsToContents(self, header, data, limit_ms):\n        \"\"\"Resize all the colummns to its contents.\"\"\"\n        max_col = data.model().columnCount()\n        if limit_ms is None:\n            max_col_ms = None\n        else:\n            max_col_ms = limit_ms / max(1, max_col)\n        for col in range(max_col):\n            self._resizeColumnToContents(header, data, col, max_col_ms)", "code_tokens": "def _resizeColumnsToContents ( self , header , data , limit_ms ) : max_col = data . model ( ) . columnCount ( ) if limit_ms is None : max_col_ms = None else : max_col_ms = limit_ms / max ( 1 , max_col ) for col in range ( max_col ) : self . _resizeColumnToContents ( header , data , col , max_col_ms )", "docstring_tokens": "Resize all the colummns to its contents .", "label": 1}, {"idx": "cosqa-train-10379", "doc": "spacing for texts in python", "code": "def indent(txt, spacing=4):\n    \"\"\"\n    Indent given text using custom spacing, default is set to 4.\n    \"\"\"\n    return prefix(str(txt), ''.join([' ' for _ in range(spacing)]))", "code_tokens": "def indent ( txt , spacing = 4 ) : return prefix ( str ( txt ) , '' . join ( [ ' ' for _ in range ( spacing ) ] ) )", "docstring_tokens": "Indent given text using custom spacing default is set to 4 .", "label": 0}, {"idx": "cosqa-train-10380", "doc": "python autoreload run command", "code": "def _load_autoreload_magic(self):\n        \"\"\"Load %autoreload magic.\"\"\"\n        from IPython.core.getipython import get_ipython\n        try:\n            get_ipython().run_line_magic('reload_ext', 'autoreload')\n            get_ipython().run_line_magic('autoreload', '2')\n        except Exception:\n            pass", "code_tokens": "def _load_autoreload_magic ( self ) : from IPython . core . getipython import get_ipython try : get_ipython ( ) . run_line_magic ( 'reload_ext' , 'autoreload' ) get_ipython ( ) . run_line_magic ( 'autoreload' , '2' ) except Exception : pass", "docstring_tokens": "Load %autoreload magic .", "label": 0}, {"idx": "cosqa-train-10381", "doc": "spearman rank correlation python", "code": "def lspearmanr(x,y):\n    \"\"\"\nCalculates a Spearman rank-order correlation coefficient.  Taken\nfrom Heiman's Basic Statistics for the Behav. Sci (1st), p.192.\n\nUsage:   lspearmanr(x,y)      where x and y are equal-length lists\nReturns: Spearman's r, two-tailed p-value\n\"\"\"\n    TINY = 1e-30\n    if len(x) != len(y):\n        raise ValueError('Input values not paired in spearmanr.  Aborting.')\n    n = len(x)\n    rankx = rankdata(x)\n    ranky = rankdata(y)\n    dsq = sumdiffsquared(rankx,ranky)\n    rs = 1 - 6*dsq / float(n*(n**2-1))\n    t = rs * math.sqrt((n-2) / ((rs+1.0)*(1.0-rs)))\n    df = n-2\n    probrs = betai(0.5*df,0.5,df/(df+t*t))  # t already a float\n# probability values for rs are from part 2 of the spearman function in\n# Numerical Recipies, p.510.  They are close to tables, but not exact. (?)\n    return rs, probrs", "code_tokens": "def lspearmanr ( x , y ) : TINY = 1e-30 if len ( x ) != len ( y ) : raise ValueError ( 'Input values not paired in spearmanr.  Aborting.' ) n = len ( x ) rankx = rankdata ( x ) ranky = rankdata ( y ) dsq = sumdiffsquared ( rankx , ranky ) rs = 1 - 6 * dsq / float ( n * ( n ** 2 - 1 ) ) t = rs * math . sqrt ( ( n - 2 ) / ( ( rs + 1.0 ) * ( 1.0 - rs ) ) ) df = n - 2 probrs = betai ( 0.5 * df , 0.5 , df / ( df + t * t ) ) # t already a float # probability values for rs are from part 2 of the spearman function in # Numerical Recipies, p.510.  They are close to tables, but not exact. (?) return rs , probrs", "docstring_tokens": "Calculates a Spearman rank - order correlation coefficient . Taken from Heiman s Basic Statistics for the Behav . Sci ( 1st ) p . 192 .", "label": 1}, {"idx": "cosqa-train-10382", "doc": "python average of a dictonary", "code": "def _mean_dict(dict_list):\n    \"\"\"Compute the mean value across a list of dictionaries\n    \"\"\"\n    return {k: np.array([d[k] for d in dict_list]).mean()\n            for k in dict_list[0].keys()}", "code_tokens": "def _mean_dict ( dict_list ) : return { k : np . array ( [ d [ k ] for d in dict_list ] ) . mean ( ) for k in dict_list [ 0 ] . keys ( ) }", "docstring_tokens": "Compute the mean value across a list of dictionaries", "label": 0}, {"idx": "cosqa-train-10383", "doc": "split python only first", "code": "def _split_python(python):\n    \"\"\"Split Python source into chunks.\n\n    Chunks are separated by at least two return lines. The break must not\n    be followed by a space. Also, long Python strings spanning several lines\n    are not splitted.\n\n    \"\"\"\n    python = _preprocess(python)\n    if not python:\n        return []\n    lexer = PythonSplitLexer()\n    lexer.read(python)\n    return lexer.chunks", "code_tokens": "def _split_python ( python ) : python = _preprocess ( python ) if not python : return [ ] lexer = PythonSplitLexer ( ) lexer . read ( python ) return lexer . chunks", "docstring_tokens": "Split Python source into chunks .", "label": 1}, {"idx": "cosqa-train-10384", "doc": "python average of number arrary", "code": "def average(arr):\n  \"\"\"average of the values, must have more than 0 entries.\n\n  :param arr: list of numbers\n  :type arr: number[] a number array\n  :return: average\n  :rtype: float\n\n  \"\"\"\n  if len(arr) == 0:\n    sys.stderr.write(\"ERROR: no content in array to take average\\n\")\n    sys.exit()\n  if len(arr) == 1:  return arr[0]\n  return float(sum(arr))/float(len(arr))", "code_tokens": "def average ( arr ) : if len ( arr ) == 0 : sys . stderr . write ( \"ERROR: no content in array to take average\\n\" ) sys . exit ( ) if len ( arr ) == 1 : return arr [ 0 ] return float ( sum ( arr ) ) / float ( len ( arr ) )", "docstring_tokens": "average of the values must have more than 0 entries .", "label": 1}, {"idx": "cosqa-train-10385", "doc": "split string into segments of certain lengthpython", "code": "def split_len(s, length):\n    \"\"\"split string *s* into list of strings no longer than *length*\"\"\"\n    return [s[i:i+length] for i in range(0, len(s), length)]", "code_tokens": "def split_len ( s , length ) : return [ s [ i : i + length ] for i in range ( 0 , len ( s ) , length ) ]", "docstring_tokens": "split string * s * into list of strings no longer than * length *", "label": 1}, {"idx": "cosqa-train-10386", "doc": "python aws generate s3 url", "code": "def stack_template_url(bucket_name, blueprint, endpoint):\n    \"\"\"Produces an s3 url for a given blueprint.\n\n    Args:\n        bucket_name (string): The name of the S3 bucket where the resulting\n            templates are stored.\n        blueprint (:class:`stacker.blueprints.base.Blueprint`): The blueprint\n            object to create the URL to.\n        endpoint (string): The s3 endpoint used for the bucket.\n\n    Returns:\n        string: S3 URL.\n    \"\"\"\n    key_name = stack_template_key_name(blueprint)\n    return \"%s/%s/%s\" % (endpoint, bucket_name, key_name)", "code_tokens": "def stack_template_url ( bucket_name , blueprint , endpoint ) : key_name = stack_template_key_name ( blueprint ) return \"%s/%s/%s\" % ( endpoint , bucket_name , key_name )", "docstring_tokens": "Produces an s3 url for a given blueprint .", "label": 0}, {"idx": "cosqa-train-10387", "doc": "python aws lambda return 400 response api gateway", "code": "def get_api_url(self, lambda_name, stage_name):\n        \"\"\"\n        Given a lambda_name and stage_name, return a valid API URL.\n        \"\"\"\n        api_id = self.get_api_id(lambda_name)\n        if api_id:\n            return \"https://{}.execute-api.{}.amazonaws.com/{}\".format(api_id, self.boto_session.region_name, stage_name)\n        else:\n            return None", "code_tokens": "def get_api_url ( self , lambda_name , stage_name ) : api_id = self . get_api_id ( lambda_name ) if api_id : return \"https://{}.execute-api.{}.amazonaws.com/{}\" . format ( api_id , self . boto_session . region_name , stage_name ) else : return None", "docstring_tokens": "Given a lambda_name and stage_name return a valid API URL .", "label": 1}, {"idx": "cosqa-train-10388", "doc": "sqlalchemy python create table not null column", "code": "def create_all(self, check_first: bool = True):\n        \"\"\"Create the empty database (tables).\n\n        :param bool check_first: Defaults to True, don't issue CREATEs for tables already present\n         in the target database. Defers to :meth:`sqlalchemy.sql.schema.MetaData.create_all`\n        \"\"\"\n        self._metadata.create_all(self.engine, checkfirst=check_first)", "code_tokens": "def create_all ( self , check_first : bool = True ) : self . _metadata . create_all ( self . engine , checkfirst = check_first )", "docstring_tokens": "Create the empty database ( tables ) .", "label": 1}, {"idx": "cosqa-train-10389", "doc": "python axes pixels between points", "code": "def extent(self):\n        \"\"\"Helper for matplotlib imshow\"\"\"\n        return (\n            self.intervals[1].pix1 - 0.5,\n            self.intervals[1].pix2 - 0.5,\n            self.intervals[0].pix1 - 0.5,\n            self.intervals[0].pix2 - 0.5,\n        )", "code_tokens": "def extent ( self ) : return ( self . intervals [ 1 ] . pix1 - 0.5 , self . intervals [ 1 ] . pix2 - 0.5 , self . intervals [ 0 ] . pix1 - 0.5 , self . intervals [ 0 ] . pix2 - 0.5 , )", "docstring_tokens": "Helper for matplotlib imshow", "label": 1}, {"idx": "cosqa-train-10390", "doc": "stack overflow define function max in python", "code": "def _heapreplace_max(heap, item):\n    \"\"\"Maxheap version of a heappop followed by a heappush.\"\"\"\n    returnitem = heap[0]    # raises appropriate IndexError if heap is empty\n    heap[0] = item\n    _siftup_max(heap, 0)\n    return returnitem", "code_tokens": "def _heapreplace_max ( heap , item ) : returnitem = heap [ 0 ] # raises appropriate IndexError if heap is empty heap [ 0 ] = item _siftup_max ( heap , 0 ) return returnitem", "docstring_tokens": "Maxheap version of a heappop followed by a heappush .", "label": 0}, {"idx": "cosqa-train-10391", "doc": "python bar plot change graph height", "code": "def _change_height(self, ax, new_value):\n        \"\"\"Make bars in horizontal bar chart thinner\"\"\"\n        for patch in ax.patches:\n            current_height = patch.get_height()\n            diff = current_height - new_value\n\n            # we change the bar height\n            patch.set_height(new_value)\n\n            # we recenter the bar\n            patch.set_y(patch.get_y() + diff * .5)", "code_tokens": "def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )", "docstring_tokens": "Make bars in horizontal bar chart thinner", "label": 1}, {"idx": "cosqa-train-10392", "doc": "stack overflow python databases i", "code": "def init_db():\n    \"\"\"\n    Drops and re-creates the SQL schema\n    \"\"\"\n    db.drop_all()\n    db.configure_mappers()\n    db.create_all()\n    db.session.commit()", "code_tokens": "def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )", "docstring_tokens": "Drops and re - creates the SQL schema", "label": 1}, {"idx": "cosqa-train-10393", "doc": "python base64 decode with b ahead of string", "code": "def toBase64(s):\n    \"\"\"Represent string / bytes s as base64, omitting newlines\"\"\"\n    if isinstance(s, str):\n        s = s.encode(\"utf-8\")\n    return binascii.b2a_base64(s)[:-1]", "code_tokens": "def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( \"utf-8\" ) return binascii . b2a_base64 ( s ) [ : - 1 ]", "docstring_tokens": "Represent string / bytes s as base64 omitting newlines", "label": 0}, {"idx": "cosqa-train-10394", "doc": "stack overflow python databases in c", "code": "def init_db():\n    \"\"\"\n    Drops and re-creates the SQL schema\n    \"\"\"\n    db.drop_all()\n    db.configure_mappers()\n    db.create_all()\n    db.session.commit()", "code_tokens": "def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )", "docstring_tokens": "Drops and re - creates the SQL schema", "label": 1}, {"idx": "cosqa-train-10395", "doc": "python base64 to ndarray", "code": "def encode_ndarray(obj):\n    \"\"\"Write a numpy array and its shape to base64 buffers\"\"\"\n    shape = obj.shape\n    if len(shape) == 1:\n        shape = (1, obj.shape[0])\n    if obj.flags.c_contiguous:\n        obj = obj.T\n    elif not obj.flags.f_contiguous:\n        obj = asfortranarray(obj.T)\n    else:\n        obj = obj.T\n    try:\n        data = obj.astype(float64).tobytes()\n    except AttributeError:\n        data = obj.astype(float64).tostring()\n\n    data = base64.b64encode(data).decode('utf-8')\n    return data, shape", "code_tokens": "def encode_ndarray ( obj ) : shape = obj . shape if len ( shape ) == 1 : shape = ( 1 , obj . shape [ 0 ] ) if obj . flags . c_contiguous : obj = obj . T elif not obj . flags . f_contiguous : obj = asfortranarray ( obj . T ) else : obj = obj . T try : data = obj . astype ( float64 ) . tobytes ( ) except AttributeError : data = obj . astype ( float64 ) . tostring ( ) data = base64 . b64encode ( data ) . decode ( 'utf-8' ) return data , shape", "docstring_tokens": "Write a numpy array and its shape to base64 buffers", "label": 0}, {"idx": "cosqa-train-10396", "doc": "stacked plot python time series matplotlib", "code": "def stackplot(marray, seconds=None, start_time=None, ylabels=None):\n    \"\"\"\n    will plot a stack of traces one above the other assuming\n    marray.shape = numRows, numSamples\n    \"\"\"\n    tarray = np.transpose(marray)\n    stackplot_t(tarray, seconds=seconds, start_time=start_time, ylabels=ylabels)\n    plt.show()", "code_tokens": "def stackplot ( marray , seconds = None , start_time = None , ylabels = None ) : tarray = np . transpose ( marray ) stackplot_t ( tarray , seconds = seconds , start_time = start_time , ylabels = ylabels ) plt . show ( )", "docstring_tokens": "will plot a stack of traces one above the other assuming marray . shape = numRows numSamples", "label": 1}, {"idx": "cosqa-train-10397", "doc": "python basehttpserver header set nocache", "code": "def apply_caching(response):\n    \"\"\"Applies the configuration's http headers to all responses\"\"\"\n    for k, v in config.get('HTTP_HEADERS').items():\n        response.headers[k] = v\n    return response", "code_tokens": "def apply_caching ( response ) : for k , v in config . get ( 'HTTP_HEADERS' ) . items ( ) : response . headers [ k ] = v return response", "docstring_tokens": "Applies the configuration s http headers to all responses", "label": 0}, {"idx": "cosqa-train-10398", "doc": "stackoverflow python slugify filename", "code": "def slugify_filename(filename):\n    \"\"\" Slugify filename \"\"\"\n    name, ext = os.path.splitext(filename)\n    slugified = get_slugified_name(name)\n    return slugified + ext", "code_tokens": "def slugify_filename ( filename ) : name , ext = os . path . splitext ( filename ) slugified = get_slugified_name ( name ) return slugified + ext", "docstring_tokens": "Slugify filename", "label": 1}, {"idx": "cosqa-train-10399", "doc": "python binary representation of the tiff", "code": "def to_bytes(self):\n\t\t\"\"\"Convert the entire image to bytes.\n\t\t\n\t\t:rtype: bytes\n\t\t\"\"\"\n\t\tchunks = [PNG_SIGN]\n\t\tchunks.extend(c[1] for c in self.chunks)\n\t\treturn b\"\".join(chunks)", "code_tokens": "def to_bytes ( self ) : chunks = [ PNG_SIGN ] chunks . extend ( c [ 1 ] for c in self . chunks ) return b\"\" . join ( chunks )", "docstring_tokens": "Convert the entire image to bytes . : rtype : bytes", "label": 1}, {"idx": "cosqa-train-10400", "doc": "stackovrflow python send text", "code": "async def _send_plain_text(self, request: Request, stack: Stack):\n        \"\"\"\n        Sends plain text using `_send_text()`.\n        \"\"\"\n\n        await self._send_text(request, stack, None)", "code_tokens": "async def _send_plain_text ( self , request : Request , stack : Stack ) : await self . _send_text ( request , stack , None )", "docstring_tokens": "Sends plain text using _send_text () .", "label": 0}, {"idx": "cosqa-train-10401", "doc": "python binding to adb", "code": "def main(ctx, connection):\n    \"\"\"Command line interface for PyBEL.\"\"\"\n    ctx.obj = Manager(connection=connection)\n    ctx.obj.bind()", "code_tokens": "def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )", "docstring_tokens": "Command line interface for PyBEL .", "label": 1}, {"idx": "cosqa-train-10402", "doc": "standard deviation time series python", "code": "def circstd(dts, axis=2):\n    \"\"\"Circular standard deviation\"\"\"\n    R = np.abs(np.exp(1.0j * dts).mean(axis=axis))\n    return np.sqrt(-2.0 * np.log(R))", "code_tokens": "def circstd ( dts , axis = 2 ) : R = np . abs ( np . exp ( 1.0j * dts ) . mean ( axis = axis ) ) return np . sqrt ( - 2.0 * np . log ( R ) )", "docstring_tokens": "Circular standard deviation", "label": 0}, {"idx": "cosqa-train-10403", "doc": "python bokeh plot has no data renderers", "code": "def _get_bokeh_html(self, chart_obj):\n        \"\"\"\n        Get the html for a Bokeh chart\n        \"\"\"\n        global bokeh_renderer\n        try:\n            renderer = bokeh_renderer\n            p = renderer.get_plot(chart_obj).state\n            script, div = components(p)\n            return script + \"\\n\" + div\n\n        except Exception as e:\n            self.err(e, self._get_bokeh_html,\n                     \"Can not get html from the Bokeh rendering engine\")", "code_tokens": "def _get_bokeh_html ( self , chart_obj ) : global bokeh_renderer try : renderer = bokeh_renderer p = renderer . get_plot ( chart_obj ) . state script , div = components ( p ) return script + \"\\n\" + div except Exception as e : self . err ( e , self . _get_bokeh_html , \"Can not get html from the Bokeh rendering engine\" )", "docstring_tokens": "Get the html for a Bokeh chart", "label": 1}, {"idx": "cosqa-train-10404", "doc": "standard scalar function in python", "code": "def Softsign(a):\n    \"\"\"\n    Softsign op.\n    \"\"\"\n    return np.divide(a, np.add(np.abs(a), 1)),", "code_tokens": "def Softsign ( a ) : return np . divide ( a , np . add ( np . abs ( a ) , 1 ) ) ,", "docstring_tokens": "Softsign op .", "label": 1}, {"idx": "cosqa-train-10405", "doc": "python bool object not callable", "code": "def less_strict_bool(x):\n    \"\"\"Idempotent and None-safe version of strict_bool.\"\"\"\n    if x is None:\n        return False\n    elif x is True or x is False:\n        return x\n    else:\n        return strict_bool(x)", "code_tokens": "def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )", "docstring_tokens": "Idempotent and None - safe version of strict_bool .", "label": 0}, {"idx": "cosqa-train-10406", "doc": "static int inside python function", "code": "def is_static(*p):\n    \"\"\" A static value (does not change at runtime)\n    which is known at compile time\n    \"\"\"\n    return all(is_CONST(x) or\n               is_number(x) or\n               is_const(x)\n               for x in p)", "code_tokens": "def is_static ( * p ) : return all ( is_CONST ( x ) or is_number ( x ) or is_const ( x ) for x in p )", "docstring_tokens": "A static value ( does not change at runtime ) which is known at compile time", "label": 1}, {"idx": "cosqa-train-10407", "doc": "python boolean not true", "code": "def _check_and_convert_bools(self):\n        \"\"\"Replace boolean variables by the characters 'F'/'T'\n        \"\"\"\n        replacements = {\n            True: 'T',\n            False: 'F',\n        }\n\n        for key in self.bools:\n            if isinstance(self[key], bool):\n                self[key] = replacements[self[key]]", "code_tokens": "def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]", "docstring_tokens": "Replace boolean variables by the characters F / T", "label": 0}, {"idx": "cosqa-train-10408", "doc": "statistic unique data in column in python", "code": "def describe_unique_1d(series):\n    \"\"\"Compute summary statistics of a unique (`S_TYPE_UNIQUE`) variable (a Series).\n\n    Parameters\n    ----------\n    series : Series\n        The variable to describe.\n\n    Returns\n    -------\n    Series\n        The description of the variable as a Series with index being stats keys.\n    \"\"\"\n    return pd.Series([base.S_TYPE_UNIQUE], index=['type'], name=series.name)", "code_tokens": "def describe_unique_1d ( series ) : return pd . Series ( [ base . S_TYPE_UNIQUE ] , index = [ 'type' ] , name = series . name )", "docstring_tokens": "Compute summary statistics of a unique ( S_TYPE_UNIQUE ) variable ( a Series ) .", "label": 1}, {"idx": "cosqa-train-10409", "doc": "python boto3 check if sts is expire and renew", "code": "def needs_update(self, cache_key):\n    \"\"\"Check if the given cached item is invalid.\n\n    :param cache_key: A CacheKey object (as returned by CacheKeyGenerator.key_for().\n    :returns: True if the cached version of the item is out of date.\n    \"\"\"\n    if not self.cacheable(cache_key):\n      # An uncacheable CacheKey is always out of date.\n      return True\n\n    return self._read_sha(cache_key) != cache_key.hash", "code_tokens": "def needs_update ( self , cache_key ) : if not self . cacheable ( cache_key ) : # An uncacheable CacheKey is always out of date. return True return self . _read_sha ( cache_key ) != cache_key . hash", "docstring_tokens": "Check if the given cached item is invalid .", "label": 1}, {"idx": "cosqa-train-10410", "doc": "stop async loop python", "code": "async def wait_and_quit(loop):\n\t\"\"\"Wait until all task are executed.\"\"\"\n\tfrom pylp.lib.tasks import running\n\tif running:\n\t\tawait asyncio.wait(map(lambda runner: runner.future, running))", "code_tokens": "async def wait_and_quit ( loop ) : from pylp . lib . tasks import running if running : await asyncio . wait ( map ( lambda runner : runner . future , running ) )", "docstring_tokens": "Wait until all task are executed .", "label": 0}, {"idx": "cosqa-train-10411", "doc": "python boto3 dynamodb delete a item from list", "code": "def delete_item(self, item):\n        \"\"\"Delete an object in DynamoDB.\n\n        :param item: Unpacked into kwargs for :func:`boto3.DynamoDB.Client.delete_item`.\n        :raises bloop.exceptions.ConstraintViolation: if the condition (or atomic) is not met.\n        \"\"\"\n        try:\n            self.dynamodb_client.delete_item(**item)\n        except botocore.exceptions.ClientError as error:\n            handle_constraint_violation(error)", "code_tokens": "def delete_item ( self , item ) : try : self . dynamodb_client . delete_item ( * * item ) except botocore . exceptions . ClientError as error : handle_constraint_violation ( error )", "docstring_tokens": "Delete an object in DynamoDB .", "label": 0}, {"idx": "cosqa-train-10412", "doc": "store a list of points python", "code": "def polygon_from_points(points):\n    \"\"\"\n    Constructs a numpy-compatible polygon from a page representation.\n    \"\"\"\n    polygon = []\n    for pair in points.split(\" \"):\n        x_y = pair.split(\",\")\n        polygon.append([float(x_y[0]), float(x_y[1])])\n    return polygon", "code_tokens": "def polygon_from_points ( points ) : polygon = [ ] for pair in points . split ( \" \" ) : x_y = pair . split ( \",\" ) polygon . append ( [ float ( x_y [ 0 ] ) , float ( x_y [ 1 ] ) ] ) return polygon", "docstring_tokens": "Constructs a numpy - compatible polygon from a page representation .", "label": 0}, {"idx": "cosqa-train-10413", "doc": "python boto3 upload all files in a folder", "code": "def sync_s3(self):\n        \"\"\"Walk the media/static directories and syncs files to S3\"\"\"\n        bucket, key = self.open_s3()\n        for directory in self.DIRECTORIES:\n            for root, dirs, files in os.walk(directory):\n                self.upload_s3((bucket, key, self.AWS_BUCKET_NAME, directory), root, files, dirs)", "code_tokens": "def sync_s3 ( self ) : bucket , key = self . open_s3 ( ) for directory in self . DIRECTORIES : for root , dirs , files in os . walk ( directory ) : self . upload_s3 ( ( bucket , key , self . AWS_BUCKET_NAME , directory ) , root , files , dirs )", "docstring_tokens": "Walk the media / static directories and syncs files to S3", "label": 1}, {"idx": "cosqa-train-10414", "doc": "store database credentials on environment variable in python", "code": "def set_user_password(environment, parameter, password):\n    \"\"\"\n    Sets a user's password in the keyring storage\n    \"\"\"\n    username = '%s:%s' % (environment, parameter)\n    return password_set(username, password)", "code_tokens": "def set_user_password ( environment , parameter , password ) : username = '%s:%s' % ( environment , parameter ) return password_set ( username , password )", "docstring_tokens": "Sets a user s password in the keyring storage", "label": 1}, {"idx": "cosqa-train-10415", "doc": "python bottle run server background", "code": "def start():\n    \"\"\"Starts the web server.\"\"\"\n    global app\n    bottle.run(app, host=conf.WebHost, port=conf.WebPort,\n               debug=conf.WebAutoReload, reloader=conf.WebAutoReload,\n               quiet=conf.WebQuiet)", "code_tokens": "def start ( ) : global app bottle . run ( app , host = conf . WebHost , port = conf . WebPort , debug = conf . WebAutoReload , reloader = conf . WebAutoReload , quiet = conf . WebQuiet )", "docstring_tokens": "Starts the web server .", "label": 1}, {"idx": "cosqa-train-10416", "doc": "str object is not callable python", "code": "def __str__(self):\n        \"\"\"Executes self.function to convert LazyString instance to a real\n        str.\"\"\"\n        if not hasattr(self, '_str'):\n            self._str=self.function(*self.args, **self.kwargs)\n        return self._str", "code_tokens": "def __str__ ( self ) : if not hasattr ( self , '_str' ) : self . _str = self . function ( * self . args , * * self . kwargs ) return self . _str", "docstring_tokens": "Executes self . function to convert LazyString instance to a real str .", "label": 0}, {"idx": "cosqa-train-10417", "doc": "python bound method reference circular", "code": "def attr_cache_clear(self):\n        node = extract_node(\"\"\"def cache_clear(self): pass\"\"\")\n        return BoundMethod(proxy=node, bound=self._instance.parent.scope())", "code_tokens": "def attr_cache_clear ( self ) : node = extract_node ( \"\"\"def cache_clear(self): pass\"\"\" ) return BoundMethod ( proxy = node , bound = self . _instance . parent . scope ( ) )", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-10418", "doc": "string as file object stringio python", "code": "def loads(s, model=None, parser=None):\n    \"\"\"Deserialize s (a str) to a Python object.\"\"\"\n    with StringIO(s) as f:\n        return load(f, model=model, parser=parser)", "code_tokens": "def loads ( s , model = None , parser = None ) : with StringIO ( s ) as f : return load ( f , model = model , parser = parser )", "docstring_tokens": "Deserialize s ( a str ) to a Python object .", "label": 1}, {"idx": "cosqa-train-10419", "doc": "python boundmethod to unbound", "code": "def __call__(self, obj, *arg, **kw):\n        \"\"\"\n        Call the unbound method.\n        \n        We essentially build a bound method and call that. This ensures that\n        the code for managing observers is invoked in the same was as it would\n        be for a bound method.\n        \"\"\"\n        bound_method = self._manager.__get__(obj, obj.__class__)\n        return bound_method(*arg, **kw)", "code_tokens": "def __call__ ( self , obj , * arg , * * kw ) : bound_method = self . _manager . __get__ ( obj , obj . __class__ ) return bound_method ( * arg , * * kw )", "docstring_tokens": "Call the unbound method . We essentially build a bound method and call that . This ensures that the code for managing observers is invoked in the same was as it would be for a bound method .", "label": 1}, {"idx": "cosqa-train-10420", "doc": "string to list python comma", "code": "def split_elements(value):\n    \"\"\"Split a string with comma or space-separated elements into a list.\"\"\"\n    l = [v.strip() for v in value.split(',')]\n    if len(l) == 1:\n        l = value.split()\n    return l", "code_tokens": "def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l", "docstring_tokens": "Split a string with comma or space - separated elements into a list .", "label": 0}, {"idx": "cosqa-train-10421", "doc": "python bs4 xml to dict", "code": "def xml_str_to_dict(s):\n    \"\"\" Transforms an XML string it to python-zimbra dict format\n\n    For format, see:\n      https://github.com/Zimbra-Community/python-zimbra/blob/master/README.md\n\n    :param: a string, containing XML\n    :returns: a dict, with python-zimbra format\n    \"\"\"\n    xml = minidom.parseString(s)\n    return pythonzimbra.tools.xmlserializer.dom_to_dict(xml.firstChild)", "code_tokens": "def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )", "docstring_tokens": "Transforms an XML string it to python - zimbra dict format", "label": 1}, {"idx": "cosqa-train-10422", "doc": "strip html tags in python", "code": "def do_striptags(value):\n    \"\"\"Strip SGML/XML tags and replace adjacent whitespace by one space.\n    \"\"\"\n    if hasattr(value, '__html__'):\n        value = value.__html__()\n    return Markup(unicode(value)).striptags()", "code_tokens": "def do_striptags ( value ) : if hasattr ( value , '__html__' ) : value = value . __html__ ( ) return Markup ( unicode ( value ) ) . striptags ( )", "docstring_tokens": "Strip SGML / XML tags and replace adjacent whitespace by one space .", "label": 1}, {"idx": "cosqa-train-10423", "doc": "python bson to file", "code": "def WriteManyToPath(objs, filepath):\n  \"\"\"Serializes and writes given Python objects to a multi-document YAML file.\n\n  Args:\n    objs: An iterable of Python objects to serialize.\n    filepath: A path to the file into which the object is to be written.\n  \"\"\"\n  with io.open(filepath, mode=\"w\", encoding=\"utf-8\") as filedesc:\n    WriteManyToFile(objs, filedesc)", "code_tokens": "def WriteManyToPath ( objs , filepath ) : with io . open ( filepath , mode = \"w\" , encoding = \"utf-8\" ) as filedesc : WriteManyToFile ( objs , filedesc )", "docstring_tokens": "Serializes and writes given Python objects to a multi - document YAML file .", "label": 1}, {"idx": "cosqa-train-10424", "doc": "strip non alphabetic characters python", "code": "def clean(self, text):\n        \"\"\"Remove all unwanted characters from text.\"\"\"\n        return ''.join([c for c in text if c in self.alphabet])", "code_tokens": "def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )", "docstring_tokens": "Remove all unwanted characters from text .", "label": 1}, {"idx": "cosqa-train-10425", "doc": "python built in yaml support", "code": "def yaml_to_param(obj, name):\n\t\"\"\"\n\tReturn the top-level element of a document sub-tree containing the\n\tYAML serialization of a Python object.\n\t\"\"\"\n\treturn from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))", "code_tokens": "def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "docstring_tokens": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object .", "label": 0}, {"idx": "cosqa-train-10426", "doc": "sum function python non iterable", "code": "def _accumulate(sequence, func):\n    \"\"\"\n    Python2 accumulate implementation taken from\n    https://docs.python.org/3/library/itertools.html#itertools.accumulate\n    \"\"\"\n    iterator = iter(sequence)\n    total = next(iterator)\n    yield total\n    for element in iterator:\n        total = func(total, element)\n        yield total", "code_tokens": "def _accumulate ( sequence , func ) : iterator = iter ( sequence ) total = next ( iterator ) yield total for element in iterator : total = func ( total , element ) yield total", "docstring_tokens": "Python2 accumulate implementation taken from https : // docs . python . org / 3 / library / itertools . html#itertools . accumulate", "label": 1}, {"idx": "cosqa-train-10427", "doc": "python bytearray from image frame", "code": "def to_bytes(self):\n\t\t\"\"\"Convert the entire image to bytes.\n\t\t\n\t\t:rtype: bytes\n\t\t\"\"\"\n\t\tchunks = [PNG_SIGN]\n\t\tchunks.extend(c[1] for c in self.chunks)\n\t\treturn b\"\".join(chunks)", "code_tokens": "def to_bytes ( self ) : chunks = [ PNG_SIGN ] chunks . extend ( c [ 1 ] for c in self . chunks ) return b\"\" . join ( chunks )", "docstring_tokens": "Convert the entire image to bytes . : rtype : bytes", "label": 1}, {"idx": "cosqa-train-10428", "doc": "sum results of a query python sqlalchemy", "code": "def get_count(self, query):\n        \"\"\"\n        Returns a number of query results. This is faster than .count() on the query\n        \"\"\"\n        count_q = query.statement.with_only_columns(\n            [func.count()]).order_by(None)\n        count = query.session.execute(count_q).scalar()\n        return count", "code_tokens": "def get_count ( self , query ) : count_q = query . statement . with_only_columns ( [ func . count ( ) ] ) . order_by ( None ) count = query . session . execute ( count_q ) . scalar ( ) return count", "docstring_tokens": "Returns a number of query results . This is faster than . count () on the query", "label": 1}, {"idx": "cosqa-train-10429", "doc": "python bytecode to native code", "code": "def xeval(source, optimize=True):\n    \"\"\"Compiles to native Python bytecode and runs program, returning the\n    topmost value on the stack.\n\n    Args:\n        optimize: Whether to optimize the code after parsing it.\n\n    Returns:\n        None: If the stack is empty\n        obj: If the stack contains a single value\n        [obj, obj, ...]: If the stack contains many values\n    \"\"\"\n    native = xcompile(source, optimize=optimize)\n    return native()", "code_tokens": "def xeval ( source , optimize = True ) : native = xcompile ( source , optimize = optimize ) return native ( )", "docstring_tokens": "Compiles to native Python bytecode and runs program returning the topmost value on the stack .", "label": 0}, {"idx": "cosqa-train-10430", "doc": "summing with a for loop in python", "code": "def _accumulate(sequence, func):\n    \"\"\"\n    Python2 accumulate implementation taken from\n    https://docs.python.org/3/library/itertools.html#itertools.accumulate\n    \"\"\"\n    iterator = iter(sequence)\n    total = next(iterator)\n    yield total\n    for element in iterator:\n        total = func(total, element)\n        yield total", "code_tokens": "def _accumulate ( sequence , func ) : iterator = iter ( sequence ) total = next ( iterator ) yield total for element in iterator : total = func ( total , element ) yield total", "docstring_tokens": "Python2 accumulate implementation taken from https : // docs . python . org / 3 / library / itertools . html#itertools . accumulate", "label": 0}, {"idx": "cosqa-train-10431", "doc": "python bytecode to numpy from array", "code": "def _convert_to_array(array_like, dtype):\n        \"\"\"\n        Convert Matrix attributes which are array-like or buffer to array.\n        \"\"\"\n        if isinstance(array_like, bytes):\n            return np.frombuffer(array_like, dtype=dtype)\n        return np.asarray(array_like, dtype=dtype)", "code_tokens": "def _convert_to_array ( array_like , dtype ) : if isinstance ( array_like , bytes ) : return np . frombuffer ( array_like , dtype = dtype ) return np . asarray ( array_like , dtype = dtype )", "docstring_tokens": "Convert Matrix attributes which are array - like or buffer to array .", "label": 0}, {"idx": "cosqa-train-10432", "doc": "swagger api generate python", "code": "def add_swagger(app, json_route, html_route):\n    \"\"\"\n    a convenience method for both adding a swagger.json route,\n    as well as adding a page showing the html documentation\n    \"\"\"\n    app.router.add_route('GET', json_route, create_swagger_json_handler(app))\n    add_swagger_api_route(app, html_route, json_route)", "code_tokens": "def add_swagger ( app , json_route , html_route ) : app . router . add_route ( 'GET' , json_route , create_swagger_json_handler ( app ) ) add_swagger_api_route ( app , html_route , json_route )", "docstring_tokens": "a convenience method for both adding a swagger . json route as well as adding a page showing the html documentation", "label": 0}, {"idx": "cosqa-train-10433", "doc": "python calculate boundingcircle from points", "code": "def get_bound(pts):\n    \"\"\"Compute a minimal rectangle that covers all the points.\"\"\"\n    (x0, y0, x1, y1) = (INF, INF, -INF, -INF)\n    for (x, y) in pts:\n        x0 = min(x0, x)\n        y0 = min(y0, y)\n        x1 = max(x1, x)\n        y1 = max(y1, y)\n    return (x0, y0, x1, y1)", "code_tokens": "def get_bound ( pts ) : ( x0 , y0 , x1 , y1 ) = ( INF , INF , - INF , - INF ) for ( x , y ) in pts : x0 = min ( x0 , x ) y0 = min ( y0 , y ) x1 = max ( x1 , x ) y1 = max ( y1 , y ) return ( x0 , y0 , x1 , y1 )", "docstring_tokens": "Compute a minimal rectangle that covers all the points .", "label": 1}, {"idx": "cosqa-train-10434", "doc": "swap function for lists python", "code": "def lazy_reverse_binmap(f, xs):\n    \"\"\"\n    Same as lazy_binmap, except the parameters are flipped for the binary function\n    \"\"\"\n    return (f(y, x) for x, y in zip(xs, xs[1:]))", "code_tokens": "def lazy_reverse_binmap ( f , xs ) : return ( f ( y , x ) for x , y in zip ( xs , xs [ 1 : ] ) )", "docstring_tokens": "Same as lazy_binmap except the parameters are flipped for the binary function", "label": 1}, {"idx": "cosqa-train-10435", "doc": "python calculate hash of any file", "code": "def generate_hash(filepath):\n    \"\"\"Public function that reads a local file and generates a SHA256 hash digest for it\"\"\"\n    fr = FileReader(filepath)\n    data = fr.read_bin()\n    return _calculate_sha256(data)", "code_tokens": "def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )", "docstring_tokens": "Public function that reads a local file and generates a SHA256 hash digest for it", "label": 0}, {"idx": "cosqa-train-10436", "doc": "take the longest string in list python", "code": "def get_longest_orf(orfs):\n    \"\"\"Find longest ORF from the given list of ORFs.\"\"\"\n    sorted_orf = sorted(orfs, key=lambda x: len(x['sequence']), reverse=True)[0]\n    return sorted_orf", "code_tokens": "def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf", "docstring_tokens": "Find longest ORF from the given list of ORFs .", "label": 1}, {"idx": "cosqa-train-10437", "doc": "python calculate rotation matrix of two vector", "code": "def qrot(vector, quaternion):\n    \"\"\"Rotate a 3D vector using quaternion algebra.\n\n    Implemented by Vladimir Kulikovskiy.\n\n    Parameters\n    ----------\n    vector: np.array\n    quaternion: np.array\n\n    Returns\n    -------\n    np.array\n\n    \"\"\"\n    t = 2 * np.cross(quaternion[1:], vector)\n    v_rot = vector + quaternion[0] * t + np.cross(quaternion[1:], t)\n    return v_rot", "code_tokens": "def qrot ( vector , quaternion ) : t = 2 * np . cross ( quaternion [ 1 : ] , vector ) v_rot = vector + quaternion [ 0 ] * t + np . cross ( quaternion [ 1 : ] , t ) return v_rot", "docstring_tokens": "Rotate a 3D vector using quaternion algebra .", "label": 1}, {"idx": "cosqa-train-10438", "doc": "take two list from the python and generate a dynamic table html", "code": "def _render_table(data, fields=None):\n  \"\"\" Helper to render a list of dictionaries as an HTML display object. \"\"\"\n  return IPython.core.display.HTML(datalab.utils.commands.HtmlBuilder.render_table(data, fields))", "code_tokens": "def _render_table ( data , fields = None ) : return IPython . core . display . HTML ( datalab . utils . commands . HtmlBuilder . render_table ( data , fields ) )", "docstring_tokens": "Helper to render a list of dictionaries as an HTML display object .", "label": 1}, {"idx": "cosqa-train-10439", "doc": "python capital to lower case letter", "code": "def to_pascal_case(s):\n    \"\"\"Transform underscore separated string to pascal case\n\n    \"\"\"\n    return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())", "code_tokens": "def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )", "docstring_tokens": "Transform underscore separated string to pascal case", "label": 1}, {"idx": "cosqa-train-10440", "doc": "taking the fft of an large array in python", "code": "def hkm_fc(fdata, Nmax, m, s):\n    \"\"\" Assume fdata has even rows\"\"\"\n\n    f = fdata[:, m]\n    L1 = f.size\n    MM = int(L1 / 2)\n    Q = s.size\n\n    ff = np.zeros(Q, dtype=np.complex128)\n    for n in xrange(MM, L1):\n        ff[n] = f[n - MM]\n\n    for n in xrange(0, MM):\n        ff[n] = f[n + MM]\n\n    # For larger problems, this speeds things up pretty good.\n    F = np.fft.fft(ff)\n    S = np.fft.fft(s)\n    out = 4 * np.pi * np.fft.ifft(F * S)\n\n    return out[0:Nmax + 1]", "code_tokens": "def hkm_fc ( fdata , Nmax , m , s ) : f = fdata [ : , m ] L1 = f . size MM = int ( L1 / 2 ) Q = s . size ff = np . zeros ( Q , dtype = np . complex128 ) for n in xrange ( MM , L1 ) : ff [ n ] = f [ n - MM ] for n in xrange ( 0 , MM ) : ff [ n ] = f [ n + MM ] # For larger problems, this speeds things up pretty good.\n F = np . fft . fft ( ff ) S = np . fft . fft ( s ) out = 4 * np . pi * np . fft . ifft ( F * S ) return out [ 0 : Nmax + 1 ]", "docstring_tokens": "Assume fdata has even rows", "label": 1}, {"idx": "cosqa-train-10441", "doc": "python capitalize first lette r", "code": "def decamelise(text):\n    \"\"\"Convert CamelCase to lower_and_underscore.\"\"\"\n    s = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s).lower()", "code_tokens": "def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s ) . lower ( )", "docstring_tokens": "Convert CamelCase to lower_and_underscore .", "label": 0}, {"idx": "cosqa-train-10442", "doc": "temporary failure in name resolution smtp python", "code": "def get_server(address=None):\n        \"\"\"Return an SMTP servername guess from outgoing email address.\"\"\"\n        if address:\n            domain = address.split(\"@\")[1]\n            try:\n                return SMTP_SERVERS[domain]\n            except KeyError:\n                return (\"smtp.\" + domain, 465)\n        return (None, None)", "code_tokens": "def get_server ( address = None ) : if address : domain = address . split ( \"@\" ) [ 1 ] try : return SMTP_SERVERS [ domain ] except KeyError : return ( \"smtp.\" + domain , 465 ) return ( None , None )", "docstring_tokens": "Return an SMTP servername guess from outgoing email address .", "label": 1}, {"idx": "cosqa-train-10443", "doc": "python capture closing of matplotlib figure", "code": "def close(*args, **kwargs):\n    r\"\"\"Close last created figure, alias to ``plt.close()``.\"\"\"\n    _, plt, _ = _import_plt()\n    plt.close(*args, **kwargs)", "code_tokens": "def close ( * args , * * kwargs ) : _ , plt , _ = _import_plt ( ) plt . close ( * args , * * kwargs )", "docstring_tokens": "r Close last created figure alias to plt . close () .", "label": 0}, {"idx": "cosqa-train-10444", "doc": "tensorflow supported python versions", "code": "def tf2():\n  \"\"\"Provide the root module of a TF-2.0 API for use within TensorBoard.\n\n  Returns:\n    The root module of a TF-2.0 API, if available.\n\n  Raises:\n    ImportError: if a TF-2.0 API is not available.\n  \"\"\"\n  # Import the `tf` compat API from this file and check if it's already TF 2.0.\n  if tf.__version__.startswith('2.'):\n    return tf\n  elif hasattr(tf, 'compat') and hasattr(tf.compat, 'v2'):\n    # As a fallback, try `tensorflow.compat.v2` if it's defined.\n    return tf.compat.v2\n  raise ImportError('cannot import tensorflow 2.0 API')", "code_tokens": "def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )", "docstring_tokens": "Provide the root module of a TF - 2 . 0 API for use within TensorBoard .", "label": 1}, {"idx": "cosqa-train-10445", "doc": "python capture return value of shell command", "code": "def call_out(command):\n  \"\"\"\n  Run the given command (with shell=False) and return a tuple of\n  (int returncode, str output). Strip the output of enclosing whitespace.\n  \"\"\"\n  # start external command process\n  p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n  # get outputs\n  out, _ = p.communicate()\n\n  return p.returncode, out.strip()", "code_tokens": "def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "docstring_tokens": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace .", "label": 0}, {"idx": "cosqa-train-10446", "doc": "tensorflow take python list as placeholder", "code": "def _int64_feature(value):\n  \"\"\"Wrapper for inserting int64 features into Example proto.\"\"\"\n  if not isinstance(value, list):\n    value = [value]\n  return tf.train.Feature(int64_list=tf.train.Int64List(value=value))", "code_tokens": "def _int64_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( int64_list = tf . train . Int64List ( value = value ) )", "docstring_tokens": "Wrapper for inserting int64 features into Example proto .", "label": 0}, {"idx": "cosqa-train-10447", "doc": "python cast a datetime", "code": "def _datetime_to_date(arg):\n    \"\"\"\n    convert datetime/str to date\n    :param arg:\n    :return:\n    \"\"\"\n    _arg = parse(arg)\n    if isinstance(_arg, datetime.datetime):\n        _arg = _arg.date()\n    return _arg", "code_tokens": "def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "docstring_tokens": "convert datetime / str to date : param arg : : return :", "label": 0}, {"idx": "cosqa-train-10448", "doc": "terminate while loop after predefined time python process", "code": "def timeout_thread_handler(timeout, stop_event):\n    \"\"\"A background thread to kill the process if it takes too long.\n\n    Args:\n        timeout (float): The number of seconds to wait before killing\n            the process.\n        stop_event (Event): An optional event to cleanly stop the background\n            thread if required during testing.\n    \"\"\"\n\n    stop_happened = stop_event.wait(timeout)\n    if stop_happened is False:\n        print(\"Killing program due to %f second timeout\" % timeout)\n\n    os._exit(2)", "code_tokens": "def timeout_thread_handler ( timeout , stop_event ) : stop_happened = stop_event . wait ( timeout ) if stop_happened is False : print ( \"Killing program due to %f second timeout\" % timeout ) os . _exit ( 2 )", "docstring_tokens": "A background thread to kill the process if it takes too long .", "label": 1}, {"idx": "cosqa-train-10449", "doc": "python cast string to custom type", "code": "def text(value, encoding=\"utf-8\", errors=\"strict\"):\n    \"\"\"Convert a value to str on Python 3 and unicode on Python 2.\"\"\"\n    if isinstance(value, text_type):\n        return value\n    elif isinstance(value, bytes):\n        return text_type(value, encoding, errors)\n    else:\n        return text_type(value)", "code_tokens": "def text ( value , encoding = \"utf-8\" , errors = \"strict\" ) : if isinstance ( value , text_type ) : return value elif isinstance ( value , bytes ) : return text_type ( value , encoding , errors ) else : return text_type ( value )", "docstring_tokens": "Convert a value to str on Python 3 and unicode on Python 2 .", "label": 1}, {"idx": "cosqa-train-10450", "doc": "test if a row in a file is empty python", "code": "def file_empty(fp):\n    \"\"\"Determine if a file is empty or not.\"\"\"\n    # for python 2 we need to use a homemade peek()\n    if six.PY2:\n        contents = fp.read()\n        fp.seek(0)\n        return not bool(contents)\n\n    else:\n        return not fp.peek()", "code_tokens": "def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )", "docstring_tokens": "Determine if a file is empty or not .", "label": 1}, {"idx": "cosqa-train-10451", "doc": "python catch and raise same excepiton", "code": "def reraise(error):\n    \"\"\"Re-raises the error that was processed by prepare_for_reraise earlier.\"\"\"\n    if hasattr(error, \"_type_\"):\n        six.reraise(type(error), error, error._traceback)\n    raise error", "code_tokens": "def reraise ( error ) : if hasattr ( error , \"_type_\" ) : six . reraise ( type ( error ) , error , error . _traceback ) raise error", "docstring_tokens": "Re - raises the error that was processed by prepare_for_reraise earlier .", "label": 1}, {"idx": "cosqa-train-10452", "doc": "test if multiple variables are none python", "code": "def _not_none(items):\n    \"\"\"Whether the item is a placeholder or contains a placeholder.\"\"\"\n    if not isinstance(items, (tuple, list)):\n        items = (items,)\n    return all(item is not _none for item in items)", "code_tokens": "def _not_none ( items ) : if not isinstance ( items , ( tuple , list ) ) : items = ( items , ) return all ( item is not _none for item in items )", "docstring_tokens": "Whether the item is a placeholder or contains a placeholder .", "label": 1}, {"idx": "cosqa-train-10453", "doc": "python caught sigwinch, shutting down gracefully", "code": "def signal_handler(signal_name, frame):\n    \"\"\"Quit signal handler.\"\"\"\n    sys.stdout.flush()\n    print(\"\\nSIGINT in frame signal received. Quitting...\")\n    sys.stdout.flush()\n    sys.exit(0)", "code_tokens": "def signal_handler ( signal_name , frame ) : sys . stdout . flush ( ) print ( \"\\nSIGINT in frame signal received. Quitting...\" ) sys . stdout . flush ( ) sys . exit ( 0 )", "docstring_tokens": "Quit signal handler .", "label": 1}, {"idx": "cosqa-train-10454", "doc": "test the number of characters in python list", "code": "def token_list_len(tokenlist):\n    \"\"\"\n    Return the amount of characters in this token list.\n\n    :param tokenlist: List of (token, text) or (token, text, mouse_handler)\n                      tuples.\n    \"\"\"\n    ZeroWidthEscape = Token.ZeroWidthEscape\n    return sum(len(item[1]) for item in tokenlist if item[0] != ZeroWidthEscape)", "code_tokens": "def token_list_len ( tokenlist ) : ZeroWidthEscape = Token . ZeroWidthEscape return sum ( len ( item [ 1 ] ) for item in tokenlist if item [ 0 ] != ZeroWidthEscape )", "docstring_tokens": "Return the amount of characters in this token list .", "label": 1}, {"idx": "cosqa-train-10455", "doc": "python chaining filter functions", "code": "def filter(self, func):\n        \"\"\"Returns a SndRcv list filtered by a truth function\"\"\"\n        return self.__class__( [ i for i in self.res if func(*i) ], name='filtered %s'%self.listname)", "code_tokens": "def filter ( self , func ) : return self . __class__ ( [ i for i in self . res if func ( * i ) ] , name = 'filtered %s' % self . listname )", "docstring_tokens": "Returns a SndRcv list filtered by a truth function", "label": 1}, {"idx": "cosqa-train-10456", "doc": "testing the symbol set with nested brackets in python", "code": "def is_SYMBOL(token, *symbols):\n    \"\"\" Returns True if ALL of the given argument are AST nodes\n    of the given token (e.g. 'BINARY')\n    \"\"\"\n    from symbols.symbol_ import Symbol\n    assert all(isinstance(x, Symbol) for x in symbols)\n    for sym in symbols:\n        if sym.token != token:\n            return False\n\n    return True", "code_tokens": "def is_SYMBOL ( token , * symbols ) : from symbols . symbol_ import Symbol assert all ( isinstance ( x , Symbol ) for x in symbols ) for sym in symbols : if sym . token != token : return False return True", "docstring_tokens": "Returns True if ALL of the given argument are AST nodes of the given token ( e . g . BINARY )", "label": 1}, {"idx": "cosqa-train-10457", "doc": "python chang fraction to decimal number in string", "code": "def format_float(value): # not used\n    \"\"\"Modified form of the 'g' format specifier.\n    \"\"\"\n    string = \"{:g}\".format(value).replace(\"e+\", \"e\")\n    string = re.sub(\"e(-?)0*(\\d+)\", r\"e\\1\\2\", string)\n    return string", "code_tokens": "def format_float ( value ) : # not used string = \"{:g}\" . format ( value ) . replace ( \"e+\" , \"e\" ) string = re . sub ( \"e(-?)0*(\\d+)\" , r\"e\\1\\2\" , string ) return string", "docstring_tokens": "Modified form of the g format specifier .", "label": 1}, {"idx": "cosqa-train-10458", "doc": "text replace with dictionary python multiple values full match", "code": "def replace_all(text, dic):\n    \"\"\"Takes a string and dictionary. replaces all occurrences of i with j\"\"\"\n\n    for i, j in dic.iteritems():\n        text = text.replace(i, j)\n    return text", "code_tokens": "def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text", "docstring_tokens": "Takes a string and dictionary . replaces all occurrences of i with j", "label": 1}, {"idx": "cosqa-train-10459", "doc": "python change backward slash to forward slash", "code": "def norm_slash(name):\n    \"\"\"Normalize path slashes.\"\"\"\n\n    if isinstance(name, str):\n        return name.replace('/', \"\\\\\") if not is_case_sensitive() else name\n    else:\n        return name.replace(b'/', b\"\\\\\") if not is_case_sensitive() else name", "code_tokens": "def norm_slash ( name ) : if isinstance ( name , str ) : return name . replace ( '/' , \"\\\\\" ) if not is_case_sensitive ( ) else name else : return name . replace ( b'/' , b\"\\\\\" ) if not is_case_sensitive ( ) else name", "docstring_tokens": "Normalize path slashes .", "label": 1}, {"idx": "cosqa-train-10460", "doc": "textwrap python doensnt work", "code": "def wrap(text, indent='    '):\n    \"\"\"Wrap text to terminal width with default indentation\"\"\"\n    wrapper = textwrap.TextWrapper(\n        width=int(os.environ.get('COLUMNS', 80)),\n        initial_indent=indent,\n        subsequent_indent=indent\n    )\n    return '\\n'.join(wrapper.wrap(text))", "code_tokens": "def wrap ( text , indent = '    ' ) : wrapper = textwrap . TextWrapper ( width = int ( os . environ . get ( 'COLUMNS' , 80 ) ) , initial_indent = indent , subsequent_indent = indent ) return '\\n' . join ( wrapper . wrap ( text ) )", "docstring_tokens": "Wrap text to terminal width with default indentation", "label": 1}, {"idx": "cosqa-train-10461", "doc": "python change column string to boolean true", "code": "def _check_and_convert_bools(self):\n        \"\"\"Replace boolean variables by the characters 'F'/'T'\n        \"\"\"\n        replacements = {\n            True: 'T',\n            False: 'F',\n        }\n\n        for key in self.bools:\n            if isinstance(self[key], bool):\n                self[key] = replacements[self[key]]", "code_tokens": "def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]", "docstring_tokens": "Replace boolean variables by the characters F / T", "label": 0}, {"idx": "cosqa-train-10462", "doc": "the order of an element in an index python", "code": "def get_feature_order(dataset, features):\n    \"\"\" Returns a list with the order that features requested appear in\n    dataset \"\"\"\n    all_features = dataset.get_feature_names()\n\n    i = [all_features.index(f) for f in features]\n\n    return i", "code_tokens": "def get_feature_order ( dataset , features ) : all_features = dataset . get_feature_names ( ) i = [ all_features . index ( f ) for f in features ] return i", "docstring_tokens": "Returns a list with the order that features requested appear in dataset", "label": 1}, {"idx": "cosqa-train-10463", "doc": "python change directory decorate", "code": "def change_dir(directory):\n  \"\"\"\n  Wraps a function to run in a given directory.\n\n  \"\"\"\n  def cd_decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n      org_path = os.getcwd()\n      os.chdir(directory)\n      func(*args, **kwargs)\n      os.chdir(org_path)\n    return wrapper\n  return cd_decorator", "code_tokens": "def change_dir ( directory ) : def cd_decorator ( func ) : @ wraps ( func ) def wrapper ( * args , * * kwargs ) : org_path = os . getcwd ( ) os . chdir ( directory ) func ( * args , * * kwargs ) os . chdir ( org_path ) return wrapper return cd_decorator", "docstring_tokens": "Wraps a function to run in a given directory .", "label": 1}, {"idx": "cosqa-train-10464", "doc": "time in am/pm in python to utc time", "code": "def datetime_local_to_utc(local):\n    \"\"\"\n    Simple function to convert naive :std:`datetime.datetime` object containing\n    local time to a naive :std:`datetime.datetime` object with UTC time.\n    \"\"\"\n    timestamp = time.mktime(local.timetuple())\n    return datetime.datetime.utcfromtimestamp(timestamp)", "code_tokens": "def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )", "docstring_tokens": "Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time .", "label": 1}, {"idx": "cosqa-train-10465", "doc": "python change file permissions linux", "code": "def add_exec_permission_to(target_file):\n    \"\"\"Add executable permissions to the file\n\n    :param target_file: the target file whose permission to be changed\n    \"\"\"\n    mode = os.stat(target_file).st_mode\n    os.chmod(target_file, mode | stat.S_IXUSR)", "code_tokens": "def add_exec_permission_to ( target_file ) : mode = os . stat ( target_file ) . st_mode os . chmod ( target_file , mode | stat . S_IXUSR )", "docstring_tokens": "Add executable permissions to the file", "label": 0}, {"idx": "cosqa-train-10466", "doc": "timestamp string to datetime python", "code": "def date_to_timestamp(date):\n    \"\"\"\n        date to unix timestamp in milliseconds\n    \"\"\"\n    date_tuple = date.timetuple()\n    timestamp = calendar.timegm(date_tuple) * 1000\n    return timestamp", "code_tokens": "def date_to_timestamp ( date ) : date_tuple = date . timetuple ( ) timestamp = calendar . timegm ( date_tuple ) * 1000 return timestamp", "docstring_tokens": "date to unix timestamp in milliseconds", "label": 0}, {"idx": "cosqa-train-10467", "doc": "python change function values with slider", "code": "def _update_plot(self, _):\n        \"\"\"Callback to redraw the plot to reflect the new parameter values.\"\"\"\n        # Since all sliders call this same callback without saying who they are\n        # I need to update the values for all parameters. This can be\n        # circumvented by creating a seperate callback function for each\n        # parameter.\n        for param in self.model.params:\n            param.value = self._sliders[param].val\n        for indep_var, dep_var in self._projections:\n            self._update_specific_plot(indep_var, dep_var)", "code_tokens": "def _update_plot ( self , _ ) : # Since all sliders call this same callback without saying who they are # I need to update the values for all parameters. This can be # circumvented by creating a seperate callback function for each # parameter. for param in self . model . params : param . value = self . _sliders [ param ] . val for indep_var , dep_var in self . _projections : self . _update_specific_plot ( indep_var , dep_var )", "docstring_tokens": "Callback to redraw the plot to reflect the new parameter values .", "label": 1}, {"idx": "cosqa-train-10468", "doc": "to check the data type of each column in python", "code": "def _maybe_pandas_data(data, feature_names, feature_types):\n    \"\"\" Extract internal data from pd.DataFrame for DMatrix data \"\"\"\n\n    if not isinstance(data, DataFrame):\n        return data, feature_names, feature_types\n\n    data_dtypes = data.dtypes\n    if not all(dtype.name in PANDAS_DTYPE_MAPPER for dtype in data_dtypes):\n        bad_fields = [data.columns[i] for i, dtype in\n                      enumerate(data_dtypes) if dtype.name not in PANDAS_DTYPE_MAPPER]\n\n        msg = \"\"\"DataFrame.dtypes for data must be int, float or bool.\n                Did not expect the data types in fields \"\"\"\n        raise ValueError(msg + ', '.join(bad_fields))\n\n    if feature_names is None:\n        if isinstance(data.columns, MultiIndex):\n            feature_names = [\n                ' '.join([str(x) for x in i])\n                for i in data.columns\n            ]\n        else:\n            feature_names = data.columns.format()\n\n    if feature_types is None:\n        feature_types = [PANDAS_DTYPE_MAPPER[dtype.name] for dtype in data_dtypes]\n\n    data = data.values.astype('float')\n\n    return data, feature_names, feature_types", "code_tokens": "def _maybe_pandas_data ( data , feature_names , feature_types ) : if not isinstance ( data , DataFrame ) : return data , feature_names , feature_types data_dtypes = data . dtypes if not all ( dtype . name in PANDAS_DTYPE_MAPPER for dtype in data_dtypes ) : bad_fields = [ data . columns [ i ] for i , dtype in enumerate ( data_dtypes ) if dtype . name not in PANDAS_DTYPE_MAPPER ] msg = \"\"\"DataFrame.dtypes for data must be int, float or bool.\n                Did not expect the data types in fields \"\"\" raise ValueError ( msg + ', ' . join ( bad_fields ) ) if feature_names is None : if isinstance ( data . columns , MultiIndex ) : feature_names = [ ' ' . join ( [ str ( x ) for x in i ] ) for i in data . columns ] else : feature_names = data . columns . format ( ) if feature_types is None : feature_types = [ PANDAS_DTYPE_MAPPER [ dtype . name ] for dtype in data_dtypes ] data = data . values . astype ( 'float' ) return data , feature_names , feature_types", "docstring_tokens": "Extract internal data from pd . DataFrame for DMatrix data", "label": 0}, {"idx": "cosqa-train-10469", "doc": "python change index name of a df", "code": "def _update_index_on_df(df, index_names):\n    \"\"\"Helper function to restore index information after collection. Doesn't\n    use self so we can serialize this.\"\"\"\n    if index_names:\n        df = df.set_index(index_names)\n        # Remove names from unnamed indexes\n        index_names = _denormalize_index_names(index_names)\n        df.index.names = index_names\n    return df", "code_tokens": "def _update_index_on_df ( df , index_names ) : if index_names : df = df . set_index ( index_names ) # Remove names from unnamed indexes index_names = _denormalize_index_names ( index_names ) df . index . names = index_names return df", "docstring_tokens": "Helper function to restore index information after collection . Doesn t use self so we can serialize this .", "label": 0}, {"idx": "cosqa-train-10470", "doc": "to impute missing values in python", "code": "def impute_data(self,x):\n        \"\"\"Imputes data set containing Nan values\"\"\"\n        imp = Imputer(missing_values='NaN', strategy='mean', axis=0)\n        return imp.fit_transform(x)", "code_tokens": "def impute_data ( self , x ) : imp = Imputer ( missing_values = 'NaN' , strategy = 'mean' , axis = 0 ) return imp . fit_transform ( x )", "docstring_tokens": "Imputes data set containing Nan values", "label": 1}, {"idx": "cosqa-train-10471", "doc": "python change the shape of list", "code": "def shape_list(l,shape,dtype):\n    \"\"\" Shape a list of lists into the appropriate shape and data type \"\"\"\n    return np.array(l, dtype=dtype).reshape(shape)", "code_tokens": "def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )", "docstring_tokens": "Shape a list of lists into the appropriate shape and data type", "label": 1}, {"idx": "cosqa-train-10472", "doc": "to many indexers in python", "code": "def convert_from_missing_indexer_tuple(indexer, axes):\n    \"\"\"\n    create a filtered indexer that doesn't have any missing indexers\n    \"\"\"\n\n    def get_indexer(_i, _idx):\n        return (axes[_i].get_loc(_idx['key']) if isinstance(_idx, dict) else\n                _idx)\n\n    return tuple(get_indexer(_i, _idx) for _i, _idx in enumerate(indexer))", "code_tokens": "def convert_from_missing_indexer_tuple ( indexer , axes ) : def get_indexer ( _i , _idx ) : return ( axes [ _i ] . get_loc ( _idx [ 'key' ] ) if isinstance ( _idx , dict ) else _idx ) return tuple ( get_indexer ( _i , _idx ) for _i , _idx in enumerate ( indexer ) )", "docstring_tokens": "create a filtered indexer that doesn t have any missing indexers", "label": 0}, {"idx": "cosqa-train-10473", "doc": "python change user to root", "code": "def _is_root():\n    \"\"\"Checks if the user is rooted.\"\"\"\n    import os\n    import ctypes\n    try:\n        return os.geteuid() == 0\n    except AttributeError:\n        return ctypes.windll.shell32.IsUserAnAdmin() != 0\n    return False", "code_tokens": "def _is_root ( ) : import os import ctypes try : return os . geteuid ( ) == 0 except AttributeError : return ctypes . windll . shell32 . IsUserAnAdmin ( ) != 0 return False", "docstring_tokens": "Checks if the user is rooted .", "label": 1}, {"idx": "cosqa-train-10474", "doc": "tracking centroid of an object python", "code": "def compute_centroid(points):\n    \"\"\" Computes the centroid of set of points\n\n    Args:\n        points (:obj:`list` of :obj:`Point`)\n    Returns:\n        :obj:`Point`\n    \"\"\"\n    lats = [p[1] for p in points]\n    lons = [p[0] for p in points]\n    return Point(np.mean(lats), np.mean(lons), None)", "code_tokens": "def compute_centroid ( points ) : lats = [ p [ 1 ] for p in points ] lons = [ p [ 0 ] for p in points ] return Point ( np . mean ( lats ) , np . mean ( lons ) , None )", "docstring_tokens": "Computes the centroid of set of points", "label": 1}, {"idx": "cosqa-train-10475", "doc": "python change variables in outer scope", "code": "def scopes_as(self, new_scopes):\n        \"\"\"Replace my :attr:`scopes` for the duration of the with block.\n\n        My global scope is not replaced.\n\n        Args:\n            new_scopes (list of dict-likes): The new :attr:`scopes` to use.\n        \"\"\"\n        old_scopes, self.scopes = self.scopes, new_scopes\n        yield\n        self.scopes = old_scopes", "code_tokens": "def scopes_as ( self , new_scopes ) : old_scopes , self . scopes = self . scopes , new_scopes yield self . scopes = old_scopes", "docstring_tokens": "Replace my : attr : scopes for the duration of the with block .", "label": 1}, {"idx": "cosqa-train-10476", "doc": "training mnist data python", "code": "def get_mnist(data_type=\"train\", location=\"/tmp/mnist\"):\n    \"\"\"\n    Get mnist dataset with features and label as ndarray.\n    Data would be downloaded automatically if it doesn't present at the specific location.\n\n    :param data_type: \"train\" for training data and \"test\" for testing data.\n    :param location: Location to store mnist dataset.\n    :return: (features: ndarray, label: ndarray)\n    \"\"\"\n    X, Y = mnist.read_data_sets(location, data_type)\n    return X, Y + 1", "code_tokens": "def get_mnist ( data_type = \"train\" , location = \"/tmp/mnist\" ) : X , Y = mnist . read_data_sets ( location , data_type ) return X , Y + 1", "docstring_tokens": "Get mnist dataset with features and label as ndarray . Data would be downloaded automatically if it doesn t present at the specific location .", "label": 1}, {"idx": "cosqa-train-10477", "doc": "python check array of strings", "code": "def all_strings(arr):\n        \"\"\"\n        Ensures that the argument is a list that either is empty or contains only strings\n        :param arr: list\n        :return:\n        \"\"\"\n        if not isinstance([], list):\n            raise TypeError(\"non-list value found where list is expected\")\n        return all(isinstance(x, str) for x in arr)", "code_tokens": "def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( \"non-list value found where list is expected\" ) return all ( isinstance ( x , str ) for x in arr )", "docstring_tokens": "Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return :", "label": 1}, {"idx": "cosqa-train-10478", "doc": "transfer column string to date type in python", "code": "def convert_str_to_datetime(df, *, column: str, format: str):\n    \"\"\"\n    Convert string column into datetime column\n\n    ---\n\n    ### Parameters\n\n    *mandatory :*\n    - `column` (*str*): name of the column to format\n    - `format` (*str*): current format of the values (see [available formats](\n    https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior))\n    \"\"\"\n    df[column] = pd.to_datetime(df[column], format=format)\n    return df", "code_tokens": "def convert_str_to_datetime ( df , * , column : str , format : str ) : df [ column ] = pd . to_datetime ( df [ column ] , format = format ) return df", "docstring_tokens": "Convert string column into datetime column", "label": 1}, {"idx": "cosqa-train-10479", "doc": "python check datetime instance", "code": "def is_datetime_like(dtype):\n    \"\"\"Check if a dtype is a subclass of the numpy datetime types\n    \"\"\"\n    return (np.issubdtype(dtype, np.datetime64) or\n            np.issubdtype(dtype, np.timedelta64))", "code_tokens": "def is_datetime_like ( dtype ) : return ( np . issubdtype ( dtype , np . datetime64 ) or np . issubdtype ( dtype , np . timedelta64 ) )", "docstring_tokens": "Check if a dtype is a subclass of the numpy datetime types", "label": 0}, {"idx": "cosqa-train-10480", "doc": "trigger to exit python", "code": "def _quit(self, *args):\n        \"\"\" quit crash \"\"\"\n        self.logger.warn('Bye!')\n        sys.exit(self.exit())", "code_tokens": "def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )", "docstring_tokens": "quit crash", "label": 0}, {"idx": "cosqa-train-10481", "doc": "python check exact one parametars", "code": "def any_of(value, *args):\n    \"\"\" At least one of the items in value should match \"\"\"\n\n    if len(args):\n        value = (value,) + args\n\n    return ExpectationAny(value)", "code_tokens": "def any_of ( value , * args ) : if len ( args ) : value = ( value , ) + args return ExpectationAny ( value )", "docstring_tokens": "At least one of the items in value should match", "label": 1}, {"idx": "cosqa-train-10482", "doc": "turn dictionary into query string python", "code": "def dict_to_querystring(dictionary):\n    \"\"\"Converts a dict to a querystring suitable to be appended to a URL.\"\"\"\n    s = u\"\"\n    for d in dictionary.keys():\n        s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d])\n    return s[:-1]", "code_tokens": "def dict_to_querystring ( dictionary ) : s = u\"\" for d in dictionary . keys ( ) : s = unicode . format ( u\"{0}{1}={2}&\" , s , d , dictionary [ d ] ) return s [ : - 1 ]", "docstring_tokens": "Converts a dict to a querystring suitable to be appended to a URL .", "label": 1}, {"idx": "cosqa-train-10483", "doc": "python check folder exist then create", "code": "def check_create_folder(filename):\n    \"\"\"Check if the folder exisits. If not, create the folder\"\"\"\n    os.makedirs(os.path.dirname(filename), exist_ok=True)", "code_tokens": "def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )", "docstring_tokens": "Check if the folder exisits . If not create the folder", "label": 1}, {"idx": "cosqa-train-10484", "doc": "turn fractions in a function to decimals python", "code": "def round_float(f, digits, rounding=ROUND_HALF_UP):\n    \"\"\"\n    Accurate float rounding from http://stackoverflow.com/a/15398691.\n    \"\"\"\n    return Decimal(str(f)).quantize(Decimal(10) ** (-1 * digits),\n                                    rounding=rounding)", "code_tokens": "def round_float ( f , digits , rounding = ROUND_HALF_UP ) : return Decimal ( str ( f ) ) . quantize ( Decimal ( 10 ) ** ( - 1 * digits ) , rounding = rounding )", "docstring_tokens": "Accurate float rounding from http : // stackoverflow . com / a / 15398691 .", "label": 1}, {"idx": "cosqa-train-10485", "doc": "python check for 200 status code", "code": "def raise_for_not_ok_status(response):\n    \"\"\"\n    Raises a `requests.exceptions.HTTPError` if the response has a non-200\n    status code.\n    \"\"\"\n    if response.code != OK:\n        raise HTTPError('Non-200 response code (%s) for url: %s' % (\n            response.code, uridecode(response.request.absoluteURI)))\n\n    return response", "code_tokens": "def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response", "docstring_tokens": "Raises a requests . exceptions . HTTPError if the response has a non - 200 status code .", "label": 1}, {"idx": "cosqa-train-10486", "doc": "turn string elements separated by commas into list python", "code": "def split_elements(value):\n    \"\"\"Split a string with comma or space-separated elements into a list.\"\"\"\n    l = [v.strip() for v in value.split(',')]\n    if len(l) == 1:\n        l = value.split()\n    return l", "code_tokens": "def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l", "docstring_tokens": "Split a string with comma or space - separated elements into a list .", "label": 0}, {"idx": "cosqa-train-10487", "doc": "python check for attribute to exist", "code": "def has_attribute(module_name, attribute_name):\n    \"\"\"Is this attribute present?\"\"\"\n    init_file = '%s/__init__.py' % module_name\n    return any(\n        [attribute_name in init_line for init_line in open(init_file).readlines()]\n    )", "code_tokens": "def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )", "docstring_tokens": "Is this attribute present?", "label": 1}, {"idx": "cosqa-train-10488", "doc": "turn string to json python", "code": "def serialize_json_string(self, value):\n        \"\"\"\n        Tries to load an encoded json string back into an object\n        :param json_string:\n        :return:\n        \"\"\"\n\n        # Check if the value might be a json string\n        if not isinstance(value, six.string_types):\n            return value\n\n        # Make sure it starts with a brace\n        if not value.startswith('{') or value.startswith('['):\n            return value\n\n        # Try to load the string\n        try:\n            return json.loads(value)\n        except:\n            return value", "code_tokens": "def serialize_json_string ( self , value ) : # Check if the value might be a json string if not isinstance ( value , six . string_types ) : return value # Make sure it starts with a brace if not value . startswith ( '{' ) or value . startswith ( '[' ) : return value # Try to load the string try : return json . loads ( value ) except : return value", "docstring_tokens": "Tries to load an encoded json string back into an object : param json_string : : return :", "label": 0}, {"idx": "cosqa-train-10489", "doc": "python check http connection", "code": "def is_http_running_on(port):\n  \"\"\" Check if an http server runs on a given port.\n\n  Args:\n    The port to check.\n  Returns:\n    True if it is used by an http server. False otherwise.\n  \"\"\"\n  try:\n    conn = httplib.HTTPConnection('127.0.0.1:' + str(port))\n    conn.connect()\n    conn.close()\n    return True\n  except Exception:\n    return False", "code_tokens": "def is_http_running_on ( port ) : try : conn = httplib . HTTPConnection ( '127.0.0.1:' + str ( port ) ) conn . connect ( ) conn . close ( ) return True except Exception : return False", "docstring_tokens": "Check if an http server runs on a given port .", "label": 1}, {"idx": "cosqa-train-10490", "doc": "turn string to list commas python", "code": "def split_elements(value):\n    \"\"\"Split a string with comma or space-separated elements into a list.\"\"\"\n    l = [v.strip() for v in value.split(',')]\n    if len(l) == 1:\n        l = value.split()\n    return l", "code_tokens": "def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l", "docstring_tokens": "Split a string with comma or space - separated elements into a list .", "label": 1}, {"idx": "cosqa-train-10491", "doc": "python check if a field exists in a object", "code": "def has_field(mc, field_name):\n    \"\"\"\n    detect if a model has a given field has\n\n    :param field_name:\n    :param mc:\n    :return:\n    \"\"\"\n    try:\n        mc._meta.get_field(field_name)\n    except FieldDoesNotExist:\n        return False\n    return True", "code_tokens": "def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True", "docstring_tokens": "detect if a model has a given field has", "label": 1}, {"idx": "cosqa-train-10492", "doc": "turning a multidict into a dict python", "code": "def multidict_to_dict(d):\n    \"\"\"\n    Turns a werkzeug.MultiDict or django.MultiValueDict into a dict with\n    list values\n    :param d: a MultiDict or MultiValueDict instance\n    :return: a dict instance\n    \"\"\"\n    return dict((k, v[0] if len(v) == 1 else v) for k, v in iterlists(d))", "code_tokens": "def multidict_to_dict ( d ) : return dict ( ( k , v [ 0 ] if len ( v ) == 1 else v ) for k , v in iterlists ( d ) )", "docstring_tokens": "Turns a werkzeug . MultiDict or django . MultiValueDict into a dict with list values : param d : a MultiDict or MultiValueDict instance : return : a dict instance", "label": 1}, {"idx": "cosqa-train-10493", "doc": "python check if a path is a file", "code": "def is_file(path):\n    \"\"\"Determine if a Path or string is a file on the file system.\"\"\"\n    try:\n        return path.expanduser().absolute().is_file()\n    except AttributeError:\n        return os.path.isfile(os.path.abspath(os.path.expanduser(str(path))))", "code_tokens": "def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )", "docstring_tokens": "Determine if a Path or string is a file on the file system .", "label": 1}, {"idx": "cosqa-train-10494", "doc": "type hinting python style", "code": "def make_kind_check(python_types, numpy_kind):\n    \"\"\"\n    Make a function that checks whether a scalar or array is of a given kind\n    (e.g. float, int, datetime, timedelta).\n    \"\"\"\n    def check(value):\n        if hasattr(value, 'dtype'):\n            return value.dtype.kind == numpy_kind\n        return isinstance(value, python_types)\n    return check", "code_tokens": "def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check", "docstring_tokens": "Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) .", "label": 1}, {"idx": "cosqa-train-10495", "doc": "python check if a string is only punctuation", "code": "def is_delimiter(line):\n    \"\"\" True if a line consists only of a single punctuation character.\"\"\"\n    return bool(line) and line[0] in punctuation and line[0]*len(line) == line", "code_tokens": "def is_delimiter ( line ) : return bool ( line ) and line [ 0 ] in punctuation and line [ 0 ] * len ( line ) == line", "docstring_tokens": "True if a line consists only of a single punctuation character .", "label": 0}, {"idx": "cosqa-train-10496", "doc": "type of string in python", "code": "def visit_Str(self, node):\n        \"\"\" Set the pythonic string type. \"\"\"\n        self.result[node] = self.builder.NamedType(pytype_to_ctype(str))", "code_tokens": "def visit_Str ( self , node ) : self . result [ node ] = self . builder . NamedType ( pytype_to_ctype ( str ) )", "docstring_tokens": "Set the pythonic string type .", "label": 1}, {"idx": "cosqa-train-10497", "doc": "python check if all elements in a list are the same", "code": "def _check_elements_equal(lst):\n    \"\"\"\n    Returns true if all of the elements in the list are equal.\n    \"\"\"\n    assert isinstance(lst, list), \"Input value must be a list.\"\n    return not lst or lst.count(lst[0]) == len(lst)", "code_tokens": "def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , \"Input value must be a list.\" return not lst or lst . count ( lst [ 0 ] ) == len ( lst )", "docstring_tokens": "Returns true if all of the elements in the list are equal .", "label": 0}, {"idx": "cosqa-train-10498", "doc": "typecasting in python string to boolean", "code": "def FromString(self, string):\n    \"\"\"Parse a bool from a string.\"\"\"\n    if string.lower() in (\"false\", \"no\", \"n\"):\n      return False\n\n    if string.lower() in (\"true\", \"yes\", \"y\"):\n      return True\n\n    raise TypeValueError(\"%s is not recognized as a boolean value.\" % string)", "code_tokens": "def FromString ( self , string ) : if string . lower ( ) in ( \"false\" , \"no\" , \"n\" ) : return False if string . lower ( ) in ( \"true\" , \"yes\" , \"y\" ) : return True raise TypeValueError ( \"%s is not recognized as a boolean value.\" % string )", "docstring_tokens": "Parse a bool from a string .", "label": 1}, {"idx": "cosqa-train-10499", "doc": "python check if an array contains a given range of values", "code": "def are_in_interval(s, l, r, border = 'included'):\n        \"\"\"\n        Checks whether all number in the sequence s lie inside the interval formed by\n        l and r.\n        \"\"\"\n        return numpy.all([IntensityRangeStandardization.is_in_interval(x, l, r, border) for x in s])", "code_tokens": "def are_in_interval ( s , l , r , border = 'included' ) : return numpy . all ( [ IntensityRangeStandardization . is_in_interval ( x , l , r , border ) for x in s ] )", "docstring_tokens": "Checks whether all number in the sequence s lie inside the interval formed by l and r .", "label": 0}, {"idx": "cosqa-train-10500", "doc": "ubuntu python max memory", "code": "def peak_memory_usage():\n    \"\"\"Return peak memory usage in MB\"\"\"\n    if sys.platform.startswith('win'):\n        p = psutil.Process()\n        return p.memory_info().peak_wset / 1024 / 1024\n\n    mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss\n    factor_mb = 1 / 1024\n    if sys.platform == 'darwin':\n        factor_mb = 1 / (1024 * 1024)\n    return mem * factor_mb", "code_tokens": "def peak_memory_usage ( ) : if sys . platform . startswith ( 'win' ) : p = psutil . Process ( ) return p . memory_info ( ) . peak_wset / 1024 / 1024 mem = resource . getrusage ( resource . RUSAGE_SELF ) . ru_maxrss factor_mb = 1 / 1024 if sys . platform == 'darwin' : factor_mb = 1 / ( 1024 * 1024 ) return mem * factor_mb", "docstring_tokens": "Return peak memory usage in MB", "label": 1}, {"idx": "cosqa-train-10501", "doc": "python check if case insensitive substring exists", "code": "def contains_case_insensitive(adict, akey):\n    \"\"\"Check if key is in adict. The search is case insensitive.\"\"\"\n    for key in adict:\n        if key.lower() == akey.lower():\n            return True\n    return False", "code_tokens": "def contains_case_insensitive ( adict , akey ) : for key in adict : if key . lower ( ) == akey . lower ( ) : return True return False", "docstring_tokens": "Check if key is in adict . The search is case insensitive .", "label": 1}, {"idx": "cosqa-train-10502", "doc": "uniquifying a list in python", "code": "def uniquify_list(L):\n    \"\"\"Same order unique list using only a list compression.\"\"\"\n    return [e for i, e in enumerate(L) if L.index(e) == i]", "code_tokens": "def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]", "docstring_tokens": "Same order unique list using only a list compression .", "label": 0}, {"idx": "cosqa-train-10503", "doc": "python check if complex number function", "code": "def is_complex(dtype):\n  \"\"\"Returns whether this is a complex floating point type.\"\"\"\n  dtype = tf.as_dtype(dtype)\n  if hasattr(dtype, 'is_complex'):\n    return dtype.is_complex\n  return np.issubdtype(np.dtype(dtype), np.complex)", "code_tokens": "def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )", "docstring_tokens": "Returns whether this is a complex floating point type .", "label": 1}, {"idx": "cosqa-train-10504", "doc": "unix timestamp to utc offset python", "code": "def datetime_to_timestamp(dt):\n    \"\"\"Convert a UTC datetime to a Unix timestamp\"\"\"\n    delta = dt - datetime.utcfromtimestamp(0)\n    return delta.seconds + delta.days * 24 * 3600", "code_tokens": "def datetime_to_timestamp ( dt ) : delta = dt - datetime . utcfromtimestamp ( 0 ) return delta . seconds + delta . days * 24 * 3600", "docstring_tokens": "Convert a UTC datetime to a Unix timestamp", "label": 1}, {"idx": "cosqa-train-10505", "doc": "python check if database can be reached", "code": "def exists(self):\n        \"\"\"\n        Performs an existence check on the remote database.\n\n        :returns: Boolean True if the database exists, False otherwise\n        \"\"\"\n        resp = self.r_session.head(self.database_url)\n        if resp.status_code not in [200, 404]:\n            resp.raise_for_status()\n\n        return resp.status_code == 200", "code_tokens": "def exists ( self ) : resp = self . r_session . head ( self . database_url ) if resp . status_code not in [ 200 , 404 ] : resp . raise_for_status ( ) return resp . status_code == 200", "docstring_tokens": "Performs an existence check on the remote database .", "label": 1}, {"idx": "cosqa-train-10506", "doc": "unix utc to local time python", "code": "def datetime_local_to_utc(local):\n    \"\"\"\n    Simple function to convert naive :std:`datetime.datetime` object containing\n    local time to a naive :std:`datetime.datetime` object with UTC time.\n    \"\"\"\n    timestamp = time.mktime(local.timetuple())\n    return datetime.datetime.utcfromtimestamp(timestamp)", "code_tokens": "def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )", "docstring_tokens": "Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time .", "label": 1}, {"idx": "cosqa-train-10507", "doc": "update elasticsearch index python", "code": "def update_index(index):\n    \"\"\"Re-index every document in a named index.\"\"\"\n    logger.info(\"Updating search index: '%s'\", index)\n    client = get_client()\n    responses = []\n    for model in get_index_models(index):\n        logger.info(\"Updating search index model: '%s'\", model.search_doc_type)\n        objects = model.objects.get_search_queryset(index).iterator()\n        actions = bulk_actions(objects, index=index, action=\"index\")\n        response = helpers.bulk(client, actions, chunk_size=get_setting(\"chunk_size\"))\n        responses.append(response)\n    return responses", "code_tokens": "def update_index ( index ) : logger . info ( \"Updating search index: '%s'\" , index ) client = get_client ( ) responses = [ ] for model in get_index_models ( index ) : logger . info ( \"Updating search index model: '%s'\" , model . search_doc_type ) objects = model . objects . get_search_queryset ( index ) . iterator ( ) actions = bulk_actions ( objects , index = index , action = \"index\" ) response = helpers . bulk ( client , actions , chunk_size = get_setting ( \"chunk_size\" ) ) responses . append ( response ) return responses", "docstring_tokens": "Re - index every document in a named index .", "label": 0}, {"idx": "cosqa-train-10508", "doc": "python check if email is valid", "code": "def is_valid_email(email):\n    \"\"\"\n    Check if email is valid\n    \"\"\"\n    pattern = re.compile(r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+')\n    return bool(pattern.match(email))", "code_tokens": "def is_valid_email ( email ) : pattern = re . compile ( r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+' ) return bool ( pattern . match ( email ) )", "docstring_tokens": "Check if email is valid", "label": 0}, {"idx": "cosqa-train-10509", "doc": "usage of any/all in python", "code": "def All(sequence):\n  \"\"\"\n  :param sequence: Any sequence whose elements can be evaluated as booleans.\n  :returns: true if all elements of the sequence satisfy True and x.\n  \"\"\"\n  return bool(reduce(lambda x, y: x and y, sequence, True))", "code_tokens": "def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )", "docstring_tokens": ": param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x .", "label": 0}, {"idx": "cosqa-train-10510", "doc": "python check if file exists without permission", "code": "def readable(path):\n    \"\"\"Test whether a path exists and is readable.  Returns None for\n    broken symbolic links or a failing stat() and False if\n    the file exists but does not have read permission. True is returned\n    if the file is readable.\"\"\"\n    try:\n        st = os.stat(path)\n        return 0 != st.st_mode & READABLE_MASK\n    except os.error:\n        return None\n    return True", "code_tokens": "def readable ( path ) : try : st = os . stat ( path ) return 0 != st . st_mode & READABLE_MASK except os . error : return None return True", "docstring_tokens": "Test whether a path exists and is readable . Returns None for broken symbolic links or a failing stat () and False if the file exists but does not have read permission . True is returned if the file is readable .", "label": 1}, {"idx": "cosqa-train-10511", "doc": "using datetime in python on a variable python", "code": "def Timestamp(year, month, day, hour, minute, second):\n    \"\"\"Constructs an object holding a datetime/timestamp value.\"\"\"\n    return datetime.datetime(year, month, day, hour, minute, second)", "code_tokens": "def Timestamp ( year , month , day , hour , minute , second ) : return datetime . datetime ( year , month , day , hour , minute , second )", "docstring_tokens": "Constructs an object holding a datetime / timestamp value .", "label": 1}, {"idx": "cosqa-train-10512", "doc": "python check if is collection", "code": "def is_collection(obj):\n    \"\"\"Tests if an object is a collection.\"\"\"\n\n    col = getattr(obj, '__getitem__', False)\n    val = False if (not col) else True\n\n    if isinstance(obj, basestring):\n        val = False\n\n    return val", "code_tokens": "def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val", "docstring_tokens": "Tests if an object is a collection .", "label": 0}, {"idx": "cosqa-train-10513", "doc": "using element tree to read xml file in python", "code": "def xmltreefromfile(filename):\n    \"\"\"Internal function to read an XML file\"\"\"\n    try:\n        return ElementTree.parse(filename, ElementTree.XMLParser(collect_ids=False))\n    except TypeError:\n        return ElementTree.parse(filename, ElementTree.XMLParser())", "code_tokens": "def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )", "docstring_tokens": "Internal function to read an XML file", "label": 1}, {"idx": "cosqa-train-10514", "doc": "python check if it is a file", "code": "def is_file(path):\n    \"\"\"Determine if a Path or string is a file on the file system.\"\"\"\n    try:\n        return path.expanduser().absolute().is_file()\n    except AttributeError:\n        return os.path.isfile(os.path.abspath(os.path.expanduser(str(path))))", "code_tokens": "def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )", "docstring_tokens": "Determine if a Path or string is a file on the file system .", "label": 1}, {"idx": "cosqa-train-10515", "doc": "using h5py in python 3", "code": "def h5ToDict(h5, readH5pyDataset=True):\n    \"\"\" Read a hdf5 file into a dictionary \"\"\"\n    h = h5py.File(h5, \"r\")\n    ret = unwrapArray(h, recursive=True, readH5pyDataset=readH5pyDataset)\n    if readH5pyDataset: h.close()\n    return ret", "code_tokens": "def h5ToDict ( h5 , readH5pyDataset = True ) : h = h5py . File ( h5 , \"r\" ) ret = unwrapArray ( h , recursive = True , readH5pyDataset = readH5pyDataset ) if readH5pyDataset : h . close ( ) return ret", "docstring_tokens": "Read a hdf5 file into a dictionary", "label": 0}, {"idx": "cosqa-train-10516", "doc": "python check if json file exists", "code": "def information(filename):\n    \"\"\"Returns the file exif\"\"\"\n    check_if_this_file_exist(filename)\n    filename = os.path.abspath(filename)\n    result = get_json(filename)\n    result = result[0]\n    return result", "code_tokens": "def information ( filename ) : check_if_this_file_exist ( filename ) filename = os . path . abspath ( filename ) result = get_json ( filename ) result = result [ 0 ] return result", "docstring_tokens": "Returns the file exif", "label": 1}, {"idx": "cosqa-train-10517", "doc": "using image magick in python in windows", "code": "def imagemagick(color_count, img, magick_command):\n    \"\"\"Call Imagemagick to generate a scheme.\"\"\"\n    flags = [\"-resize\", \"25%\", \"-colors\", str(color_count),\n             \"-unique-colors\", \"txt:-\"]\n    img += \"[0]\"\n\n    return subprocess.check_output([*magick_command, img, *flags]).splitlines()", "code_tokens": "def imagemagick ( color_count , img , magick_command ) : flags = [ \"-resize\" , \"25%\" , \"-colors\" , str ( color_count ) , \"-unique-colors\" , \"txt:-\" ] img += \"[0]\" return subprocess . check_output ( [ * magick_command , img , * flags ] ) . splitlines ( )", "docstring_tokens": "Call Imagemagick to generate a scheme .", "label": 1}, {"idx": "cosqa-train-10518", "doc": "python check if line for multiple strings", "code": "def has_multiline_items(maybe_list: Optional[Sequence[str]]):\n    \"\"\"Check whether one of the items in the list has multiple lines.\"\"\"\n    return maybe_list and any(is_multiline(item) for item in maybe_list)", "code_tokens": "def has_multiline_items ( maybe_list : Optional [ Sequence [ str ] ] ) : return maybe_list and any ( is_multiline ( item ) for item in maybe_list )", "docstring_tokens": "Check whether one of the items in the list has multiple lines .", "label": 0}, {"idx": "cosqa-train-10519", "doc": "using lambda with tuple input python", "code": "def lambda_tuple_converter(func):\n    \"\"\"\n    Converts a Python 2 function as\n      lambda (x,y): x + y\n    In the Python 3 format:\n      lambda x,y : x + y\n    \"\"\"\n    if func is not None and func.__code__.co_argcount == 1:\n        return lambda *args: func(args[0] if len(args) == 1 else args)\n    else:\n        return func", "code_tokens": "def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func", "docstring_tokens": "Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y", "label": 1}, {"idx": "cosqa-train-10520", "doc": "python check if numeric type", "code": "def is_numeric_dtype(dtype):\n    \"\"\"Return ``True`` if ``dtype`` is a numeric type.\"\"\"\n    dtype = np.dtype(dtype)\n    return np.issubsctype(getattr(dtype, 'base', None), np.number)", "code_tokens": "def is_numeric_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . number )", "docstring_tokens": "Return True if dtype is a numeric type .", "label": 1}, {"idx": "cosqa-train-10521", "doc": "using one hot tensor as index for a python 2d list", "code": "def one_hot_encoding(input_tensor, num_labels):\n    \"\"\" One-hot encode labels from input \"\"\"\n    xview = input_tensor.view(-1, 1).to(torch.long)\n\n    onehot = torch.zeros(xview.size(0), num_labels, device=input_tensor.device, dtype=torch.float)\n    onehot.scatter_(1, xview, 1)\n    return onehot.view(list(input_tensor.shape) + [-1])", "code_tokens": "def one_hot_encoding ( input_tensor , num_labels ) : xview = input_tensor . view ( - 1 , 1 ) . to ( torch . long ) onehot = torch . zeros ( xview . size ( 0 ) , num_labels , device = input_tensor . device , dtype = torch . float ) onehot . scatter_ ( 1 , xview , 1 ) return onehot . view ( list ( input_tensor . shape ) + [ - 1 ] )", "docstring_tokens": "One - hot encode labels from input", "label": 0}, {"idx": "cosqa-train-10522", "doc": "python check if numpy dtype", "code": "def _isstring(dtype):\n    \"\"\"Given a numpy dtype, determines whether it is a string. Returns True\n    if the dtype is string or unicode.\n    \"\"\"\n    return dtype.type == numpy.unicode_ or dtype.type == numpy.string_", "code_tokens": "def _isstring ( dtype ) : return dtype . type == numpy . unicode_ or dtype . type == numpy . string_", "docstring_tokens": "Given a numpy dtype determines whether it is a string . Returns True if the dtype is string or unicode .", "label": 0}, {"idx": "cosqa-train-10523", "doc": "using python to delete a map service", "code": "def delete(args):\n    \"\"\"\n    Delete a river by name\n    \"\"\"\n    m = RiverManager(args.hosts)\n    m.delete(args.name)", "code_tokens": "def delete ( args ) : m = RiverManager ( args . hosts ) m . delete ( args . name )", "docstring_tokens": "Delete a river by name", "label": 0}, {"idx": "cosqa-train-10524", "doc": "python check if object exists dynamodb", "code": "def exists(self):\n    \"\"\" Checks if the item exists. \"\"\"\n    try:\n      return self.metadata is not None\n    except datalab.utils.RequestException:\n      return False\n    except Exception as e:\n      raise e", "code_tokens": "def exists ( self ) : try : return self . metadata is not None except datalab . utils . RequestException : return False except Exception as e : raise e", "docstring_tokens": "Checks if the item exists .", "label": 1}, {"idx": "cosqa-train-10525", "doc": "using python to generate c++", "code": "def generate(env):\n    \"\"\"Add Builders and construction variables for SGI MIPS C++ to an Environment.\"\"\"\n\n    cplusplus.generate(env)\n\n    env['CXX']         = 'CC'\n    env['CXXFLAGS']    = SCons.Util.CLVar('-LANG:std')\n    env['SHCXX']       = '$CXX'\n    env['SHOBJSUFFIX'] = '.o'\n    env['STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME'] = 1", "code_tokens": "def generate ( env ) : cplusplus . generate ( env ) env [ 'CXX' ] = 'CC' env [ 'CXXFLAGS' ] = SCons . Util . CLVar ( '-LANG:std' ) env [ 'SHCXX' ] = '$CXX' env [ 'SHOBJSUFFIX' ] = '.o' env [ 'STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME' ] = 1", "docstring_tokens": "Add Builders and construction variables for SGI MIPS C ++ to an Environment .", "label": 1}, {"idx": "cosqa-train-10526", "doc": "python check if object is a char", "code": "def is_string(obj):\n    \"\"\"Is this a string.\n\n    :param object obj:\n    :rtype: bool\n    \"\"\"\n    if PYTHON3:\n        str_type = (bytes, str)\n    else:\n        str_type = (bytes, str, unicode)\n    return isinstance(obj, str_type)", "code_tokens": "def is_string ( obj ) : if PYTHON3 : str_type = ( bytes , str ) else : str_type = ( bytes , str , unicode ) return isinstance ( obj , str_type )", "docstring_tokens": "Is this a string .", "label": 1}, {"idx": "cosqa-train-10527", "doc": "using replace in loop from a string using python", "code": "def multi_replace(instr, search_list=[], repl_list=None):\n    \"\"\"\n    Does a string replace with a list of search and replacements\n\n    TODO: rename\n    \"\"\"\n    repl_list = [''] * len(search_list) if repl_list is None else repl_list\n    for ser, repl in zip(search_list, repl_list):\n        instr = instr.replace(ser, repl)\n    return instr", "code_tokens": "def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr", "docstring_tokens": "Does a string replace with a list of search and replacements", "label": 1}, {"idx": "cosqa-train-10528", "doc": "python check if object json serializable", "code": "def is_serializable(obj):\n    \"\"\"Return `True` if the given object conforms to the Serializable protocol.\n\n    :rtype: bool\n    \"\"\"\n    if inspect.isclass(obj):\n      return Serializable.is_serializable_type(obj)\n    return isinstance(obj, Serializable) or hasattr(obj, '_asdict')", "code_tokens": "def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )", "docstring_tokens": "Return True if the given object conforms to the Serializable protocol .", "label": 1}, {"idx": "cosqa-train-10529", "doc": "using title case in python", "code": "def camel_case(self, snake_case):\n        \"\"\" Convert snake case to camel case \"\"\"\n        components = snake_case.split('_')\n        return components[0] + \"\".join(x.title() for x in components[1:])", "code_tokens": "def camel_case ( self , snake_case ) : components = snake_case . split ( '_' ) return components [ 0 ] + \"\" . join ( x . title ( ) for x in components [ 1 : ] )", "docstring_tokens": "Convert snake case to camel case", "label": 1}, {"idx": "cosqa-train-10530", "doc": "python check if object not nonetype", "code": "def is_sequence(obj):\n    \"\"\"Check if `obj` is a sequence, but not a string or bytes.\"\"\"\n    return isinstance(obj, Sequence) and not (\n        isinstance(obj, str) or BinaryClass.is_valid_type(obj))", "code_tokens": "def is_sequence ( obj ) : return isinstance ( obj , Sequence ) and not ( isinstance ( obj , str ) or BinaryClass . is_valid_type ( obj ) )", "docstring_tokens": "Check if obj is a sequence but not a string or bytes .", "label": 1}, {"idx": "cosqa-train-10531", "doc": "valiate filename python check user input reg ex", "code": "def is_valid_file(parser,arg):\n\t\"\"\"verify the validity of the given file. Never trust the End-User\"\"\"\n\tif not os.path.exists(arg):\n       \t\tparser.error(\"File %s not found\"%arg)\n\telse:\n\t       \treturn arg", "code_tokens": "def is_valid_file ( parser , arg ) : if not os . path . exists ( arg ) : parser . error ( \"File %s not found\" % arg ) else : return arg", "docstring_tokens": "verify the validity of the given file . Never trust the End - User", "label": 1}, {"idx": "cosqa-train-10532", "doc": "python check if port 443 is open", "code": "def is_http_running_on(port):\n  \"\"\" Check if an http server runs on a given port.\n\n  Args:\n    The port to check.\n  Returns:\n    True if it is used by an http server. False otherwise.\n  \"\"\"\n  try:\n    conn = httplib.HTTPConnection('127.0.0.1:' + str(port))\n    conn.connect()\n    conn.close()\n    return True\n  except Exception:\n    return False", "code_tokens": "def is_http_running_on ( port ) : try : conn = httplib . HTTPConnection ( '127.0.0.1:' + str ( port ) ) conn . connect ( ) conn . close ( ) return True except Exception : return False", "docstring_tokens": "Check if an http server runs on a given port .", "label": 1}, {"idx": "cosqa-train-10533", "doc": "validate credit card number in python using string input", "code": "def is_valid(number):\n    \"\"\"determines whether the card number is valid.\"\"\"\n    n = str(number)\n    if not n.isdigit():\n        return False\n    return int(n[-1]) == get_check_digit(n[:-1])", "code_tokens": "def is_valid ( number ) : n = str ( number ) if not n . isdigit ( ) : return False return int ( n [ - 1 ] ) == get_check_digit ( n [ : - 1 ] )", "docstring_tokens": "determines whether the card number is valid .", "label": 1}, {"idx": "cosqa-train-10534", "doc": "python check if value is null or a list", "code": "def is_nullable_list(val, vtype):\n    \"\"\"Return True if list contains either values of type `vtype` or None.\"\"\"\n    return (isinstance(val, list) and\n            any(isinstance(v, vtype) for v in val) and\n            all((isinstance(v, vtype) or v is None) for v in val))", "code_tokens": "def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )", "docstring_tokens": "Return True if list contains either values of type vtype or None .", "label": 1}, {"idx": "cosqa-train-10535", "doc": "validate email address string python", "code": "def __validate_email(self, email):\n        \"\"\"Checks if a string looks like an email address\"\"\"\n\n        e = re.match(self.EMAIL_ADDRESS_REGEX, email, re.UNICODE)\n        if e:\n            return email\n        else:\n            error = \"Invalid email address: \" + str(email)\n            msg = self.GRIMOIRELAB_INVALID_FORMAT % {'error': error}\n            raise InvalidFormatError(cause=msg)", "code_tokens": "def __validate_email ( self , email ) : e = re . match ( self . EMAIL_ADDRESS_REGEX , email , re . UNICODE ) if e : return email else : error = \"Invalid email address: \" + str ( email ) msg = self . GRIMOIRELAB_INVALID_FORMAT % { 'error' : error } raise InvalidFormatError ( cause = msg )", "docstring_tokens": "Checks if a string looks like an email address", "label": 0}, {"idx": "cosqa-train-10536", "doc": "python check ifa value isina list", "code": "def isCommaList(inputFilelist):\n    \"\"\"Return True if the input is a comma separated list of names.\"\"\"\n    if isinstance(inputFilelist, int) or isinstance(inputFilelist, np.int32):\n        ilist = str(inputFilelist)\n    else:\n        ilist = inputFilelist\n    if \",\" in ilist:\n        return True\n    return False", "code_tokens": "def isCommaList ( inputFilelist ) : if isinstance ( inputFilelist , int ) or isinstance ( inputFilelist , np . int32 ) : ilist = str ( inputFilelist ) else : ilist = inputFilelist if \",\" in ilist : return True return False", "docstring_tokens": "Return True if the input is a comma separated list of names .", "label": 1}, {"idx": "cosqa-train-10537", "doc": "visualizing layer outputs in cnn conv2d python", "code": "def conv2d(x_input, w_matrix):\n    \"\"\"conv2d returns a 2d convolution layer with full stride.\"\"\"\n    return tf.nn.conv2d(x_input, w_matrix, strides=[1, 1, 1, 1], padding='SAME')", "code_tokens": "def conv2d ( x_input , w_matrix ) : return tf . nn . conv2d ( x_input , w_matrix , strides = [ 1 , 1 , 1 , 1 ] , padding = 'SAME' )", "docstring_tokens": "conv2d returns a 2d convolution layer with full stride .", "label": 1}, {"idx": "cosqa-train-10538", "doc": "python check int is not float or boolean", "code": "def is_float(value):\n    \"\"\"must be a float\"\"\"\n    return isinstance(value, float) or isinstance(value, int) or isinstance(value, np.float64), float(value)", "code_tokens": "def is_float ( value ) : return isinstance ( value , float ) or isinstance ( value , int ) or isinstance ( value , np . float64 ) , float ( value )", "docstring_tokens": "must be a float", "label": 1}, {"idx": "cosqa-train-10539", "doc": "want python to run one time then stop loop", "code": "def _run_once(self):\n    \"\"\"Run once, should be called only from loop()\"\"\"\n    try:\n      self.do_wait()\n      self._execute_wakeup_tasks()\n      self._trigger_timers()\n    except Exception as e:\n      Log.error(\"Error occured during _run_once(): \" + str(e))\n      Log.error(traceback.format_exc())\n      self.should_exit = True", "code_tokens": "def _run_once ( self ) : try : self . do_wait ( ) self . _execute_wakeup_tasks ( ) self . _trigger_timers ( ) except Exception as e : Log . error ( \"Error occured during _run_once(): \" + str ( e ) ) Log . error ( traceback . format_exc ( ) ) self . should_exit = True", "docstring_tokens": "Run once should be called only from loop ()", "label": 0}, {"idx": "cosqa-train-10540", "doc": "python check is a function is a method", "code": "def is_function(self):\n        \"\"\"return True if callback is a vanilla plain jane function\"\"\"\n        if self.is_instance() or self.is_class(): return False\n        return isinstance(self.callback, (Callable, classmethod))", "code_tokens": "def is_function ( self ) : if self . is_instance ( ) or self . is_class ( ) : return False return isinstance ( self . callback , ( Callable , classmethod ) )", "docstring_tokens": "return True if callback is a vanilla plain jane function", "label": 0}, {"idx": "cosqa-train-10541", "doc": "what can you store in a python session", "code": "def save_session(self, sid, session, namespace=None):\n        \"\"\"Store the user session for a client.\n\n        The only difference with the :func:`socketio.Server.save_session`\n        method is that when the ``namespace`` argument is not given the\n        namespace associated with the class is used.\n        \"\"\"\n        return self.server.save_session(\n            sid, session, namespace=namespace or self.namespace)", "code_tokens": "def save_session ( self , sid , session , namespace = None ) : return self . server . save_session ( sid , session , namespace = namespace or self . namespace )", "docstring_tokens": "Store the user session for a client .", "label": 1}, {"idx": "cosqa-train-10542", "doc": "python check null nonetype object has no attribute", "code": "def _check_model(obj, models=None):\n    \"\"\"Checks object if it's a peewee model and unique.\"\"\"\n    return isinstance(obj, type) and issubclass(obj, pw.Model) and hasattr(obj, '_meta')", "code_tokens": "def _check_model ( obj , models = None ) : return isinstance ( obj , type ) and issubclass ( obj , pw . Model ) and hasattr ( obj , '_meta' )", "docstring_tokens": "Checks object if it s a peewee model and unique .", "label": 1}, {"idx": "cosqa-train-10543", "doc": "what category is a string variable in python", "code": "def get_category(self):\n        \"\"\"Get the category of the item.\n\n        :return: the category of the item.\n        :returntype: `unicode`\"\"\"\n        var = self.xmlnode.prop(\"category\")\n        if not var:\n            var = \"?\"\n        return var.decode(\"utf-8\")", "code_tokens": "def get_category ( self ) : var = self . xmlnode . prop ( \"category\" ) if not var : var = \"?\" return var . decode ( \"utf-8\" )", "docstring_tokens": "Get the category of the item .", "label": 1}, {"idx": "cosqa-train-10544", "doc": "what function in python code tests if a string only contains letters", "code": "def is_identifier(string):\n    \"\"\"Check if string could be a valid python identifier\n\n    :param string: string to be tested\n    :returns: True if string can be a python identifier, False otherwise\n    :rtype: bool\n    \"\"\"\n    matched = PYTHON_IDENTIFIER_RE.match(string)\n    return bool(matched) and not keyword.iskeyword(string)", "code_tokens": "def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )", "docstring_tokens": "Check if string could be a valid python identifier", "label": 0}, {"idx": "cosqa-train-10545", "doc": "python check string extensions in list", "code": "def watched_extension(extension):\n    \"\"\"Return True if the given extension is one of the watched extensions\"\"\"\n    for ext in hamlpy.VALID_EXTENSIONS:\n        if extension.endswith('.' + ext):\n            return True\n    return False", "code_tokens": "def watched_extension ( extension ) : for ext in hamlpy . VALID_EXTENSIONS : if extension . endswith ( '.' + ext ) : return True return False", "docstring_tokens": "Return True if the given extension is one of the watched extensions", "label": 1}, {"idx": "cosqa-train-10546", "doc": "what method is used to test if one set is contained entirely within another set in python", "code": "def issuperset(self, other):\n        \"\"\"Report whether this RangeSet contains another set.\"\"\"\n        self._binary_sanity_check(other)\n        return set.issuperset(self, other)", "code_tokens": "def issuperset ( self , other ) : self . _binary_sanity_check ( other ) return set . issuperset ( self , other )", "docstring_tokens": "Report whether this RangeSet contains another set .", "label": 0}, {"idx": "cosqa-train-10547", "doc": "python check variable type list or matrix", "code": "def contains_geometric_info(var):\n    \"\"\" Check whether the passed variable is a tuple with two floats or integers \"\"\"\n    return isinstance(var, tuple) and len(var) == 2 and all(isinstance(val, (int, float)) for val in var)", "code_tokens": "def contains_geometric_info ( var ) : return isinstance ( var , tuple ) and len ( var ) == 2 and all ( isinstance ( val , ( int , float ) ) for val in var )", "docstring_tokens": "Check whether the passed variable is a tuple with two floats or integers", "label": 1}, {"idx": "cosqa-train-10548", "doc": "what should be your test size in training python", "code": "def _get_example_length(example):\n  \"\"\"Returns the maximum length between the example inputs and targets.\"\"\"\n  length = tf.maximum(tf.shape(example[0])[0], tf.shape(example[1])[0])\n  return length", "code_tokens": "def _get_example_length ( example ) : length = tf . maximum ( tf . shape ( example [ 0 ] ) [ 0 ] , tf . shape ( example [ 1 ] ) [ 0 ] ) return length", "docstring_tokens": "Returns the maximum length between the example inputs and targets .", "label": 0}, {"idx": "cosqa-train-10549", "doc": "python check whether stdout is binary", "code": "def binary_stdout():\n    \"\"\"\n    A sys.stdout that accepts bytes.\n    \"\"\"\n\n    # First there is a Python3 issue.\n    try:\n        stdout = sys.stdout.buffer\n    except AttributeError:\n        # Probably Python 2, where bytes are strings.\n        stdout = sys.stdout\n\n    # On Windows the C runtime file orientation needs changing.\n    if sys.platform == \"win32\":\n        import msvcrt\n        import os\n        msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)\n\n    return stdout", "code_tokens": "def binary_stdout ( ) : # First there is a Python3 issue. try : stdout = sys . stdout . buffer except AttributeError : # Probably Python 2, where bytes are strings. stdout = sys . stdout # On Windows the C runtime file orientation needs changing. if sys . platform == \"win32\" : import msvcrt import os msvcrt . setmode ( sys . stdout . fileno ( ) , os . O_BINARY ) return stdout", "docstring_tokens": "A sys . stdout that accepts bytes .", "label": 1}, {"idx": "cosqa-train-10550", "doc": "who killed my python process with sigkill", "code": "def process_kill(pid, sig=None):\n    \"\"\"Send signal to process.\n    \"\"\"\n    sig = sig or signal.SIGTERM\n    os.kill(pid, sig)", "code_tokens": "def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )", "docstring_tokens": "Send signal to process .", "label": 0}, {"idx": "cosqa-train-10551", "doc": "python chunk list into n parts'", "code": "def chunked(l, n):\n    \"\"\"Chunk one big list into few small lists.\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunked ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Chunk one big list into few small lists .", "label": 0}, {"idx": "cosqa-train-10552", "doc": "word contain all vowels python", "code": "def vowels(self):\n        \"\"\"\n        Return a new IPAString, containing only the vowels in the current string.\n\n        :rtype: IPAString\n        \"\"\"\n        return IPAString(ipa_chars=[c for c in self.ipa_chars if c.is_vowel])", "code_tokens": "def vowels ( self ) : return IPAString ( ipa_chars = [ c for c in self . ipa_chars if c . is_vowel ] )", "docstring_tokens": "Return a new IPAString containing only the vowels in the current string .", "label": 0}, {"idx": "cosqa-train-10553", "doc": "wrapping python as a wrapper", "code": "def library(func):\n    \"\"\"\n    A decorator for providing a unittest with a library and have it called only\n    once.\n    \"\"\"\n    @wraps(func)\n    def wrapped(*args, **kwargs):\n        \"\"\"Transparent wrapper.\"\"\"\n        return func(*args, **kwargs)\n    SINGLES.append(wrapped)\n    return wrapped", "code_tokens": "def library ( func ) : @ wraps ( func ) def wrapped ( * args , * * kwargs ) : \"\"\"Transparent wrapper.\"\"\" return func ( * args , * * kwargs ) SINGLES . append ( wrapped ) return wrapped", "docstring_tokens": "A decorator for providing a unittest with a library and have it called only once .", "label": 1}, {"idx": "cosqa-train-10554", "doc": "python clear all variables from memory", "code": "def Flush(self):\n    \"\"\"Flush all items from cache.\"\"\"\n    while self._age:\n      node = self._age.PopLeft()\n      self.KillObject(node.data)\n\n    self._hash = dict()", "code_tokens": "def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )", "docstring_tokens": "Flush all items from cache .", "label": 1}, {"idx": "cosqa-train-10555", "doc": "write a fits file python", "code": "def write_fits(self, fitsfile):\n        \"\"\"Write the ROI model to a FITS file.\"\"\"\n\n        tab = self.create_table()\n        hdu_data = fits.table_to_hdu(tab)\n        hdus = [fits.PrimaryHDU(), hdu_data]\n        fits_utils.write_hdus(hdus, fitsfile)", "code_tokens": "def write_fits ( self , fitsfile ) : tab = self . create_table ( ) hdu_data = fits . table_to_hdu ( tab ) hdus = [ fits . PrimaryHDU ( ) , hdu_data ] fits_utils . write_hdus ( hdus , fitsfile )", "docstring_tokens": "Write the ROI model to a FITS file .", "label": 1}, {"idx": "cosqa-train-10556", "doc": "python clear deleate an object", "code": "def ExpireObject(self, key):\n    \"\"\"Expire a specific object from cache.\"\"\"\n    node = self._hash.pop(key, None)\n    if node:\n      self._age.Unlink(node)\n      self.KillObject(node.data)\n\n      return node.data", "code_tokens": "def ExpireObject ( self , key ) : node = self . _hash . pop ( key , None ) if node : self . _age . Unlink ( node ) self . KillObject ( node . data ) return node . data", "docstring_tokens": "Expire a specific object from cache .", "label": 1}, {"idx": "cosqa-train-10557", "doc": "write a json object to file python", "code": "def _serialize_json(obj, fp):\n    \"\"\" Serialize ``obj`` as a JSON formatted stream to ``fp`` \"\"\"\n    json.dump(obj, fp, indent=4, default=serialize)", "code_tokens": "def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )", "docstring_tokens": "Serialize obj as a JSON formatted stream to fp", "label": 1}, {"idx": "cosqa-train-10558", "doc": "python close all figures", "code": "def close_all_but_this(self):\n        \"\"\"Close all files but the current one\"\"\"\n        self.close_all_right()\n        for i in range(0, self.get_stack_count()-1  ):\n            self.close_file(0)", "code_tokens": "def close_all_but_this ( self ) : self . close_all_right ( ) for i in range ( 0 , self . get_stack_count ( ) - 1 ) : self . close_file ( 0 )", "docstring_tokens": "Close all files but the current one", "label": 1}, {"idx": "cosqa-train-10559", "doc": "python close gui command", "code": "def do_exit(self, arg):\n        \"\"\"Exit the shell session.\"\"\"\n\n        if self.current:\n            self.current.close()\n        self.resource_manager.close()\n        del self.resource_manager\n        return True", "code_tokens": "def do_exit ( self , arg ) : if self . current : self . current . close ( ) self . resource_manager . close ( ) del self . resource_manager return True", "docstring_tokens": "Exit the shell session .", "label": 1}, {"idx": "cosqa-train-10560", "doc": "write in bold and read in color of the print mesaage in python", "code": "def good(txt):\n    \"\"\"Print, emphasized 'good', the given 'txt' message\"\"\"\n\n    print(\"%s# %s%s%s\" % (PR_GOOD_CC, get_time_stamp(), txt, PR_NC))\n    sys.stdout.flush()", "code_tokens": "def good ( txt ) : print ( \"%s# %s%s%s\" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "docstring_tokens": "Print emphasized good the given txt message", "label": 1}, {"idx": "cosqa-train-10561", "doc": "python close socket gracefully", "code": "def socket_close(self):\n        \"\"\"Close our socket.\"\"\"\n        if self.sock != NC.INVALID_SOCKET:\n            self.sock.close()\n        self.sock = NC.INVALID_SOCKET", "code_tokens": "def socket_close ( self ) : if self . sock != NC . INVALID_SOCKET : self . sock . close ( ) self . sock = NC . INVALID_SOCKET", "docstring_tokens": "Close our socket .", "label": 1}, {"idx": "cosqa-train-10562", "doc": "write python object to yaml file", "code": "def WriteToPath(obj, filepath):\n  \"\"\"Serializes and writes given Python object to the specified YAML file.\n\n  Args:\n    obj: A Python object to serialize.\n    filepath: A path to the file into which the object is to be written.\n  \"\"\"\n  with io.open(filepath, mode=\"w\", encoding=\"utf-8\") as filedesc:\n    WriteToFile(obj, filedesc)", "code_tokens": "def WriteToPath ( obj , filepath ) : with io . open ( filepath , mode = \"w\" , encoding = \"utf-8\" ) as filedesc : WriteToFile ( obj , filedesc )", "docstring_tokens": "Serializes and writes given Python object to the specified YAML file .", "label": 1}, {"idx": "cosqa-train-10563", "doc": "python closing files safely", "code": "def __exit__(self, *args):\n        \"\"\"\n        Cleanup any necessary opened files\n        \"\"\"\n\n        if self._output_file_handle:\n            self._output_file_handle.close()\n            self._output_file_handle = None", "code_tokens": "def __exit__ ( self , * args ) : if self . _output_file_handle : self . _output_file_handle . close ( ) self . _output_file_handle = None", "docstring_tokens": "Cleanup any necessary opened files", "label": 0}, {"idx": "cosqa-train-10564", "doc": "writerow python extra line", "code": "def _write_separator(self):\n        \"\"\"\n        Inserts a horizontal (commented) line tot the generated code.\n        \"\"\"\n        tmp = self._page_width - ((4 * self.__indent_level) + 2)\n        self._write_line('# ' + ('-' * tmp))", "code_tokens": "def _write_separator ( self ) : tmp = self . _page_width - ( ( 4 * self . __indent_level ) + 2 ) self . _write_line ( '# ' + ( '-' * tmp ) )", "docstring_tokens": "Inserts a horizontal ( commented ) line tot the generated code .", "label": 1}, {"idx": "cosqa-train-10565", "doc": "python cmd get dynamically added do methods to show up in help", "code": "def do_help(self, arg):\n        \"\"\"\n        Show help on all commands.\n        \"\"\"\n        print(self.response_prompt, file=self.stdout)\n        return cmd.Cmd.do_help(self, arg)", "code_tokens": "def do_help ( self , arg ) : print ( self . response_prompt , file = self . stdout ) return cmd . Cmd . do_help ( self , arg )", "docstring_tokens": "Show help on all commands .", "label": 1}, {"idx": "cosqa-train-10566", "doc": "writing at the end of the line python", "code": "def write_line(self, line, count=1):\n        \"\"\"writes the line and count newlines after the line\"\"\"\n        self.write(line)\n        self.write_newlines(count)", "code_tokens": "def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )", "docstring_tokens": "writes the line and count newlines after the line", "label": 0}, {"idx": "cosqa-train-10567", "doc": "python code for graphing a normal multi variate", "code": "def linear_variogram_model(m, d):\n    \"\"\"Linear model, m is [slope, nugget]\"\"\"\n    slope = float(m[0])\n    nugget = float(m[1])\n    return slope * d + nugget", "code_tokens": "def linear_variogram_model ( m , d ) : slope = float ( m [ 0 ] ) nugget = float ( m [ 1 ] ) return slope * d + nugget", "docstring_tokens": "Linear model m is [ slope nugget ]", "label": 1}, {"idx": "cosqa-train-10568", "doc": "wx python window not showing", "code": "def disable_wx(self):\n        \"\"\"Disable event loop integration with wxPython.\n\n        This merely sets PyOS_InputHook to NULL.\n        \"\"\"\n        if self._apps.has_key(GUI_WX):\n            self._apps[GUI_WX]._in_event_loop = False\n        self.clear_inputhook()", "code_tokens": "def disable_wx ( self ) : if self . _apps . has_key ( GUI_WX ) : self . _apps [ GUI_WX ] . _in_event_loop = False self . clear_inputhook ( )", "docstring_tokens": "Disable event loop integration with wxPython .", "label": 1}, {"idx": "cosqa-train-10569", "doc": "python code to calculate distance using my map distance", "code": "def direct2dDistance(self, point):\n        \"\"\"consider the distance between two mapPoints, ignoring all terrain, pathing issues\"\"\"\n        if not isinstance(point, MapPoint): return 0.0\n        return  ((self.x-point.x)**2 + (self.y-point.y)**2)**(0.5) # simple distance formula", "code_tokens": "def direct2dDistance ( self , point ) : if not isinstance ( point , MapPoint ) : return 0.0 return ( ( self . x - point . x ) ** 2 + ( self . y - point . y ) ** 2 ) ** ( 0.5 ) # simple distance formula", "docstring_tokens": "consider the distance between two mapPoints ignoring all terrain pathing issues", "label": 0}, {"idx": "cosqa-train-10570", "doc": "wxpython add icon image", "code": "def set_icon(self, bmp):\n        \"\"\"Sets main window icon to given wx.Bitmap\"\"\"\n\n        _icon = wx.EmptyIcon()\n        _icon.CopyFromBitmap(bmp)\n        self.SetIcon(_icon)", "code_tokens": "def set_icon ( self , bmp ) : _icon = wx . EmptyIcon ( ) _icon . CopyFromBitmap ( bmp ) self . SetIcon ( _icon )", "docstring_tokens": "Sets main window icon to given wx . Bitmap", "label": 1}, {"idx": "cosqa-train-10571", "doc": "wxpython change text color", "code": "def _update_fontcolor(self, fontcolor):\n        \"\"\"Updates text font color button\n\n        Parameters\n        ----------\n\n        fontcolor: Integer\n        \\tText color in integer RGB format\n\n        \"\"\"\n\n        textcolor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)\n        textcolor.SetRGB(fontcolor)\n\n        self.textcolor_choice.SetColour(textcolor)", "code_tokens": "def _update_fontcolor ( self , fontcolor ) : textcolor = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_WINDOWTEXT ) textcolor . SetRGB ( fontcolor ) self . textcolor_choice . SetColour ( textcolor )", "docstring_tokens": "Updates text font color button", "label": 1}, {"idx": "cosqa-train-10572", "doc": "python code to print all the columns csv", "code": "def printcsv(csvdiffs):\n    \"\"\"print the csv\"\"\"\n    for row in csvdiffs:\n        print(','.join([str(cell) for cell in row]))", "code_tokens": "def printcsv ( csvdiffs ) : for row in csvdiffs : print ( ',' . join ( [ str ( cell ) for cell in row ] ) )", "docstring_tokens": "print the csv", "label": 0}, {"idx": "cosqa-train-10573", "doc": "wxpython hide a control, maintain sizer", "code": "def disable_wx(self):\n        \"\"\"Disable event loop integration with wxPython.\n\n        This merely sets PyOS_InputHook to NULL.\n        \"\"\"\n        if self._apps.has_key(GUI_WX):\n            self._apps[GUI_WX]._in_event_loop = False\n        self.clear_inputhook()", "code_tokens": "def disable_wx ( self ) : if self . _apps . has_key ( GUI_WX ) : self . _apps [ GUI_WX ] . _in_event_loop = False self . clear_inputhook ( )", "docstring_tokens": "Disable event loop integration with wxPython .", "label": 0}, {"idx": "cosqa-train-10574", "doc": "python code to receive a java object in json", "code": "def from_json(cls, s):\n        \"\"\"\n        Restores the object from the given JSON.\n\n        :param s: the JSON string to parse\n        :type s: str\n        :return: the\n        \"\"\"\n        d = json.loads(s)\n        return get_dict_handler(d[\"type\"])(d)", "code_tokens": "def from_json ( cls , s ) : d = json . loads ( s ) return get_dict_handler ( d [ \"type\" ] ) ( d )", "docstring_tokens": "Restores the object from the given JSON .", "label": 1}, {"idx": "cosqa-train-10575", "doc": "wxpython select background color", "code": "def _update_bordercolor(self, bordercolor):\n        \"\"\"Updates background color\"\"\"\n\n        border_color = wx.SystemSettings_GetColour(wx.SYS_COLOUR_ACTIVEBORDER)\n        border_color.SetRGB(bordercolor)\n\n        self.linecolor_choice.SetColour(border_color)", "code_tokens": "def _update_bordercolor ( self , bordercolor ) : border_color = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_ACTIVEBORDER ) border_color . SetRGB ( bordercolor ) self . linecolor_choice . SetColour ( border_color )", "docstring_tokens": "Updates background color", "label": 1}, {"idx": "cosqa-train-10576", "doc": "python code to validate whether a location is within a geo json polygon", "code": "def point_in_multipolygon(point, multipoly):\n    \"\"\"\n    valid whether the point is located in a mulitpolygon (donut polygon is not supported)\n\n    Keyword arguments:\n    point      -- point geojson object\n    multipoly  -- multipolygon geojson object\n\n    if(point inside multipoly) return true else false\n    \"\"\"\n    coords_array = [multipoly['coordinates']] if multipoly[\n        'type'] == \"MultiPolygon\" else multipoly['coordinates']\n\n    for coords in coords_array:\n        if _point_in_polygon(point, coords):\n            return True\n\n    return False", "code_tokens": "def point_in_multipolygon ( point , multipoly ) : coords_array = [ multipoly [ 'coordinates' ] ] if multipoly [ 'type' ] == \"MultiPolygon\" else multipoly [ 'coordinates' ] for coords in coords_array : if _point_in_polygon ( point , coords ) : return True return False", "docstring_tokens": "valid whether the point is located in a mulitpolygon ( donut polygon is not supported )", "label": 1}, {"idx": "cosqa-train-10577", "doc": "python codecs decode to binary", "code": "def to_binary(s, encoding='utf8'):\n    \"\"\"Portable cast function.\n\n    In python 2 the ``str`` function which is used to coerce objects to bytes does not\n    accept an encoding argument, whereas python 3's ``bytes`` function requires one.\n\n    :param s: object to be converted to binary_type\n    :return: binary_type instance, representing s.\n    \"\"\"\n    if PY3:  # pragma: no cover\n        return s if isinstance(s, binary_type) else binary_type(s, encoding=encoding)\n    return binary_type(s)", "code_tokens": "def to_binary ( s , encoding = 'utf8' ) : if PY3 : # pragma: no cover return s if isinstance ( s , binary_type ) else binary_type ( s , encoding = encoding ) return binary_type ( s )", "docstring_tokens": "Portable cast function .", "label": 0}, {"idx": "cosqa-train-10578", "doc": "xlabel and ylabel in subplot in python", "code": "def show_xticklabels(self, row, column):\n        \"\"\"Show the x-axis tick labels for a subplot.\n\n        :param row,column: specify the subplot.\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.show_xticklabels()", "code_tokens": "def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "docstring_tokens": "Show the x - axis tick labels for a subplot .", "label": 0}, {"idx": "cosqa-train-10579", "doc": "python combinations of 3 list", "code": "def combinations(l):\n    \"\"\"Pure-Python implementation of itertools.combinations(l, 2).\"\"\"\n    result = []\n    for x in xrange(len(l) - 1):\n        ls = l[x + 1:]\n        for y in ls:\n            result.append((l[x], y))\n    return result", "code_tokens": "def combinations ( l ) : result = [ ] for x in xrange ( len ( l ) - 1 ) : ls = l [ x + 1 : ] for y in ls : result . append ( ( l [ x ] , y ) ) return result", "docstring_tokens": "Pure - Python implementation of itertools . combinations ( l 2 ) .", "label": 0}, {"idx": "cosqa-train-10580", "doc": "xml data validation using python", "code": "def str_is_well_formed(xml_str):\n    \"\"\"\n  Args:\n    xml_str : str\n      DataONE API XML doc.\n\n  Returns:\n    bool: **True** if XML doc is well formed.\n  \"\"\"\n    try:\n        str_to_etree(xml_str)\n    except xml.etree.ElementTree.ParseError:\n        return False\n    else:\n        return True", "code_tokens": "def str_is_well_formed ( xml_str ) : try : str_to_etree ( xml_str ) except xml . etree . ElementTree . ParseError : return False else : return True", "docstring_tokens": "Args : xml_str : str DataONE API XML doc .", "label": 0}, {"idx": "cosqa-train-10581", "doc": "python combine arbitrary number of lists into one list", "code": "def listunion(ListOfLists):\n    \"\"\"\n    Take the union of a list of lists.\n\n    Take a Python list of Python lists::\n\n            [[l11,l12, ...], [l21,l22, ...], ... , [ln1, ln2, ...]]\n\n    and return the aggregated list::\n\n            [l11,l12, ..., l21, l22 , ...]\n\n    For a list of two lists, e.g. `[a, b]`, this is like::\n\n            a.extend(b)\n\n    **Parameters**\n\n            **ListOfLists** :  Python list\n\n                    Python list of Python lists.\n\n    **Returns**\n\n            **u** :  Python list\n\n                    Python list created by taking the union of the\n                    lists in `ListOfLists`.\n\n    \"\"\"\n    u = []\n    for s in ListOfLists:\n        if s != None:\n            u.extend(s)\n    return u", "code_tokens": "def listunion ( ListOfLists ) : u = [ ] for s in ListOfLists : if s != None : u . extend ( s ) return u", "docstring_tokens": "Take the union of a list of lists .", "label": 0}, {"idx": "cosqa-train-10582", "doc": "xml string to dict pythong", "code": "def xml_str_to_dict(s):\n    \"\"\" Transforms an XML string it to python-zimbra dict format\n\n    For format, see:\n      https://github.com/Zimbra-Community/python-zimbra/blob/master/README.md\n\n    :param: a string, containing XML\n    :returns: a dict, with python-zimbra format\n    \"\"\"\n    xml = minidom.parseString(s)\n    return pythonzimbra.tools.xmlserializer.dom_to_dict(xml.firstChild)", "code_tokens": "def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )", "docstring_tokens": "Transforms an XML string it to python - zimbra dict format", "label": 1}, {"idx": "cosqa-train-10583", "doc": "python combining async code", "code": "async def result_processor(tasks):\n    \"\"\"An async result aggregator that combines all the results\n       This gets executed in unsync.loop and unsync.thread\"\"\"\n    output = {}\n    for task in tasks:\n        num, res = await task\n        output[num] = res\n    return output", "code_tokens": "async def result_processor ( tasks ) : output = { } for task in tasks : num , res = await task output [ num ] = res return output", "docstring_tokens": "An async result aggregator that combines all the results This gets executed in unsync . loop and unsync . thread", "label": 1}, {"idx": "cosqa-train-10584", "doc": "yaml load dump in python", "code": "def print_yaml(o):\n    \"\"\"Pretty print an object as YAML.\"\"\"\n    print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))", "code_tokens": "def print_yaml ( o ) : print ( yaml . dump ( o , default_flow_style = False , indent = 4 , encoding = 'utf-8' ) )", "docstring_tokens": "Pretty print an object as YAML .", "label": 0}, {"idx": "cosqa-train-10585", "doc": "python combobox dropdown click event", "code": "def onchange(self, value):\n        \"\"\"Called when a new DropDownItem gets selected.\n        \"\"\"\n        log.debug('combo box. selected %s' % value)\n        self.select_by_value(value)\n        return (value, )", "code_tokens": "def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )", "docstring_tokens": "Called when a new DropDownItem gets selected .", "label": 1}, {"idx": "cosqa-train-10586", "doc": "zero element vector, python3", "code": "def prox_zero(X, step):\n    \"\"\"Proximal operator to project onto zero\n    \"\"\"\n    return np.zeros(X.shape, dtype=X.dtype)", "code_tokens": "def prox_zero ( X , step ) : return np . zeros ( X . shape , dtype = X . dtype )", "docstring_tokens": "Proximal operator to project onto zero", "label": 0}, {"idx": "cosqa-train-10587", "doc": "python comma separated value", "code": "def list_to_csv(value):\n    \"\"\"\n    Converts list to string with comma separated values. For string is no-op.\n    \"\"\"\n    if isinstance(value, (list, tuple, set)):\n        value = \",\".join(value)\n    return value", "code_tokens": "def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = \",\" . join ( value ) return value", "docstring_tokens": "Converts list to string with comma separated values . For string is no - op .", "label": 1}, {"idx": "cosqa-train-10588", "doc": "python common words dictionary list", "code": "def compare(dicts):\n    \"\"\"Compare by iteration\"\"\"\n\n    common_members = {}\n    common_keys = reduce(lambda x, y: x & y, map(dict.keys, dicts))\n    for k in common_keys:\n        common_members[k] = list(\n            reduce(lambda x, y: x & y, [set(d[k]) for d in dicts]))\n\n    return common_members", "code_tokens": "def compare ( dicts ) : common_members = { } common_keys = reduce ( lambda x , y : x & y , map ( dict . keys , dicts ) ) for k in common_keys : common_members [ k ] = list ( reduce ( lambda x , y : x & y , [ set ( d [ k ] ) for d in dicts ] ) ) return common_members", "docstring_tokens": "Compare by iteration", "label": 1}, {"idx": "cosqa-train-10589", "doc": "python context manager within context manager", "code": "def replace_sys_args(new_args):\n    \"\"\"Temporarily replace sys.argv with current arguments\n\n    Restores sys.argv upon exit of the context manager.\n    \"\"\"\n    # Replace sys.argv arguments\n    # for module import\n    old_args = sys.argv\n    sys.argv = new_args\n    try:\n        yield\n    finally:\n        sys.argv = old_args", "code_tokens": "def replace_sys_args ( new_args ) : # Replace sys.argv arguments # for module import old_args = sys . argv sys . argv = new_args try : yield finally : sys . argv = old_args", "docstring_tokens": "Temporarily replace sys . argv with current arguments", "label": 0}, {"idx": "cosqa-train-10590", "doc": "how to use \"save as other\" reduced size pdf in python script text", "code": "def _single_page_pdf(page):\n    \"\"\"Construct a single page PDF from the provided page in memory\"\"\"\n    pdf = Pdf.new()\n    pdf.pages.append(page)\n    bio = BytesIO()\n    pdf.save(bio)\n    bio.seek(0)\n    return bio.read()", "code_tokens": "def _single_page_pdf ( page ) : pdf = Pdf . new ( ) pdf . pages . append ( page ) bio = BytesIO ( ) pdf . save ( bio ) bio . seek ( 0 ) return bio . read ( )", "docstring_tokens": "Construct a single page PDF from the provided page in memory", "label": 1}, {"idx": "cosqa-train-10591", "doc": "python conventions for naming functions", "code": "def export(defn):\n    \"\"\"Decorator to explicitly mark functions that are exposed in a lib.\"\"\"\n    globals()[defn.__name__] = defn\n    __all__.append(defn.__name__)\n    return defn", "code_tokens": "def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "docstring_tokens": "Decorator to explicitly mark functions that are exposed in a lib .", "label": 0}, {"idx": "cosqa-train-10592", "doc": "is there a way to \"clear\" in python", "code": "def trim(self):\n        \"\"\"Clear not used counters\"\"\"\n        for key, value in list(iteritems(self.counters)):\n            if value.empty():\n                del self.counters[key]", "code_tokens": "def trim ( self ) : for key , value in list ( iteritems ( self . counters ) ) : if value . empty ( ) : del self . counters [ key ]", "docstring_tokens": "Clear not used counters", "label": 1}, {"idx": "cosqa-train-10593", "doc": "python conver string to numpy str", "code": "def np2str(value):\n    \"\"\"Convert an `numpy.string_` to str.\n\n    Args:\n        value (ndarray): scalar or 1-element numpy array to convert\n\n    Raises:\n        ValueError: if value is array larger than 1-element or it is not of\n                    type `numpy.string_` or it is not a numpy array\n\n    \"\"\"\n    if hasattr(value, 'dtype') and \\\n            issubclass(value.dtype.type, (np.string_, np.object_)) and value.size == 1:\n        value = np.asscalar(value)\n        if not isinstance(value, str):\n            # python 3 - was scalar numpy array of bytes\n            # otherwise python 2 - scalar numpy array of 'str'\n            value = value.decode()\n        return value\n    else:\n        raise ValueError(\"Array is not a string type or is larger than 1\")", "code_tokens": "def np2str ( value ) : if hasattr ( value , 'dtype' ) and issubclass ( value . dtype . type , ( np . string_ , np . object_ ) ) and value . size == 1 : value = np . asscalar ( value ) if not isinstance ( value , str ) : # python 3 - was scalar numpy array of bytes # otherwise python 2 - scalar numpy array of 'str' value = value . decode ( ) return value else : raise ValueError ( \"Array is not a string type or is larger than 1\" )", "docstring_tokens": "Convert an numpy . string_ to str .", "label": 1}, {"idx": "cosqa-train-10594", "doc": "python \"binary string\" to int", "code": "def _from_bytes(bytes, byteorder=\"big\", signed=False):\n    \"\"\"This is the same functionality as ``int.from_bytes`` in python 3\"\"\"\n    return int.from_bytes(bytes, byteorder=byteorder, signed=signed)", "code_tokens": "def _from_bytes ( bytes , byteorder = \"big\" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )", "docstring_tokens": "This is the same functionality as int . from_bytes in python 3", "label": 1}, {"idx": "cosqa-train-10595", "doc": "python convolve gaussian kernel", "code": "def convolve_gaussian_2d(image, gaussian_kernel_1d):\n    \"\"\"Convolve 2d gaussian.\"\"\"\n    result = scipy.ndimage.filters.correlate1d(\n        image, gaussian_kernel_1d, axis=0)\n    result = scipy.ndimage.filters.correlate1d(\n        result, gaussian_kernel_1d, axis=1)\n    return result", "code_tokens": "def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result", "docstring_tokens": "Convolve 2d gaussian .", "label": 1}, {"idx": "cosqa-train-10596", "doc": "python open file dialog \"without tkinter\"", "code": "def askopenfilename(**kwargs):\n    \"\"\"Return file name(s) from Tkinter's file open dialog.\"\"\"\n    try:\n        from Tkinter import Tk\n        import tkFileDialog as filedialog\n    except ImportError:\n        from tkinter import Tk, filedialog\n    root = Tk()\n    root.withdraw()\n    root.update()\n    filenames = filedialog.askopenfilename(**kwargs)\n    root.destroy()\n    return filenames", "code_tokens": "def askopenfilename ( * * kwargs ) : try : from Tkinter import Tk import tkFileDialog as filedialog except ImportError : from tkinter import Tk , filedialog root = Tk ( ) root . withdraw ( ) root . update ( ) filenames = filedialog . askopenfilename ( * * kwargs ) root . destroy ( ) return filenames", "docstring_tokens": "Return file name ( s ) from Tkinter s file open dialog .", "label": 1}, {"idx": "cosqa-train-10597", "doc": "python copy dict lowercase keys", "code": "def keys_to_snake_case(camel_case_dict):\n    \"\"\"\n    Make a copy of a dictionary with all keys converted to snake case. This is just calls to_snake_case on\n    each of the keys in the dictionary and returns a new dictionary.\n\n    :param camel_case_dict: Dictionary with the keys to convert.\n    :type camel_case_dict: Dictionary.\n\n    :return: Dictionary with the keys converted to snake case.\n    \"\"\"\n    return dict((to_snake_case(key), value) for (key, value) in camel_case_dict.items())", "code_tokens": "def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )", "docstring_tokens": "Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .", "label": 1}, {"idx": "cosqa-train-10598", "doc": "'blueprint' object is not callable python", "code": "def register_blueprints(app):\n    \"\"\"Register Flask blueprints.\"\"\"\n    app.register_blueprint(public.public_bp)\n    app.register_blueprint(genes.genes_bp)\n    app.register_blueprint(cases.cases_bp)\n    app.register_blueprint(login.login_bp)\n    app.register_blueprint(variants.variants_bp)\n    app.register_blueprint(panels.panels_bp)\n    app.register_blueprint(dashboard.dashboard_bp)\n    app.register_blueprint(api.api_bp)\n    app.register_blueprint(alignviewers.alignviewers_bp)\n    app.register_blueprint(phenotypes.hpo_bp)\n    app.register_blueprint(institutes.overview)", "code_tokens": "def register_blueprints ( app ) : app . register_blueprint ( public . public_bp ) app . register_blueprint ( genes . genes_bp ) app . register_blueprint ( cases . cases_bp ) app . register_blueprint ( login . login_bp ) app . register_blueprint ( variants . variants_bp ) app . register_blueprint ( panels . panels_bp ) app . register_blueprint ( dashboard . dashboard_bp ) app . register_blueprint ( api . api_bp ) app . register_blueprint ( alignviewers . alignviewers_bp ) app . register_blueprint ( phenotypes . hpo_bp ) app . register_blueprint ( institutes . overview )", "docstring_tokens": "Register Flask blueprints .", "label": 1}, {"idx": "cosqa-train-10599", "doc": "python copy properties of one object to another", "code": "def _clone_properties(self):\n    \"\"\"Internal helper to clone self._properties if necessary.\"\"\"\n    cls = self.__class__\n    if self._properties is cls._properties:\n      self._properties = dict(cls._properties)", "code_tokens": "def _clone_properties ( self ) : cls = self . __class__ if self . _properties is cls . _properties : self . _properties = dict ( cls . _properties )", "docstring_tokens": "Internal helper to clone self . _properties if necessary .", "label": 1}, {"idx": "cosqa-train-10600", "doc": "1d array dtype python", "code": "def dict_to_numpy_array(d):\n    \"\"\"\n    Convert a dict of 1d array to a numpy recarray\n    \"\"\"\n    return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))", "code_tokens": "def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )", "docstring_tokens": "Convert a dict of 1d array to a numpy recarray", "label": 1}, {"idx": "cosqa-train-10601", "doc": "python correlation function on specific columns", "code": "def correlation(df, rowvar=False):\n    \"\"\"\n    Calculate column-wise Pearson correlations using ``numpy.ma.corrcoef``\n\n    Input data is masked to ignore NaNs when calculating correlations. Data is returned as\n    a Pandas ``DataFrame`` of column_n x column_n dimensions, with column index copied to\n    both axes.\n\n    :param df: Pandas DataFrame\n    :return: Pandas DataFrame (n_columns x n_columns) of column-wise correlations\n    \"\"\"\n\n    # Create a correlation matrix for all correlations\n    # of the columns (filled with na for all values)\n    df = df.copy()\n    maskv = np.ma.masked_where(np.isnan(df.values), df.values)\n    cdf = np.ma.corrcoef(maskv, rowvar=False)\n    cdf = pd.DataFrame(np.array(cdf))\n    cdf.columns = df.columns\n    cdf.index = df.columns\n    cdf = cdf.sort_index(level=0, axis=1)\n    cdf = cdf.sort_index(level=0)\n    return cdf", "code_tokens": "def correlation ( df , rowvar = False ) : # Create a correlation matrix for all correlations # of the columns (filled with na for all values) df = df . copy ( ) maskv = np . ma . masked_where ( np . isnan ( df . values ) , df . values ) cdf = np . ma . corrcoef ( maskv , rowvar = False ) cdf = pd . DataFrame ( np . array ( cdf ) ) cdf . columns = df . columns cdf . index = df . columns cdf = cdf . sort_index ( level = 0 , axis = 1 ) cdf = cdf . sort_index ( level = 0 ) return cdf", "docstring_tokens": "Calculate column - wise Pearson correlations using numpy . ma . corrcoef", "label": 1}, {"idx": "cosqa-train-10602", "doc": "1d convolutional network python", "code": "def conv1x1(in_planes, out_planes, stride=1):\n    \"\"\"1x1 convolution\"\"\"\n    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)", "code_tokens": "def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )", "docstring_tokens": "1x1 convolution", "label": 1}, {"idx": "cosqa-train-10603", "doc": "python cosine similarity of two vectors", "code": "def cross_v2(vec1, vec2):\n    \"\"\"Return the crossproduct of the two vectors as a Vec2.\n    Cross product doesn't really make sense in 2D, but return the Z component\n    of the 3d result.\n    \"\"\"\n\n    return vec1.y * vec2.x - vec1.x * vec2.y", "code_tokens": "def cross_v2 ( vec1 , vec2 ) : return vec1 . y * vec2 . x - vec1 . x * vec2 . y", "docstring_tokens": "Return the crossproduct of the two vectors as a Vec2 . Cross product doesn t really make sense in 2D but return the Z component of the 3d result .", "label": 1}, {"idx": "cosqa-train-10604", "doc": "3 dimension convolution of cnn with python numpy", "code": "def conv1x1(in_planes, out_planes, stride=1):\n    \"\"\"1x1 convolution\"\"\"\n    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)", "code_tokens": "def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )", "docstring_tokens": "1x1 convolution", "label": 1}, {"idx": "cosqa-train-10605", "doc": "python count unique number of occurrences in list", "code": "def count_list(the_list):\n    \"\"\"\n    Generates a count of the number of times each unique item appears in a list\n    \"\"\"\n    count = the_list.count\n    result = [(item, count(item)) for item in set(the_list)]\n    result.sort()\n    return result", "code_tokens": "def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result", "docstring_tokens": "Generates a count of the number of times each unique item appears in a list", "label": 1}, {"idx": "cosqa-train-10606", "doc": "a string of colors for print in python", "code": "def write_color(string, name, style='normal', when='auto'):\n    \"\"\" Write the given colored string to standard out. \"\"\"\n    write(color(string, name, style, when))", "code_tokens": "def write_color ( string , name , style = 'normal' , when = 'auto' ) : write ( color ( string , name , style , when ) )", "docstring_tokens": "Write the given colored string to standard out .", "label": 1}, {"idx": "cosqa-train-10607", "doc": "python counting sundays in a month", "code": "def first_sunday(self, year, month):\n        \"\"\"Get the first sunday of a month.\"\"\"\n        date = datetime(year, month, 1, 0)\n        days_until_sunday = 6 - date.weekday()\n\n        return date + timedelta(days=days_until_sunday)", "code_tokens": "def first_sunday ( self , year , month ) : date = datetime ( year , month , 1 , 0 ) days_until_sunday = 6 - date . weekday ( ) return date + timedelta ( days = days_until_sunday )", "docstring_tokens": "Get the first sunday of a month .", "label": 0}, {"idx": "cosqa-train-10608", "doc": "access a column using column name python", "code": "def _get_column_by_db_name(cls, name):\n        \"\"\"\n        Returns the column, mapped by db_field name\n        \"\"\"\n        return cls._columns.get(cls._db_map.get(name, name))", "code_tokens": "def _get_column_by_db_name ( cls , name ) : return cls . _columns . get ( cls . _db_map . get ( name , name ) )", "docstring_tokens": "Returns the column mapped by db_field name", "label": 1}, {"idx": "cosqa-train-10609", "doc": "python covert string to number", "code": "def get_number(s, cast=int):\n    \"\"\"\n    Try to get a number out of a string, and cast it.\n    \"\"\"\n    import string\n    d = \"\".join(x for x in str(s) if x in string.digits)\n    return cast(d)", "code_tokens": "def get_number ( s , cast = int ) : import string d = \"\" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )", "docstring_tokens": "Try to get a number out of a string and cast it .", "label": 1}, {"idx": "cosqa-train-10610", "doc": "access item based on name in list python", "code": "def get_by(self, name):\n    \"\"\"get element by name\"\"\"\n    return next((item for item in self if item.name == name), None)", "code_tokens": "def get_by ( self , name ) : return next ( ( item for item in self if item . name == name ) , None )", "docstring_tokens": "get element by name", "label": 1}, {"idx": "cosqa-train-10611", "doc": "python covert string type list to list", "code": "def comma_delimited_to_list(list_param):\n    \"\"\"Convert comma-delimited list / string into a list of strings\n\n    :param list_param: Comma-delimited string\n    :type list_param: str | unicode\n    :return: A list of strings\n    :rtype: list\n    \"\"\"\n    if isinstance(list_param, list):\n        return list_param\n    if isinstance(list_param, str):\n        return list_param.split(',')\n    else:\n        return []", "code_tokens": "def comma_delimited_to_list ( list_param ) : if isinstance ( list_param , list ) : return list_param if isinstance ( list_param , str ) : return list_param . split ( ',' ) else : return [ ]", "docstring_tokens": "Convert comma - delimited list / string into a list of strings", "label": 1}, {"idx": "cosqa-train-10612", "doc": "access last element python numpy", "code": "def other_ind(self):\n        \"\"\"last row or column of square A\"\"\"\n        return np.full(self.n_min, self.size - 1, dtype=np.int)", "code_tokens": "def other_ind ( self ) : return np . full ( self . n_min , self . size - 1 , dtype = np . int )", "docstring_tokens": "last row or column of square A", "label": 1}, {"idx": "cosqa-train-10613", "doc": "python create a randomly size rectangle", "code": "def from_rectangle(box):\n        \"\"\" Create a vector randomly within the given rectangle. \"\"\"\n        x = box.left + box.width * random.uniform(0, 1)\n        y = box.bottom + box.height * random.uniform(0, 1)\n        return Vector(x, y)", "code_tokens": "def from_rectangle ( box ) : x = box . left + box . width * random . uniform ( 0 , 1 ) y = box . bottom + box . height * random . uniform ( 0 , 1 ) return Vector ( x , y )", "docstring_tokens": "Create a vector randomly within the given rectangle .", "label": 1}, {"idx": "cosqa-train-10614", "doc": "access s3 data from python aws", "code": "def s3(ctx, bucket_name, data_file, region):\n    \"\"\"Use the S3 SWAG backend.\"\"\"\n    if not ctx.data_file:\n        ctx.data_file = data_file\n\n    if not ctx.bucket_name:\n        ctx.bucket_name = bucket_name\n\n    if not ctx.region:\n        ctx.region = region\n\n    ctx.type = 's3'", "code_tokens": "def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'", "docstring_tokens": "Use the S3 SWAG backend .", "label": 1}, {"idx": "cosqa-train-10615", "doc": "accesssing cpu return functions in python", "code": "def get_system_cpu_times():\n    \"\"\"Return system CPU times as a namedtuple.\"\"\"\n    user, nice, system, idle = _psutil_osx.get_system_cpu_times()\n    return _cputimes_ntuple(user, nice, system, idle)", "code_tokens": "def get_system_cpu_times ( ) : user , nice , system , idle = _psutil_osx . get_system_cpu_times ( ) return _cputimes_ntuple ( user , nice , system , idle )", "docstring_tokens": "Return system CPU times as a namedtuple .", "label": 1}, {"idx": "cosqa-train-10616", "doc": "python create comment block", "code": "def to_comment(value):\n  \"\"\"\n  Builds a comment.\n  \"\"\"\n  if value is None:\n    return\n  if len(value.split('\\n')) == 1:\n    return \"* \" + value\n  else:\n    return '\\n'.join([' * ' + l for l in value.split('\\n')[:-1]])", "code_tokens": "def to_comment ( value ) : if value is None : return if len ( value . split ( '\\n' ) ) == 1 : return \"* \" + value else : return '\\n' . join ( [ ' * ' + l for l in value . split ( '\\n' ) [ : - 1 ] ] )", "docstring_tokens": "Builds a comment .", "label": 1}, {"idx": "cosqa-train-10617", "doc": "activate virtual envs in python", "code": "def init():\n    \"\"\"\n    Execute init tasks for all components (virtualenv, pip).\n    \"\"\"\n    print(yellow(\"# Setting up environment...\\n\", True))\n    virtualenv.init()\n    virtualenv.update_requirements()\n    print(green(\"\\n# DONE.\", True))\n    print(green(\"Type \") + green(\"activate\", True) + green(\" to enable your virtual environment.\"))", "code_tokens": "def init ( ) : print ( yellow ( \"# Setting up environment...\\n\" , True ) ) virtualenv . init ( ) virtualenv . update_requirements ( ) print ( green ( \"\\n# DONE.\" , True ) ) print ( green ( \"Type \" ) + green ( \"activate\" , True ) + green ( \" to enable your virtual environment.\" ) )", "docstring_tokens": "Execute init tasks for all components ( virtualenv pip ) .", "label": 1}, {"idx": "cosqa-train-10618", "doc": "python create dictionary from list of tuples", "code": "def _convert(tup, dictlist):\n    \"\"\"\n    :param tup: a list of tuples\n    :param di: a dictionary converted from tup\n    :return: dictionary\n    \"\"\"\n    di = {}\n    for a, b in tup:\n        di.setdefault(a, []).append(b)\n    for key, val in di.items():\n        dictlist.append((key, val))\n    return dictlist", "code_tokens": "def _convert ( tup , dictlist ) : di = { } for a , b in tup : di . setdefault ( a , [ ] ) . append ( b ) for key , val in di . items ( ) : dictlist . append ( ( key , val ) ) return dictlist", "docstring_tokens": ": param tup : a list of tuples : param di : a dictionary converted from tup : return : dictionary", "label": 0}, {"idx": "cosqa-train-10619", "doc": "activemq python consumer 0", "code": "def init_mq(self):\n        \"\"\"Init connection and consumer with openstack mq.\"\"\"\n        mq = self.init_connection()\n        self.init_consumer(mq)\n        return mq.connection", "code_tokens": "def init_mq ( self ) : mq = self . init_connection ( ) self . init_consumer ( mq ) return mq . connection", "docstring_tokens": "Init connection and consumer with openstack mq .", "label": 1}, {"idx": "cosqa-train-10620", "doc": "python create directory path", "code": "def create_path(path):\n    \"\"\"Creates a absolute path in the file system.\n\n    :param path: The path to be created\n    \"\"\"\n    import os\n    if not os.path.exists(path):\n        os.makedirs(path)", "code_tokens": "def create_path ( path ) : import os if not os . path . exists ( path ) : os . makedirs ( path )", "docstring_tokens": "Creates a absolute path in the file system .", "label": 1}, {"idx": "cosqa-train-10621", "doc": "add a token interface python", "code": "def token(name):\n    \"\"\"Marker for a token\n\n    :param str name: Name of tokenizer\n    \"\"\"\n\n    def wrap(f):\n        tokenizers.append((name, f))\n        return f\n\n    return wrap", "code_tokens": "def token ( name ) : def wrap ( f ) : tokenizers . append ( ( name , f ) ) return f return wrap", "docstring_tokens": "Marker for a token", "label": 1}, {"idx": "cosqa-train-10622", "doc": "python create large random string", "code": "def uniqueID(size=6, chars=string.ascii_uppercase + string.digits):\n    \"\"\"A quick and dirty way to get a unique string\"\"\"\n    return ''.join(random.choice(chars) for x in xrange(size))", "code_tokens": "def uniqueID ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return '' . join ( random . choice ( chars ) for x in xrange ( size ) )", "docstring_tokens": "A quick and dirty way to get a unique string", "label": 1}, {"idx": "cosqa-train-10623", "doc": "add auth bearer header to python request", "code": "def __call__(self, r):\n        \"\"\"Update the request headers.\"\"\"\n        r.headers['Authorization'] = 'JWT {jwt}'.format(jwt=self.token)\n        return r", "code_tokens": "def __call__ ( self , r ) : r . headers [ 'Authorization' ] = 'JWT {jwt}' . format ( jwt = self . token ) return r", "docstring_tokens": "Update the request headers .", "label": 1}, {"idx": "cosqa-train-10624", "doc": "python create numpy array as list", "code": "def recarray(self):\n        \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"\n        return numpy.rec.fromrecords(self.records, names=self.names)", "code_tokens": "def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "docstring_tokens": "Returns data as : class : numpy . recarray .", "label": 1}, {"idx": "cosqa-train-10625", "doc": "add column sqlalchemy python", "code": "def add_column(connection, column):\n    \"\"\"\n    Add a column to the current table.\n    \"\"\"\n    stmt = alembic.ddl.base.AddColumn(_State.table.name, column)\n    connection.execute(stmt)\n    _State.reflect_metadata()", "code_tokens": "def add_column ( connection , column ) : stmt = alembic . ddl . base . AddColumn ( _State . table . name , column ) connection . execute ( stmt ) _State . reflect_metadata ( )", "docstring_tokens": "Add a column to the current table .", "label": 1}, {"idx": "cosqa-train-10626", "doc": "python create path if doesnt exist", "code": "def check_create_folder(filename):\n    \"\"\"Check if the folder exisits. If not, create the folder\"\"\"\n    os.makedirs(os.path.dirname(filename), exist_ok=True)", "code_tokens": "def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )", "docstring_tokens": "Check if the folder exisits . If not create the folder", "label": 1}, {"idx": "cosqa-train-10627", "doc": "add early stopping in tensorflow 2 layers in python", "code": "def unit_ball_L_inf(shape, precondition=True):\n  \"\"\"A tensorflow variable tranfomed to be constrained in a L_inf unit ball.\n\n  Note that this code also preconditions the gradient to go in the L_inf\n  direction of steepest descent.\n\n  EXPERIMENTAL: Do not use for adverserial examples if you need to be confident\n  they are strong attacks. We are not yet confident in this code.\n  \"\"\"\n  x = tf.Variable(tf.zeros(shape))\n  if precondition:\n    return constrain_L_inf_precondition(x)\n  else:\n    return constrain_L_inf(x)", "code_tokens": "def unit_ball_L_inf ( shape , precondition = True ) : x = tf . Variable ( tf . zeros ( shape ) ) if precondition : return constrain_L_inf_precondition ( x ) else : return constrain_L_inf ( x )", "docstring_tokens": "A tensorflow variable tranfomed to be constrained in a L_inf unit ball .", "label": 1}, {"idx": "cosqa-train-10628", "doc": "python creating a string form a list", "code": "def _make_cmd_list(cmd_list):\n    \"\"\"\n    Helper function to easily create the proper json formated string from a list of strs\n    :param cmd_list: list of strings\n    :return: str json formatted\n    \"\"\"\n    cmd = ''\n    for i in cmd_list:\n        cmd = cmd + '\"' + i + '\",'\n    cmd = cmd[:-1]\n    return cmd", "code_tokens": "def _make_cmd_list ( cmd_list ) : cmd = '' for i in cmd_list : cmd = cmd + '\"' + i + '\",' cmd = cmd [ : - 1 ] return cmd", "docstring_tokens": "Helper function to easily create the proper json formated string from a list of strs : param cmd_list : list of strings : return : str json formatted", "label": 1}, {"idx": "cosqa-train-10629", "doc": "add high frequency signal to wave file python", "code": "def save_to_16bit_wave_file(fname, sig, rate):\n  \"\"\"\n  Save a given signal ``sig`` to file ``fname`` as a 16-bit one-channel wave\n  with the given ``rate`` sample rate.\n  \"\"\"\n  with closing(wave.open(fname, \"wb\")) as wave_file:\n    wave_file.setnchannels(1)\n    wave_file.setsampwidth(2)\n    wave_file.setframerate(rate)\n    for chunk in chunks((clip(sig) * 2 ** 15).map(int), dfmt=\"h\", padval=0):\n      wave_file.writeframes(chunk)", "code_tokens": "def save_to_16bit_wave_file ( fname , sig , rate ) : with closing ( wave . open ( fname , \"wb\" ) ) as wave_file : wave_file . setnchannels ( 1 ) wave_file . setsampwidth ( 2 ) wave_file . setframerate ( rate ) for chunk in chunks ( ( clip ( sig ) * 2 ** 15 ) . map ( int ) , dfmt = \"h\" , padval = 0 ) : wave_file . writeframes ( chunk )", "docstring_tokens": "Save a given signal sig to file fname as a 16 - bit one - channel wave with the given rate sample rate .", "label": 1}, {"idx": "cosqa-train-10630", "doc": "python ctype returned null in string", "code": "def to_bytes_or_none(value):\n    \"\"\"Converts C char arrays to bytes and C NULL values to None.\"\"\"\n    if value == ffi.NULL:\n        return None\n    elif isinstance(value, ffi.CData):\n        return ffi.string(value)\n    else:\n        raise ValueError('Value must be char[] or NULL')", "code_tokens": "def to_bytes_or_none ( value ) : if value == ffi . NULL : return None elif isinstance ( value , ffi . CData ) : return ffi . string ( value ) else : raise ValueError ( 'Value must be char[] or NULL' )", "docstring_tokens": "Converts C char arrays to bytes and C NULL values to None .", "label": 1}, {"idx": "cosqa-train-10631", "doc": "add images to pdf python code", "code": "def save_image(pdf_path, img_path, page_num):\n    \"\"\"\n\n    Creates images for a page of the input pdf document and saves it\n    at img_path.\n\n    :param pdf_path: path to pdf to create images for.\n    :param img_path: path where to save the images.\n    :param page_num: page number to create image from in the pdf file.\n    :return:\n    \"\"\"\n    pdf_img = Image(filename=\"{}[{}]\".format(pdf_path, page_num))\n    with pdf_img.convert(\"png\") as converted:\n        # Set white background.\n        converted.background_color = Color(\"white\")\n        converted.alpha_channel = \"remove\"\n        converted.save(filename=img_path)", "code_tokens": "def save_image ( pdf_path , img_path , page_num ) : pdf_img = Image ( filename = \"{}[{}]\" . format ( pdf_path , page_num ) ) with pdf_img . convert ( \"png\" ) as converted : # Set white background. converted . background_color = Color ( \"white\" ) converted . alpha_channel = \"remove\" converted . save ( filename = img_path )", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-10632", "doc": "python ctypes load dll linux", "code": "def load(self, name):\n        \"\"\"Loads and returns foreign library.\"\"\"\n        name = ctypes.util.find_library(name)\n        return ctypes.cdll.LoadLibrary(name)", "code_tokens": "def load ( self , name ) : name = ctypes . util . find_library ( name ) return ctypes . cdll . LoadLibrary ( name )", "docstring_tokens": "Loads and returns foreign library .", "label": 1}, {"idx": "cosqa-train-10633", "doc": "add itemes to end of python liost", "code": "def append(self, item):\n        \"\"\" append item and print it to stdout \"\"\"\n        print(item)\n        super(MyList, self).append(item)", "code_tokens": "def append ( self , item ) : print ( item ) super ( MyList , self ) . append ( item )", "docstring_tokens": "append item and print it to stdout", "label": 1}, {"idx": "cosqa-train-10634", "doc": "python ctypes pass array of short", "code": "def cfloat32_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes float pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_float)):\n        return np.fromiter(cptr, dtype=np.float32, count=length)\n    else:\n        raise RuntimeError('Expected float pointer')", "code_tokens": "def cfloat32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_float ) ) : return np . fromiter ( cptr , dtype = np . float32 , count = length ) else : raise RuntimeError ( 'Expected float pointer' )", "docstring_tokens": "Convert a ctypes float pointer array to a numpy array .", "label": 1}, {"idx": "cosqa-train-10635", "doc": "add iterable to list python", "code": "def concat(cls, iterables):\n    \"\"\"\n    Similar to #itertools.chain.from_iterable().\n    \"\"\"\n\n    def generator():\n      for it in iterables:\n        for element in it:\n          yield element\n    return cls(generator())", "code_tokens": "def concat ( cls , iterables ) : def generator ( ) : for it in iterables : for element in it : yield element return cls ( generator ( ) )", "docstring_tokens": "Similar to #itertools . chain . from_iterable () .", "label": 0}, {"idx": "cosqa-train-10636", "doc": "python ctypes pass string to c char*", "code": "def c_str(string):\n    \"\"\"\"Convert a python string to C string.\"\"\"\n    if not isinstance(string, str):\n        string = string.decode('ascii')\n    return ctypes.c_char_p(string.encode('utf-8'))", "code_tokens": "def c_str ( string ) : if not isinstance ( string , str ) : string = string . decode ( 'ascii' ) return ctypes . c_char_p ( string . encode ( 'utf-8' ) )", "docstring_tokens": "Convert a python string to C string .", "label": 1}, {"idx": "cosqa-train-10637", "doc": "add noise to the audio python", "code": "def synthesize(self, duration):\n        \"\"\"\n        Synthesize white noise\n\n        Args:\n            duration (numpy.timedelta64): The duration of the synthesized sound\n        \"\"\"\n        sr = self.samplerate.samples_per_second\n        seconds = duration / Seconds(1)\n        samples = np.random.uniform(low=-1., high=1., size=int(sr * seconds))\n        return AudioSamples(samples, self.samplerate)", "code_tokens": "def synthesize ( self , duration ) : sr = self . samplerate . samples_per_second seconds = duration / Seconds ( 1 ) samples = np . random . uniform ( low = - 1. , high = 1. , size = int ( sr * seconds ) ) return AudioSamples ( samples , self . samplerate )", "docstring_tokens": "Synthesize white noise", "label": 1}, {"idx": "cosqa-train-10638", "doc": "python ctypes structure dictionary", "code": "def struct2dict(struct):\n    \"\"\"convert a ctypes structure to a dictionary\"\"\"\n    return {x: getattr(struct, x) for x in dict(struct._fields_).keys()}", "code_tokens": "def struct2dict ( struct ) : return { x : getattr ( struct , x ) for x in dict ( struct . _fields_ ) . keys ( ) }", "docstring_tokens": "convert a ctypes structure to a dictionary", "label": 1}, {"idx": "cosqa-train-10639", "doc": "adding text to images in python", "code": "def add_text_to_image(fname, txt, opFilename):\n    \"\"\" convert an image by adding text \"\"\"\n    ft = ImageFont.load(\"T://user//dev//src//python//_AS_LIB//timR24.pil\")\n    #wh = ft.getsize(txt)\n    print(\"Adding text \", txt, \" to \", fname, \" pixels wide to file \" , opFilename)\n    im = Image.open(fname)\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), txt, fill=(0, 0, 0), font=ft)\n    del draw  \n    im.save(opFilename)", "code_tokens": "def add_text_to_image ( fname , txt , opFilename ) : ft = ImageFont . load ( \"T://user//dev//src//python//_AS_LIB//timR24.pil\" ) #wh = ft.getsize(txt) print ( \"Adding text \" , txt , \" to \" , fname , \" pixels wide to file \" , opFilename ) im = Image . open ( fname ) draw = ImageDraw . Draw ( im ) draw . text ( ( 0 , 0 ) , txt , fill = ( 0 , 0 , 0 ) , font = ft ) del draw im . save ( opFilename )", "docstring_tokens": "convert an image by adding text", "label": 0}, {"idx": "cosqa-train-10640", "doc": "python ctypes use string", "code": "def c_str(string):\n    \"\"\"\"Convert a python string to C string.\"\"\"\n    if not isinstance(string, str):\n        string = string.decode('ascii')\n    return ctypes.c_char_p(string.encode('utf-8'))", "code_tokens": "def c_str ( string ) : if not isinstance ( string , str ) : string = string . decode ( 'ascii' ) return ctypes . c_char_p ( string . encode ( 'utf-8' ) )", "docstring_tokens": "Convert a python string to C string .", "label": 1}, {"idx": "cosqa-train-10641", "doc": "admin run command for python in cmd", "code": "def managepy(cmd, extra=None):\n    \"\"\"Run manage.py using this component's specific Django settings\"\"\"\n\n    extra = extra.split() if extra else []\n    run_django_cli(['invoke', cmd] + extra)", "code_tokens": "def managepy ( cmd , extra = None ) : extra = extra . split ( ) if extra else [ ] run_django_cli ( [ 'invoke' , cmd ] + extra )", "docstring_tokens": "Run manage . py using this component s specific Django settings", "label": 0}, {"idx": "cosqa-train-10642", "doc": "python curses add string without moving cursor", "code": "def add_str(window, line_num, str):\n    \"\"\" attempt to draw str on screen and ignore errors if they occur \"\"\"\n    try:\n        window.addstr(line_num, 0, str)\n    except curses.error:\n        pass", "code_tokens": "def add_str ( window , line_num , str ) : try : window . addstr ( line_num , 0 , str ) except curses . error : pass", "docstring_tokens": "attempt to draw str on screen and ignore errors if they occur", "label": 1}, {"idx": "cosqa-train-10643", "doc": "amax python for 3d numpy array", "code": "def Max(a, axis, keep_dims):\n    \"\"\"\n    Max reduction op.\n    \"\"\"\n    return np.amax(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis),\n                   keepdims=keep_dims),", "code_tokens": "def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "docstring_tokens": "Max reduction op .", "label": 1}, {"idx": "cosqa-train-10644", "doc": "python curses window addstr", "code": "def add_str(window, line_num, str):\n    \"\"\" attempt to draw str on screen and ignore errors if they occur \"\"\"\n    try:\n        window.addstr(line_num, 0, str)\n    except curses.error:\n        pass", "code_tokens": "def add_str ( window , line_num , str ) : try : window . addstr ( line_num , 0 , str ) except curses . error : pass", "docstring_tokens": "attempt to draw str on screen and ignore errors if they occur", "label": 1}, {"idx": "cosqa-train-10645", "doc": "anyway to inject javascript with python", "code": "def add_to_js(self, name, var):\n        \"\"\"Add an object to Javascript.\"\"\"\n        frame = self.page().mainFrame()\n        frame.addToJavaScriptWindowObject(name, var)", "code_tokens": "def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )", "docstring_tokens": "Add an object to Javascript .", "label": 1}, {"idx": "cosqa-train-10646", "doc": "python cycle through files with specific extension", "code": "def glob_by_extensions(directory, extensions):\n    \"\"\" Returns files matched by all extensions in the extensions list \"\"\"\n    directorycheck(directory)\n    files = []\n    xt = files.extend\n    for ex in extensions:\n        xt(glob.glob('{0}/*.{1}'.format(directory, ex)))\n    return files", "code_tokens": "def glob_by_extensions ( directory , extensions ) : directorycheck ( directory ) files = [ ] xt = files . extend for ex in extensions : xt ( glob . glob ( '{0}/*.{1}' . format ( directory , ex ) ) ) return files", "docstring_tokens": "Returns files matched by all extensions in the extensions list", "label": 1}, {"idx": "cosqa-train-10647", "doc": "apply a list of functions python", "code": "def compose(*funcs):\n    \"\"\"compose a list of functions\"\"\"\n    return lambda x: reduce(lambda v, f: f(v), reversed(funcs), x)", "code_tokens": "def compose ( * funcs ) : return lambda x : reduce ( lambda v , f : f ( v ) , reversed ( funcs ) , x )", "docstring_tokens": "compose a list of functions", "label": 1}, {"idx": "cosqa-train-10648", "doc": "python data frame drop columns without names", "code": "def del_Unnamed(df):\n    \"\"\"\n    Deletes all the unnamed columns\n\n    :param df: pandas dataframe\n    \"\"\"\n    cols_del=[c for c in df.columns if 'Unnamed' in c]\n    return df.drop(cols_del,axis=1)", "code_tokens": "def del_Unnamed ( df ) : cols_del = [ c for c in df . columns if 'Unnamed' in c ] return df . drop ( cols_del , axis = 1 )", "docstring_tokens": "Deletes all the unnamed columns", "label": 1}, {"idx": "cosqa-train-10649", "doc": "apply a texture opengl python", "code": "def load(self):\n\t\t\"\"\"Load the noise texture data into the current texture unit\"\"\"\n\t\tglTexImage3D(GL_TEXTURE_3D, 0, GL_LUMINANCE16_ALPHA16, \n\t\t\tself.width, self.width, self.width, 0, GL_LUMINANCE_ALPHA, \n\t\t\tGL_UNSIGNED_SHORT, ctypes.byref(self.data))", "code_tokens": "def load ( self ) : glTexImage3D ( GL_TEXTURE_3D , 0 , GL_LUMINANCE16_ALPHA16 , self . width , self . width , self . width , 0 , GL_LUMINANCE_ALPHA , GL_UNSIGNED_SHORT , ctypes . byref ( self . data ) )", "docstring_tokens": "Load the noise texture data into the current texture unit", "label": 1}, {"idx": "cosqa-train-10650", "doc": "python datatype of an array check condition", "code": "def is_iterable(value):\n    \"\"\"must be an iterable (list, array, tuple)\"\"\"\n    return isinstance(value, np.ndarray) or isinstance(value, list) or isinstance(value, tuple), value", "code_tokens": "def is_iterable ( value ) : return isinstance ( value , np . ndarray ) or isinstance ( value , list ) or isinstance ( value , tuple ) , value", "docstring_tokens": "must be an iterable ( list array tuple )", "label": 0}, {"idx": "cosqa-train-10651", "doc": "apply function to a table python", "code": "def make_table_map(table, headers):\n    \"\"\"Create a function to map from rows with the structure of the headers to the structure of the table.\"\"\"\n\n    header_parts = {}\n    for i, h in enumerate(headers):\n        header_parts[h] = 'row[{}]'.format(i)\n\n    body_code = 'lambda row: [{}]'.format(','.join(header_parts.get(c.name, 'None') for c in table.columns))\n    header_code = 'lambda row: [{}]'.format(\n        ','.join(header_parts.get(c.name, \"'{}'\".format(c.name)) for c in table.columns))\n\n    return eval(header_code), eval(body_code)", "code_tokens": "def make_table_map ( table , headers ) : header_parts = { } for i , h in enumerate ( headers ) : header_parts [ h ] = 'row[{}]' . format ( i ) body_code = 'lambda row: [{}]' . format ( ',' . join ( header_parts . get ( c . name , 'None' ) for c in table . columns ) ) header_code = 'lambda row: [{}]' . format ( ',' . join ( header_parts . get ( c . name , \"'{}'\" . format ( c . name ) ) for c in table . columns ) ) return eval ( header_code ) , eval ( body_code )", "docstring_tokens": "Create a function to map from rows with the structure of the headers to the structure of the table .", "label": 1}, {"idx": "cosqa-train-10652", "doc": "python datetime delta total milliseconds", "code": "def datetime_delta_to_ms(delta):\n    \"\"\"\n    Given a datetime.timedelta object, return the delta in milliseconds\n    \"\"\"\n    delta_ms = delta.days * 24 * 60 * 60 * 1000\n    delta_ms += delta.seconds * 1000\n    delta_ms += delta.microseconds / 1000\n    delta_ms = int(delta_ms)\n    return delta_ms", "code_tokens": "def datetime_delta_to_ms ( delta ) : delta_ms = delta . days * 24 * 60 * 60 * 1000 delta_ms += delta . seconds * 1000 delta_ms += delta . microseconds / 1000 delta_ms = int ( delta_ms ) return delta_ms", "docstring_tokens": "Given a datetime . timedelta object return the delta in milliseconds", "label": 1}, {"idx": "cosqa-train-10653", "doc": "apply upper case python function", "code": "def upcaseTokens(s,l,t):\n    \"\"\"Helper parse action to convert tokens to upper case.\"\"\"\n    return [ tt.upper() for tt in map(_ustr,t) ]", "code_tokens": "def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]", "docstring_tokens": "Helper parse action to convert tokens to upper case .", "label": 1}, {"idx": "cosqa-train-10654", "doc": "python datetime isoformat formatstring", "code": "def isoformat(dt):\n    \"\"\"Return an ISO-8601 formatted string from the provided datetime object\"\"\"\n    if not isinstance(dt, datetime.datetime):\n        raise TypeError(\"Must provide datetime.datetime object to isoformat\")\n\n    if dt.tzinfo is None:\n        raise ValueError(\"naive datetime objects are not allowed beyond the library boundaries\")\n\n    return dt.isoformat().replace(\"+00:00\", \"Z\")", "code_tokens": "def isoformat ( dt ) : if not isinstance ( dt , datetime . datetime ) : raise TypeError ( \"Must provide datetime.datetime object to isoformat\" ) if dt . tzinfo is None : raise ValueError ( \"naive datetime objects are not allowed beyond the library boundaries\" ) return dt . isoformat ( ) . replace ( \"+00:00\" , \"Z\" )", "docstring_tokens": "Return an ISO - 8601 formatted string from the provided datetime object", "label": 1}, {"idx": "cosqa-train-10655", "doc": "area of a triangle using python", "code": "def get_tri_area(pts):\n    \"\"\"\n    Given a list of coords for 3 points,\n    Compute the area of this triangle.\n\n    Args:\n        pts: [a, b, c] three points\n    \"\"\"\n    a, b, c = pts[0], pts[1], pts[2]\n    v1 = np.array(b) - np.array(a)\n    v2 = np.array(c) - np.array(a)\n    area_tri = abs(sp.linalg.norm(sp.cross(v1, v2)) / 2)\n    return area_tri", "code_tokens": "def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri", "docstring_tokens": "Given a list of coords for 3 points Compute the area of this triangle .", "label": 1}, {"idx": "cosqa-train-10656", "doc": "python datetime timestamp to human readable", "code": "def timestamp_to_datetime(cls, dt, dt_format=DATETIME_FORMAT):\n        \"\"\"Convert unix timestamp to human readable date/time string\"\"\"\n        return cls.convert_datetime(cls.get_datetime(dt), dt_format=dt_format)", "code_tokens": "def timestamp_to_datetime ( cls , dt , dt_format = DATETIME_FORMAT ) : return cls . convert_datetime ( cls . get_datetime ( dt ) , dt_format = dt_format )", "docstring_tokens": "Convert unix timestamp to human readable date / time string", "label": 1}, {"idx": "cosqa-train-10657", "doc": "argmax of array values in python", "code": "def findMax(arr):\n    \"\"\"\n    in comparison to argrelmax() more simple and  reliable peak finder\n    \"\"\"\n    out = np.zeros(shape=arr.shape, dtype=bool)\n    _calcMax(arr, out)\n    return out", "code_tokens": "def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out", "docstring_tokens": "in comparison to argrelmax () more simple and reliable peak finder", "label": 1}, {"idx": "cosqa-train-10658", "doc": "python datetime to iso datetime", "code": "async def iso(self, source):\n        \"\"\"Convert to timestamp.\"\"\"\n        from datetime import datetime\n        unix_timestamp = int(source)\n        return datetime.fromtimestamp(unix_timestamp).isoformat()", "code_tokens": "async def iso ( self , source ) : from datetime import datetime unix_timestamp = int ( source ) return datetime . fromtimestamp ( unix_timestamp ) . isoformat ( )", "docstring_tokens": "Convert to timestamp .", "label": 1}, {"idx": "cosqa-train-10659", "doc": "array to ascii python", "code": "def barray(iterlines):\n    \"\"\"\n    Array of bytes\n    \"\"\"\n    lst = [line.encode('utf-8') for line in iterlines]\n    arr = numpy.array(lst)\n    return arr", "code_tokens": "def barray ( iterlines ) : lst = [ line . encode ( 'utf-8' ) for line in iterlines ] arr = numpy . array ( lst ) return arr", "docstring_tokens": "Array of bytes", "label": 0}, {"idx": "cosqa-train-10660", "doc": "python datetime truncate microseconds", "code": "def ms_to_datetime(ms):\n    \"\"\"\n    Converts a millisecond accuracy timestamp to a datetime\n    \"\"\"\n    dt = datetime.datetime.utcfromtimestamp(ms / 1000)\n    return dt.replace(microsecond=(ms % 1000) * 1000).replace(tzinfo=pytz.utc)", "code_tokens": "def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )", "docstring_tokens": "Converts a millisecond accuracy timestamp to a datetime", "label": 1}, {"idx": "cosqa-train-10661", "doc": "ascii capital letters python", "code": "def to_camel_case(snake_case_name):\n    \"\"\"\n    Converts snake_cased_names to CamelCaseNames.\n\n    :param snake_case_name: The name you'd like to convert from.\n    :type snake_case_name: string\n\n    :returns: A converted string\n    :rtype: string\n    \"\"\"\n    bits = snake_case_name.split('_')\n    return ''.join([bit.capitalize() for bit in bits])", "code_tokens": "def to_camel_case ( snake_case_name ) : bits = snake_case_name . split ( '_' ) return '' . join ( [ bit . capitalize ( ) for bit in bits ] )", "docstring_tokens": "Converts snake_cased_names to CamelCaseNames .", "label": 0}, {"idx": "cosqa-train-10662", "doc": "python datetime with tzinfo from timestamp", "code": "def convert_tstamp(response):\n\t\"\"\"\n\tConvert a Stripe API timestamp response (unix epoch) to a native datetime.\n\n\t:rtype: datetime\n\t\"\"\"\n\tif response is None:\n\t\t# Allow passing None to convert_tstamp()\n\t\treturn response\n\n\t# Overrides the set timezone to UTC - I think...\n\ttz = timezone.utc if settings.USE_TZ else None\n\n\treturn datetime.datetime.fromtimestamp(response, tz)", "code_tokens": "def convert_tstamp ( response ) : if response is None : # Allow passing None to convert_tstamp() return response # Overrides the set timezone to UTC - I think... tz = timezone . utc if settings . USE_TZ else None return datetime . datetime . fromtimestamp ( response , tz )", "docstring_tokens": "Convert a Stripe API timestamp response ( unix epoch ) to a native datetime .", "label": 1}, {"idx": "cosqa-train-10663", "doc": "auto crop particular object from image in python", "code": "def crop_box(im, box=False, **kwargs):\n    \"\"\"Uses box coordinates to crop an image without resizing it first.\"\"\"\n    if box:\n        im = im.crop(box)\n    return im", "code_tokens": "def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im", "docstring_tokens": "Uses box coordinates to crop an image without resizing it first .", "label": 1}, {"idx": "cosqa-train-10664", "doc": "python decision tree output node and depth", "code": "def cric__decision_tree():\n    \"\"\" Decision Tree\n    \"\"\"\n    model = sklearn.tree.DecisionTreeClassifier(random_state=0, max_depth=4)\n\n    # we want to explain the raw probability outputs of the trees\n    model.predict = lambda X: model.predict_proba(X)[:,1]\n    \n    return model", "code_tokens": "def cric__decision_tree ( ) : model = sklearn . tree . DecisionTreeClassifier ( random_state = 0 , max_depth = 4 ) # we want to explain the raw probability outputs of the trees model . predict = lambda X : model . predict_proba ( X ) [ : , 1 ] return model", "docstring_tokens": "Decision Tree", "label": 1}, {"idx": "cosqa-train-10665", "doc": "automaitcally crop images python", "code": "def crop_box(im, box=False, **kwargs):\n    \"\"\"Uses box coordinates to crop an image without resizing it first.\"\"\"\n    if box:\n        im = im.crop(box)\n    return im", "code_tokens": "def crop_box ( im , box = False , * * kwargs ) : if box : im = im . crop ( box ) return im", "docstring_tokens": "Uses box coordinates to crop an image without resizing it first .", "label": 1}, {"idx": "cosqa-train-10666", "doc": "python decision tree symbolic feature", "code": "def cric__decision_tree():\n    \"\"\" Decision Tree\n    \"\"\"\n    model = sklearn.tree.DecisionTreeClassifier(random_state=0, max_depth=4)\n\n    # we want to explain the raw probability outputs of the trees\n    model.predict = lambda X: model.predict_proba(X)[:,1]\n    \n    return model", "code_tokens": "def cric__decision_tree ( ) : model = sklearn . tree . DecisionTreeClassifier ( random_state = 0 , max_depth = 4 ) # we want to explain the raw probability outputs of the trees model . predict = lambda X : model . predict_proba ( X ) [ : , 1 ] return model", "docstring_tokens": "Decision Tree", "label": 1}, {"idx": "cosqa-train-10667", "doc": "aws ec2 python get instance ips", "code": "def get_ips(self, instance_id):\n        \"\"\"Retrieves all IP addresses associated to a given instance.\n\n        :return: tuple (IPs)\n        \"\"\"\n        instance = self._load_instance(instance_id)\n        IPs = sum(instance.networks.values(), [])\n        return IPs", "code_tokens": "def get_ips ( self , instance_id ) : instance = self . _load_instance ( instance_id ) IPs = sum ( instance . networks . values ( ) , [ ] ) return IPs", "docstring_tokens": "Retrieves all IP addresses associated to a given instance .", "label": 1}, {"idx": "cosqa-train-10668", "doc": "python decorate an instance method", "code": "def attribute(func):\n    \"\"\"Wrap a function as an attribute.\"\"\"\n    attr = abc.abstractmethod(func)\n    attr.__iattribute__ = True\n    attr = _property(attr)\n    return attr", "code_tokens": "def attribute ( func ) : attr = abc . abstractmethod ( func ) attr . __iattribute__ = True attr = _property ( attr ) return attr", "docstring_tokens": "Wrap a function as an attribute .", "label": 1}, {"idx": "cosqa-train-10669", "doc": "aws lambda python boto3 credential", "code": "def create_aws_lambda(ctx, bucket, region_name, aws_access_key_id, aws_secret_access_key):\n    \"\"\"Creates an AWS Chalice project for deployment to AWS Lambda.\"\"\"\n    from canari.commands.create_aws_lambda import create_aws_lambda\n    create_aws_lambda(ctx.project, bucket, region_name, aws_access_key_id, aws_secret_access_key)", "code_tokens": "def create_aws_lambda ( ctx , bucket , region_name , aws_access_key_id , aws_secret_access_key ) : from canari . commands . create_aws_lambda import create_aws_lambda create_aws_lambda ( ctx . project , bucket , region_name , aws_access_key_id , aws_secret_access_key )", "docstring_tokens": "Creates an AWS Chalice project for deployment to AWS Lambda .", "label": 1}, {"idx": "cosqa-train-10670", "doc": "python decorate function execution", "code": "def map_wrap(f):\n    \"\"\"Wrap standard function to easily pass into 'map' processing.\n    \"\"\"\n    @functools.wraps(f)\n    def wrapper(*args, **kwargs):\n        return f(*args, **kwargs)\n    return wrapper", "code_tokens": "def map_wrap ( f ) : @ functools . wraps ( f ) def wrapper ( * args , * * kwargs ) : return f ( * args , * * kwargs ) return wrapper", "docstring_tokens": "Wrap standard function to easily pass into map processing .", "label": 1}, {"idx": "cosqa-train-10671", "doc": "python decorate object method", "code": "def _iterable_to_varargs_method(func):\n    \"\"\"decorator to convert a method taking a iterable to a *args one\"\"\"\n    def wrapped(self, *args, **kwargs):\n        return func(self, args, **kwargs)\n    return wrapped", "code_tokens": "def _iterable_to_varargs_method ( func ) : def wrapped ( self , * args , * * kwargs ) : return func ( self , args , * * kwargs ) return wrapped", "docstring_tokens": "decorator to convert a method taking a iterable to a * args one", "label": 1}, {"idx": "cosqa-train-10672", "doc": "aws python list ec2 filter by tag", "code": "def _aws_get_instance_by_tag(region, name, tag, raw):\n    \"\"\"Get all instances matching a tag.\"\"\"\n    client = boto3.session.Session().client('ec2', region)\n    matching_reservations = client.describe_instances(Filters=[{'Name': tag, 'Values': [name]}]).get('Reservations', [])\n    instances = []\n    [[instances.append(_aws_instance_from_dict(region, instance, raw))  # pylint: disable=expression-not-assigned\n      for instance in reservation.get('Instances')] for reservation in matching_reservations if reservation]\n    return instances", "code_tokens": "def _aws_get_instance_by_tag ( region , name , tag , raw ) : client = boto3 . session . Session ( ) . client ( 'ec2' , region ) matching_reservations = client . describe_instances ( Filters = [ { 'Name' : tag , 'Values' : [ name ] } ] ) . get ( 'Reservations' , [ ] ) instances = [ ] [ [ instances . append ( _aws_instance_from_dict ( region , instance , raw ) ) # pylint: disable=expression-not-assigned for instance in reservation . get ( 'Instances' ) ] for reservation in matching_reservations if reservation ] return instances", "docstring_tokens": "Get all instances matching a tag .", "label": 1}, {"idx": "cosqa-train-10673", "doc": "python def specify variable type", "code": "def visit_Str(self, node):\n        \"\"\" Set the pythonic string type. \"\"\"\n        self.result[node] = self.builder.NamedType(pytype_to_ctype(str))", "code_tokens": "def visit_Str ( self , node ) : self . result [ node ] = self . builder . NamedType ( pytype_to_ctype ( str ) )", "docstring_tokens": "Set the pythonic string type .", "label": 0}, {"idx": "cosqa-train-10674", "doc": "axes3d view setting python 3", "code": "def plot3d_init(fignum):\n    \"\"\"\n    initializes 3D plot\n    \"\"\"\n    from mpl_toolkits.mplot3d import Axes3D\n    fig = plt.figure(fignum)\n    ax = fig.add_subplot(111, projection='3d')\n    return ax", "code_tokens": "def plot3d_init ( fignum ) : from mpl_toolkits . mplot3d import Axes3D fig = plt . figure ( fignum ) ax = fig . add_subplot ( 111 , projection = '3d' ) return ax", "docstring_tokens": "initializes 3D plot", "label": 1}, {"idx": "cosqa-train-10675", "doc": "python def to remove duplicates from excel file", "code": "def _remove_duplicate_files(xs):\n    \"\"\"Remove files specified multiple times in a list.\n    \"\"\"\n    seen = set([])\n    out = []\n    for x in xs:\n        if x[\"path\"] not in seen:\n            out.append(x)\n            seen.add(x[\"path\"])\n    return out", "code_tokens": "def _remove_duplicate_files ( xs ) : seen = set ( [ ] ) out = [ ] for x in xs : if x [ \"path\" ] not in seen : out . append ( x ) seen . add ( x [ \"path\" ] ) return out", "docstring_tokens": "Remove files specified multiple times in a list .", "label": 1}, {"idx": "cosqa-train-10676", "doc": "best normalized 2d python", "code": "def standardize():\n    \"\"\"\n    return variant standarize function\n    \"\"\"\n\n    def f(G, bim):\n        G_out = standardize_snps(G)\n        return G_out, bim\n\n    return f", "code_tokens": "def standardize ( ) : def f ( G , bim ) : G_out = standardize_snps ( G ) return G_out , bim return f", "docstring_tokens": "return variant standarize function", "label": 0}, {"idx": "cosqa-train-10677", "doc": "python default function value not being overwritten", "code": "def setdefault(obj, field, default):\n    \"\"\"Set an object's field to default if it doesn't have a value\"\"\"\n    setattr(obj, field, getattr(obj, field, default))", "code_tokens": "def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )", "docstring_tokens": "Set an object s field to default if it doesn t have a value", "label": 1}, {"idx": "cosqa-train-10678", "doc": "best way to do two way mapping python", "code": "def _merge_maps(m1, m2):\n    \"\"\"merge two Mapping objects, keeping the type of the first mapping\"\"\"\n    return type(m1)(chain(m1.items(), m2.items()))", "code_tokens": "def _merge_maps ( m1 , m2 ) : return type ( m1 ) ( chain ( m1 . items ( ) , m2 . items ( ) ) )", "docstring_tokens": "merge two Mapping objects keeping the type of the first mapping", "label": 1}, {"idx": "cosqa-train-10679", "doc": "python default value if null", "code": "def safe_int(val, default=None):\n    \"\"\"\n    Returns int() of val if val is not convertable to int use default\n    instead\n\n    :param val:\n    :param default:\n    \"\"\"\n\n    try:\n        val = int(val)\n    except (ValueError, TypeError):\n        val = default\n\n    return val", "code_tokens": "def safe_int ( val , default = None ) : try : val = int ( val ) except ( ValueError , TypeError ) : val = default return val", "docstring_tokens": "Returns int () of val if val is not convertable to int use default instead", "label": 1}, {"idx": "cosqa-train-10680", "doc": "best way to get key against a value from python dictionary", "code": "def get_key_by_value(dictionary, search_value):\n    \"\"\"\n    searchs a value in a dicionary and returns the key of the first occurrence\n\n    :param dictionary: dictionary to search in\n    :param search_value: value to search for\n    \"\"\"\n    for key, value in dictionary.iteritems():\n        if value == search_value:\n            return ugettext(key)", "code_tokens": "def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )", "docstring_tokens": "searchs a value in a dicionary and returns the key of the first occurrence", "label": 1}, {"idx": "cosqa-train-10681", "doc": "python delete a unempty folder", "code": "def remove_examples_all():\n    \"\"\"remove arduino/examples/all directory.\n\n    :rtype: None\n\n    \"\"\"\n    d = examples_all_dir()\n    if d.exists():\n        log.debug('remove %s', d)\n        d.rmtree()\n    else:\n        log.debug('nothing to remove: %s', d)", "code_tokens": "def remove_examples_all ( ) : d = examples_all_dir ( ) if d . exists ( ) : log . debug ( 'remove %s' , d ) d . rmtree ( ) else : log . debug ( 'nothing to remove: %s' , d )", "docstring_tokens": "remove arduino / examples / all directory .", "label": 0}, {"idx": "cosqa-train-10682", "doc": "best way to see xml content in python", "code": "def __get_xml_text(root):\n    \"\"\" Return the text for the given root node (xml.dom.minidom). \"\"\"\n    txt = \"\"\n    for e in root.childNodes:\n        if (e.nodeType == e.TEXT_NODE):\n            txt += e.data\n    return txt", "code_tokens": "def __get_xml_text ( root ) : txt = \"\" for e in root . childNodes : if ( e . nodeType == e . TEXT_NODE ) : txt += e . data return txt", "docstring_tokens": "Return the text for the given root node ( xml . dom . minidom ) .", "label": 1}, {"idx": "cosqa-train-10683", "doc": "python deleting the cache", "code": "def __delitem__(self, resource):\n        \"\"\"Remove resource instance from internal cache\"\"\"\n        self.__caches[type(resource)].pop(resource.get_cache_internal_key(), None)", "code_tokens": "def __delitem__ ( self , resource ) : self . __caches [ type ( resource ) ] . pop ( resource . get_cache_internal_key ( ) , None )", "docstring_tokens": "Remove resource instance from internal cache", "label": 1}, {"idx": "cosqa-train-10684", "doc": "best way to stringify python object", "code": "def get_object_as_string(obj):\n    \"\"\"\n    Converts any object to JSON-like readable format, ready to be printed for debugging purposes\n    :param obj: Any object\n    :return: string\n    \"\"\"\n    if isinstance(obj, str):\n        return obj\n    if isinstance(obj, list):\n        return '\\r\\n\\;'.join([get_object_as_string(item) for item in obj])\n    attrs = vars(obj)\n    as_string = ', '.join(\"%s: %s\" % item for item in attrs.items())\n    return as_string", "code_tokens": "def get_object_as_string ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , list ) : return '\\r\\n\\;' . join ( [ get_object_as_string ( item ) for item in obj ] ) attrs = vars ( obj ) as_string = ', ' . join ( \"%s: %s\" % item for item in attrs . items ( ) ) return as_string", "docstring_tokens": "Converts any object to JSON - like readable format ready to be printed for debugging purposes : param obj : Any object : return : string", "label": 1}, {"idx": "cosqa-train-10685", "doc": "python design time domain high pass filter", "code": "def highpass(cutoff):\n  \"\"\"\n  This strategy uses an exponential approximation for cut-off frequency\n  calculation, found by matching the one-pole Laplace lowpass filter\n  and mirroring the resulting filter to get a highpass.\n  \"\"\"\n  R = thub(exp(cutoff - pi), 2)\n  return (1 - R) / (1 + R * z ** -1)", "code_tokens": "def highpass ( cutoff ) : R = thub ( exp ( cutoff - pi ) , 2 ) return ( 1 - R ) / ( 1 + R * z ** - 1 )", "docstring_tokens": "This strategy uses an exponential approximation for cut - off frequency calculation found by matching the one - pole Laplace lowpass filter and mirroring the resulting filter to get a highpass .", "label": 1}, {"idx": "cosqa-train-10686", "doc": "bits to binary python", "code": "def intToBin(i):\n    \"\"\" Integer to two bytes \"\"\"\n    # devide in two parts (bytes)\n    i1 = i % 256\n    i2 = int(i / 256)\n    # make string (little endian)\n    return chr(i1) + chr(i2)", "code_tokens": "def intToBin ( i ) : # devide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return chr ( i1 ) + chr ( i2 )", "docstring_tokens": "Integer to two bytes", "label": 1}, {"idx": "cosqa-train-10687", "doc": "python detect gaps in list", "code": "def _gaps_from(intervals):\n    \"\"\"\n    From a list of intervals extract\n    a list of sorted gaps in the form of [(g,i)]\n    where g is the size of the ith gap.\n    \"\"\"\n    sliding_window = zip(intervals, intervals[1:])\n    gaps = [b[0] - a[1] for a, b in sliding_window]\n    return gaps", "code_tokens": "def _gaps_from ( intervals ) : sliding_window = zip ( intervals , intervals [ 1 : ] ) gaps = [ b [ 0 ] - a [ 1 ] for a , b in sliding_window ] return gaps", "docstring_tokens": "From a list of intervals extract a list of sorted gaps in the form of [ ( g i ) ] where g is the size of the ith gap .", "label": 1}, {"idx": "cosqa-train-10688", "doc": "black or white background python", "code": "def set_color(self, fg=None, bg=None, intensify=False, target=sys.stdout):\n        \"\"\"Set foreground- and background colors and intensity.\"\"\"\n        raise NotImplementedError", "code_tokens": "def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError", "docstring_tokens": "Set foreground - and background colors and intensity .", "label": 1}, {"idx": "cosqa-train-10689", "doc": "python detect if function is a method", "code": "def isroutine(object):\n    \"\"\"Return true if the object is any kind of function or method.\"\"\"\n    return (isbuiltin(object)\n            or isfunction(object)\n            or ismethod(object)\n            or ismethoddescriptor(object))", "code_tokens": "def isroutine ( object ) : return ( isbuiltin ( object ) or isfunction ( object ) or ismethod ( object ) or ismethoddescriptor ( object ) )", "docstring_tokens": "Return true if the object is any kind of function or method .", "label": 1}, {"idx": "cosqa-train-10690", "doc": "boxplot not accurate python", "code": "def compute_boxplot(self, series):\n        \"\"\"\n        Compute boxplot for given pandas Series.\n        \"\"\"\n        from matplotlib.cbook import boxplot_stats\n        series = series[series.notnull()]\n        if len(series.values) == 0:\n            return {}\n        elif not is_numeric_dtype(series):\n            return self.non_numeric_stats(series)\n        stats = boxplot_stats(list(series.values))[0]\n        stats['count'] = len(series.values)\n        stats['fliers'] = \"|\".join(map(str, stats['fliers']))\n        return stats", "code_tokens": "def compute_boxplot ( self , series ) : from matplotlib . cbook import boxplot_stats series = series [ series . notnull ( ) ] if len ( series . values ) == 0 : return { } elif not is_numeric_dtype ( series ) : return self . non_numeric_stats ( series ) stats = boxplot_stats ( list ( series . values ) ) [ 0 ] stats [ 'count' ] = len ( series . values ) stats [ 'fliers' ] = \"|\" . join ( map ( str , stats [ 'fliers' ] ) ) return stats", "docstring_tokens": "Compute boxplot for given pandas Series .", "label": 1}, {"idx": "cosqa-train-10691", "doc": "python detect parent process exit", "code": "def kill_mprocess(process):\n    \"\"\"kill process\n    Args:\n        process - Popen object for process\n    \"\"\"\n    if process and proc_alive(process):\n        process.terminate()\n        process.communicate()\n    return not proc_alive(process)", "code_tokens": "def kill_mprocess ( process ) : if process and proc_alive ( process ) : process . terminate ( ) process . communicate ( ) return not proc_alive ( process )", "docstring_tokens": "kill process Args : process - Popen object for process", "label": 1}, {"idx": "cosqa-train-10692", "doc": "bring window to focus python", "code": "def inFocus(self):\n        \"\"\"Set GUI on-top flag\"\"\"\n        previous_flags = self.window.flags()\n        self.window.setFlags(previous_flags |\n                             QtCore.Qt.WindowStaysOnTopHint)", "code_tokens": "def inFocus ( self ) : previous_flags = self . window . flags ( ) self . window . setFlags ( previous_flags | QtCore . Qt . WindowStaysOnTopHint )", "docstring_tokens": "Set GUI on - top flag", "label": 1}, {"idx": "cosqa-train-10693", "doc": "python determine file empty", "code": "def file_empty(fp):\n    \"\"\"Determine if a file is empty or not.\"\"\"\n    # for python 2 we need to use a homemade peek()\n    if six.PY2:\n        contents = fp.read()\n        fp.seek(0)\n        return not bool(contents)\n\n    else:\n        return not fp.peek()", "code_tokens": "def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )", "docstring_tokens": "Determine if a file is empty or not .", "label": 1}, {"idx": "cosqa-train-10694", "doc": "bringing frame within a frame into toplevel python", "code": "def __pop_top_frame(self):\n        \"\"\"Pops the top frame off the frame stack.\"\"\"\n        popped = self.__stack.pop()\n        if self.__stack:\n            self.__stack[-1].process_subframe(popped)", "code_tokens": "def __pop_top_frame ( self ) : popped = self . __stack . pop ( ) if self . __stack : self . __stack [ - 1 ] . process_subframe ( popped )", "docstring_tokens": "Pops the top frame off the frame stack .", "label": 1}, {"idx": "cosqa-train-10695", "doc": "python determine process memory usage", "code": "def machine_info():\n    \"\"\"Retrieve core and memory information for the current machine.\n    \"\"\"\n    import psutil\n    BYTES_IN_GIG = 1073741824.0\n    free_bytes = psutil.virtual_memory().total\n    return [{\"memory\": float(\"%.1f\" % (free_bytes / BYTES_IN_GIG)), \"cores\": multiprocessing.cpu_count(),\n             \"name\": socket.gethostname()}]", "code_tokens": "def machine_info ( ) : import psutil BYTES_IN_GIG = 1073741824.0 free_bytes = psutil . virtual_memory ( ) . total return [ { \"memory\" : float ( \"%.1f\" % ( free_bytes / BYTES_IN_GIG ) ) , \"cores\" : multiprocessing . cpu_count ( ) , \"name\" : socket . gethostname ( ) } ]", "docstring_tokens": "Retrieve core and memory information for the current machine .", "label": 1}, {"idx": "cosqa-train-10696", "doc": "build python extension with compile flag", "code": "def code(self):\n    \"\"\"Returns the code object for this BUILD file.\"\"\"\n    return compile(self.source(), self.full_path, 'exec', flags=0, dont_inherit=True)", "code_tokens": "def code ( self ) : return compile ( self . source ( ) , self . full_path , 'exec' , flags = 0 , dont_inherit = True )", "docstring_tokens": "Returns the code object for this BUILD file .", "label": 1}, {"idx": "cosqa-train-10697", "doc": "python determining bytes on a buffered reader", "code": "def read_string(buff, byteorder='big'):\n    \"\"\"Read a string from a file-like object.\"\"\"\n    length = read_numeric(USHORT, buff, byteorder)\n    return buff.read(length).decode('utf-8')", "code_tokens": "def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )", "docstring_tokens": "Read a string from a file - like object .", "label": 1}, {"idx": "cosqa-train-10698", "doc": "built in python ftp server", "code": "def connect(host, port, username, password):\n        \"\"\"Connect and login to an FTP server and return ftplib.FTP object.\"\"\"\n        # Instantiate ftplib client\n        session = ftplib.FTP()\n\n        # Connect to host without auth\n        session.connect(host, port)\n\n        # Authenticate connection\n        session.login(username, password)\n        return session", "code_tokens": "def connect ( host , port , username , password ) : # Instantiate ftplib client session = ftplib . FTP ( ) # Connect to host without auth session . connect ( host , port ) # Authenticate connection session . login ( username , password ) return session", "docstring_tokens": "Connect and login to an FTP server and return ftplib . FTP object .", "label": 1}, {"idx": "cosqa-train-10699", "doc": "python diagonal matrix boolen", "code": "def is_bool_matrix(l):\n    r\"\"\"Checks if l is a 2D numpy array of bools\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 2 and (l.dtype == bool):\n            return True\n    return False", "code_tokens": "def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False", "docstring_tokens": "r Checks if l is a 2D numpy array of bools", "label": 1}, {"idx": "cosqa-train-10700", "doc": "bytearray in python for array", "code": "def barray(iterlines):\n    \"\"\"\n    Array of bytes\n    \"\"\"\n    lst = [line.encode('utf-8') for line in iterlines]\n    arr = numpy.array(lst)\n    return arr", "code_tokens": "def barray ( iterlines ) : lst = [ line . encode ( 'utf-8' ) for line in iterlines ] arr = numpy . array ( lst ) return arr", "docstring_tokens": "Array of bytes", "label": 1}, {"idx": "cosqa-train-10701", "doc": "python dict keys iterable", "code": "def itervalues(d, **kw):\n    \"\"\"Return an iterator over the values of a dictionary.\"\"\"\n    if not PY2:\n        return iter(d.values(**kw))\n    return d.itervalues(**kw)", "code_tokens": "def itervalues ( d , * * kw ) : if not PY2 : return iter ( d . values ( * * kw ) ) return d . itervalues ( * * kw )", "docstring_tokens": "Return an iterator over the values of a dictionary .", "label": 1}, {"idx": "cosqa-train-10702", "doc": "bytes to gzip object python", "code": "def ungzip_data(input_data):\n    \"\"\"Return a string of data after gzip decoding\n\n    :param the input gziped data\n    :return  the gzip decoded data\"\"\"\n    buf = StringIO(input_data)\n    f = gzip.GzipFile(fileobj=buf)\n    return f", "code_tokens": "def ungzip_data ( input_data ) : buf = StringIO ( input_data ) f = gzip . GzipFile ( fileobj = buf ) return f", "docstring_tokens": "Return a string of data after gzip decoding", "label": 1}, {"idx": "cosqa-train-10703", "doc": "bytes to json object python", "code": "def loadb(b):\n    \"\"\"Deserialize ``b`` (instance of ``bytes``) to a Python object.\"\"\"\n    assert isinstance(b, (bytes, bytearray))\n    return std_json.loads(b.decode('utf-8'))", "code_tokens": "def loadb ( b ) : assert isinstance ( b , ( bytes , bytearray ) ) return std_json . loads ( b . decode ( 'utf-8' ) )", "docstring_tokens": "Deserialize b ( instance of bytes ) to a Python object .", "label": 1}, {"idx": "cosqa-train-10704", "doc": "python dictionary best way to check if item in set and get value", "code": "def is_set(self, key):\n        \"\"\"Return True if variable is a set\"\"\"\n        data = self.model.get_data()\n        return isinstance(data[key], set)", "code_tokens": "def is_set ( self , key ) : data = self . model . get_data ( ) return isinstance ( data [ key ] , set )", "docstring_tokens": "Return True if variable is a set", "label": 1}, {"idx": "cosqa-train-10705", "doc": "c++ equivelence of def in python", "code": "def is_static(*p):\n    \"\"\" A static value (does not change at runtime)\n    which is known at compile time\n    \"\"\"\n    return all(is_CONST(x) or\n               is_number(x) or\n               is_const(x)\n               for x in p)", "code_tokens": "def is_static ( * p ) : return all ( is_CONST ( x ) or is_number ( x ) or is_const ( x ) for x in p )", "docstring_tokens": "A static value ( does not change at runtime ) which is known at compile time", "label": 0}, {"idx": "cosqa-train-10706", "doc": "python dictionary set default for wrong key", "code": "def setdefaults(dct, defaults):\n    \"\"\"Given a target dct and a dict of {key:default value} pairs,\n    calls setdefault for all of those pairs.\"\"\"\n    for key in defaults:\n        dct.setdefault(key, defaults[key])\n\n    return dct", "code_tokens": "def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct", "docstring_tokens": "Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs .", "label": 1}, {"idx": "cosqa-train-10707", "doc": "c++ map to python dict", "code": "def get_python_dict(scala_map):\n    \"\"\"Return a dict from entries in a scala.collection.immutable.Map\"\"\"\n    python_dict = {}\n    keys = get_python_list(scala_map.keys().toList())\n    for key in keys:\n        python_dict[key] = scala_map.apply(key)\n    return python_dict", "code_tokens": "def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict", "docstring_tokens": "Return a dict from entries in a scala . collection . immutable . Map", "label": 1}, {"idx": "cosqa-train-10708", "doc": "python dictionary setdefault multiple keys", "code": "def setdefaults(dct, defaults):\n    \"\"\"Given a target dct and a dict of {key:default value} pairs,\n    calls setdefault for all of those pairs.\"\"\"\n    for key in defaults:\n        dct.setdefault(key, defaults[key])\n\n    return dct", "code_tokens": "def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct", "docstring_tokens": "Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs .", "label": 1}, {"idx": "cosqa-train-10709", "doc": "calculate an average in python using the count of an array", "code": "def variance(arr):\n  \"\"\"variance of the values, must have 2 or more entries.\n\n  :param arr: list of numbers\n  :type arr: number[] a number array\n  :return: variance\n  :rtype: float\n\n  \"\"\"\n  avg = average(arr)\n  return sum([(float(x)-avg)**2 for x in arr])/float(len(arr)-1)", "code_tokens": "def variance ( arr ) : avg = average ( arr ) return sum ( [ ( float ( x ) - avg ) ** 2 for x in arr ] ) / float ( len ( arr ) - 1 )", "docstring_tokens": "variance of the values must have 2 or more entries .", "label": 1}, {"idx": "cosqa-train-10710", "doc": "python dictionary url encode", "code": "def get_dict_to_encoded_url(data):\n    \"\"\"\n    Converts a dict to an encoded URL.\n    Example: given  data = {'a': 1, 'b': 2}, it returns 'a=1&b=2'\n    \"\"\"\n    unicode_data = dict([(k, smart_str(v)) for k, v in data.items()])\n    encoded = urllib.urlencode(unicode_data)\n    return encoded", "code_tokens": "def get_dict_to_encoded_url ( data ) : unicode_data = dict ( [ ( k , smart_str ( v ) ) for k , v in data . items ( ) ] ) encoded = urllib . urlencode ( unicode_data ) return encoded", "docstring_tokens": "Converts a dict to an encoded URL . Example : given data = { a : 1 b : 2 } it returns a = 1&b = 2", "label": 1}, {"idx": "cosqa-train-10711", "doc": "calculate an inverse matrix using python", "code": "def inh(table):\n    \"\"\"\n    inverse hyperbolic sine transformation\n    \"\"\"\n    t = []\n    for i in table:\n        t.append(np.ndarray.tolist(np.arcsinh(i)))\n    return t", "code_tokens": "def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "docstring_tokens": "inverse hyperbolic sine transformation", "label": 1}, {"idx": "cosqa-train-10712", "doc": "python dictionary values to lowercase", "code": "def keys_to_snake_case(camel_case_dict):\n    \"\"\"\n    Make a copy of a dictionary with all keys converted to snake case. This is just calls to_snake_case on\n    each of the keys in the dictionary and returns a new dictionary.\n\n    :param camel_case_dict: Dictionary with the keys to convert.\n    :type camel_case_dict: Dictionary.\n\n    :return: Dictionary with the keys converted to snake case.\n    \"\"\"\n    return dict((to_snake_case(key), value) for (key, value) in camel_case_dict.items())", "code_tokens": "def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )", "docstring_tokens": "Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .", "label": 1}, {"idx": "cosqa-train-10713", "doc": "calculate centroid vector of list of vectors python", "code": "def find_dist_to_centroid(cvects, idx_list, weights=None):\n    \"\"\" Find the centroid for a set of vectors\n\n    Parameters\n    ----------\n    cvects : ~numpy.ndarray(3,nsrc) with directional cosine (i.e., x,y,z component) values\n\n    idx_list : [int,...]\n      list of the source indices in the cluster\n\n    weights : ~numpy.ndarray(nsrc) with the weights to use.  None for equal weighting\n\n    returns (np.ndarray(nsrc)) distances to the centroid (in degrees)\n    \"\"\"\n    centroid = find_centroid(cvects, idx_list, weights)\n    dist_vals = np.degrees(np.arccos((centroid * cvects.T[idx_list]).sum(1)))\n    return dist_vals, centroid", "code_tokens": "def find_dist_to_centroid ( cvects , idx_list , weights = None ) : centroid = find_centroid ( cvects , idx_list , weights ) dist_vals = np . degrees ( np . arccos ( ( centroid * cvects . T [ idx_list ] ) . sum ( 1 ) ) ) return dist_vals , centroid", "docstring_tokens": "Find the centroid for a set of vectors", "label": 1}, {"idx": "cosqa-train-10714", "doc": "python disable output buffer", "code": "def disable_stdout_buffering():\n    \"\"\"This turns off stdout buffering so that outputs are immediately\n    materialized and log messages show up before the program exits\"\"\"\n    stdout_orig = sys.stdout\n    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)\n    # NOTE(brandyn): This removes the original stdout\n    return stdout_orig", "code_tokens": "def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig", "docstring_tokens": "This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits", "label": 1}, {"idx": "cosqa-train-10715", "doc": "calculate euclidean distance between two vectors python", "code": "def vector_distance(a, b):\n    \"\"\"The Euclidean distance between two vectors.\"\"\"\n    a = np.array(a)\n    b = np.array(b)\n    return np.linalg.norm(a - b)", "code_tokens": "def vector_distance ( a , b ) : a = np . array ( a ) b = np . array ( b ) return np . linalg . norm ( a - b )", "docstring_tokens": "The Euclidean distance between two vectors .", "label": 1}, {"idx": "cosqa-train-10716", "doc": "python discord already connected to a voice channel", "code": "async def connect(self):\n        \"\"\"\n        Connects to the voice channel associated with this Player.\n        \"\"\"\n        await self.node.join_voice_channel(self.channel.guild.id, self.channel.id)", "code_tokens": "async def connect ( self ) : await self . node . join_voice_channel ( self . channel . guild . id , self . channel . id )", "docstring_tokens": "Connects to the voice channel associated with this Player .", "label": 1}, {"idx": "cosqa-train-10717", "doc": "calculate median of list of times python", "code": "def median_date(dt_list):\n    \"\"\"Calcuate median datetime from datetime list\n    \"\"\"\n    #dt_list_sort = sorted(dt_list)\n    idx = len(dt_list)/2\n    if len(dt_list) % 2 == 0:\n        md = mean_date([dt_list[idx-1], dt_list[idx]])\n    else:\n        md = dt_list[idx]\n    return md", "code_tokens": "def median_date ( dt_list ) : #dt_list_sort = sorted(dt_list) idx = len ( dt_list ) / 2 if len ( dt_list ) % 2 == 0 : md = mean_date ( [ dt_list [ idx - 1 ] , dt_list [ idx ] ] ) else : md = dt_list [ idx ] return md", "docstring_tokens": "Calcuate median datetime from datetime list", "label": 1}, {"idx": "cosqa-train-10718", "doc": "python display specific columns", "code": "def _get_printable_columns(columns, row):\n    \"\"\"Return only the part of the row which should be printed.\n    \"\"\"\n    if not columns:\n        return row\n\n    # Extract the column values, in the order specified.\n    return tuple(row[c] for c in columns)", "code_tokens": "def _get_printable_columns ( columns , row ) : if not columns : return row # Extract the column values, in the order specified. return tuple ( row [ c ] for c in columns )", "docstring_tokens": "Return only the part of the row which should be printed .", "label": 1}, {"idx": "cosqa-train-10719", "doc": "calculate p value python logistic regression", "code": "def glog(x,l = 2):\n    \"\"\"\n    Generalised logarithm\n\n    :param x: number\n    :param p: number added befor logarithm \n\n    \"\"\"\n    return np.log((x+np.sqrt(x**2+l**2))/2)/np.log(l)", "code_tokens": "def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )", "docstring_tokens": "Generalised logarithm", "label": 1}, {"idx": "cosqa-train-10720", "doc": "python dispose of object in loop", "code": "def release(self):\n        \"\"\"\n        Releases this resource back to the pool it came from.\n        \"\"\"\n        if self.errored:\n            self.pool.delete_resource(self)\n        else:\n            self.pool.release(self)", "code_tokens": "def release ( self ) : if self . errored : self . pool . delete_resource ( self ) else : self . pool . release ( self )", "docstring_tokens": "Releases this resource back to the pool it came from .", "label": 1}, {"idx": "cosqa-train-10721", "doc": "calculating the average of a list in python", "code": "def mean(inlist):\n    \"\"\"\nReturns the arithematic mean of the values in the passed list.\nAssumes a '1D' list, but will function on the 1st dim of an array(!).\n\nUsage:   lmean(inlist)\n\"\"\"\n    sum = 0\n    for item in inlist:\n        sum = sum + item\n    return sum / float(len(inlist))", "code_tokens": "def mean ( inlist ) : sum = 0 for item in inlist : sum = sum + item return sum / float ( len ( inlist ) )", "docstring_tokens": "Returns the arithematic mean of the values in the passed list . Assumes a 1D list but will function on the 1st dim of an array ( ! ) .", "label": 1}, {"idx": "cosqa-train-10722", "doc": "python distance of two points", "code": "def dist_sq(self, other):\n    \"\"\"Distance squared to some other point.\"\"\"\n    dx = self.x - other.x\n    dy = self.y - other.y\n    return dx**2 + dy**2", "code_tokens": "def dist_sq ( self , other ) : dx = self . x - other . x dy = self . y - other . y return dx ** 2 + dy ** 2", "docstring_tokens": "Distance squared to some other point .", "label": 0}, {"idx": "cosqa-train-10723", "doc": "call a function with wrapper python", "code": "def map_wrap(f):\n    \"\"\"Wrap standard function to easily pass into 'map' processing.\n    \"\"\"\n    @functools.wraps(f)\n    def wrapper(*args, **kwargs):\n        return f(*args, **kwargs)\n    return wrapper", "code_tokens": "def map_wrap ( f ) : @ functools . wraps ( f ) def wrapper ( * args , * * kwargs ) : return f ( * args , * * kwargs ) return wrapper", "docstring_tokens": "Wrap standard function to easily pass into map processing .", "label": 1}, {"idx": "cosqa-train-10724", "doc": "python divide string into list of lines", "code": "def split_multiline(value):\n    \"\"\"Split a multiline string into a list, excluding blank lines.\"\"\"\n    return [element for element in (line.strip() for line in value.split('\\n'))\n            if element]", "code_tokens": "def split_multiline ( value ) : return [ element for element in ( line . strip ( ) for line in value . split ( '\\n' ) ) if element ]", "docstring_tokens": "Split a multiline string into a list excluding blank lines .", "label": 1}, {"idx": "cosqa-train-10725", "doc": "calling index iterable python", "code": "def stop_at(iterable, idx):\n    \"\"\"Stops iterating before yielding the specified idx.\"\"\"\n    for i, item in enumerate(iterable):\n        if i == idx: return\n        yield item", "code_tokens": "def stop_at ( iterable , idx ) : for i , item in enumerate ( iterable ) : if i == idx : return yield item", "docstring_tokens": "Stops iterating before yielding the specified idx .", "label": 1}, {"idx": "cosqa-train-10726", "doc": "python django change active directory", "code": "def launch_server():\n    \"\"\"Launches the django server at 127.0.0.1:8000\n    \"\"\"\n    print(os.path.dirname(os.path.abspath(__file__)))\n    cur_dir = os.getcwd()\n    path = os.path.dirname(os.path.abspath(__file__))\n    run = True\n    os.chdir(path)\n    os.system('python manage.py runserver --nostatic')\n    os.chdir(cur_dir)", "code_tokens": "def launch_server ( ) : print ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) cur_dir = os . getcwd ( ) path = os . path . dirname ( os . path . abspath ( __file__ ) ) run = True os . chdir ( path ) os . system ( 'python manage.py runserver --nostatic' ) os . chdir ( cur_dir )", "docstring_tokens": "Launches the django server at 127 . 0 . 0 . 1 : 8000", "label": 1}, {"idx": "cosqa-train-10727", "doc": "can a range object hold strings python", "code": "def add_range(self, sequence, begin, end):\n    \"\"\"Add a read_range primitive\"\"\"\n    sequence.parser_tree = parsing.Range(self.value(begin).strip(\"'\"),\n                                         self.value(end).strip(\"'\"))\n    return True", "code_tokens": "def add_range ( self , sequence , begin , end ) : sequence . parser_tree = parsing . Range ( self . value ( begin ) . strip ( \"'\" ) , self . value ( end ) . strip ( \"'\" ) ) return True", "docstring_tokens": "Add a read_range primitive", "label": 1}, {"idx": "cosqa-train-10728", "doc": "python django function redirect", "code": "def url(viewname, *args, **kwargs):\n    \"\"\"Helper for Django's ``reverse`` in templates.\"\"\"\n    return reverse(viewname, args=args, kwargs=kwargs)", "code_tokens": "def url ( viewname , * args , * * kwargs ) : return reverse ( viewname , args = args , kwargs = kwargs )", "docstring_tokens": "Helper for Django s reverse in templates .", "label": 1}, {"idx": "cosqa-train-10729", "doc": "can i pass instance method as variable python", "code": "def do(self):\n        \"\"\"\n        Set a restore point (copy the object), then call the method.\n        :return: obj.do_method(*args)\n        \"\"\"\n        self.restore_point = self.obj.copy()\n        return self.do_method(self.obj, *self.args)", "code_tokens": "def do ( self ) : self . restore_point = self . obj . copy ( ) return self . do_method ( self . obj , * self . args )", "docstring_tokens": "Set a restore point ( copy the object ) then call the method . : return : obj . do_method ( * args )", "label": 1}, {"idx": "cosqa-train-10730", "doc": "python django how to print out image models", "code": "def _image_field(self):\n        \"\"\"\n        Try to automatically detect an image field\n        \"\"\"\n        for field in self.model._meta.fields:\n            if isinstance(field, ImageField):\n                return field.name", "code_tokens": "def _image_field ( self ) : for field in self . model . _meta . fields : if isinstance ( field , ImageField ) : return field . name", "docstring_tokens": "Try to automatically detect an image field", "label": 1}, {"idx": "cosqa-train-10731", "doc": "can you change a python iterable mid loop", "code": "def __init__(self, function):\n\t\t\"\"\"function: to be called with each stream element as its\n\t\tonly argument\n\t\t\"\"\"\n\t\tsuper(takewhile, self).__init__()\n\t\tself.function = function", "code_tokens": "def __init__ ( self , function ) : super ( takewhile , self ) . __init__ ( ) self . function = function", "docstring_tokens": "function : to be called with each stream element as its only argument", "label": 1}, {"idx": "cosqa-train-10732", "doc": "python django request get locale", "code": "def set_locale(request):\n    \"\"\"Return locale from GET lang param or automatically.\"\"\"\n    return request.query.get('lang', app.ps.babel.select_locale_by_request(request))", "code_tokens": "def set_locale ( request ) : return request . query . get ( 'lang' , app . ps . babel . select_locale_by_request ( request ) )", "docstring_tokens": "Return locale from GET lang param or automatically .", "label": 1}, {"idx": "cosqa-train-10733", "doc": "can you change the data type of an entire list in python", "code": "def shape_list(l,shape,dtype):\n    \"\"\" Shape a list of lists into the appropriate shape and data type \"\"\"\n    return np.array(l, dtype=dtype).reshape(shape)", "code_tokens": "def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )", "docstring_tokens": "Shape a list of lists into the appropriate shape and data type", "label": 1}, {"idx": "cosqa-train-10734", "doc": "python django static files", "code": "def static_urls_js():\n    \"\"\"\n    Add global variables to JavaScript about the location and latest version of\n    transpiled files.\n    Usage::\n        {% static_urls_js %}\n    \"\"\"\n    if apps.is_installed('django.contrib.staticfiles'):\n        from django.contrib.staticfiles.storage import staticfiles_storage\n        static_base_url = staticfiles_storage.base_url\n    else:\n        static_base_url = PrefixNode.handle_simple(\"STATIC_URL\")\n    transpile_base_url = urljoin(static_base_url, 'js/transpile/')\n    return {\n        'static_base_url': static_base_url,\n        'transpile_base_url': transpile_base_url,\n        'version': LAST_RUN['version']\n    }", "code_tokens": "def static_urls_js ( ) : if apps . is_installed ( 'django.contrib.staticfiles' ) : from django . contrib . staticfiles . storage import staticfiles_storage static_base_url = staticfiles_storage . base_url else : static_base_url = PrefixNode . handle_simple ( \"STATIC_URL\" ) transpile_base_url = urljoin ( static_base_url , 'js/transpile/' ) return { 'static_base_url' : static_base_url , 'transpile_base_url' : transpile_base_url , 'version' : LAST_RUN [ 'version' ] }", "docstring_tokens": "Add global variables to JavaScript about the location and latest version of transpiled files . Usage :: { % static_urls_js % }", "label": 1}, {"idx": "cosqa-train-10735", "doc": "can you combine pdf files using python", "code": "def append_pdf(input_pdf: bytes, output_writer: PdfFileWriter):\n    \"\"\"\n    Appends a PDF to a pyPDF writer. Legacy interface.\n    \"\"\"\n    append_memory_pdf_to_writer(input_pdf=input_pdf,\n                                writer=output_writer)", "code_tokens": "def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )", "docstring_tokens": "Appends a PDF to a pyPDF writer . Legacy interface .", "label": 1}, {"idx": "cosqa-train-10736", "doc": "python django validator regex", "code": "def is_rfc2822(instance: str):\n    \"\"\"Validates RFC2822 format\"\"\"\n    if not isinstance(instance, str):\n        return True\n    return email.utils.parsedate(instance) is not None", "code_tokens": "def is_rfc2822 ( instance : str ) : if not isinstance ( instance , str ) : return True return email . utils . parsedate ( instance ) is not None", "docstring_tokens": "Validates RFC2822 format", "label": 1}, {"idx": "cosqa-train-10737", "doc": "can you replace multiple things in a string in python", "code": "def replace(s, replace):\n    \"\"\"Replace multiple values in a string\"\"\"\n    for r in replace:\n        s = s.replace(*r)\n    return s", "code_tokens": "def replace ( s , replace ) : for r in replace : s = s . replace ( * r ) return s", "docstring_tokens": "Replace multiple values in a string", "label": 1}, {"idx": "cosqa-train-10738", "doc": "python docstring restructuredtext sphinx", "code": "def process_docstring(app, what, name, obj, options, lines):\n    \"\"\"React to a docstring event and append contracts to it.\"\"\"\n    # pylint: disable=unused-argument\n    # pylint: disable=too-many-arguments\n    lines.extend(_format_contracts(what=what, obj=obj))", "code_tokens": "def process_docstring ( app , what , name , obj , options , lines ) : # pylint: disable=unused-argument # pylint: disable=too-many-arguments lines . extend ( _format_contracts ( what = what , obj = obj ) )", "docstring_tokens": "React to a docstring event and append contracts to it .", "label": 1}, {"idx": "cosqa-train-10739", "doc": "can you turn a string into a dictionary python", "code": "def list_string_to_dict(string):\n    \"\"\"Inputs ``['a', 'b', 'c']``, returns ``{'a': 0, 'b': 1, 'c': 2}``.\"\"\"\n    dictionary = {}\n    for idx, c in enumerate(string):\n        dictionary.update({c: idx})\n    return dictionary", "code_tokens": "def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary", "docstring_tokens": "Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } .", "label": 1}, {"idx": "cosqa-train-10740", "doc": "python doctest string multiline", "code": "def debug_src(src, pm=False, globs=None):\n    \"\"\"Debug a single doctest docstring, in argument `src`'\"\"\"\n    testsrc = script_from_examples(src)\n    debug_script(testsrc, pm, globs)", "code_tokens": "def debug_src ( src , pm = False , globs = None ) : testsrc = script_from_examples ( src ) debug_script ( testsrc , pm , globs )", "docstring_tokens": "Debug a single doctest docstring in argument src", "label": 1}, {"idx": "cosqa-train-10741", "doc": "python downsampling 2d array", "code": "def downsample_with_striding(array, factor):\n    \"\"\"Downsample x by factor using striding.\n\n    @return: The downsampled array, of the same type as x.\n    \"\"\"\n    return array[tuple(np.s_[::f] for f in factor)]", "code_tokens": "def downsample_with_striding ( array , factor ) : return array [ tuple ( np . s_ [ : : f ] for f in factor ) ]", "docstring_tokens": "Downsample x by factor using striding .", "label": 1}, {"idx": "cosqa-train-10742", "doc": "catch code in cache mem python", "code": "def cache(self):\n        \"\"\"Memoize access to the cache backend.\"\"\"\n        if self._cache is None:\n            self._cache = django_cache.get_cache(self.cache_name)\n        return self._cache", "code_tokens": "def cache ( self ) : if self . _cache is None : self . _cache = django_cache . get_cache ( self . cache_name ) return self . _cache", "docstring_tokens": "Memoize access to the cache backend .", "label": 0}, {"idx": "cosqa-train-10743", "doc": "python draw line segment", "code": "def _add_line_segment(self, x, y):\n        \"\"\"Add a |_LineSegment| operation to the drawing sequence.\"\"\"\n        self._drawing_operations.append(_LineSegment.new(self, x, y))", "code_tokens": "def _add_line_segment ( self , x , y ) : self . _drawing_operations . append ( _LineSegment . new ( self , x , y ) )", "docstring_tokens": "Add a |_LineSegment| operation to the drawing sequence .", "label": 1}, {"idx": "cosqa-train-10744", "doc": "centos 7 yum remove python", "code": "def update(kernel=False):\n    \"\"\"\n    Upgrade all packages, skip obsoletes if ``obsoletes=0`` in ``yum.conf``.\n\n    Exclude *kernel* upgrades by default.\n    \"\"\"\n    manager = MANAGER\n    cmds = {'yum -y --color=never': {False: '--exclude=kernel* update', True: 'update'}}\n    cmd = cmds[manager][kernel]\n    run_as_root(\"%(manager)s %(cmd)s\" % locals())", "code_tokens": "def update ( kernel = False ) : manager = MANAGER cmds = { 'yum -y --color=never' : { False : '--exclude=kernel* update' , True : 'update' } } cmd = cmds [ manager ] [ kernel ] run_as_root ( \"%(manager)s %(cmd)s\" % locals ( ) )", "docstring_tokens": "Upgrade all packages skip obsoletes if obsoletes = 0 in yum . conf .", "label": 1}, {"idx": "cosqa-train-10745", "doc": "python draw string into qrcode", "code": "def qr(self,text):\n        \"\"\" Print QR Code for the provided string \"\"\"\n        qr_code = qrcode.QRCode(version=4, box_size=4, border=1)\n        qr_code.add_data(text)\n        qr_code.make(fit=True)\n        qr_img = qr_code.make_image()\n        im = qr_img._img.convert(\"RGB\")\n        # Convert the RGB image in printable image\n        self._convert_image(im)", "code_tokens": "def qr ( self , text ) : qr_code = qrcode . QRCode ( version = 4 , box_size = 4 , border = 1 ) qr_code . add_data ( text ) qr_code . make ( fit = True ) qr_img = qr_code . make_image ( ) im = qr_img . _img . convert ( \"RGB\" ) # Convert the RGB image in printable image self . _convert_image ( im )", "docstring_tokens": "Print QR Code for the provided string", "label": 0}, {"idx": "cosqa-train-10746", "doc": "change a string into a list in python", "code": "def to_list(var):\n    \"\"\"Checks if given value is a list, tries to convert, if it is not.\"\"\"\n    if var is None:\n        return []\n    if isinstance(var, str):\n        var = var.split('\\n')\n    elif not isinstance(var, list):\n        try:\n            var = list(var)\n        except TypeError:\n            raise ValueError(\"{} cannot be converted to the list.\".format(var))\n    return var", "code_tokens": "def to_list ( var ) : if var is None : return [ ] if isinstance ( var , str ) : var = var . split ( '\\n' ) elif not isinstance ( var , list ) : try : var = list ( var ) except TypeError : raise ValueError ( \"{} cannot be converted to the list.\" . format ( var ) ) return var", "docstring_tokens": "Checks if given value is a list tries to convert if it is not .", "label": 1}, {"idx": "cosqa-train-10747", "doc": "python drop none from dictionary", "code": "def nonull_dict(self):\n        \"\"\"Like dict, but does not hold any null values.\n\n        :return:\n\n        \"\"\"\n        return {k: v for k, v in six.iteritems(self.dict) if v and k != '_codes'}", "code_tokens": "def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }", "docstring_tokens": "Like dict but does not hold any null values .", "label": 1}, {"idx": "cosqa-train-10748", "doc": "change all strings in a list to list python", "code": "def string_to_list(string, sep=\",\", filter_empty=False):\n    \"\"\"Transforma una string con elementos separados por `sep` en una lista.\"\"\"\n    return [value.strip() for value in string.split(sep)\n            if (not filter_empty or value)]", "code_tokens": "def string_to_list ( string , sep = \",\" , filter_empty = False ) : return [ value . strip ( ) for value in string . split ( sep ) if ( not filter_empty or value ) ]", "docstring_tokens": "Transforma una string con elementos separados por sep en una lista .", "label": 1}, {"idx": "cosqa-train-10749", "doc": "python elasticsearch batch delete", "code": "def delete_index(index):\n    \"\"\"Delete index entirely (removes all documents and mapping).\"\"\"\n    logger.info(\"Deleting search index: '%s'\", index)\n    client = get_client()\n    return client.indices.delete(index=index)", "code_tokens": "def delete_index ( index ) : logger . info ( \"Deleting search index: '%s'\" , index ) client = get_client ( ) return client . indices . delete ( index = index )", "docstring_tokens": "Delete index entirely ( removes all documents and mapping ) .", "label": 1}, {"idx": "cosqa-train-10750", "doc": "change cartesian coordinates to range and azimuth python", "code": "def angle_to_cartesian(lon, lat):\n    \"\"\"Convert spherical coordinates to cartesian unit vectors.\"\"\"\n    theta = np.array(np.pi / 2. - lat)\n    return np.vstack((np.sin(theta) * np.cos(lon),\n                      np.sin(theta) * np.sin(lon),\n                      np.cos(theta))).T", "code_tokens": "def angle_to_cartesian ( lon , lat ) : theta = np . array ( np . pi / 2. - lat ) return np . vstack ( ( np . sin ( theta ) * np . cos ( lon ) , np . sin ( theta ) * np . sin ( lon ) , np . cos ( theta ) ) ) . T", "docstring_tokens": "Convert spherical coordinates to cartesian unit vectors .", "label": 1}, {"idx": "cosqa-train-10751", "doc": "python elasticsearch hits is empty", "code": "def can_elasticsearch(record):\n    \"\"\"Check if a given record is indexed.\n\n    :param record: A record object.\n    :returns: If the record is indexed returns `True`, otherwise `False`.\n    \"\"\"\n    search = request._methodview.search_class()\n    search = search.get_record(str(record.id))\n    return search.count() == 1", "code_tokens": "def can_elasticsearch ( record ) : search = request . _methodview . search_class ( ) search = search . get_record ( str ( record . id ) ) return search . count ( ) == 1", "docstring_tokens": "Check if a given record is indexed .", "label": 1}, {"idx": "cosqa-train-10752", "doc": "change column string to float python", "code": "def comma_converter(float_string):\n    \"\"\"Convert numbers to floats whether the decimal point is '.' or ','\"\"\"\n    trans_table = maketrans(b',', b'.')\n    return float(float_string.translate(trans_table))", "code_tokens": "def comma_converter ( float_string ) : trans_table = maketrans ( b',' , b'.' ) return float ( float_string . translate ( trans_table ) )", "docstring_tokens": "Convert numbers to floats whether the decimal point is . or", "label": 1}, {"idx": "cosqa-train-10753", "doc": "python elasticsearch not all values sent", "code": "def raw(self):\n        \"\"\"\n        Build query and passes to `Elasticsearch`, then returns the raw\n        format returned.\n        \"\"\"\n        es = self.get_es()\n\n        params = dict(self.query_params)\n        mlt_fields = self.mlt_fields or params.pop('mlt_fields', [])\n\n        body = self.s.build_search() if self.s else ''\n\n        hits = es.mlt(\n            index=self.index, doc_type=self.doctype, id=self.id,\n            mlt_fields=mlt_fields, body=body, **params)\n\n        log.debug(hits)\n\n        return hits", "code_tokens": "def raw ( self ) : es = self . get_es ( ) params = dict ( self . query_params ) mlt_fields = self . mlt_fields or params . pop ( 'mlt_fields' , [ ] ) body = self . s . build_search ( ) if self . s else '' hits = es . mlt ( index = self . index , doc_type = self . doctype , id = self . id , mlt_fields = mlt_fields , body = body , * * params ) log . debug ( hits ) return hits", "docstring_tokens": "Build query and passes to Elasticsearch then returns the raw format returned .", "label": 1}, {"idx": "cosqa-train-10754", "doc": "change numpy array to table in python", "code": "def from_array(cls, arr):\n        \"\"\"Convert a structured NumPy array into a Table.\"\"\"\n        return cls().with_columns([(f, arr[f]) for f in arr.dtype.names])", "code_tokens": "def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )", "docstring_tokens": "Convert a structured NumPy array into a Table .", "label": 1}, {"idx": "cosqa-train-10755", "doc": "python eliminate spaces in a string", "code": "def unpunctuate(s, *, char_blacklist=string.punctuation):\n    \"\"\" Remove punctuation from string s. \"\"\"\n    # remove punctuation\n    s = \"\".join(c for c in s if c not in char_blacklist)\n    # remove consecutive spaces\n    return \" \".join(filter(None, s.split(\" \")))", "code_tokens": "def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = \"\" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return \" \" . join ( filter ( None , s . split ( \" \" ) ) )", "docstring_tokens": "Remove punctuation from string s .", "label": 1}, {"idx": "cosqa-train-10756", "doc": "change object value and heap python", "code": "def push(h, x):\n    \"\"\"Push a new value into heap.\"\"\"\n    h.push(x)\n    up(h, h.size()-1)", "code_tokens": "def push ( h , x ) : h . push ( x ) up ( h , h . size ( ) - 1 )", "docstring_tokens": "Push a new value into heap .", "label": 1}, {"idx": "cosqa-train-10757", "doc": "python email address exists validate", "code": "def validate_email(email):\n    \"\"\"\n    Validates an email address\n    Source: Himanshu Shankar (https://github.com/iamhssingh)\n    Parameters\n    ----------\n    email: str\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    from django.core.validators import validate_email\n    from django.core.exceptions import ValidationError\n    try:\n        validate_email(email)\n        return True\n    except ValidationError:\n        return False", "code_tokens": "def validate_email ( email ) : from django . core . validators import validate_email from django . core . exceptions import ValidationError try : validate_email ( email ) return True except ValidationError : return False", "docstring_tokens": "Validates an email address Source : Himanshu Shankar ( https : // github . com / iamhssingh ) Parameters ---------- email : str", "label": 1}, {"idx": "cosqa-train-10758", "doc": "change python dictionary to multidimensional array", "code": "def C_dict2array(C):\n    \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"\n    return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "code_tokens": "def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )", "docstring_tokens": "Convert an OrderedDict containing C values to a 1D array .", "label": 1}, {"idx": "cosqa-train-10759", "doc": "python email only sending to self", "code": "def email_user(self, subject, message, from_email=None):\n        \"\"\" Send an email to this User.\"\"\"\n        send_mail(subject, message, from_email, [self.email])", "code_tokens": "def email_user ( self , subject , message , from_email = None ) : send_mail ( subject , message , from_email , [ self . email ] )", "docstring_tokens": "Send an email to this User .", "label": 1}, {"idx": "cosqa-train-10760", "doc": "change scale python plot", "code": "def update_scale(self, value):\n        \"\"\" updates the scale of all actors in the plotter \"\"\"\n        self.plotter.set_scale(self.x_slider_group.value,\n                               self.y_slider_group.value,\n                               self.z_slider_group.value)", "code_tokens": "def update_scale ( self , value ) : self . plotter . set_scale ( self . x_slider_group . value , self . y_slider_group . value , self . z_slider_group . value )", "docstring_tokens": "updates the scale of all actors in the plotter", "label": 0}, {"idx": "cosqa-train-10761", "doc": "python empty line signifies last line stdin", "code": "def pass_from_pipe(cls):\n        \"\"\"Return password from pipe if not on TTY, else False.\n        \"\"\"\n        is_pipe = not sys.stdin.isatty()\n        return is_pipe and cls.strip_last_newline(sys.stdin.read())", "code_tokens": "def pass_from_pipe ( cls ) : is_pipe = not sys . stdin . isatty ( ) return is_pipe and cls . strip_last_newline ( sys . stdin . read ( ) )", "docstring_tokens": "Return password from pipe if not on TTY else False .", "label": 0}, {"idx": "cosqa-train-10762", "doc": "change the type of one element in a tuple python", "code": "def as_tuple(self, value):\n        \"\"\"Utility function which converts lists to tuples.\"\"\"\n        if isinstance(value, list):\n            value = tuple(value)\n        return value", "code_tokens": "def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value", "docstring_tokens": "Utility function which converts lists to tuples .", "label": 1}, {"idx": "cosqa-train-10763", "doc": "python equivelent to sql in", "code": "def selectin(table, field, value, complement=False):\n    \"\"\"Select rows where the given field is a member of the given value.\"\"\"\n\n    return select(table, field, lambda v: v in value,\n                  complement=complement)", "code_tokens": "def selectin ( table , field , value , complement = False ) : return select ( table , field , lambda v : v in value , complement = complement )", "docstring_tokens": "Select rows where the given field is a member of the given value .", "label": 0}, {"idx": "cosqa-train-10764", "doc": "change year in datetime python", "code": "def move_datetime_year(dt, direction, num_shifts):\n    \"\"\"\n    Move datetime 1 year in the chosen direction.\n    unit is a no-op, to keep the API the same as the day case\n    \"\"\"\n    delta = relativedelta(years=+num_shifts)\n    return _move_datetime(dt, direction, delta)", "code_tokens": "def move_datetime_year ( dt , direction , num_shifts ) : delta = relativedelta ( years = + num_shifts ) return _move_datetime ( dt , direction , delta )", "docstring_tokens": "Move datetime 1 year in the chosen direction . unit is a no - op to keep the API the same as the day case", "label": 1}, {"idx": "cosqa-train-10765", "doc": "python escape out % in string", "code": "def quote(s, unsafe='/'):\n    \"\"\"Pass in a dictionary that has unsafe characters as the keys, and the percent\n    encoded value as the value.\"\"\"\n    res = s.replace('%', '%25')\n    for c in unsafe:\n        res = res.replace(c, '%' + (hex(ord(c)).upper())[2:])\n    return res", "code_tokens": "def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res", "docstring_tokens": "Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value .", "label": 1}, {"idx": "cosqa-train-10766", "doc": "changing numpy array to float python", "code": "def as_float_array(a):\n    \"\"\"View the quaternion array as an array of floats\n\n    This function is fast (of order 1 microsecond) because no data is\n    copied; the returned quantity is just a \"view\" of the original.\n\n    The output view has one more dimension (of size 4) than the input\n    array, but is otherwise the same shape.\n\n    \"\"\"\n    return np.asarray(a, dtype=np.quaternion).view((np.double, 4))", "code_tokens": "def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )", "docstring_tokens": "View the quaternion array as an array of floats", "label": 1}, {"idx": "cosqa-train-10767", "doc": "python escape string to path in bash", "code": "def escapePathForShell(path):\n\t\t\"\"\"\n\t\tEscapes a filesystem path for use as a command-line argument\n\t\t\"\"\"\n\t\tif platform.system() == 'Windows':\n\t\t\treturn '\"{}\"'.format(path.replace('\"', '\"\"'))\n\t\telse:\n\t\t\treturn shellescape.quote(path)", "code_tokens": "def escapePathForShell ( path ) : if platform . system ( ) == 'Windows' : return '\"{}\"' . format ( path . replace ( '\"' , '\"\"' ) ) else : return shellescape . quote ( path )", "docstring_tokens": "Escapes a filesystem path for use as a command - line argument", "label": 1}, {"idx": "cosqa-train-10768", "doc": "check file is empty python", "code": "def file_empty(fp):\n    \"\"\"Determine if a file is empty or not.\"\"\"\n    # for python 2 we need to use a homemade peek()\n    if six.PY2:\n        contents = fp.read()\n        fp.seek(0)\n        return not bool(contents)\n\n    else:\n        return not fp.peek()", "code_tokens": "def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )", "docstring_tokens": "Determine if a file is empty or not .", "label": 1}, {"idx": "cosqa-train-10769", "doc": "python every time take n items from list using yield", "code": "def split_every(n, iterable):\n    \"\"\"Returns a generator that spits an iteratable into n-sized chunks. The last chunk may have\n    less than n elements.\n\n    See http://stackoverflow.com/a/22919323/503377.\"\"\"\n    items = iter(iterable)\n    return itertools.takewhile(bool, (list(itertools.islice(items, n)) for _ in itertools.count()))", "code_tokens": "def split_every ( n , iterable ) : items = iter ( iterable ) return itertools . takewhile ( bool , ( list ( itertools . islice ( items , n ) ) for _ in itertools . count ( ) ) )", "docstring_tokens": "Returns a generator that spits an iteratable into n - sized chunks . The last chunk may have less than n elements .", "label": 1}, {"idx": "cosqa-train-10770", "doc": "check for punctuation in string python", "code": "def is_punctuation(text):\n    \"\"\"Check if given string is a punctuation\"\"\"\n    return not (text.lower() in config.AVRO_VOWELS or\n                text.lower() in config.AVRO_CONSONANTS)", "code_tokens": "def is_punctuation ( text ) : return not ( text . lower ( ) in config . AVRO_VOWELS or text . lower ( ) in config . AVRO_CONSONANTS )", "docstring_tokens": "Check if given string is a punctuation", "label": 1}, {"idx": "cosqa-train-10771", "doc": "python execution root directory", "code": "def getpackagepath():\n    \"\"\"\n     *Get the root path for this python package - used in unit testing code*\n    \"\"\"\n    moduleDirectory = os.path.dirname(__file__)\n    packagePath = os.path.dirname(__file__) + \"/../\"\n\n    return packagePath", "code_tokens": "def getpackagepath ( ) : moduleDirectory = os . path . dirname ( __file__ ) packagePath = os . path . dirname ( __file__ ) + \"/../\" return packagePath", "docstring_tokens": "* Get the root path for this python package - used in unit testing code *", "label": 1}, {"idx": "cosqa-train-10772", "doc": "check if a file is json python", "code": "def is_json_file(filename, show_warnings = False):\n    \"\"\"Check configuration file type is JSON\n    Return a boolean indicating wheather the file is JSON format or not\n    \"\"\"\n    try:\n        config_dict = load_config(filename, file_type = \"json\")\n        is_json = True\n    except:\n        is_json = False\n    return(is_json)", "code_tokens": "def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = \"json\" ) is_json = True except : is_json = False return ( is_json )", "docstring_tokens": "Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not", "label": 1}, {"idx": "cosqa-train-10773", "doc": "python expand a path", "code": "def expandpath(path):\n    \"\"\"\n    Expand a filesystem path that may or may not contain user/env vars.\n\n    :param str path: path to expand\n    :return str: expanded version of input path\n    \"\"\"\n    return os.path.expandvars(os.path.expanduser(path)).replace(\"//\", \"/\")", "code_tokens": "def expandpath ( path ) : return os . path . expandvars ( os . path . expanduser ( path ) ) . replace ( \"//\" , \"/\" )", "docstring_tokens": "Expand a filesystem path that may or may not contain user / env vars .", "label": 1}, {"idx": "cosqa-train-10774", "doc": "check if a queue is empty in python", "code": "def full(self):\n        \"\"\"Return True if the queue is full\"\"\"\n        if not self.size: return False\n        return len(self.pq) == (self.size + self.removed_count)", "code_tokens": "def full ( self ) : if not self . size : return False return len ( self . pq ) == ( self . size + self . removed_count )", "docstring_tokens": "Return True if the queue is full", "label": 1}, {"idx": "cosqa-train-10775", "doc": "check if a sting is empty python", "code": "def is_non_empty_string(input_string):\n    \"\"\"\n    Validate if non empty string\n\n    :param input_string: Input is a *str*.\n    :return: True if input is string and non empty.\n       Raise :exc:`Exception` otherwise.\n    \"\"\"\n    try:\n        if not input_string.strip():\n            raise ValueError()\n    except AttributeError as error:\n        raise TypeError(error)\n\n    return True", "code_tokens": "def is_non_empty_string ( input_string ) : try : if not input_string . strip ( ) : raise ValueError ( ) except AttributeError as error : raise TypeError ( error ) return True", "docstring_tokens": "Validate if non empty string", "label": 1}, {"idx": "cosqa-train-10776", "doc": "python expand variable in string", "code": "def _expand(self, str, local_vars={}):\n        \"\"\"Expand $vars in a string.\"\"\"\n        return ninja_syntax.expand(str, self.vars, local_vars)", "code_tokens": "def _expand ( self , str , local_vars = { } ) : return ninja_syntax . expand ( str , self . vars , local_vars )", "docstring_tokens": "Expand $vars in a string .", "label": 1}, {"idx": "cosqa-train-10777", "doc": "check if attribute exists python", "code": "def has_attribute(module_name, attribute_name):\n    \"\"\"Is this attribute present?\"\"\"\n    init_file = '%s/__init__.py' % module_name\n    return any(\n        [attribute_name in init_line for init_line in open(init_file).readlines()]\n    )", "code_tokens": "def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )", "docstring_tokens": "Is this attribute present?", "label": 1}, {"idx": "cosqa-train-10778", "doc": "python extension add method to object", "code": "def register_extension_class(ext, base, *args, **kwargs):\n    \"\"\"Instantiate the given extension class and register as a public attribute of the given base.\n\n    README: The expected protocol here is to instantiate the given extension and pass the base\n    object as the first positional argument, then unpack args and kwargs as additional arguments to\n    the extension's constructor.\n    \"\"\"\n    ext_instance = ext.plugin(base, *args, **kwargs)\n    setattr(base, ext.name.lstrip('_'), ext_instance)", "code_tokens": "def register_extension_class ( ext , base , * args , * * kwargs ) : ext_instance = ext . plugin ( base , * args , * * kwargs ) setattr ( base , ext . name . lstrip ( '_' ) , ext_instance )", "docstring_tokens": "Instantiate the given extension class and register as a public attribute of the given base .", "label": 1}, {"idx": "cosqa-train-10779", "doc": "check if file is readonly python", "code": "def is_readable(filename):\n    \"\"\"Check if file is a regular file and is readable.\"\"\"\n    return os.path.isfile(filename) and os.access(filename, os.R_OK)", "code_tokens": "def is_readable ( filename ) : return os . path . isfile ( filename ) and os . access ( filename , os . R_OK )", "docstring_tokens": "Check if file is a regular file and is readable .", "label": 1}, {"idx": "cosqa-train-10780", "doc": "python extract complex nested ordereddict keys", "code": "def flattened_nested_key_indices(nested_dict):\n    \"\"\"\n    Combine the outer and inner keys of nested dictionaries into a single\n    ordering.\n    \"\"\"\n    outer_keys, inner_keys = collect_nested_keys(nested_dict)\n    combined_keys = list(sorted(set(outer_keys + inner_keys)))\n    return {k: i for (i, k) in enumerate(combined_keys)}", "code_tokens": "def flattened_nested_key_indices ( nested_dict ) : outer_keys , inner_keys = collect_nested_keys ( nested_dict ) combined_keys = list ( sorted ( set ( outer_keys + inner_keys ) ) ) return { k : i for ( i , k ) in enumerate ( combined_keys ) }", "docstring_tokens": "Combine the outer and inner keys of nested dictionaries into a single ordering .", "label": 1}, {"idx": "cosqa-train-10781", "doc": "check if it is nonetype python", "code": "def is_sequence(obj):\n    \"\"\"Check if `obj` is a sequence, but not a string or bytes.\"\"\"\n    return isinstance(obj, Sequence) and not (\n        isinstance(obj, str) or BinaryClass.is_valid_type(obj))", "code_tokens": "def is_sequence ( obj ) : return isinstance ( obj , Sequence ) and not ( isinstance ( obj , str ) or BinaryClass . is_valid_type ( obj ) )", "docstring_tokens": "Check if obj is a sequence but not a string or bytes .", "label": 1}, {"idx": "cosqa-train-10782", "doc": "python extract sentences based on keywords", "code": "def extract_keywords_from_text(self, text):\n        \"\"\"Method to extract keywords from the text provided.\n\n        :param text: Text to extract keywords from, provided as a string.\n        \"\"\"\n        sentences = nltk.tokenize.sent_tokenize(text)\n        self.extract_keywords_from_sentences(sentences)", "code_tokens": "def extract_keywords_from_text ( self , text ) : sentences = nltk . tokenize . sent_tokenize ( text ) self . extract_keywords_from_sentences ( sentences )", "docstring_tokens": "Method to extract keywords from the text provided .", "label": 1}, {"idx": "cosqa-train-10783", "doc": "check if list object is null in python", "code": "def is_nullable_list(val, vtype):\n    \"\"\"Return True if list contains either values of type `vtype` or None.\"\"\"\n    return (isinstance(val, list) and\n            any(isinstance(v, vtype) for v in val) and\n            all((isinstance(v, vtype) or v is None) for v in val))", "code_tokens": "def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )", "docstring_tokens": "Return True if list contains either values of type vtype or None .", "label": 1}, {"idx": "cosqa-train-10784", "doc": "python fast reading within text file", "code": "def _fast_read(self, infile):\n        \"\"\"Function for fast reading from sensor files.\"\"\"\n        infile.seek(0)\n        return(int(infile.read().decode().strip()))", "code_tokens": "def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )", "docstring_tokens": "Function for fast reading from sensor files .", "label": 1}, {"idx": "cosqa-train-10785", "doc": "check if object is a number python", "code": "def is_number(obj):\n    \"\"\"Check if obj is number.\"\"\"\n    return isinstance(obj, (int, float, np.int_, np.float_))", "code_tokens": "def is_number ( obj ) : return isinstance ( obj , ( int , float , np . int_ , np . float_ ) )", "docstring_tokens": "Check if obj is number .", "label": 1}, {"idx": "cosqa-train-10786", "doc": "python fast way to decode image", "code": "def ffmpeg_works():\n  \"\"\"Tries to encode images with ffmpeg to check if it works.\"\"\"\n  images = np.zeros((2, 32, 32, 3), dtype=np.uint8)\n  try:\n    _encode_gif(images, 2)\n    return True\n  except (IOError, OSError):\n    return False", "code_tokens": "def ffmpeg_works ( ) : images = np . zeros ( ( 2 , 32 , 32 , 3 ) , dtype = np . uint8 ) try : _encode_gif ( images , 2 ) return True except ( IOError , OSError ) : return False", "docstring_tokens": "Tries to encode images with ffmpeg to check if it works .", "label": 1}, {"idx": "cosqa-train-10787", "doc": "check if python is running on microsoft", "code": "def inside_softimage():\n    \"\"\"Returns a boolean indicating if the code is executed inside softimage.\"\"\"\n    try:\n        import maya\n        return False\n    except ImportError:\n        pass\n    try:\n        from win32com.client import Dispatch as disp\n        disp('XSI.Application')\n        return True\n    except:\n        return False", "code_tokens": "def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False", "docstring_tokens": "Returns a boolean indicating if the code is executed inside softimage .", "label": 1}, {"idx": "cosqa-train-10788", "doc": "python fastest way to copy files", "code": "def copyFile(input, output, replace=None):\n    \"\"\"Copy a file whole from input to output.\"\"\"\n\n    _found = findFile(output)\n    if not _found or (_found and replace):\n        shutil.copy2(input, output)", "code_tokens": "def copyFile ( input , output , replace = None ) : _found = findFile ( output ) if not _found or ( _found and replace ) : shutil . copy2 ( input , output )", "docstring_tokens": "Copy a file whole from input to output .", "label": 1}, {"idx": "cosqa-train-10789", "doc": "check if python variable is a file path", "code": "def is_file(path):\n    \"\"\"Determine if a Path or string is a file on the file system.\"\"\"\n    try:\n        return path.expanduser().absolute().is_file()\n    except AttributeError:\n        return os.path.isfile(os.path.abspath(os.path.expanduser(str(path))))", "code_tokens": "def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )", "docstring_tokens": "Determine if a Path or string is a file on the file system .", "label": 1}, {"idx": "cosqa-train-10790", "doc": "python fatest way to read remote files", "code": "def get_remote_content(filepath):\n        \"\"\" A handy wrapper to get a remote file content \"\"\"\n        with hide('running'):\n            temp = BytesIO()\n            get(filepath, temp)\n            content = temp.getvalue().decode('utf-8')\n        return content.strip()", "code_tokens": "def get_remote_content ( filepath ) : with hide ( 'running' ) : temp = BytesIO ( ) get ( filepath , temp ) content = temp . getvalue ( ) . decode ( 'utf-8' ) return content . strip ( )", "docstring_tokens": "A handy wrapper to get a remote file content", "label": 1}, {"idx": "cosqa-train-10791", "doc": "check if string is hex python", "code": "def is_hex_string(string):\n    \"\"\"Check if the string is only composed of hex characters.\"\"\"\n    pattern = re.compile(r'[A-Fa-f0-9]+')\n    if isinstance(string, six.binary_type):\n        string = str(string)\n    return pattern.match(string) is not None", "code_tokens": "def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None", "docstring_tokens": "Check if the string is only composed of hex characters .", "label": 1}, {"idx": "cosqa-train-10792", "doc": "python ffmpeg save animation", "code": "def create_movie(fig, update_figure, filename, title, fps=15, dpi=100):\n    \"\"\"Helps us to create a movie.\"\"\"\n    FFMpegWriter = manimation.writers['ffmpeg']\n    metadata     = dict(title=title)\n    writer       = FFMpegWriter(fps=fps, metadata=metadata)\n\n    with writer.saving(fig, filename, dpi):\n        t = 0\n        while True:\n            if update_figure(t):\n                writer.grab_frame()\n                t += 1\n            else:\n                break", "code_tokens": "def create_movie ( fig , update_figure , filename , title , fps = 15 , dpi = 100 ) : FFMpegWriter = manimation . writers [ 'ffmpeg' ] metadata = dict ( title = title ) writer = FFMpegWriter ( fps = fps , metadata = metadata ) with writer . saving ( fig , filename , dpi ) : t = 0 while True : if update_figure ( t ) : writer . grab_frame ( ) t += 1 else : break", "docstring_tokens": "Helps us to create a movie .", "label": 1}, {"idx": "cosqa-train-10793", "doc": "check if string present in list of strings python", "code": "def any_contains_any(strings, candidates):\n    \"\"\"Whether any of the strings contains any of the candidates.\"\"\"\n    for string in strings:\n        for c in candidates:\n            if c in string:\n                return True", "code_tokens": "def any_contains_any ( strings , candidates ) : for string in strings : for c in candidates : if c in string : return True", "docstring_tokens": "Whether any of the strings contains any of the candidates .", "label": 1}, {"idx": "cosqa-train-10794", "doc": "python fft numpy code example magnitude", "code": "def log_magnitude_spectrum(frames):\n    \"\"\"Compute the log of the magnitude spectrum of frames\"\"\"\n    return N.log(N.abs(N.fft.rfft(frames)).clip(1e-5, N.inf))", "code_tokens": "def log_magnitude_spectrum ( frames ) : return N . log ( N . abs ( N . fft . rfft ( frames ) ) . clip ( 1e-5 , N . inf ) )", "docstring_tokens": "Compute the log of the magnitude spectrum of frames", "label": 1}, {"idx": "cosqa-train-10795", "doc": "check if variable is emoty or not in python", "code": "def is_symbol(string):\n    \"\"\"\n    Return true if the string is a mathematical symbol.\n    \"\"\"\n    return (\n        is_int(string) or is_float(string) or\n        is_constant(string) or is_unary(string) or\n        is_binary(string) or\n        (string == '(') or (string == ')')\n    )", "code_tokens": "def is_symbol ( string ) : return ( is_int ( string ) or is_float ( string ) or is_constant ( string ) or is_unary ( string ) or is_binary ( string ) or ( string == '(' ) or ( string == ')' ) )", "docstring_tokens": "Return true if the string is a mathematical symbol .", "label": 1}, {"idx": "cosqa-train-10796", "doc": "python fft plot magnitude phase", "code": "def log_magnitude_spectrum(frames):\n    \"\"\"Compute the log of the magnitude spectrum of frames\"\"\"\n    return N.log(N.abs(N.fft.rfft(frames)).clip(1e-5, N.inf))", "code_tokens": "def log_magnitude_spectrum ( frames ) : return N . log ( N . abs ( N . fft . rfft ( frames ) ) . clip ( 1e-5 , N . inf ) )", "docstring_tokens": "Compute the log of the magnitude spectrum of frames", "label": 1}, {"idx": "cosqa-train-10797", "doc": "check if variable not passed into html python flask", "code": "def check_empty_dict(GET_dict):\n    \"\"\"\n    Returns True if the GET querstring contains on values, but it can contain\n    empty keys.\n    This is better than doing not bool(request.GET) as an empty key will return\n    True\n    \"\"\"\n    empty = True\n    for k, v in GET_dict.items():\n        # Don't disable on p(age) or 'all' GET param\n        if v and k != 'p' and k != 'all':\n            empty = False\n    return empty", "code_tokens": "def check_empty_dict ( GET_dict ) : empty = True for k , v in GET_dict . items ( ) : # Don't disable on p(age) or 'all' GET param if v and k != 'p' and k != 'all' : empty = False return empty", "docstring_tokens": "Returns True if the GET querstring contains on values but it can contain empty keys . This is better than doing not bool ( request . GET ) as an empty key will return True", "label": 1}, {"idx": "cosqa-train-10798", "doc": "python fft scipy amplitude", "code": "def log_magnitude_spectrum(frames):\n    \"\"\"Compute the log of the magnitude spectrum of frames\"\"\"\n    return N.log(N.abs(N.fft.rfft(frames)).clip(1e-5, N.inf))", "code_tokens": "def log_magnitude_spectrum ( frames ) : return N . log ( N . abs ( N . fft . rfft ( frames ) ) . clip ( 1e-5 , N . inf ) )", "docstring_tokens": "Compute the log of the magnitude spectrum of frames", "label": 1}, {"idx": "cosqa-train-10799", "doc": "python fft spectrum np", "code": "def rfft2d_freqs(h, w):\n    \"\"\"Computes 2D spectrum frequencies.\"\"\"\n\n    fy = np.fft.fftfreq(h)[:, None]\n    # when we have an odd input dimension we need to keep one additional\n    # frequency and later cut off 1 pixel\n    if w % 2 == 1:\n        fx = np.fft.fftfreq(w)[: w // 2 + 2]\n    else:\n        fx = np.fft.fftfreq(w)[: w // 2 + 1]\n    return np.sqrt(fx * fx + fy * fy)", "code_tokens": "def rfft2d_freqs ( h , w ) : fy = np . fft . fftfreq ( h ) [ : , None ] # when we have an odd input dimension we need to keep one additional # frequency and later cut off 1 pixel if w % 2 == 1 : fx = np . fft . fftfreq ( w ) [ : w // 2 + 2 ] else : fx = np . fft . fftfreq ( w ) [ : w // 2 + 1 ] return np . sqrt ( fx * fx + fy * fy )", "docstring_tokens": "Computes 2D spectrum frequencies .", "label": 1}, {"idx": "cosqa-train-10800", "doc": "check list shape python", "code": "def _rectangular(n):\n    \"\"\"Checks to see if a 2D list is a valid 2D matrix\"\"\"\n    for i in n:\n        if len(i) != len(n[0]):\n            return False\n    return True", "code_tokens": "def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True", "docstring_tokens": "Checks to see if a 2D list is a valid 2D matrix", "label": 1}, {"idx": "cosqa-train-10801", "doc": "python file extension for pickled objects", "code": "def load(cls,filename):\n        \"\"\"Load from stored files\"\"\"\n        filename = cls.correct_file_extension(filename)\n        with open(filename,'rb') as f:\n            return pickle.load(f)", "code_tokens": "def load ( cls , filename ) : filename = cls . correct_file_extension ( filename ) with open ( filename , 'rb' ) as f : return pickle . load ( f )", "docstring_tokens": "Load from stored files", "label": 1}, {"idx": "cosqa-train-10802", "doc": "check memory size of computer python", "code": "def current_memory_usage():\n    \"\"\"\n    Returns this programs current memory usage in bytes\n    \"\"\"\n    import psutil\n    proc = psutil.Process(os.getpid())\n    #meminfo = proc.get_memory_info()\n    meminfo = proc.memory_info()\n    rss = meminfo[0]  # Resident Set Size / Mem Usage\n    vms = meminfo[1]  # Virtual Memory Size / VM Size  # NOQA\n    return rss", "code_tokens": "def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss", "docstring_tokens": "Returns this programs current memory usage in bytes", "label": 1}, {"idx": "cosqa-train-10803", "doc": "python file extension rename to lower", "code": "def lower_ext(abspath):\n    \"\"\"Convert file extension to lowercase.\n    \"\"\"\n    fname, ext = os.path.splitext(abspath)\n    return fname + ext.lower()", "code_tokens": "def lower_ext ( abspath ) : fname , ext = os . path . splitext ( abspath ) return fname + ext . lower ( )", "docstring_tokens": "Convert file extension to lowercase .", "label": 1}, {"idx": "cosqa-train-10804", "doc": "check memory usage in python", "code": "def get_free_memory_win():\n    \"\"\"Return current free memory on the machine for windows.\n\n    Warning : this script is really not robust\n    Return in MB unit\n    \"\"\"\n    stat = MEMORYSTATUSEX()\n    ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(stat))\n    return int(stat.ullAvailPhys / 1024 / 1024)", "code_tokens": "def get_free_memory_win ( ) : stat = MEMORYSTATUSEX ( ) ctypes . windll . kernel32 . GlobalMemoryStatusEx ( ctypes . byref ( stat ) ) return int ( stat . ullAvailPhys / 1024 / 1024 )", "docstring_tokens": "Return current free memory on the machine for windows .", "label": 1}, {"idx": "cosqa-train-10805", "doc": "python file flush not working", "code": "def file_writelines_flush_sync(path, lines):\n    \"\"\"\n    Fill file at @path with @lines then flush all buffers\n    (Python and system buffers)\n    \"\"\"\n    fp = open(path, 'w')\n    try:\n        fp.writelines(lines)\n        flush_sync_file_object(fp)\n    finally:\n        fp.close()", "code_tokens": "def file_writelines_flush_sync ( path , lines ) : fp = open ( path , 'w' ) try : fp . writelines ( lines ) flush_sync_file_object ( fp ) finally : fp . close ( )", "docstring_tokens": "Fill file at", "label": 0}, {"idx": "cosqa-train-10806", "doc": "check systemd service python", "code": "def service_available(service_name):\n    \"\"\"Determine whether a system service is available\"\"\"\n    try:\n        subprocess.check_output(\n            ['service', service_name, 'status'],\n            stderr=subprocess.STDOUT).decode('UTF-8')\n    except subprocess.CalledProcessError as e:\n        return b'unrecognized service' not in e.output\n    else:\n        return True", "code_tokens": "def service_available ( service_name ) : try : subprocess . check_output ( [ 'service' , service_name , 'status' ] , stderr = subprocess . STDOUT ) . decode ( 'UTF-8' ) except subprocess . CalledProcessError as e : return b'unrecognized service' not in e . output else : return True", "docstring_tokens": "Determine whether a system service is available", "label": 1}, {"idx": "cosqa-train-10807", "doc": "python file read last line", "code": "def last(self):\n        \"\"\"Get the last object in file.\"\"\"\n        # End of file\n        self.__file.seek(0, 2)\n\n        # Get the last struct\n        data = self.get(self.length - 1)\n\n        return data", "code_tokens": "def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data", "docstring_tokens": "Get the last object in file .", "label": 1}, {"idx": "cosqa-train-10808", "doc": "check type in list python", "code": "def _valid_other_type(x, types):\n    \"\"\"\n    Do all elements of x have a type from types?\n    \"\"\"\n    return all(any(isinstance(el, t) for t in types) for el in np.ravel(x))", "code_tokens": "def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )", "docstring_tokens": "Do all elements of x have a type from types?", "label": 1}, {"idx": "cosqa-train-10809", "doc": "python filter columns isin", "code": "def selectin(table, field, value, complement=False):\n    \"\"\"Select rows where the given field is a member of the given value.\"\"\"\n\n    return select(table, field, lambda v: v in value,\n                  complement=complement)", "code_tokens": "def selectin ( table , field , value , complement = False ) : return select ( table , field , lambda v : v in value , complement = complement )", "docstring_tokens": "Select rows where the given field is a member of the given value .", "label": 1}, {"idx": "cosqa-train-10810", "doc": "checking for file changes in python", "code": "def example_write_file_to_disk_if_changed():\n    \"\"\" Try to remove all comments from a file, and save it if changes were made. \"\"\"\n    my_file = FileAsObj('/tmp/example_file.txt')\n    my_file.rm(my_file.egrep('^#'))\n    if my_file.changed:\n        my_file.save()", "code_tokens": "def example_write_file_to_disk_if_changed ( ) : my_file = FileAsObj ( '/tmp/example_file.txt' ) my_file . rm ( my_file . egrep ( '^#' ) ) if my_file . changed : my_file . save ( )", "docstring_tokens": "Try to remove all comments from a file and save it if changes were made .", "label": 1}, {"idx": "cosqa-train-10811", "doc": "python filter empty lines", "code": "def cleanLines(source, lineSep=os.linesep):\n    \"\"\"\n    :param source: some iterable source (list, file, etc)\n    :param lineSep: string of separators (chars) that must be removed\n    :return: list of non empty lines with removed separators\n    \"\"\"\n    stripped = (line.strip(lineSep) for line in source)\n    return (line for line in stripped if len(line) != 0)", "code_tokens": "def cleanLines ( source , lineSep = os . linesep ) : stripped = ( line . strip ( lineSep ) for line in source ) return ( line for line in stripped if len ( line ) != 0 )", "docstring_tokens": ": param source : some iterable source ( list file etc ) : param lineSep : string of separators ( chars ) that must be removed : return : list of non empty lines with removed separators", "label": 1}, {"idx": "cosqa-train-10812", "doc": "checking in python if two files are similar", "code": "def cmp_contents(filename1, filename2):\n    \"\"\" Returns True if contents of the files are the same\n\n    Parameters\n    ----------\n    filename1 : str\n        filename of first file to compare\n    filename2 : str\n        filename of second file to compare\n\n    Returns\n    -------\n    tf : bool\n        True if binary contents of `filename1` is same as binary contents of\n        `filename2`, False otherwise.\n    \"\"\"\n    with open_readable(filename1, 'rb') as fobj:\n        contents1 = fobj.read()\n    with open_readable(filename2, 'rb') as fobj:\n        contents2 = fobj.read()\n    return contents1 == contents2", "code_tokens": "def cmp_contents ( filename1 , filename2 ) : with open_readable ( filename1 , 'rb' ) as fobj : contents1 = fobj . read ( ) with open_readable ( filename2 , 'rb' ) as fobj : contents2 = fobj . read ( ) return contents1 == contents2", "docstring_tokens": "Returns True if contents of the files are the same", "label": 1}, {"idx": "cosqa-train-10813", "doc": "python filter out stop words", "code": "def _removeStopwords(text_list):\n    \"\"\"\n    Removes stopwords contained in a list of words.\n\n    :param text_string: A list of strings.\n    :type text_string: list.\n\n    :returns: The input ``text_list`` with stopwords removed.\n    :rtype: list\n    \"\"\"\n\n    output_list = []\n\n    for word in text_list:\n        if word.lower() not in _stopwords:\n            output_list.append(word)\n\n    return output_list", "code_tokens": "def _removeStopwords ( text_list ) : output_list = [ ] for word in text_list : if word . lower ( ) not in _stopwords : output_list . append ( word ) return output_list", "docstring_tokens": "Removes stopwords contained in a list of words .", "label": 1}, {"idx": "cosqa-train-10814", "doc": "checking the intersection of two boxes in python", "code": "def boxes_intersect(box1, box2):\n    \"\"\"Determines if two rectangles, each input as a tuple\n        (xmin, xmax, ymin, ymax), intersect.\"\"\"\n    xmin1, xmax1, ymin1, ymax1 = box1\n    xmin2, xmax2, ymin2, ymax2 = box2\n    if interval_intersection_width(xmin1, xmax1, xmin2, xmax2) and \\\n            interval_intersection_width(ymin1, ymax1, ymin2, ymax2):\n        return True\n    else:\n        return False", "code_tokens": "def boxes_intersect ( box1 , box2 ) : xmin1 , xmax1 , ymin1 , ymax1 = box1 xmin2 , xmax2 , ymin2 , ymax2 = box2 if interval_intersection_width ( xmin1 , xmax1 , xmin2 , xmax2 ) and interval_intersection_width ( ymin1 , ymax1 , ymin2 , ymax2 ) : return True else : return False", "docstring_tokens": "Determines if two rectangles each input as a tuple ( xmin xmax ymin ymax ) intersect .", "label": 1}, {"idx": "cosqa-train-10815", "doc": "python filter the duplicated item in a list", "code": "def delete_duplicates(seq):\n    \"\"\"\n    Remove duplicates from an iterable, preserving the order.\n\n    Args:\n        seq: Iterable of various type.\n\n    Returns:\n        list: List of unique objects.\n\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "Remove duplicates from an iterable preserving the order .", "label": 1}, {"idx": "cosqa-train-10816", "doc": "python finally run before raise", "code": "def __exit__(self, type, value, traceback):\n        \"\"\"When the `with` statement ends.\"\"\"\n\n        if not self.asarfile:\n            return\n\n        self.asarfile.close()\n        self.asarfile = None", "code_tokens": "def __exit__ ( self , type , value , traceback ) : if not self . asarfile : return self . asarfile . close ( ) self . asarfile = None", "docstring_tokens": "When the with statement ends .", "label": 1}, {"idx": "cosqa-train-10817", "doc": "chmod python windows to remove file", "code": "def rmfile(path):\n    \"\"\"Ensure file deleted also on *Windows* where read-only files need special treatment.\"\"\"\n    if osp.isfile(path):\n        if is_win:\n            os.chmod(path, 0o777)\n        os.remove(path)", "code_tokens": "def rmfile ( path ) : if osp . isfile ( path ) : if is_win : os . chmod ( path , 0o777 ) os . remove ( path )", "docstring_tokens": "Ensure file deleted also on * Windows * where read - only files need special treatment .", "label": 1}, {"idx": "cosqa-train-10818", "doc": "python finding local maxima in image", "code": "def local_minima(img, min_distance = 4):\n    r\"\"\"\n    Returns all local minima from an image.\n    \n    Parameters\n    ----------\n    img : array_like\n        The image.\n    min_distance : integer\n        The minimal distance between the minimas in voxels. If it is less, only the lower minima is returned.\n    \n    Returns\n    -------\n    indices : sequence\n        List of all minima indices.\n    values : sequence\n        List of all minima values.\n    \"\"\"\n    # @TODO: Write a unittest for this.\n    fits = numpy.asarray(img)\n    minfits = minimum_filter(fits, size=min_distance) # default mode is reflect\n    minima_mask = fits == minfits\n    good_indices = numpy.transpose(minima_mask.nonzero())\n    good_fits = fits[minima_mask]\n    order = good_fits.argsort()\n    return good_indices[order], good_fits[order]", "code_tokens": "def local_minima ( img , min_distance = 4 ) : # @TODO: Write a unittest for this. fits = numpy . asarray ( img ) minfits = minimum_filter ( fits , size = min_distance ) # default mode is reflect minima_mask = fits == minfits good_indices = numpy . transpose ( minima_mask . nonzero ( ) ) good_fits = fits [ minima_mask ] order = good_fits . argsort ( ) return good_indices [ order ] , good_fits [ order ]", "docstring_tokens": "r Returns all local minima from an image . Parameters ---------- img : array_like The image . min_distance : integer The minimal distance between the minimas in voxels . If it is less only the lower minima is returned . Returns ------- indices : sequence List of all minima indices . values : sequence List of all minima values .", "label": 1}, {"idx": "cosqa-train-10819", "doc": "choose directory in python gui", "code": "def on_source_directory_chooser_clicked(self):\n        \"\"\"Autoconnect slot activated when tbSourceDir is clicked.\"\"\"\n\n        title = self.tr('Set the source directory for script and scenario')\n        self.choose_directory(self.source_directory, title)", "code_tokens": "def on_source_directory_chooser_clicked ( self ) : title = self . tr ( 'Set the source directory for script and scenario' ) self . choose_directory ( self . source_directory , title )", "docstring_tokens": "Autoconnect slot activated when tbSourceDir is clicked .", "label": 1}, {"idx": "cosqa-train-10820", "doc": "python first of month for date", "code": "def monthly(date=datetime.date.today()):\n    \"\"\"\n    Take a date object and return the first day of the month.\n    \"\"\"\n    return datetime.date(date.year, date.month, 1)", "code_tokens": "def monthly ( date = datetime . date . today ( ) ) : return datetime . date ( date . year , date . month , 1 )", "docstring_tokens": "Take a date object and return the first day of the month .", "label": 1}, {"idx": "cosqa-train-10821", "doc": "cifar 10 python 3", "code": "def revnet_164_cifar():\n  \"\"\"Tiny hparams suitable for CIFAR/etc.\"\"\"\n  hparams = revnet_cifar_base()\n  hparams.bottleneck = True\n  hparams.num_channels = [16, 32, 64]\n  hparams.num_layers_per_block = [8, 8, 8]\n  return hparams", "code_tokens": "def revnet_164_cifar ( ) : hparams = revnet_cifar_base ( ) hparams . bottleneck = True hparams . num_channels = [ 16 , 32 , 64 ] hparams . num_layers_per_block = [ 8 , 8 , 8 ] return hparams", "docstring_tokens": "Tiny hparams suitable for CIFAR / etc .", "label": 1}, {"idx": "cosqa-train-10822", "doc": "python fiure out object type", "code": "def type(self):\n        \"\"\"Returns type of the data for the given FeatureType.\"\"\"\n        if self is FeatureType.TIMESTAMP:\n            return list\n        if self is FeatureType.BBOX:\n            return BBox\n        return dict", "code_tokens": "def type ( self ) : if self is FeatureType . TIMESTAMP : return list if self is FeatureType . BBOX : return BBox return dict", "docstring_tokens": "Returns type of the data for the given FeatureType .", "label": 1}, {"idx": "cosqa-train-10823", "doc": "clear all local variables python", "code": "def _clear(self):\n        \"\"\"Resets all assigned data for the current message.\"\"\"\n        self._finished = False\n        self._measurement = None\n        self._message = None\n        self._message_body = None", "code_tokens": "def _clear ( self ) : self . _finished = False self . _measurement = None self . _message = None self . _message_body = None", "docstring_tokens": "Resets all assigned data for the current message .", "label": 1}, {"idx": "cosqa-train-10824", "doc": "python fixed align print text", "code": "def indented_show(text, howmany=1):\n        \"\"\"Print a formatted indented text.\n        \"\"\"\n        print(StrTemplate.pad_indent(text=text, howmany=howmany))", "code_tokens": "def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )", "docstring_tokens": "Print a formatted indented text .", "label": 1}, {"idx": "cosqa-train-10825", "doc": "clear an numpy array from memory, python", "code": "def free(self):\n        \"\"\"Free the underlying C array\"\"\"\n        if self._ptr is None:\n            return\n        Gauged.array_free(self.ptr)\n        FloatArray.ALLOCATIONS -= 1\n        self._ptr = None", "code_tokens": "def free ( self ) : if self . _ptr is None : return Gauged . array_free ( self . ptr ) FloatArray . ALLOCATIONS -= 1 self . _ptr = None", "docstring_tokens": "Free the underlying C array", "label": 1}, {"idx": "cosqa-train-10826", "doc": "python flask if has url params not empty", "code": "def check_empty_dict(GET_dict):\n    \"\"\"\n    Returns True if the GET querstring contains on values, but it can contain\n    empty keys.\n    This is better than doing not bool(request.GET) as an empty key will return\n    True\n    \"\"\"\n    empty = True\n    for k, v in GET_dict.items():\n        # Don't disable on p(age) or 'all' GET param\n        if v and k != 'p' and k != 'all':\n            empty = False\n    return empty", "code_tokens": "def check_empty_dict ( GET_dict ) : empty = True for k , v in GET_dict . items ( ) : # Don't disable on p(age) or 'all' GET param if v and k != 'p' and k != 'all' : empty = False return empty", "docstring_tokens": "Returns True if the GET querstring contains on values but it can contain empty keys . This is better than doing not bool ( request . GET ) as an empty key will return True", "label": 1}, {"idx": "cosqa-train-10827", "doc": "close command in python 2", "code": "def do_exit(self, arg):\n        \"\"\"Exit the shell session.\"\"\"\n\n        if self.current:\n            self.current.close()\n        self.resource_manager.close()\n        del self.resource_manager\n        return True", "code_tokens": "def do_exit ( self , arg ) : if self . current : self . current . close ( ) self . resource_manager . close ( ) del self . resource_manager return True", "docstring_tokens": "Exit the shell session .", "label": 1}, {"idx": "cosqa-train-10828", "doc": "python flask if requests is post", "code": "def handleFlaskPostRequest(flaskRequest, endpoint):\n    \"\"\"\n    Handles the specified flask request for one of the POST URLS\n    Invokes the specified endpoint to generate a response.\n    \"\"\"\n    if flaskRequest.method == \"POST\":\n        return handleHttpPost(flaskRequest, endpoint)\n    elif flaskRequest.method == \"OPTIONS\":\n        return handleHttpOptions()\n    else:\n        raise exceptions.MethodNotAllowedException()", "code_tokens": "def handleFlaskPostRequest ( flaskRequest , endpoint ) : if flaskRequest . method == \"POST\" : return handleHttpPost ( flaskRequest , endpoint ) elif flaskRequest . method == \"OPTIONS\" : return handleHttpOptions ( ) else : raise exceptions . MethodNotAllowedException ( )", "docstring_tokens": "Handles the specified flask request for one of the POST URLS Invokes the specified endpoint to generate a response .", "label": 1}, {"idx": "cosqa-train-10829", "doc": "close db connection on execpt python", "code": "def close( self ):\n        \"\"\"\n        Close the db and release memory\n        \"\"\"\n        if self.db is not None:\n            self.db.commit()\n            self.db.close()\n            self.db = None\n\n        return", "code_tokens": "def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return", "docstring_tokens": "Close the db and release memory", "label": 1}, {"idx": "cosqa-train-10830", "doc": "python flask link route and responce", "code": "def home():\n    \"\"\"Temporary helper function to link to the API routes\"\"\"\n    return dict(links=dict(api='{}{}'.format(request.url, PREFIX[1:]))), \\\n        HTTPStatus.OK", "code_tokens": "def home ( ) : return dict ( links = dict ( api = '{}{}' . format ( request . url , PREFIX [ 1 : ] ) ) ) , HTTPStatus . OK", "docstring_tokens": "Temporary helper function to link to the API routes", "label": 0}, {"idx": "cosqa-train-10831", "doc": "close python sql server connections", "code": "def cleanup(self, app):\n        \"\"\"Close all connections.\"\"\"\n        if hasattr(self.database.obj, 'close_all'):\n            self.database.close_all()", "code_tokens": "def cleanup ( self , app ) : if hasattr ( self . database . obj , 'close_all' ) : self . database . close_all ( )", "docstring_tokens": "Close all connections .", "label": 0}, {"idx": "cosqa-train-10832", "doc": "python flask method not allowed for requested url", "code": "def _has_fr_route(self):\n        \"\"\"Encapsulating the rules for whether the request was to a Flask endpoint\"\"\"\n        # 404's, 405's, which might not have a url_rule\n        if self._should_use_fr_error_handler():\n            return True\n        # for all other errors, just check if FR dispatched the route\n        if not request.url_rule:\n            return False\n        return self.owns_endpoint(request.url_rule.endpoint)", "code_tokens": "def _has_fr_route ( self ) : # 404's, 405's, which might not have a url_rule if self . _should_use_fr_error_handler ( ) : return True # for all other errors, just check if FR dispatched the route if not request . url_rule : return False return self . owns_endpoint ( request . url_rule . endpoint )", "docstring_tokens": "Encapsulating the rules for whether the request was to a Flask endpoint", "label": 1}, {"idx": "cosqa-train-10833", "doc": "cmap color python colarbar limits", "code": "def palettebar(height, length, colormap):\n    \"\"\"Return the channels of a palettebar.\n    \"\"\"\n    cbar = np.tile(np.arange(length) * 1.0 / (length - 1), (height, 1))\n    cbar = (cbar * (colormap.values.max() + 1 - colormap.values.min())\n            + colormap.values.min())\n\n    return colormap.palettize(cbar)", "code_tokens": "def palettebar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) + 1 - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . palettize ( cbar )", "docstring_tokens": "Return the channels of a palettebar .", "label": 1}, {"idx": "cosqa-train-10834", "doc": "python flask request set authorization headers", "code": "def __call__(self, r):\n        \"\"\"Update the request headers.\"\"\"\n        r.headers['Authorization'] = 'JWT {jwt}'.format(jwt=self.token)\n        return r", "code_tokens": "def __call__ ( self , r ) : r . headers [ 'Authorization' ] = 'JWT {jwt}' . format ( jwt = self . token ) return r", "docstring_tokens": "Update the request headers .", "label": 1}, {"idx": "cosqa-train-10835", "doc": "code for calculating manhattan distance in python", "code": "def _manhattan_distance(vec_a, vec_b):\n    \"\"\"Return manhattan distance between two lists of numbers.\"\"\"\n    if len(vec_a) != len(vec_b):\n        raise ValueError('len(vec_a) must equal len(vec_b)')\n    return sum(map(lambda a, b: abs(a - b), vec_a, vec_b))", "code_tokens": "def _manhattan_distance ( vec_a , vec_b ) : if len ( vec_a ) != len ( vec_b ) : raise ValueError ( 'len(vec_a) must equal len(vec_b)' ) return sum ( map ( lambda a , b : abs ( a - b ) , vec_a , vec_b ) )", "docstring_tokens": "Return manhattan distance between two lists of numbers .", "label": 1}, {"idx": "cosqa-train-10836", "doc": "python flask watch restart", "code": "def do_restart(self, line):\n        \"\"\"Request that the Outstation perform a cold restart. Command syntax is: restart\"\"\"\n        self.application.master.Restart(opendnp3.RestartType.COLD, restart_callback)", "code_tokens": "def do_restart ( self , line ) : self . application . master . Restart ( opendnp3 . RestartType . COLD , restart_callback )", "docstring_tokens": "Request that the Outstation perform a cold restart . Command syntax is : restart", "label": 1}, {"idx": "cosqa-train-10837", "doc": "combobox dropdown event python click", "code": "def onchange(self, value):\n        \"\"\"Called when a new DropDownItem gets selected.\n        \"\"\"\n        log.debug('combo box. selected %s' % value)\n        self.select_by_value(value)\n        return (value, )", "code_tokens": "def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )", "docstring_tokens": "Called when a new DropDownItem gets selected .", "label": 1}, {"idx": "cosqa-train-10838", "doc": "command to clear the shell in python", "code": "def clear():\n    \"\"\"Clears the console.\"\"\"\n    if sys.platform.startswith(\"win\"):\n        call(\"cls\", shell=True)\n    else:\n        call(\"clear\", shell=True)", "code_tokens": "def clear ( ) : if sys . platform . startswith ( \"win\" ) : call ( \"cls\" , shell = True ) else : call ( \"clear\" , shell = True )", "docstring_tokens": "Clears the console .", "label": 1}, {"idx": "cosqa-train-10839", "doc": "python flat nested lists", "code": "def flatten(nested):\n    \"\"\" Return a flatten version of the nested argument \"\"\"\n    flat_return = list()\n\n    def __inner_flat(nested,flat):\n        for i in nested:\n            __inner_flat(i, flat) if isinstance(i, list) else flat.append(i)\n        return flat\n\n    __inner_flat(nested,flat_return)\n\n    return flat_return", "code_tokens": "def flatten ( nested ) : flat_return = list ( ) def __inner_flat ( nested , flat ) : for i in nested : __inner_flat ( i , flat ) if isinstance ( i , list ) else flat . append ( i ) return flat __inner_flat ( nested , flat_return ) return flat_return", "docstring_tokens": "Return a flatten version of the nested argument", "label": 1}, {"idx": "cosqa-train-10840", "doc": "command to run test cases in python shell", "code": "def test(ctx, all=False, verbose=False):\n    \"\"\"Run the tests.\"\"\"\n    cmd = 'tox' if all else 'py.test'\n    if verbose:\n        cmd += ' -v'\n    return ctx.run(cmd, pty=True).return_code", "code_tokens": "def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code", "docstring_tokens": "Run the tests .", "label": 1}, {"idx": "cosqa-train-10841", "doc": "python flatten deep nested list", "code": "def flatten(nested):\n    \"\"\" Return a flatten version of the nested argument \"\"\"\n    flat_return = list()\n\n    def __inner_flat(nested,flat):\n        for i in nested:\n            __inner_flat(i, flat) if isinstance(i, list) else flat.append(i)\n        return flat\n\n    __inner_flat(nested,flat_return)\n\n    return flat_return", "code_tokens": "def flatten ( nested ) : flat_return = list ( ) def __inner_flat ( nested , flat ) : for i in nested : __inner_flat ( i , flat ) if isinstance ( i , list ) else flat . append ( i ) return flat __inner_flat ( nested , flat_return ) return flat_return", "docstring_tokens": "Return a flatten version of the nested argument", "label": 1}, {"idx": "cosqa-train-10842", "doc": "compare elemt wise two vector sin python", "code": "def _euclidean_dist(vector_a, vector_b):\n    \"\"\"\n    :param vector_a:    A list of numbers.\n    :param vector_b:    A list of numbers.\n    :returns:           The euclidean distance between the two vectors.\n    \"\"\"\n    dist = 0\n    for (x, y) in zip(vector_a, vector_b):\n        dist += (x-y)*(x-y)\n    return math.sqrt(dist)", "code_tokens": "def _euclidean_dist ( vector_a , vector_b ) : dist = 0 for ( x , y ) in zip ( vector_a , vector_b ) : dist += ( x - y ) * ( x - y ) return math . sqrt ( dist )", "docstring_tokens": ": param vector_a : A list of numbers . : param vector_b : A list of numbers . : returns : The euclidean distance between the two vectors .", "label": 1}, {"idx": "cosqa-train-10843", "doc": "python flatten in not defined", "code": "def flatten(lis):\n    \"\"\"Given a list, possibly nested to any level, return it flattened.\"\"\"\n    new_lis = []\n    for item in lis:\n        if isinstance(item, collections.Sequence) and not isinstance(item, basestring):\n            new_lis.extend(flatten(item))\n        else:\n            new_lis.append(item)\n    return new_lis", "code_tokens": "def flatten ( lis ) : new_lis = [ ] for item in lis : if isinstance ( item , collections . Sequence ) and not isinstance ( item , basestring ) : new_lis . extend ( flatten ( item ) ) else : new_lis . append ( item ) return new_lis", "docstring_tokens": "Given a list possibly nested to any level return it flattened .", "label": 1}, {"idx": "cosqa-train-10844", "doc": "compare python string, list and tuple", "code": "def is_iter_non_string(obj):\n    \"\"\"test if object is a list or tuple\"\"\"\n    if isinstance(obj, list) or isinstance(obj, tuple):\n        return True\n    return False", "code_tokens": "def is_iter_non_string ( obj ) : if isinstance ( obj , list ) or isinstance ( obj , tuple ) : return True return False", "docstring_tokens": "test if object is a list or tuple", "label": 1}, {"idx": "cosqa-train-10845", "doc": "python flip a matrix", "code": "def imflip(img, direction='horizontal'):\n    \"\"\"Flip an image horizontally or vertically.\n\n    Args:\n        img (ndarray): Image to be flipped.\n        direction (str): The flip direction, either \"horizontal\" or \"vertical\".\n\n    Returns:\n        ndarray: The flipped image.\n    \"\"\"\n    assert direction in ['horizontal', 'vertical']\n    if direction == 'horizontal':\n        return np.flip(img, axis=1)\n    else:\n        return np.flip(img, axis=0)", "code_tokens": "def imflip ( img , direction = 'horizontal' ) : assert direction in [ 'horizontal' , 'vertical' ] if direction == 'horizontal' : return np . flip ( img , axis = 1 ) else : return np . flip ( img , axis = 0 )", "docstring_tokens": "Flip an image horizontally or vertically .", "label": 1}, {"idx": "cosqa-train-10846", "doc": "comparing elements of an array to an entire second array in python", "code": "def compare(a, b):\n    \"\"\"\n     Compare items in 2 arrays. Returns sum(abs(a(i)-b(i)))\n    \"\"\"\n    s=0\n    for i in range(len(a)):\n        s=s+abs(a[i]-b[i])\n    return s", "code_tokens": "def compare ( a , b ) : s = 0 for i in range ( len ( a ) ) : s = s + abs ( a [ i ] - b [ i ] ) return s", "docstring_tokens": "Compare items in 2 arrays . Returns sum ( abs ( a ( i ) - b ( i )))", "label": 1}, {"idx": "cosqa-train-10847", "doc": "python flush thread before executing", "code": "def enable_writes(self):\n        \"\"\"Restores the state of the batched queue for writing.\"\"\"\n        self.write_buffer = []\n        self.flush_lock = threading.RLock()\n        self.flush_thread = FlushThread(self.max_batch_time,\n                                        self._flush_writes)", "code_tokens": "def enable_writes ( self ) : self . write_buffer = [ ] self . flush_lock = threading . RLock ( ) self . flush_thread = FlushThread ( self . max_batch_time , self . _flush_writes )", "docstring_tokens": "Restores the state of the batched queue for writing .", "label": 1}, {"idx": "cosqa-train-10848", "doc": "comparing integers and strings in python", "code": "def is_int(string):\n    \"\"\"\n    Checks if a string is an integer. If the string value is an integer\n    return True, otherwise return False. \n    \n    Args:\n        string: a string to test.\n\n    Returns: \n        boolean\n    \"\"\"\n    try:\n        a = float(string)\n        b = int(a)\n    except ValueError:\n        return False\n    else:\n        return a == b", "code_tokens": "def is_int ( string ) : try : a = float ( string ) b = int ( a ) except ValueError : return False else : return a == b", "docstring_tokens": "Checks if a string is an integer . If the string value is an integer return True otherwise return False . Args : string : a string to test .", "label": 1}, {"idx": "cosqa-train-10849", "doc": "python flush writes faster", "code": "def enable_writes(self):\n        \"\"\"Restores the state of the batched queue for writing.\"\"\"\n        self.write_buffer = []\n        self.flush_lock = threading.RLock()\n        self.flush_thread = FlushThread(self.max_batch_time,\n                                        self._flush_writes)", "code_tokens": "def enable_writes ( self ) : self . write_buffer = [ ] self . flush_lock = threading . RLock ( ) self . flush_thread = FlushThread ( self . max_batch_time , self . _flush_writes )", "docstring_tokens": "Restores the state of the batched queue for writing .", "label": 1}, {"idx": "cosqa-train-10850", "doc": "compress zlib python readable by gzip", "code": "def compressBuffer(buffer):\n    \"\"\"\n    Note that this code compresses into a buffer held in memory, rather\n    than a disk file. This is done through the use of cStringIO.StringIO().\n    \"\"\"\n    # http://jython.xhaus.com/http-compression-in-python-and-jython/\n    zbuf = cStringIO.StringIO()\n    zfile = gzip.GzipFile(mode='wb', fileobj=zbuf, compresslevel=9)\n    zfile.write(buffer)\n    zfile.close()\n    return zbuf.getvalue()", "code_tokens": "def compressBuffer ( buffer ) : # http://jython.xhaus.com/http-compression-in-python-and-jython/ zbuf = cStringIO . StringIO ( ) zfile = gzip . GzipFile ( mode = 'wb' , fileobj = zbuf , compresslevel = 9 ) zfile . write ( buffer ) zfile . close ( ) return zbuf . getvalue ( )", "docstring_tokens": "Note that this code compresses into a buffer held in memory rather than a disk file . This is done through the use of cStringIO . StringIO () .", "label": 1}, {"idx": "cosqa-train-10851", "doc": "python fonttools how to merge", "code": "def setLib(self, lib):\n        \"\"\" Copy the lib items into our font. \"\"\"\n        for name, item in lib.items():\n            self.font.lib[name] = item", "code_tokens": "def setLib ( self , lib ) : for name , item in lib . items ( ) : self . font . lib [ name ] = item", "docstring_tokens": "Copy the lib items into our font .", "label": 1}, {"idx": "cosqa-train-10852", "doc": "compute poisson cdf in python", "code": "def EvalPoissonPmf(k, lam):\n    \"\"\"Computes the Poisson PMF.\n\n    k: number of events\n    lam: parameter lambda in events per unit time\n\n    returns: float probability\n    \"\"\"\n    # don't use the scipy function (yet).  for lam=0 it returns NaN;\n    # should be 0.0\n    # return scipy.stats.poisson.pmf(k, lam)\n\n    return lam ** k * math.exp(-lam) / math.factorial(k)", "code_tokens": "def EvalPoissonPmf ( k , lam ) : # don't use the scipy function (yet).  for lam=0 it returns NaN; # should be 0.0 # return scipy.stats.poisson.pmf(k, lam) return lam ** k * math . exp ( - lam ) / math . factorial ( k )", "docstring_tokens": "Computes the Poisson PMF .", "label": 1}, {"idx": "cosqa-train-10853", "doc": "python for tensorflow nightly versio", "code": "def tf2():\n  \"\"\"Provide the root module of a TF-2.0 API for use within TensorBoard.\n\n  Returns:\n    The root module of a TF-2.0 API, if available.\n\n  Raises:\n    ImportError: if a TF-2.0 API is not available.\n  \"\"\"\n  # Import the `tf` compat API from this file and check if it's already TF 2.0.\n  if tf.__version__.startswith('2.'):\n    return tf\n  elif hasattr(tf, 'compat') and hasattr(tf.compat, 'v2'):\n    # As a fallback, try `tensorflow.compat.v2` if it's defined.\n    return tf.compat.v2\n  raise ImportError('cannot import tensorflow 2.0 API')", "code_tokens": "def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )", "docstring_tokens": "Provide the root module of a TF - 2 . 0 API for use within TensorBoard .", "label": 1}, {"idx": "cosqa-train-10854", "doc": "compute the middle index in list python", "code": "def bisect_index(a, x):\n    \"\"\" Find the leftmost index of an element in a list using binary search.\n\n    Parameters\n    ----------\n    a: list\n        A sorted list.\n    x: arbitrary\n        The element.\n\n    Returns\n    -------\n    int\n        The index.\n\n    \"\"\"\n    i = bisect.bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    raise ValueError", "code_tokens": "def bisect_index ( a , x ) : i = bisect . bisect_left ( a , x ) if i != len ( a ) and a [ i ] == x : return i raise ValueError", "docstring_tokens": "Find the leftmost index of an element in a list using binary search .", "label": 1}, {"idx": "cosqa-train-10855", "doc": "python force lambda function to be eager", "code": "def _eager_tasklet(tasklet):\n  \"\"\"Decorator to turn tasklet to run eagerly.\"\"\"\n\n  @utils.wrapping(tasklet)\n  def eager_wrapper(*args, **kwds):\n    fut = tasklet(*args, **kwds)\n    _run_until_rpc()\n    return fut\n\n  return eager_wrapper", "code_tokens": "def _eager_tasklet ( tasklet ) : @ utils . wrapping ( tasklet ) def eager_wrapper ( * args , * * kwds ) : fut = tasklet ( * args , * * kwds ) _run_until_rpc ( ) return fut return eager_wrapper", "docstring_tokens": "Decorator to turn tasklet to run eagerly .", "label": 1}, {"idx": "cosqa-train-10856", "doc": "compute tpr fpr for a model in python", "code": "def tpr(y, z):\n    \"\"\"True positive rate `tp / (tp + fn)`\n    \"\"\"\n    tp, tn, fp, fn = contingency_table(y, z)\n    return tp / (tp + fn)", "code_tokens": "def tpr ( y , z ) : tp , tn , fp , fn = contingency_table ( y , z ) return tp / ( tp + fn )", "docstring_tokens": "True positive rate tp / ( tp + fn )", "label": 1}, {"idx": "cosqa-train-10857", "doc": "python force list reference to be copy", "code": "def copy(self):\n        \"\"\"Return a copy of this list with each element copied to new memory\n        \"\"\"\n        out = type(self)()\n        for series in self:\n            out.append(series.copy())\n        return out", "code_tokens": "def copy ( self ) : out = type ( self ) ( ) for series in self : out . append ( series . copy ( ) ) return out", "docstring_tokens": "Return a copy of this list with each element copied to new memory", "label": 1}, {"idx": "cosqa-train-10858", "doc": "configure a list of characters into a string python", "code": "def delimited(items, character='|'):\n    \"\"\"Returns a character delimited version of the provided list as a Python string\"\"\"\n    return '|'.join(items) if type(items) in (list, tuple, set) else items", "code_tokens": "def delimited ( items , character = '|' ) : return '|' . join ( items ) if type ( items ) in ( list , tuple , set ) else items", "docstring_tokens": "Returns a character delimited version of the provided list as a Python string", "label": 1}, {"idx": "cosqa-train-10859", "doc": "python forcible close socket before opening", "code": "def close(self):\n    \"\"\"Send a close message to the external process and join it.\"\"\"\n    try:\n      self._conn.send((self._CLOSE, None))\n      self._conn.close()\n    except IOError:\n      # The connection was already closed.\n      pass\n    self._process.join()", "code_tokens": "def close ( self ) : try : self . _conn . send ( ( self . _CLOSE , None ) ) self . _conn . close ( ) except IOError : # The connection was already closed. pass self . _process . join ( )", "docstring_tokens": "Send a close message to the external process and join it .", "label": 1}, {"idx": "cosqa-train-10860", "doc": "connect to python ftp server", "code": "def connect(host, port, username, password):\n        \"\"\"Connect and login to an FTP server and return ftplib.FTP object.\"\"\"\n        # Instantiate ftplib client\n        session = ftplib.FTP()\n\n        # Connect to host without auth\n        session.connect(host, port)\n\n        # Authenticate connection\n        session.login(username, password)\n        return session", "code_tokens": "def connect ( host , port , username , password ) : # Instantiate ftplib client session = ftplib . FTP ( ) # Connect to host without auth session . connect ( host , port ) # Authenticate connection session . login ( username , password ) return session", "docstring_tokens": "Connect and login to an FTP server and return ftplib . FTP object .", "label": 1}, {"idx": "cosqa-train-10861", "doc": "python format center padding", "code": "def _pad(self, text):\n        \"\"\"Pad the text.\"\"\"\n        top_bottom = (\"\\n\" * self._padding) + \" \"\n        right_left = \" \" * self._padding * self.PAD_WIDTH\n        return top_bottom + right_left + text + right_left + top_bottom", "code_tokens": "def _pad ( self , text ) : top_bottom = ( \"\\n\" * self . _padding ) + \" \" right_left = \" \" * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom", "docstring_tokens": "Pad the text .", "label": 1}, {"idx": "cosqa-train-10862", "doc": "connecting to ftp server python", "code": "def connect(host, port, username, password):\n        \"\"\"Connect and login to an FTP server and return ftplib.FTP object.\"\"\"\n        # Instantiate ftplib client\n        session = ftplib.FTP()\n\n        # Connect to host without auth\n        session.connect(host, port)\n\n        # Authenticate connection\n        session.login(username, password)\n        return session", "code_tokens": "def connect ( host , port , username , password ) : # Instantiate ftplib client session = ftplib . FTP ( ) # Connect to host without auth session . connect ( host , port ) # Authenticate connection session . login ( username , password ) return session", "docstring_tokens": "Connect and login to an FTP server and return ftplib . FTP object .", "label": 1}, {"idx": "cosqa-train-10863", "doc": "python format compute length", "code": "def __len__(self):\n        \"\"\" This will equal 124 for the V1 database. \"\"\"\n        length = 0\n        for typ, siz, _ in self.format:\n            length += siz\n        return length", "code_tokens": "def __len__ ( self ) : length = 0 for typ , siz , _ in self . format : length += siz return length", "docstring_tokens": "This will equal 124 for the V1 database .", "label": 1}, {"idx": "cosqa-train-10864", "doc": "constrained delaunay triangulation python", "code": "def computeDelaunayTriangulation(points):\n    \"\"\" Takes a list of point objects (which must have x and y fields).\n        Returns a list of 3-tuples: the indices of the points that form a\n        Delaunay triangle.\n    \"\"\"\n    siteList = SiteList(points)\n    context  = Context()\n    context.triangulate = True\n    voronoi(siteList,context)\n    return context.triangles", "code_tokens": "def computeDelaunayTriangulation ( points ) : siteList = SiteList ( points ) context = Context ( ) context . triangulate = True voronoi ( siteList , context ) return context . triangles", "docstring_tokens": "Takes a list of point objects ( which must have x and y fields ) . Returns a list of 3 - tuples : the indices of the points that form a Delaunay triangle .", "label": 1}, {"idx": "cosqa-train-10865", "doc": "python format datetime objects as strings", "code": "def serialize(self, value):\n        \"\"\"Takes a datetime object and returns a string\"\"\"\n        if isinstance(value, str):\n            return value\n        return value.strftime(DATETIME_FORMAT)", "code_tokens": "def serialize ( self , value ) : if isinstance ( value , str ) : return value return value . strftime ( DATETIME_FORMAT )", "docstring_tokens": "Takes a datetime object and returns a string", "label": 1}, {"idx": "cosqa-train-10866", "doc": "count he number of calls of function in python", "code": "def wrap_count(method):\n    \"\"\"\n    Returns number of wraps around given method.\n    \"\"\"\n    number = 0\n    while hasattr(method, '__aspects_orig'):\n        number += 1\n        method = method.__aspects_orig\n    return number", "code_tokens": "def wrap_count ( method ) : number = 0 while hasattr ( method , '__aspects_orig' ) : number += 1 method = method . __aspects_orig return number", "docstring_tokens": "Returns number of wraps around given method .", "label": 1}, {"idx": "cosqa-train-10867", "doc": "python format round 2 decimal placesexample", "code": "def _saferound(value, decimal_places):\n    \"\"\"\n    Rounds a float value off to the desired precision\n    \"\"\"\n    try:\n        f = float(value)\n    except ValueError:\n        return ''\n    format = '%%.%df' % decimal_places\n    return format % f", "code_tokens": "def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f", "docstring_tokens": "Rounds a float value off to the desired precision", "label": 0}, {"idx": "cosqa-train-10868", "doc": "count leading whitespace in python", "code": "def GetIndentLevel(line):\n  \"\"\"Return the number of leading spaces in line.\n\n  Args:\n    line: A string to check.\n\n  Returns:\n    An integer count of leading spaces, possibly zero.\n  \"\"\"\n  indent = Match(r'^( *)\\S', line)\n  if indent:\n    return len(indent.group(1))\n  else:\n    return 0", "code_tokens": "def GetIndentLevel ( line ) : indent = Match ( r'^( *)\\S' , line ) if indent : return len ( indent . group ( 1 ) ) else : return 0", "docstring_tokens": "Return the number of leading spaces in line .", "label": 1}, {"idx": "cosqa-train-10869", "doc": "python format width in data", "code": "def fmt_sz(intval):\n    \"\"\" Format a byte sized value.\n    \"\"\"\n    try:\n        return fmt.human_size(intval)\n    except (ValueError, TypeError):\n        return \"N/A\".rjust(len(fmt.human_size(0)))", "code_tokens": "def fmt_sz ( intval ) : try : return fmt . human_size ( intval ) except ( ValueError , TypeError ) : return \"N/A\" . rjust ( len ( fmt . human_size ( 0 ) ) )", "docstring_tokens": "Format a byte sized value .", "label": 1}, {"idx": "cosqa-train-10870", "doc": "count most common element in array python", "code": "def _most_common(iterable):\n    \"\"\"Returns the most common element in `iterable`.\"\"\"\n    data = Counter(iterable)\n    return max(data, key=data.__getitem__)", "code_tokens": "def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )", "docstring_tokens": "Returns the most common element in iterable .", "label": 1}, {"idx": "cosqa-train-10871", "doc": "python from csv file to printed report", "code": "def csvpretty(csvfile: csvfile=sys.stdin):\n    \"\"\" Pretty print a CSV file. \"\"\"\n    shellish.tabulate(csv.reader(csvfile))", "code_tokens": "def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )", "docstring_tokens": "Pretty print a CSV file .", "label": 1}, {"idx": "cosqa-train-10872", "doc": "count null nan values in python", "code": "def count(data, axis=None):\n    \"\"\"Count the number of non-NA in this array along the given axis or axes\n    \"\"\"\n    return np.sum(np.logical_not(isnull(data)), axis=axis)", "code_tokens": "def count ( data , axis = None ) : return np . sum ( np . logical_not ( isnull ( data ) ) , axis = axis )", "docstring_tokens": "Count the number of non - NA in this array along the given axis or axes", "label": 1}, {"idx": "cosqa-train-10873", "doc": "python frombytes not enough image data", "code": "def from_bytes(cls, b):\n\t\t\"\"\"Create :class:`PNG` from raw bytes.\n\t\t\n\t\t:arg bytes b: The raw bytes of the PNG file.\n\t\t:rtype: :class:`PNG`\n\t\t\"\"\"\n\t\tim = cls()\n\t\tim.chunks = list(parse_chunks(b))\n\t\tim.init()\n\t\treturn im", "code_tokens": "def from_bytes ( cls , b ) : im = cls ( ) im . chunks = list ( parse_chunks ( b ) ) im . init ( ) return im", "docstring_tokens": "Create : class : PNG from raw bytes . : arg bytes b : The raw bytes of the PNG file . : rtype : : class : PNG", "label": 1}, {"idx": "cosqa-train-10874", "doc": "count words in a sentance python", "code": "def count(lines):\n  \"\"\" Counts the word frequences in a list of sentences.\n\n  Note:\n    This is a helper function for parallel execution of `Vocabulary.from_text`\n    method.\n  \"\"\"\n  words = [w for l in lines for w in l.strip().split()]\n  return Counter(words)", "code_tokens": "def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )", "docstring_tokens": "Counts the word frequences in a list of sentences .", "label": 1}, {"idx": "cosqa-train-10875", "doc": "python fseek go to end of file", "code": "def align_file_position(f, size):\n    \"\"\" Align the position in the file to the next block of specified size \"\"\"\n    align = (size - 1) - (f.tell() % size)\n    f.seek(align, 1)", "code_tokens": "def align_file_position ( f , size ) : align = ( size - 1 ) - ( f . tell ( ) % size ) f . seek ( align , 1 )", "docstring_tokens": "Align the position in the file to the next block of specified size", "label": 0}, {"idx": "cosqa-train-10876", "doc": "counting bounding box in python", "code": "def get_area(self):\n        \"\"\"Calculate area of bounding box.\"\"\"\n        return (self.p2.x-self.p1.x)*(self.p2.y-self.p1.y)", "code_tokens": "def get_area ( self ) : return ( self . p2 . x - self . p1 . x ) * ( self . p2 . y - self . p1 . y )", "docstring_tokens": "Calculate area of bounding box .", "label": 1}, {"idx": "cosqa-train-10877", "doc": "python ftp server access", "code": "def connect(host, port, username, password):\n        \"\"\"Connect and login to an FTP server and return ftplib.FTP object.\"\"\"\n        # Instantiate ftplib client\n        session = ftplib.FTP()\n\n        # Connect to host without auth\n        session.connect(host, port)\n\n        # Authenticate connection\n        session.login(username, password)\n        return session", "code_tokens": "def connect ( host , port , username , password ) : # Instantiate ftplib client session = ftplib . FTP ( ) # Connect to host without auth session . connect ( host , port ) # Authenticate connection session . login ( username , password ) return session", "docstring_tokens": "Connect and login to an FTP server and return ftplib . FTP object .", "label": 1}, {"idx": "cosqa-train-10878", "doc": "cpython benchmark against java", "code": "def test_python_java_rt():\n    \"\"\" Run Python test cases against Java runtime classes. \"\"\"\n    sub_env = {'PYTHONPATH': _build_dir()}\n\n    log.info('Executing Python unit tests (against Java runtime classes)...')\n    return jpyutil._execute_python_scripts(python_java_rt_tests,\n                                           env=sub_env)", "code_tokens": "def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )", "docstring_tokens": "Run Python test cases against Java runtime classes .", "label": 1}, {"idx": "cosqa-train-10879", "doc": "python function caller self", "code": "def __call__(self, func, *args, **kwargs):\n        \"\"\"Shorcut for self.run.\"\"\"\n        return self.run(func, *args, **kwargs)", "code_tokens": "def __call__ ( self , func , * args , * * kwargs ) : return self . run ( func , * args , * * kwargs )", "docstring_tokens": "Shorcut for self . run .", "label": 1}, {"idx": "cosqa-train-10880", "doc": "create a bucket with python boto", "code": "def touch():\n    \"\"\"Create new bucket.\"\"\"\n    from .models import Bucket\n    bucket = Bucket.create()\n    db.session.commit()\n    click.secho(str(bucket), fg='green')", "code_tokens": "def touch ( ) : from . models import Bucket bucket = Bucket . create ( ) db . session . commit ( ) click . secho ( str ( bucket ) , fg = 'green' )", "docstring_tokens": "Create new bucket .", "label": 1}, {"idx": "cosqa-train-10881", "doc": "python function compare length of 2 strings", "code": "def count_string_diff(a,b):\n    \"\"\"Return the number of characters in two strings that don't exactly match\"\"\"\n    shortest = min(len(a), len(b))\n    return sum(a[i] != b[i] for i in range(shortest))", "code_tokens": "def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )", "docstring_tokens": "Return the number of characters in two strings that don t exactly match", "label": 1}, {"idx": "cosqa-train-10882", "doc": "create a dict for a string python", "code": "def list_string_to_dict(string):\n    \"\"\"Inputs ``['a', 'b', 'c']``, returns ``{'a': 0, 'b': 1, 'c': 2}``.\"\"\"\n    dictionary = {}\n    for idx, c in enumerate(string):\n        dictionary.update({c: idx})\n    return dictionary", "code_tokens": "def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary", "docstring_tokens": "Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } .", "label": 1}, {"idx": "cosqa-train-10883", "doc": "python function mutliple return print", "code": "def print(*a):\n    \"\"\" print just one that returns what you give it instead of None \"\"\"\n    try:\n        _print(*a)\n        return a[0] if len(a) == 1 else a\n    except:\n        _print(*a)", "code_tokens": "def print ( * a ) : try : _print ( * a ) return a [ 0 ] if len ( a ) == 1 else a except : _print ( * a )", "docstring_tokens": "print just one that returns what you give it instead of None", "label": 1}, {"idx": "cosqa-train-10884", "doc": "create a dictionary based on unique values in python", "code": "def _init_unique_sets(self):\n        \"\"\"Initialise sets used for uniqueness checking.\"\"\"\n\n        ks = dict()\n        for t in self._unique_checks:\n            key = t[0]\n            ks[key] = set() # empty set\n        return ks", "code_tokens": "def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks", "docstring_tokens": "Initialise sets used for uniqueness checking .", "label": 1}, {"idx": "cosqa-train-10885", "doc": "python function never invoke", "code": "def _callable_once(func):\n    \"\"\" Returns a function that is only callable once; any other call will do nothing \"\"\"\n\n    def once(*args, **kwargs):\n        if not once.called:\n            once.called = True\n            return func(*args, **kwargs)\n\n    once.called = False\n    return once", "code_tokens": "def _callable_once ( func ) : def once ( * args , * * kwargs ) : if not once . called : once . called = True return func ( * args , * * kwargs ) once . called = False return once", "docstring_tokens": "Returns a function that is only callable once ; any other call will do nothing", "label": 1}, {"idx": "cosqa-train-10886", "doc": "create a function to generate random letters in python", "code": "def random_letters(n):\n    \"\"\"\n    Generate a random string from a-zA-Z\n    :param n: length of the string\n    :return: the random string\n    \"\"\"\n    return ''.join(random.SystemRandom().choice(string.ascii_letters) for _ in range(n))", "code_tokens": "def random_letters ( n ) : return '' . join ( random . SystemRandom ( ) . choice ( string . ascii_letters ) for _ in range ( n ) )", "docstring_tokens": "Generate a random string from a - zA - Z : param n : length of the string : return : the random string", "label": 1}, {"idx": "cosqa-train-10887", "doc": "python function paramter flag", "code": "def _iterable_to_varargs_method(func):\n    \"\"\"decorator to convert a method taking a iterable to a *args one\"\"\"\n    def wrapped(self, *args, **kwargs):\n        return func(self, args, **kwargs)\n    return wrapped", "code_tokens": "def _iterable_to_varargs_method ( func ) : def wrapped ( self , * args , * * kwargs ) : return func ( self , args , * * kwargs ) return wrapped", "docstring_tokens": "decorator to convert a method taking a iterable to a * args one", "label": 0}, {"idx": "cosqa-train-10888", "doc": "create a legend just for definitions in python", "code": "def finish_plot():\n    \"\"\"Helper for plotting.\"\"\"\n    plt.legend()\n    plt.grid(color='0.7')\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.show()", "code_tokens": "def finish_plot ( ) : plt . legend ( ) plt . grid ( color = '0.7' ) plt . xlabel ( 'x' ) plt . ylabel ( 'y' ) plt . show ( )", "docstring_tokens": "Helper for plotting .", "label": 1}, {"idx": "cosqa-train-10889", "doc": "python function to calculate month based on date", "code": "def calculate_month(birth_date):\n    \"\"\"\n    Calculates and returns a month number basing on PESEL standard.\n    \"\"\"\n    year = int(birth_date.strftime('%Y'))\n    month = int(birth_date.strftime('%m')) + ((int(year / 100) - 14) % 5) * 20\n\n    return month", "code_tokens": "def calculate_month ( birth_date ) : year = int ( birth_date . strftime ( '%Y' ) ) month = int ( birth_date . strftime ( '%m' ) ) + ( ( int ( year / 100 ) - 14 ) % 5 ) * 20 return month", "docstring_tokens": "Calculates and returns a month number basing on PESEL standard .", "label": 1}, {"idx": "cosqa-train-10890", "doc": "create a yaml document in python", "code": "def _dump_spec(spec):\n    \"\"\"Dump bel specification dictionary using YAML\n\n    Formats this with an extra indentation for lists to make it easier to\n    use cold folding on the YAML version of the spec dictionary.\n    \"\"\"\n    with open(\"spec.yaml\", \"w\") as f:\n        yaml.dump(spec, f, Dumper=MyDumper, default_flow_style=False)", "code_tokens": "def _dump_spec ( spec ) : with open ( \"spec.yaml\" , \"w\" ) as f : yaml . dump ( spec , f , Dumper = MyDumper , default_flow_style = False )", "docstring_tokens": "Dump bel specification dictionary using YAML", "label": 1}, {"idx": "cosqa-train-10891", "doc": "python function to change a sentence to a list of words", "code": "def sent2features(sentence, template):\n    \"\"\" extract features in a sentence\n\n    :type sentence: list of token, each token is a list of tag\n    \"\"\"\n    return [word2features(sentence, i, template) for i in range(len(sentence))]", "code_tokens": "def sent2features ( sentence , template ) : return [ word2features ( sentence , i , template ) for i in range ( len ( sentence ) ) ]", "docstring_tokens": "extract features in a sentence", "label": 1}, {"idx": "cosqa-train-10892", "doc": "create accuracy test python", "code": "def AddAccuracy(model, softmax, label):\n    \"\"\"Adds an accuracy op to the model\"\"\"\n    accuracy = brew.accuracy(model, [softmax, label], \"accuracy\")\n    return accuracy", "code_tokens": "def AddAccuracy ( model , softmax , label ) : accuracy = brew . accuracy ( model , [ softmax , label ] , \"accuracy\" ) return accuracy", "docstring_tokens": "Adds an accuracy op to the model", "label": 1}, {"idx": "cosqa-train-10893", "doc": "python function to get it owner", "code": "def get_selection_owner(self, selection):\n        \"\"\"Return the window that owns selection (an atom), or X.NONE if\n        there is no owner for the selection. Can raise BadAtom.\"\"\"\n        r = request.GetSelectionOwner(display = self.display,\n                                      selection = selection)\n        return r.owner", "code_tokens": "def get_selection_owner ( self , selection ) : r = request . GetSelectionOwner ( display = self . display , selection = selection ) return r . owner", "docstring_tokens": "Return the window that owns selection ( an atom ) or X . NONE if there is no owner for the selection . Can raise BadAtom .", "label": 1}, {"idx": "cosqa-train-10894", "doc": "create code in python that reads pdf", "code": "def _single_page_pdf(page):\n    \"\"\"Construct a single page PDF from the provided page in memory\"\"\"\n    pdf = Pdf.new()\n    pdf.pages.append(page)\n    bio = BytesIO()\n    pdf.save(bio)\n    bio.seek(0)\n    return bio.read()", "code_tokens": "def _single_page_pdf ( page ) : pdf = Pdf . new ( ) pdf . pages . append ( page ) bio = BytesIO ( ) pdf . save ( bio ) bio . seek ( 0 ) return bio . read ( )", "docstring_tokens": "Construct a single page PDF from the provided page in memory", "label": 1}, {"idx": "cosqa-train-10895", "doc": "python function to toggle gpio pin", "code": "def setup(self, pin, mode, pull_up_down=PUD_OFF):\n        \"\"\"Set the input or output mode for a specified pin.  Mode should be\n        either OUTPUT or INPUT.\n        \"\"\"\n        self.rpi_gpio.setup(pin, self._dir_mapping[mode],\n                            pull_up_down=self._pud_mapping[pull_up_down])", "code_tokens": "def setup ( self , pin , mode , pull_up_down = PUD_OFF ) : self . rpi_gpio . setup ( pin , self . _dir_mapping [ mode ] , pull_up_down = self . _pud_mapping [ pull_up_down ] )", "docstring_tokens": "Set the input or output mode for a specified pin . Mode should be either OUTPUT or INPUT .", "label": 1}, {"idx": "cosqa-train-10896", "doc": "create distance grid on map python", "code": "def direct2dDistance(self, point):\n        \"\"\"consider the distance between two mapPoints, ignoring all terrain, pathing issues\"\"\"\n        if not isinstance(point, MapPoint): return 0.0\n        return  ((self.x-point.x)**2 + (self.y-point.y)**2)**(0.5) # simple distance formula", "code_tokens": "def direct2dDistance ( self , point ) : if not isinstance ( point , MapPoint ) : return 0.0 return ( ( self . x - point . x ) ** 2 + ( self . y - point . y ) ** 2 ) ** ( 0.5 ) # simple distance formula", "docstring_tokens": "consider the distance between two mapPoints ignoring all terrain pathing issues", "label": 1}, {"idx": "cosqa-train-10897", "doc": "python garbage collection call", "code": "def cleanup_storage(*args):\n    \"\"\"Clean up processes after SIGTERM or SIGINT is received.\"\"\"\n    ShardedClusters().cleanup()\n    ReplicaSets().cleanup()\n    Servers().cleanup()\n    sys.exit(0)", "code_tokens": "def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )", "docstring_tokens": "Clean up processes after SIGTERM or SIGINT is received .", "label": 1}, {"idx": "cosqa-train-10898", "doc": "create inclusive range in python", "code": "def LinSpace(start, stop, num):\n    \"\"\"\n    Linspace op.\n    \"\"\"\n    return np.linspace(start, stop, num=num, dtype=np.float32),", "code_tokens": "def LinSpace ( start , stop , num ) : return np . linspace ( start , stop , num = num , dtype = np . float32 ) ,", "docstring_tokens": "Linspace op .", "label": 1}, {"idx": "cosqa-train-10899", "doc": "python garbage collection slow", "code": "def cleanup_storage(*args):\n    \"\"\"Clean up processes after SIGTERM or SIGINT is received.\"\"\"\n    ShardedClusters().cleanup()\n    ReplicaSets().cleanup()\n    Servers().cleanup()\n    sys.exit(0)", "code_tokens": "def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )", "docstring_tokens": "Clean up processes after SIGTERM or SIGINT is received .", "label": 0}, {"idx": "cosqa-train-10900", "doc": "create property file for python", "code": "def write_property(fh, key, value):\n  \"\"\"\n    Write a single property to the file in Java properties format.\n\n    :param fh: a writable file-like object\n    :param key: the key to write\n    :param value: the value to write\n  \"\"\"\n  if key is COMMENT:\n    write_comment(fh, value)\n    return\n\n  _require_string(key, 'keys')\n  _require_string(value, 'values')\n\n  fh.write(_escape_key(key))\n  fh.write(b'=')\n  fh.write(_escape_value(value))\n  fh.write(b'\\n')", "code_tokens": "def write_property ( fh , key , value ) : if key is COMMENT : write_comment ( fh , value ) return _require_string ( key , 'keys' ) _require_string ( value , 'values' ) fh . write ( _escape_key ( key ) ) fh . write ( b'=' ) fh . write ( _escape_value ( value ) ) fh . write ( b'\\n' )", "docstring_tokens": "Write a single property to the file in Java properties format .", "label": 1}, {"idx": "cosqa-train-10901", "doc": "python gaussian distribution pdf", "code": "def EvalGaussianPdf(x, mu, sigma):\n    \"\"\"Computes the unnormalized PDF of the normal distribution.\n\n    x: value\n    mu: mean\n    sigma: standard deviation\n    \n    returns: float probability density\n    \"\"\"\n    return scipy.stats.norm.pdf(x, mu, sigma)", "code_tokens": "def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )", "docstring_tokens": "Computes the unnormalized PDF of the normal distribution .", "label": 1}, {"idx": "cosqa-train-10902", "doc": "create ruler with lines in python", "code": "def ruler_line(self, widths, linetype='-'):\n        \"\"\"Generates a ruler line for separating rows from each other\"\"\"\n        cells = []\n        for w in widths:\n            cells.append(linetype * (w+2))\n        return '+' + '+'.join(cells) + '+'", "code_tokens": "def ruler_line ( self , widths , linetype = '-' ) : cells = [ ] for w in widths : cells . append ( linetype * ( w + 2 ) ) return '+' + '+' . join ( cells ) + '+'", "docstring_tokens": "Generates a ruler line for separating rows from each other", "label": 1}, {"idx": "cosqa-train-10903", "doc": "python gaussian filter numpy array", "code": "def smooth_gaussian(image, sigma=1):\n    \"\"\"Returns Gaussian smoothed image.\n\n    :param image: numpy array or :class:`jicimagelib.image.Image`\n    :param sigma: standard deviation\n    :returns: :class:`jicimagelib.image.Image`\n    \"\"\"\n    return scipy.ndimage.filters.gaussian_filter(image, sigma=sigma, mode=\"nearest\")", "code_tokens": "def smooth_gaussian ( image , sigma = 1 ) : return scipy . ndimage . filters . gaussian_filter ( image , sigma = sigma , mode = \"nearest\" )", "docstring_tokens": "Returns Gaussian smoothed image .", "label": 1}, {"idx": "cosqa-train-10904", "doc": "crop image out of background python", "code": "def _trim(image):\n    \"\"\"Trim a PIL image and remove white space.\"\"\"\n    background = PIL.Image.new(image.mode, image.size, image.getpixel((0, 0)))\n    diff = PIL.ImageChops.difference(image, background)\n    diff = PIL.ImageChops.add(diff, diff, 2.0, -100)\n    bbox = diff.getbbox()\n    if bbox:\n        image = image.crop(bbox)\n    return image", "code_tokens": "def _trim ( image ) : background = PIL . Image . new ( image . mode , image . size , image . getpixel ( ( 0 , 0 ) ) ) diff = PIL . ImageChops . difference ( image , background ) diff = PIL . ImageChops . add ( diff , diff , 2.0 , - 100 ) bbox = diff . getbbox ( ) if bbox : image = image . crop ( bbox ) return image", "docstring_tokens": "Trim a PIL image and remove white space .", "label": 1}, {"idx": "cosqa-train-10905", "doc": "python gaussian fit image", "code": "def gauss_box_model(x, amplitude=1.0, mean=0.0, stddev=1.0, hpix=0.5):\n    \"\"\"Integrate a Gaussian profile.\"\"\"\n    z = (x - mean) / stddev\n    z2 = z + hpix / stddev\n    z1 = z - hpix / stddev\n    return amplitude * (norm.cdf(z2) - norm.cdf(z1))", "code_tokens": "def gauss_box_model ( x , amplitude = 1.0 , mean = 0.0 , stddev = 1.0 , hpix = 0.5 ) : z = ( x - mean ) / stddev z2 = z + hpix / stddev z1 = z - hpix / stddev return amplitude * ( norm . cdf ( z2 ) - norm . cdf ( z1 ) )", "docstring_tokens": "Integrate a Gaussian profile .", "label": 0}, {"idx": "cosqa-train-10906", "doc": "cross validation python without sklearn", "code": "def check_cv(self, y):\n        \"\"\"Resolve which cross validation strategy is used.\"\"\"\n        y_arr = None\n        if self.stratified:\n            # Try to convert y to numpy for sklearn's check_cv; if conversion\n            # doesn't work, still try.\n            try:\n                y_arr = to_numpy(y)\n            except (AttributeError, TypeError):\n                y_arr = y\n\n        if self._is_float(self.cv):\n            return self._check_cv_float()\n        return self._check_cv_non_float(y_arr)", "code_tokens": "def check_cv ( self , y ) : y_arr = None if self . stratified : # Try to convert y to numpy for sklearn's check_cv; if conversion # doesn't work, still try. try : y_arr = to_numpy ( y ) except ( AttributeError , TypeError ) : y_arr = y if self . _is_float ( self . cv ) : return self . _check_cv_float ( ) return self . _check_cv_non_float ( y_arr )", "docstring_tokens": "Resolve which cross validation strategy is used .", "label": 1}, {"idx": "cosqa-train-10907", "doc": "python gaussian image filter", "code": "def smooth_gaussian(image, sigma=1):\n    \"\"\"Returns Gaussian smoothed image.\n\n    :param image: numpy array or :class:`jicimagelib.image.Image`\n    :param sigma: standard deviation\n    :returns: :class:`jicimagelib.image.Image`\n    \"\"\"\n    return scipy.ndimage.filters.gaussian_filter(image, sigma=sigma, mode=\"nearest\")", "code_tokens": "def smooth_gaussian ( image , sigma = 1 ) : return scipy . ndimage . filters . gaussian_filter ( image , sigma = sigma , mode = \"nearest\" )", "docstring_tokens": "Returns Gaussian smoothed image .", "label": 1}, {"idx": "cosqa-train-10908", "doc": "cumsum on a list in python", "code": "def cumsum(inlist):\n    \"\"\"\nReturns a list consisting of the cumulative sum of the items in the\npassed list.\n\nUsage:   lcumsum(inlist)\n\"\"\"\n    newlist = copy.deepcopy(inlist)\n    for i in range(1, len(newlist)):\n        newlist[i] = newlist[i] + newlist[i - 1]\n    return newlist", "code_tokens": "def cumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist", "docstring_tokens": "Returns a list consisting of the cumulative sum of the items in the passed list .", "label": 1}, {"idx": "cosqa-train-10909", "doc": "python generate a covariance matrix given pairwise correlations", "code": "def cov_to_correlation(cov):\n    \"\"\"Compute the correlation matrix given the covariance matrix.\n\n    Parameters\n    ----------\n    cov : `~numpy.ndarray`\n        N x N matrix of covariances among N parameters.\n\n    Returns\n    -------\n    corr : `~numpy.ndarray`\n        N x N matrix of correlations among N parameters.\n    \"\"\"\n    err = np.sqrt(np.diag(cov))\n    errinv = np.ones_like(err) * np.nan\n    m = np.isfinite(err) & (err != 0)\n    errinv[m] = 1. / err[m]\n    corr = np.array(cov)\n    return corr * np.outer(errinv, errinv)", "code_tokens": "def cov_to_correlation ( cov ) : err = np . sqrt ( np . diag ( cov ) ) errinv = np . ones_like ( err ) * np . nan m = np . isfinite ( err ) & ( err != 0 ) errinv [ m ] = 1. / err [ m ] corr = np . array ( cov ) return corr * np . outer ( errinv , errinv )", "docstring_tokens": "Compute the correlation matrix given the covariance matrix .", "label": 1}, {"idx": "cosqa-train-10910", "doc": "curly braces in python format string", "code": "def string_format_func(s):\n\t\"\"\"\n\tFunction used internally to format string data for output to XML.\n\tEscapes back-slashes and quotes, and wraps the resulting string in\n\tquotes.\n\t\"\"\"\n\treturn u\"\\\"%s\\\"\" % unicode(s).replace(u\"\\\\\", u\"\\\\\\\\\").replace(u\"\\\"\", u\"\\\\\\\"\")", "code_tokens": "def string_format_func ( s ) : return u\"\\\"%s\\\"\" % unicode ( s ) . replace ( u\"\\\\\" , u\"\\\\\\\\\" ) . replace ( u\"\\\"\" , u\"\\\\\\\"\" )", "docstring_tokens": "Function used internally to format string data for output to XML . Escapes back - slashes and quotes and wraps the resulting string in quotes .", "label": 0}, {"idx": "cosqa-train-10911", "doc": "python generate list of filenames in directory", "code": "def directory_files(path):\n    \"\"\"Yield directory file names.\"\"\"\n\n    for entry in os.scandir(path):\n        if not entry.name.startswith('.') and entry.is_file():\n            yield entry.name", "code_tokens": "def directory_files ( path ) : for entry in os . scandir ( path ) : if not entry . name . startswith ( '.' ) and entry . is_file ( ) : yield entry . name", "docstring_tokens": "Yield directory file names .", "label": 1}, {"idx": "cosqa-train-10912", "doc": "cv2 imread python try catch", "code": "def imdecode(image_path):\n    \"\"\"Return BGR image read by opencv\"\"\"\n    import os\n    assert os.path.exists(image_path), image_path + ' not found'\n    im = cv2.imread(image_path)\n    return im", "code_tokens": "def imdecode ( image_path ) : import os assert os . path . exists ( image_path ) , image_path + ' not found' im = cv2 . imread ( image_path ) return im", "docstring_tokens": "Return BGR image read by opencv", "label": 1}, {"idx": "cosqa-train-10913", "doc": "python generate pdf from pngs", "code": "def save_image(pdf_path, img_path, page_num):\n    \"\"\"\n\n    Creates images for a page of the input pdf document and saves it\n    at img_path.\n\n    :param pdf_path: path to pdf to create images for.\n    :param img_path: path where to save the images.\n    :param page_num: page number to create image from in the pdf file.\n    :return:\n    \"\"\"\n    pdf_img = Image(filename=\"{}[{}]\".format(pdf_path, page_num))\n    with pdf_img.convert(\"png\") as converted:\n        # Set white background.\n        converted.background_color = Color(\"white\")\n        converted.alpha_channel = \"remove\"\n        converted.save(filename=img_path)", "code_tokens": "def save_image ( pdf_path , img_path , page_num ) : pdf_img = Image ( filename = \"{}[{}]\" . format ( pdf_path , page_num ) ) with pdf_img . convert ( \"png\" ) as converted : # Set white background. converted . background_color = Color ( \"white\" ) converted . alpha_channel = \"remove\" converted . save ( filename = img_path )", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-10914", "doc": "data frame consist all element not in other data frame python", "code": "def intersect(self, other):\n        \"\"\" Return a new :class:`DataFrame` containing rows only in\n        both this frame and another frame.\n\n        This is equivalent to `INTERSECT` in SQL.\n        \"\"\"\n        return DataFrame(self._jdf.intersect(other._jdf), self.sql_ctx)", "code_tokens": "def intersect ( self , other ) : return DataFrame ( self . _jdf . intersect ( other . _jdf ) , self . sql_ctx )", "docstring_tokens": "Return a new : class : DataFrame containing rows only in both this frame and another frame .", "label": 1}, {"idx": "cosqa-train-10915", "doc": "python generate random integer with step interval", "code": "def random_int(self, min=0, max=9999, step=1):\n        \"\"\"\n        Returns a random integer between two values.\n\n        :param min: lower bound value (inclusive; default=0)\n        :param max: upper bound value (inclusive; default=9999)\n        :param step: range step (default=1)\n        :returns: random integer between min and max\n        \"\"\"\n        return self.generator.random.randrange(min, max + 1, step)", "code_tokens": "def random_int ( self , min = 0 , max = 9999 , step = 1 ) : return self . generator . random . randrange ( min , max + 1 , step )", "docstring_tokens": "Returns a random integer between two values .", "label": 1}, {"idx": "cosqa-train-10916", "doc": "data frame from dictionary, python", "code": "def to_dataframe(products):\n        \"\"\"Return the products from a query response as a Pandas DataFrame\n        with the values in their appropriate Python types.\n        \"\"\"\n        try:\n            import pandas as pd\n        except ImportError:\n            raise ImportError(\"to_dataframe requires the optional dependency Pandas.\")\n\n        return pd.DataFrame.from_dict(products, orient='index')", "code_tokens": "def to_dataframe ( products ) : try : import pandas as pd except ImportError : raise ImportError ( \"to_dataframe requires the optional dependency Pandas.\" ) return pd . DataFrame . from_dict ( products , orient = 'index' )", "docstring_tokens": "Return the products from a query response as a Pandas DataFrame with the values in their appropriate Python types .", "label": 1}, {"idx": "cosqa-train-10917", "doc": "python generate randoms strings", "code": "def generate_random_id(size=6, chars=string.ascii_uppercase + string.digits):\n    \"\"\"Generate random id numbers.\"\"\"\n    return \"\".join(random.choice(chars) for x in range(size))", "code_tokens": "def generate_random_id ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return \"\" . join ( random . choice ( chars ) for x in range ( size ) )", "docstring_tokens": "Generate random id numbers .", "label": 1}, {"idx": "cosqa-train-10918", "doc": "data frame from list in python", "code": "def to_dataframe(products):\n        \"\"\"Return the products from a query response as a Pandas DataFrame\n        with the values in their appropriate Python types.\n        \"\"\"\n        try:\n            import pandas as pd\n        except ImportError:\n            raise ImportError(\"to_dataframe requires the optional dependency Pandas.\")\n\n        return pd.DataFrame.from_dict(products, orient='index')", "code_tokens": "def to_dataframe ( products ) : try : import pandas as pd except ImportError : raise ImportError ( \"to_dataframe requires the optional dependency Pandas.\" ) return pd . DataFrame . from_dict ( products , orient = 'index' )", "docstring_tokens": "Return the products from a query response as a Pandas DataFrame with the values in their appropriate Python types .", "label": 1}, {"idx": "cosqa-train-10919", "doc": "python get a specific matrix column", "code": "def get_column(self, X, column):\n        \"\"\"Return a column of the given matrix.\n\n        Args:\n            X: `numpy.ndarray` or `pandas.DataFrame`.\n            column: `int` or `str`.\n\n        Returns:\n            np.ndarray: Selected column.\n        \"\"\"\n        if isinstance(X, pd.DataFrame):\n            return X[column].values\n\n        return X[:, column]", "code_tokens": "def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]", "docstring_tokens": "Return a column of the given matrix .", "label": 1}, {"idx": "cosqa-train-10920", "doc": "data frame string to date in python", "code": "def _parse(self, date_str, format='%Y-%m-%d'):\n        \"\"\"\n        helper function for parsing FRED date string into datetime\n        \"\"\"\n        rv = pd.to_datetime(date_str, format=format)\n        if hasattr(rv, 'to_pydatetime'):\n            rv = rv.to_pydatetime()\n        return rv", "code_tokens": "def _parse ( self , date_str , format = '%Y-%m-%d' ) : rv = pd . to_datetime ( date_str , format = format ) if hasattr ( rv , 'to_pydatetime' ) : rv = rv . to_pydatetime ( ) return rv", "docstring_tokens": "helper function for parsing FRED date string into datetime", "label": 0}, {"idx": "cosqa-train-10921", "doc": "python get all colors in image", "code": "def get_colors(img):\n    \"\"\"\n    Returns a list of all the image's colors.\n    \"\"\"\n    w, h = img.size\n    return [color[:3] for count, color in img.convert('RGB').getcolors(w * h)]", "code_tokens": "def get_colors ( img ) : w , h = img . size return [ color [ : 3 ] for count , color in img . convert ( 'RGB' ) . getcolors ( w * h ) ]", "docstring_tokens": "Returns a list of all the image s colors .", "label": 1}, {"idx": "cosqa-train-10922", "doc": "data frame to hdf5 in python", "code": "def save_hdf(self,filename,path=''):\n        \"\"\"Saves all relevant data to .h5 file; so state can be restored.\n        \"\"\"\n        self.dataframe.to_hdf(filename,'{}/df'.format(path))", "code_tokens": "def save_hdf ( self , filename , path = '' ) : self . dataframe . to_hdf ( filename , '{}/df' . format ( path ) )", "docstring_tokens": "Saves all relevant data to . h5 file ; so state can be restored .", "label": 1}, {"idx": "cosqa-train-10923", "doc": "python get all dates in a given month", "code": "def get_month_start_end_day():\n    \"\"\"\n    Get the month start date a nd end date\n    \"\"\"\n    t = date.today()\n    n = mdays[t.month]\n    return (date(t.year, t.month, 1), date(t.year, t.month, n))", "code_tokens": "def get_month_start_end_day ( ) : t = date . today ( ) n = mdays [ t . month ] return ( date ( t . year , t . month , 1 ) , date ( t . year , t . month , n ) )", "docstring_tokens": "Get the month start date a nd end date", "label": 0}, {"idx": "cosqa-train-10924", "doc": "data length for reshape python", "code": "def batchify(data, batch_size):\n    \"\"\"Reshape data into (num_example, batch_size)\"\"\"\n    nbatch = data.shape[0] // batch_size\n    data = data[:nbatch * batch_size]\n    data = data.reshape((batch_size, nbatch)).T\n    return data", "code_tokens": "def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data", "docstring_tokens": "Reshape data into ( num_example batch_size )", "label": 1}, {"idx": "cosqa-train-10925", "doc": "python get array for subset of image based on box", "code": "def bounding_box(img):\n    r\"\"\"\n    Return the bounding box incorporating all non-zero values in the image.\n    \n    Parameters\n    ----------\n    img : array_like\n        An array containing non-zero objects.\n        \n    Returns\n    -------\n    bbox : a list of slicer objects defining the bounding box\n    \"\"\"\n    locations = numpy.argwhere(img)\n    mins = locations.min(0)\n    maxs = locations.max(0) + 1\n    return [slice(x, y) for x, y in zip(mins, maxs)]", "code_tokens": "def bounding_box ( img ) : locations = numpy . argwhere ( img ) mins = locations . min ( 0 ) maxs = locations . max ( 0 ) + 1 return [ slice ( x , y ) for x , y in zip ( mins , maxs ) ]", "docstring_tokens": "r Return the bounding box incorporating all non - zero values in the image . Parameters ---------- img : array_like An array containing non - zero objects . Returns ------- bbox : a list of slicer objects defining the bounding box", "label": 1}, {"idx": "cosqa-train-10926", "doc": "date from string datetime python", "code": "def string_to_date(value):\n    \"\"\"\n    Return a Python date that corresponds to the specified string\n    representation.\n\n    @param value: string representation of a date.\n\n    @return: an instance ``datetime.datetime`` represented by the string.\n    \"\"\"\n    if isinstance(value, datetime.date):\n        return value\n\n    return dateutil.parser.parse(value).date()", "code_tokens": "def string_to_date ( value ) : if isinstance ( value , datetime . date ) : return value return dateutil . parser . parse ( value ) . date ( )", "docstring_tokens": "Return a Python date that corresponds to the specified string representation .", "label": 1}, {"idx": "cosqa-train-10927", "doc": "python get attribute dictionary from object", "code": "def dict_from_object(obj: object):\n    \"\"\"Convert a object into dictionary with all of its readable attributes.\"\"\"\n\n    # If object is a dict instance, no need to convert.\n    return (obj if isinstance(obj, dict)\n            else {attr: getattr(obj, attr)\n                  for attr in dir(obj) if not attr.startswith('_')})", "code_tokens": "def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )", "docstring_tokens": "Convert a object into dictionary with all of its readable attributes .", "label": 1}, {"idx": "cosqa-train-10928", "doc": "datetime datetime object with tzoffset python", "code": "def to_pydatetime(self):\n        \"\"\"\n        Converts datetimeoffset object into Python's datetime.datetime object\n        @return: time zone aware datetime.datetime\n        \"\"\"\n        dt = datetime.datetime.combine(self._date.to_pydate(), self._time.to_pytime())\n        from .tz import FixedOffsetTimezone\n        return dt.replace(tzinfo=_utc).astimezone(FixedOffsetTimezone(self._offset))", "code_tokens": "def to_pydatetime ( self ) : dt = datetime . datetime . combine ( self . _date . to_pydate ( ) , self . _time . to_pytime ( ) ) from . tz import FixedOffsetTimezone return dt . replace ( tzinfo = _utc ) . astimezone ( FixedOffsetTimezone ( self . _offset ) )", "docstring_tokens": "Converts datetimeoffset object into Python s datetime . datetime object", "label": 0}, {"idx": "cosqa-train-10929", "doc": "python get cofactor matrix", "code": "def getcoef(self):\n        \"\"\"Get final coefficient map array.\"\"\"\n\n        global mp_Z_Y1\n        return np.swapaxes(mp_Z_Y1, 0, self.xstep.cri.axisK+1)[0]", "code_tokens": "def getcoef ( self ) : global mp_Z_Y1 return np . swapaxes ( mp_Z_Y1 , 0 , self . xstep . cri . axisK + 1 ) [ 0 ]", "docstring_tokens": "Get final coefficient map array .", "label": 1}, {"idx": "cosqa-train-10930", "doc": "datetime python millisecond format", "code": "def ms_to_datetime(ms):\n    \"\"\"\n    Converts a millisecond accuracy timestamp to a datetime\n    \"\"\"\n    dt = datetime.datetime.utcfromtimestamp(ms / 1000)\n    return dt.replace(microsecond=(ms % 1000) * 1000).replace(tzinfo=pytz.utc)", "code_tokens": "def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )", "docstring_tokens": "Converts a millisecond accuracy timestamp to a datetime", "label": 1}, {"idx": "cosqa-train-10931", "doc": "python get current globals", "code": "def caller_locals():\n    \"\"\"Get the local variables in the caller's frame.\"\"\"\n    import inspect\n    frame = inspect.currentframe()\n    try:\n        return frame.f_back.f_back.f_locals\n    finally:\n        del frame", "code_tokens": "def caller_locals ( ) : import inspect frame = inspect . currentframe ( ) try : return frame . f_back . f_back . f_locals finally : del frame", "docstring_tokens": "Get the local variables in the caller s frame .", "label": 1}, {"idx": "cosqa-train-10932", "doc": "datetime to iso86301 string python", "code": "def isoformat(dt):\n    \"\"\"Return an ISO-8601 formatted string from the provided datetime object\"\"\"\n    if not isinstance(dt, datetime.datetime):\n        raise TypeError(\"Must provide datetime.datetime object to isoformat\")\n\n    if dt.tzinfo is None:\n        raise ValueError(\"naive datetime objects are not allowed beyond the library boundaries\")\n\n    return dt.isoformat().replace(\"+00:00\", \"Z\")", "code_tokens": "def isoformat ( dt ) : if not isinstance ( dt , datetime . datetime ) : raise TypeError ( \"Must provide datetime.datetime object to isoformat\" ) if dt . tzinfo is None : raise ValueError ( \"naive datetime objects are not allowed beyond the library boundaries\" ) return dt . isoformat ( ) . replace ( \"+00:00\" , \"Z\" )", "docstring_tokens": "Return an ISO - 8601 formatted string from the provided datetime object", "label": 1}, {"idx": "cosqa-train-10933", "doc": "python get date from file modifiede", "code": "def get_time(filename):\n\t\"\"\"\n\tGet the modified time for a file as a datetime instance\n\t\"\"\"\n\tts = os.stat(filename).st_mtime\n\treturn datetime.datetime.utcfromtimestamp(ts)", "code_tokens": "def get_time ( filename ) : ts = os . stat ( filename ) . st_mtime return datetime . datetime . utcfromtimestamp ( ts )", "docstring_tokens": "Get the modified time for a file as a datetime instance", "label": 1}, {"idx": "cosqa-train-10934", "doc": "datetime to utc time python", "code": "def datetime_local_to_utc(local):\n    \"\"\"\n    Simple function to convert naive :std:`datetime.datetime` object containing\n    local time to a naive :std:`datetime.datetime` object with UTC time.\n    \"\"\"\n    timestamp = time.mktime(local.timetuple())\n    return datetime.datetime.utcfromtimestamp(timestamp)", "code_tokens": "def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )", "docstring_tokens": "Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time .", "label": 1}, {"idx": "cosqa-train-10935", "doc": "python get dictionary keys with largest values", "code": "def find_largest_contig(contig_lengths_dict):\n    \"\"\"\n    Determine the largest contig for each strain\n    :param contig_lengths_dict: dictionary of strain name: reverse-sorted list of all contig lengths\n    :return: longest_contig_dict: dictionary of strain name: longest contig\n    \"\"\"\n    # Initialise the dictionary\n    longest_contig_dict = dict()\n    for file_name, contig_lengths in contig_lengths_dict.items():\n        # As the list is sorted in descending order, the largest contig is the first entry in the list\n        longest_contig_dict[file_name] = contig_lengths[0]\n    return longest_contig_dict", "code_tokens": "def find_largest_contig ( contig_lengths_dict ) : # Initialise the dictionary longest_contig_dict = dict ( ) for file_name , contig_lengths in contig_lengths_dict . items ( ) : # As the list is sorted in descending order, the largest contig is the first entry in the list longest_contig_dict [ file_name ] = contig_lengths [ 0 ] return longest_contig_dict", "docstring_tokens": "Determine the largest contig for each strain : param contig_lengths_dict : dictionary of strain name : reverse - sorted list of all contig lengths : return : longest_contig_dict : dictionary of strain name : longest contig", "label": 1}, {"idx": "cosqa-train-10936", "doc": "def and return python and feed into next function", "code": "def __next__(self, reward, ask_id, lbl):\n        \"\"\"For Python3 compatibility of generator.\"\"\"\n        return self.next(reward, ask_id, lbl)", "code_tokens": "def __next__ ( self , reward , ask_id , lbl ) : return self . next ( reward , ask_id , lbl )", "docstring_tokens": "For Python3 compatibility of generator .", "label": 1}, {"idx": "cosqa-train-10937", "doc": "python get dimensions of list", "code": "def get_dimension_array(array):\n    \"\"\"\n    Get dimension of an array getting the number of rows and the max num of\n    columns.\n    \"\"\"\n    if all(isinstance(el, list) for el in array):\n        result = [len(array), len(max([x for x in array], key=len,))]\n\n    # elif array and isinstance(array, list):\n    else:\n        result = [len(array), 1]\n\n    return result", "code_tokens": "def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result", "docstring_tokens": "Get dimension of an array getting the number of rows and the max num of columns .", "label": 1}, {"idx": "cosqa-train-10938", "doc": "default dict of default dicts python", "code": "def setDictDefaults (d, defaults):\n  \"\"\"Sets all defaults for the given dictionary to those contained in a\n  second defaults dictionary.  This convenience method calls:\n\n    d.setdefault(key, value)\n\n  for each key and value in the given defaults dictionary.\n  \"\"\"\n  for key, val in defaults.items():\n    d.setdefault(key, val)\n\n  return d", "code_tokens": "def setDictDefaults ( d , defaults ) : for key , val in defaults . items ( ) : d . setdefault ( key , val ) return d", "docstring_tokens": "Sets all defaults for the given dictionary to those contained in a second defaults dictionary . This convenience method calls :", "label": 1}, {"idx": "cosqa-train-10939", "doc": "python get field by name nil on missing", "code": "def get_field_by_name(self, name):\n        \"\"\"\n        the field member matching name, or None if no such field is found\n        \"\"\"\n\n        for f in self.fields:\n            if f.get_name() == name:\n                return f\n        return None", "code_tokens": "def get_field_by_name ( self , name ) : for f in self . fields : if f . get_name ( ) == name : return f return None", "docstring_tokens": "the field member matching name or None if no such field is found", "label": 1}, {"idx": "cosqa-train-10940", "doc": "defaultvalue for a boolean in python", "code": "def less_strict_bool(x):\n    \"\"\"Idempotent and None-safe version of strict_bool.\"\"\"\n    if x is None:\n        return False\n    elif x is True or x is False:\n        return x\n    else:\n        return strict_bool(x)", "code_tokens": "def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )", "docstring_tokens": "Idempotent and None - safe version of strict_bool .", "label": 1}, {"idx": "cosqa-train-10941", "doc": "python get file from remote linux", "code": "def get_remote_content(filepath):\n        \"\"\" A handy wrapper to get a remote file content \"\"\"\n        with hide('running'):\n            temp = BytesIO()\n            get(filepath, temp)\n            content = temp.getvalue().decode('utf-8')\n        return content.strip()", "code_tokens": "def get_remote_content ( filepath ) : with hide ( 'running' ) : temp = BytesIO ( ) get ( filepath , temp ) content = temp . getvalue ( ) . decode ( 'utf-8' ) return content . strip ( )", "docstring_tokens": "A handy wrapper to get a remote file content", "label": 1}, {"idx": "cosqa-train-10942", "doc": "define a function to checking data type in python", "code": "def isnumber(*args):\n    \"\"\"Checks if value is an integer, long integer or float.\n\n    NOTE: Treats booleans as numbers, where True=1 and False=0.\n    \"\"\"\n    return all(map(lambda c: isinstance(c, int) or isinstance(c, float), args))", "code_tokens": "def isnumber ( * args ) : return all ( map ( lambda c : isinstance ( c , int ) or isinstance ( c , float ) , args ) )", "docstring_tokens": "Checks if value is an integer long integer or float .", "label": 1}, {"idx": "cosqa-train-10943", "doc": "python get file parent folder name", "code": "def get_parent_folder_name(file_path):\n    \"\"\"Finds parent folder of file\n\n    :param file_path: path\n    :return: Name of folder container\n    \"\"\"\n    return os.path.split(os.path.split(os.path.abspath(file_path))[0])[-1]", "code_tokens": "def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]", "docstring_tokens": "Finds parent folder of file", "label": 1}, {"idx": "cosqa-train-10944", "doc": "define equality in python object", "code": "def __eq__(self, other):\n        \"\"\"Determine if two objects are equal.\"\"\"\n        return isinstance(other, self.__class__) \\\n            and self._freeze() == other._freeze()", "code_tokens": "def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) and self . _freeze ( ) == other . _freeze ( )", "docstring_tokens": "Determine if two objects are equal .", "label": 1}, {"idx": "cosqa-train-10945", "doc": "python get float from string", "code": "def energy_string_to_float( string ):\n    \"\"\"\n    Convert a string of a calculation energy, e.g. '-1.2345 eV' to a float.\n\n    Args:\n        string (str): The string to convert.\n  \n    Return\n        (float) \n    \"\"\"\n    energy_re = re.compile( \"(-?\\d+\\.\\d+)\" )\n    return float( energy_re.match( string ).group(0) )", "code_tokens": "def energy_string_to_float ( string ) : energy_re = re . compile ( \"(-?\\d+\\.\\d+)\" ) return float ( energy_re . match ( string ) . group ( 0 ) )", "docstring_tokens": "Convert a string of a calculation energy e . g . - 1 . 2345 eV to a float .", "label": 1}, {"idx": "cosqa-train-10946", "doc": "define function arg type and default values python", "code": "def get_default_args(func):\n    \"\"\"\n    returns a dictionary of arg_name:default_values for the input function\n    \"\"\"\n    args, varargs, keywords, defaults = getargspec_no_self(func)\n    return dict(zip(args[-len(defaults):], defaults))", "code_tokens": "def get_default_args ( func ) : args , varargs , keywords , defaults = getargspec_no_self ( func ) return dict ( zip ( args [ - len ( defaults ) : ] , defaults ) )", "docstring_tokens": "returns a dictionary of arg_name : default_values for the input function", "label": 1}, {"idx": "cosqa-train-10947", "doc": "python get hierarchy of parent for an instance", "code": "def root_parent(self, category=None):\n        \"\"\" Returns the topmost parent of the current category. \"\"\"\n        return next(filter(lambda c: c.is_root, self.hierarchy()))", "code_tokens": "def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )", "docstring_tokens": "Returns the topmost parent of the current category .", "label": 1}, {"idx": "cosqa-train-10948", "doc": "definition python nonetype to int", "code": "def test_value(self, value):\n        \"\"\"Test if value is an instance of int.\"\"\"\n        if not isinstance(value, int):\n            raise ValueError('expected int value: ' + str(type(value)))", "code_tokens": "def test_value ( self , value ) : if not isinstance ( value , int ) : raise ValueError ( 'expected int value: ' + str ( type ( value ) ) )", "docstring_tokens": "Test if value is an instance of int .", "label": 1}, {"idx": "cosqa-train-10949", "doc": "python get highest score", "code": "def _rank(self, ranking, n):\n    \"\"\" return the first n sentences with highest ranking \"\"\"\n    return nlargest(n, ranking, key=ranking.get)", "code_tokens": "def _rank ( self , ranking , n ) : return nlargest ( n , ranking , key = ranking . get )", "docstring_tokens": "return the first n sentences with highest ranking", "label": 1}, {"idx": "cosqa-train-10950", "doc": "delete image files in python", "code": "def delete(self, mutagen_file):\n        \"\"\"Remove all images from the file.\n        \"\"\"\n        for cover_tag in self.TAG_NAMES.values():\n            try:\n                del mutagen_file[cover_tag]\n            except KeyError:\n                pass", "code_tokens": "def delete ( self , mutagen_file ) : for cover_tag in self . TAG_NAMES . values ( ) : try : del mutagen_file [ cover_tag ] except KeyError : pass", "docstring_tokens": "Remove all images from the file .", "label": 1}, {"idx": "cosqa-train-10951", "doc": "python get image size from request", "code": "def get_image_dimension(self, url):\n        \"\"\"\n        Return a tuple that contains (width, height)\n        Pass in a url to an image and find out its size without loading the whole file\n        If the image wxh could not be found, the tuple will contain `None` values\n        \"\"\"\n        w_h = (None, None)\n        try:\n            if url.startswith('//'):\n                url = 'http:' + url\n            data = requests.get(url).content\n            im = Image.open(BytesIO(data))\n\n            w_h = im.size\n        except Exception:\n            logger.warning(\"Error getting image size {}\".format(url), exc_info=True)\n\n        return w_h", "code_tokens": "def get_image_dimension ( self , url ) : w_h = ( None , None ) try : if url . startswith ( '//' ) : url = 'http:' + url data = requests . get ( url ) . content im = Image . open ( BytesIO ( data ) ) w_h = im . size except Exception : logger . warning ( \"Error getting image size {}\" . format ( url ) , exc_info = True ) return w_h", "docstring_tokens": "Return a tuple that contains ( width height ) Pass in a url to an image and find out its size without loading the whole file If the image wxh could not be found the tuple will contain None values", "label": 1}, {"idx": "cosqa-train-10952", "doc": "delete index not working python", "code": "def delete_index(index):\n    \"\"\"Delete index entirely (removes all documents and mapping).\"\"\"\n    logger.info(\"Deleting search index: '%s'\", index)\n    client = get_client()\n    return client.indices.delete(index=index)", "code_tokens": "def delete_index ( index ) : logger . info ( \"Deleting search index: '%s'\" , index ) client = get_client ( ) return client . indices . delete ( index = index )", "docstring_tokens": "Delete index entirely ( removes all documents and mapping ) .", "label": 0}, {"idx": "cosqa-train-10953", "doc": "python get index for sorted array", "code": "def argsort_indices(a, axis=-1):\n    \"\"\"Like argsort, but returns an index suitable for sorting the\n    the original array even if that array is multidimensional\n    \"\"\"\n    a = np.asarray(a)\n    ind = list(np.ix_(*[np.arange(d) for d in a.shape]))\n    ind[axis] = a.argsort(axis)\n    return tuple(ind)", "code_tokens": "def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )", "docstring_tokens": "Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional", "label": 1}, {"idx": "cosqa-train-10954", "doc": "delete last e;ement from stack in python", "code": "def pop(self):\n        \"\"\"\n        return the last stack element and delete it from the list\n        \"\"\"\n        if not self.empty():\n            val = self.stack[-1]\n            del self.stack[-1]\n            return val", "code_tokens": "def pop ( self ) : if not self . empty ( ) : val = self . stack [ - 1 ] del self . stack [ - 1 ] return val", "docstring_tokens": "return the last stack element and delete it from the list", "label": 1}, {"idx": "cosqa-train-10955", "doc": "python get index of list values that equal", "code": "def equal(list1, list2):\n    \"\"\" takes flags returns indexes of True values \"\"\"\n    return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]", "code_tokens": "def equal ( list1 , list2 ) : return [ item1 == item2 for item1 , item2 in broadcast_zip ( list1 , list2 ) ]", "docstring_tokens": "takes flags returns indexes of True values", "label": 1}, {"idx": "cosqa-train-10956", "doc": "delete last value in array in python", "code": "def remove_last_entry(self):\n        \"\"\"Remove the last NoteContainer in the Bar.\"\"\"\n        self.current_beat -= 1.0 / self.bar[-1][1]\n        self.bar = self.bar[:-1]\n        return self.current_beat", "code_tokens": "def remove_last_entry ( self ) : self . current_beat -= 1.0 / self . bar [ - 1 ] [ 1 ] self . bar = self . bar [ : - 1 ] return self . current_beat", "docstring_tokens": "Remove the last NoteContainer in the Bar .", "label": 1}, {"idx": "cosqa-train-10957", "doc": "python get index of row", "code": "def translate_index_to_position(self, index):\n        \"\"\"\n        Given an index for the text, return the corresponding (row, col) tuple.\n        (0-based. Returns (0, 0) for index=0.)\n        \"\"\"\n        # Find start of this line.\n        row, row_index = self._find_line_start_index(index)\n        col = index - row_index\n\n        return row, col", "code_tokens": "def translate_index_to_position ( self , index ) : # Find start of this line. row , row_index = self . _find_line_start_index ( index ) col = index - row_index return row , col", "docstring_tokens": "Given an index for the text return the corresponding ( row col ) tuple . ( 0 - based . Returns ( 0 0 ) for index = 0 . )", "label": 1}, {"idx": "cosqa-train-10958", "doc": "delete object from s3 python", "code": "def remove_file_from_s3(awsclient, bucket, key):\n    \"\"\"Remove a file from an AWS S3 bucket.\n\n    :param awsclient:\n    :param bucket:\n    :param key:\n    :return:\n    \"\"\"\n    client_s3 = awsclient.get_client('s3')\n    response = client_s3.delete_object(Bucket=bucket, Key=key)", "code_tokens": "def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )", "docstring_tokens": "Remove a file from an AWS S3 bucket .", "label": 1}, {"idx": "cosqa-train-10959", "doc": "python get indices of element lambda condition", "code": "def get_inputs_from_cm(index, cm):\n    \"\"\"Return indices of inputs to the node with the given index.\"\"\"\n    return tuple(i for i in range(cm.shape[0]) if cm[i][index])", "code_tokens": "def get_inputs_from_cm ( index , cm ) : return tuple ( i for i in range ( cm . shape [ 0 ] ) if cm [ i ] [ index ] )", "docstring_tokens": "Return indices of inputs to the node with the given index .", "label": 1}, {"idx": "cosqa-train-10960", "doc": "deletefolder or file in python", "code": "def safe_rmtree(directory):\n  \"\"\"Delete a directory if it's present. If it's not present, no-op.\"\"\"\n  if os.path.exists(directory):\n    shutil.rmtree(directory, True)", "code_tokens": "def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )", "docstring_tokens": "Delete a directory if it s present . If it s not present no - op .", "label": 0}, {"idx": "cosqa-train-10961", "doc": "python get instance attribute by name", "code": "def get_property_by_name(pif, name):\n    \"\"\"Get a property by name\"\"\"\n    return next((x for x in pif.properties if x.name == name), None)", "code_tokens": "def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )", "docstring_tokens": "Get a property by name", "label": 1}, {"idx": "cosqa-train-10962", "doc": "deleting all objects in memory python", "code": "def detach_all(self):\n        \"\"\"\n        Detach from all tracked classes and objects.\n        Restore the original constructors and cleanse the tracking lists.\n        \"\"\"\n        self.detach_all_classes()\n        self.objects.clear()\n        self.index.clear()\n        self._keepalive[:] = []", "code_tokens": "def detach_all ( self ) : self . detach_all_classes ( ) self . objects . clear ( ) self . index . clear ( ) self . _keepalive [ : ] = [ ]", "docstring_tokens": "Detach from all tracked classes and objects . Restore the original constructors and cleanse the tracking lists .", "label": 1}, {"idx": "cosqa-train-10963", "doc": "python get last n of array", "code": "def tail(self, n=10):\n        \"\"\"\n        Get an SArray that contains the last n elements in the SArray.\n\n        Parameters\n        ----------\n        n : int\n            The number of elements to fetch\n\n        Returns\n        -------\n        out : SArray\n            A new SArray which contains the last n rows of the current SArray.\n        \"\"\"\n        with cython_context():\n            return SArray(_proxy=self.__proxy__.tail(n))", "code_tokens": "def tail ( self , n = 10 ) : with cython_context ( ) : return SArray ( _proxy = self . __proxy__ . tail ( n ) )", "docstring_tokens": "Get an SArray that contains the last n elements in the SArray .", "label": 1}, {"idx": "cosqa-train-10964", "doc": "deleting entire column whose header is empty in python", "code": "def drop_empty(rows):\n    \"\"\"Transpose the columns into rows, remove all of the rows that are empty after the first cell, then\n    transpose back. The result is that columns that have a header but no data in the body are removed, assuming\n    the header is the first row. \"\"\"\n    return zip(*[col for col in zip(*rows) if bool(filter(bool, col[1:]))])", "code_tokens": "def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )", "docstring_tokens": "Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row .", "label": 1}, {"idx": "cosqa-train-10965", "doc": "python get length of stream", "code": "def file_length(file_obj):\n    \"\"\"\n    Returns the length in bytes of a given file object.\n    Necessary because os.fstat only works on real files and not file-like\n    objects. This works on more types of streams, primarily StringIO.\n    \"\"\"\n    file_obj.seek(0, 2)\n    length = file_obj.tell()\n    file_obj.seek(0)\n    return length", "code_tokens": "def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length", "docstring_tokens": "Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO .", "label": 0}, {"idx": "cosqa-train-10966", "doc": "deleting files from a folder python", "code": "def clean_out_dir(directory):\n    \"\"\"\n    Delete all the files and subdirectories in a directory.\n    \"\"\"\n    if not isinstance(directory, path):\n        directory = path(directory)\n    for file_path in directory.files():\n        file_path.remove()\n    for dir_path in directory.dirs():\n        dir_path.rmtree()", "code_tokens": "def clean_out_dir ( directory ) : if not isinstance ( directory , path ) : directory = path ( directory ) for file_path in directory . files ( ) : file_path . remove ( ) for dir_path in directory . dirs ( ) : dir_path . rmtree ( )", "docstring_tokens": "Delete all the files and subdirectories in a directory .", "label": 1}, {"idx": "cosqa-train-10967", "doc": "python get linux clipboard", "code": "def paste(cmd=paste_cmd, stdout=PIPE):\n    \"\"\"Returns system clipboard contents.\n    \"\"\"\n    return Popen(cmd, stdout=stdout).communicate()[0].decode('utf-8')", "code_tokens": "def paste ( cmd = paste_cmd , stdout = PIPE ) : return Popen ( cmd , stdout = stdout ) . communicate ( ) [ 0 ] . decode ( 'utf-8' )", "docstring_tokens": "Returns system clipboard contents .", "label": 1}, {"idx": "cosqa-train-10968", "doc": "deploy a python project inteded for c++ in a virtual env", "code": "def generate(env):\n    \"\"\"Add Builders and construction variables for SGI MIPS C++ to an Environment.\"\"\"\n\n    cplusplus.generate(env)\n\n    env['CXX']         = 'CC'\n    env['CXXFLAGS']    = SCons.Util.CLVar('-LANG:std')\n    env['SHCXX']       = '$CXX'\n    env['SHOBJSUFFIX'] = '.o'\n    env['STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME'] = 1", "code_tokens": "def generate ( env ) : cplusplus . generate ( env ) env [ 'CXX' ] = 'CC' env [ 'CXXFLAGS' ] = SCons . Util . CLVar ( '-LANG:std' ) env [ 'SHCXX' ] = '$CXX' env [ 'SHOBJSUFFIX' ] = '.o' env [ 'STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME' ] = 1", "docstring_tokens": "Add Builders and construction variables for SGI MIPS C ++ to an Environment .", "label": 1}, {"idx": "cosqa-train-10969", "doc": "python get list item index position", "code": "def _get_item_position(self, idx):\n        \"\"\"Return a tuple of (start, end) indices of an item from its index.\"\"\"\n        start = 0 if idx == 0 else self._index[idx - 1] + 1\n        end = self._index[idx]\n        return start, end", "code_tokens": "def _get_item_position ( self , idx ) : start = 0 if idx == 0 else self . _index [ idx - 1 ] + 1 end = self . _index [ idx ] return start , end", "docstring_tokens": "Return a tuple of ( start end ) indices of an item from its index .", "label": 1}, {"idx": "cosqa-train-10970", "doc": "designing a bandpass filter with 4 frequencies, python", "code": "def fft_bandpassfilter(data, fs, lowcut, highcut):\n    \"\"\"\n    http://www.swharden.com/blog/2009-01-21-signal-filtering-with-python/#comment-16801\n    \"\"\"\n    fft = np.fft.fft(data)\n    # n = len(data)\n    # timestep = 1.0 / fs\n    # freq = np.fft.fftfreq(n, d=timestep)\n    bp = fft.copy()\n\n    # Zero out fft coefficients\n    # bp[10:-10] = 0\n\n    # Normalise\n    # bp *= real(fft.dot(fft))/real(bp.dot(bp))\n\n    bp *= fft.dot(fft) / bp.dot(bp)\n\n    # must multipy by 2 to get the correct amplitude\n    ibp = 12 * np.fft.ifft(bp)\n    return ibp", "code_tokens": "def fft_bandpassfilter ( data , fs , lowcut , highcut ) : fft = np . fft . fft ( data ) # n = len(data) # timestep = 1.0 / fs # freq = np.fft.fftfreq(n, d=timestep) bp = fft . copy ( ) # Zero out fft coefficients # bp[10:-10] = 0 # Normalise # bp *= real(fft.dot(fft))/real(bp.dot(bp)) bp *= fft . dot ( fft ) / bp . dot ( bp ) # must multipy by 2 to get the correct amplitude ibp = 12 * np . fft . ifft ( bp ) return ibp", "docstring_tokens": "http : // www . swharden . com / blog / 2009 - 01 - 21 - signal - filtering - with - python / #comment - 16801", "label": 1}, {"idx": "cosqa-train-10971", "doc": "python get memory usage by process", "code": "def get_memory_usage():\n    \"\"\"Gets RAM memory usage\n\n    :return: MB of memory used by this process\n    \"\"\"\n    process = psutil.Process(os.getpid())\n    mem = process.memory_info().rss\n    return mem / (1024 * 1024)", "code_tokens": "def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )", "docstring_tokens": "Gets RAM memory usage", "label": 1}, {"idx": "cosqa-train-10972", "doc": "designing a server with session management for multiple user in python", "code": "def main(ctx, connection):\n    \"\"\"Command line interface for PyBEL.\"\"\"\n    ctx.obj = Manager(connection=connection)\n    ctx.obj.bind()", "code_tokens": "def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )", "docstring_tokens": "Command line interface for PyBEL .", "label": 0}, {"idx": "cosqa-train-10973", "doc": "detect empty dictionary python", "code": "def nonull_dict(self):\n        \"\"\"Like dict, but does not hold any null values.\n\n        :return:\n\n        \"\"\"\n        return {k: v for k, v in six.iteritems(self.dict) if v and k != '_codes'}", "code_tokens": "def nonull_dict ( self ) : return { k : v for k , v in six . iteritems ( self . dict ) if v and k != '_codes' }", "docstring_tokens": "Like dict but does not hold any null values .", "label": 1}, {"idx": "cosqa-train-10974", "doc": "python get memory usage of numpy array", "code": "def memory_usage(self, deep=False):\n        \"\"\"\n        Memory usage of my values\n\n        Parameters\n        ----------\n        deep : bool\n            Introspect the data deeply, interrogate\n            `object` dtypes for system-level memory consumption\n\n        Returns\n        -------\n        bytes used\n\n        Notes\n        -----\n        Memory usage does not include memory consumed by elements that\n        are not components of the array if deep=False\n\n        See Also\n        --------\n        numpy.ndarray.nbytes\n        \"\"\"\n        return self._codes.nbytes + self.dtype.categories.memory_usage(\n            deep=deep)", "code_tokens": "def memory_usage ( self , deep = False ) : return self . _codes . nbytes + self . dtype . categories . memory_usage ( deep = deep )", "docstring_tokens": "Memory usage of my values", "label": 1}, {"idx": "cosqa-train-10975", "doc": "detect the date created on a file with python", "code": "def get_creation_datetime(filepath):\n    \"\"\"\n    Get the date that a file was created.\n\n    Parameters\n    ----------\n    filepath : str\n\n    Returns\n    -------\n    creation_datetime : datetime.datetime or None\n    \"\"\"\n    if platform.system() == 'Windows':\n        return datetime.fromtimestamp(os.path.getctime(filepath))\n    else:\n        stat = os.stat(filepath)\n        try:\n            return datetime.fromtimestamp(stat.st_birthtime)\n        except AttributeError:\n            # We're probably on Linux. No easy way to get creation dates here,\n            # so we'll settle for when its content was last modified.\n            return None", "code_tokens": "def get_creation_datetime ( filepath ) : if platform . system ( ) == 'Windows' : return datetime . fromtimestamp ( os . path . getctime ( filepath ) ) else : stat = os . stat ( filepath ) try : return datetime . fromtimestamp ( stat . st_birthtime ) except AttributeError : # We're probably on Linux. No easy way to get creation dates here, # so we'll settle for when its content was last modified. return None", "docstring_tokens": "Get the date that a file was created .", "label": 1}, {"idx": "cosqa-train-10976", "doc": "python get nearest position in list", "code": "def get_closest_index(myList, myNumber):\n    \"\"\"\n    Assumes myList is sorted. Returns closest value to myNumber.\n    If two numbers are equally close, return the smallest number.\n\n    Parameters\n    ----------\n    myList : array\n        The list in which to find the closest value to myNumber\n    myNumber : float\n        The number to find the closest to in MyList\n\n    Returns\n    -------\n    closest_values_index : int\n        The index in the array of the number closest to myNumber in myList\n    \"\"\"\n    closest_values_index = _np.where(self.time == take_closest(myList, myNumber))[0][0]\n    return closest_values_index", "code_tokens": "def get_closest_index ( myList , myNumber ) : closest_values_index = _np . where ( self . time == take_closest ( myList , myNumber ) ) [ 0 ] [ 0 ] return closest_values_index", "docstring_tokens": "Assumes myList is sorted . Returns closest value to myNumber . If two numbers are equally close return the smallest number .", "label": 1}, {"idx": "cosqa-train-10977", "doc": "detect yellow bordered square in photo python tensorflow", "code": "def resize_by_area(img, size):\n  \"\"\"image resize function used by quite a few image problems.\"\"\"\n  return tf.to_int64(\n      tf.image.resize_images(img, [size, size], tf.image.ResizeMethod.AREA))", "code_tokens": "def resize_by_area ( img , size ) : return tf . to_int64 ( tf . image . resize_images ( img , [ size , size ] , tf . image . ResizeMethod . AREA ) )", "docstring_tokens": "image resize function used by quite a few image problems .", "label": 0}, {"idx": "cosqa-train-10978", "doc": "python get object as dict", "code": "def conv_dict(self):\n        \"\"\"dictionary of conversion\"\"\"\n        return dict(integer=self.integer, real=self.real, no_type=self.no_type)", "code_tokens": "def conv_dict ( self ) : return dict ( integer = self . integer , real = self . real , no_type = self . no_type )", "docstring_tokens": "dictionary of conversion", "label": 1}, {"idx": "cosqa-train-10979", "doc": "determine bounding box of keyword in python", "code": "def bbox(img):\n    \"\"\"Find the bounding box around nonzero elements in the given array\n\n    Copied from https://stackoverflow.com/a/31402351/5703449 .\n\n    Returns:\n        rowmin, rowmax, colmin, colmax\n    \"\"\"\n    rows = np.any(img, axis=1)\n    cols = np.any(img, axis=0)\n    rmin, rmax = np.where(rows)[0][[0, -1]]\n    cmin, cmax = np.where(cols)[0][[0, -1]]\n\n    return rmin, rmax, cmin, cmax", "code_tokens": "def bbox ( img ) : rows = np . any ( img , axis = 1 ) cols = np . any ( img , axis = 0 ) rmin , rmax = np . where ( rows ) [ 0 ] [ [ 0 , - 1 ] ] cmin , cmax = np . where ( cols ) [ 0 ] [ [ 0 , - 1 ] ] return rmin , rmax , cmin , cmax", "docstring_tokens": "Find the bounding box around nonzero elements in the given array", "label": 1}, {"idx": "cosqa-train-10980", "doc": "python get object of string", "code": "def load_object_by_name(object_name):\n    \"\"\"Load an object from a module by name\"\"\"\n    mod_name, attr = object_name.rsplit('.', 1)\n    mod = import_module(mod_name)\n    return getattr(mod, attr)", "code_tokens": "def load_object_by_name ( object_name ) : mod_name , attr = object_name . rsplit ( '.' , 1 ) mod = import_module ( mod_name ) return getattr ( mod , attr )", "docstring_tokens": "Load an object from a module by name", "label": 1}, {"idx": "cosqa-train-10981", "doc": "deterministic distribution noise in python", "code": "def block(seed):\n    \"\"\" Return block of normal random numbers\n\n    Parameters\n    ----------\n    seed : {None, int}\n        The seed to generate the noise.sd\n\n    Returns\n    --------\n    noise : numpy.ndarray\n        Array of random numbers\n    \"\"\"\n    num = SAMPLE_RATE * BLOCK_SIZE\n    rng = RandomState(seed % 2**32)\n    variance = SAMPLE_RATE / 2\n    return rng.normal(size=num, scale=variance**0.5)", "code_tokens": "def block ( seed ) : num = SAMPLE_RATE * BLOCK_SIZE rng = RandomState ( seed % 2 ** 32 ) variance = SAMPLE_RATE / 2 return rng . normal ( size = num , scale = variance ** 0.5 )", "docstring_tokens": "Return block of normal random numbers", "label": 1}, {"idx": "cosqa-train-10982", "doc": "python get object of type", "code": "def get_object_or_child_by_type(self, *types):\n        \"\"\" Get object if child already been read or get child.\n\n        Use this method for fast access to objects in case of static configurations.\n\n        :param types: requested object types.\n        :return: all children of the specified types.\n        \"\"\"\n\n        objects = self.get_objects_or_children_by_type(*types)\n        return objects[0] if any(objects) else None", "code_tokens": "def get_object_or_child_by_type ( self , * types ) : objects = self . get_objects_or_children_by_type ( * types ) return objects [ 0 ] if any ( objects ) else None", "docstring_tokens": "Get object if child already been read or get child .", "label": 1}, {"idx": "cosqa-train-10983", "doc": "dfs without recursion in python", "code": "def dfs_recursive(graph, node, seen):\n    \"\"\"DFS, detect connected component, recursive implementation\n\n    :param graph: directed graph in listlist or listdict format\n    :param int node: to start graph exploration\n    :param boolean-table seen: will be set true for the connected component\n          containing node.\n    :complexity: `O(|V|+|E|)`\n    \"\"\"\n    seen[node] = True\n    for neighbor in graph[node]:\n        if not seen[neighbor]:\n            dfs_recursive(graph, neighbor, seen)", "code_tokens": "def dfs_recursive ( graph , node , seen ) : seen [ node ] = True for neighbor in graph [ node ] : if not seen [ neighbor ] : dfs_recursive ( graph , neighbor , seen )", "docstring_tokens": "DFS detect connected component recursive implementation", "label": 1}, {"idx": "cosqa-train-10984", "doc": "python get object's parent", "code": "def _lookup_parent(self, cls):\n        \"\"\"Lookup a transitive parent object that is an instance\n            of a given class.\"\"\"\n        codeobj = self.parent\n        while codeobj is not None and not isinstance(codeobj, cls):\n            codeobj = codeobj.parent\n        return codeobj", "code_tokens": "def _lookup_parent ( self , cls ) : codeobj = self . parent while codeobj is not None and not isinstance ( codeobj , cls ) : codeobj = codeobj . parent return codeobj", "docstring_tokens": "Lookup a transitive parent object that is an instance of a given class .", "label": 1}, {"idx": "cosqa-train-10985", "doc": "dict to html python", "code": "def dict_to_html_attrs(dict_):\n    \"\"\"\n    Banana banana\n    \"\"\"\n    res = ' '.join('%s=\"%s\"' % (k, v) for k, v in dict_.items())\n    return res", "code_tokens": "def dict_to_html_attrs ( dict_ ) : res = ' ' . join ( '%s=\"%s\"' % ( k , v ) for k , v in dict_ . items ( ) ) return res", "docstring_tokens": "Banana banana", "label": 1}, {"idx": "cosqa-train-10986", "doc": "python get parent file path", "code": "def get_parent_dir(name):\n    \"\"\"Get the parent directory of a filename.\"\"\"\n    parent_dir = os.path.dirname(os.path.dirname(name))\n    if parent_dir:\n        return parent_dir\n    return os.path.abspath('.')", "code_tokens": "def get_parent_dir ( name ) : parent_dir = os . path . dirname ( os . path . dirname ( name ) ) if parent_dir : return parent_dir return os . path . abspath ( '.' )", "docstring_tokens": "Get the parent directory of a filename .", "label": 1}, {"idx": "cosqa-train-10987", "doc": "dictionarry type from python to c++", "code": "def struct2dict(struct):\n    \"\"\"convert a ctypes structure to a dictionary\"\"\"\n    return {x: getattr(struct, x) for x in dict(struct._fields_).keys()}", "code_tokens": "def struct2dict ( struct ) : return { x : getattr ( struct , x ) for x in dict ( struct . _fields_ ) . keys ( ) }", "docstring_tokens": "convert a ctypes structure to a dictionary", "label": 1}, {"idx": "cosqa-train-10988", "doc": "python get parent scope of function", "code": "def get_parent_var(name, global_ok=False, default=None, skip_frames=0):\n    \"\"\"\n    Directly gets a variable from a parent frame-scope.\n\n    Returns\n    --------\n    Any\n        The content of the variable found by the given name, or None.\n    \"\"\"\n\n    scope = get_parent_scope_from_var(name, global_ok=global_ok, skip_frames=skip_frames + 1)\n\n    if not scope:\n        return default\n\n    if name in scope.locals:\n        return scope.locals.get(name, default)\n\n    return scope.globals.get(name, default)", "code_tokens": "def get_parent_var ( name , global_ok = False , default = None , skip_frames = 0 ) : scope = get_parent_scope_from_var ( name , global_ok = global_ok , skip_frames = skip_frames + 1 ) if not scope : return default if name in scope . locals : return scope . locals . get ( name , default ) return scope . globals . get ( name , default )", "docstring_tokens": "Directly gets a variable from a parent frame - scope .", "label": 1}, {"idx": "cosqa-train-10989", "doc": "dictionary data type for latitude and longitude in python", "code": "def make_coord_dict(coord):\n    \"\"\"helper function to make a dict from a coordinate for logging\"\"\"\n    return dict(\n        z=int_if_exact(coord.zoom),\n        x=int_if_exact(coord.column),\n        y=int_if_exact(coord.row),\n    )", "code_tokens": "def make_coord_dict ( coord ) : return dict ( z = int_if_exact ( coord . zoom ) , x = int_if_exact ( coord . column ) , y = int_if_exact ( coord . row ) , )", "docstring_tokens": "helper function to make a dict from a coordinate for logging", "label": 1}, {"idx": "cosqa-train-10990", "doc": "python get pixel position from screen", "code": "def screen_to_latlon(self, x, y):\n        \"\"\"\n        Return the latitude and longitude corresponding to a screen point\n        :param x: screen x\n        :param y: screen y\n        :return: latitude and longitude at x,y\n        \"\"\"\n        xtile = 1. * x / TILE_SIZE + self.xtile\n        ytile = 1. * y / TILE_SIZE + self.ytile\n        return self.num2deg(xtile, ytile, self.zoom)", "code_tokens": "def screen_to_latlon ( self , x , y ) : xtile = 1. * x / TILE_SIZE + self . xtile ytile = 1. * y / TILE_SIZE + self . ytile return self . num2deg ( xtile , ytile , self . zoom )", "docstring_tokens": "Return the latitude and longitude corresponding to a screen point : param x : screen x : param y : screen y : return : latitude and longitude at x y", "label": 1}, {"idx": "cosqa-train-10991", "doc": "different activation functions python", "code": "def softplus(attrs, inputs, proto_obj):\n    \"\"\"Applies the sofplus activation function element-wise to the input.\"\"\"\n    new_attrs = translation_utils._add_extra_attributes(attrs, {'act_type' : 'softrelu'})\n    return 'Activation', new_attrs, inputs", "code_tokens": "def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs", "docstring_tokens": "Applies the sofplus activation function element - wise to the input .", "label": 1}, {"idx": "cosqa-train-10992", "doc": "python get precision of float", "code": "def round_to_float(number, precision):\n    \"\"\"Round a float to a precision\"\"\"\n    rounded = Decimal(str(floor((number + precision / 2) // precision))\n                      ) * Decimal(str(precision))\n    return float(rounded)", "code_tokens": "def round_to_float ( number , precision ) : rounded = Decimal ( str ( floor ( ( number + precision / 2 ) // precision ) ) ) * Decimal ( str ( precision ) ) return float ( rounded )", "docstring_tokens": "Round a float to a precision", "label": 1}, {"idx": "cosqa-train-10993", "doc": "digit to integer as what to string python", "code": "def int2str(num, radix=10, alphabet=BASE85):\n    \"\"\"helper function for quick base conversions from integers to strings\"\"\"\n    return NumConv(radix, alphabet).int2str(num)", "code_tokens": "def int2str ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . int2str ( num )", "docstring_tokens": "helper function for quick base conversions from integers to strings", "label": 1}, {"idx": "cosqa-train-10994", "doc": "python get query strinng from url", "code": "def get_querystring(uri):\n    \"\"\"Get Querystring information from uri.\n\n    :param uri: uri\n    :return: querystring info or {}\n    \"\"\"\n    parts = urlparse.urlsplit(uri)\n    return urlparse.parse_qs(parts.query)", "code_tokens": "def get_querystring ( uri ) : parts = urlparse . urlsplit ( uri ) return urlparse . parse_qs ( parts . query )", "docstring_tokens": "Get Querystring information from uri .", "label": 1}, {"idx": "cosqa-train-10995", "doc": "discord python bot check owner", "code": "def me(self):\n        \"\"\"Similar to :attr:`.Guild.me` except it may return the :class:`.ClientUser` in private message contexts.\"\"\"\n        return self.guild.me if self.guild is not None else self.bot.user", "code_tokens": "def me ( self ) : return self . guild . me if self . guild is not None else self . bot . user", "docstring_tokens": "Similar to : attr : . Guild . me except it may return the : class : . ClientUser in private message contexts .", "label": 1}, {"idx": "cosqa-train-10996", "doc": "python get region of image", "code": "def border(self):\n        \"\"\"Region formed by taking border elements.\n\n        :returns: :class:`jicimagelib.region.Region`\n        \"\"\"\n\n        border_array = self.bitmap - self.inner.bitmap\n        return Region(border_array)", "code_tokens": "def border ( self ) : border_array = self . bitmap - self . inner . bitmap return Region ( border_array )", "docstring_tokens": "Region formed by taking border elements .", "label": 1}, {"idx": "cosqa-train-10997", "doc": "discord python get user from id string", "code": "def get_user_by_id(self, id):\n        \"\"\"Retrieve a User object by ID.\"\"\"\n        return self.db_adapter.get_object(self.UserClass, id=id)", "code_tokens": "def get_user_by_id ( self , id ) : return self . db_adapter . get_object ( self . UserClass , id = id )", "docstring_tokens": "Retrieve a User object by ID .", "label": 1}, {"idx": "cosqa-train-10998", "doc": "python get regkey value", "code": "def __get_registry_key(self, key):\n        \"\"\" Read currency from windows registry \"\"\"\n        import winreg\n\n        root = winreg.OpenKey(\n            winreg.HKEY_CURRENT_USER, r'SOFTWARE\\GSettings\\org\\gnucash\\general', 0, winreg.KEY_READ)\n        [pathname, regtype] = (winreg.QueryValueEx(root, key))\n        winreg.CloseKey(root)\n        return pathname", "code_tokens": "def __get_registry_key ( self , key ) : import winreg root = winreg . OpenKey ( winreg . HKEY_CURRENT_USER , r'SOFTWARE\\GSettings\\org\\gnucash\\general' , 0 , winreg . KEY_READ ) [ pathname , regtype ] = ( winreg . QueryValueEx ( root , key ) ) winreg . CloseKey ( root ) return pathname", "docstring_tokens": "Read currency from windows registry", "label": 1}, {"idx": "cosqa-train-10999", "doc": "distance between data pair in python", "code": "def skip_connection_distance(a, b):\n    \"\"\"The distance between two skip-connections.\"\"\"\n    if a[2] != b[2]:\n        return 1.0\n    len_a = abs(a[1] - a[0])\n    len_b = abs(b[1] - b[0])\n    return (abs(a[0] - b[0]) + abs(len_a - len_b)) / (max(a[0], b[0]) + max(len_a, len_b))", "code_tokens": "def skip_connection_distance ( a , b ) : if a [ 2 ] != b [ 2 ] : return 1.0 len_a = abs ( a [ 1 ] - a [ 0 ] ) len_b = abs ( b [ 1 ] - b [ 0 ] ) return ( abs ( a [ 0 ] - b [ 0 ] ) + abs ( len_a - len_b ) ) / ( max ( a [ 0 ] , b [ 0 ] ) + max ( len_a , len_b ) )", "docstring_tokens": "The distance between two skip - connections .", "label": 1}, {"idx": "cosqa-train-11000", "doc": "python get retreiev access property dynamic", "code": "def value(self):\n        \"\"\"Value of property.\"\"\"\n        if self._prop.fget is None:\n            raise AttributeError('Unable to read attribute')\n        return self._prop.fget(self._obj)", "code_tokens": "def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )", "docstring_tokens": "Value of property .", "label": 1}, {"idx": "cosqa-train-11001", "doc": "distinct items in a list python", "code": "def unique(input_list):\n    \"\"\"\n    Return a list of unique items (similar to set functionality).\n\n    Parameters\n    ----------\n    input_list : list\n        A list containg some items that can occur more than once.\n\n    Returns\n    -------\n    list\n        A list with only unique occurances of an item.\n\n    \"\"\"\n    output = []\n    for item in input_list:\n        if item not in output:\n            output.append(item)\n    return output", "code_tokens": "def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output", "docstring_tokens": "Return a list of unique items ( similar to set functionality ) .", "label": 1}, {"idx": "cosqa-train-11002", "doc": "python get rid of axis points on graph", "code": "def clean_axis(axis):\n    \"\"\"Remove ticks, tick labels, and frame from axis\"\"\"\n    axis.get_xaxis().set_ticks([])\n    axis.get_yaxis().set_ticks([])\n    for spine in list(axis.spines.values()):\n        spine.set_visible(False)", "code_tokens": "def clean_axis ( axis ) : axis . get_xaxis ( ) . set_ticks ( [ ] ) axis . get_yaxis ( ) . set_ticks ( [ ] ) for spine in list ( axis . spines . values ( ) ) : spine . set_visible ( False )", "docstring_tokens": "Remove ticks tick labels and frame from axis", "label": 1}, {"idx": "cosqa-train-11003", "doc": "distribution fitting in normal distribution python", "code": "def norm(x, mu, sigma=1.0):\n    \"\"\" Scipy norm function \"\"\"\n    return stats.norm(loc=mu, scale=sigma).pdf(x)", "code_tokens": "def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )", "docstring_tokens": "Scipy norm function", "label": 1}, {"idx": "cosqa-train-11004", "doc": "django python test check if column/key exists", "code": "def check_attribute_exists(instance):\n    \"\"\" Additional check for the dimension model, to ensure that attributes\n    given as the key and label attribute on the dimension exist. \"\"\"\n    attributes = instance.get('attributes', {}).keys()\n    if instance.get('key_attribute') not in attributes:\n        return False\n    label_attr = instance.get('label_attribute')\n    if label_attr and label_attr not in attributes:\n        return False\n    return True", "code_tokens": "def check_attribute_exists ( instance ) : attributes = instance . get ( 'attributes' , { } ) . keys ( ) if instance . get ( 'key_attribute' ) not in attributes : return False label_attr = instance . get ( 'label_attribute' ) if label_attr and label_attr not in attributes : return False return True", "docstring_tokens": "Additional check for the dimension model to ensure that attributes given as the key and label attribute on the dimension exist .", "label": 1}, {"idx": "cosqa-train-11005", "doc": "python get size of url image", "code": "def get_image_dimension(self, url):\n        \"\"\"\n        Return a tuple that contains (width, height)\n        Pass in a url to an image and find out its size without loading the whole file\n        If the image wxh could not be found, the tuple will contain `None` values\n        \"\"\"\n        w_h = (None, None)\n        try:\n            if url.startswith('//'):\n                url = 'http:' + url\n            data = requests.get(url).content\n            im = Image.open(BytesIO(data))\n\n            w_h = im.size\n        except Exception:\n            logger.warning(\"Error getting image size {}\".format(url), exc_info=True)\n\n        return w_h", "code_tokens": "def get_image_dimension ( self , url ) : w_h = ( None , None ) try : if url . startswith ( '//' ) : url = 'http:' + url data = requests . get ( url ) . content im = Image . open ( BytesIO ( data ) ) w_h = im . size except Exception : logger . warning ( \"Error getting image size {}\" . format ( url ) , exc_info = True ) return w_h", "docstring_tokens": "Return a tuple that contains ( width height ) Pass in a url to an image and find out its size without loading the whole file If the image wxh could not be found the tuple will contain None values", "label": 0}, {"idx": "cosqa-train-11006", "doc": "do abstract methods in python slow down code", "code": "def _full_analysis_mp_alias(br_obj, analysis_set, output_directory, unique_name, verbose, quick_plots):\n    \"\"\"\n    Alias for instance method that allows the method to be called in a\n    multiprocessing pool. Needed as multiprocessing does not otherwise work\n    on object instance methods.\n    \"\"\"\n    return (br_obj, unique_name, br_obj.full_analysis(analysis_set, output_directory, verbose = verbose, compile_pdf = verbose, quick_plots = quick_plots))", "code_tokens": "def _full_analysis_mp_alias ( br_obj , analysis_set , output_directory , unique_name , verbose , quick_plots ) : return ( br_obj , unique_name , br_obj . full_analysis ( analysis_set , output_directory , verbose = verbose , compile_pdf = verbose , quick_plots = quick_plots ) )", "docstring_tokens": "Alias for instance method that allows the method to be called in a multiprocessing pool . Needed as multiprocessing does not otherwise work on object instance methods .", "label": 0}, {"idx": "cosqa-train-11007", "doc": "python get sort index numpy array", "code": "def argsort_indices(a, axis=-1):\n    \"\"\"Like argsort, but returns an index suitable for sorting the\n    the original array even if that array is multidimensional\n    \"\"\"\n    a = np.asarray(a)\n    ind = list(np.ix_(*[np.arange(d) for d in a.shape]))\n    ind[axis] = a.argsort(axis)\n    return tuple(ind)", "code_tokens": "def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )", "docstring_tokens": "Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional", "label": 1}, {"idx": "cosqa-train-11008", "doc": "does python have boolean values", "code": "def _check_and_convert_bools(self):\n        \"\"\"Replace boolean variables by the characters 'F'/'T'\n        \"\"\"\n        replacements = {\n            True: 'T',\n            False: 'F',\n        }\n\n        for key in self.bools:\n            if isinstance(self[key], bool):\n                self[key] = replacements[self[key]]", "code_tokens": "def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]", "docstring_tokens": "Replace boolean variables by the characters F / T", "label": 1}, {"idx": "cosqa-train-11009", "doc": "python get sound volume", "code": "def calc_volume(self, sample: np.ndarray):\n        \"\"\"Find the RMS of the audio\"\"\"\n        return sqrt(np.mean(np.square(sample)))", "code_tokens": "def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )", "docstring_tokens": "Find the RMS of the audio", "label": 1}, {"idx": "cosqa-train-11010", "doc": "does the code coninue running after sleep python", "code": "def test3():\n    \"\"\"Test the multiprocess\n    \"\"\"\n    import time\n    \n    p = MVisionProcess()\n    p.start()\n    time.sleep(5)\n    p.stop()", "code_tokens": "def test3 ( ) : import time p = MVisionProcess ( ) p . start ( ) time . sleep ( 5 ) p . stop ( )", "docstring_tokens": "Test the multiprocess", "label": 1}, {"idx": "cosqa-train-11011", "doc": "python get stty size", "code": "def _size_36():\n    \"\"\" returns the rows, columns of terminal \"\"\"\n    from shutil import get_terminal_size\n    dim = get_terminal_size()\n    if isinstance(dim, list):\n        return dim[0], dim[1]\n    return dim.lines, dim.columns", "code_tokens": "def _size_36 ( ) : from shutil import get_terminal_size dim = get_terminal_size ( ) if isinstance ( dim , list ) : return dim [ 0 ] , dim [ 1 ] return dim . lines , dim . columns", "docstring_tokens": "returns the rows columns of terminal", "label": 0}, {"idx": "cosqa-train-11012", "doc": "dot product of vectors python", "code": "def dot_v3(v, w):\n    \"\"\"Return the dotproduct of two vectors.\"\"\"\n\n    return sum([x * y for x, y in zip(v, w)])", "code_tokens": "def dot_v3 ( v , w ) : return sum ( [ x * y for x , y in zip ( v , w ) ] )", "docstring_tokens": "Return the dotproduct of two vectors .", "label": 0}, {"idx": "cosqa-train-11013", "doc": "python get the cores of my pc", "code": "def _num_cpus_darwin():\n    \"\"\"Return the number of active CPUs on a Darwin system.\"\"\"\n    p = subprocess.Popen(['sysctl','-n','hw.ncpu'],stdout=subprocess.PIPE)\n    return p.stdout.read()", "code_tokens": "def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )", "docstring_tokens": "Return the number of active CPUs on a Darwin system .", "label": 1}, {"idx": "cosqa-train-11014", "doc": "dot product operation in python", "code": "def dot(self, w):\n        \"\"\"Return the dotproduct between self and another vector.\"\"\"\n\n        return sum([x * y for x, y in zip(self, w)])", "code_tokens": "def dot ( self , w ) : return sum ( [ x * y for x , y in zip ( self , w ) ] )", "docstring_tokens": "Return the dotproduct between self and another vector .", "label": 1}, {"idx": "cosqa-train-11015", "doc": "python get the function name", "code": "def get_func_name(func):\n    \"\"\"Return a name which includes the module name and function name.\"\"\"\n    func_name = getattr(func, '__name__', func.__class__.__name__)\n    module_name = func.__module__\n\n    if module_name is not None:\n        module_name = func.__module__\n        return '{}.{}'.format(module_name, func_name)\n\n    return func_name", "code_tokens": "def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name", "docstring_tokens": "Return a name which includes the module name and function name .", "label": 1}, {"idx": "cosqa-train-11016", "doc": "draw horizontal line in python", "code": "def hline(self, x, y, width, color):\n        \"\"\"Draw a horizontal line up to a given length.\"\"\"\n        self.rect(x, y, width, 1, color, fill=True)", "code_tokens": "def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )", "docstring_tokens": "Draw a horizontal line up to a given length .", "label": 1}, {"idx": "cosqa-train-11017", "doc": "python get the largest dictionary key", "code": "def find_largest_contig(contig_lengths_dict):\n    \"\"\"\n    Determine the largest contig for each strain\n    :param contig_lengths_dict: dictionary of strain name: reverse-sorted list of all contig lengths\n    :return: longest_contig_dict: dictionary of strain name: longest contig\n    \"\"\"\n    # Initialise the dictionary\n    longest_contig_dict = dict()\n    for file_name, contig_lengths in contig_lengths_dict.items():\n        # As the list is sorted in descending order, the largest contig is the first entry in the list\n        longest_contig_dict[file_name] = contig_lengths[0]\n    return longest_contig_dict", "code_tokens": "def find_largest_contig ( contig_lengths_dict ) : # Initialise the dictionary longest_contig_dict = dict ( ) for file_name , contig_lengths in contig_lengths_dict . items ( ) : # As the list is sorted in descending order, the largest contig is the first entry in the list longest_contig_dict [ file_name ] = contig_lengths [ 0 ] return longest_contig_dict", "docstring_tokens": "Determine the largest contig for each strain : param contig_lengths_dict : dictionary of strain name : reverse - sorted list of all contig lengths : return : longest_contig_dict : dictionary of strain name : longest contig", "label": 1}, {"idx": "cosqa-train-11018", "doc": "draw line segments connecting the three points in python", "code": "def line_segment(X0, X1):\n    r\"\"\"\n    Calculate the voxel coordinates of a straight line between the two given\n    end points\n\n    Parameters\n    ----------\n    X0 and X1 : array_like\n        The [x, y] or [x, y, z] coordinates of the start and end points of\n        the line.\n\n    Returns\n    -------\n    coords : list of lists\n        A list of lists containing the X, Y, and Z coordinates of all voxels\n        that should be drawn between the start and end points to create a solid\n        line.\n    \"\"\"\n    X0 = sp.around(X0).astype(int)\n    X1 = sp.around(X1).astype(int)\n    if len(X0) == 3:\n        L = sp.amax(sp.absolute([[X1[0]-X0[0]], [X1[1]-X0[1]], [X1[2]-X0[2]]])) + 1\n        x = sp.rint(sp.linspace(X0[0], X1[0], L)).astype(int)\n        y = sp.rint(sp.linspace(X0[1], X1[1], L)).astype(int)\n        z = sp.rint(sp.linspace(X0[2], X1[2], L)).astype(int)\n        return [x, y, z]\n    else:\n        L = sp.amax(sp.absolute([[X1[0]-X0[0]], [X1[1]-X0[1]]])) + 1\n        x = sp.rint(sp.linspace(X0[0], X1[0], L)).astype(int)\n        y = sp.rint(sp.linspace(X0[1], X1[1], L)).astype(int)\n        return [x, y]", "code_tokens": "def line_segment ( X0 , X1 ) : X0 = sp . around ( X0 ) . astype ( int ) X1 = sp . around ( X1 ) . astype ( int ) if len ( X0 ) == 3 : L = sp . amax ( sp . absolute ( [ [ X1 [ 0 ] - X0 [ 0 ] ] , [ X1 [ 1 ] - X0 [ 1 ] ] , [ X1 [ 2 ] - X0 [ 2 ] ] ] ) ) + 1 x = sp . rint ( sp . linspace ( X0 [ 0 ] , X1 [ 0 ] , L ) ) . astype ( int ) y = sp . rint ( sp . linspace ( X0 [ 1 ] , X1 [ 1 ] , L ) ) . astype ( int ) z = sp . rint ( sp . linspace ( X0 [ 2 ] , X1 [ 2 ] , L ) ) . astype ( int ) return [ x , y , z ] else : L = sp . amax ( sp . absolute ( [ [ X1 [ 0 ] - X0 [ 0 ] ] , [ X1 [ 1 ] - X0 [ 1 ] ] ] ) ) + 1 x = sp . rint ( sp . linspace ( X0 [ 0 ] , X1 [ 0 ] , L ) ) . astype ( int ) y = sp . rint ( sp . linspace ( X0 [ 1 ] , X1 [ 1 ] , L ) ) . astype ( int ) return [ x , y ]", "docstring_tokens": "r Calculate the voxel coordinates of a straight line between the two given end points", "label": 1}, {"idx": "cosqa-train-11019", "doc": "python get the last column", "code": "def get_last_row(dbconn, tablename, n=1, uuid=None):\n    \"\"\"\n    Returns the last `n` rows in the table\n    \"\"\"\n    return fetch(dbconn, tablename, n, uuid, end=True)", "code_tokens": "def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )", "docstring_tokens": "Returns the last n rows in the table", "label": 1}, {"idx": "cosqa-train-11020", "doc": "python get the row and column number of mati", "code": "def get_size(self, m):\n        \"\"\"\n        Return the 2-D size of a Jacobian matrix in tuple\n        \"\"\"\n        nrow, ncol = 0, 0\n        if m[0] == 'F':\n            nrow = self.n\n        elif m[0] == 'G':\n            nrow = self.m\n\n        if m[1] == 'x':\n            ncol = self.n\n        elif m[1] == 'y':\n            ncol = self.m\n\n        return nrow, ncol", "code_tokens": "def get_size ( self , m ) : nrow , ncol = 0 , 0 if m [ 0 ] == 'F' : nrow = self . n elif m [ 0 ] == 'G' : nrow = self . m if m [ 1 ] == 'x' : ncol = self . n elif m [ 1 ] == 'y' : ncol = self . m return nrow , ncol", "docstring_tokens": "Return the 2 - D size of a Jacobian matrix in tuple", "label": 1}, {"idx": "cosqa-train-11021", "doc": "dynamic attribute access python", "code": "def experiment_property(prop):\n    \"\"\"Get a property of the experiment by name.\"\"\"\n    exp = experiment(session)\n    p = getattr(exp, prop)\n    return success_response(field=prop, data=p, request_type=prop)", "code_tokens": "def experiment_property ( prop ) : exp = experiment ( session ) p = getattr ( exp , prop ) return success_response ( field = prop , data = p , request_type = prop )", "docstring_tokens": "Get a property of the experiment by name .", "label": 0}, {"idx": "cosqa-train-11022", "doc": "python get the second lowest value in a list", "code": "def find_le(a, x):\n    \"\"\"Find rightmost value less than or equal to x.\"\"\"\n    i = bs.bisect_right(a, x)\n    if i: return i - 1\n    raise ValueError", "code_tokens": "def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError", "docstring_tokens": "Find rightmost value less than or equal to x .", "label": 1}, {"idx": "cosqa-train-11023", "doc": "easiest way to pad an image python", "code": "def __call__(self, img):\n        \"\"\"\n        Args:\n            img (PIL Image): Image to be padded.\n\n        Returns:\n            PIL Image: Padded image.\n        \"\"\"\n        return F.pad(img, self.padding, self.fill, self.padding_mode)", "code_tokens": "def __call__ ( self , img ) : return F . pad ( img , self . padding , self . fill , self . padding_mode )", "docstring_tokens": "Args : img ( PIL Image ) : Image to be padded .", "label": 1}, {"idx": "cosqa-train-11024", "doc": "python get user name on windows", "code": "def get_user_name():\n    \"\"\"Get user name provide by operating system\n    \"\"\"\n\n    if sys.platform == 'win32':\n        #user = os.getenv('USERPROFILE')\n        user = os.getenv('USERNAME')\n    else:\n        user = os.getenv('LOGNAME')\n\n    return user", "code_tokens": "def get_user_name ( ) : if sys . platform == 'win32' : #user = os.getenv('USERPROFILE') user = os . getenv ( 'USERNAME' ) else : user = os . getenv ( 'LOGNAME' ) return user", "docstring_tokens": "Get user name provide by operating system", "label": 1}, {"idx": "cosqa-train-11025", "doc": "edit a copy of a dictionary python", "code": "def copy_and_update(dictionary, update):\n    \"\"\"Returns an updated copy of the dictionary without modifying the original\"\"\"\n    newdict = dictionary.copy()\n    newdict.update(update)\n    return newdict", "code_tokens": "def copy_and_update ( dictionary , update ) : newdict = dictionary . copy ( ) newdict . update ( update ) return newdict", "docstring_tokens": "Returns an updated copy of the dictionary without modifying the original", "label": 0}, {"idx": "cosqa-train-11026", "doc": "python get utc offset datetime", "code": "def convert_2_utc(self, datetime_, timezone):\n        \"\"\"convert to datetime to UTC offset.\"\"\"\n\n        datetime_ = self.tz_mapper[timezone].localize(datetime_)\n        return datetime_.astimezone(pytz.UTC)", "code_tokens": "def convert_2_utc ( self , datetime_ , timezone ) : datetime_ = self . tz_mapper [ timezone ] . localize ( datetime_ ) return datetime_ . astimezone ( pytz . UTC )", "docstring_tokens": "convert to datetime to UTC offset .", "label": 1}, {"idx": "cosqa-train-11027", "doc": "efficent way to remove character from string python", "code": "def remove_accent_string(string):\n    \"\"\"\n    Remove all accent from a whole string.\n    \"\"\"\n    return utils.join([add_accent_char(c, Accent.NONE) for c in string])", "code_tokens": "def remove_accent_string ( string ) : return utils . join ( [ add_accent_char ( c , Accent . NONE ) for c in string ] )", "docstring_tokens": "Remove all accent from a whole string .", "label": 1}, {"idx": "cosqa-train-11028", "doc": "python get utilized ram", "code": "def current_memory_usage():\n    \"\"\"\n    Returns this programs current memory usage in bytes\n    \"\"\"\n    import psutil\n    proc = psutil.Process(os.getpid())\n    #meminfo = proc.get_memory_info()\n    meminfo = proc.memory_info()\n    rss = meminfo[0]  # Resident Set Size / Mem Usage\n    vms = meminfo[1]  # Virtual Memory Size / VM Size  # NOQA\n    return rss", "code_tokens": "def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss", "docstring_tokens": "Returns this programs current memory usage in bytes", "label": 1}, {"idx": "cosqa-train-11029", "doc": "elasticsearch check whether a field exists python", "code": "def has_field(mc, field_name):\n    \"\"\"\n    detect if a model has a given field has\n\n    :param field_name:\n    :param mc:\n    :return:\n    \"\"\"\n    try:\n        mc._meta.get_field(field_name)\n    except FieldDoesNotExist:\n        return False\n    return True", "code_tokens": "def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True", "docstring_tokens": "detect if a model has a given field has", "label": 1}, {"idx": "cosqa-train-11030", "doc": "python get value from enum by name", "code": "def get_enum_from_name(self, enum_name):\n        \"\"\"\n            Return an enum from a name\n        Args:\n            enum_name (str): name of the enum\n        Returns:\n            Enum\n        \"\"\"\n        return next((e for e in self.enums if e.name == enum_name), None)", "code_tokens": "def get_enum_from_name ( self , enum_name ) : return next ( ( e for e in self . enums if e . name == enum_name ) , None )", "docstring_tokens": "Return an enum from a name Args : enum_name ( str ) : name of the enum Returns : Enum", "label": 1}, {"idx": "cosqa-train-11031", "doc": "elasticsearch python bulk upsert", "code": "def replace_one(self, replacement):\n        \"\"\"Replace one entire document matching the selector criteria.\n\n        :Parameters:\n          - `replacement` (dict): the replacement document\n        \"\"\"\n        self.__bulk.add_replace(self.__selector, replacement, upsert=True,\n                                collation=self.__collation)", "code_tokens": "def replace_one ( self , replacement ) : self . __bulk . add_replace ( self . __selector , replacement , upsert = True , collation = self . __collation )", "docstring_tokens": "Replace one entire document matching the selector criteria .", "label": 1}, {"idx": "cosqa-train-11032", "doc": "python get value in a list closest to a number", "code": "def get_closest_index(myList, myNumber):\n    \"\"\"\n    Assumes myList is sorted. Returns closest value to myNumber.\n    If two numbers are equally close, return the smallest number.\n\n    Parameters\n    ----------\n    myList : array\n        The list in which to find the closest value to myNumber\n    myNumber : float\n        The number to find the closest to in MyList\n\n    Returns\n    -------\n    closest_values_index : int\n        The index in the array of the number closest to myNumber in myList\n    \"\"\"\n    closest_values_index = _np.where(self.time == take_closest(myList, myNumber))[0][0]\n    return closest_values_index", "code_tokens": "def get_closest_index ( myList , myNumber ) : closest_values_index = _np . where ( self . time == take_closest ( myList , myNumber ) ) [ 0 ] [ 0 ] return closest_values_index", "docstring_tokens": "Assumes myList is sorted . Returns closest value to myNumber . If two numbers are equally close return the smallest number .", "label": 1}, {"idx": "cosqa-train-11033", "doc": "elegant python 3 reproduction of most common words from a story", "code": "def most_common(items):\n    \"\"\"\n    Wanted functionality from Counters (new in Python 2.7).\n    \"\"\"\n    counts = {}\n    for i in items:\n        counts.setdefault(i, 0)\n        counts[i] += 1\n    return max(six.iteritems(counts), key=operator.itemgetter(1))", "code_tokens": "def most_common ( items ) : counts = { } for i in items : counts . setdefault ( i , 0 ) counts [ i ] += 1 return max ( six . iteritems ( counts ) , key = operator . itemgetter ( 1 ) )", "docstring_tokens": "Wanted functionality from Counters ( new in Python 2 . 7 ) .", "label": 1}, {"idx": "cosqa-train-11034", "doc": "python get variable attribute", "code": "def getSystemVariable(self, remote, name):\n        \"\"\"Get single system variable from CCU / Homegear\"\"\"\n        if self._server is not None:\n            return self._server.getSystemVariable(remote, name)", "code_tokens": "def getSystemVariable ( self , remote , name ) : if self . _server is not None : return self . _server . getSystemVariable ( remote , name )", "docstring_tokens": "Get single system variable from CCU / Homegear", "label": 1}, {"idx": "cosqa-train-11035", "doc": "eliminate empty cells from list in python 2", "code": "def drop_empty(rows):\n    \"\"\"Transpose the columns into rows, remove all of the rows that are empty after the first cell, then\n    transpose back. The result is that columns that have a header but no data in the body are removed, assuming\n    the header is the first row. \"\"\"\n    return zip(*[col for col in zip(*rows) if bool(filter(bool, col[1:]))])", "code_tokens": "def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )", "docstring_tokens": "Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row .", "label": 1}, {"idx": "cosqa-train-11036", "doc": "python get weeks between 2 days", "code": "def get_week_start_end_day():\n    \"\"\"\n    Get the week start date and end date\n    \"\"\"\n    t = date.today()\n    wd = t.weekday()\n    return (t - timedelta(wd), t + timedelta(6 - wd))", "code_tokens": "def get_week_start_end_day ( ) : t = date . today ( ) wd = t . weekday ( ) return ( t - timedelta ( wd ) , t + timedelta ( 6 - wd ) )", "docstring_tokens": "Get the week start date and end date", "label": 0}, {"idx": "cosqa-train-11037", "doc": "email address validation using reg exp in python", "code": "def is_valid_email(email):\n    \"\"\"\n    Check if email is valid\n    \"\"\"\n    pattern = re.compile(r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+')\n    return bool(pattern.match(email))", "code_tokens": "def is_valid_email ( email ) : pattern = re . compile ( r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+' ) return bool ( pattern . match ( email ) )", "docstring_tokens": "Check if email is valid", "label": 1}, {"idx": "cosqa-train-11038", "doc": "python get window title", "code": "def title(self):\n        \"\"\" The title of this window \"\"\"\n        with switch_window(self._browser, self.name):\n            return self._browser.title", "code_tokens": "def title ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . title", "docstring_tokens": "The title of this window", "label": 1}, {"idx": "cosqa-train-11039", "doc": "enter text into header docx python", "code": "def fill_document(doc):\n    \"\"\"Add a section, a subsection and some text to the document.\n\n    :param doc: the document\n    :type doc: :class:`pylatex.document.Document` instance\n    \"\"\"\n    with doc.create(Section('A section')):\n        doc.append('Some regular text and some ')\n        doc.append(italic('italic text. '))\n\n        with doc.create(Subsection('A subsection')):\n            doc.append('Also some crazy characters: $&#{}')", "code_tokens": "def fill_document ( doc ) : with doc . create ( Section ( 'A section' ) ) : doc . append ( 'Some regular text and some ' ) doc . append ( italic ( 'italic text. ' ) ) with doc . create ( Subsection ( 'A subsection' ) ) : doc . append ( 'Also some crazy characters: $&#{}' )", "docstring_tokens": "Add a section a subsection and some text to the document .", "label": 0}, {"idx": "cosqa-train-11040", "doc": "python get word count across list of sentences", "code": "def count(lines):\n  \"\"\" Counts the word frequences in a list of sentences.\n\n  Note:\n    This is a helper function for parallel execution of `Vocabulary.from_text`\n    method.\n  \"\"\"\n  words = [w for l in lines for w in l.strip().split()]\n  return Counter(words)", "code_tokens": "def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )", "docstring_tokens": "Counts the word frequences in a list of sentences .", "label": 1}, {"idx": "cosqa-train-11041", "doc": "epoch value from datetime python", "code": "def AmericanDateToEpoch(self, date_str):\n    \"\"\"Take a US format date and return epoch.\"\"\"\n    try:\n      epoch = time.strptime(date_str, \"%m/%d/%Y\")\n      return int(calendar.timegm(epoch)) * 1000000\n    except ValueError:\n      return 0", "code_tokens": "def AmericanDateToEpoch ( self , date_str ) : try : epoch = time . strptime ( date_str , \"%m/%d/%Y\" ) return int ( calendar . timegm ( epoch ) ) * 1000000 except ValueError : return 0", "docstring_tokens": "Take a US format date and return epoch .", "label": 1}, {"idx": "cosqa-train-11042", "doc": "python get xml node parent", "code": "def root_parent(self, category=None):\n        \"\"\" Returns the topmost parent of the current category. \"\"\"\n        return next(filter(lambda c: c.is_root, self.hierarchy()))", "code_tokens": "def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )", "docstring_tokens": "Returns the topmost parent of the current category .", "label": 1}, {"idx": "cosqa-train-11043", "doc": "equivalent of a vector python", "code": "def norm_vec(vector):\n    \"\"\"Normalize the length of a vector to one\"\"\"\n    assert len(vector) == 3\n    v = np.array(vector)\n    return v/np.sqrt(np.sum(v**2))", "code_tokens": "def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )", "docstring_tokens": "Normalize the length of a vector to one", "label": 1}, {"idx": "cosqa-train-11044", "doc": "python getsystem up time", "code": "def _uptime_syllable():\n    \"\"\"Returns uptime in seconds or None, on Syllable.\"\"\"\n    global __boottime\n    try:\n        __boottime = os.stat('/dev/pty/mst/pty0').st_mtime\n        return time.time() - __boottime\n    except (NameError, OSError):\n        return None", "code_tokens": "def _uptime_syllable ( ) : global __boottime try : __boottime = os . stat ( '/dev/pty/mst/pty0' ) . st_mtime return time . time ( ) - __boottime except ( NameError , OSError ) : return None", "docstring_tokens": "Returns uptime in seconds or None on Syllable .", "label": 1}, {"idx": "cosqa-train-11045", "doc": "escape percent sign in python", "code": "def quote(s, unsafe='/'):\n    \"\"\"Pass in a dictionary that has unsafe characters as the keys, and the percent\n    encoded value as the value.\"\"\"\n    res = s.replace('%', '%25')\n    for c in unsafe:\n        res = res.replace(c, '%' + (hex(ord(c)).upper())[2:])\n    return res", "code_tokens": "def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res", "docstring_tokens": "Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value .", "label": 1}, {"idx": "cosqa-train-11046", "doc": "python gevent combine multiprocessing", "code": "def fetch_event(urls):\n    \"\"\"\n    This parallel fetcher uses gevent one uses gevent\n    \"\"\"\n    rs = (grequests.get(u) for u in urls)\n    return [content.json() for content in grequests.map(rs)]", "code_tokens": "def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]", "docstring_tokens": "This parallel fetcher uses gevent one uses gevent", "label": 1}, {"idx": "cosqa-train-11047", "doc": "excuting sql query from sqlalchemy in python", "code": "def commit(self, session=None):\n        \"\"\"Merge modified objects into parent transaction.\n\n        Once commited a transaction object is not usable anymore\n\n        :param:session: current sqlalchemy Session\n        \"\"\"\n        if self.__cleared:\n            return\n\n        if self._parent:\n            # nested transaction\n            self._commit_parent()\n        else:\n            self._commit_repository()\n        self._clear()", "code_tokens": "def commit ( self , session = None ) : if self . __cleared : return if self . _parent : # nested transaction self . _commit_parent ( ) else : self . _commit_repository ( ) self . _clear ( )", "docstring_tokens": "Merge modified objects into parent transaction .", "label": 1}, {"idx": "cosqa-train-11048", "doc": "python gevent wsgiserver multithread", "code": "def fetch_event(urls):\n    \"\"\"\n    This parallel fetcher uses gevent one uses gevent\n    \"\"\"\n    rs = (grequests.get(u) for u in urls)\n    return [content.json() for content in grequests.map(rs)]", "code_tokens": "def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]", "docstring_tokens": "This parallel fetcher uses gevent one uses gevent", "label": 1}, {"idx": "cosqa-train-11049", "doc": "export python graph to word document", "code": "def save_dot(self, fd):\n        \"\"\" Saves a representation of the case in the Graphviz DOT language.\n        \"\"\"\n        from pylon.io import DotWriter\n        DotWriter(self).write(fd)", "code_tokens": "def save_dot ( self , fd ) : from pylon . io import DotWriter DotWriter ( self ) . write ( fd )", "docstring_tokens": "Saves a representation of the case in the Graphviz DOT language .", "label": 1}, {"idx": "cosqa-train-11050", "doc": "python given date get first of month", "code": "def get_month_start(day=None):\n    \"\"\"Returns the first day of the given month.\"\"\"\n    day = add_timezone(day or datetime.date.today())\n    return day.replace(day=1)", "code_tokens": "def get_month_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( day = 1 )", "docstring_tokens": "Returns the first day of the given month .", "label": 1}, {"idx": "cosqa-train-11051", "doc": "export r data frame to python", "code": "def sav_to_pandas_rpy2(input_file):\n    \"\"\"\n    SPSS .sav files to Pandas DataFrame through Rpy2\n\n    :param input_file: string\n\n    :return:\n    \"\"\"\n    import pandas.rpy.common as com\n\n    w = com.robj.r('foreign::read.spss(\"%s\", to.data.frame=TRUE)' % input_file)\n    return com.convert_robj(w)", "code_tokens": "def sav_to_pandas_rpy2 ( input_file ) : import pandas . rpy . common as com w = com . robj . r ( 'foreign::read.spss(\"%s\", to.data.frame=TRUE)' % input_file ) return com . convert_robj ( w )", "docstring_tokens": "SPSS . sav files to Pandas DataFrame through Rpy2", "label": 1}, {"idx": "cosqa-train-11052", "doc": "python glm linear regression", "code": "def fit_linear(X, y):\n    \"\"\"\n    Uses OLS to fit the regression.\n    \"\"\"\n    model = linear_model.LinearRegression()\n    model.fit(X, y)\n    return model", "code_tokens": "def fit_linear ( X , y ) : model = linear_model . LinearRegression ( ) model . fit ( X , y ) return model", "docstring_tokens": "Uses OLS to fit the regression .", "label": 1}, {"idx": "cosqa-train-11053", "doc": "export sql view to excel python", "code": "def tab(self, output):\n        \"\"\"Output data in excel-compatible tab-delimited format\"\"\"\n        import csv\n        csvwriter = csv.writer(self.outfile, dialect=csv.excel_tab)\n        csvwriter.writerows(output)", "code_tokens": "def tab ( self , output ) : import csv csvwriter = csv . writer ( self . outfile , dialect = csv . excel_tab ) csvwriter . writerows ( output )", "docstring_tokens": "Output data in excel - compatible tab - delimited format", "label": 1}, {"idx": "cosqa-train-11054", "doc": "python global type hinting", "code": "def is_builtin_type(tp):\n    \"\"\"Checks if the given type is a builtin one.\n    \"\"\"\n    return hasattr(__builtins__, tp.__name__) and tp is getattr(__builtins__, tp.__name__)", "code_tokens": "def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )", "docstring_tokens": "Checks if the given type is a builtin one .", "label": 1}, {"idx": "cosqa-train-11055", "doc": "extract everthing before underscore python", "code": "def underscore(text):\n    \"\"\"Converts text that may be camelcased into an underscored format\"\"\"\n    return UNDERSCORE[1].sub(r'\\1_\\2', UNDERSCORE[0].sub(r'\\1_\\2', text)).lower()", "code_tokens": "def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\\1_\\2' , UNDERSCORE [ 0 ] . sub ( r'\\1_\\2' , text ) ) . lower ( )", "docstring_tokens": "Converts text that may be camelcased into an underscored format", "label": 1}, {"idx": "cosqa-train-11056", "doc": "python glpk read from lp file", "code": "def glpk_read_cplex(path):\n    \"\"\"Reads cplex file and returns glpk problem.\n\n    Returns\n    -------\n    glp_prob\n        A glpk problems (same type as returned by glp_create_prob)\n    \"\"\"\n    from swiglpk import glp_create_prob, glp_read_lp\n\n    problem = glp_create_prob()\n    glp_read_lp(problem, None, path)\n    return problem", "code_tokens": "def glpk_read_cplex ( path ) : from swiglpk import glp_create_prob , glp_read_lp problem = glp_create_prob ( ) glp_read_lp ( problem , None , path ) return problem", "docstring_tokens": "Reads cplex file and returns glpk problem .", "label": 1}, {"idx": "cosqa-train-11057", "doc": "extract keywords from text python", "code": "def extract_keywords_from_text(self, text):\n        \"\"\"Method to extract keywords from the text provided.\n\n        :param text: Text to extract keywords from, provided as a string.\n        \"\"\"\n        sentences = nltk.tokenize.sent_tokenize(text)\n        self.extract_keywords_from_sentences(sentences)", "code_tokens": "def extract_keywords_from_text ( self , text ) : sentences = nltk . tokenize . sent_tokenize ( text ) self . extract_keywords_from_sentences ( sentences )", "docstring_tokens": "Method to extract keywords from the text provided .", "label": 1}, {"idx": "cosqa-train-11058", "doc": "python gpio read realy state and toggle", "code": "def input(self,pin):\n        \"\"\"Read the specified pin and return HIGH/true if the pin is pulled high,\n        or LOW/false if pulled low.\n        \"\"\"\n        return self.mraa_gpio.Gpio.read(self.mraa_gpio.Gpio(pin))", "code_tokens": "def input ( self , pin ) : return self . mraa_gpio . Gpio . read ( self . mraa_gpio . Gpio ( pin ) )", "docstring_tokens": "Read the specified pin and return HIGH / true if the pin is pulled high or LOW / false if pulled low .", "label": 1}, {"idx": "cosqa-train-11059", "doc": "extract pure text from xml python", "code": "def _extract_node_text(node):\n    \"\"\"Extract text from a given lxml node.\"\"\"\n\n    texts = map(\n        six.text_type.strip, map(six.text_type, map(unescape, node.xpath(\".//text()\")))\n    )\n    return \" \".join(text for text in texts if text)", "code_tokens": "def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( \".//text()\" ) ) ) ) return \" \" . join ( text for text in texts if text )", "docstring_tokens": "Extract text from a given lxml node .", "label": 1}, {"idx": "cosqa-train-11060", "doc": "faster dot product python", "code": "def dot_product(self, other):\n        \"\"\" Return the dot product of the given vectors. \"\"\"\n        return self.x * other.x + self.y * other.y", "code_tokens": "def dot_product ( self , other ) : return self . x * other . x + self . y * other . y", "docstring_tokens": "Return the dot product of the given vectors .", "label": 1}, {"idx": "cosqa-train-11061", "doc": "python gzip unzip file", "code": "def _unzip_handle(handle):\n    \"\"\"Transparently unzip the file handle\"\"\"\n    if isinstance(handle, basestring):\n        handle = _gzip_open_filename(handle)\n    else:\n        handle = _gzip_open_handle(handle)\n    return handle", "code_tokens": "def _unzip_handle ( handle ) : if isinstance ( handle , basestring ) : handle = _gzip_open_filename ( handle ) else : handle = _gzip_open_handle ( handle ) return handle", "docstring_tokens": "Transparently unzip the file handle", "label": 1}, {"idx": "cosqa-train-11062", "doc": "fastest way to iterate over an iterator python", "code": "def peekiter(iterable):\n    \"\"\"Return first row and also iterable with same items as original\"\"\"\n    it = iter(iterable)\n    one = next(it)\n\n    def gen():\n        \"\"\"Generator that returns first and proxy other items from source\"\"\"\n        yield one\n        while True:\n            yield next(it)\n    return (one, gen())", "code_tokens": "def peekiter ( iterable ) : it = iter ( iterable ) one = next ( it ) def gen ( ) : \"\"\"Generator that returns first and proxy other items from source\"\"\" yield one while True : yield next ( it ) return ( one , gen ( ) )", "docstring_tokens": "Return first row and also iterable with same items as original", "label": 1}, {"idx": "cosqa-train-11063", "doc": "python help function signature", "code": "def help_for_command(command):\n    \"\"\"Get the help text (signature + docstring) for a command (function).\"\"\"\n    help_text = pydoc.text.document(command)\n    # remove backspaces\n    return re.subn('.\\\\x08', '', help_text)[0]", "code_tokens": "def help_for_command ( command ) : help_text = pydoc . text . document ( command ) # remove backspaces return re . subn ( '.\\\\x08' , '' , help_text ) [ 0 ]", "docstring_tokens": "Get the help text ( signature + docstring ) for a command ( function ) .", "label": 1}, {"idx": "cosqa-train-11064", "doc": "fcfs python with i/o", "code": "def main():\n    usage=\"\"\"\nUserspace ioctl example\n\n\"\"\" + Fuse.fusage\n    server = FiocFS(version=\"%prog \" + fuse.__version__,\n                     usage=usage,\n                     dash_s_do='setsingle')\n\n    server.parse(errex=1)\n    server.main()", "code_tokens": "def main ( ) : usage = \"\"\"\nUserspace ioctl example\n\n\"\"\" + Fuse . fusage server = FiocFS ( version = \"%prog \" + fuse . __version__ , usage = usage , dash_s_do = 'setsingle' ) server . parse ( errex = 1 ) server . main ( )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-11065", "doc": "python hierarchical clustering symmetric matrix", "code": "def hclust_linearize(U):\n    \"\"\"Sorts the rows of a matrix by hierarchical clustering.\n\n    Parameters:\n        U (ndarray) : matrix of data\n\n    Returns:\n        prm (ndarray) : permutation of the rows\n    \"\"\"\n\n    from scipy.cluster import hierarchy\n    Z = hierarchy.ward(U)\n    return hierarchy.leaves_list(hierarchy.optimal_leaf_ordering(Z, U))", "code_tokens": "def hclust_linearize ( U ) : from scipy . cluster import hierarchy Z = hierarchy . ward ( U ) return hierarchy . leaves_list ( hierarchy . optimal_leaf_ordering ( Z , U ) )", "docstring_tokens": "Sorts the rows of a matrix by hierarchical clustering .", "label": 1}, {"idx": "cosqa-train-11066", "doc": "fetch last 10 results from python list", "code": "def searchlast(self,n=10):\n        \"\"\"Return the last n results (or possibly less if not found). Note that the last results are not necessarily the best ones! Depending on the search type.\"\"\"            \n        solutions = deque([], n)\n        for solution in self:\n            solutions.append(solution)\n        return solutions", "code_tokens": "def searchlast ( self , n = 10 ) : solutions = deque ( [ ] , n ) for solution in self : solutions . append ( solution ) return solutions", "docstring_tokens": "Return the last n results ( or possibly less if not found ) . Note that the last results are not necessarily the best ones! Depending on the search type .", "label": 1}, {"idx": "cosqa-train-11067", "doc": "python hoe to check if query dict is empty", "code": "def check_empty_dict(GET_dict):\n    \"\"\"\n    Returns True if the GET querstring contains on values, but it can contain\n    empty keys.\n    This is better than doing not bool(request.GET) as an empty key will return\n    True\n    \"\"\"\n    empty = True\n    for k, v in GET_dict.items():\n        # Don't disable on p(age) or 'all' GET param\n        if v and k != 'p' and k != 'all':\n            empty = False\n    return empty", "code_tokens": "def check_empty_dict ( GET_dict ) : empty = True for k , v in GET_dict . items ( ) : # Don't disable on p(age) or 'all' GET param if v and k != 'p' and k != 'all' : empty = False return empty", "docstring_tokens": "Returns True if the GET querstring contains on values but it can contain empty keys . This is better than doing not bool ( request . GET ) as an empty key will return True", "label": 1}, {"idx": "cosqa-train-11068", "doc": "fetch the background color of the excel cell into a list using the python", "code": "def _get_background_color(self):\n        \"\"\"Returns background color rgb tuple of right line\"\"\"\n\n        color = self.cell_attributes[self.key][\"bgcolor\"]\n        return tuple(c / 255.0 for c in color_pack2rgb(color))", "code_tokens": "def _get_background_color ( self ) : color = self . cell_attributes [ self . key ] [ \"bgcolor\" ] return tuple ( c / 255.0 for c in color_pack2rgb ( color ) )", "docstring_tokens": "Returns background color rgb tuple of right line", "label": 1}, {"idx": "cosqa-train-11069", "doc": "python how check if float", "code": "def clean_float(v):\n    \"\"\"Remove commas from a float\"\"\"\n\n    if v is None or not str(v).strip():\n        return None\n\n    return float(str(v).replace(',', ''))", "code_tokens": "def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )", "docstring_tokens": "Remove commas from a float", "label": 1}, {"idx": "cosqa-train-11070", "doc": "fetchall result as dict postgresql python", "code": "def _dictfetchall(self, cursor):\n        \"\"\" Return all rows from a cursor as a dict. \"\"\"\n        columns = [col[0] for col in cursor.description]\n        return [\n            dict(zip(columns, row))\n            for row in cursor.fetchall()\n        ]", "code_tokens": "def _dictfetchall ( self , cursor ) : columns = [ col [ 0 ] for col in cursor . description ] return [ dict ( zip ( columns , row ) ) for row in cursor . fetchall ( ) ]", "docstring_tokens": "Return all rows from a cursor as a dict .", "label": 1}, {"idx": "cosqa-train-11071", "doc": "python how ot use daemon to exit", "code": "def fast_exit(code):\n    \"\"\"Exit without garbage collection, this speeds up exit by about 10ms for\n    things like bash completion.\n    \"\"\"\n    sys.stdout.flush()\n    sys.stderr.flush()\n    os._exit(code)", "code_tokens": "def fast_exit ( code ) : sys . stdout . flush ( ) sys . stderr . flush ( ) os . _exit ( code )", "docstring_tokens": "Exit without garbage collection this speeds up exit by about 10ms for things like bash completion .", "label": 1}, {"idx": "cosqa-train-11072", "doc": "fft low frequency signal python", "code": "def fft_freqs(n_fft, fs):\n    \"\"\"Return frequencies for DFT\n\n    Parameters\n    ----------\n    n_fft : int\n        Number of points in the FFT.\n    fs : float\n        The sampling rate.\n    \"\"\"\n    return np.arange(0, (n_fft // 2 + 1)) / float(n_fft) * float(fs)", "code_tokens": "def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )", "docstring_tokens": "Return frequencies for DFT", "label": 1}, {"idx": "cosqa-train-11073", "doc": "python how to analyze stdout line by line", "code": "def report_stdout(host, stdout):\n    \"\"\"Take a stdout and print it's lines to output if lines are present.\n\n    :param host: the host where the process is running\n    :type host: str\n    :param stdout: the std out of that process\n    :type stdout: paramiko.channel.Channel\n    \"\"\"\n    lines = stdout.readlines()\n    if lines:\n        print(\"STDOUT from {host}:\".format(host=host))\n        for line in lines:\n            print(line.rstrip(), file=sys.stdout)", "code_tokens": "def report_stdout ( host , stdout ) : lines = stdout . readlines ( ) if lines : print ( \"STDOUT from {host}:\" . format ( host = host ) ) for line in lines : print ( line . rstrip ( ) , file = sys . stdout )", "docstring_tokens": "Take a stdout and print it s lines to output if lines are present .", "label": 1}, {"idx": "cosqa-train-11074", "doc": "fileconf not applied python logging", "code": "def load_config(filename=\"logging.ini\", *args, **kwargs):\n    \"\"\"\n    Load logger config from file\n    \n    Keyword arguments:\n    filename -- configuration filename (Default: \"logging.ini\")\n    *args -- options passed to fileConfig\n    **kwargs -- options passed to fileConfigg\n    \n    \"\"\"\n    logging.config.fileConfig(filename, *args, **kwargs)", "code_tokens": "def load_config ( filename = \"logging.ini\" , * args , * * kwargs ) : logging . config . fileConfig ( filename , * args , * * kwargs )", "docstring_tokens": "Load logger config from file Keyword arguments : filename -- configuration filename ( Default : logging . ini ) * args -- options passed to fileConfig ** kwargs -- options passed to fileConfigg", "label": 1}, {"idx": "cosqa-train-11075", "doc": "python how to call sed", "code": "def sed(match, replacement, path, modifiers=\"\"):\n    \"\"\"\n    Perform sed text substitution.\n    \"\"\"\n    cmd = \"sed -r -i 's/%s/%s/%s' %s\" % (match, replacement, modifiers, path)\n\n    process = Subprocess(cmd, shell=True)\n    ret, out, err = process.run(timeout=60)\n    if ret:\n        raise SubprocessError(\"Sed command failed!\")", "code_tokens": "def sed ( match , replacement , path , modifiers = \"\" ) : cmd = \"sed -r -i 's/%s/%s/%s' %s\" % ( match , replacement , modifiers , path ) process = Subprocess ( cmd , shell = True ) ret , out , err = process . run ( timeout = 60 ) if ret : raise SubprocessError ( \"Sed command failed!\" )", "docstring_tokens": "Perform sed text substitution .", "label": 1}, {"idx": "cosqa-train-11076", "doc": "filter a dictionary in python and only return the key", "code": "def filter_dict(d, keys):\n    \"\"\"\n    Creates a new dict from an existing dict that only has the given keys\n    \"\"\"\n    return {k: v for k, v in d.items() if k in keys}", "code_tokens": "def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "docstring_tokens": "Creates a new dict from an existing dict that only has the given keys", "label": 1}, {"idx": "cosqa-train-11077", "doc": "python how to change max line length", "code": "def _multiline_width(multiline_s, line_width_fn=len):\n    \"\"\"Visible width of a potentially multiline content.\"\"\"\n    return max(map(line_width_fn, re.split(\"[\\r\\n]\", multiline_s)))", "code_tokens": "def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( \"[\\r\\n]\" , multiline_s ) ) )", "docstring_tokens": "Visible width of a potentially multiline content .", "label": 0}, {"idx": "cosqa-train-11078", "doc": "filter unique items in python", "code": "def unique(iterable):\n    \"\"\"Filter out duplicate items from an iterable\"\"\"\n    seen = set()\n    for item in iterable:\n        if item not in seen:\n            seen.add(item)\n            yield item", "code_tokens": "def unique ( iterable ) : seen = set ( ) for item in iterable : if item not in seen : seen . add ( item ) yield item", "docstring_tokens": "Filter out duplicate items from an iterable", "label": 1}, {"idx": "cosqa-train-11079", "doc": "python how to check a process is running", "code": "def is_running(self):\n        \"\"\"Returns a bool determining if the process is in a running state or\n        not\n\n        :rtype: bool\n\n        \"\"\"\n        return self.state in [self.STATE_IDLE, self.STATE_ACTIVE,\n                              self.STATE_SLEEPING]", "code_tokens": "def is_running ( self ) : return self . state in [ self . STATE_IDLE , self . STATE_ACTIVE , self . STATE_SLEEPING ]", "docstring_tokens": "Returns a bool determining if the process is in a running state or not", "label": 1}, {"idx": "cosqa-train-11080", "doc": "finding max using lambda in python", "code": "def argmax(l,f=None):\n    \"\"\"http://stackoverflow.com/questions/5098580/implementing-argmax-in-python\"\"\"\n    if f:\n        l = [f(i) for i in l]\n    return max(enumerate(l), key=lambda x:x[1])[0]", "code_tokens": "def argmax ( l , f = None ) : if f : l = [ f ( i ) for i in l ] return max ( enumerate ( l ) , key = lambda x : x [ 1 ] ) [ 0 ]", "docstring_tokens": "http : // stackoverflow . com / questions / 5098580 / implementing - argmax - in - python", "label": 1}, {"idx": "cosqa-train-11081", "doc": "python how to check if a variable is iterable", "code": "def is_iterable_but_not_string(obj):\n    \"\"\"\n    Determine whether or not obj is iterable but not a string (eg, a list, set, tuple etc).\n    \"\"\"\n    return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)", "code_tokens": "def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )", "docstring_tokens": "Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) .", "label": 1}, {"idx": "cosqa-train-11082", "doc": "finding the largest key in a dictionary python", "code": "def find_largest_contig(contig_lengths_dict):\n    \"\"\"\n    Determine the largest contig for each strain\n    :param contig_lengths_dict: dictionary of strain name: reverse-sorted list of all contig lengths\n    :return: longest_contig_dict: dictionary of strain name: longest contig\n    \"\"\"\n    # Initialise the dictionary\n    longest_contig_dict = dict()\n    for file_name, contig_lengths in contig_lengths_dict.items():\n        # As the list is sorted in descending order, the largest contig is the first entry in the list\n        longest_contig_dict[file_name] = contig_lengths[0]\n    return longest_contig_dict", "code_tokens": "def find_largest_contig ( contig_lengths_dict ) : # Initialise the dictionary longest_contig_dict = dict ( ) for file_name , contig_lengths in contig_lengths_dict . items ( ) : # As the list is sorted in descending order, the largest contig is the first entry in the list longest_contig_dict [ file_name ] = contig_lengths [ 0 ] return longest_contig_dict", "docstring_tokens": "Determine the largest contig for each strain : param contig_lengths_dict : dictionary of strain name : reverse - sorted list of all contig lengths : return : longest_contig_dict : dictionary of strain name : longest contig", "label": 1}, {"idx": "cosqa-train-11083", "doc": "python how to check if an attribute exists", "code": "def has_attribute(module_name, attribute_name):\n    \"\"\"Is this attribute present?\"\"\"\n    init_file = '%s/__init__.py' % module_name\n    return any(\n        [attribute_name in init_line for init_line in open(init_file).readlines()]\n    )", "code_tokens": "def has_attribute ( module_name , attribute_name ) : init_file = '%s/__init__.py' % module_name return any ( [ attribute_name in init_line for init_line in open ( init_file ) . readlines ( ) ] )", "docstring_tokens": "Is this attribute present?", "label": 1}, {"idx": "cosqa-train-11084", "doc": "finding the median of an even list in python", "code": "def get_median(temp_list):\n    \"\"\"Return median\n    \"\"\"\n    num = len(temp_list)\n    temp_list.sort()\n    print(temp_list)\n    if num % 2 == 0:\n        median = (temp_list[int(num/2)] + temp_list[int(num/2) - 1]) / 2\n    else:\n        median = temp_list[int(num/2)]\n    return median", "code_tokens": "def get_median ( temp_list ) : num = len ( temp_list ) temp_list . sort ( ) print ( temp_list ) if num % 2 == 0 : median = ( temp_list [ int ( num / 2 ) ] + temp_list [ int ( num / 2 ) - 1 ] ) / 2 else : median = temp_list [ int ( num / 2 ) ] return median", "docstring_tokens": "Return median", "label": 1}, {"idx": "cosqa-train-11085", "doc": "python how to check tree node size", "code": "def num_leaves(tree):\n    \"\"\"Determine the number of leaves in a tree\"\"\"\n    if tree.is_leaf:\n        return 1\n    else:\n        return num_leaves(tree.left_child) + num_leaves(tree.right_child)", "code_tokens": "def num_leaves ( tree ) : if tree . is_leaf : return 1 else : return num_leaves ( tree . left_child ) + num_leaves ( tree . right_child )", "docstring_tokens": "Determine the number of leaves in a tree", "label": 1}, {"idx": "cosqa-train-11086", "doc": "finding the method name python", "code": "def FindMethodByName(self, name):\n    \"\"\"Searches for the specified method, and returns its descriptor.\"\"\"\n    for method in self.methods:\n      if name == method.name:\n        return method\n    return None", "code_tokens": "def FindMethodByName ( self , name ) : for method in self . methods : if name == method . name : return method return None", "docstring_tokens": "Searches for the specified method and returns its descriptor .", "label": 1}, {"idx": "cosqa-train-11087", "doc": "python how to chunk a large number into groups of smaller ones", "code": "def most_even(number, group):\n    \"\"\"Divide a number into a list of numbers as even as possible.\"\"\"\n    count, rest = divmod(number, group)\n    counts = zip_longest([count] * group, [1] * rest, fillvalue=0)\n    chunks = [sum(one) for one in counts]\n    logging.debug('chunks: %s', chunks)\n    return chunks", "code_tokens": "def most_even ( number , group ) : count , rest = divmod ( number , group ) counts = zip_longest ( [ count ] * group , [ 1 ] * rest , fillvalue = 0 ) chunks = [ sum ( one ) for one in counts ] logging . debug ( 'chunks: %s' , chunks ) return chunks", "docstring_tokens": "Divide a number into a list of numbers as even as possible .", "label": 1}, {"idx": "cosqa-train-11088", "doc": "finding width of expanded python tkinter widget", "code": "def count(self):\n        \"\"\"\n        Returns the number of widgets currently displayed (takes child splits\n        into account).\n        \"\"\"\n        c = self.main_tab_widget.count()\n        for child in self.child_splitters:\n            c += child.count()\n        return c", "code_tokens": "def count ( self ) : c = self . main_tab_widget . count ( ) for child in self . child_splitters : c += child . count ( ) return c", "docstring_tokens": "Returns the number of widgets currently displayed ( takes child splits into account ) .", "label": 1}, {"idx": "cosqa-train-11089", "doc": "python how to correctly close a socket", "code": "def socket_close(self):\n        \"\"\"Close our socket.\"\"\"\n        if self.sock != NC.INVALID_SOCKET:\n            self.sock.close()\n        self.sock = NC.INVALID_SOCKET", "code_tokens": "def socket_close ( self ) : if self . sock != NC . INVALID_SOCKET : self . sock . close ( ) self . sock = NC . INVALID_SOCKET", "docstring_tokens": "Close our socket .", "label": 1}, {"idx": "cosqa-train-11090", "doc": "fitting data into equation using python", "code": "def apply_fit(xy,coeffs):\n    \"\"\" Apply the coefficients from a linear fit to\n        an array of x,y positions.\n\n        The coeffs come from the 'coeffs' member of the\n        'fit_arrays()' output.\n    \"\"\"\n    x_new = coeffs[0][2] + coeffs[0][0]*xy[:,0] + coeffs[0][1]*xy[:,1]\n    y_new = coeffs[1][2] + coeffs[1][0]*xy[:,0] + coeffs[1][1]*xy[:,1]\n\n    return x_new,y_new", "code_tokens": "def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "docstring_tokens": "Apply the coefficients from a linear fit to an array of x y positions .", "label": 0}, {"idx": "cosqa-train-11091", "doc": "python how to create a iterable", "code": "def force_iterable(f):\n    \"\"\"Will make any functions return an iterable objects by wrapping its result in a list.\"\"\"\n    def wrapper(*args, **kwargs):\n        r = f(*args, **kwargs)\n        if hasattr(r, '__iter__'):\n            return r\n        else:\n            return [r]\n    return wrapper", "code_tokens": "def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper", "docstring_tokens": "Will make any functions return an iterable objects by wrapping its result in a list .", "label": 1}, {"idx": "cosqa-train-11092", "doc": "fix bad urls python", "code": "def url_fix_common_typos (url):\n    \"\"\"Fix common typos in given URL like forgotten colon.\"\"\"\n    if url.startswith(\"http//\"):\n        url = \"http://\" + url[6:]\n    elif url.startswith(\"https//\"):\n        url = \"https://\" + url[7:]\n    return url", "code_tokens": "def url_fix_common_typos ( url ) : if url . startswith ( \"http//\" ) : url = \"http://\" + url [ 6 : ] elif url . startswith ( \"https//\" ) : url = \"https://\" + url [ 7 : ] return url", "docstring_tokens": "Fix common typos in given URL like forgotten colon .", "label": 1}, {"idx": "cosqa-train-11093", "doc": "python how to create an object with an id that incrments everytime it is created", "code": "def _initialize_id(self):\n        \"\"\"Initializes the id of the instance.\"\"\"\n        self.id = str(self.db.incr(self._key['id']))", "code_tokens": "def _initialize_id ( self ) : self . id = str ( self . db . incr ( self . _key [ 'id' ] ) )", "docstring_tokens": "Initializes the id of the instance .", "label": 1}, {"idx": "cosqa-train-11094", "doc": "flask python create one table sqlalchemy", "code": "def create_db(app, appbuilder):\n    \"\"\"\n        Create all your database objects (SQLAlchemy specific).\n    \"\"\"\n    from flask_appbuilder.models.sqla import Base\n\n    _appbuilder = import_application(app, appbuilder)\n    engine = _appbuilder.get_session.get_bind(mapper=None, clause=None)\n    Base.metadata.create_all(engine)\n    click.echo(click.style(\"DB objects created\", fg=\"green\"))", "code_tokens": "def create_db ( app , appbuilder ) : from flask_appbuilder . models . sqla import Base _appbuilder = import_application ( app , appbuilder ) engine = _appbuilder . get_session . get_bind ( mapper = None , clause = None ) Base . metadata . create_all ( engine ) click . echo ( click . style ( \"DB objects created\" , fg = \"green\" ) )", "docstring_tokens": "Create all your database objects ( SQLAlchemy specific ) .", "label": 1}, {"idx": "cosqa-train-11095", "doc": "python how to define an alias", "code": "def call_alias(self, alias, rest=''):\n        \"\"\"Call an alias given its name and the rest of the line.\"\"\"\n        cmd = self.transform_alias(alias, rest)\n        try:\n            self.shell.system(cmd)\n        except:\n            self.shell.showtraceback()", "code_tokens": "def call_alias ( self , alias , rest = '' ) : cmd = self . transform_alias ( alias , rest ) try : self . shell . system ( cmd ) except : self . shell . showtraceback ( )", "docstring_tokens": "Call an alias given its name and the rest of the line .", "label": 1}, {"idx": "cosqa-train-11096", "doc": "flatten list of lists python numpy", "code": "def flatten_array(grid):\n    \"\"\"\n    Takes a multi-dimensional array and returns a 1 dimensional array with the\n    same contents.\n    \"\"\"\n    grid = [grid[i][j] for i in range(len(grid)) for j in range(len(grid[i]))]\n    while type(grid[0]) is list:\n        grid = flatten_array(grid)\n    return grid", "code_tokens": "def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid", "docstring_tokens": "Takes a multi - dimensional array and returns a 1 dimensional array with the same contents .", "label": 1}, {"idx": "cosqa-train-11097", "doc": "python how to delete all tables in mysql database", "code": "def delete_all_from_db():\n    \"\"\"Clear the database.\n\n    Used for testing and debugging.\n\n    \"\"\"\n    # The models.CASCADE property is set on all ForeignKey fields, so tables can\n    # be deleted in any order without breaking constraints.\n    for model in django.apps.apps.get_models():\n        model.objects.all().delete()", "code_tokens": "def delete_all_from_db ( ) : # The models.CASCADE property is set on all ForeignKey fields, so tables can # be deleted in any order without breaking constraints. for model in django . apps . apps . get_models ( ) : model . objects . all ( ) . delete ( )", "docstring_tokens": "Clear the database .", "label": 1}, {"idx": "cosqa-train-11098", "doc": "floyd python not found", "code": "def version():\n    \"\"\"\n    View the current version of the CLI.\n    \"\"\"\n    import pkg_resources\n    version = pkg_resources.require(PROJECT_NAME)[0].version\n    floyd_logger.info(version)", "code_tokens": "def version ( ) : import pkg_resources version = pkg_resources . require ( PROJECT_NAME ) [ 0 ] . version floyd_logger . info ( version )", "docstring_tokens": "View the current version of the CLI .", "label": 0}, {"idx": "cosqa-train-11099", "doc": "python how to delete columns", "code": "def remove_columns(self, data, columns):\n        \"\"\" This method removes columns in data\n\n        :param data: original Pandas dataframe\n        :param columns: list of columns to remove\n        :type data: pandas.DataFrame\n        :type columns: list of strings\n\n        :returns: Pandas dataframe with removed columns\n        :rtype: pandas.DataFrame\n        \"\"\"\n\n        for column in columns:\n            if column in data.columns:\n                data = data.drop(column, axis=1)\n\n        return data", "code_tokens": "def remove_columns ( self , data , columns ) : for column in columns : if column in data . columns : data = data . drop ( column , axis = 1 ) return data", "docstring_tokens": "This method removes columns in data", "label": 1}, {"idx": "cosqa-train-11100", "doc": "force a file to delete in python", "code": "def safe_delete(filename):\n  \"\"\"Delete a file safely. If it's not present, no-op.\"\"\"\n  try:\n    os.unlink(filename)\n  except OSError as e:\n    if e.errno != errno.ENOENT:\n      raise", "code_tokens": "def safe_delete ( filename ) : try : os . unlink ( filename ) except OSError as e : if e . errno != errno . ENOENT : raise", "docstring_tokens": "Delete a file safely . If it s not present no - op .", "label": 1}, {"idx": "cosqa-train-11101", "doc": "python how to dump to json file", "code": "def save(self, fname):\n        \"\"\" Saves the dictionary in json format\n        :param fname: file to save to\n        \"\"\"\n        with open(fname, 'wb') as f:\n            json.dump(self, f)", "code_tokens": "def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )", "docstring_tokens": "Saves the dictionary in json format : param fname : file to save to", "label": 1}, {"idx": "cosqa-train-11102", "doc": "fork and forking in python", "code": "def go_to_background():\n    \"\"\" Daemonize the running process. \"\"\"\n    try:\n        if os.fork():\n            sys.exit()\n    except OSError as errmsg:\n        LOGGER.error('Fork failed: {0}'.format(errmsg))\n        sys.exit('Fork failed')", "code_tokens": "def go_to_background ( ) : try : if os . fork ( ) : sys . exit ( ) except OSError as errmsg : LOGGER . error ( 'Fork failed: {0}' . format ( errmsg ) ) sys . exit ( 'Fork failed' )", "docstring_tokens": "Daemonize the running process .", "label": 1}, {"idx": "cosqa-train-11103", "doc": "python how to equally space points in an ellipse", "code": "def create_ellipse(width,height,angle):\n    \"\"\"Create parametric ellipse from 200 points.\"\"\"\n    angle = angle / 180.0 * np.pi\n    thetas = np.linspace(0,2*np.pi,200)\n    a = width / 2.0\n    b = height / 2.0\n\n    x = a*np.cos(thetas)*np.cos(angle) - b*np.sin(thetas)*np.sin(angle)\n    y = a*np.cos(thetas)*np.sin(angle) + b*np.sin(thetas)*np.cos(angle)\n    z = np.zeros(thetas.shape)\n    return np.vstack((x,y,z)).T", "code_tokens": "def create_ellipse ( width , height , angle ) : angle = angle / 180.0 * np . pi thetas = np . linspace ( 0 , 2 * np . pi , 200 ) a = width / 2.0 b = height / 2.0 x = a * np . cos ( thetas ) * np . cos ( angle ) - b * np . sin ( thetas ) * np . sin ( angle ) y = a * np . cos ( thetas ) * np . sin ( angle ) + b * np . sin ( thetas ) * np . cos ( angle ) z = np . zeros ( thetas . shape ) return np . vstack ( ( x , y , z ) ) . T", "docstring_tokens": "Create parametric ellipse from 200 points .", "label": 1}, {"idx": "cosqa-train-11104", "doc": "frequency listing of characters in string on python", "code": "def entropy(string):\n    \"\"\"Compute entropy on the string\"\"\"\n    p, lns = Counter(string), float(len(string))\n    return -sum(count/lns * math.log(count/lns, 2) for count in p.values())", "code_tokens": "def entropy ( string ) : p , lns = Counter ( string ) , float ( len ( string ) ) return - sum ( count / lns * math . log ( count / lns , 2 ) for count in p . values ( ) )", "docstring_tokens": "Compute entropy on the string", "label": 0}, {"idx": "cosqa-train-11105", "doc": "python how to evaluate bound methods", "code": "def __is_bound_method(method):\n    \"\"\"Return ``True`` if the `method` is a bound method (attached to an class\n    instance.\n\n    Args:\n        method: A method or function type object.\n    \"\"\"\n    if not(hasattr(method, \"__func__\") and hasattr(method, \"__self__\")):\n        return False\n\n    # Bound methods have a __self__ attribute pointing to the owner instance\n    return six.get_method_self(method) is not None", "code_tokens": "def __is_bound_method ( method ) : if not ( hasattr ( method , \"__func__\" ) and hasattr ( method , \"__self__\" ) ) : return False # Bound methods have a __self__ attribute pointing to the owner instance return six . get_method_self ( method ) is not None", "docstring_tokens": "Return True if the method is a bound method ( attached to an class instance .", "label": 1}, {"idx": "cosqa-train-11106", "doc": "from staticmethod get function python", "code": "def static_method(cls, f):\n        \"\"\"Decorator which dynamically binds static methods to the model for later use.\"\"\"\n        setattr(cls, f.__name__, staticmethod(f))\n        return f", "code_tokens": "def static_method ( cls , f ) : setattr ( cls , f . __name__ , staticmethod ( f ) ) return f", "docstring_tokens": "Decorator which dynamically binds static methods to the model for later use .", "label": 1}, {"idx": "cosqa-train-11107", "doc": "python how to format a time amount", "code": "def format_time(time):\n    \"\"\" Formats the given time into HH:MM:SS \"\"\"\n    h, r = divmod(time / 1000, 3600)\n    m, s = divmod(r, 60)\n\n    return \"%02d:%02d:%02d\" % (h, m, s)", "code_tokens": "def format_time ( time ) : h , r = divmod ( time / 1000 , 3600 ) m , s = divmod ( r , 60 ) return \"%02d:%02d:%02d\" % ( h , m , s )", "docstring_tokens": "Formats the given time into HH : MM : SS", "label": 1}, {"idx": "cosqa-train-11108", "doc": "from string to date format in python", "code": "def string_to_date(value):\n    \"\"\"\n    Return a Python date that corresponds to the specified string\n    representation.\n\n    @param value: string representation of a date.\n\n    @return: an instance ``datetime.datetime`` represented by the string.\n    \"\"\"\n    if isinstance(value, datetime.date):\n        return value\n\n    return dateutil.parser.parse(value).date()", "code_tokens": "def string_to_date ( value ) : if isinstance ( value , datetime . date ) : return value return dateutil . parser . parse ( value ) . date ( )", "docstring_tokens": "Return a Python date that corresponds to the specified string representation .", "label": 1}, {"idx": "cosqa-train-11109", "doc": "python how to get data directory", "code": "def data_directory():\n    \"\"\"Return the absolute path to the directory containing the package data.\"\"\"\n    package_directory = os.path.abspath(os.path.dirname(__file__))\n    return os.path.join(package_directory, \"data\")", "code_tokens": "def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , \"data\" )", "docstring_tokens": "Return the absolute path to the directory containing the package data .", "label": 1}, {"idx": "cosqa-train-11110", "doc": "fromtimestamp python time zone", "code": "def fromtimestamp(cls, timestamp):\n    \"\"\"Returns a datetime object of a given timestamp (in local tz).\"\"\"\n    d = cls.utcfromtimestamp(timestamp)\n    return d.astimezone(localtz())", "code_tokens": "def fromtimestamp ( cls , timestamp ) : d = cls . utcfromtimestamp ( timestamp ) return d . astimezone ( localtz ( ) )", "docstring_tokens": "Returns a datetime object of a given timestamp ( in local tz ) .", "label": 1}, {"idx": "cosqa-train-11111", "doc": "python how to get dimension of list of list", "code": "def get_list_dimensions(_list):\n    \"\"\"\n    Takes a nested list and returns the size of each dimension followed\n    by the element type in the list\n    \"\"\"\n    if isinstance(_list, list) or isinstance(_list, tuple):\n        return [len(_list)] + get_list_dimensions(_list[0])\n    return []", "code_tokens": "def get_list_dimensions ( _list ) : if isinstance ( _list , list ) or isinstance ( _list , tuple ) : return [ len ( _list ) ] + get_list_dimensions ( _list [ 0 ] ) return [ ]", "docstring_tokens": "Takes a nested list and returns the size of each dimension followed by the element type in the list", "label": 1}, {"idx": "cosqa-train-11112", "doc": "function python leap year boolean", "code": "def _is_leap_year(year):\n    \"\"\"Determine if a year is leap year.\n\n    Parameters\n    ----------\n    year : numeric\n\n    Returns\n    -------\n    isleap : array of bools\n    \"\"\"\n    isleap = ((np.mod(year, 4) == 0) &\n              ((np.mod(year, 100) != 0) | (np.mod(year, 400) == 0)))\n    return isleap", "code_tokens": "def _is_leap_year ( year ) : isleap = ( ( np . mod ( year , 4 ) == 0 ) & ( ( np . mod ( year , 100 ) != 0 ) | ( np . mod ( year , 400 ) == 0 ) ) ) return isleap", "docstring_tokens": "Determine if a year is leap year .", "label": 1}, {"idx": "cosqa-train-11113", "doc": "python how to get extension from list of files", "code": "def glob_by_extensions(directory, extensions):\n    \"\"\" Returns files matched by all extensions in the extensions list \"\"\"\n    directorycheck(directory)\n    files = []\n    xt = files.extend\n    for ex in extensions:\n        xt(glob.glob('{0}/*.{1}'.format(directory, ex)))\n    return files", "code_tokens": "def glob_by_extensions ( directory , extensions ) : directorycheck ( directory ) files = [ ] xt = files . extend for ex in extensions : xt ( glob . glob ( '{0}/*.{1}' . format ( directory , ex ) ) ) return files", "docstring_tokens": "Returns files matched by all extensions in the extensions list", "label": 1}, {"idx": "cosqa-train-11114", "doc": "function that accepts two bitstrings and returns the xor value python", "code": "def xor_bytes(a, b):\n    \"\"\"\n    Calculate the byte wise exclusive of of two :class:`bytes` objects\n    of the same length.\n    \"\"\"\n    assert len(a) == len(b)\n    return bytes(map(operator.xor, a, b))", "code_tokens": "def xor_bytes ( a , b ) : assert len ( a ) == len ( b ) return bytes ( map ( operator . xor , a , b ) )", "docstring_tokens": "Calculate the byte wise exclusive of of two : class : bytes objects of the same length .", "label": 1}, {"idx": "cosqa-train-11115", "doc": "python how to get max value of a column", "code": "def get_max(qs, field):\n    \"\"\"\n    get max for queryset.\n\n    qs: queryset\n    field: The field name to max.\n    \"\"\"\n    max_field = '%s__max' % field\n    num = qs.aggregate(Max(field))[max_field]\n    return num if num else 0", "code_tokens": "def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0", "docstring_tokens": "get max for queryset .", "label": 1}, {"idx": "cosqa-train-11116", "doc": "gaussian density function in python", "code": "def gauss_pdf(x, mu, sigma):\n    \"\"\"Normalized Gaussian\"\"\"\n    return 1 / np.sqrt(2 * np.pi) / sigma * np.exp(-(x - mu) ** 2 / 2. / sigma ** 2)", "code_tokens": "def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )", "docstring_tokens": "Normalized Gaussian", "label": 0}, {"idx": "cosqa-train-11117", "doc": "python how to get memory utilization of a process", "code": "def get_memory_usage():\n    \"\"\"Gets RAM memory usage\n\n    :return: MB of memory used by this process\n    \"\"\"\n    process = psutil.Process(os.getpid())\n    mem = process.memory_info().rss\n    return mem / (1024 * 1024)", "code_tokens": "def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )", "docstring_tokens": "Gets RAM memory usage", "label": 1}, {"idx": "cosqa-train-11118", "doc": "generat a key with commants in python", "code": "def unit_key_from_name(name):\n  \"\"\"Return a legal python name for the given name for use as a unit key.\"\"\"\n  result = name\n\n  for old, new in six.iteritems(UNIT_KEY_REPLACEMENTS):\n    result = result.replace(old, new)\n\n  # Collapse redundant underscores and convert to uppercase.\n  result = re.sub(r'_+', '_', result.upper())\n\n  return result", "code_tokens": "def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result", "docstring_tokens": "Return a legal python name for the given name for use as a unit key .", "label": 0}, {"idx": "cosqa-train-11119", "doc": "python how to get name of method being run", "code": "def get_method_from_module(module_path, method_name):\n    \"\"\" from a valid python module path, get the run method name passed \"\"\"\n    top_module = __import__(module_path)\n\n    module = top_module\n    # we tunnel down until we find the module we want\n    for submodule_name in module_path.split('.')[1:]:\n        module = getattr(module, submodule_name)\n\n    assert hasattr(module, method_name), \\\n        \"unable to find method {0} from module {1}. does the method exist?\".format(method_name, module_path)\n    return getattr(module, method_name)", "code_tokens": "def get_method_from_module ( module_path , method_name ) : top_module = __import__ ( module_path ) module = top_module # we tunnel down until we find the module we want for submodule_name in module_path . split ( '.' ) [ 1 : ] : module = getattr ( module , submodule_name ) assert hasattr ( module , method_name ) , \"unable to find method {0} from module {1}. does the method exist?\" . format ( method_name , module_path ) return getattr ( module , method_name )", "docstring_tokens": "from a valid python module path get the run method name passed", "label": 1}, {"idx": "cosqa-train-11120", "doc": "generate custom colors with python using hsv", "code": "def hex_to_hsv(color):\n    \"\"\"\n    Converts from hex to hsv\n\n    Parameters:\n    -----------\n            color : string\n                    Color representation on color\n\n    Example:\n            hex_to_hsv('#ff9933')\n    \"\"\"\n    color = normalize(color)\n    color = color[1:]\n    # color=tuple(ord(c)/255.0 for c in color.decode('hex'))\n    color = (int(color[0:2], base=16) / 255.0, int(color[2:4],\n                                                   base=16) / 255.0, int(color[4:6], base=16) / 255.0)\n    return colorsys.rgb_to_hsv(*color)", "code_tokens": "def hex_to_hsv ( color ) : color = normalize ( color ) color = color [ 1 : ] # color=tuple(ord(c)/255.0 for c in color.decode('hex')) color = ( int ( color [ 0 : 2 ] , base = 16 ) / 255.0 , int ( color [ 2 : 4 ] , base = 16 ) / 255.0 , int ( color [ 4 : 6 ] , base = 16 ) / 255.0 ) return colorsys . rgb_to_hsv ( * color )", "docstring_tokens": "Converts from hex to hsv", "label": 1}, {"idx": "cosqa-train-11121", "doc": "python how to get object type", "code": "def type(self):\n        \"\"\"Returns type of the data for the given FeatureType.\"\"\"\n        if self is FeatureType.TIMESTAMP:\n            return list\n        if self is FeatureType.BBOX:\n            return BBox\n        return dict", "code_tokens": "def type ( self ) : if self is FeatureType . TIMESTAMP : return list if self is FeatureType . BBOX : return BBox return dict", "docstring_tokens": "Returns type of the data for the given FeatureType .", "label": 1}, {"idx": "cosqa-train-11122", "doc": "generate filenames given pattern python", "code": "def match_files(files, pattern: Pattern):\n    \"\"\"Yields file name if matches a regular expression pattern.\"\"\"\n\n    for name in files:\n        if re.match(pattern, name):\n            yield name", "code_tokens": "def match_files ( files , pattern : Pattern ) : for name in files : if re . match ( pattern , name ) : yield name", "docstring_tokens": "Yields file name if matches a regular expression pattern .", "label": 1}, {"idx": "cosqa-train-11123", "doc": "python how to get parent path", "code": "def grandparent_path(self):\n        \"\"\" return grandparent's path string \"\"\"\n        return os.path.basename(os.path.join(self.path, '../..'))", "code_tokens": "def grandparent_path ( self ) : return os . path . basename ( os . path . join ( self . path , '../..' ) )", "docstring_tokens": "return grandparent s path string", "label": 0}, {"idx": "cosqa-train-11124", "doc": "generate random number on python django forms", "code": "def positive_integer(anon, obj, field, val):\n    \"\"\"\n    Returns a random positive integer (for a Django PositiveIntegerField)\n    \"\"\"\n    return anon.faker.positive_integer(field=field)", "code_tokens": "def positive_integer ( anon , obj , field , val ) : return anon . faker . positive_integer ( field = field )", "docstring_tokens": "Returns a random positive integer ( for a Django PositiveIntegerField )", "label": 1}, {"idx": "cosqa-train-11125", "doc": "python how to get quarter of date", "code": "def previous_quarter(d):\n    \"\"\"\n    Retrieve the previous quarter for dt\n    \"\"\"\n    from django_toolkit.datetime_util import quarter as datetime_quarter\n    return quarter( (datetime_quarter(datetime(d.year, d.month, d.day))[0] + timedelta(days=-1)).date() )", "code_tokens": "def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )", "docstring_tokens": "Retrieve the previous quarter for dt", "label": 0}, {"idx": "cosqa-train-11126", "doc": "generate white noise in python", "code": "def normal_noise(points):\n    \"\"\"Init a noise variable.\"\"\"\n    return np.random.rand(1) * np.random.randn(points, 1) \\\n        + random.sample([2, -2], 1)", "code_tokens": "def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "docstring_tokens": "Init a noise variable .", "label": 1}, {"idx": "cosqa-train-11127", "doc": "python how to get range of array with positive values numpy", "code": "def _interval_to_bound_points(array):\n    \"\"\"\n    Helper function which returns an array\n    with the Intervals' boundaries.\n    \"\"\"\n\n    array_boundaries = np.array([x.left for x in array])\n    array_boundaries = np.concatenate(\n        (array_boundaries, np.array([array[-1].right])))\n\n    return array_boundaries", "code_tokens": "def _interval_to_bound_points ( array ) : array_boundaries = np . array ( [ x . left for x in array ] ) array_boundaries = np . concatenate ( ( array_boundaries , np . array ( [ array [ - 1 ] . right ] ) ) ) return array_boundaries", "docstring_tokens": "Helper function which returns an array with the Intervals boundaries .", "label": 1}, {"idx": "cosqa-train-11128", "doc": "generating a latex table in python", "code": "def get_latex_table(self, parameters=None, transpose=False, caption=None,\n                        label=\"tab:model_params\", hlines=True, blank_fill=\"--\"):  # pragma: no cover\n        \"\"\" Generates a LaTeX table from parameter summaries.\n\n        Parameters\n        ----------\n        parameters : list[str], optional\n            A list of what parameters to include in the table. By default, includes all parameters\n        transpose : bool, optional\n            Defaults to False, which gives each column as a parameter, each chain (framework)\n            as a row. You can swap it so that you have a parameter each row and a framework\n            each column by setting this to True\n        caption : str, optional\n            If you want to generate a caption for the table through Python, use this.\n            Defaults to an empty string\n        label : str, optional\n            If you want to generate a label for the table through Python, use this.\n            Defaults to an empty string\n        hlines : bool, optional\n            Inserts ``\\\\hline`` before and after the header, and at the end of table.\n        blank_fill : str, optional\n            If a framework does not have a particular parameter, will fill that cell of\n            the table with this string.\n\n        Returns\n        -------\n        str\n            the LaTeX table.\n        \"\"\"\n        if parameters is None:\n            parameters = self.parent._all_parameters\n        for p in parameters:\n            assert isinstance(p, str), \\\n                \"Generating a LaTeX table requires all parameters have labels\"\n        num_parameters = len(parameters)\n        num_chains = len(self.parent.chains)\n        fit_values = self.get_summary(squeeze=False)\n        if label is None:\n            label = \"\"\n        if caption is None:\n            caption = \"\"\n\n        end_text = \" \\\\\\\\ \\n\"\n        if transpose:\n            column_text = \"c\" * (num_chains + 1)\n        else:\n            column_text = \"c\" * (num_parameters + 1)\n\n        center_text = \"\"\n        hline_text = \"\\\\hline\\n\"\n        if hlines:\n            center_text += hline_text + \"\\t\\t\"\n        if transpose:\n            center_text += \" & \".join([\"Parameter\"] + [c.name for c in self.parent.chains]) + end_text\n            if hlines:\n                center_text += \"\\t\\t\" + hline_text\n            for p in parameters:\n                arr = [\"\\t\\t\" + p]\n                for chain_res in fit_values:\n                    if p in chain_res:\n                        arr.append(self.get_parameter_text(*chain_res[p], wrap=True))\n                    else:\n                        arr.append(blank_fill)\n                center_text += \" & \".join(arr) + end_text\n        else:\n            center_text += \" & \".join([\"Model\"] + parameters) + end_text\n            if hlines:\n                center_text += \"\\t\\t\" + hline_text\n            for name, chain_res in zip([c.name for c in self.parent.chains], fit_values):\n                arr = [\"\\t\\t\" + name]\n                for p in parameters:\n                    if p in chain_res:\n                        arr.append(self.get_parameter_text(*chain_res[p], wrap=True))\n                    else:\n                        arr.append(blank_fill)\n                center_text += \" & \".join(arr) + end_text\n        if hlines:\n            center_text += \"\\t\\t\" + hline_text\n        final_text = get_latex_table_frame(caption, label) % (column_text, center_text)\n\n        return final_text", "code_tokens": "def get_latex_table ( self , parameters = None , transpose = False , caption = None , label = \"tab:model_params\" , hlines = True , blank_fill = \"--\" ) : # pragma: no cover if parameters is None : parameters = self . parent . _all_parameters for p in parameters : assert isinstance ( p , str ) , \"Generating a LaTeX table requires all parameters have labels\" num_parameters = len ( parameters ) num_chains = len ( self . parent . chains ) fit_values = self . get_summary ( squeeze = False ) if label is None : label = \"\" if caption is None : caption = \"\" end_text = \" \\\\\\\\ \\n\" if transpose : column_text = \"c\" * ( num_chains + 1 ) else : column_text = \"c\" * ( num_parameters + 1 ) center_text = \"\" hline_text = \"\\\\hline\\n\" if hlines : center_text += hline_text + \"\\t\\t\" if transpose : center_text += \" & \" . join ( [ \"Parameter\" ] + [ c . name for c in self . parent . chains ] ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text for p in parameters : arr = [ \"\\t\\t\" + p ] for chain_res in fit_values : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += \" & \" . join ( arr ) + end_text else : center_text += \" & \" . join ( [ \"Model\" ] + parameters ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text for name , chain_res in zip ( [ c . name for c in self . parent . chains ] , fit_values ) : arr = [ \"\\t\\t\" + name ] for p in parameters : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += \" & \" . join ( arr ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text final_text = get_latex_table_frame ( caption , label ) % ( column_text , center_text ) return final_text", "docstring_tokens": "Generates a LaTeX table from parameter summaries .", "label": 1}, {"idx": "cosqa-train-11129", "doc": "python how to get the details of a method", "code": "def FindMethodByName(self, name):\n    \"\"\"Searches for the specified method, and returns its descriptor.\"\"\"\n    for method in self.methods:\n      if name == method.name:\n        return method\n    return None", "code_tokens": "def FindMethodByName ( self , name ) : for method in self . methods : if name == method . name : return method return None", "docstring_tokens": "Searches for the specified method and returns its descriptor .", "label": 1}, {"idx": "cosqa-train-11130", "doc": "generating a normal random distribution in python", "code": "def rnormal(mu, tau, size=None):\n    \"\"\"\n    Random normal variates.\n    \"\"\"\n    return np.random.normal(mu, 1. / np.sqrt(tau), size)", "code_tokens": "def rnormal ( mu , tau , size = None ) : return np . random . normal ( mu , 1. / np . sqrt ( tau ) , size )", "docstring_tokens": "Random normal variates .", "label": 1}, {"idx": "cosqa-train-11131", "doc": "python how to get the number of cores in a computer", "code": "def _num_cpus_darwin():\n    \"\"\"Return the number of active CPUs on a Darwin system.\"\"\"\n    p = subprocess.Popen(['sysctl','-n','hw.ncpu'],stdout=subprocess.PIPE)\n    return p.stdout.read()", "code_tokens": "def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )", "docstring_tokens": "Return the number of active CPUs on a Darwin system .", "label": 1}, {"idx": "cosqa-train-11132", "doc": "geojson to topojson python", "code": "def to_topojson(self):\n        \"\"\"Adds points and converts to topojson string.\"\"\"\n        topojson = self.topojson\n        topojson[\"objects\"][\"points\"] = {\n            \"type\": \"GeometryCollection\",\n            \"geometries\": [point.to_topojson() for point in self.points.all()],\n        }\n        return json.dumps(topojson)", "code_tokens": "def to_topojson ( self ) : topojson = self . topojson topojson [ \"objects\" ] [ \"points\" ] = { \"type\" : \"GeometryCollection\" , \"geometries\" : [ point . to_topojson ( ) for point in self . points . all ( ) ] , } return json . dumps ( topojson )", "docstring_tokens": "Adds points and converts to topojson string .", "label": 1}, {"idx": "cosqa-train-11133", "doc": "python how to get unique elements of a list", "code": "def uniquify_list(L):\n    \"\"\"Same order unique list using only a list compression.\"\"\"\n    return [e for i, e in enumerate(L) if L.index(e) == i]", "code_tokens": "def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]", "docstring_tokens": "Same order unique list using only a list compression .", "label": 1}, {"idx": "cosqa-train-11134", "doc": "geolocator in not defined python", "code": "def get_geoip(ip):\n    \"\"\"Lookup country for IP address.\"\"\"\n    reader = geolite2.reader()\n    ip_data = reader.get(ip) or {}\n    return ip_data.get('country', {}).get('iso_code')", "code_tokens": "def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )", "docstring_tokens": "Lookup country for IP address .", "label": 1}, {"idx": "cosqa-train-11135", "doc": "python how to get variable's name", "code": "def get_var(self, name):\n        \"\"\" Returns the variable set with the given name.\n        \"\"\"\n        for var in self.vars:\n            if var.name == name:\n                return var\n        else:\n            raise ValueError", "code_tokens": "def get_var ( self , name ) : for var in self . vars : if var . name == name : return var else : raise ValueError", "docstring_tokens": "Returns the variable set with the given name .", "label": 1}, {"idx": "cosqa-train-11136", "doc": "get all variables from python script", "code": "def get_variables(args):\n  \"\"\"\n  Return a dictionary of variables specified at CLI\n  :param: args: Command Line Arguments namespace\n  \"\"\"\n  variables_dict = {}\n  if args.variables:\n    for var in args.variables:\n      words = var.split('=')\n      variables_dict[words[0]] = words[1]\n  return variables_dict", "code_tokens": "def get_variables ( args ) : variables_dict = { } if args . variables : for var in args . variables : words = var . split ( '=' ) variables_dict [ words [ 0 ] ] = words [ 1 ] return variables_dict", "docstring_tokens": "Return a dictionary of variables specified at CLI : param : args : Command Line Arguments namespace", "label": 1}, {"idx": "cosqa-train-11137", "doc": "python how to handle paginated calls using offset", "code": "def paginate(self, request, offset=0, limit=None):\n        \"\"\"Paginate queryset.\"\"\"\n        return self.collection.offset(offset).limit(limit), self.collection.count()", "code_tokens": "def paginate ( self , request , offset = 0 , limit = None ) : return self . collection . offset ( offset ) . limit ( limit ) , self . collection . count ( )", "docstring_tokens": "Paginate queryset .", "label": 1}, {"idx": "cosqa-train-11138", "doc": "get any expression like asterisk in python", "code": "def make_regex(separator):\n    \"\"\"Utility function to create regexp for matching escaped separators\n    in strings.\n\n    \"\"\"\n    return re.compile(r'(?:' + re.escape(separator) + r')?((?:[^' +\n                      re.escape(separator) + r'\\\\]|\\\\.)+)')", "code_tokens": "def make_regex ( separator ) : return re . compile ( r'(?:' + re . escape ( separator ) + r')?((?:[^' + re . escape ( separator ) + r'\\\\]|\\\\.)+)' )", "docstring_tokens": "Utility function to create regexp for matching escaped separators in strings .", "label": 1}, {"idx": "cosqa-train-11139", "doc": "python how to implement websocket", "code": "async def create_websocket_server(sock, filter=None):  # pylint: disable=W0622\n    \"\"\"\n    A more low-level form of open_websocket_server.\n    You are responsible for closing this websocket.\n    \"\"\"\n    ws = Websocket()\n    await ws.start_server(sock, filter=filter)\n    return ws", "code_tokens": "async def create_websocket_server ( sock , filter = None ) : # pylint: disable=W0622 ws = Websocket ( ) await ws . start_server ( sock , filter = filter ) return ws", "docstring_tokens": "A more low - level form of open_websocket_server . You are responsible for closing this websocket .", "label": 1}, {"idx": "cosqa-train-11140", "doc": "get attribute name of a variable python", "code": "def get_attribute_name_id(attr):\n    \"\"\"\n    Return the attribute name identifier\n    \"\"\"\n    return attr.value.id if isinstance(attr.value, ast.Name) else None", "code_tokens": "def get_attribute_name_id ( attr ) : return attr . value . id if isinstance ( attr . value , ast . Name ) else None", "docstring_tokens": "Return the attribute name identifier", "label": 1}, {"idx": "cosqa-train-11141", "doc": "python how to know list is nested", "code": "def empty_tree(input_list):\n    \"\"\"Recursively iterate through values in nested lists.\"\"\"\n    for item in input_list:\n        if not isinstance(item, list) or not empty_tree(item):\n            return False\n    return True", "code_tokens": "def empty_tree ( input_list ) : for item in input_list : if not isinstance ( item , list ) or not empty_tree ( item ) : return False return True", "docstring_tokens": "Recursively iterate through values in nested lists .", "label": 1}, {"idx": "cosqa-train-11142", "doc": "get attribute type in python", "code": "def get_attribute_name_id(attr):\n    \"\"\"\n    Return the attribute name identifier\n    \"\"\"\n    return attr.value.id if isinstance(attr.value, ast.Name) else None", "code_tokens": "def get_attribute_name_id ( attr ) : return attr . value . id if isinstance ( attr . value , ast . Name ) else None", "docstring_tokens": "Return the attribute name identifier", "label": 1}, {"idx": "cosqa-train-11143", "doc": "python how to make an iterable", "code": "def force_iterable(f):\n    \"\"\"Will make any functions return an iterable objects by wrapping its result in a list.\"\"\"\n    def wrapper(*args, **kwargs):\n        r = f(*args, **kwargs)\n        if hasattr(r, '__iter__'):\n            return r\n        else:\n            return [r]\n    return wrapper", "code_tokens": "def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper", "docstring_tokens": "Will make any functions return an iterable objects by wrapping its result in a list .", "label": 1}, {"idx": "cosqa-train-11144", "doc": "get average for numbers in list python", "code": "def calc_list_average(l):\n    \"\"\"\n    Calculates the average value of a list of numbers\n    Returns a float\n    \"\"\"\n    total = 0.0\n    for value in l:\n        total += value\n    return total / len(l)", "code_tokens": "def calc_list_average ( l ) : total = 0.0 for value in l : total += value return total / len ( l )", "docstring_tokens": "Calculates the average value of a list of numbers Returns a float", "label": 1}, {"idx": "cosqa-train-11145", "doc": "python how to make list of points", "code": "def polygon_from_points(points):\n    \"\"\"\n    Constructs a numpy-compatible polygon from a page representation.\n    \"\"\"\n    polygon = []\n    for pair in points.split(\" \"):\n        x_y = pair.split(\",\")\n        polygon.append([float(x_y[0]), float(x_y[1])])\n    return polygon", "code_tokens": "def polygon_from_points ( points ) : polygon = [ ] for pair in points . split ( \" \" ) : x_y = pair . split ( \",\" ) polygon . append ( [ float ( x_y [ 0 ] ) , float ( x_y [ 1 ] ) ] ) return polygon", "docstring_tokens": "Constructs a numpy - compatible polygon from a page representation .", "label": 1}, {"idx": "cosqa-train-11146", "doc": "get average in dictionaries python", "code": "def _mean_dict(dict_list):\n    \"\"\"Compute the mean value across a list of dictionaries\n    \"\"\"\n    return {k: np.array([d[k] for d in dict_list]).mean()\n            for k in dict_list[0].keys()}", "code_tokens": "def _mean_dict ( dict_list ) : return { k : np . array ( [ d [ k ] for d in dict_list ] ) . mean ( ) for k in dict_list [ 0 ] . keys ( ) }", "docstring_tokens": "Compute the mean value across a list of dictionaries", "label": 1}, {"idx": "cosqa-train-11147", "doc": "python how to manipulate an attrubute of a object", "code": "def populate_obj(obj, attrs):\n    \"\"\"Populates an object's attributes using the provided dict\n    \"\"\"\n    for k, v in attrs.iteritems():\n        setattr(obj, k, v)", "code_tokens": "def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "docstring_tokens": "Populates an object s attributes using the provided dict", "label": 1}, {"idx": "cosqa-train-11148", "doc": "get common values in a dictionary python", "code": "def compare(dicts):\n    \"\"\"Compare by iteration\"\"\"\n\n    common_members = {}\n    common_keys = reduce(lambda x, y: x & y, map(dict.keys, dicts))\n    for k in common_keys:\n        common_members[k] = list(\n            reduce(lambda x, y: x & y, [set(d[k]) for d in dicts]))\n\n    return common_members", "code_tokens": "def compare ( dicts ) : common_members = { } common_keys = reduce ( lambda x , y : x & y , map ( dict . keys , dicts ) ) for k in common_keys : common_members [ k ] = list ( reduce ( lambda x , y : x & y , [ set ( d [ k ] ) for d in dicts ] ) ) return common_members", "docstring_tokens": "Compare by iteration", "label": 1}, {"idx": "cosqa-train-11149", "doc": "python how to map grid points", "code": "def RadiusGrid(gridSize):\n    \"\"\"\n    Return a square grid with values of the distance from the centre \n    of the grid to each gridpoint\n    \"\"\"\n    x,y=np.mgrid[0:gridSize,0:gridSize]\n    x = x-(gridSize-1.0)/2.0\n    y = y-(gridSize-1.0)/2.0\n    return np.abs(x+1j*y)", "code_tokens": "def RadiusGrid ( gridSize ) : x , y = np . mgrid [ 0 : gridSize , 0 : gridSize ] x = x - ( gridSize - 1.0 ) / 2.0 y = y - ( gridSize - 1.0 ) / 2.0 return np . abs ( x + 1j * y )", "docstring_tokens": "Return a square grid with values of the distance from the centre of the grid to each gridpoint", "label": 1}, {"idx": "cosqa-train-11150", "doc": "get date of previous monday python", "code": "def prevmonday(num):\n    \"\"\"\n    Return unix SECOND timestamp of \"num\" mondays ago\n    \"\"\"\n    today = get_today()\n    lastmonday = today - timedelta(days=today.weekday(), weeks=num)\n    return lastmonday", "code_tokens": "def prevmonday ( num ) : today = get_today ( ) lastmonday = today - timedelta ( days = today . weekday ( ) , weeks = num ) return lastmonday", "docstring_tokens": "Return unix SECOND timestamp of num mondays ago", "label": 1}, {"idx": "cosqa-train-11151", "doc": "python how to match dictionarys", "code": "def intersect(d1, d2):\n    \"\"\"Intersect dictionaries d1 and d2 by key *and* value.\"\"\"\n    return dict((k, d1[k]) for k in d1 if k in d2 and d1[k] == d2[k])", "code_tokens": "def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )", "docstring_tokens": "Intersect dictionaries d1 and d2 by key * and * value .", "label": 1}, {"idx": "cosqa-train-11152", "doc": "get dimension of array axis python", "code": "def array_size(x, axis):\n  \"\"\"Calculate the size of `x` along `axis` dimensions only.\"\"\"\n  axis_shape = x.shape if axis is None else tuple(x.shape[a] for a in axis)\n  return max(numpy.prod(axis_shape), 1)", "code_tokens": "def array_size ( x , axis ) : axis_shape = x . shape if axis is None else tuple ( x . shape [ a ] for a in axis ) return max ( numpy . prod ( axis_shape ) , 1 )", "docstring_tokens": "Calculate the size of x along axis dimensions only .", "label": 1}, {"idx": "cosqa-train-11153", "doc": "python how to mix backslash and forward slashes in path", "code": "def norm_slash(name):\n    \"\"\"Normalize path slashes.\"\"\"\n\n    if isinstance(name, str):\n        return name.replace('/', \"\\\\\") if not is_case_sensitive() else name\n    else:\n        return name.replace(b'/', b\"\\\\\") if not is_case_sensitive() else name", "code_tokens": "def norm_slash ( name ) : if isinstance ( name , str ) : return name . replace ( '/' , \"\\\\\" ) if not is_case_sensitive ( ) else name else : return name . replace ( b'/' , b\"\\\\\" ) if not is_case_sensitive ( ) else name", "docstring_tokens": "Normalize path slashes .", "label": 1}, {"idx": "cosqa-train-11154", "doc": "get distinct in list python", "code": "def distinct(xs):\n    \"\"\"Get the list of distinct values with preserving order.\"\"\"\n    # don't use collections.OrderedDict because we do support Python 2.6\n    seen = set()\n    return [x for x in xs if x not in seen and not seen.add(x)]", "code_tokens": "def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]", "docstring_tokens": "Get the list of distinct values with preserving order .", "label": 1}, {"idx": "cosqa-train-11155", "doc": "python how to move read file pointer back", "code": "def align_file_position(f, size):\n    \"\"\" Align the position in the file to the next block of specified size \"\"\"\n    align = (size - 1) - (f.tell() % size)\n    f.seek(align, 1)", "code_tokens": "def align_file_position ( f , size ) : align = ( size - 1 ) - ( f . tell ( ) % size ) f . seek ( align , 1 )", "docstring_tokens": "Align the position in the file to the next block of specified size", "label": 1}, {"idx": "cosqa-train-11156", "doc": "get distinct values in a list in python", "code": "def distinct(xs):\n    \"\"\"Get the list of distinct values with preserving order.\"\"\"\n    # don't use collections.OrderedDict because we do support Python 2.6\n    seen = set()\n    return [x for x in xs if x not in seen and not seen.add(x)]", "code_tokens": "def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]", "docstring_tokens": "Get the list of distinct values with preserving order .", "label": 1}, {"idx": "cosqa-train-11157", "doc": "python how to normalize a list of dictionaries", "code": "def _normalize(obj):\n    \"\"\"\n    Normalize dicts and lists\n\n    :param obj:\n    :return: normalized object\n    \"\"\"\n    if isinstance(obj, list):\n        return [_normalize(item) for item in obj]\n    elif isinstance(obj, dict):\n        return {k: _normalize(v) for k, v in obj.items() if v is not None}\n    elif hasattr(obj, 'to_python'):\n        return obj.to_python()\n    return obj", "code_tokens": "def _normalize ( obj ) : if isinstance ( obj , list ) : return [ _normalize ( item ) for item in obj ] elif isinstance ( obj , dict ) : return { k : _normalize ( v ) for k , v in obj . items ( ) if v is not None } elif hasattr ( obj , 'to_python' ) : return obj . to_python ( ) return obj", "docstring_tokens": "Normalize dicts and lists", "label": 0}, {"idx": "cosqa-train-11158", "doc": "get file length without read python", "code": "def file_length(file_obj):\n    \"\"\"\n    Returns the length in bytes of a given file object.\n    Necessary because os.fstat only works on real files and not file-like\n    objects. This works on more types of streams, primarily StringIO.\n    \"\"\"\n    file_obj.seek(0, 2)\n    length = file_obj.tell()\n    file_obj.seek(0)\n    return length", "code_tokens": "def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length", "docstring_tokens": "Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO .", "label": 1}, {"idx": "cosqa-train-11159", "doc": "python how to print the first 10 lines in a large file", "code": "def head(filename, n=10):\n    \"\"\" prints the top `n` lines of a file \"\"\"\n    with freader(filename) as fr:\n        for _ in range(n):\n            print(fr.readline().strip())", "code_tokens": "def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )", "docstring_tokens": "prints the top n lines of a file", "label": 1}, {"idx": "cosqa-train-11160", "doc": "get hash of file + python", "code": "def generate_hash(filepath):\n    \"\"\"Public function that reads a local file and generates a SHA256 hash digest for it\"\"\"\n    fr = FileReader(filepath)\n    data = fr.read_bin()\n    return _calculate_sha256(data)", "code_tokens": "def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )", "docstring_tokens": "Public function that reads a local file and generates a SHA256 hash digest for it", "label": 1}, {"idx": "cosqa-train-11161", "doc": "python how to rank a list object", "code": "def ranks(self, key, value):\n    \"\"\"Populate the ``ranks`` key.\"\"\"\n    return [normalize_rank(el) for el in force_list(value.get('a'))]", "code_tokens": "def ranks ( self , key , value ) : return [ normalize_rank ( el ) for el in force_list ( value . get ( 'a' ) ) ]", "docstring_tokens": "Populate the ranks key .", "label": 1}, {"idx": "cosqa-train-11162", "doc": "get index in a tuple python", "code": "def _get_item_position(self, idx):\n        \"\"\"Return a tuple of (start, end) indices of an item from its index.\"\"\"\n        start = 0 if idx == 0 else self._index[idx - 1] + 1\n        end = self._index[idx]\n        return start, end", "code_tokens": "def _get_item_position ( self , idx ) : start = 0 if idx == 0 else self . _index [ idx - 1 ] + 1 end = self . _index [ idx ] return start , end", "docstring_tokens": "Return a tuple of ( start end ) indices of an item from its index .", "label": 1}, {"idx": "cosqa-train-11163", "doc": "python how to remove docstrings from compiled code", "code": "def debug_src(src, pm=False, globs=None):\n    \"\"\"Debug a single doctest docstring, in argument `src`'\"\"\"\n    testsrc = script_from_examples(src)\n    debug_script(testsrc, pm, globs)", "code_tokens": "def debug_src ( src , pm = False , globs = None ) : testsrc = script_from_examples ( src ) debug_script ( testsrc , pm , globs )", "docstring_tokens": "Debug a single doctest docstring in argument src", "label": 1}, {"idx": "cosqa-train-11164", "doc": "get index of current row python", "code": "def getRowCurrentIndex(self):\n        \"\"\" Returns the index of column 0 of the current item in the underlying model.\n            See also the notes at the top of this module on current item vs selected item(s).\n        \"\"\"\n        curIndex = self.currentIndex()\n        col0Index = curIndex.sibling(curIndex.row(), 0)\n        return col0Index", "code_tokens": "def getRowCurrentIndex ( self ) : curIndex = self . currentIndex ( ) col0Index = curIndex . sibling ( curIndex . row ( ) , 0 ) return col0Index", "docstring_tokens": "Returns the index of column 0 of the current item in the underlying model . See also the notes at the top of this module on current item vs selected item ( s ) .", "label": 1}, {"idx": "cosqa-train-11165", "doc": "python how to remove extra spaces in a string", "code": "def sanitize_word(s):\n    \"\"\"Remove non-alphanumerical characters from metric word.\n    And trim excessive underscores.\n    \"\"\"\n    s = re.sub('[^\\w-]+', '_', s)\n    s = re.sub('__+', '_', s)\n    return s.strip('_')", "code_tokens": "def sanitize_word ( s ) : s = re . sub ( '[^\\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )", "docstring_tokens": "Remove non - alphanumerical characters from metric word . And trim excessive underscores .", "label": 1}, {"idx": "cosqa-train-11166", "doc": "get index of iterator in python", "code": "def index(self, elem):\n        \"\"\"Find the index of elem in the reversed iterator.\"\"\"\n        return _coconut.len(self._iter) - self._iter.index(elem) - 1", "code_tokens": "def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1", "docstring_tokens": "Find the index of elem in the reversed iterator .", "label": 1}, {"idx": "cosqa-train-11167", "doc": "python how to remove multiple whitespace", "code": "def text_remove_empty_lines(text):\n    \"\"\"\n    Whitespace normalization:\n\n      - Strip empty lines\n      - Strip trailing whitespace\n    \"\"\"\n    lines = [ line.rstrip()  for line in text.splitlines()  if line.strip() ]\n    return \"\\n\".join(lines)", "code_tokens": "def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return \"\\n\" . join ( lines )", "docstring_tokens": "Whitespace normalization :", "label": 1}, {"idx": "cosqa-train-11168", "doc": "get indexes of elements python", "code": "def get_idx_rect(index_list):\n    \"\"\"Extract the boundaries from a list of indexes\"\"\"\n    rows, cols = list(zip(*[(i.row(), i.column()) for i in index_list]))\n    return ( min(rows), max(rows), min(cols), max(cols) )", "code_tokens": "def get_idx_rect ( index_list ) : rows , cols = list ( zip ( * [ ( i . row ( ) , i . column ( ) ) for i in index_list ] ) ) return ( min ( rows ) , max ( rows ) , min ( cols ) , max ( cols ) )", "docstring_tokens": "Extract the boundaries from a list of indexes", "label": 1}, {"idx": "cosqa-train-11169", "doc": "python how to remove spaces between strings", "code": "def strip_spaces(s):\n    \"\"\" Strip excess spaces from a string \"\"\"\n    return u\" \".join([c for c in s.split(u' ') if c])", "code_tokens": "def strip_spaces ( s ) : return u\" \" . join ( [ c for c in s . split ( u' ' ) if c ] )", "docstring_tokens": "Strip excess spaces from a string", "label": 1}, {"idx": "cosqa-train-11170", "doc": "get keywords from a sentence python nltk", "code": "def extract_keywords_from_text(self, text):\n        \"\"\"Method to extract keywords from the text provided.\n\n        :param text: Text to extract keywords from, provided as a string.\n        \"\"\"\n        sentences = nltk.tokenize.sent_tokenize(text)\n        self.extract_keywords_from_sentences(sentences)", "code_tokens": "def extract_keywords_from_text ( self , text ) : sentences = nltk . tokenize . sent_tokenize ( text ) self . extract_keywords_from_sentences ( sentences )", "docstring_tokens": "Method to extract keywords from the text provided .", "label": 1}, {"idx": "cosqa-train-11171", "doc": "python how to remove zeros from the end of decimal numbers", "code": "def drop_trailing_zeros_decimal(num):\n    \"\"\" Drops the trailinz zeros from decimal value.\n        Returns a string\n    \"\"\"\n    out = str(num)\n    return out.rstrip('0').rstrip('.') if '.' in out else out", "code_tokens": "def drop_trailing_zeros_decimal ( num ) : out = str ( num ) return out . rstrip ( '0' ) . rstrip ( '.' ) if '.' in out else out", "docstring_tokens": "Drops the trailinz zeros from decimal value . Returns a string", "label": 1}, {"idx": "cosqa-train-11172", "doc": "get last inserted id from mongodb collection python", "code": "def add_todo(request):\n    cur = request.cursor\n    todo = request.json[\"todo\"]\n    cur.execute(\"\"\"INSERT INTO todos (todo) VALUES (?)\"\"\", (todo,))\n    last_id = cur.lastrowid\n    cur.connection.commit()\n\n    return request.Response(json={\"id\": last_id, \"todo\": todo})", "code_tokens": "def add_todo ( request ) : cur = request . cursor todo = request . json [ \"todo\" ] cur . execute ( \"\"\"INSERT INTO todos (todo) VALUES (?)\"\"\" , ( todo , ) ) last_id = cur . lastrowid cur . connection . commit ( ) return request . Response ( json = { \"id\" : last_id , \"todo\" : todo } )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-11173", "doc": "python how to return array of float64", "code": "def as_float_array(a):\n    \"\"\"View the quaternion array as an array of floats\n\n    This function is fast (of order 1 microsecond) because no data is\n    copied; the returned quantity is just a \"view\" of the original.\n\n    The output view has one more dimension (of size 4) than the input\n    array, but is otherwise the same shape.\n\n    \"\"\"\n    return np.asarray(a, dtype=np.quaternion).view((np.double, 4))", "code_tokens": "def as_float_array ( a ) : return np . asarray ( a , dtype = np . quaternion ) . view ( ( np . double , 4 ) )", "docstring_tokens": "View the quaternion array as an array of floats", "label": 1}, {"idx": "cosqa-train-11174", "doc": "get last modified file with python", "code": "def get_last_modified_timestamp(self):\n        \"\"\"\n        Looks at the files in a git root directory and grabs the last modified timestamp\n        \"\"\"\n        cmd = \"find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '\"\n        ps = subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)\n        output = ps.communicate()[0]\n        print output", "code_tokens": "def get_last_modified_timestamp ( self ) : cmd = \"find . -print0 | xargs -0 stat -f '%T@ %p' | sort -n | tail -1 | cut -f2- -d' '\" ps = subprocess . Popen ( cmd , shell = True , stdout = subprocess . PIPE , stderr = subprocess . STDOUT ) output = ps . communicate ( ) [ 0 ] print output", "docstring_tokens": "Looks at the files in a git root directory and grabs the last modified timestamp", "label": 1}, {"idx": "cosqa-train-11175", "doc": "python how to revert monkeypatch changes", "code": "def monkey_restore():\n    \"\"\"restore real versions. Inverse of `monkey_patch`\"\"\"\n    for k, v in originals.items():\n        setattr(time_mod, k, v)\n    \n    global epoch\n    epoch = None", "code_tokens": "def monkey_restore ( ) : for k , v in originals . items ( ) : setattr ( time_mod , k , v ) global epoch epoch = None", "docstring_tokens": "restore real versions . Inverse of monkey_patch", "label": 0}, {"idx": "cosqa-train-11176", "doc": "get mouse x and y position in python position", "code": "def get_mouse_location(self):\n        \"\"\"\n        Get the current mouse location (coordinates and screen number).\n\n        :return: a namedtuple with ``x``, ``y`` and ``screen_num`` fields\n        \"\"\"\n        x = ctypes.c_int(0)\n        y = ctypes.c_int(0)\n        screen_num = ctypes.c_int(0)\n        _libxdo.xdo_get_mouse_location(\n            self._xdo, ctypes.byref(x), ctypes.byref(y),\n            ctypes.byref(screen_num))\n        return mouse_location(x.value, y.value, screen_num.value)", "code_tokens": "def get_mouse_location ( self ) : x = ctypes . c_int ( 0 ) y = ctypes . c_int ( 0 ) screen_num = ctypes . c_int ( 0 ) _libxdo . xdo_get_mouse_location ( self . _xdo , ctypes . byref ( x ) , ctypes . byref ( y ) , ctypes . byref ( screen_num ) ) return mouse_location ( x . value , y . value , screen_num . value )", "docstring_tokens": "Get the current mouse location ( coordinates and screen number ) .", "label": 1}, {"idx": "cosqa-train-11177", "doc": "python how to see if key is in dict", "code": "def __contains__(self, key):\n        \"\"\"\n        Invoked when determining whether a specific key is in the dictionary\n        using `key in d`.\n\n        The key is looked up case-insensitively.\n        \"\"\"\n        k = self._real_key(key)\n        return k in self._data", "code_tokens": "def __contains__ ( self , key ) : k = self . _real_key ( key ) return k in self . _data", "docstring_tokens": "Invoked when determining whether a specific key is in the dictionary using key in d .", "label": 1}, {"idx": "cosqa-train-11178", "doc": "get nth numpy in python", "code": "def _nth(arr, n):\n    \"\"\"\n    Return the nth value of array\n\n    If it is missing return NaN\n    \"\"\"\n    try:\n        return arr.iloc[n]\n    except (KeyError, IndexError):\n        return np.nan", "code_tokens": "def _nth ( arr , n ) : try : return arr . iloc [ n ] except ( KeyError , IndexError ) : return np . nan", "docstring_tokens": "Return the nth value of array", "label": 1}, {"idx": "cosqa-train-11179", "doc": "python how to set the value of constraint", "code": "def set_constraint_bound(self, name, value):\n        \"\"\"Set the upper bound of a constraint.\"\"\"\n        index = self._get_constraint_index(name)\n        self.upper_bounds[index] = value\n        self._reset_solution()", "code_tokens": "def set_constraint_bound ( self , name , value ) : index = self . _get_constraint_index ( name ) self . upper_bounds [ index ] = value self . _reset_solution ( )", "docstring_tokens": "Set the upper bound of a constraint .", "label": 1}, {"idx": "cosqa-train-11180", "doc": "get num cores on machine python", "code": "def _num_cpus_darwin():\n    \"\"\"Return the number of active CPUs on a Darwin system.\"\"\"\n    p = subprocess.Popen(['sysctl','-n','hw.ncpu'],stdout=subprocess.PIPE)\n    return p.stdout.read()", "code_tokens": "def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )", "docstring_tokens": "Return the number of active CPUs on a Darwin system .", "label": 1}, {"idx": "cosqa-train-11181", "doc": "get number of days in datetime python", "code": "def _days_in_month(date):\n    \"\"\"The number of days in the month of the given date\"\"\"\n    if date.month == 12:\n        reference = type(date)(date.year + 1, 1, 1)\n    else:\n        reference = type(date)(date.year, date.month + 1, 1)\n    return (reference - timedelta(days=1)).day", "code_tokens": "def _days_in_month ( date ) : if date . month == 12 : reference = type ( date ) ( date . year + 1 , 1 , 1 ) else : reference = type ( date ) ( date . year , date . month + 1 , 1 ) return ( reference - timedelta ( days = 1 ) ) . day", "docstring_tokens": "The number of days in the month of the given date", "label": 1}, {"idx": "cosqa-train-11182", "doc": "python how to split string into chunks of n size", "code": "def schunk(string, size):\n    \"\"\"Splits string into n sized chunks.\"\"\"\n    return [string[i:i+size] for i in range(0, len(string), size)]", "code_tokens": "def schunk ( string , size ) : return [ string [ i : i + size ] for i in range ( 0 , len ( string ) , size ) ]", "docstring_tokens": "Splits string into n sized chunks .", "label": 1}, {"idx": "cosqa-train-11183", "doc": "get number of nonzero values in array python", "code": "def count(data, axis=None):\n    \"\"\"Count the number of non-NA in this array along the given axis or axes\n    \"\"\"\n    return np.sum(np.logical_not(isnull(data)), axis=axis)", "code_tokens": "def count ( data , axis = None ) : return np . sum ( np . logical_not ( isnull ( data ) ) , axis = axis )", "docstring_tokens": "Count the number of non - NA in this array along the given axis or axes", "label": 1}, {"idx": "cosqa-train-11184", "doc": "python how to suppress printing in a method", "code": "def _normalize_instancemethod(instance_method):\n    \"\"\"\n    wraps(instancemethod) returns a function, not an instancemethod so its repr() is all messed up;\n    we want the original repr to show up in the logs, therefore we do this trick\n    \"\"\"\n    if not hasattr(instance_method, 'im_self'):\n        return instance_method\n\n    def _func(*args, **kwargs):\n        return instance_method(*args, **kwargs)\n\n    _func.__name__ = repr(instance_method)\n    return _func", "code_tokens": "def _normalize_instancemethod ( instance_method ) : if not hasattr ( instance_method , 'im_self' ) : return instance_method def _func ( * args , * * kwargs ) : return instance_method ( * args , * * kwargs ) _func . __name__ = repr ( instance_method ) return _func", "docstring_tokens": "wraps ( instancemethod ) returns a function not an instancemethod so its repr () is all messed up ; we want the original repr to show up in the logs therefore we do this trick", "label": 1}, {"idx": "cosqa-train-11185", "doc": "get number of rows in output of sql query in python", "code": "def count_rows(self, table, cols='*'):\n        \"\"\"Get the number of rows in a particular table.\"\"\"\n        query = 'SELECT COUNT({0}) FROM {1}'.format(join_cols(cols), wrap(table))\n        result = self.fetch(query)\n        return result if result is not None else 0", "code_tokens": "def count_rows ( self , table , cols = '*' ) : query = 'SELECT COUNT({0}) FROM {1}' . format ( join_cols ( cols ) , wrap ( table ) ) result = self . fetch ( query ) return result if result is not None else 0", "docstring_tokens": "Get the number of rows in a particular table .", "label": 1}, {"idx": "cosqa-train-11186", "doc": "python how to terminate a program using quit", "code": "def cli_command_quit(self, msg):\n        \"\"\"\\\n        kills the child and exits\n        \"\"\"\n        if self.state == State.RUNNING and self.sprocess and self.sprocess.proc:\n            self.sprocess.proc.kill()\n        else:\n            sys.exit(0)", "code_tokens": "def cli_command_quit ( self , msg ) : if self . state == State . RUNNING and self . sprocess and self . sprocess . proc : self . sprocess . proc . kill ( ) else : sys . exit ( 0 )", "docstring_tokens": "\\ kills the child and exits", "label": 1}, {"idx": "cosqa-train-11187", "doc": "get previous date python", "code": "def get_previous(self):\n        \"\"\"Get the billing cycle prior to this one. May return None\"\"\"\n        return BillingCycle.objects.filter(date_range__lt=self.date_range).order_by('date_range').last()", "code_tokens": "def get_previous ( self ) : return BillingCycle . objects . filter ( date_range__lt = self . date_range ) . order_by ( 'date_range' ) . last ( )", "docstring_tokens": "Get the billing cycle prior to this one . May return None", "label": 1}, {"idx": "cosqa-train-11188", "doc": "python how to turn a string into a number", "code": "def get_number(s, cast=int):\n    \"\"\"\n    Try to get a number out of a string, and cast it.\n    \"\"\"\n    import string\n    d = \"\".join(x for x in str(s) if x in string.digits)\n    return cast(d)", "code_tokens": "def get_number ( s , cast = int ) : import string d = \"\" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )", "docstring_tokens": "Try to get a number out of a string and cast it .", "label": 1}, {"idx": "cosqa-train-11189", "doc": "get properties names python", "code": "def get_keys_from_class(cc):\n    \"\"\"Return list of the key property names for a class \"\"\"\n    return [prop.name for prop in cc.properties.values() \\\n            if 'key' in prop.qualifiers]", "code_tokens": "def get_keys_from_class ( cc ) : return [ prop . name for prop in cc . properties . values ( ) if 'key' in prop . qualifiers ]", "docstring_tokens": "Return list of the key property names for a class", "label": 1}, {"idx": "cosqa-train-11190", "doc": "python how to turn logs into a list", "code": "def log_to_json(log):\n    \"\"\"Convert a log record into a list of strings\"\"\"\n    return [log.timestamp.isoformat()[:22],\n            log.level, log.process, log.message]", "code_tokens": "def log_to_json ( log ) : return [ log . timestamp . isoformat ( ) [ : 22 ] , log . level , log . process , log . message ]", "docstring_tokens": "Convert a log record into a list of strings", "label": 1}, {"idx": "cosqa-train-11191", "doc": "get result from cursor python", "code": "def execute(self, cmd, *args, **kwargs):\n        \"\"\" Execute the SQL command and return the data rows as tuples\n        \"\"\"\n        self.cursor.execute(cmd, *args, **kwargs)", "code_tokens": "def execute ( self , cmd , * args , * * kwargs ) : self . cursor . execute ( cmd , * args , * * kwargs )", "docstring_tokens": "Execute the SQL command and return the data rows as tuples", "label": 1}, {"idx": "cosqa-train-11192", "doc": "python how to unreference memory", "code": "def invalidate_cache(cpu, address, size):\n        \"\"\" remove decoded instruction from instruction cache \"\"\"\n        cache = cpu.instruction_cache\n        for offset in range(size):\n            if address + offset in cache:\n                del cache[address + offset]", "code_tokens": "def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]", "docstring_tokens": "remove decoded instruction from instruction cache", "label": 1}, {"idx": "cosqa-train-11193", "doc": "get rgb colors in python from an image", "code": "def get_colors(img):\n    \"\"\"\n    Returns a list of all the image's colors.\n    \"\"\"\n    w, h = img.size\n    return [color[:3] for count, color in img.convert('RGB').getcolors(w * h)]", "code_tokens": "def get_colors ( img ) : w , h = img . size return [ color [ : 3 ] for count , color in img . convert ( 'RGB' ) . getcolors ( w * h ) ]", "docstring_tokens": "Returns a list of all the image s colors .", "label": 1}, {"idx": "cosqa-train-11194", "doc": "python how to upgrate", "code": "def upgrade(directory, sql, tag, x_arg, revision):\n    \"\"\"Upgrade to a later version\"\"\"\n    _upgrade(directory, revision, sql, tag, x_arg)", "code_tokens": "def upgrade ( directory , sql , tag , x_arg , revision ) : _upgrade ( directory , revision , sql , tag , x_arg )", "docstring_tokens": "Upgrade to a later version", "label": 1}, {"idx": "cosqa-train-11195", "doc": "get something from a form python", "code": "def get(key, default=None):\n    \"\"\" return the key from the request\n    \"\"\"\n    data = get_form() or get_query_string()\n    return data.get(key, default)", "code_tokens": "def get ( key , default = None ) : data = get_form ( ) or get_query_string ( ) return data . get ( key , default )", "docstring_tokens": "return the key from the request", "label": 0}, {"idx": "cosqa-train-11196", "doc": "python how to use bins in histogram", "code": "def inverseHistogram(hist, bin_range):\n    \"\"\"sample data from given histogram and min, max values within range\n\n    Returns:\n        np.array: data that would create the same histogram as given\n    \"\"\"\n    data = hist.astype(float) / np.min(hist[np.nonzero(hist)])\n    new_data = np.empty(shape=np.sum(data, dtype=int))\n    i = 0\n    xvals = np.linspace(bin_range[0], bin_range[1], len(data))\n    for d, x in zip(data, xvals):\n        new_data[i:i + d] = x\n        i += int(d)\n    return new_data", "code_tokens": "def inverseHistogram ( hist , bin_range ) : data = hist . astype ( float ) / np . min ( hist [ np . nonzero ( hist ) ] ) new_data = np . empty ( shape = np . sum ( data , dtype = int ) ) i = 0 xvals = np . linspace ( bin_range [ 0 ] , bin_range [ 1 ] , len ( data ) ) for d , x in zip ( data , xvals ) : new_data [ i : i + d ] = x i += int ( d ) return new_data", "docstring_tokens": "sample data from given histogram and min max values within range", "label": 1}, {"idx": "cosqa-train-11197", "doc": "get text from a url python", "code": "def url_read_text(url, verbose=True):\n    r\"\"\"\n    Directly reads text data from url\n    \"\"\"\n    data = url_read(url, verbose)\n    text = data.decode('utf8')\n    return text", "code_tokens": "def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text", "docstring_tokens": "r Directly reads text data from url", "label": 1}, {"idx": "cosqa-train-11198", "doc": "python how to write a context manager", "code": "def __enter__(self):\n        \"\"\" Implements the context manager protocol. Specially useful for asserting exceptions\n        \"\"\"\n        clone = self.clone()\n        self._contexts.append(clone)\n        self.reset()\n        return self", "code_tokens": "def __enter__ ( self ) : clone = self . clone ( ) self . _contexts . append ( clone ) self . reset ( ) return self", "docstring_tokens": "Implements the context manager protocol . Specially useful for asserting exceptions", "label": 1}, {"idx": "cosqa-train-11199", "doc": "get the date from string in python", "code": "def _read_date_from_string(str1):\n    \"\"\"\n    Reads the date from a string in the format YYYY/MM/DD and returns\n    :class: datetime.date\n    \"\"\"\n    full_date = [int(x) for x in str1.split('/')]\n    return datetime.date(full_date[0], full_date[1], full_date[2])", "code_tokens": "def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )", "docstring_tokens": "Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date", "label": 1}, {"idx": "cosqa-train-11200", "doc": "python howto test value is an array or not", "code": "def is_iterable(value):\n    \"\"\"must be an iterable (list, array, tuple)\"\"\"\n    return isinstance(value, np.ndarray) or isinstance(value, list) or isinstance(value, tuple), value", "code_tokens": "def is_iterable ( value ) : return isinstance ( value , np . ndarray ) or isinstance ( value , list ) or isinstance ( value , tuple ) , value", "docstring_tokens": "must be an iterable ( list array tuple )", "label": 1}, {"idx": "cosqa-train-11201", "doc": "get the index of a minimum value of a list python numpy", "code": "def find_nearest_index(arr, value):\n    \"\"\"For a given value, the function finds the nearest value\n    in the array and returns its index.\"\"\"\n    arr = np.array(arr)\n    index = (abs(arr-value)).argmin()\n    return index", "code_tokens": "def find_nearest_index ( arr , value ) : arr = np . array ( arr ) index = ( abs ( arr - value ) ) . argmin ( ) return index", "docstring_tokens": "For a given value the function finds the nearest value in the array and returns its index .", "label": 1}, {"idx": "cosqa-train-11202", "doc": "python html table show table", "code": "def html(header_rows):\n    \"\"\"\n    Convert a list of tuples describing a table into a HTML string\n    \"\"\"\n    name = 'table%d' % next(tablecounter)\n    return HtmlTable([map(str, row) for row in header_rows], name).render()", "code_tokens": "def html ( header_rows ) : name = 'table%d' % next ( tablecounter ) return HtmlTable ( [ map ( str , row ) for row in header_rows ] , name ) . render ( )", "docstring_tokens": "Convert a list of tuples describing a table into a HTML string", "label": 1}, {"idx": "cosqa-train-11203", "doc": "get the index of a value in python based on conditions", "code": "def get_index_nested(x, i):\n    \"\"\"\n    Description:\n        Returns the first index of the array (vector) x containing the value i.\n    Parameters:\n        x: one-dimensional array\n        i: search value\n    \"\"\"\n    for ind in range(len(x)):\n        if i == x[ind]:\n            return ind\n    return -1", "code_tokens": "def get_index_nested ( x , i ) : for ind in range ( len ( x ) ) : if i == x [ ind ] : return ind return - 1", "docstring_tokens": "Description : Returns the first index of the array ( vector ) x containing the value i . Parameters : x : one - dimensional array i : search value", "label": 1}, {"idx": "cosqa-train-11204", "doc": "python if (not boolean)", "code": "def process_bool_arg(arg):\n    \"\"\" Determine True/False from argument \"\"\"\n    if isinstance(arg, bool):\n        return arg\n    elif isinstance(arg, basestring):\n        if arg.lower() in [\"true\", \"1\"]:\n            return True\n        elif arg.lower() in [\"false\", \"0\"]:\n            return False", "code_tokens": "def process_bool_arg ( arg ) : if isinstance ( arg , bool ) : return arg elif isinstance ( arg , basestring ) : if arg . lower ( ) in [ \"true\" , \"1\" ] : return True elif arg . lower ( ) in [ \"false\" , \"0\" ] : return False", "docstring_tokens": "Determine True / False from argument", "label": 1}, {"idx": "cosqa-train-11205", "doc": "get the length of a file in python", "code": "def file_length(file_obj):\n    \"\"\"\n    Returns the length in bytes of a given file object.\n    Necessary because os.fstat only works on real files and not file-like\n    objects. This works on more types of streams, primarily StringIO.\n    \"\"\"\n    file_obj.seek(0, 2)\n    length = file_obj.tell()\n    file_obj.seek(0)\n    return length", "code_tokens": "def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length", "docstring_tokens": "Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO .", "label": 1}, {"idx": "cosqa-train-11206", "doc": "python if folder exist and create", "code": "def ensure_dir_exists(directory):\n    \"\"\"Se asegura de que un directorio exista.\"\"\"\n    if directory and not os.path.exists(directory):\n        os.makedirs(directory)", "code_tokens": "def ensure_dir_exists ( directory ) : if directory and not os . path . exists ( directory ) : os . makedirs ( directory )", "docstring_tokens": "Se asegura de que un directorio exista .", "label": 1}, {"idx": "cosqa-train-11207", "doc": "get the most common element from list python", "code": "def mostCommonItem(lst):\n    \"\"\"Choose the most common item from the list, or the first item if all\n    items are unique.\"\"\"\n    # This elegant solution from: http://stackoverflow.com/a/1518632/1760218\n    lst = [l for l in lst if l]\n    if lst:\n        return max(set(lst), key=lst.count)\n    else:\n        return None", "code_tokens": "def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None", "docstring_tokens": "Choose the most common item from the list or the first item if all items are unique .", "label": 1}, {"idx": "cosqa-train-11208", "doc": "python if subset isin set", "code": "def issuperset(self, other):\n        \"\"\"Report whether this RangeSet contains another set.\"\"\"\n        self._binary_sanity_check(other)\n        return set.issuperset(self, other)", "code_tokens": "def issuperset ( self , other ) : self . _binary_sanity_check ( other ) return set . issuperset ( self , other )", "docstring_tokens": "Report whether this RangeSet contains another set .", "label": 1}, {"idx": "cosqa-train-11209", "doc": "python image crop and pad", "code": "def resize_image_with_crop_or_pad(img, target_height, target_width):\n    \"\"\"\n    Crops and/or pads an image to a target width and height.\n\n    Resizes an image to a target width and height by either cropping the image or padding it with zeros.\n\n    NO CENTER CROP. NO CENTER PAD. (Just fill bottom right or crop bottom right)\n\n    :param img: Numpy array representing the image.\n    :param target_height: Target height.\n    :param target_width: Target width.\n    :return: The cropped and padded image.\n    \"\"\"\n    h, w = target_height, target_width\n    max_h, max_w, c = img.shape\n\n    # crop\n    img = crop_center(img, min(max_h, h), min(max_w, w))\n\n    # pad\n    padded_img = np.zeros(shape=(h, w, c), dtype=img.dtype)\n    padded_img[:img.shape[0], :img.shape[1], :img.shape[2]] = img\n\n    return padded_img", "code_tokens": "def resize_image_with_crop_or_pad ( img , target_height , target_width ) : h , w = target_height , target_width max_h , max_w , c = img . shape # crop img = crop_center ( img , min ( max_h , h ) , min ( max_w , w ) ) # pad padded_img = np . zeros ( shape = ( h , w , c ) , dtype = img . dtype ) padded_img [ : img . shape [ 0 ] , : img . shape [ 1 ] , : img . shape [ 2 ] ] = img return padded_img", "docstring_tokens": "Crops and / or pads an image to a target width and height .", "label": 1}, {"idx": "cosqa-train-11210", "doc": "get traceback in dll from python", "code": "def debug_on_error(type, value, tb):\n    \"\"\"Code due to Thomas Heller - published in Python Cookbook (O'Reilley)\"\"\"\n    traceback.print_exc(type, value, tb)\n    print()\n    pdb.pm()", "code_tokens": "def debug_on_error ( type , value , tb ) : traceback . print_exc ( type , value , tb ) print ( ) pdb . pm ( )", "docstring_tokens": "Code due to Thomas Heller - published in Python Cookbook ( O Reilley )", "label": 1}, {"idx": "cosqa-train-11211", "doc": "python image margin padding", "code": "def __call__(self, img):\n        \"\"\"\n        Args:\n            img (PIL Image): Image to be padded.\n\n        Returns:\n            PIL Image: Padded image.\n        \"\"\"\n        return F.pad(img, self.padding, self.fill, self.padding_mode)", "code_tokens": "def __call__ ( self , img ) : return F . pad ( img , self . padding , self . fill , self . padding_mode )", "docstring_tokens": "Args : img ( PIL Image ) : Image to be padded .", "label": 1}, {"idx": "cosqa-train-11212", "doc": "get utc time from datetime python", "code": "def timestamp_from_datetime(dt):\n    \"\"\"\n    Compute timestamp from a datetime object that could be timezone aware\n    or unaware.\n    \"\"\"\n    try:\n        utc_dt = dt.astimezone(pytz.utc)\n    except ValueError:\n        utc_dt = dt.replace(tzinfo=pytz.utc)\n    return timegm(utc_dt.timetuple())", "code_tokens": "def timestamp_from_datetime ( dt ) : try : utc_dt = dt . astimezone ( pytz . utc ) except ValueError : utc_dt = dt . replace ( tzinfo = pytz . utc ) return timegm ( utc_dt . timetuple ( ) )", "docstring_tokens": "Compute timestamp from a datetime object that could be timezone aware or unaware .", "label": 1}, {"idx": "cosqa-train-11213", "doc": "python image resize and save", "code": "def resize_image(self, data, size):\n        \"\"\" Resizes the given image to fit inside a box of the given size. \"\"\"\n        from machina.core.compat import PILImage as Image\n        image = Image.open(BytesIO(data))\n\n        # Resize!\n        image.thumbnail(size, Image.ANTIALIAS)\n\n        string = BytesIO()\n        image.save(string, format='PNG')\n        return string.getvalue()", "code_tokens": "def resize_image ( self , data , size ) : from machina . core . compat import PILImage as Image image = Image . open ( BytesIO ( data ) ) # Resize! image . thumbnail ( size , Image . ANTIALIAS ) string = BytesIO ( ) image . save ( string , format = 'PNG' ) return string . getvalue ( )", "docstring_tokens": "Resizes the given image to fit inside a box of the given size .", "label": 1}, {"idx": "cosqa-train-11214", "doc": "get values callable iterator python", "code": "def find_all(self, string, callback):\n\t\t\"\"\"\n\t\tWrapper on iter method, callback gets an iterator result\n\t\t\"\"\"\n\t\tfor index, output in self.iter(string):\n\t\t\tcallback(index, output)", "code_tokens": "def find_all ( self , string , callback ) : for index , output in self . iter ( string ) : callback ( index , output )", "docstring_tokens": "Wrapper on iter method callback gets an iterator result", "label": 1}, {"idx": "cosqa-train-11215", "doc": "python image resize aspect ratio", "code": "def scale_image(image, new_width):\n    \"\"\"Resizes an image preserving the aspect ratio.\n    \"\"\"\n    (original_width, original_height) = image.size\n    aspect_ratio = original_height/float(original_width)\n    new_height = int(aspect_ratio * new_width)\n\n    # This scales it wider than tall, since characters are biased\n    new_image = image.resize((new_width*2, new_height))\n    return new_image", "code_tokens": "def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image", "docstring_tokens": "Resizes an image preserving the aspect ratio .", "label": 1}, {"idx": "cosqa-train-11216", "doc": "getelementsbytagname python get all child", "code": "def getChildElementsByTagName(self, tagName):\n    \"\"\" Return child elements of type tagName if found, else [] \"\"\"\n    result = []\n    for child in self.childNodes:\n        if isinstance(child, Element):\n            if child.tagName == tagName:\n                result.append(child)\n    return result", "code_tokens": "def getChildElementsByTagName ( self , tagName ) : result = [ ] for child in self . childNodes : if isinstance ( child , Element ) : if child . tagName == tagName : result . append ( child ) return result", "docstring_tokens": "Return child elements of type tagName if found else []", "label": 1}, {"idx": "cosqa-train-11217", "doc": "python image rgb to hsl hue", "code": "def _hue(color, **kwargs):\n    \"\"\" Get hue value of HSL color.\n    \"\"\"\n    h = colorsys.rgb_to_hls(*[x / 255.0 for x in color.value[:3]])[0]\n    return NumberValue(h * 360.0)", "code_tokens": "def _hue ( color , * * kwargs ) : h = colorsys . rgb_to_hls ( * [ x / 255.0 for x in color . value [ : 3 ] ] ) [ 0 ] return NumberValue ( h * 360.0 )", "docstring_tokens": "Get hue value of HSL color .", "label": 1}, {"idx": "cosqa-train-11218", "doc": "go through the folder and select files python", "code": "def search_script_directory(self, path):\n        \"\"\"\n        Recursively loop through a directory to find all python\n        script files. When one is found, it is analyzed for import statements\n        :param path: string\n        :return: generator\n        \"\"\"\n        for subdir, dirs, files in os.walk(path):\n            for file_name in files:\n                if file_name.endswith(\".py\"):\n                    self.search_script_file(subdir, file_name)", "code_tokens": "def search_script_directory ( self , path ) : for subdir , dirs , files in os . walk ( path ) : for file_name in files : if file_name . endswith ( \".py\" ) : self . search_script_file ( subdir , file_name )", "docstring_tokens": "Recursively loop through a directory to find all python script files . When one is found it is analyzed for import statements : param path : string : return : generator", "label": 1}, {"idx": "cosqa-train-11219", "doc": "python implement a bytes like object", "code": "def _from_bytes(bytes, byteorder=\"big\", signed=False):\n    \"\"\"This is the same functionality as ``int.from_bytes`` in python 3\"\"\"\n    return int.from_bytes(bytes, byteorder=byteorder, signed=signed)", "code_tokens": "def _from_bytes ( bytes , byteorder = \"big\" , signed = False ) : return int . from_bytes ( bytes , byteorder = byteorder , signed = signed )", "docstring_tokens": "This is the same functionality as int . from_bytes in python 3", "label": 1}, {"idx": "cosqa-train-11220", "doc": "graph dfs detect cycle python", "code": "def dfs_recursive(graph, node, seen):\n    \"\"\"DFS, detect connected component, recursive implementation\n\n    :param graph: directed graph in listlist or listdict format\n    :param int node: to start graph exploration\n    :param boolean-table seen: will be set true for the connected component\n          containing node.\n    :complexity: `O(|V|+|E|)`\n    \"\"\"\n    seen[node] = True\n    for neighbor in graph[node]:\n        if not seen[neighbor]:\n            dfs_recursive(graph, neighbor, seen)", "code_tokens": "def dfs_recursive ( graph , node , seen ) : seen [ node ] = True for neighbor in graph [ node ] : if not seen [ neighbor ] : dfs_recursive ( graph , neighbor , seen )", "docstring_tokens": "DFS detect connected component recursive implementation", "label": 1}, {"idx": "cosqa-train-11221", "doc": "python implement matrix inverse", "code": "def inverse(self):\n        \"\"\"\n        Returns inverse of transformation.\n        \"\"\"\n        invr = np.linalg.inv(self.affine_matrix)\n        return SymmOp(invr)", "code_tokens": "def inverse ( self ) : invr = np . linalg . inv ( self . affine_matrix ) return SymmOp ( invr )", "docstring_tokens": "Returns inverse of transformation .", "label": 1}, {"idx": "cosqa-train-11222", "doc": "graph from dictionary networkx python", "code": "def to_networkx(graph):\n    \"\"\" Convert a Mapper 1-complex to a networkx graph.\n\n    Parameters\n    -----------\n\n    graph: dictionary, graph object returned from `kmapper.map`\n\n    Returns\n    --------\n\n    g: graph as networkx.Graph() object\n\n    \"\"\"\n\n    # import here so networkx is not always required.\n    import networkx as nx\n\n    nodes = graph[\"nodes\"].keys()\n    edges = [[start, end] for start, ends in graph[\"links\"].items() for end in ends]\n\n    g = nx.Graph()\n    g.add_nodes_from(nodes)\n    nx.set_node_attributes(g, dict(graph[\"nodes\"]), \"membership\")\n\n    g.add_edges_from(edges)\n\n    return g", "code_tokens": "def to_networkx ( graph ) : # import here so networkx is not always required. import networkx as nx nodes = graph [ \"nodes\" ] . keys ( ) edges = [ [ start , end ] for start , ends in graph [ \"links\" ] . items ( ) for end in ends ] g = nx . Graph ( ) g . add_nodes_from ( nodes ) nx . set_node_attributes ( g , dict ( graph [ \"nodes\" ] ) , \"membership\" ) g . add_edges_from ( edges ) return g", "docstring_tokens": "Convert a Mapper 1 - complex to a networkx graph .", "label": 1}, {"idx": "cosqa-train-11223", "doc": "python indentation back shidt", "code": "def indent(self):\n        \"\"\"\n        Begins an indented block. Must be used in a 'with' code block.\n        All calls to the logger inside of the block will be indented.\n        \"\"\"\n        blk = IndentBlock(self, self._indent)\n        self._indent += 1\n        return blk", "code_tokens": "def indent ( self ) : blk = IndentBlock ( self , self . _indent ) self . _indent += 1 return blk", "docstring_tokens": "Begins an indented block . Must be used in a with code block . All calls to the logger inside of the block will be indented .", "label": 1}, {"idx": "cosqa-train-11224", "doc": "graphviz python to png", "code": "def _text_to_graphiz(self, text):\n        \"\"\"create a graphviz graph from text\"\"\"\n        dot = Source(text, format='svg')\n        return dot.pipe().decode('utf-8')", "code_tokens": "def _text_to_graphiz ( self , text ) : dot = Source ( text , format = 'svg' ) return dot . pipe ( ) . decode ( 'utf-8' )", "docstring_tokens": "create a graphviz graph from text", "label": 1}, {"idx": "cosqa-train-11225", "doc": "python index for first column name", "code": "def _get_col_index(name):\n    \"\"\"Convert column name to index.\"\"\"\n\n    index = string.ascii_uppercase.index\n    col = 0\n    for c in name.upper():\n        col = col * 26 + index(c) + 1\n    return col", "code_tokens": "def _get_col_index ( name ) : index = string . ascii_uppercase . index col = 0 for c in name . upper ( ) : col = col * 26 + index ( c ) + 1 return col", "docstring_tokens": "Convert column name to index .", "label": 1}, {"idx": "cosqa-train-11226", "doc": "gray scale image to matrix in python", "code": "def rgb2gray(img):\n    \"\"\"Converts an RGB image to grayscale using matlab's algorithm.\"\"\"\n    T = np.linalg.inv(np.array([\n        [1.0,  0.956,  0.621],\n        [1.0, -0.272, -0.647],\n        [1.0, -1.106,  1.703],\n    ]))\n    r_c, g_c, b_c = T[0]\n    r, g, b = np.rollaxis(as_float_image(img), axis=-1)\n    return r_c * r + g_c * g + b_c * b", "code_tokens": "def rgb2gray ( img ) : T = np . linalg . inv ( np . array ( [ [ 1.0 , 0.956 , 0.621 ] , [ 1.0 , - 0.272 , - 0.647 ] , [ 1.0 , - 1.106 , 1.703 ] , ] ) ) r_c , g_c , b_c = T [ 0 ] r , g , b = np . rollaxis ( as_float_image ( img ) , axis = - 1 ) return r_c * r + g_c * g + b_c * b", "docstring_tokens": "Converts an RGB image to grayscale using matlab s algorithm .", "label": 0}, {"idx": "cosqa-train-11227", "doc": "python index of maximum value array", "code": "def MultiArgMax(x):\n  \"\"\"\n  Get tuple (actually a generator) of indices where the max value of\n  array x occurs. Requires that x have a max() method, as x.max()\n  (in the case of NumPy) is much faster than max(x).\n  For a simpler, faster argmax when there is only a single maximum entry,\n  or when knowing only the first index where the maximum occurs,\n  call argmax() on a NumPy array.\n\n  :param x: Any sequence that has a max() method.\n  :returns: Generator with the indices where the max value occurs.\n  \"\"\"\n  m = x.max()\n  return (i for i, v in enumerate(x) if v == m)", "code_tokens": "def MultiArgMax ( x ) : m = x . max ( ) return ( i for i , v in enumerate ( x ) if v == m )", "docstring_tokens": "Get tuple ( actually a generator ) of indices where the max value of array x occurs . Requires that x have a max () method as x . max () ( in the case of NumPy ) is much faster than max ( x ) . For a simpler faster argmax when there is only a single maximum entry or when knowing only the first index where the maximum occurs call argmax () on a NumPy array .", "label": 1}, {"idx": "cosqa-train-11228", "doc": "hamming distance calculation string in python", "code": "def hamming(s, t):\n    \"\"\"\n    Calculate the Hamming distance between two strings. From Wikipedia article: Iterative with two matrix rows.\n\n    :param s: string 1\n    :type s: str\n    :param t: string 2\n    :type s: str\n    :return: Hamming distance\n    :rtype: float\n    \"\"\"\n    if len(s) != len(t):\n        raise ValueError('Hamming distance needs strings of equal length.')\n    return sum(s_ != t_ for s_, t_ in zip(s, t))", "code_tokens": "def hamming ( s , t ) : if len ( s ) != len ( t ) : raise ValueError ( 'Hamming distance needs strings of equal length.' ) return sum ( s_ != t_ for s_ , t_ in zip ( s , t ) )", "docstring_tokens": "Calculate the Hamming distance between two strings . From Wikipedia article : Iterative with two matrix rows .", "label": 1}, {"idx": "cosqa-train-11229", "doc": "python indexing with list of booleans", "code": "def equal(list1, list2):\n    \"\"\" takes flags returns indexes of True values \"\"\"\n    return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]", "code_tokens": "def equal ( list1 , list2 ) : return [ item1 == item2 for item1 , item2 in broadcast_zip ( list1 , list2 ) ]", "docstring_tokens": "takes flags returns indexes of True values", "label": 1}, {"idx": "cosqa-train-11230", "doc": "hash of string python stack overflow", "code": "def _string_hash(s):\n    \"\"\"String hash (djb2) with consistency between py2/py3 and persistency between runs (unlike `hash`).\"\"\"\n    h = 5381\n    for c in s:\n        h = h * 33 + ord(c)\n    return h", "code_tokens": "def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h", "docstring_tokens": "String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) .", "label": 0}, {"idx": "cosqa-train-11231", "doc": "python inspect getmembers example", "code": "def get_public_members(obj):\n    \"\"\"\n    Retrieves a list of member-like objects (members or properties) that are\n    publically exposed.\n\n    :param obj: The object to probe.\n    :return:    A list of strings.\n    \"\"\"\n    return {attr: getattr(obj, attr) for attr in dir(obj)\n            if not attr.startswith(\"_\")\n            and not hasattr(getattr(obj, attr), '__call__')}", "code_tokens": "def get_public_members ( obj ) : return { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( \"_\" ) and not hasattr ( getattr ( obj , attr ) , '__call__' ) }", "docstring_tokens": "Retrieves a list of member - like objects ( members or properties ) that are publically exposed .", "label": 1}, {"idx": "cosqa-train-11232", "doc": "hide a tkinter window python", "code": "def hide(self):\n        \"\"\"Hide the window.\"\"\"\n        self.tk.withdraw()\n        self._visible = False\n        if self._modal:\n            self.tk.grab_release()", "code_tokens": "def hide ( self ) : self . tk . withdraw ( ) self . _visible = False if self . _modal : self . tk . grab_release ( )", "docstring_tokens": "Hide the window .", "label": 1}, {"idx": "cosqa-train-11233", "doc": "python inspect how to get the function name from the stack", "code": "def _module_name_from_previous_frame(num_frames_back):\n    \"\"\"\n    Returns the module name associated with a frame `num_frames_back` in the\n    call stack. This function adds 1 to account for itself, so `num_frames_back`\n    should be given relative to the caller.\n    \"\"\"\n    frm = inspect.stack()[num_frames_back + 1]\n    return inspect.getmodule(frm[0]).__name__", "code_tokens": "def _module_name_from_previous_frame ( num_frames_back ) : frm = inspect . stack ( ) [ num_frames_back + 1 ] return inspect . getmodule ( frm [ 0 ] ) . __name__", "docstring_tokens": "Returns the module name associated with a frame num_frames_back in the call stack . This function adds 1 to account for itself so num_frames_back should be given relative to the caller .", "label": 1}, {"idx": "cosqa-train-11234", "doc": "how can i combine all the elements in a list in python", "code": "def combinations(l):\n    \"\"\"Pure-Python implementation of itertools.combinations(l, 2).\"\"\"\n    result = []\n    for x in xrange(len(l) - 1):\n        ls = l[x + 1:]\n        for y in ls:\n            result.append((l[x], y))\n    return result", "code_tokens": "def combinations ( l ) : result = [ ] for x in xrange ( len ( l ) - 1 ) : ls = l [ x + 1 : ] for y in ls : result . append ( ( l [ x ] , y ) ) return result", "docstring_tokens": "Pure - Python implementation of itertools . combinations ( l 2 ) .", "label": 1}, {"idx": "cosqa-train-11235", "doc": "python instance del count", "code": "def pop():\n        \"\"\"Remove instance from instance list\"\"\"\n        pid = os.getpid()\n        thread = threading.current_thread()\n        Wdb._instances.pop((pid, thread))", "code_tokens": "def pop ( ) : pid = os . getpid ( ) thread = threading . current_thread ( ) Wdb . _instances . pop ( ( pid , thread ) )", "docstring_tokens": "Remove instance from instance list", "label": 1}, {"idx": "cosqa-train-11236", "doc": "how decompiled python code looks like", "code": "def xeval(source, optimize=True):\n    \"\"\"Compiles to native Python bytecode and runs program, returning the\n    topmost value on the stack.\n\n    Args:\n        optimize: Whether to optimize the code after parsing it.\n\n    Returns:\n        None: If the stack is empty\n        obj: If the stack contains a single value\n        [obj, obj, ...]: If the stack contains many values\n    \"\"\"\n    native = xcompile(source, optimize=optimize)\n    return native()", "code_tokens": "def xeval ( source , optimize = True ) : native = xcompile ( source , optimize = optimize ) return native ( )", "docstring_tokens": "Compiles to native Python bytecode and runs program returning the topmost value on the stack .", "label": 1}, {"idx": "cosqa-train-11237", "doc": "python integers floats strings", "code": "def type_converter(text):\n    \"\"\" I convert strings into integers, floats, and strings! \"\"\"\n    if text.isdigit():\n        return int(text), int\n\n    try:\n        return float(text), float\n    except ValueError:\n        return text, STRING_TYPE", "code_tokens": "def type_converter ( text ) : if text . isdigit ( ) : return int ( text ) , int try : return float ( text ) , float except ValueError : return text , STRING_TYPE", "docstring_tokens": "I convert strings into integers floats and strings!", "label": 1}, {"idx": "cosqa-train-11238", "doc": "how do functions in python know the parametr type", "code": "def is_symbol(string):\n    \"\"\"\n    Return true if the string is a mathematical symbol.\n    \"\"\"\n    return (\n        is_int(string) or is_float(string) or\n        is_constant(string) or is_unary(string) or\n        is_binary(string) or\n        (string == '(') or (string == ')')\n    )", "code_tokens": "def is_symbol ( string ) : return ( is_int ( string ) or is_float ( string ) or is_constant ( string ) or is_unary ( string ) or is_binary ( string ) or ( string == '(' ) or ( string == ')' ) )", "docstring_tokens": "Return true if the string is a mathematical symbol .", "label": 1}, {"idx": "cosqa-train-11239", "doc": "python interactive shell color", "code": "def auto():\n\t\"\"\"set colouring on if STDOUT is a terminal device, off otherwise\"\"\"\n\ttry:\n\t\tStyle.enabled = False\n\t\tStyle.enabled = sys.stdout.isatty()\n\texcept (AttributeError, TypeError):\n\t\tpass", "code_tokens": "def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass", "docstring_tokens": "set colouring on if STDOUT is a terminal device off otherwise", "label": 1}, {"idx": "cosqa-train-11240", "doc": "how do i change the root directory to run the python code", "code": "def getpackagepath():\n    \"\"\"\n     *Get the root path for this python package - used in unit testing code*\n    \"\"\"\n    moduleDirectory = os.path.dirname(__file__)\n    packagePath = os.path.dirname(__file__) + \"/../\"\n\n    return packagePath", "code_tokens": "def getpackagepath ( ) : moduleDirectory = os . path . dirname ( __file__ ) packagePath = os . path . dirname ( __file__ ) + \"/../\" return packagePath", "docstring_tokens": "* Get the root path for this python package - used in unit testing code *", "label": 0}, {"idx": "cosqa-train-11241", "doc": "python interactive window python is not defined", "code": "def isInteractive():\n    \"\"\"\n    A basic check of if the program is running in interactive mode\n    \"\"\"\n    if sys.stdout.isatty() and os.name != 'nt':\n        #Hopefully everything but ms supports '\\r'\n        try:\n            import threading\n        except ImportError:\n            return False\n        else:\n            return True\n    else:\n        return False", "code_tokens": "def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\\r' try : import threading except ImportError : return False else : return True else : return False", "docstring_tokens": "A basic check of if the program is running in interactive mode", "label": 1}, {"idx": "cosqa-train-11242", "doc": "how do i get tensorflow for python", "code": "def get_example_features(example):\n  \"\"\"Returns the non-sequence features from the provided example.\"\"\"\n  return (example.features.feature if isinstance(example, tf.train.Example)\n          else example.context.feature)", "code_tokens": "def get_example_features ( example ) : return ( example . features . feature if isinstance ( example , tf . train . Example ) else example . context . feature )", "docstring_tokens": "Returns the non - sequence features from the provided example .", "label": 1}, {"idx": "cosqa-train-11243", "doc": "python interger to binary", "code": "def intToBin(i):\n    \"\"\" Integer to two bytes \"\"\"\n    # devide in two parts (bytes)\n    i1 = i % 256\n    i2 = int(i / 256)\n    # make string (little endian)\n    return chr(i1) + chr(i2)", "code_tokens": "def intToBin ( i ) : # devide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return chr ( i1 ) + chr ( i2 )", "docstring_tokens": "Integer to two bytes", "label": 1}, {"idx": "cosqa-train-11244", "doc": "how do i get the ascii representation of a char in python", "code": "def to_unicode_repr( _letter ):\n    \"\"\" helpful in situations where browser/app may recognize Unicode encoding\n        in the \\u0b8e type syntax but not actual unicode glyph/code-point\"\"\"\n    # Python 2-3 compatible\n    return u\"u'\"+ u\"\".join( [ u\"\\\\u%04x\"%ord(l) for l in _letter ] ) + u\"'\"", "code_tokens": "def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u\"u'\" + u\"\" . join ( [ u\"\\\\u%04x\" % ord ( l ) for l in _letter ] ) + u\"'\"", "docstring_tokens": "helpful in situations where browser / app may recognize Unicode encoding in the \\ u0b8e type syntax but not actual unicode glyph / code - point", "label": 0}, {"idx": "cosqa-train-11245", "doc": "python interpolate between different coordinate matrices", "code": "def _linearInterpolationTransformMatrix(matrix1, matrix2, value):\n    \"\"\" Linear, 'oldstyle' interpolation of the transform matrix.\"\"\"\n    return tuple(_interpolateValue(matrix1[i], matrix2[i], value) for i in range(len(matrix1)))", "code_tokens": "def _linearInterpolationTransformMatrix ( matrix1 , matrix2 , value ) : return tuple ( _interpolateValue ( matrix1 [ i ] , matrix2 [ i ] , value ) for i in range ( len ( matrix1 ) ) )", "docstring_tokens": "Linear oldstyle interpolation of the transform matrix .", "label": 1}, {"idx": "cosqa-train-11246", "doc": "how do i know if a folder exits in python", "code": "def isdir(s):\n    \"\"\"Return true if the pathname refers to an existing directory.\"\"\"\n    try:\n        st = os.stat(s)\n    except os.error:\n        return False\n    return stat.S_ISDIR(st.st_mode)", "code_tokens": "def isdir ( s ) : try : st = os . stat ( s ) except os . error : return False return stat . S_ISDIR ( st . st_mode )", "docstring_tokens": "Return true if the pathname refers to an existing directory .", "label": 1}, {"idx": "cosqa-train-11247", "doc": "python io open file with exclusive access permissions", "code": "def fopenat(base_fd, path):\n    \"\"\"\n    Does openat read-only, then does fdopen to get a file object\n    \"\"\"\n\n    return os.fdopen(openat(base_fd, path, os.O_RDONLY), 'rb')", "code_tokens": "def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )", "docstring_tokens": "Does openat read - only then does fdopen to get a file object", "label": 1}, {"idx": "cosqa-train-11248", "doc": "how do i mae the cursor on python skinny again", "code": "def hidden_cursor(self):\n        \"\"\"Return a context manager that hides the cursor while inside it and\n        makes it visible on leaving.\"\"\"\n        self.stream.write(self.hide_cursor)\n        try:\n            yield\n        finally:\n            self.stream.write(self.normal_cursor)", "code_tokens": "def hidden_cursor ( self ) : self . stream . write ( self . hide_cursor ) try : yield finally : self . stream . write ( self . normal_cursor )", "docstring_tokens": "Return a context manager that hides the cursor while inside it and makes it visible on leaving .", "label": 1}, {"idx": "cosqa-train-11249", "doc": "python ipywidgets 'function' object is not subscriptable", "code": "def widget(self, f):\n        \"\"\"\n        Return an interactive function widget for the given function.\n\n        The widget is only constructed, not displayed nor attached to\n        the function.\n\n        Returns\n        -------\n        An instance of ``self.cls`` (typically :class:`interactive`).\n\n        Parameters\n        ----------\n        f : function\n            The function to which the interactive widgets are tied.\n        \"\"\"\n        return self.cls(f, self.opts, **self.kwargs)", "code_tokens": "def widget ( self , f ) : return self . cls ( f , self . opts , * * self . kwargs )", "docstring_tokens": "Return an interactive function widget for the given function .", "label": 0}, {"idx": "cosqa-train-11250", "doc": "how do i parse data from command line in python", "code": "def main(pargs):\n    \"\"\"This should only be used for testing. The primary mode of operation is\n    as an imported library.\n    \"\"\"\n    input_file = sys.argv[1]\n    fp = ParseFileLineByLine(input_file)\n    for i in fp:\n        print(i)", "code_tokens": "def main ( pargs ) : input_file = sys . argv [ 1 ] fp = ParseFileLineByLine ( input_file ) for i in fp : print ( i )", "docstring_tokens": "This should only be used for testing . The primary mode of operation is as an imported library .", "label": 1}, {"idx": "cosqa-train-11251", "doc": "python is last date of month", "code": "def last_day(year=_year, month=_month):\n    \"\"\"\n    get the current month's last day\n    :param year:  default to current year\n    :param month:  default to current month\n    :return: month's last day\n    \"\"\"\n    last_day = calendar.monthrange(year, month)[1]\n    return datetime.date(year=year, month=month, day=last_day)", "code_tokens": "def last_day ( year = _year , month = _month ) : last_day = calendar . monthrange ( year , month ) [ 1 ] return datetime . date ( year = year , month = month , day = last_day )", "docstring_tokens": "get the current month s last day : param year : default to current year : param month : default to current month : return : month s last day", "label": 1}, {"idx": "cosqa-train-11252", "doc": "how do i reset python spyder", "code": "def restart(self, reset=False):\n        \"\"\"\n        Quit and Restart Spyder application.\n\n        If reset True it allows to reset spyder on restart.\n        \"\"\"\n        # Get start path to use in restart script\n        spyder_start_directory = get_module_path('spyder')\n        restart_script = osp.join(spyder_start_directory, 'app', 'restart.py')\n\n        # Get any initial argument passed when spyder was started\n        # Note: Variables defined in bootstrap.py and spyder/app/start.py\n        env = os.environ.copy()\n        bootstrap_args = env.pop('SPYDER_BOOTSTRAP_ARGS', None)\n        spyder_args = env.pop('SPYDER_ARGS')\n\n        # Get current process and python running spyder\n        pid = os.getpid()\n        python = sys.executable\n\n        # Check if started with bootstrap.py\n        if bootstrap_args is not None:\n            spyder_args = bootstrap_args\n            is_bootstrap = True\n        else:\n            is_bootstrap = False\n\n        # Pass variables as environment variables (str) to restarter subprocess\n        env['SPYDER_ARGS'] = spyder_args\n        env['SPYDER_PID'] = str(pid)\n        env['SPYDER_IS_BOOTSTRAP'] = str(is_bootstrap)\n        env['SPYDER_RESET'] = str(reset)\n\n        if DEV:\n            if os.name == 'nt':\n                env['PYTHONPATH'] = ';'.join(sys.path)\n            else:\n                env['PYTHONPATH'] = ':'.join(sys.path)\n\n        # Build the command and popen arguments depending on the OS\n        if os.name == 'nt':\n            # Hide flashing command prompt\n            startupinfo = subprocess.STARTUPINFO()\n            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n            shell = False\n        else:\n            startupinfo = None\n            shell = True\n\n        command = '\"{0}\" \"{1}\"'\n        command = command.format(python, restart_script)\n\n        try:\n            if self.closing(True):\n                subprocess.Popen(command, shell=shell, env=env,\n                                 startupinfo=startupinfo)\n                self.console.quit()\n        except Exception as error:\n            # If there is an error with subprocess, Spyder should not quit and\n            # the error can be inspected in the internal console\n            print(error)  # spyder: test-skip\n            print(command)", "code_tokens": "def restart ( self , reset = False ) : # Get start path to use in restart script\n spyder_start_directory = get_module_path ( 'spyder' ) restart_script = osp . join ( spyder_start_directory , 'app' , 'restart.py' ) # Get any initial argument passed when spyder was started\n # Note: Variables defined in bootstrap.py and spyder/app/start.py\n env = os . environ . copy ( ) bootstrap_args = env . pop ( 'SPYDER_BOOTSTRAP_ARGS' , None ) spyder_args = env . pop ( 'SPYDER_ARGS' ) # Get current process and python running spyder\n pid = os . getpid ( ) python = sys . executable # Check if started with bootstrap.py\n if bootstrap_args is not None : spyder_args = bootstrap_args is_bootstrap = True else : is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess\n env [ 'SPYDER_ARGS' ] = spyder_args env [ 'SPYDER_PID' ] = str ( pid ) env [ 'SPYDER_IS_BOOTSTRAP' ] = str ( is_bootstrap ) env [ 'SPYDER_RESET' ] = str ( reset ) if DEV : if os . name == 'nt' : env [ 'PYTHONPATH' ] = ';' . join ( sys . path ) else : env [ 'PYTHONPATH' ] = ':' . join ( sys . path ) # Build the command and popen arguments depending on the OS\n if os . name == 'nt' : # Hide flashing command prompt\n startupinfo = subprocess . STARTUPINFO ( ) startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW shell = False else : startupinfo = None shell = True command = '\"{0}\" \"{1}\"' command = command . format ( python , restart_script ) try : if self . closing ( True ) : subprocess . Popen ( command , shell = shell , env = env , startupinfo = startupinfo ) self . console . quit ( ) except Exception as error : # If there is an error with subprocess, Spyder should not quit and\n # the error can be inspected in the internal console\n print ( error ) # spyder: test-skip\n print ( command )", "docstring_tokens": "Quit and Restart Spyder application . If reset True it allows to reset spyder on restart .", "label": 0}, {"idx": "cosqa-train-11253", "doc": "python is not none syntax", "code": "def _not_none(items):\n    \"\"\"Whether the item is a placeholder or contains a placeholder.\"\"\"\n    if not isinstance(items, (tuple, list)):\n        items = (items,)\n    return all(item is not _none for item in items)", "code_tokens": "def _not_none ( items ) : if not isinstance ( items , ( tuple , list ) ) : items = ( items , ) return all ( item is not _none for item in items )", "docstring_tokens": "Whether the item is a placeholder or contains a placeholder .", "label": 0}, {"idx": "cosqa-train-11254", "doc": "how do i run a django python program", "code": "def server(port):\n    \"\"\"Start the Django dev server.\"\"\"\n    args = ['python', 'manage.py', 'runserver']\n    if port:\n        args.append(port)\n    run.main(args)", "code_tokens": "def server ( port ) : args = [ 'python' , 'manage.py' , 'runserver' ] if port : args . append ( port ) run . main ( args )", "docstring_tokens": "Start the Django dev server .", "label": 1}, {"idx": "cosqa-train-11255", "doc": "python is not none\\", "code": "def less_strict_bool(x):\n    \"\"\"Idempotent and None-safe version of strict_bool.\"\"\"\n    if x is None:\n        return False\n    elif x is True or x is False:\n        return x\n    else:\n        return strict_bool(x)", "code_tokens": "def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )", "docstring_tokens": "Idempotent and None - safe version of strict_bool .", "label": 1}, {"idx": "cosqa-train-11256", "doc": "how do i set int64 as the default in python", "code": "def safe_int(val, default=None):\n    \"\"\"\n    Returns int() of val if val is not convertable to int use default\n    instead\n\n    :param val:\n    :param default:\n    \"\"\"\n\n    try:\n        val = int(val)\n    except (ValueError, TypeError):\n        val = default\n\n    return val", "code_tokens": "def safe_int ( val , default = None ) : try : val = int ( val ) except ( ValueError , TypeError ) : val = default return val", "docstring_tokens": "Returns int () of val if val is not convertable to int use default instead", "label": 1}, {"idx": "cosqa-train-11257", "doc": "python iterate an nest dict and return", "code": "def _iterate_flattened_values(value):\n  \"\"\"Provides an iterator over all values in a nested structure.\"\"\"\n  if isinstance(value, six.string_types):\n    yield value\n    return\n\n  if isinstance(value, collections.Mapping):\n    value = collections.ValuesView(value)\n\n  if isinstance(value, collections.Iterable):\n    for nested_value in value:\n      for nested_nested_value in _iterate_flattened_values(nested_value):\n        yield nested_nested_value\n\n  yield value", "code_tokens": "def _iterate_flattened_values ( value ) : if isinstance ( value , six . string_types ) : yield value return if isinstance ( value , collections . Mapping ) : value = collections . ValuesView ( value ) if isinstance ( value , collections . Iterable ) : for nested_value in value : for nested_nested_value in _iterate_flattened_values ( nested_value ) : yield nested_nested_value yield value", "docstring_tokens": "Provides an iterator over all values in a nested structure .", "label": 1}, {"idx": "cosqa-train-11258", "doc": "how do i tell something to print 6 lines in the paragraph in python", "code": "def erase_lines(n=1):\n    \"\"\" Erases n lines from the screen and moves the cursor up to follow\n    \"\"\"\n    for _ in range(n):\n        print(codes.cursor[\"up\"], end=\"\")\n        print(codes.cursor[\"eol\"], end=\"\")", "code_tokens": "def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ \"up\" ] , end = \"\" ) print ( codes . cursor [ \"eol\" ] , end = \"\" )", "docstring_tokens": "Erases n lines from the screen and moves the cursor up to follow", "label": 1}, {"idx": "cosqa-train-11259", "doc": "python iterate json file", "code": "def json_iter (path):\n    \"\"\"\n    iterator for JSON-per-line in a file pattern\n    \"\"\"\n    with open(path, 'r') as f:\n        for line in f.readlines():\n            yield json.loads(line)", "code_tokens": "def json_iter ( path ) : with open ( path , 'r' ) as f : for line in f . readlines ( ) : yield json . loads ( line )", "docstring_tokens": "iterator for JSON - per - line in a file pattern", "label": 1}, {"idx": "cosqa-train-11260", "doc": "how do i tokenize multiple files in python", "code": "def listified_tokenizer(source):\n    \"\"\"Tokenizes *source* and returns the tokens as a list of lists.\"\"\"\n    io_obj = io.StringIO(source)\n    return [list(a) for a in tokenize.generate_tokens(io_obj.readline)]", "code_tokens": "def listified_tokenizer ( source ) : io_obj = io . StringIO ( source ) return [ list ( a ) for a in tokenize . generate_tokens ( io_obj . readline ) ]", "docstring_tokens": "Tokenizes * source * and returns the tokens as a list of lists .", "label": 1}, {"idx": "cosqa-train-11261", "doc": "python iterate through two dictionary keys and create a list of common values as strings", "code": "def compare(dicts):\n    \"\"\"Compare by iteration\"\"\"\n\n    common_members = {}\n    common_keys = reduce(lambda x, y: x & y, map(dict.keys, dicts))\n    for k in common_keys:\n        common_members[k] = list(\n            reduce(lambda x, y: x & y, [set(d[k]) for d in dicts]))\n\n    return common_members", "code_tokens": "def compare ( dicts ) : common_members = { } common_keys = reduce ( lambda x , y : x & y , map ( dict . keys , dicts ) ) for k in common_keys : common_members [ k ] = list ( reduce ( lambda x , y : x & y , [ set ( d [ k ] ) for d in dicts ] ) ) return common_members", "docstring_tokens": "Compare by iteration", "label": 1}, {"idx": "cosqa-train-11262", "doc": "how do i use a github access token with gitpython", "code": "def check_github(self):\n        \"\"\"\n        If the requirement is frozen to a github url, check for new commits.\n\n        API Tokens\n        ----------\n        For more than 50 github api calls per hour, pipchecker requires\n        authentication with the github api by settings the environemnt\n        variable ``GITHUB_API_TOKEN`` or setting the command flag\n        --github-api-token='mytoken'``.\n\n        To create a github api token for use at the command line::\n             curl -u 'rizumu' -d '{\"scopes\":[\"repo\"], \"note\":\"pipchecker\"}' https://api.github.com/authorizations\n\n        For more info on github api tokens:\n            https://help.github.com/articles/creating-an-oauth-token-for-command-line-use\n            http://developer.github.com/v3/oauth/#oauth-authorizations-api\n\n        Requirement Format\n        ------------------\n        Pipchecker gets the sha of frozen repo and checks if it is\n        found at the head of any branches. If it is not found then\n        the requirement is considered to be out of date.\n\n        Therefore, freezing at the commit hash will provide the expected\n        results, but if freezing at a branch or tag name, pipchecker will\n        not be able to determine with certainty if the repo is out of date.\n\n        Freeze at the commit hash (sha)::\n            git+git://github.com/django/django.git@393c268e725f5b229ecb554f3fac02cfc250d2df#egg=Django\n            https://github.com/django/django/archive/393c268e725f5b229ecb554f3fac02cfc250d2df.tar.gz#egg=Django\n            https://github.com/django/django/archive/393c268e725f5b229ecb554f3fac02cfc250d2df.zip#egg=Django\n\n        Freeze with a branch name::\n            git+git://github.com/django/django.git@master#egg=Django\n            https://github.com/django/django/archive/master.tar.gz#egg=Django\n            https://github.com/django/django/archive/master.zip#egg=Django\n\n        Freeze with a tag::\n            git+git://github.com/django/django.git@1.5b2#egg=Django\n            https://github.com/django/django/archive/1.5b2.tar.gz#egg=Django\n            https://github.com/django/django/archive/1.5b2.zip#egg=Django\n\n        Do not freeze::\n            git+git://github.com/django/django.git#egg=Django\n\n        \"\"\"\n        for name, req in list(self.reqs.items()):\n            req_url = req[\"url\"]\n            if not req_url:\n                continue\n            req_url = str(req_url)\n            if req_url.startswith(\"git\") and \"github.com/\" not in req_url:\n                continue\n            if req_url.endswith((\".tar.gz\", \".tar.bz2\", \".zip\")):\n                continue\n\n            headers = {\n                \"content-type\": \"application/json\",\n            }\n            if self.github_api_token:\n                headers[\"Authorization\"] = \"token {0}\".format(self.github_api_token)\n            try:\n                path_parts = urlparse(req_url).path.split(\"#\", 1)[0].strip(\"/\").rstrip(\"/\").split(\"/\")\n\n                if len(path_parts) == 2:\n                    user, repo = path_parts\n\n                elif 'archive' in path_parts:\n                    # Supports URL of format:\n                    # https://github.com/django/django/archive/master.tar.gz#egg=Django\n                    # https://github.com/django/django/archive/master.zip#egg=Django\n                    user, repo = path_parts[:2]\n                    repo += '@' + path_parts[-1].replace('.tar.gz', '').replace('.zip', '')\n\n                else:\n                    self.style.ERROR(\"\\nFailed to parse %r\\n\" % (req_url, ))\n                    continue\n            except (ValueError, IndexError) as e:\n                self.stdout.write(self.style.ERROR(\"\\nFailed to parse %r: %s\\n\" % (req_url, e)))\n                continue\n\n            try:\n                test_auth = requests.get(\"https://api.github.com/django/\", headers=headers).json()\n            except HTTPError as e:\n                self.stdout.write(\"\\n%s\\n\" % str(e))\n                return\n\n            if \"message\" in test_auth and test_auth[\"message\"] == \"Bad credentials\":\n                self.stdout.write(self.style.ERROR(\"\\nGithub API: Bad credentials. Aborting!\\n\"))\n                return\n            elif \"message\" in test_auth and test_auth[\"message\"].startswith(\"API Rate Limit Exceeded\"):\n                self.stdout.write(self.style.ERROR(\"\\nGithub API: Rate Limit Exceeded. Aborting!\\n\"))\n                return\n\n            frozen_commit_sha = None\n            if \".git\" in repo:\n                repo_name, frozen_commit_full = repo.split(\".git\")\n                if frozen_commit_full.startswith(\"@\"):\n                    frozen_commit_sha = frozen_commit_full[1:]\n            elif \"@\" in repo:\n                repo_name, frozen_commit_sha = repo.split(\"@\")\n\n            if frozen_commit_sha is None:\n                msg = self.style.ERROR(\"repo is not frozen\")\n\n            if frozen_commit_sha:\n                branch_url = \"https://api.github.com/repos/{0}/{1}/branches\".format(user, repo_name)\n                branch_data = requests.get(branch_url, headers=headers).json()\n\n                frozen_commit_url = \"https://api.github.com/repos/{0}/{1}/commits/{2}\".format(\n                    user, repo_name, frozen_commit_sha\n                )\n                frozen_commit_data = requests.get(frozen_commit_url, headers=headers).json()\n\n                if \"message\" in frozen_commit_data and frozen_commit_data[\"message\"] == \"Not Found\":\n                    msg = self.style.ERROR(\"{0} not found in {1}. Repo may be private.\".format(frozen_commit_sha[:10], name))\n                elif frozen_commit_data[\"sha\"] in [branch[\"commit\"][\"sha\"] for branch in branch_data]:\n                    msg = self.style.BOLD(\"up to date\")\n                else:\n                    msg = self.style.INFO(\"{0} is not the head of any branch\".format(frozen_commit_data[\"sha\"][:10]))\n\n            if \"dist\" in req:\n                pkg_info = \"{dist.project_name} {dist.version}\".format(dist=req[\"dist\"])\n            elif frozen_commit_sha is None:\n                pkg_info = name\n            else:\n                pkg_info = \"{0} {1}\".format(name, frozen_commit_sha[:10])\n            self.stdout.write(\"{pkg_info:40} {msg}\".format(pkg_info=pkg_info, msg=msg))\n            del self.reqs[name]", "code_tokens": "def check_github ( self ) : for name , req in list ( self . reqs . items ( ) ) : req_url = req [ \"url\" ] if not req_url : continue req_url = str ( req_url ) if req_url . startswith ( \"git\" ) and \"github.com/\" not in req_url : continue if req_url . endswith ( ( \".tar.gz\" , \".tar.bz2\" , \".zip\" ) ) : continue headers = { \"content-type\" : \"application/json\" , } if self . github_api_token : headers [ \"Authorization\" ] = \"token {0}\" . format ( self . github_api_token ) try : path_parts = urlparse ( req_url ) . path . split ( \"#\" , 1 ) [ 0 ] . strip ( \"/\" ) . rstrip ( \"/\" ) . split ( \"/\" ) if len ( path_parts ) == 2 : user , repo = path_parts elif 'archive' in path_parts : # Supports URL of format: # https://github.com/django/django/archive/master.tar.gz#egg=Django # https://github.com/django/django/archive/master.zip#egg=Django user , repo = path_parts [ : 2 ] repo += '@' + path_parts [ - 1 ] . replace ( '.tar.gz' , '' ) . replace ( '.zip' , '' ) else : self . style . ERROR ( \"\\nFailed to parse %r\\n\" % ( req_url , ) ) continue except ( ValueError , IndexError ) as e : self . stdout . write ( self . style . ERROR ( \"\\nFailed to parse %r: %s\\n\" % ( req_url , e ) ) ) continue try : test_auth = requests . get ( \"https://api.github.com/django/\" , headers = headers ) . json ( ) except HTTPError as e : self . stdout . write ( \"\\n%s\\n\" % str ( e ) ) return if \"message\" in test_auth and test_auth [ \"message\" ] == \"Bad credentials\" : self . stdout . write ( self . style . ERROR ( \"\\nGithub API: Bad credentials. Aborting!\\n\" ) ) return elif \"message\" in test_auth and test_auth [ \"message\" ] . startswith ( \"API Rate Limit Exceeded\" ) : self . stdout . write ( self . style . ERROR ( \"\\nGithub API: Rate Limit Exceeded. Aborting!\\n\" ) ) return frozen_commit_sha = None if \".git\" in repo : repo_name , frozen_commit_full = repo . split ( \".git\" ) if frozen_commit_full . startswith ( \"@\" ) : frozen_commit_sha = frozen_commit_full [ 1 : ] elif \"@\" in repo : repo_name , frozen_commit_sha = repo . split ( \"@\" ) if frozen_commit_sha is None : msg = self . style . ERROR ( \"repo is not frozen\" ) if frozen_commit_sha : branch_url = \"https://api.github.com/repos/{0}/{1}/branches\" . format ( user , repo_name ) branch_data = requests . get ( branch_url , headers = headers ) . json ( ) frozen_commit_url = \"https://api.github.com/repos/{0}/{1}/commits/{2}\" . format ( user , repo_name , frozen_commit_sha ) frozen_commit_data = requests . get ( frozen_commit_url , headers = headers ) . json ( ) if \"message\" in frozen_commit_data and frozen_commit_data [ \"message\" ] == \"Not Found\" : msg = self . style . ERROR ( \"{0} not found in {1}. Repo may be private.\" . format ( frozen_commit_sha [ : 10 ] , name ) ) elif frozen_commit_data [ \"sha\" ] in [ branch [ \"commit\" ] [ \"sha\" ] for branch in branch_data ] : msg = self . style . BOLD ( \"up to date\" ) else : msg = self . style . INFO ( \"{0} is not the head of any branch\" . format ( frozen_commit_data [ \"sha\" ] [ : 10 ] ) ) if \"dist\" in req : pkg_info = \"{dist.project_name} {dist.version}\" . format ( dist = req [ \"dist\" ] ) elif frozen_commit_sha is None : pkg_info = name else : pkg_info = \"{0} {1}\" . format ( name , frozen_commit_sha [ : 10 ] ) self . stdout . write ( \"{pkg_info:40} {msg}\" . format ( pkg_info = pkg_info , msg = msg ) ) del self . reqs [ name ]", "docstring_tokens": "If the requirement is frozen to a github url check for new commits .", "label": 1}, {"idx": "cosqa-train-11263", "doc": "how do you change a list to a string in python", "code": "def list_i2str(ilist):\n    \"\"\"\n    Convert an integer list into a string list.\n    \"\"\"\n    slist = []\n    for el in ilist:\n        slist.append(str(el))\n    return slist", "code_tokens": "def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist", "docstring_tokens": "Convert an integer list into a string list .", "label": 0}, {"idx": "cosqa-train-11264", "doc": "python iterator of a dictionary", "code": "def itervalues(d, **kw):\n    \"\"\"Return an iterator over the values of a dictionary.\"\"\"\n    if not PY2:\n        return iter(d.values(**kw))\n    return d.itervalues(**kw)", "code_tokens": "def itervalues ( d , * * kw ) : if not PY2 : return iter ( d . values ( * * kw ) ) return d . itervalues ( * * kw )", "docstring_tokens": "Return an iterator over the values of a dictionary .", "label": 1}, {"idx": "cosqa-train-11265", "doc": "how do you get only latitude and longitude using geocode in python geeks for geeks", "code": "def _query_for_reverse_geocoding(lat, lng):\n    \"\"\"\n    Given a lat & lng, what's the string search query.\n\n    If the API changes, change this function. Only for internal use.\n    \"\"\"\n    # have to do some stupid f/Decimal/str stuff to (a) ensure we get as much\n    # decimal places as the user already specified and (b) to ensure we don't\n    # get e-5 stuff\n    return \"{0:f},{1:f}\".format(Decimal(str(lat)), Decimal(str(lng)))", "code_tokens": "def _query_for_reverse_geocoding ( lat , lng ) : # have to do some stupid f/Decimal/str stuff to (a) ensure we get as much # decimal places as the user already specified and (b) to ensure we don't # get e-5 stuff return \"{0:f},{1:f}\" . format ( Decimal ( str ( lat ) ) , Decimal ( str ( lng ) ) )", "docstring_tokens": "Given a lat & lng what s the string search query .", "label": 1}, {"idx": "cosqa-train-11266", "doc": "python iterparse has children", "code": "def iterparse(source, events=('end',), remove_comments=True, **kw):\n    \"\"\"Thin wrapper around ElementTree.iterparse\"\"\"\n    return ElementTree.iterparse(source, events, SourceLineParser(), **kw)", "code_tokens": "def iterparse ( source , events = ( 'end' , ) , remove_comments = True , * * kw ) : return ElementTree . iterparse ( source , events , SourceLineParser ( ) , * * kw )", "docstring_tokens": "Thin wrapper around ElementTree . iterparse", "label": 0}, {"idx": "cosqa-train-11267", "doc": "how do you get the type of an object in python", "code": "def getTypeStr(_type):\n  r\"\"\"Gets the string representation of the given type.\n  \"\"\"\n  if isinstance(_type, CustomType):\n    return str(_type)\n\n  if hasattr(_type, '__name__'):\n    return _type.__name__\n\n  return ''", "code_tokens": "def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''", "docstring_tokens": "r Gets the string representation of the given type .", "label": 1}, {"idx": "cosqa-train-11268", "doc": "python jaccard similarity on chunks of a large list of lists", "code": "def jaccard(c_1, c_2):\n    \"\"\"\n    Calculates the Jaccard similarity between two sets of nodes. Called by mroc.\n\n    Inputs:  - c_1: Community (set of nodes) 1.\n             - c_2: Community (set of nodes) 2.\n\n    Outputs: - jaccard_similarity: The Jaccard similarity of these two communities.\n    \"\"\"\n    nom = np.intersect1d(c_1, c_2).size\n    denom = np.union1d(c_1, c_2).size\n    return nom/denom", "code_tokens": "def jaccard ( c_1 , c_2 ) : nom = np . intersect1d ( c_1 , c_2 ) . size denom = np . union1d ( c_1 , c_2 ) . size return nom / denom", "docstring_tokens": "Calculates the Jaccard similarity between two sets of nodes . Called by mroc .", "label": 1}, {"idx": "cosqa-train-11269", "doc": "how do you kill a program in python", "code": "def cli_command_quit(self, msg):\n        \"\"\"\\\n        kills the child and exits\n        \"\"\"\n        if self.state == State.RUNNING and self.sprocess and self.sprocess.proc:\n            self.sprocess.proc.kill()\n        else:\n            sys.exit(0)", "code_tokens": "def cli_command_quit ( self , msg ) : if self . state == State . RUNNING and self . sprocess and self . sprocess . proc : self . sprocess . proc . kill ( ) else : sys . exit ( 0 )", "docstring_tokens": "\\ kills the child and exits", "label": 1}, {"idx": "cosqa-train-11270", "doc": "python jinja2 parse file", "code": "def render(template, context):\n        \"\"\"Wrapper to the jinja2 render method from a template file\n\n        Parameters\n        ----------\n        template : str\n            Path to template file.\n        context : dict\n            Dictionary with kwargs context to populate the template\n        \"\"\"\n\n        path, filename = os.path.split(template)\n\n        return jinja2.Environment(\n            loader=jinja2.FileSystemLoader(path or './')\n        ).get_template(filename).render(context)", "code_tokens": "def render ( template , context ) : path , filename = os . path . split ( template ) return jinja2 . Environment ( loader = jinja2 . FileSystemLoader ( path or './' ) ) . get_template ( filename ) . render ( context )", "docstring_tokens": "Wrapper to the jinja2 render method from a template file", "label": 1}, {"idx": "cosqa-train-11271", "doc": "how do you load a an images in a file into python", "code": "def load_image(fname):\n    \"\"\" read an image from file - PIL doesnt close nicely \"\"\"\n    with open(fname, \"rb\") as f:\n        i = Image.open(fname)\n        #i.load()\n        return i", "code_tokens": "def load_image ( fname ) : with open ( fname , \"rb\" ) as f : i = Image . open ( fname ) #i.load() return i", "docstring_tokens": "read an image from file - PIL doesnt close nicely", "label": 1}, {"idx": "cosqa-train-11272", "doc": "python join array elem into line separated string", "code": "def format_line(data, linestyle):\n    \"\"\"Formats a list of elements using the given line style\"\"\"\n    return linestyle.begin + linestyle.sep.join(data) + linestyle.end", "code_tokens": "def format_line ( data , linestyle ) : return linestyle . begin + linestyle . sep . join ( data ) + linestyle . end", "docstring_tokens": "Formats a list of elements using the given line style", "label": 1}, {"idx": "cosqa-train-11273", "doc": "how do you set limits for the axes in python", "code": "def set_xlimits_widgets(self, set_min=True, set_max=True):\n        \"\"\"Populate axis limits GUI with current plot values.\"\"\"\n        xmin, xmax = self.tab_plot.ax.get_xlim()\n        if set_min:\n            self.w.x_lo.set_text('{0}'.format(xmin))\n        if set_max:\n            self.w.x_hi.set_text('{0}'.format(xmax))", "code_tokens": "def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )", "docstring_tokens": "Populate axis limits GUI with current plot values .", "label": 1}, {"idx": "cosqa-train-11274", "doc": "python join column entried", "code": "def get_join_cols(by_entry):\n  \"\"\" helper function used for joins\n  builds left and right join list for join function\n  \"\"\"\n  left_cols = []\n  right_cols = []\n  for col in by_entry:\n    if isinstance(col, str):\n      left_cols.append(col)\n      right_cols.append(col)\n    else:\n      left_cols.append(col[0])\n      right_cols.append(col[1])\n  return left_cols, right_cols", "code_tokens": "def get_join_cols ( by_entry ) : left_cols = [ ] right_cols = [ ] for col in by_entry : if isinstance ( col , str ) : left_cols . append ( col ) right_cols . append ( col ) else : left_cols . append ( col [ 0 ] ) right_cols . append ( col [ 1 ] ) return left_cols , right_cols", "docstring_tokens": "helper function used for joins builds left and right join list for join function", "label": 1}, {"idx": "cosqa-train-11275", "doc": "how do you sort an array in python and save indices of sort", "code": "def argsort_indices(a, axis=-1):\n    \"\"\"Like argsort, but returns an index suitable for sorting the\n    the original array even if that array is multidimensional\n    \"\"\"\n    a = np.asarray(a)\n    ind = list(np.ix_(*[np.arange(d) for d in a.shape]))\n    ind[axis] = a.argsort(axis)\n    return tuple(ind)", "code_tokens": "def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )", "docstring_tokens": "Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional", "label": 1}, {"idx": "cosqa-train-11276", "doc": "python join multiple images into single image", "code": "def join_images(img_files, out_file):\n    \"\"\"Join the list of images into the out file\"\"\"\n    images = [PIL.Image.open(f) for f in img_files]\n    joined = PIL.Image.new(\n        'RGB',\n        (sum(i.size[0] for i in images), max(i.size[1] for i in images))\n    )\n    left = 0\n    for img in images:\n        joined.paste(im=img, box=(left, 0))\n        left = left + img.size[0]\n    joined.save(out_file)", "code_tokens": "def join_images ( img_files , out_file ) : images = [ PIL . Image . open ( f ) for f in img_files ] joined = PIL . Image . new ( 'RGB' , ( sum ( i . size [ 0 ] for i in images ) , max ( i . size [ 1 ] for i in images ) ) ) left = 0 for img in images : joined . paste ( im = img , box = ( left , 0 ) ) left = left + img . size [ 0 ] joined . save ( out_file )", "docstring_tokens": "Join the list of images into the out file", "label": 1}, {"idx": "cosqa-train-11277", "doc": "how do you test for equality in python", "code": "def equal(obj1, obj2):\n    \"\"\"Calculate equality between two (Comparable) objects.\"\"\"\n    Comparable.log(obj1, obj2, '==')\n    equality = obj1.equality(obj2)\n    Comparable.log(obj1, obj2, '==', result=equality)\n    return equality", "code_tokens": "def equal ( obj1 , obj2 ) : Comparable . log ( obj1 , obj2 , '==' ) equality = obj1 . equality ( obj2 ) Comparable . log ( obj1 , obj2 , '==' , result = equality ) return equality", "docstring_tokens": "Calculate equality between two ( Comparable ) objects .", "label": 1}, {"idx": "cosqa-train-11278", "doc": "python join string only if nonempty", "code": "def _py2_and_3_joiner(sep, joinable):\n    \"\"\"\n    Allow '\\n'.join(...) statements to work in Py2 and Py3.\n    :param sep:\n    :param joinable:\n    :return:\n    \"\"\"\n    if ISPY3:\n        sep = bytes(sep, DEFAULT_ENCODING)\n    joined = sep.join(joinable)\n    return joined.decode(DEFAULT_ENCODING) if ISPY3 else joined", "code_tokens": "def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "docstring_tokens": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return :", "label": 0}, {"idx": "cosqa-train-11279", "doc": "how does python change type from int to float", "code": "def type_converter(text):\n    \"\"\" I convert strings into integers, floats, and strings! \"\"\"\n    if text.isdigit():\n        return int(text), int\n\n    try:\n        return float(text), float\n    except ValueError:\n        return text, STRING_TYPE", "code_tokens": "def type_converter ( text ) : if text . isdigit ( ) : return int ( text ) , int try : return float ( text ) , float except ValueError : return text , STRING_TYPE", "docstring_tokens": "I convert strings into integers floats and strings!", "label": 0}, {"idx": "cosqa-train-11280", "doc": "python join url fragments without /", "code": "def urljoin(*urls):\n    \"\"\"\n    The default urlparse.urljoin behavior look strange\n    Standard urlparse.urljoin('http://a.com/foo', '/bar')\n    Expect: http://a.com/foo/bar\n    Actually: http://a.com/bar\n\n    This function fix that.\n    \"\"\"\n    return reduce(urlparse.urljoin, [u.strip('/')+'/' for u in urls if u.strip('/')], '').rstrip('/')", "code_tokens": "def urljoin ( * urls ) : return reduce ( urlparse . urljoin , [ u . strip ( '/' ) + '/' for u in urls if u . strip ( '/' ) ] , '' ) . rstrip ( '/' )", "docstring_tokens": "The default urlparse . urljoin behavior look strange Standard urlparse . urljoin ( http : // a . com / foo / bar ) Expect : http : // a . com / foo / bar Actually : http : // a . com / bar This function fix that .", "label": 1}, {"idx": "cosqa-train-11281", "doc": "how does python compare complex number", "code": "def complex_check(*args, func=None):\n    \"\"\"Check if arguments are complex numbers.\"\"\"\n    func = func or inspect.stack()[2][3]\n    for var in args:\n        if not isinstance(var, numbers.Complex):\n            name = type(var).__name__\n            raise ComplexError(\n                f'Function {func} expected complex number, {name} got instead.')", "code_tokens": "def complex_check ( * args , func = None ) : func = func or inspect . stack ( ) [ 2 ] [ 3 ] for var in args : if not isinstance ( var , numbers . Complex ) : name = type ( var ) . __name__ raise ComplexError ( f'Function {func} expected complex number, {name} got instead.' )", "docstring_tokens": "Check if arguments are complex numbers .", "label": 1}, {"idx": "cosqa-train-11282", "doc": "python join with seperator", "code": "def _py2_and_3_joiner(sep, joinable):\n    \"\"\"\n    Allow '\\n'.join(...) statements to work in Py2 and Py3.\n    :param sep:\n    :param joinable:\n    :return:\n    \"\"\"\n    if ISPY3:\n        sep = bytes(sep, DEFAULT_ENCODING)\n    joined = sep.join(joinable)\n    return joined.decode(DEFAULT_ENCODING) if ISPY3 else joined", "code_tokens": "def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "docstring_tokens": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return :", "label": 1}, {"idx": "cosqa-train-11283", "doc": "how is alias used in python", "code": "def magic(self, alias):\n        \"\"\"Returns the appropriate IPython code magic when\n        called with an alias for a language.\n        \"\"\"\n        if alias in self.aliases:\n            return self.aliases[alias]\n        else:\n            return \"%%{}\\n\".format(alias)", "code_tokens": "def magic ( self , alias ) : if alias in self . aliases : return self . aliases [ alias ] else : return \"%%{}\\n\" . format ( alias )", "docstring_tokens": "Returns the appropriate IPython code magic when called with an alias for a language .", "label": 1}, {"idx": "cosqa-train-11284", "doc": "python json check if serializable", "code": "def is_serializable(obj):\n    \"\"\"Return `True` if the given object conforms to the Serializable protocol.\n\n    :rtype: bool\n    \"\"\"\n    if inspect.isclass(obj):\n      return Serializable.is_serializable_type(obj)\n    return isinstance(obj, Serializable) or hasattr(obj, '_asdict')", "code_tokens": "def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )", "docstring_tokens": "Return True if the given object conforms to the Serializable protocol .", "label": 1}, {"idx": "cosqa-train-11285", "doc": "how similar are two words in python", "code": "def basic_word_sim(word1, word2):\n    \"\"\"\n    Simple measure of similarity: Number of letters in common / max length\n    \"\"\"\n    return sum([1 for c in word1 if c in word2]) / max(len(word1), len(word2))", "code_tokens": "def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )", "docstring_tokens": "Simple measure of similarity : Number of letters in common / max length", "label": 1}, {"idx": "cosqa-train-11286", "doc": "python json dump command output", "code": "def pprint(j, no_pretty):\n    \"\"\"\n    Prints as formatted JSON\n    \"\"\"\n    if not no_pretty:\n        click.echo(\n            json.dumps(j, cls=PotionJSONEncoder, sort_keys=True, indent=4, separators=(\",\", \": \"))\n        )\n    else:\n        click.echo(j)", "code_tokens": "def pprint ( j , no_pretty ) : if not no_pretty : click . echo ( json . dumps ( j , cls = PotionJSONEncoder , sort_keys = True , indent = 4 , separators = ( \",\" , \": \" ) ) ) else : click . echo ( j )", "docstring_tokens": "Prints as formatted JSON", "label": 0}, {"idx": "cosqa-train-11287", "doc": "how to access an 2 d array in python", "code": "def torecarray(*args, **kwargs):\n    \"\"\"\n    Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.\n\n    \"\"\"\n\n    import numpy as np\n    return toarray(*args, **kwargs).view(np.recarray)", "code_tokens": "def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )", "docstring_tokens": "Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) .", "label": 1}, {"idx": "cosqa-train-11288", "doc": "python json dumps numpy key", "code": "def deserialize_ndarray_npy(d):\n    \"\"\"\n    Deserializes a JSONified :obj:`numpy.ndarray` that was created using numpy's\n    :obj:`save` function.\n\n    Args:\n        d (:obj:`dict`): A dictionary representation of an :obj:`ndarray` object, created\n            using :obj:`numpy.save`.\n\n    Returns:\n        An :obj:`ndarray` object.\n    \"\"\"\n    with io.BytesIO() as f:\n        f.write(json.loads(d['npy']).encode('latin-1'))\n        f.seek(0)\n        return np.load(f)", "code_tokens": "def deserialize_ndarray_npy ( d ) : with io . BytesIO ( ) as f : f . write ( json . loads ( d [ 'npy' ] ) . encode ( 'latin-1' ) ) f . seek ( 0 ) return np . load ( f )", "docstring_tokens": "Deserializes a JSONified : obj : numpy . ndarray that was created using numpy s : obj : save function .", "label": 1}, {"idx": "cosqa-train-11289", "doc": "python json dumps remove space", "code": "def dump_json(obj):\n    \"\"\"Dump Python object as JSON string.\"\"\"\n    return simplejson.dumps(obj, ignore_nan=True, default=json_util.default)", "code_tokens": "def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )", "docstring_tokens": "Dump Python object as JSON string .", "label": 1}, {"idx": "cosqa-train-11290", "doc": "how to access element of a list n python", "code": "def chunk_list(l, n):\n    \"\"\"Return `n` size lists from a given list `l`\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Return n size lists from a given list l", "label": 1}, {"idx": "cosqa-train-11291", "doc": "python json file parse comment", "code": "def parse_json(filename):\n    \"\"\" Parse a JSON file\n        First remove comments and then use the json module package\n        Comments look like :\n            // ...\n        or\n            /*\n            ...\n            */\n    \"\"\"\n    # Regular expression for comments\n    comment_re = re.compile(\n        '(^)?[^\\S\\n]*/(?:\\*(.*?)\\*/[^\\S\\n]*|/[^\\n]*)($)?',\n        re.DOTALL | re.MULTILINE\n    )\n\n    with open(filename) as f:\n        content = ''.join(f.readlines())\n\n        ## Looking for comments\n        match = comment_re.search(content)\n        while match:\n            # single line comment\n            content = content[:match.start()] + content[match.end():]\n            match = comment_re.search(content)\n\n        # Return json file\n        return json.loads(content)", "code_tokens": "def parse_json ( filename ) : # Regular expression for comments comment_re = re . compile ( '(^)?[^\\S\\n]*/(?:\\*(.*?)\\*/[^\\S\\n]*|/[^\\n]*)($)?' , re . DOTALL | re . MULTILINE ) with open ( filename ) as f : content = '' . join ( f . readlines ( ) ) ## Looking for comments match = comment_re . search ( content ) while match : # single line comment content = content [ : match . start ( ) ] + content [ match . end ( ) : ] match = comment_re . search ( content ) # Return json file return json . loads ( content )", "docstring_tokens": "Parse a JSON file First remove comments and then use the json module package Comments look like : // ... or / * ... * /", "label": 1}, {"idx": "cosqa-train-11292", "doc": "how to access the first number in an integer python", "code": "def find_first_number(ll):\n    \"\"\" Returns nr of first entry parseable to float in ll, None otherwise\"\"\"\n    for nr, entry in enumerate(ll):\n        try:\n            float(entry)\n        except (ValueError, TypeError) as e:\n            pass\n        else:\n            return nr\n    return None", "code_tokens": "def find_first_number ( ll ) : for nr , entry in enumerate ( ll ) : try : float ( entry ) except ( ValueError , TypeError ) as e : pass else : return nr return None", "docstring_tokens": "Returns nr of first entry parseable to float in ll None otherwise", "label": 1}, {"idx": "cosqa-train-11293", "doc": "python json print tree", "code": "def prettyprint(d):\n        \"\"\"Print dicttree in Json-like format. keys are sorted\n        \"\"\"\n        print(json.dumps(d, sort_keys=True, \n                         indent=4, separators=(\",\" , \": \")))", "code_tokens": "def prettyprint ( d ) : print ( json . dumps ( d , sort_keys = True , indent = 4 , separators = ( \",\" , \": \" ) ) )", "docstring_tokens": "Print dicttree in Json - like format . keys are sorted", "label": 1}, {"idx": "cosqa-train-11294", "doc": "how to accessfile path python", "code": "def get_file_string(filepath):\n    \"\"\"Get string from file.\"\"\"\n    with open(os.path.abspath(filepath)) as f:\n        return f.read()", "code_tokens": "def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )", "docstring_tokens": "Get string from file .", "label": 1}, {"idx": "cosqa-train-11295", "doc": "python json serialize deserialize list of object", "code": "def from_json_list(cls, api_client, data):\n        \"\"\"Convert a list of JSON values to a list of models\n        \"\"\"\n        return [cls.from_json(api_client, item) for item in data]", "code_tokens": "def from_json_list ( cls , api_client , data ) : return [ cls . from_json ( api_client , item ) for item in data ]", "docstring_tokens": "Convert a list of JSON values to a list of models", "label": 1}, {"idx": "cosqa-train-11296", "doc": "how to add a ? in python url", "code": "def append_query_parameter(url, parameters, ignore_if_exists=True):\n    \"\"\" quick and dirty appending of query parameters to a url \"\"\"\n    if ignore_if_exists:\n        for key in parameters.keys():\n            if key + \"=\" in url:\n                del parameters[key]\n    parameters_str = \"&\".join(k + \"=\" + v for k, v in parameters.items())\n    append_token = \"&\" if \"?\" in url else \"?\"\n    return url + append_token + parameters_str", "code_tokens": "def append_query_parameter ( url , parameters , ignore_if_exists = True ) : if ignore_if_exists : for key in parameters . keys ( ) : if key + \"=\" in url : del parameters [ key ] parameters_str = \"&\" . join ( k + \"=\" + v for k , v in parameters . items ( ) ) append_token = \"&\" if \"?\" in url else \"?\" return url + append_token + parameters_str", "docstring_tokens": "quick and dirty appending of query parameters to a url", "label": 1}, {"idx": "cosqa-train-11297", "doc": "python json to yaml converter", "code": "def yaml_to_param(obj, name):\n\t\"\"\"\n\tReturn the top-level element of a document sub-tree containing the\n\tYAML serialization of a Python object.\n\t\"\"\"\n\treturn from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))", "code_tokens": "def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "docstring_tokens": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object .", "label": 1}, {"idx": "cosqa-train-11298", "doc": "how to add a delimiter to a list in python", "code": "def linedelimited (inlist,delimiter):\n    \"\"\"\nReturns a string composed of elements in inlist, with each element\nseparated by 'delimiter.'  Used by function writedelimited.  Use '\\t'\nfor tab-delimiting.\n\nUsage:   linedelimited (inlist,delimiter)\n\"\"\"\n    outstr = ''\n    for item in inlist:\n        if type(item) != StringType:\n            item = str(item)\n        outstr = outstr + item + delimiter\n    outstr = outstr[0:-1]\n    return outstr", "code_tokens": "def linedelimited ( inlist , delimiter ) : outstr = '' for item in inlist : if type ( item ) != StringType : item = str ( item ) outstr = outstr + item + delimiter outstr = outstr [ 0 : - 1 ] return outstr", "docstring_tokens": "Returns a string composed of elements in inlist with each element separated by delimiter . Used by function writedelimited . Use \\ t for tab - delimiting .", "label": 1}, {"idx": "cosqa-train-11299", "doc": "python k random element from array", "code": "def downsample(array, k):\n    \"\"\"Choose k random elements of array.\"\"\"\n    length = array.shape[0]\n    indices = random.sample(xrange(length), k)\n    return array[indices]", "code_tokens": "def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]", "docstring_tokens": "Choose k random elements of array .", "label": 1}, {"idx": "cosqa-train-11300", "doc": "how to add a number to certain elements of an array numpy python", "code": "def _increment(arr, indices):\n    \"\"\"Increment some indices in a 1D vector of non-negative integers.\n    Repeated indices are taken into account.\"\"\"\n    arr = _as_array(arr)\n    indices = _as_array(indices)\n    bbins = np.bincount(indices)\n    arr[:len(bbins)] += bbins\n    return arr", "code_tokens": "def _increment ( arr , indices ) : arr = _as_array ( arr ) indices = _as_array ( indices ) bbins = np . bincount ( indices ) arr [ : len ( bbins ) ] += bbins return arr", "docstring_tokens": "Increment some indices in a 1D vector of non - negative integers . Repeated indices are taken into account .", "label": 1}, {"idx": "cosqa-train-11301", "doc": "python kdeplot the curve is not in the data", "code": "def plot_kde(data, ax, title=None, color='r', fill_bt=True):\n    \"\"\"\n    Plot a smoothed (by kernel density estimate) histogram.\n    :type data: numpy array\n    :param data: An array containing the data to be plotted\n\n    :type ax: matplotlib.Axes\n    :param ax: The Axes object to draw to\n\n    :type title: str\n    :param title: The plot title\n\n    :type color: str\n    :param color: The color of the histogram line and fill. Note that the fill\n                  will be plotted with an alpha of 0.35.\n\n    :type fill_bt: bool\n    :param fill_bt: Specify whether to fill the area beneath the histogram line\n    \"\"\"\n    if isinstance(data, list):\n        data = np.asarray(data)\n    e = kde.KDEUnivariate(data.astype(np.float))\n    e.fit()\n    ax.plot(e.support, e.density, color=color, alpha=0.9, linewidth=2.25)\n    if fill_bt:\n        ax.fill_between(e.support, e.density, alpha=.35, zorder=1,\n                        antialiased=True, color=color)\n    if title is not None:\n        t = ax.set_title(title)\n        t.set_y(1.05)", "code_tokens": "def plot_kde ( data , ax , title = None , color = 'r' , fill_bt = True ) : if isinstance ( data , list ) : data = np . asarray ( data ) e = kde . KDEUnivariate ( data . astype ( np . float ) ) e . fit ( ) ax . plot ( e . support , e . density , color = color , alpha = 0.9 , linewidth = 2.25 ) if fill_bt : ax . fill_between ( e . support , e . density , alpha = .35 , zorder = 1 , antialiased = True , color = color ) if title is not None : t = ax . set_title ( title ) t . set_y ( 1.05 )", "docstring_tokens": "Plot a smoothed ( by kernel density estimate ) histogram . : type data : numpy array : param data : An array containing the data to be plotted", "label": 1}, {"idx": "cosqa-train-11302", "doc": "how to add custom spacing in python", "code": "def indent(txt, spacing=4):\n    \"\"\"\n    Indent given text using custom spacing, default is set to 4.\n    \"\"\"\n    return prefix(str(txt), ''.join([' ' for _ in range(spacing)]))", "code_tokens": "def indent ( txt , spacing = 4 ) : return prefix ( str ( txt ) , '' . join ( [ ' ' for _ in range ( spacing ) ] ) )", "docstring_tokens": "Indent given text using custom spacing default is set to 4 .", "label": 1}, {"idx": "cosqa-train-11303", "doc": "python keep diagonal entries of an array, everything else becomes zero", "code": "def check_precomputed_distance_matrix(X):\n    \"\"\"Perform check_array(X) after removing infinite values (numpy.inf) from the given distance matrix.\n    \"\"\"\n    tmp = X.copy()\n    tmp[np.isinf(tmp)] = 1\n    check_array(tmp)", "code_tokens": "def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "docstring_tokens": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix .", "label": 0}, {"idx": "cosqa-train-11304", "doc": "how to add long description in python", "code": "def get_long_description():\n    \"\"\" Read the long description. \"\"\"\n    here = path.abspath(path.dirname(__file__))\n    with open(path.join(here, 'README.rst')) as readme:\n        return readme.read()\n    return None", "code_tokens": "def get_long_description ( ) : here = path . abspath ( path . dirname ( __file__ ) ) with open ( path . join ( here , 'README.rst' ) ) as readme : return readme . read ( ) return None", "docstring_tokens": "Read the long description .", "label": 1}, {"idx": "cosqa-train-11305", "doc": "python kill process by signal", "code": "def process_kill(pid, sig=None):\n    \"\"\"Send signal to process.\n    \"\"\"\n    sig = sig or signal.SIGTERM\n    os.kill(pid, sig)", "code_tokens": "def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )", "docstring_tokens": "Send signal to process .", "label": 1}, {"idx": "cosqa-train-11306", "doc": "how to add size on the python", "code": "def calculate_size(name, replace_existing_values):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += BOOLEAN_SIZE_IN_BYTES\n    return data_size", "code_tokens": "def calculate_size ( name , replace_existing_values ) : data_size = 0 data_size += calculate_size_str ( name ) data_size += BOOLEAN_SIZE_IN_BYTES return data_size", "docstring_tokens": "Calculates the request payload size", "label": 1}, {"idx": "cosqa-train-11307", "doc": "python lambda example to tuple", "code": "def lambda_tuple_converter(func):\n    \"\"\"\n    Converts a Python 2 function as\n      lambda (x,y): x + y\n    In the Python 3 format:\n      lambda x,y : x + y\n    \"\"\"\n    if func is not None and func.__code__.co_argcount == 1:\n        return lambda *args: func(args[0] if len(args) == 1 else args)\n    else:\n        return func", "code_tokens": "def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func", "docstring_tokens": "Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y", "label": 1}, {"idx": "cosqa-train-11308", "doc": "how to add values to display on top of each bar chart python", "code": "def _change_height(self, ax, new_value):\n        \"\"\"Make bars in horizontal bar chart thinner\"\"\"\n        for patch in ax.patches:\n            current_height = patch.get_height()\n            diff = current_height - new_value\n\n            # we change the bar height\n            patch.set_height(new_value)\n\n            # we recenter the bar\n            patch.set_y(patch.get_y() + diff * .5)", "code_tokens": "def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )", "docstring_tokens": "Make bars in horizontal bar chart thinner", "label": 1}, {"idx": "cosqa-train-11309", "doc": "python lambda takes a tuple", "code": "def lambda_tuple_converter(func):\n    \"\"\"\n    Converts a Python 2 function as\n      lambda (x,y): x + y\n    In the Python 3 format:\n      lambda x,y : x + y\n    \"\"\"\n    if func is not None and func.__code__.co_argcount == 1:\n        return lambda *args: func(args[0] if len(args) == 1 else args)\n    else:\n        return func", "code_tokens": "def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func", "docstring_tokens": "Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y", "label": 1}, {"idx": "cosqa-train-11310", "doc": "how to allivate permission in python", "code": "def has_edit_permission(self, request):\n        \"\"\" Can edit this object \"\"\"\n        return request.user.is_authenticated and request.user.is_active and request.user.is_staff", "code_tokens": "def has_edit_permission ( self , request ) : return request . user . is_authenticated and request . user . is_active and request . user . is_staff", "docstring_tokens": "Can edit this object", "label": 1}, {"idx": "cosqa-train-11311", "doc": "python last file line not read", "code": "def last(self):\n        \"\"\"Get the last object in file.\"\"\"\n        # End of file\n        self.__file.seek(0, 2)\n\n        # Get the last struct\n        data = self.get(self.length - 1)\n\n        return data", "code_tokens": "def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data", "docstring_tokens": "Get the last object in file .", "label": 1}, {"idx": "cosqa-train-11312", "doc": "how to append a line in a file in the middle of file in python", "code": "def prepend_line(filepath, line):\n    \"\"\"Rewrite a file adding a line to its beginning.\n    \"\"\"\n    with open(filepath) as f:\n        lines = f.readlines()\n\n    lines.insert(0, line)\n\n    with open(filepath, 'w') as f:\n        f.writelines(lines)", "code_tokens": "def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )", "docstring_tokens": "Rewrite a file adding a line to its beginning .", "label": 1}, {"idx": "cosqa-train-11313", "doc": "how to apply bin function to elements in a list or array in python", "code": "def lazy_reverse_binmap(f, xs):\n    \"\"\"\n    Same as lazy_binmap, except the parameters are flipped for the binary function\n    \"\"\"\n    return (f(y, x) for x, y in zip(xs, xs[1:]))", "code_tokens": "def lazy_reverse_binmap ( f , xs ) : return ( f ( y , x ) for x , y in zip ( xs , xs [ 1 : ] ) )", "docstring_tokens": "Same as lazy_binmap except the parameters are flipped for the binary function", "label": 1}, {"idx": "cosqa-train-11314", "doc": "python left right mid string", "code": "def _mid(string, start, end=None):\n    \"\"\"\n    Returns a substring delimited by start and end position.\n    \"\"\"\n    if end is None:\n        end = len(string)\n    return string[start:start + end]", "code_tokens": "def _mid ( string , start , end = None ) : if end is None : end = len ( string ) return string [ start : start + end ]", "docstring_tokens": "Returns a substring delimited by start and end position .", "label": 1}, {"idx": "cosqa-train-11315", "doc": "how to apply log transformation to a column in python", "code": "def log_normalize(data):\n    \"\"\"Perform log transform log(x + 1).\n    \n    Parameters\n    ----------\n    data : array_like\n    \n    \"\"\"\n    if sp.issparse(data):\n        data = data.copy()\n        data.data = np.log2(data.data + 1)\n        return data\n\n    return np.log2(data.astype(np.float64) + 1)", "code_tokens": "def log_normalize ( data ) : if sp . issparse ( data ) : data = data . copy ( ) data . data = np . log2 ( data . data + 1 ) return data return np . log2 ( data . astype ( np . float64 ) + 1 )", "docstring_tokens": "Perform log transform log ( x + 1 ) . Parameters ---------- data : array_like", "label": 1}, {"idx": "cosqa-train-11316", "doc": "python len function complexity", "code": "def size(self):\n        \"\"\"\n        Recursively find size of a tree. Slow.\n        \"\"\"\n\n        if self is NULL:\n            return 0\n        return 1 + self.left.size() + self.right.size()", "code_tokens": "def size ( self ) : if self is NULL : return 0 return 1 + self . left . size ( ) + self . right . size ( )", "docstring_tokens": "Recursively find size of a tree . Slow .", "label": 1}, {"idx": "cosqa-train-11317", "doc": "how to ask question in python then pick formula based on answer", "code": "def confirm(question, default=True):\n    \"\"\"Ask a yes/no question interactively.\n\n    :param question: The text of the question to ask.\n    :returns: True if the answer was \"yes\", False otherwise.\n    \"\"\"\n    valid = {\"\": default, \"yes\": True, \"y\": True, \"no\": False, \"n\": False}\n    while 1:\n        choice = input(question + (\" [Y/n] \" if default else \" [y/N] \")).lower()\n        if choice in valid:\n            return valid[choice]\n        print(\"Please respond with 'y' or 'n' \")", "code_tokens": "def confirm ( question , default = True ) : valid = { \"\" : default , \"yes\" : True , \"y\" : True , \"no\" : False , \"n\" : False } while 1 : choice = input ( question + ( \" [Y/n] \" if default else \" [y/N] \" ) ) . lower ( ) if choice in valid : return valid [ choice ] print ( \"Please respond with 'y' or 'n' \" )", "docstring_tokens": "Ask a yes / no question interactively .", "label": 1}, {"idx": "cosqa-train-11318", "doc": "python levenshtein distance algorithm", "code": "def levenshtein_distance_metric(a, b):\n    \"\"\" 1 - farthest apart (same number of words, all diff). 0 - same\"\"\"\n    return (levenshtein_distance(a, b) / (2.0 * max(len(a), len(b), 1)))", "code_tokens": "def levenshtein_distance_metric ( a , b ) : return ( levenshtein_distance ( a , b ) / ( 2.0 * max ( len ( a ) , len ( b ) , 1 ) ) )", "docstring_tokens": "1 - farthest apart ( same number of words all diff ) . 0 - same", "label": 1}, {"idx": "cosqa-train-11319", "doc": "how to bold only certain characters in python", "code": "def classnameify(s):\n  \"\"\"\n  Makes a classname\n  \"\"\"\n  return ''.join(w if w in ACRONYMS else w.title() for w in s.split('_'))", "code_tokens": "def classnameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '_' ) )", "docstring_tokens": "Makes a classname", "label": 0}, {"idx": "cosqa-train-11320", "doc": "python limit axis range", "code": "def ylim(self, low, high):\n        \"\"\"Set yaxis limits\n\n        Parameters\n        ----------\n        low : number\n        high : number\n        index : int, optional\n\n        Returns\n        -------\n        Chart\n\n        \"\"\"\n        self.chart['yAxis'][0]['min'] = low\n        self.chart['yAxis'][0]['max'] = high\n        return self", "code_tokens": "def ylim ( self , low , high ) : self . chart [ 'yAxis' ] [ 0 ] [ 'min' ] = low self . chart [ 'yAxis' ] [ 0 ] [ 'max' ] = high return self", "docstring_tokens": "Set yaxis limits", "label": 0}, {"idx": "cosqa-train-11321", "doc": "how to bold the text in print in python", "code": "def good(txt):\n    \"\"\"Print, emphasized 'good', the given 'txt' message\"\"\"\n\n    print(\"%s# %s%s%s\" % (PR_GOOD_CC, get_time_stamp(), txt, PR_NC))\n    sys.stdout.flush()", "code_tokens": "def good ( txt ) : print ( \"%s# %s%s%s\" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "docstring_tokens": "Print emphasized good the given txt message", "label": 1}, {"idx": "cosqa-train-11322", "doc": "python linked list implementation with head and tail", "code": "def get_tail(self):\n        \"\"\"Gets tail\n\n        :return: Tail of linked list\n        \"\"\"\n        node = self.head\n        last_node = self.head\n\n        while node is not None:\n            last_node = node\n            node = node.next_node\n\n        return last_node", "code_tokens": "def get_tail ( self ) : node = self . head last_node = self . head while node is not None : last_node = node node = node . next_node return last_node", "docstring_tokens": "Gets tail", "label": 1}, {"idx": "cosqa-train-11323", "doc": "how to byte align in python", "code": "def be_array_from_bytes(fmt, data):\n    \"\"\"\n    Reads an array from bytestring with big-endian data.\n    \"\"\"\n    arr = array.array(str(fmt), data)\n    return fix_byteorder(arr)", "code_tokens": "def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )", "docstring_tokens": "Reads an array from bytestring with big - endian data .", "label": 1}, {"idx": "cosqa-train-11324", "doc": "python list combine to string with delimiter", "code": "def list2string (inlist,delimit=' '):\n    \"\"\"\nConverts a 1D list to a single long string for file output, using\nthe string.join function.\n\nUsage:   list2string (inlist,delimit=' ')\nReturns: the string created from inlist\n\"\"\"\n    stringlist = [makestr(_) for _ in inlist]\n    return string.join(stringlist,delimit)", "code_tokens": "def list2string ( inlist , delimit = ' ' ) : stringlist = [ makestr ( _ ) for _ in inlist ] return string . join ( stringlist , delimit )", "docstring_tokens": "Converts a 1D list to a single long string for file output using the string . join function .", "label": 1}, {"idx": "cosqa-train-11325", "doc": "how to calculate covariance python", "code": "def empirical(X):\n    \"\"\"Compute empirical covariance as baseline estimator.\n    \"\"\"\n    print(\"Empirical\")\n    cov = np.dot(X.T, X) / n_samples\n    return cov, np.linalg.inv(cov)", "code_tokens": "def empirical ( X ) : print ( \"Empirical\" ) cov = np . dot ( X . T , X ) / n_samples return cov , np . linalg . inv ( cov )", "docstring_tokens": "Compute empirical covariance as baseline estimator .", "label": 1}, {"idx": "cosqa-train-11326", "doc": "python list dedup in order", "code": "def dedup(seq):\n    \"\"\"Remove duplicates from a list while keeping order.\"\"\"\n    seen = set()\n    for item in seq:\n        if item not in seen:\n            seen.add(item)\n            yield item", "code_tokens": "def dedup ( seq ) : seen = set ( ) for item in seq : if item not in seen : seen . add ( item ) yield item", "docstring_tokens": "Remove duplicates from a list while keeping order .", "label": 1}, {"idx": "cosqa-train-11327", "doc": "how to calculate standard deviation or missing percentage of a variable in python", "code": "def stddev(values, meanval=None):  #from AI: A Modern Appproach\n    \"\"\"The standard deviation of a set of values.\n    Pass in the mean if you already know it.\"\"\"\n    if meanval == None: meanval = mean(values)\n    return math.sqrt( sum([(x - meanval)**2 for x in values]) / (len(values)-1) )", "code_tokens": "def stddev ( values , meanval = None ) : #from AI: A Modern Appproach if meanval == None : meanval = mean ( values ) return math . sqrt ( sum ( [ ( x - meanval ) ** 2 for x in values ] ) / ( len ( values ) - 1 ) )", "docstring_tokens": "The standard deviation of a set of values . Pass in the mean if you already know it .", "label": 1}, {"idx": "cosqa-train-11328", "doc": "python list fill between values", "code": "def _fill_array_from_list(the_list, the_array):\n        \"\"\"Fill an `array` from a `list`\"\"\"\n        for i, val in enumerate(the_list):\n            the_array[i] = val\n        return the_array", "code_tokens": "def _fill_array_from_list ( the_list , the_array ) : for i , val in enumerate ( the_list ) : the_array [ i ] = val return the_array", "docstring_tokens": "Fill an array from a list", "label": 1}, {"idx": "cosqa-train-11329", "doc": "how to calculate the six months previous date python", "code": "def get_previous_month(self):\n        \"\"\"Returns date range for the previous full month.\"\"\"\n        end = utils.get_month_start() - relativedelta(days=1)\n        end = utils.to_datetime(end)\n        start = utils.get_month_start(end)\n        return start, end", "code_tokens": "def get_previous_month ( self ) : end = utils . get_month_start ( ) - relativedelta ( days = 1 ) end = utils . to_datetime ( end ) start = utils . get_month_start ( end ) return start , end", "docstring_tokens": "Returns date range for the previous full month .", "label": 0}, {"idx": "cosqa-train-11330", "doc": "python list logical indexing from a list of true", "code": "def equal(list1, list2):\n    \"\"\" takes flags returns indexes of True values \"\"\"\n    return [item1 == item2 for item1, item2 in broadcast_zip(list1, list2)]", "code_tokens": "def equal ( list1 , list2 ) : return [ item1 == item2 for item1 , item2 in broadcast_zip ( list1 , list2 ) ]", "docstring_tokens": "takes flags returns indexes of True values", "label": 0}, {"idx": "cosqa-train-11331", "doc": "how to call a range from a through z in python", "code": "def LinSpace(start, stop, num):\n    \"\"\"\n    Linspace op.\n    \"\"\"\n    return np.linspace(start, stop, num=num, dtype=np.float32),", "code_tokens": "def LinSpace ( start , stop , num ) : return np . linspace ( start , stop , num = num , dtype = np . float32 ) ,", "docstring_tokens": "Linspace op .", "label": 0}, {"idx": "cosqa-train-11332", "doc": "python list median calculations", "code": "def median(data):\n    \"\"\"Calculate the median of a list.\"\"\"\n    data.sort()\n    num_values = len(data)\n    half = num_values // 2\n    if num_values % 2:\n        return data[half]\n    return 0.5 * (data[half-1] + data[half])", "code_tokens": "def median ( data ) : data . sort ( ) num_values = len ( data ) half = num_values // 2 if num_values % 2 : return data [ half ] return 0.5 * ( data [ half - 1 ] + data [ half ] )", "docstring_tokens": "Calculate the median of a list .", "label": 1}, {"idx": "cosqa-train-11333", "doc": "how to call the header of columns in python", "code": "def printheader(h=None):\n    \"\"\"Print the header for the CSV table.\"\"\"\n    writer = csv.writer(sys.stdout)\n    writer.writerow(header_fields(h))", "code_tokens": "def printheader ( h = None ) : writer = csv . writer ( sys . stdout ) writer . writerow ( header_fields ( h ) )", "docstring_tokens": "Print the header for the CSV table .", "label": 1}, {"idx": "cosqa-train-11334", "doc": "python list numpy identical", "code": "def _unique_rows_numpy(a):\n    \"\"\"return unique rows\"\"\"\n    a = np.ascontiguousarray(a)\n    unique_a = np.unique(a.view([('', a.dtype)] * a.shape[1]))\n    return unique_a.view(a.dtype).reshape((unique_a.shape[0], a.shape[1]))", "code_tokens": "def _unique_rows_numpy ( a ) : a = np . ascontiguousarray ( a ) unique_a = np . unique ( a . view ( [ ( '' , a . dtype ) ] * a . shape [ 1 ] ) ) return unique_a . view ( a . dtype ) . reshape ( ( unique_a . shape [ 0 ] , a . shape [ 1 ] ) )", "docstring_tokens": "return unique rows", "label": 1}, {"idx": "cosqa-train-11335", "doc": "how to cast a float in python", "code": "def comma_converter(float_string):\n    \"\"\"Convert numbers to floats whether the decimal point is '.' or ','\"\"\"\n    trans_table = maketrans(b',', b'.')\n    return float(float_string.translate(trans_table))", "code_tokens": "def comma_converter ( float_string ) : trans_table = maketrans ( b',' , b'.' ) return float ( float_string . translate ( trans_table ) )", "docstring_tokens": "Convert numbers to floats whether the decimal point is . or", "label": 1}, {"idx": "cosqa-train-11336", "doc": "python lists into 2d array", "code": "def flatten_array(grid):\n    \"\"\"\n    Takes a multi-dimensional array and returns a 1 dimensional array with the\n    same contents.\n    \"\"\"\n    grid = [grid[i][j] for i in range(len(grid)) for j in range(len(grid[i]))]\n    while type(grid[0]) is list:\n        grid = flatten_array(grid)\n    return grid", "code_tokens": "def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid", "docstring_tokens": "Takes a multi - dimensional array and returns a 1 dimensional array with the same contents .", "label": 1}, {"idx": "cosqa-train-11337", "doc": "how to cast string to uint8 in python", "code": "def b2u(string):\n    \"\"\" bytes to unicode \"\"\"\n    if (isinstance(string, bytes) or\n        (PY2 and isinstance(string, str))):\n        return string.decode('utf-8')\n    return string", "code_tokens": "def b2u ( string ) : if ( isinstance ( string , bytes ) or ( PY2 and isinstance ( string , str ) ) ) : return string . decode ( 'utf-8' ) return string", "docstring_tokens": "bytes to unicode", "label": 1}, {"idx": "cosqa-train-11338", "doc": "python load array from numpy", "code": "def _openResources(self):\n        \"\"\" Uses numpy.load to open the underlying file\n        \"\"\"\n        arr = np.load(self._fileName, allow_pickle=ALLOW_PICKLE)\n        check_is_an_array(arr)\n        self._array = arr", "code_tokens": "def _openResources ( self ) : arr = np . load ( self . _fileName , allow_pickle = ALLOW_PICKLE ) check_is_an_array ( arr ) self . _array = arr", "docstring_tokens": "Uses numpy . load to open the underlying file", "label": 1}, {"idx": "cosqa-train-11339", "doc": "how to cehck if somethign is a constant python", "code": "def is_static(*p):\n    \"\"\" A static value (does not change at runtime)\n    which is known at compile time\n    \"\"\"\n    return all(is_CONST(x) or\n               is_number(x) or\n               is_const(x)\n               for x in p)", "code_tokens": "def is_static ( * p ) : return all ( is_CONST ( x ) or is_number ( x ) or is_const ( x ) for x in p )", "docstring_tokens": "A static value ( does not change at runtime ) which is known at compile time", "label": 1}, {"idx": "cosqa-train-11340", "doc": "python load comma seperated string into list", "code": "def comma_delimited_to_list(list_param):\n    \"\"\"Convert comma-delimited list / string into a list of strings\n\n    :param list_param: Comma-delimited string\n    :type list_param: str | unicode\n    :return: A list of strings\n    :rtype: list\n    \"\"\"\n    if isinstance(list_param, list):\n        return list_param\n    if isinstance(list_param, str):\n        return list_param.split(',')\n    else:\n        return []", "code_tokens": "def comma_delimited_to_list ( list_param ) : if isinstance ( list_param , list ) : return list_param if isinstance ( list_param , str ) : return list_param . split ( ',' ) else : return [ ]", "docstring_tokens": "Convert comma - delimited list / string into a list of strings", "label": 1}, {"idx": "cosqa-train-11341", "doc": "how to change a 2d list to a 1d list python", "code": "def flat(l):\n    \"\"\"\nReturns the flattened version of a '2D' list.  List-correlate to the a.flat()\nmethod of NumPy arrays.\n\nUsage:    flat(l)\n\"\"\"\n    newl = []\n    for i in range(len(l)):\n        for j in range(len(l[i])):\n            newl.append(l[i][j])\n    return newl", "code_tokens": "def flat ( l ) : newl = [ ] for i in range ( len ( l ) ) : for j in range ( len ( l [ i ] ) ) : newl . append ( l [ i ] [ j ] ) return newl", "docstring_tokens": "Returns the flattened version of a 2D list . List - correlate to the a . flat () method of NumPy arrays .", "label": 1}, {"idx": "cosqa-train-11342", "doc": "python load json byte encoding", "code": "def load_jsonf(fpath, encoding):\n    \"\"\"\n    :param unicode fpath:\n    :param unicode encoding:\n    :rtype: dict | list\n    \"\"\"\n    with codecs.open(fpath, encoding=encoding) as f:\n        return json.load(f)", "code_tokens": "def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )", "docstring_tokens": ": param unicode fpath : : param unicode encoding : : rtype : dict | list", "label": 1}, {"idx": "cosqa-train-11343", "doc": "how to change a python iterable", "code": "def _varargs_to_iterable_method(func):\n    \"\"\"decorator to convert a *args method to one taking a iterable\"\"\"\n    def wrapped(self, iterable, **kwargs):\n        return func(self, *iterable, **kwargs)\n    return wrapped", "code_tokens": "def _varargs_to_iterable_method ( func ) : def wrapped ( self , iterable , * * kwargs ) : return func ( self , * iterable , * * kwargs ) return wrapped", "docstring_tokens": "decorator to convert a * args method to one taking a iterable", "label": 1}, {"idx": "cosqa-train-11344", "doc": "python load json from url", "code": "def get_jsonparsed_data(url):\n    \"\"\"Receive the content of ``url``, parse it as JSON and return the\n       object.\n    \"\"\"\n    response = urlopen(url)\n    data = response.read().decode('utf-8')\n    return json.loads(data)", "code_tokens": "def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )", "docstring_tokens": "Receive the content of url parse it as JSON and return the object .", "label": 1}, {"idx": "cosqa-train-11345", "doc": "how to change a true to one in python", "code": "def _check_and_convert_bools(self):\n        \"\"\"Replace boolean variables by the characters 'F'/'T'\n        \"\"\"\n        replacements = {\n            True: 'T',\n            False: 'F',\n        }\n\n        for key in self.bools:\n            if isinstance(self[key], bool):\n                self[key] = replacements[self[key]]", "code_tokens": "def _check_and_convert_bools ( self ) : replacements = { True : 'T' , False : 'F' , } for key in self . bools : if isinstance ( self [ key ] , bool ) : self [ key ] = replacements [ self [ key ] ]", "docstring_tokens": "Replace boolean variables by the characters F / T", "label": 1}, {"idx": "cosqa-train-11346", "doc": "python locate the maximum of an array", "code": "def findMax(arr):\n    \"\"\"\n    in comparison to argrelmax() more simple and  reliable peak finder\n    \"\"\"\n    out = np.zeros(shape=arr.shape, dtype=bool)\n    _calcMax(arr, out)\n    return out", "code_tokens": "def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out", "docstring_tokens": "in comparison to argrelmax () more simple and reliable peak finder", "label": 1}, {"idx": "cosqa-train-11347", "doc": "how to change postition of turtle in python", "code": "def forward(self, step):\n        \"\"\"Move the turtle forward.\n\n        :param step: Integer. Distance to move forward.\n        \"\"\"\n        x = self.pos_x + math.cos(math.radians(self.rotation)) * step\n        y = self.pos_y + math.sin(math.radians(self.rotation)) * step\n        prev_brush_state = self.brush_on\n        self.brush_on = True\n        self.move(x, y)\n        self.brush_on = prev_brush_state", "code_tokens": "def forward ( self , step ) : x = self . pos_x + math . cos ( math . radians ( self . rotation ) ) * step y = self . pos_y + math . sin ( math . radians ( self . rotation ) ) * step prev_brush_state = self . brush_on self . brush_on = True self . move ( x , y ) self . brush_on = prev_brush_state", "docstring_tokens": "Move the turtle forward .", "label": 1}, {"idx": "cosqa-train-11348", "doc": "python lock no blocking", "code": "def lock(self, block=True):\n\t\t\"\"\"\n\t\tLock connection from being used else where\n\t\t\"\"\"\n\t\tself._locked = True\n\t\treturn self._lock.acquire(block)", "code_tokens": "def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )", "docstring_tokens": "Lock connection from being used else where", "label": 1}, {"idx": "cosqa-train-11349", "doc": "how to change python input to upper case", "code": "def clean(some_string, uppercase=False):\n    \"\"\"\n    helper to clean up an input string\n    \"\"\"\n    if uppercase:\n        return some_string.strip().upper()\n    else:\n        return some_string.strip().lower()", "code_tokens": "def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )", "docstring_tokens": "helper to clean up an input string", "label": 1}, {"idx": "cosqa-train-11350", "doc": "python lock non block", "code": "def lock(self, block=True):\n\t\t\"\"\"\n\t\tLock connection from being used else where\n\t\t\"\"\"\n\t\tself._locked = True\n\t\treturn self._lock.acquire(block)", "code_tokens": "def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )", "docstring_tokens": "Lock connection from being used else where", "label": 1}, {"idx": "cosqa-train-11351", "doc": "how to change python type to string", "code": "def to_str(obj):\n    \"\"\"Attempts to convert given object to a string object\n    \"\"\"\n    if not isinstance(obj, str) and PY3 and isinstance(obj, bytes):\n        obj = obj.decode('utf-8')\n    return obj if isinstance(obj, string_types) else str(obj)", "code_tokens": "def to_str ( obj ) : if not isinstance ( obj , str ) and PY3 and isinstance ( obj , bytes ) : obj = obj . decode ( 'utf-8' ) return obj if isinstance ( obj , string_types ) else str ( obj )", "docstring_tokens": "Attempts to convert given object to a string object", "label": 1}, {"idx": "cosqa-train-11352", "doc": "python lockfile run once", "code": "def __enter__(self):\n        \"\"\"Acquire a lock on the output file, prevents collisions between multiple runs.\"\"\"\n        self.fd = open(self.filename, 'a')\n        fcntl.lockf(self.fd, fcntl.LOCK_EX)\n        return self.fd", "code_tokens": "def __enter__ ( self ) : self . fd = open ( self . filename , 'a' ) fcntl . lockf ( self . fd , fcntl . LOCK_EX ) return self . fd", "docstring_tokens": "Acquire a lock on the output file prevents collisions between multiple runs .", "label": 0}, {"idx": "cosqa-train-11353", "doc": "how to change small case in python'", "code": "def to_snake_case(s):\n    \"\"\"Converts camel-case identifiers to snake-case.\"\"\"\n    return re.sub('([^_A-Z])([A-Z])', lambda m: m.group(1) + '_' + m.group(2).lower(), s)", "code_tokens": "def to_snake_case ( s ) : return re . sub ( '([^_A-Z])([A-Z])' , lambda m : m . group ( 1 ) + '_' + m . group ( 2 ) . lower ( ) , s )", "docstring_tokens": "Converts camel - case identifiers to snake - case .", "label": 1}, {"idx": "cosqa-train-11354", "doc": "python log scale wont show all points", "code": "def interpolate_logscale_single(start, end, coefficient):\n    \"\"\" Cosine interpolation \"\"\"\n    return np.exp(np.log(start) + (np.log(end) - np.log(start)) * coefficient)", "code_tokens": "def interpolate_logscale_single ( start , end , coefficient ) : return np . exp ( np . log ( start ) + ( np . log ( end ) - np . log ( start ) ) * coefficient )", "docstring_tokens": "Cosine interpolation", "label": 0}, {"idx": "cosqa-train-11355", "doc": "how to change starting position of turtle in python", "code": "def forward(self, step):\n        \"\"\"Move the turtle forward.\n\n        :param step: Integer. Distance to move forward.\n        \"\"\"\n        x = self.pos_x + math.cos(math.radians(self.rotation)) * step\n        y = self.pos_y + math.sin(math.radians(self.rotation)) * step\n        prev_brush_state = self.brush_on\n        self.brush_on = True\n        self.move(x, y)\n        self.brush_on = prev_brush_state", "code_tokens": "def forward ( self , step ) : x = self . pos_x + math . cos ( math . radians ( self . rotation ) ) * step y = self . pos_y + math . sin ( math . radians ( self . rotation ) ) * step prev_brush_state = self . brush_on self . brush_on = True self . move ( x , y ) self . brush_on = prev_brush_state", "docstring_tokens": "Move the turtle forward .", "label": 1}, {"idx": "cosqa-train-11356", "doc": "python logarithmic regression prediction", "code": "def log_loss(preds, labels):\n    \"\"\"Logarithmic loss with non-necessarily-binary labels.\"\"\"\n    log_likelihood = np.sum(labels * np.log(preds)) / len(preds)\n    return -log_likelihood", "code_tokens": "def log_loss ( preds , labels ) : log_likelihood = np . sum ( labels * np . log ( preds ) ) / len ( preds ) return - log_likelihood", "docstring_tokens": "Logarithmic loss with non - necessarily - binary labels .", "label": 1}, {"idx": "cosqa-train-11357", "doc": "how to change the scale in python plot", "code": "def update_scale(self, value):\n        \"\"\" updates the scale of all actors in the plotter \"\"\"\n        self.plotter.set_scale(self.x_slider_group.value,\n                               self.y_slider_group.value,\n                               self.z_slider_group.value)", "code_tokens": "def update_scale ( self , value ) : self . plotter . set_scale ( self . x_slider_group . value , self . y_slider_group . value , self . z_slider_group . value )", "docstring_tokens": "updates the scale of all actors in the plotter", "label": 1}, {"idx": "cosqa-train-11358", "doc": "python logger do i have to close prior to my python script exiting", "code": "def log_stop(logger):\n    \"\"\"log stop\"\"\"\n\n    handlers = logger.handlers[:]\n    for handler in handlers:\n        handler.close()\n        logger.removeHandler(handler)", "code_tokens": "def log_stop ( logger ) : handlers = logger . handlers [ : ] for handler in handlers : handler . close ( ) logger . removeHandler ( handler )", "docstring_tokens": "log stop", "label": 1}, {"idx": "cosqa-train-11359", "doc": "how to change type timestamp value python to date", "code": "def dt_to_ts(value):\n    \"\"\" If value is a datetime, convert to timestamp \"\"\"\n    if not isinstance(value, datetime):\n        return value\n    return calendar.timegm(value.utctimetuple()) + value.microsecond / 1000000.0", "code_tokens": "def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0", "docstring_tokens": "If value is a datetime convert to timestamp", "label": 1}, {"idx": "cosqa-train-11360", "doc": "python logger no color", "code": "def debug(self, text):\n\t\t\"\"\" Ajout d'un message de log de type DEBUG \"\"\"\n\t\tself.logger.debug(\"{}{}\".format(self.message_prefix, text))", "code_tokens": "def debug ( self , text ) : self . logger . debug ( \"{}{}\" . format ( self . message_prefix , text ) )", "docstring_tokens": "Ajout d un message de log de type DEBUG", "label": 1}, {"idx": "cosqa-train-11361", "doc": "how to check an input is a sequence or not in python", "code": "def _is_proper_sequence(seq):\n    \"\"\"Returns is seq is sequence and not string.\"\"\"\n    return (isinstance(seq, collections.abc.Sequence) and\n            not isinstance(seq, str))", "code_tokens": "def _is_proper_sequence ( seq ) : return ( isinstance ( seq , collections . abc . Sequence ) and not isinstance ( seq , str ) )", "docstring_tokens": "Returns is seq is sequence and not string .", "label": 1}, {"idx": "cosqa-train-11362", "doc": "python logging list of all formatter pre defined values", "code": "def parse(self):\n        \"\"\"\n        Parses format string looking for substitutions\n\n        This method is responsible for returning a list of fields (as strings)\n        to include in all log messages.\n        \"\"\"\n        standard_formatters = re.compile(r'\\((.+?)\\)', re.IGNORECASE)\n        return standard_formatters.findall(self._fmt)", "code_tokens": "def parse ( self ) : standard_formatters = re . compile ( r'\\((.+?)\\)' , re . IGNORECASE ) return standard_formatters . findall ( self . _fmt )", "docstring_tokens": "Parses format string looking for substitutions", "label": 1}, {"idx": "cosqa-train-11363", "doc": "how to check array strings python", "code": "def all_strings(arr):\n        \"\"\"\n        Ensures that the argument is a list that either is empty or contains only strings\n        :param arr: list\n        :return:\n        \"\"\"\n        if not isinstance([], list):\n            raise TypeError(\"non-list value found where list is expected\")\n        return all(isinstance(x, str) for x in arr)", "code_tokens": "def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( \"non-list value found where list is expected\" ) return all ( isinstance ( x , str ) for x in arr )", "docstring_tokens": "Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return :", "label": 1}, {"idx": "cosqa-train-11364", "doc": "python logging rotating file handler by date", "code": "def timed_rotating_file_handler(name, logname, filename, when='h',\n                                interval=1, backupCount=0,\n                                encoding=None, delay=False, utc=False):\n    \"\"\"\n    A Bark logging handler logging output to a named file.  At\n    intervals specified by the 'when', the file will be rotated, under\n    control of 'backupCount'.\n\n    Similar to logging.handlers.TimedRotatingFileHandler.\n    \"\"\"\n\n    return wrap_log_handler(logging.handlers.TimedRotatingFileHandler(\n        filename, when=when, interval=interval, backupCount=backupCount,\n        encoding=encoding, delay=delay, utc=utc))", "code_tokens": "def timed_rotating_file_handler ( name , logname , filename , when = 'h' , interval = 1 , backupCount = 0 , encoding = None , delay = False , utc = False ) : return wrap_log_handler ( logging . handlers . TimedRotatingFileHandler ( filename , when = when , interval = interval , backupCount = backupCount , encoding = encoding , delay = delay , utc = utc ) )", "docstring_tokens": "A Bark logging handler logging output to a named file . At intervals specified by the when the file will be rotated under control of backupCount .", "label": 1}, {"idx": "cosqa-train-11365", "doc": "how to check for equal in python", "code": "def hard_equals(a, b):\n    \"\"\"Implements the '===' operator.\"\"\"\n    if type(a) != type(b):\n        return False\n    return a == b", "code_tokens": "def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b", "docstring_tokens": "Implements the === operator .", "label": 1}, {"idx": "cosqa-train-11366", "doc": "python logging with queue", "code": "def add_queue_handler(queue):\n    \"\"\"Add a queue log handler to the global logger.\"\"\"\n    handler = QueueLogHandler(queue)\n    handler.setFormatter(QueueFormatter())\n    handler.setLevel(DEBUG)\n    GLOBAL_LOGGER.addHandler(handler)", "code_tokens": "def add_queue_handler ( queue ) : handler = QueueLogHandler ( queue ) handler . setFormatter ( QueueFormatter ( ) ) handler . setLevel ( DEBUG ) GLOBAL_LOGGER . addHandler ( handler )", "docstring_tokens": "Add a queue log handler to the global logger .", "label": 1}, {"idx": "cosqa-train-11367", "doc": "how to check for lower case values in python", "code": "def contains_case_insensitive(adict, akey):\n    \"\"\"Check if key is in adict. The search is case insensitive.\"\"\"\n    for key in adict:\n        if key.lower() == akey.lower():\n            return True\n    return False", "code_tokens": "def contains_case_insensitive ( adict , akey ) : for key in adict : if key . lower ( ) == akey . lower ( ) : return True return False", "docstring_tokens": "Check if key is in adict . The search is case insensitive .", "label": 0}, {"idx": "cosqa-train-11368", "doc": "python logrithm to matrix", "code": "def to_distribution_values(self, values):\n        \"\"\"\n        Returns numpy array of natural logarithms of ``values``.\n        \"\"\"\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            # avoid RuntimeWarning: divide by zero encountered in log\n            return numpy.log(values)", "code_tokens": "def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( \"ignore\" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )", "docstring_tokens": "Returns numpy array of natural logarithms of values .", "label": 1}, {"idx": "cosqa-train-11369", "doc": "how to check if 2 dicts are equal in python", "code": "def is_same_dict(d1, d2):\n    \"\"\"Test two dictionary is equal on values. (ignore order)\n    \"\"\"\n    for k, v in d1.items():\n        if isinstance(v, dict):\n            is_same_dict(v, d2[k])\n        else:\n            assert d1[k] == d2[k]\n\n    for k, v in d2.items():\n        if isinstance(v, dict):\n            is_same_dict(v, d1[k])\n        else:\n            assert d1[k] == d2[k]", "code_tokens": "def is_same_dict ( d1 , d2 ) : for k , v in d1 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d2 [ k ] ) else : assert d1 [ k ] == d2 [ k ] for k , v in d2 . items ( ) : if isinstance ( v , dict ) : is_same_dict ( v , d1 [ k ] ) else : assert d1 [ k ] == d2 [ k ]", "docstring_tokens": "Test two dictionary is equal on values . ( ignore order )", "label": 1}, {"idx": "cosqa-train-11370", "doc": "python magickmock to mock method variable value", "code": "def mock_add_spec(self, spec, spec_set=False):\n        \"\"\"Add a spec to a mock. `spec` can either be an object or a\n        list of strings. Only attributes on the `spec` can be fetched as\n        attributes from the mock.\n\n        If `spec_set` is True then only attributes on the spec can be set.\"\"\"\n        self._mock_add_spec(spec, spec_set)\n        self._mock_set_magics()", "code_tokens": "def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )", "docstring_tokens": "Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock .", "label": 1}, {"idx": "cosqa-train-11371", "doc": "how to check if a connection is refused in python", "code": "def _is_retryable_exception(e):\n    \"\"\"Returns True if the exception is always safe to retry.\n\n    This is True if the client was never able to establish a connection\n    to the server (for example, name resolution failed or the connection\n    could otherwise not be initialized).\n\n    Conservatively, if we can't tell whether a network connection could\n    have been established, we return False.\n\n    \"\"\"\n    if isinstance(e, urllib3.exceptions.ProtocolError):\n        e = e.args[1]\n    if isinstance(e, (socket.gaierror, socket.herror)):\n        return True\n    if isinstance(e, socket.error) and e.errno in _RETRYABLE_SOCKET_ERRORS:\n        return True\n    if isinstance(e, urllib3.exceptions.NewConnectionError):\n        return True\n    return False", "code_tokens": "def _is_retryable_exception ( e ) : if isinstance ( e , urllib3 . exceptions . ProtocolError ) : e = e . args [ 1 ] if isinstance ( e , ( socket . gaierror , socket . herror ) ) : return True if isinstance ( e , socket . error ) and e . errno in _RETRYABLE_SOCKET_ERRORS : return True if isinstance ( e , urllib3 . exceptions . NewConnectionError ) : return True return False", "docstring_tokens": "Returns True if the exception is always safe to retry .", "label": 1}, {"idx": "cosqa-train-11372", "doc": "python make all letters underscores", "code": "def camel_case_from_underscores(string):\n    \"\"\"generate a CamelCase string from an underscore_string.\"\"\"\n    components = string.split('_')\n    string = ''\n    for component in components:\n        string += component[0].upper() + component[1:]\n    return string", "code_tokens": "def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "docstring_tokens": "generate a CamelCase string from an underscore_string .", "label": 0}, {"idx": "cosqa-train-11373", "doc": "how to check if a path is writeable python", "code": "def _writable_dir(path):\n    \"\"\"Whether `path` is a directory, to which the user has write access.\"\"\"\n    return os.path.isdir(path) and os.access(path, os.W_OK)", "code_tokens": "def _writable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . W_OK )", "docstring_tokens": "Whether path is a directory to which the user has write access .", "label": 1}, {"idx": "cosqa-train-11374", "doc": "python make an array of datetime", "code": "def get_dt_list(fn_list):\n    \"\"\"Get list of datetime objects, extracted from a filename\n    \"\"\"\n    dt_list = np.array([fn_getdatetime(fn) for fn in fn_list])\n    return dt_list", "code_tokens": "def get_dt_list ( fn_list ) : dt_list = np . array ( [ fn_getdatetime ( fn ) for fn in fn_list ] ) return dt_list", "docstring_tokens": "Get list of datetime objects extracted from a filename", "label": 1}, {"idx": "cosqa-train-11375", "doc": "how to check if a url is valid python", "code": "def url_syntax_check(url):  # pragma: no cover\n    \"\"\"\n    Check the syntax of the given URL.\n\n    :param url: The URL to check the syntax for.\n    :type url: str\n\n    :return: The syntax validity.\n    :rtype: bool\n\n    .. warning::\n        If an empty or a non-string :code:`url` is given, we return :code:`None`.\n    \"\"\"\n\n    if url and isinstance(url, str):\n        # The given URL is not empty nor None.\n        # and\n        # * The given URL is a string.\n\n        # We silently load the configuration.\n        load_config(True)\n\n        return Check(url).is_url_valid()\n\n    # We return None, there is nothing to check.\n    return None", "code_tokens": "def url_syntax_check ( url ) : # pragma: no cover if url and isinstance ( url , str ) : # The given URL is not empty nor None. # and # * The given URL is a string. # We silently load the configuration. load_config ( True ) return Check ( url ) . is_url_valid ( ) # We return None, there is nothing to check. return None", "docstring_tokens": "Check the syntax of the given URL .", "label": 1}, {"idx": "cosqa-train-11376", "doc": "python make new list excluding values from other list", "code": "def unique(transactions):\n    \"\"\" Remove any duplicate entries. \"\"\"\n    seen = set()\n    # TODO: Handle comments\n    return [x for x in transactions if not (x in seen or seen.add(x))]", "code_tokens": "def unique ( transactions ) : seen = set ( ) # TODO: Handle comments return [ x for x in transactions if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Remove any duplicate entries .", "label": 1}, {"idx": "cosqa-train-11377", "doc": "how to check if an element in list is string in python", "code": "def all_strings(arr):\n        \"\"\"\n        Ensures that the argument is a list that either is empty or contains only strings\n        :param arr: list\n        :return:\n        \"\"\"\n        if not isinstance([], list):\n            raise TypeError(\"non-list value found where list is expected\")\n        return all(isinstance(x, str) for x in arr)", "code_tokens": "def all_strings ( arr ) : if not isinstance ( [ ] , list ) : raise TypeError ( \"non-list value found where list is expected\" ) return all ( isinstance ( x , str ) for x in arr )", "docstring_tokens": "Ensures that the argument is a list that either is empty or contains only strings : param arr : list : return :", "label": 1}, {"idx": "cosqa-train-11378", "doc": "python make print print in one line", "code": "def stdoutwriteline(*args):\n    \"\"\"\n    @type args: tuple\n    @return: None\n    \"\"\"\n    s = \"\"\n\n    for i in args:\n        s += str(i) + \" \"\n\n    s = s.strip()\n    sys.stdout.write(str(s) + \"\\n\")\n    sys.stdout.flush()\n\n    return s", "code_tokens": "def stdoutwriteline ( * args ) : s = \"\" for i in args : s += str ( i ) + \" \" s = s . strip ( ) sys . stdout . write ( str ( s ) + \"\\n\" ) sys . stdout . flush ( ) return s", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-11379", "doc": "how to check if element is in line python", "code": "def isin(elems, line):\n    \"\"\"Check if an element from a list is in a string.\n\n    :type elems: list\n    :type line: str\n\n    \"\"\"\n    found = False\n    for e in elems:\n        if e in line.lower():\n            found = True\n            break\n    return found", "code_tokens": "def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found", "docstring_tokens": "Check if an element from a list is in a string .", "label": 1}, {"idx": "cosqa-train-11380", "doc": "python make valiablke in moduile editable", "code": "def enableEditing(self, enabled):\n        \"\"\"Enable the editing buttons to add/remove rows/columns and to edit the data.\n\n        This method is also a slot.\n        In addition, the data of model will be made editable,\n        if the `enabled` parameter is true.\n\n        Args:\n            enabled (bool): This flag indicates, if the buttons\n                shall be activated.\n\n        \"\"\"\n        for button in self.buttons[1:]:\n            button.setEnabled(enabled)\n            if button.isChecked():\n                button.setChecked(False)\n\n        model = self.tableView.model()\n\n        if model is not None:\n            model.enableEditing(enabled)", "code_tokens": "def enableEditing ( self , enabled ) : for button in self . buttons [ 1 : ] : button . setEnabled ( enabled ) if button . isChecked ( ) : button . setChecked ( False ) model = self . tableView . model ( ) if model is not None : model . enableEditing ( enabled )", "docstring_tokens": "Enable the editing buttons to add / remove rows / columns and to edit the data .", "label": 1}, {"idx": "cosqa-train-11381", "doc": "how to check if not condition python", "code": "def _not(condition=None, **kwargs):\n    \"\"\"\n    Return the opposite of input condition.\n\n    :param condition: condition to process.\n\n    :result: not condition.\n    :rtype: bool\n    \"\"\"\n\n    result = True\n\n    if condition is not None:\n        result = not run(condition, **kwargs)\n\n    return result", "code_tokens": "def _not ( condition = None , * * kwargs ) : result = True if condition is not None : result = not run ( condition , * * kwargs ) return result", "docstring_tokens": "Return the opposite of input condition .", "label": 1}, {"idx": "cosqa-train-11382", "doc": "python manage windows domain name", "code": "def _config_win32_domain(self, domain):\n        \"\"\"Configure a Domain registry entry.\"\"\"\n        # we call str() on domain to convert it from unicode to ascii\n        self.domain = dns.name.from_text(str(domain))", "code_tokens": "def _config_win32_domain ( self , domain ) : # we call str() on domain to convert it from unicode to ascii self . domain = dns . name . from_text ( str ( domain ) )", "docstring_tokens": "Configure a Domain registry entry .", "label": 0}, {"idx": "cosqa-train-11383", "doc": "how to check if number is power of 2 python", "code": "def is_power_of_2(num):\n    \"\"\"Return whether `num` is a power of two\"\"\"\n    log = math.log2(num)\n    return int(log) == float(log)", "code_tokens": "def is_power_of_2 ( num ) : log = math . log2 ( num ) return int ( log ) == float ( log )", "docstring_tokens": "Return whether num is a power of two", "label": 1}, {"idx": "cosqa-train-11384", "doc": "python map react to click", "code": "def OnDoubleClick(self, event):\n        \"\"\"Double click on a given square in the map\"\"\"\n        node = HotMapNavigator.findNodeAtPosition(self.hot_map, event.GetPosition())\n        if node:\n            wx.PostEvent( self, SquareActivationEvent( node=node, point=event.GetPosition(), map=self ) )", "code_tokens": "def OnDoubleClick ( self , event ) : node = HotMapNavigator . findNodeAtPosition ( self . hot_map , event . GetPosition ( ) ) if node : wx . PostEvent ( self , SquareActivationEvent ( node = node , point = event . GetPosition ( ) , map = self ) )", "docstring_tokens": "Double click on a given square in the map", "label": 1}, {"idx": "cosqa-train-11385", "doc": "how to check if series is empty in python", "code": "def contains_empty(features):\n    \"\"\"Check features data are not empty\n\n    :param features: The features data to check.\n    :type features: list of numpy arrays.\n\n    :return: True if one of the array is empty, False else.\n\n    \"\"\"\n    if not features:\n        return True\n    for feature in features:\n        if feature.shape[0] == 0:\n            return True\n    return False", "code_tokens": "def contains_empty ( features ) : if not features : return True for feature in features : if feature . shape [ 0 ] == 0 : return True return False", "docstring_tokens": "Check features data are not empty", "label": 1}, {"idx": "cosqa-train-11386", "doc": "python mapp an array to a color scale", "code": "def apply_color_map(name: str, mat: np.ndarray = None):\n    \"\"\"returns an RGB matrix scaled by a matplotlib color map\"\"\"\n    def apply_map(mat):\n        return (cm.get_cmap(name)(_normalize(mat))[:, :, :3] * 255).astype(np.uint8)\n        \n    return apply_map if mat is None else apply_map(mat)", "code_tokens": "def apply_color_map ( name : str , mat : np . ndarray = None ) : def apply_map ( mat ) : return ( cm . get_cmap ( name ) ( _normalize ( mat ) ) [ : , : , : 3 ] * 255 ) . astype ( np . uint8 ) return apply_map if mat is None else apply_map ( mat )", "docstring_tokens": "returns an RGB matrix scaled by a matplotlib color map", "label": 0}, {"idx": "cosqa-train-11387", "doc": "how to check if sprites collide in python", "code": "def check_player_collision(self):\n        \"\"\"Check to see if we are colliding with the player.\"\"\"\n        player_tiles = r.TileMapManager.active_map.grab_collisions(self.char.coords)\n        enemy_tiles = r.TileMapManager.active_map.grab_collisions(self.coords)\n\n        #Check to see if any of the tiles are the same. If so, there is a collision.\n        for ptile in player_tiles:\n            for etile in enemy_tiles:\n                if r.TileMapManager.active_map.pixels_to_tiles(ptile.coords) == r.TileMapManager.active_map.pixels_to_tiles(etile.coords):\n                    return True\n\n        return False", "code_tokens": "def check_player_collision ( self ) : player_tiles = r . TileMapManager . active_map . grab_collisions ( self . char . coords ) enemy_tiles = r . TileMapManager . active_map . grab_collisions ( self . coords ) #Check to see if any of the tiles are the same. If so, there is a collision. for ptile in player_tiles : for etile in enemy_tiles : if r . TileMapManager . active_map . pixels_to_tiles ( ptile . coords ) == r . TileMapManager . active_map . pixels_to_tiles ( etile . coords ) : return True return False", "docstring_tokens": "Check to see if we are colliding with the player .", "label": 1}, {"idx": "cosqa-train-11388", "doc": "python mask array nomask", "code": "def asMaskedArray(self):\n        \"\"\" Creates converts to a masked array\n        \"\"\"\n        return ma.masked_array(data=self.data, mask=self.mask, fill_value=self.fill_value)", "code_tokens": "def asMaskedArray ( self ) : return ma . masked_array ( data = self . data , mask = self . mask , fill_value = self . fill_value )", "docstring_tokens": "Creates converts to a masked array", "label": 1}, {"idx": "cosqa-train-11389", "doc": "how to check if text file is empty or not python", "code": "def file_empty(fp):\n    \"\"\"Determine if a file is empty or not.\"\"\"\n    # for python 2 we need to use a homemade peek()\n    if six.PY2:\n        contents = fp.read()\n        fp.seek(0)\n        return not bool(contents)\n\n    else:\n        return not fp.peek()", "code_tokens": "def file_empty ( fp ) : # for python 2 we need to use a homemade peek() if six . PY2 : contents = fp . read ( ) fp . seek ( 0 ) return not bool ( contents ) else : return not fp . peek ( )", "docstring_tokens": "Determine if a file is empty or not .", "label": 1}, {"idx": "cosqa-train-11390", "doc": "python match a set of strings", "code": "def match(string, patterns):\n    \"\"\"Given a string return true if it matches the supplied list of\n    patterns.\n\n    Parameters\n    ----------\n    string : str\n        The string to be matched.\n    patterns : None or [pattern, ...]\n        The series of regular expressions to attempt to match.\n    \"\"\"\n    if patterns is None:\n        return True\n    else:\n        return any(re.match(pattern, string)\n                   for pattern in patterns)", "code_tokens": "def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )", "docstring_tokens": "Given a string return true if it matches the supplied list of patterns .", "label": 1}, {"idx": "cosqa-train-11391", "doc": "how to check image format in tensorflow or python", "code": "def read_image(filepath):\n  \"\"\"Returns an image tensor.\"\"\"\n  im_bytes = tf.io.read_file(filepath)\n  im = tf.image.decode_image(im_bytes, channels=CHANNELS)\n  im = tf.image.convert_image_dtype(im, tf.float32)\n  return im", "code_tokens": "def read_image ( filepath ) : im_bytes = tf . io . read_file ( filepath ) im = tf . image . decode_image ( im_bytes , channels = CHANNELS ) im = tf . image . convert_image_dtype ( im , tf . float32 ) return im", "docstring_tokens": "Returns an image tensor .", "label": 1}, {"idx": "cosqa-train-11392", "doc": "python math greatest common divisor", "code": "def _gcd_array(X):\n    \"\"\"\n    Return the largest real value h such that all elements in x are integer\n    multiples of h.\n    \"\"\"\n    greatest_common_divisor = 0.0\n    for x in X:\n        greatest_common_divisor = _gcd(greatest_common_divisor, x)\n\n    return greatest_common_divisor", "code_tokens": "def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor", "docstring_tokens": "Return the largest real value h such that all elements in x are integer multiples of h .", "label": 1}, {"idx": "cosqa-train-11393", "doc": "how to check number has only two digit in python", "code": "def is_valid(number):\n    \"\"\"determines whether the card number is valid.\"\"\"\n    n = str(number)\n    if not n.isdigit():\n        return False\n    return int(n[-1]) == get_check_digit(n[:-1])", "code_tokens": "def is_valid ( number ) : n = str ( number ) if not n . isdigit ( ) : return False return int ( n [ - 1 ] ) == get_check_digit ( n [ : - 1 ] )", "docstring_tokens": "determines whether the card number is valid .", "label": 1}, {"idx": "cosqa-train-11394", "doc": "how to check path is a file or directory python", "code": "def is_file(path):\n    \"\"\"Determine if a Path or string is a file on the file system.\"\"\"\n    try:\n        return path.expanduser().absolute().is_file()\n    except AttributeError:\n        return os.path.isfile(os.path.abspath(os.path.expanduser(str(path))))", "code_tokens": "def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )", "docstring_tokens": "Determine if a Path or string is a file on the file system .", "label": 1}, {"idx": "cosqa-train-11395", "doc": "python matplotlib not in new window", "code": "def raise_figure_window(f=0):\n    \"\"\"\n    Raises the supplied figure number or figure window.\n    \"\"\"\n    if _fun.is_a_number(f): f = _pylab.figure(f)\n    f.canvas.manager.window.raise_()", "code_tokens": "def raise_figure_window ( f = 0 ) : if _fun . is_a_number ( f ) : f = _pylab . figure ( f ) f . canvas . manager . window . raise_ ( )", "docstring_tokens": "Raises the supplied figure number or figure window .", "label": 1}, {"idx": "cosqa-train-11396", "doc": "how to check python object iterable", "code": "def is_iterable_but_not_string(obj):\n    \"\"\"\n    Determine whether or not obj is iterable but not a string (eg, a list, set, tuple etc).\n    \"\"\"\n    return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)", "code_tokens": "def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )", "docstring_tokens": "Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) .", "label": 1}, {"idx": "cosqa-train-11397", "doc": "python matplotlib prevent figure window take focus", "code": "def raise_figure_window(f=0):\n    \"\"\"\n    Raises the supplied figure number or figure window.\n    \"\"\"\n    if _fun.is_a_number(f): f = _pylab.figure(f)\n    f.canvas.manager.window.raise_()", "code_tokens": "def raise_figure_window ( f = 0 ) : if _fun . is_a_number ( f ) : f = _pylab . figure ( f ) f . canvas . manager . window . raise_ ( )", "docstring_tokens": "Raises the supplied figure number or figure window .", "label": 1}, {"idx": "cosqa-train-11398", "doc": "how to check the index of a series in python", "code": "def series_index(self, series):\n        \"\"\"\n        Return the integer index of *series* in this sequence.\n        \"\"\"\n        for idx, s in enumerate(self):\n            if series is s:\n                return idx\n        raise ValueError('series not in chart data object')", "code_tokens": "def series_index ( self , series ) : for idx , s in enumerate ( self ) : if series is s : return idx raise ValueError ( 'series not in chart data object' )", "docstring_tokens": "Return the integer index of * series * in this sequence .", "label": 0}, {"idx": "cosqa-train-11399", "doc": "python matplotlib use arrow markers", "code": "def add_arrow(self, x1, y1, x2, y2, **kws):\n        \"\"\"add arrow to plot\"\"\"\n        self.panel.add_arrow(x1, y1, x2, y2, **kws)", "code_tokens": "def add_arrow ( self , x1 , y1 , x2 , y2 , * * kws ) : self . panel . add_arrow ( x1 , y1 , x2 , y2 , * * kws )", "docstring_tokens": "add arrow to plot", "label": 1}, {"idx": "cosqa-train-11400", "doc": "how to check the interval in a list in python", "code": "def are_in_interval(s, l, r, border = 'included'):\n        \"\"\"\n        Checks whether all number in the sequence s lie inside the interval formed by\n        l and r.\n        \"\"\"\n        return numpy.all([IntensityRangeStandardization.is_in_interval(x, l, r, border) for x in s])", "code_tokens": "def are_in_interval ( s , l , r , border = 'included' ) : return numpy . all ( [ IntensityRangeStandardization . is_in_interval ( x , l , r , border ) for x in s ] )", "docstring_tokens": "Checks whether all number in the sequence s lie inside the interval formed by l and r .", "label": 1}, {"idx": "cosqa-train-11401", "doc": "python matrix band dot", "code": "def magnitude(X):\n    \"\"\"Magnitude of a complex matrix.\"\"\"\n    r = np.real(X)\n    i = np.imag(X)\n    return np.sqrt(r * r + i * i);", "code_tokens": "def magnitude ( X ) : r = np . real ( X ) i = np . imag ( X ) return np . sqrt ( r * r + i * i )", "docstring_tokens": "Magnitude of a complex matrix .", "label": 0}, {"idx": "cosqa-train-11402", "doc": "how to check the log created by python code in docker container", "code": "def _stream_docker_logs(self):\n        \"\"\"Stream stdout and stderr from the task container to this\n        process's stdout and stderr, respectively.\n        \"\"\"\n        thread = threading.Thread(target=self._stderr_stream_worker)\n        thread.start()\n        for line in self.docker_client.logs(self.container, stdout=True,\n                                            stderr=False, stream=True):\n            sys.stdout.write(line)\n        thread.join()", "code_tokens": "def _stream_docker_logs ( self ) : thread = threading . Thread ( target = self . _stderr_stream_worker ) thread . start ( ) for line in self . docker_client . logs ( self . container , stdout = True , stderr = False , stream = True ) : sys . stdout . write ( line ) thread . join ( )", "docstring_tokens": "Stream stdout and stderr from the task container to this process s stdout and stderr respectively .", "label": 1}, {"idx": "cosqa-train-11403", "doc": "python max size variable name", "code": "def calculate_size(name, max_size):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    return data_size", "code_tokens": "def calculate_size ( name , max_size ) : data_size = 0 data_size += calculate_size_str ( name ) data_size += INT_SIZE_IN_BYTES return data_size", "docstring_tokens": "Calculates the request payload size", "label": 1}, {"idx": "cosqa-train-11404", "doc": "how to check to see if a file exists in python", "code": "def _file_exists(path, filename):\n  \"\"\"Checks if the filename exists under the path.\"\"\"\n  return os.path.isfile(os.path.join(path, filename))", "code_tokens": "def _file_exists ( path , filename ) : return os . path . isfile ( os . path . join ( path , filename ) )", "docstring_tokens": "Checks if the filename exists under the path .", "label": 1}, {"idx": "cosqa-train-11405", "doc": "python maximum line length", "code": "def _multiline_width(multiline_s, line_width_fn=len):\n    \"\"\"Visible width of a potentially multiline content.\"\"\"\n    return max(map(line_width_fn, re.split(\"[\\r\\n]\", multiline_s)))", "code_tokens": "def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( \"[\\r\\n]\" , multiline_s ) ) )", "docstring_tokens": "Visible width of a potentially multiline content .", "label": 1}, {"idx": "cosqa-train-11406", "doc": "how to chek size of dataset in python", "code": "def shape(self):\n        \"\"\"Compute the shape of the dataset as (rows, cols).\"\"\"\n        if not self.data:\n            return (0, 0)\n        return (len(self.data), len(self.dimensions))", "code_tokens": "def shape ( self ) : if not self . data : return ( 0 , 0 ) return ( len ( self . data ) , len ( self . dimensions ) )", "docstring_tokens": "Compute the shape of the dataset as ( rows cols ) .", "label": 1}, {"idx": "cosqa-train-11407", "doc": "python md5 hash string", "code": "def md5_string(s):\n    \"\"\"\n    Shortcut to create md5 hash\n    :param s:\n    :return:\n    \"\"\"\n    m = hashlib.md5()\n    m.update(s)\n    return str(m.hexdigest())", "code_tokens": "def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )", "docstring_tokens": "Shortcut to create md5 hash : param s : : return :", "label": 1}, {"idx": "cosqa-train-11408", "doc": "how to clear all python dependancies", "code": "def clear_all(self):\n        \"\"\" clear all files that were to be injected \"\"\"\n        self.injections.clear_all()\n        for config_file in CONFIG_FILES:\n            self.injections.clear(os.path.join(\"~\", config_file))", "code_tokens": "def clear_all ( self ) : self . injections . clear_all ( ) for config_file in CONFIG_FILES : self . injections . clear ( os . path . join ( \"~\" , config_file ) )", "docstring_tokens": "clear all files that were to be injected", "label": 1}, {"idx": "cosqa-train-11409", "doc": "python merge pdf files free", "code": "def merge_pdfs(pdf_filepaths, out_filepath):\n    \"\"\" Merge all the PDF files in `pdf_filepaths` in a new PDF file `out_filepath`.\n\n    Parameters\n    ----------\n    pdf_filepaths: list of str\n        Paths to PDF files.\n\n    out_filepath: str\n        Path to the result PDF file.\n\n    Returns\n    -------\n    path: str\n        The output file path.\n    \"\"\"\n    merger = PdfFileMerger()\n    for pdf in pdf_filepaths:\n        merger.append(PdfFileReader(open(pdf, 'rb')))\n\n    merger.write(out_filepath)\n\n    return out_filepath", "code_tokens": "def merge_pdfs ( pdf_filepaths , out_filepath ) : merger = PdfFileMerger ( ) for pdf in pdf_filepaths : merger . append ( PdfFileReader ( open ( pdf , 'rb' ) ) ) merger . write ( out_filepath ) return out_filepath", "docstring_tokens": "Merge all the PDF files in pdf_filepaths in a new PDF file out_filepath .", "label": 1}, {"idx": "cosqa-train-11410", "doc": "how to clear output in juypter python", "code": "def clear_worker_output(self):\n        \"\"\"Drops all of the worker output collections\n            Args:\n                None\n            Returns:\n                Nothing\n        \"\"\"\n        self.data_store.clear_worker_output()\n\n        # Have the plugin manager reload all the plugins\n        self.plugin_manager.load_all_plugins()\n\n        # Store information about commands and workbench\n        self._store_information()", "code_tokens": "def clear_worker_output ( self ) : self . data_store . clear_worker_output ( ) # Have the plugin manager reload all the plugins self . plugin_manager . load_all_plugins ( ) # Store information about commands and workbench self . _store_information ( )", "docstring_tokens": "Drops all of the worker output collections Args : None Returns : Nothing", "label": 1}, {"idx": "cosqa-train-11411", "doc": "python meters to lat lon", "code": "def get_lons_from_cartesian(x__, y__):\n    \"\"\"Get longitudes from cartesian coordinates.\n    \"\"\"\n    return rad2deg(arccos(x__ / sqrt(x__ ** 2 + y__ ** 2))) * sign(y__)", "code_tokens": "def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )", "docstring_tokens": "Get longitudes from cartesian coordinates .", "label": 0}, {"idx": "cosqa-train-11412", "doc": "how to clear plots python", "code": "def clear(self):\n        \"\"\" clear plot \"\"\"\n        self.axes.cla()\n        self.conf.ntrace = 0\n        self.conf.xlabel = ''\n        self.conf.ylabel = ''\n        self.conf.title  = ''", "code_tokens": "def clear ( self ) : self . axes . cla ( ) self . conf . ntrace = 0 self . conf . xlabel = '' self . conf . ylabel = '' self . conf . title = ''", "docstring_tokens": "clear plot", "label": 1}, {"idx": "cosqa-train-11413", "doc": "python method args matching stars", "code": "def trigger(self, target: str, trigger: str, parameters: Dict[str, Any]={}):\n\t\t\"\"\"Calls the specified Trigger of another Area with the optionally given parameters.\n\n\t\tArgs:\n\t\t\ttarget: The name of the target Area.\n\t\t\ttrigger: The name of the Trigger.\n\t\t\tparameters: The parameters of the function call.\n\t\t\"\"\"\n\t\tpass", "code_tokens": "def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass", "docstring_tokens": "Calls the specified Trigger of another Area with the optionally given parameters .", "label": 1}, {"idx": "cosqa-train-11414", "doc": "python minidom remove empty line", "code": "def cleanup_nodes(doc):\n    \"\"\"\n    Remove text nodes containing only whitespace\n    \"\"\"\n    for node in doc.documentElement.childNodes:\n        if node.nodeType == Node.TEXT_NODE and node.nodeValue.isspace():\n            doc.documentElement.removeChild(node)\n    return doc", "code_tokens": "def cleanup_nodes ( doc ) : for node in doc . documentElement . childNodes : if node . nodeType == Node . TEXT_NODE and node . nodeValue . isspace ( ) : doc . documentElement . removeChild ( node ) return doc", "docstring_tokens": "Remove text nodes containing only whitespace", "label": 1}, {"idx": "cosqa-train-11415", "doc": "how to close figure python", "code": "def close_all_but_this(self):\n        \"\"\"Close all files but the current one\"\"\"\n        self.close_all_right()\n        for i in range(0, self.get_stack_count()-1  ):\n            self.close_file(0)", "code_tokens": "def close_all_but_this ( self ) : self . close_all_right ( ) for i in range ( 0 , self . get_stack_count ( ) - 1 ) : self . close_file ( 0 )", "docstring_tokens": "Close all files but the current one", "label": 1}, {"idx": "cosqa-train-11416", "doc": "python minimum value numpy array", "code": "def fn_min(self, a, axis=None):\n        \"\"\"\n        Return the minimum of an array, ignoring any NaNs.\n\n        :param a: The array.\n        :return: The minimum value of the array.\n        \"\"\"\n\n        return numpy.nanmin(self._to_ndarray(a), axis=axis)", "code_tokens": "def fn_min ( self , a , axis = None ) : return numpy . nanmin ( self . _to_ndarray ( a ) , axis = axis )", "docstring_tokens": "Return the minimum of an array ignoring any NaNs .", "label": 1}, {"idx": "cosqa-train-11417", "doc": "how to code a word count with python", "code": "def count_words(file):\n  \"\"\" Counts the word frequences in a list of sentences.\n\n  Note:\n    This is a helper function for parallel execution of `Vocabulary.from_text`\n    method.\n  \"\"\"\n  c = Counter()\n  with open(file, 'r') as f:\n    for l in f:\n      words = l.strip().split()\n      c.update(words)\n  return c", "code_tokens": "def count_words ( file ) : c = Counter ( ) with open ( file , 'r' ) as f : for l in f : words = l . strip ( ) . split ( ) c . update ( words ) return c", "docstring_tokens": "Counts the word frequences in a list of sentences .", "label": 1}, {"idx": "cosqa-train-11418", "doc": "python mlab distribution log normal", "code": "def lognorm(x, mu, sigma=1.0):\n    \"\"\" Log-normal function from scipy \"\"\"\n    return stats.lognorm(sigma, scale=mu).pdf(x)", "code_tokens": "def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )", "docstring_tokens": "Log - normal function from scipy", "label": 1}, {"idx": "cosqa-train-11419", "doc": "how to code adjacency matrix python", "code": "def adjacency(tree):\n    \"\"\"\n    Construct the adjacency matrix of the tree\n    :param tree:\n    :return:\n    \"\"\"\n    dd = ids(tree)\n    N = len(dd)\n    A = np.zeros((N, N))\n\n    def _adj(node):\n        if np.isscalar(node):\n            return\n        elif isinstance(node, tuple) and len(node) == 2:\n            A[dd[node], dd[node[0]]] = 1\n            A[dd[node[0]], dd[node]] = 1\n            _adj(node[0])\n\n            A[dd[node], dd[node[1]]] = 1\n            A[dd[node[1]], dd[node]] = 1\n            _adj(node[1])\n\n    _adj(tree)\n    return A", "code_tokens": "def adjacency ( tree ) : dd = ids ( tree ) N = len ( dd ) A = np . zeros ( ( N , N ) ) def _adj ( node ) : if np . isscalar ( node ) : return elif isinstance ( node , tuple ) and len ( node ) == 2 : A [ dd [ node ] , dd [ node [ 0 ] ] ] = 1 A [ dd [ node [ 0 ] ] , dd [ node ] ] = 1 _adj ( node [ 0 ] ) A [ dd [ node ] , dd [ node [ 1 ] ] ] = 1 A [ dd [ node [ 1 ] ] , dd [ node ] ] = 1 _adj ( node [ 1 ] ) _adj ( tree ) return A", "docstring_tokens": "Construct the adjacency matrix of the tree : param tree : : return :", "label": 1}, {"idx": "cosqa-train-11420", "doc": "python mock patch only in function", "code": "def tinsel(to_patch, module_name, decorator=mock_decorator):\n    \"\"\"\n    Decorator for simple in-place decorator mocking for tests\n\n    Args:\n        to_patch: the string path of the function to patch\n        module_name: complete string path of the module to reload\n        decorator (optional): replacement decorator. By default a pass-through\n            will be used.\n\n    Returns:\n        A wrapped test function, during the context of execution the specified\n        path is patched.\n\n    \"\"\"\n    def fn_decorator(function):\n        def wrapper(*args, **kwargs):\n            with patch(to_patch, decorator):\n                m = importlib.import_module(module_name)\n                reload(m)\n                function(*args, **kwargs)\n\n            reload(m)\n        return wrapper\n    return fn_decorator", "code_tokens": "def tinsel ( to_patch , module_name , decorator = mock_decorator ) : def fn_decorator ( function ) : def wrapper ( * args , * * kwargs ) : with patch ( to_patch , decorator ) : m = importlib . import_module ( module_name ) reload ( m ) function ( * args , * * kwargs ) reload ( m ) return wrapper return fn_decorator", "docstring_tokens": "Decorator for simple in - place decorator mocking for tests", "label": 1}, {"idx": "cosqa-train-11421", "doc": "how to code change text color in python", "code": "def stringc(text, color):\n    \"\"\"\n    Return a string with terminal colors.\n    \"\"\"\n    if has_colors:\n        text = str(text)\n\n        return \"\\033[\"+codeCodes[color]+\"m\"+text+\"\\033[0m\"\n    else:\n        return text", "code_tokens": "def stringc ( text , color ) : if has_colors : text = str ( text ) return \"\\033[\" + codeCodes [ color ] + \"m\" + text + \"\\033[0m\" else : return text", "docstring_tokens": "Return a string with terminal colors .", "label": 1}, {"idx": "cosqa-train-11422", "doc": "python mock set constructor", "code": "def __setitem__(self, _ignored, return_value):\n        \"\"\"Item assignment sets the return value and removes any side effect\"\"\"\n        self.mock.return_value = return_value\n        self.mock.side_effect = None", "code_tokens": "def __setitem__ ( self , _ignored , return_value ) : self . mock . return_value = return_value self . mock . side_effect = None", "docstring_tokens": "Item assignment sets the return value and removes any side effect", "label": 0}, {"idx": "cosqa-train-11423", "doc": "how to code for empty table in python", "code": "def step_table_made(self):\n        \"\"\"check if the step table exists\"\"\"\n        try:\n            empty = self.step_table.empty\n        except AttributeError:\n            empty = True\n        return not empty", "code_tokens": "def step_table_made ( self ) : try : empty = self . step_table . empty except AttributeError : empty = True return not empty", "docstring_tokens": "check if the step table exists", "label": 1}, {"idx": "cosqa-train-11424", "doc": "python modified file watchdog", "code": "def on_modified(self, event):\n        \"\"\"Function called everytime a new file is modified.\n\n        Args:\n            event: Event to process.\n        \"\"\"\n        self._logger.debug('Detected modify event on watched path: %s', event.src_path)\n\n        self._process_event(event)", "code_tokens": "def on_modified ( self , event ) : self . _logger . debug ( 'Detected modify event on watched path: %s' , event . src_path ) self . _process_event ( event )", "docstring_tokens": "Function called everytime a new file is modified .", "label": 1}, {"idx": "cosqa-train-11425", "doc": "how to code for the fibbonacci sequence in python", "code": "def software_fibonacci(n):\n    \"\"\" a normal old python function to return the Nth fibonacci number. \"\"\"\n    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    return a", "code_tokens": "def software_fibonacci ( n ) : a , b = 0 , 1 for i in range ( n ) : a , b = b , a + b return a", "docstring_tokens": "a normal old python function to return the Nth fibonacci number .", "label": 1}, {"idx": "cosqa-train-11426", "doc": "python modify dict in function", "code": "def _modify(item, func):\n    \"\"\"\n    Modifies each item.keys() string based on the func passed in.\n    Often used with inflection's camelize or underscore methods.\n\n    :param item: dictionary representing item to be modified\n    :param func: function to run on each key string\n    :return: dictionary where each key has been modified by func.\n    \"\"\"\n    result = dict()\n    for key in item:\n        result[func(key)] = item[key]\n    return result", "code_tokens": "def _modify ( item , func ) : result = dict ( ) for key in item : result [ func ( key ) ] = item [ key ] return result", "docstring_tokens": "Modifies each item . keys () string based on the func passed in . Often used with inflection s camelize or underscore methods .", "label": 1}, {"idx": "cosqa-train-11427", "doc": "how to combine sentence into list python", "code": "def tokenize_list(self, text):\n        \"\"\"\n        Split a text into separate words.\n        \"\"\"\n        return [self.get_record_token(record) for record in self.analyze(text)]", "code_tokens": "def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]", "docstring_tokens": "Split a text into separate words .", "label": 1}, {"idx": "cosqa-train-11428", "doc": "python mongo objectid string", "code": "def find_one_by_id(self, _id):\n        \"\"\"\n        Find a single document by id\n\n        :param str _id: BSON string repreentation of the Id\n        :return: a signle object\n        :rtype: dict\n\n        \"\"\"\n        document = (yield self.collection.find_one({\"_id\": ObjectId(_id)}))\n        raise Return(self._obj_cursor_to_dictionary(document))", "code_tokens": "def find_one_by_id ( self , _id ) : document = ( yield self . collection . find_one ( { \"_id\" : ObjectId ( _id ) } ) ) raise Return ( self . _obj_cursor_to_dictionary ( document ) )", "docstring_tokens": "Find a single document by id", "label": 1}, {"idx": "cosqa-train-11429", "doc": "how to commit multiple things at once python", "code": "def _records_commit(record_ids):\n    \"\"\"Commit all records.\"\"\"\n    for record_id in record_ids:\n        record = Record.get_record(record_id)\n        record.commit()", "code_tokens": "def _records_commit ( record_ids ) : for record_id in record_ids : record = Record . get_record ( record_id ) record . commit ( )", "docstring_tokens": "Commit all records .", "label": 1}, {"idx": "cosqa-train-11430", "doc": "python mongoclient close connection", "code": "def cleanup(self, app):\n        \"\"\"Close all connections.\"\"\"\n        if hasattr(self.database.obj, 'close_all'):\n            self.database.close_all()", "code_tokens": "def cleanup ( self , app ) : if hasattr ( self . database . obj , 'close_all' ) : self . database . close_all ( )", "docstring_tokens": "Close all connections .", "label": 1}, {"idx": "cosqa-train-11431", "doc": "how to compare a string and integer python", "code": "def is_int(string):\n    \"\"\"\n    Checks if a string is an integer. If the string value is an integer\n    return True, otherwise return False. \n    \n    Args:\n        string: a string to test.\n\n    Returns: \n        boolean\n    \"\"\"\n    try:\n        a = float(string)\n        b = int(a)\n    except ValueError:\n        return False\n    else:\n        return a == b", "code_tokens": "def is_int ( string ) : try : a = float ( string ) b = int ( a ) except ValueError : return False else : return a == b", "docstring_tokens": "Checks if a string is an integer . If the string value is an integer return True otherwise return False . Args : string : a string to test .", "label": 1}, {"idx": "cosqa-train-11432", "doc": "python mongodb create index", "code": "def ensure_index(self, key, unique=False):\n        \"\"\"Wrapper for pymongo.Collection.ensure_index\n        \"\"\"\n        return self.collection.ensure_index(key, unique=unique)", "code_tokens": "def ensure_index ( self , key , unique = False ) : return self . collection . ensure_index ( key , unique = unique )", "docstring_tokens": "Wrapper for pymongo . Collection . ensure_index", "label": 1}, {"idx": "cosqa-train-11433", "doc": "how to compile a single python file", "code": "def execfile(fname, variables):\n    \"\"\" This is builtin in python2, but we have to roll our own on py3. \"\"\"\n    with open(fname) as f:\n        code = compile(f.read(), fname, 'exec')\n        exec(code, variables)", "code_tokens": "def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )", "docstring_tokens": "This is builtin in python2 but we have to roll our own on py3 .", "label": 0}, {"idx": "cosqa-train-11434", "doc": "python mongodb cursor to json", "code": "def _obj_cursor_to_dictionary(self, cursor):\n        \"\"\"Handle conversion of pymongo cursor into a JSON object formatted for UI consumption\n\n        :param dict cursor: a mongo document that should be converted to primitive types for the client code\n        :returns: a primitive dictionary\n        :rtype: dict\n        \"\"\"\n        if not cursor:\n            return cursor\n\n        cursor = json.loads(json.dumps(cursor, cls=BSONEncoder))\n\n        if cursor.get(\"_id\"):\n            cursor[\"id\"] = cursor.get(\"_id\")\n            del cursor[\"_id\"]\n\n        return cursor", "code_tokens": "def _obj_cursor_to_dictionary ( self , cursor ) : if not cursor : return cursor cursor = json . loads ( json . dumps ( cursor , cls = BSONEncoder ) ) if cursor . get ( \"_id\" ) : cursor [ \"id\" ] = cursor . get ( \"_id\" ) del cursor [ \"_id\" ] return cursor", "docstring_tokens": "Handle conversion of pymongo cursor into a JSON object formatted for UI consumption", "label": 1}, {"idx": "cosqa-train-11435", "doc": "how to compute median of 3 values in python using function", "code": "def median(data):\n    \"\"\"Calculate the median of a list.\"\"\"\n    data.sort()\n    num_values = len(data)\n    half = num_values // 2\n    if num_values % 2:\n        return data[half]\n    return 0.5 * (data[half-1] + data[half])", "code_tokens": "def median ( data ) : data . sort ( ) num_values = len ( data ) half = num_values // 2 if num_values % 2 : return data [ half ] return 0.5 * ( data [ half - 1 ] + data [ half ] )", "docstring_tokens": "Calculate the median of a list .", "label": 1}, {"idx": "cosqa-train-11436", "doc": "python most common element in list", "code": "def mostCommonItem(lst):\n    \"\"\"Choose the most common item from the list, or the first item if all\n    items are unique.\"\"\"\n    # This elegant solution from: http://stackoverflow.com/a/1518632/1760218\n    lst = [l for l in lst if l]\n    if lst:\n        return max(set(lst), key=lst.count)\n    else:\n        return None", "code_tokens": "def mostCommonItem ( lst ) : # This elegant solution from: http://stackoverflow.com/a/1518632/1760218 lst = [ l for l in lst if l ] if lst : return max ( set ( lst ) , key = lst . count ) else : return None", "docstring_tokens": "Choose the most common item from the list or the first item if all items are unique .", "label": 1}, {"idx": "cosqa-train-11437", "doc": "how to connect redis using python", "code": "def __connect():\n    \"\"\"\n    Connect to a redis instance.\n    \"\"\"\n    global redis_instance\n    if use_tcp_socket:\n        redis_instance = redis.StrictRedis(host=hostname, port=port)\n    else:\n        redis_instance = redis.StrictRedis(unix_socket_path=unix_socket)", "code_tokens": "def __connect ( ) : global redis_instance if use_tcp_socket : redis_instance = redis . StrictRedis ( host = hostname , port = port ) else : redis_instance = redis . StrictRedis ( unix_socket_path = unix_socket )", "docstring_tokens": "Connect to a redis instance .", "label": 1}, {"idx": "cosqa-train-11438", "doc": "python move index to comumn", "code": "def select_up(self):\n        \"\"\"move cursor up\"\"\"\n        r, c = self._index\n        self._select_index(r-1, c)", "code_tokens": "def select_up ( self ) : r , c = self . _index self . _select_index ( r - 1 , c )", "docstring_tokens": "move cursor up", "label": 1}, {"idx": "cosqa-train-11439", "doc": "how to connect to mq using python", "code": "def init_mq(self):\n        \"\"\"Init connection and consumer with openstack mq.\"\"\"\n        mq = self.init_connection()\n        self.init_consumer(mq)\n        return mq.connection", "code_tokens": "def init_mq ( self ) : mq = self . init_connection ( ) self . init_consumer ( mq ) return mq . connection", "docstring_tokens": "Init connection and consumer with openstack mq .", "label": 0}, {"idx": "cosqa-train-11440", "doc": "python multiindex get index freeze", "code": "def validate_multiindex(self, obj):\n        \"\"\"validate that we can store the multi-index; reset and return the\n        new object\n        \"\"\"\n        levels = [l if l is not None else \"level_{0}\".format(i)\n                  for i, l in enumerate(obj.index.names)]\n        try:\n            return obj.reset_index(), levels\n        except ValueError:\n            raise ValueError(\"duplicate names/columns in the multi-index when \"\n                             \"storing as a table\")", "code_tokens": "def validate_multiindex ( self , obj ) : levels = [ l if l is not None else \"level_{0}\" . format ( i ) for i , l in enumerate ( obj . index . names ) ] try : return obj . reset_index ( ) , levels except ValueError : raise ValueError ( \"duplicate names/columns in the multi-index when \" \"storing as a table\" )", "docstring_tokens": "validate that we can store the multi - index ; reset and return the new object", "label": 1}, {"idx": "cosqa-train-11441", "doc": "how to conver list to dictionary in python", "code": "def list2dict(lst):\n    \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"\n\n    dic = {}\n    for k,v in lst: dic[k] = v\n    return dic", "code_tokens": "def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic", "docstring_tokens": "Takes a list of ( key value ) pairs and turns it into a dict .", "label": 1}, {"idx": "cosqa-train-11442", "doc": "python multiple context managers on single line", "code": "def replace_sys_args(new_args):\n    \"\"\"Temporarily replace sys.argv with current arguments\n\n    Restores sys.argv upon exit of the context manager.\n    \"\"\"\n    # Replace sys.argv arguments\n    # for module import\n    old_args = sys.argv\n    sys.argv = new_args\n    try:\n        yield\n    finally:\n        sys.argv = old_args", "code_tokens": "def replace_sys_args ( new_args ) : # Replace sys.argv arguments # for module import old_args = sys . argv sys . argv = new_args try : yield finally : sys . argv = old_args", "docstring_tokens": "Temporarily replace sys . argv with current arguments", "label": 1}, {"idx": "cosqa-train-11443", "doc": "how to convertt none type to string in python", "code": "def _cast_to_type(self, value):\n        \"\"\" Convert the value to its string representation\"\"\"\n        if isinstance(value, str) or value is None:\n            return value\n        return str(value)", "code_tokens": "def _cast_to_type ( self , value ) : if isinstance ( value , str ) or value is None : return value return str ( value )", "docstring_tokens": "Convert the value to its string representation", "label": 1}, {"idx": "cosqa-train-11444", "doc": "python multiple line string format", "code": "def format_line(data, linestyle):\n    \"\"\"Formats a list of elements using the given line style\"\"\"\n    return linestyle.begin + linestyle.sep.join(data) + linestyle.end", "code_tokens": "def format_line ( data , linestyle ) : return linestyle . begin + linestyle . sep . join ( data ) + linestyle . end", "docstring_tokens": "Formats a list of elements using the given line style", "label": 1}, {"idx": "cosqa-train-11445", "doc": "how to count the number of letters in python uing len", "code": "def display_len(text):\n    \"\"\"\n    Get the display length of a string. This can differ from the character\n    length if the string contains wide characters.\n    \"\"\"\n    text = unicodedata.normalize('NFD', text)\n    return sum(char_width(char) for char in text)", "code_tokens": "def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )", "docstring_tokens": "Get the display length of a string . This can differ from the character length if the string contains wide characters .", "label": 1}, {"idx": "cosqa-train-11446", "doc": "python multiply 3d matrix", "code": "def cross_product_matrix(vec):\n    \"\"\"Returns a 3x3 cross-product matrix from a 3-element vector.\"\"\"\n    return np.array([[0, -vec[2], vec[1]],\n                     [vec[2], 0, -vec[0]],\n                     [-vec[1], vec[0], 0]])", "code_tokens": "def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )", "docstring_tokens": "Returns a 3x3 cross - product matrix from a 3 - element vector .", "label": 1}, {"idx": "cosqa-train-11447", "doc": "how to create a variable containing multiple figures python", "code": "def strip_figures(figure):\n\t\"\"\"\n\tStrips a figure into multiple figures with a trace on each of them\n\n\tParameters:\n\t-----------\n\t\tfigure : Figure\n\t\t\tPlotly Figure\n\t\"\"\"\n\tfig=[]\n\tfor trace in figure['data']:\n\t\tfig.append(dict(data=[trace],layout=figure['layout']))\n\treturn fig", "code_tokens": "def strip_figures ( figure ) : fig = [ ] for trace in figure [ 'data' ] : fig . append ( dict ( data = [ trace ] , layout = figure [ 'layout' ] ) ) return fig", "docstring_tokens": "Strips a figure into multiple figures with a trace on each of them", "label": 1}, {"idx": "cosqa-train-11448", "doc": "python multiply a variable in a list", "code": "def multiply(self, number):\n        \"\"\"Return a Vector as the product of the vector and a real number.\"\"\"\n        return self.from_list([x * number for x in self.to_list()])", "code_tokens": "def multiply ( self , number ) : return self . from_list ( [ x * number for x in self . to_list ( ) ] )", "docstring_tokens": "Return a Vector as the product of the vector and a real number .", "label": 1}, {"idx": "cosqa-train-11449", "doc": "how to create acronyms and removed stopwords without nklt using python", "code": "def get_wordnet_syns(word):\n    \"\"\"\n    Utilize wordnet (installed with nltk) to get synonyms for words\n    word is the input word\n    returns a list of unique synonyms\n    \"\"\"\n    synonyms = []\n    regex = r\"_\"\n    pat = re.compile(regex)\n    synset = nltk.wordnet.wordnet.synsets(word)\n    for ss in synset:\n        for swords in ss.lemma_names:\n            synonyms.append(pat.sub(\" \", swords.lower()))\n    synonyms = f7(synonyms)\n    return synonyms", "code_tokens": "def get_wordnet_syns ( word ) : synonyms = [ ] regex = r\"_\" pat = re . compile ( regex ) synset = nltk . wordnet . wordnet . synsets ( word ) for ss in synset : for swords in ss . lemma_names : synonyms . append ( pat . sub ( \" \" , swords . lower ( ) ) ) synonyms = f7 ( synonyms ) return synonyms", "docstring_tokens": "Utilize wordnet ( installed with nltk ) to get synonyms for words word is the input word returns a list of unique synonyms", "label": 1}, {"idx": "cosqa-train-11450", "doc": "python multiproccessing map with multiple inputs", "code": "def imapchain(*a, **kwa):\n    \"\"\" Like map but also chains the results. \"\"\"\n\n    imap_results = map( *a, **kwa )\n    return itertools.chain( *imap_results )", "code_tokens": "def imapchain ( * a , * * kwa ) : imap_results = map ( * a , * * kwa ) return itertools . chain ( * imap_results )", "docstring_tokens": "Like map but also chains the results .", "label": 1}, {"idx": "cosqa-train-11451", "doc": "how to create dictionary from string in python", "code": "def list_string_to_dict(string):\n    \"\"\"Inputs ``['a', 'b', 'c']``, returns ``{'a': 0, 'b': 1, 'c': 2}``.\"\"\"\n    dictionary = {}\n    for idx, c in enumerate(string):\n        dictionary.update({c: idx})\n    return dictionary", "code_tokens": "def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary", "docstring_tokens": "Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } .", "label": 1}, {"idx": "cosqa-train-11452", "doc": "python multiprocessing stop a process", "code": "def stop(self, timeout=None):\n        \"\"\" Initiates a graceful stop of the processes \"\"\"\n\n        self.stopping = True\n\n        for process in list(self.processes):\n            self.stop_process(process, timeout=timeout)", "code_tokens": "def stop ( self , timeout = None ) : self . stopping = True for process in list ( self . processes ) : self . stop_process ( process , timeout = timeout )", "docstring_tokens": "Initiates a graceful stop of the processes", "label": 1}, {"idx": "cosqa-train-11453", "doc": "how to create dot file in python", "code": "def _intermediary_to_dot(tables, relationships):\n    \"\"\" Returns the dot source representing the database in a string. \"\"\"\n    t = '\\n'.join(t.to_dot() for t in tables)\n    r = '\\n'.join(r.to_dot() for r in relationships)\n    return '{}\\n{}\\n{}\\n}}'.format(GRAPH_BEGINNING, t, r)", "code_tokens": "def _intermediary_to_dot ( tables , relationships ) : t = '\\n' . join ( t . to_dot ( ) for t in tables ) r = '\\n' . join ( r . to_dot ( ) for r in relationships ) return '{}\\n{}\\n{}\\n}}' . format ( GRAPH_BEGINNING , t , r )", "docstring_tokens": "Returns the dot source representing the database in a string .", "label": 0}, {"idx": "cosqa-train-11454", "doc": "python mysql get list of table columns", "code": "def get_table_columns(dbconn, tablename):\n    \"\"\"\n    Return a list of tuples specifying the column name and type\n    \"\"\"\n    cur = dbconn.cursor()\n    cur.execute(\"PRAGMA table_info('%s');\" % tablename)\n    info = cur.fetchall()\n    cols = [(i[1], i[2]) for i in info]\n    return cols", "code_tokens": "def get_table_columns ( dbconn , tablename ) : cur = dbconn . cursor ( ) cur . execute ( \"PRAGMA table_info('%s');\" % tablename ) info = cur . fetchall ( ) cols = [ ( i [ 1 ] , i [ 2 ] ) for i in info ] return cols", "docstring_tokens": "Return a list of tuples specifying the column name and type", "label": 1}, {"idx": "cosqa-train-11455", "doc": "how to cretate an output file and route python output to a file", "code": "def build_output(self, fout):\n        \"\"\"Squash self.out into string.\n\n        Join every line in self.out with a new line and write the\n        result to the output file.\n        \"\"\"\n        fout.write('\\n'.join([s for s in self.out]))", "code_tokens": "def build_output ( self , fout ) : fout . write ( '\\n' . join ( [ s for s in self . out ] ) )", "docstring_tokens": "Squash self . out into string .", "label": 1}, {"idx": "cosqa-train-11456", "doc": "python mysqldb get cursor", "code": "def getCursor(self):\n\t\t\"\"\"\n\t\tGet a Dictionary Cursor for executing queries\n\t\t\"\"\"\n\t\tif self.connection is None:\n\t\t\tself.Connect()\n\t\t\t\n\t\treturn self.connection.cursor(MySQLdb.cursors.DictCursor)", "code_tokens": "def getCursor ( self ) : if self . connection is None : self . Connect ( ) return self . connection . cursor ( MySQLdb . cursors . DictCursor )", "docstring_tokens": "Get a Dictionary Cursor for executing queries", "label": 1}, {"idx": "cosqa-train-11457", "doc": "python neo4j driver to graphml", "code": "def to_dotfile(G: nx.DiGraph, filename: str):\n    \"\"\" Output a networkx graph to a DOT file. \"\"\"\n    A = to_agraph(G)\n    A.write(filename)", "code_tokens": "def to_dotfile ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . write ( filename )", "docstring_tokens": "Output a networkx graph to a DOT file .", "label": 1}, {"idx": "cosqa-train-11458", "doc": "how to deal with pickle file in python", "code": "def unpickle_file(picklefile, **kwargs):\n    \"\"\"Helper function to unpickle data from `picklefile`.\"\"\"\n    with open(picklefile, 'rb') as f:\n        return pickle.load(f, **kwargs)", "code_tokens": "def unpickle_file ( picklefile , * * kwargs ) : with open ( picklefile , 'rb' ) as f : return pickle . load ( f , * * kwargs )", "docstring_tokens": "Helper function to unpickle data from picklefile .", "label": 1}, {"idx": "cosqa-train-11459", "doc": "python networkx check if edge in graph", "code": "def has_edge(self, p_from, p_to):\n        \"\"\" Returns True when the graph has the given edge. \"\"\"\n        return p_from in self._edges and p_to in self._edges[p_from]", "code_tokens": "def has_edge ( self , p_from , p_to ) : return p_from in self . _edges and p_to in self . _edges [ p_from ]", "docstring_tokens": "Returns True when the graph has the given edge .", "label": 1}, {"idx": "cosqa-train-11460", "doc": "python networkx remove a node", "code": "def remove_node(self, node):\n        \"\"\" Remove a node from this network. \"\"\"\n        if _debug: Network._debug(\"remove_node %r\", node)\n\n        self.nodes.remove(node)\n        node.lan = None", "code_tokens": "def remove_node ( self , node ) : if _debug : Network . _debug ( \"remove_node %r\" , node ) self . nodes . remove ( node ) node . lan = None", "docstring_tokens": "Remove a node from this network .", "label": 1}, {"idx": "cosqa-train-11461", "doc": "how to delay a while loop in python", "code": "def test3():\n    \"\"\"Test the multiprocess\n    \"\"\"\n    import time\n    \n    p = MVisionProcess()\n    p.start()\n    time.sleep(5)\n    p.stop()", "code_tokens": "def test3 ( ) : import time p = MVisionProcess ( ) p . start ( ) time . sleep ( 5 ) p . stop ( )", "docstring_tokens": "Test the multiprocess", "label": 1}, {"idx": "cosqa-train-11462", "doc": "python new image with colisions", "code": "def new(self, size, fill):\n        \"\"\"Return a new Image instance filled with a color.\"\"\"\n        return Image(PIL.Image.new(\"RGB\", size, fill))", "code_tokens": "def new ( self , size , fill ) : return Image ( PIL . Image . new ( \"RGB\" , size , fill ) )", "docstring_tokens": "Return a new Image instance filled with a color .", "label": 1}, {"idx": "cosqa-train-11463", "doc": "how to delete all the commas in a list python", "code": "def strip_spaces(value, sep=None, join=True):\n    \"\"\"Cleans trailing whitespaces and replaces also multiple whitespaces with a single space.\"\"\"\n    value = value.strip()\n    value = [v.strip() for v in value.split(sep)]\n    join_sep = sep or ' '\n    return join_sep.join(value) if join else value", "code_tokens": "def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value", "docstring_tokens": "Cleans trailing whitespaces and replaces also multiple whitespaces with a single space .", "label": 1}, {"idx": "cosqa-train-11464", "doc": "python no shortcut boolean condition", "code": "def less_strict_bool(x):\n    \"\"\"Idempotent and None-safe version of strict_bool.\"\"\"\n    if x is None:\n        return False\n    elif x is True or x is False:\n        return x\n    else:\n        return strict_bool(x)", "code_tokens": "def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )", "docstring_tokens": "Idempotent and None - safe version of strict_bool .", "label": 1}, {"idx": "cosqa-train-11465", "doc": "how to delete duplicate records in python", "code": "def _remove_duplicate_files(xs):\n    \"\"\"Remove files specified multiple times in a list.\n    \"\"\"\n    seen = set([])\n    out = []\n    for x in xs:\n        if x[\"path\"] not in seen:\n            out.append(x)\n            seen.add(x[\"path\"])\n    return out", "code_tokens": "def _remove_duplicate_files ( xs ) : seen = set ( [ ] ) out = [ ] for x in xs : if x [ \"path\" ] not in seen : out . append ( x ) seen . add ( x [ \"path\" ] ) return out", "docstring_tokens": "Remove files specified multiple times in a list .", "label": 1}, {"idx": "cosqa-train-11466", "doc": "python normalize matrix by column", "code": "def normalize(X):\n    \"\"\" equivalent to scipy.preprocessing.normalize on sparse matrices\n    , but lets avoid another depedency just for a small utility function \"\"\"\n    X = coo_matrix(X)\n    X.data = X.data / sqrt(bincount(X.row, X.data ** 2))[X.row]\n    return X", "code_tokens": "def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X", "docstring_tokens": "equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function", "label": 1}, {"idx": "cosqa-train-11467", "doc": "how to delete last list member in python", "code": "def remove_last_entry(self):\n        \"\"\"Remove the last NoteContainer in the Bar.\"\"\"\n        self.current_beat -= 1.0 / self.bar[-1][1]\n        self.bar = self.bar[:-1]\n        return self.current_beat", "code_tokens": "def remove_last_entry ( self ) : self . current_beat -= 1.0 / self . bar [ - 1 ] [ 1 ] self . bar = self . bar [ : - 1 ] return self . current_beat", "docstring_tokens": "Remove the last NoteContainer in the Bar .", "label": 1}, {"idx": "cosqa-train-11468", "doc": "python nose known fail", "code": "def run(self):\n        \"\"\"\n        Runs the unit test framework. Can be overridden to run anything.\n        Returns True on passing and False on failure.\n        \"\"\"\n        try:\n            import nose\n            arguments = [sys.argv[0]] + list(self.test_args)\n            return nose.run(argv=arguments)\n        except ImportError:\n            print()\n            print(\"*** Nose library missing. Please install it. ***\")\n            print()\n            raise", "code_tokens": "def run ( self ) : try : import nose arguments = [ sys . argv [ 0 ] ] + list ( self . test_args ) return nose . run ( argv = arguments ) except ImportError : print ( ) print ( \"*** Nose library missing. Please install it. ***\" ) print ( ) raise", "docstring_tokens": "Runs the unit test framework . Can be overridden to run anything . Returns True on passing and False on failure .", "label": 1}, {"idx": "cosqa-train-11469", "doc": "how to delete letters in a string in python", "code": "def _sanitize(text):\n    \"\"\"Return sanitized Eidos text field for human readability.\"\"\"\n    d = {'-LRB-': '(', '-RRB-': ')'}\n    return re.sub('|'.join(d.keys()), lambda m: d[m.group(0)], text)", "code_tokens": "def _sanitize ( text ) : d = { '-LRB-' : '(' , '-RRB-' : ')' } return re . sub ( '|' . join ( d . keys ( ) ) , lambda m : d [ m . group ( 0 ) ] , text )", "docstring_tokens": "Return sanitized Eidos text field for human readability .", "label": 0}, {"idx": "cosqa-train-11470", "doc": "python nose last run", "code": "def test(nose_argsuments):\n    \"\"\" Run application tests \"\"\"\n    from nose import run\n\n    params = ['__main__', '-c', 'nose.ini']\n    params.extend(nose_argsuments)\n    run(argv=params)", "code_tokens": "def test ( nose_argsuments ) : from nose import run params = [ '__main__' , '-c' , 'nose.ini' ] params . extend ( nose_argsuments ) run ( argv = params )", "docstring_tokens": "Run application tests", "label": 1}, {"idx": "cosqa-train-11471", "doc": "how to delete the element in list at a particular index in python", "code": "def pop(self, index=-1):\n\t\t\"\"\"Remove and return the item at index.\"\"\"\n\t\tvalue = self._list.pop(index)\n\t\tdel self._dict[value]\n\t\treturn value", "code_tokens": "def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value", "docstring_tokens": "Remove and return the item at index .", "label": 1}, {"idx": "cosqa-train-11472", "doc": "python not condition and condition", "code": "def _not(condition=None, **kwargs):\n    \"\"\"\n    Return the opposite of input condition.\n\n    :param condition: condition to process.\n\n    :result: not condition.\n    :rtype: bool\n    \"\"\"\n\n    result = True\n\n    if condition is not None:\n        result = not run(condition, **kwargs)\n\n    return result", "code_tokens": "def _not ( condition = None , * * kwargs ) : result = True if condition is not None : result = not run ( condition , * * kwargs ) return result", "docstring_tokens": "Return the opposite of input condition .", "label": 1}, {"idx": "cosqa-train-11473", "doc": "how to destroy a canvas in python", "code": "def clear(self):\n        \"\"\"Clear the displayed image.\"\"\"\n        self._imgobj = None\n        try:\n            # See if there is an image on the canvas\n            self.canvas.delete_object_by_tag(self._canvas_img_tag)\n            self.redraw()\n        except KeyError:\n            pass", "code_tokens": "def clear ( self ) : self . _imgobj = None try : # See if there is an image on the canvas self . canvas . delete_object_by_tag ( self . _canvas_img_tag ) self . redraw ( ) except KeyError : pass", "docstring_tokens": "Clear the displayed image .", "label": 1}, {"idx": "cosqa-train-11474", "doc": "python not recognizing named method", "code": "def FindMethodByName(self, name):\n    \"\"\"Searches for the specified method, and returns its descriptor.\"\"\"\n    for method in self.methods:\n      if name == method.name:\n        return method\n    return None", "code_tokens": "def FindMethodByName ( self , name ) : for method in self . methods : if name == method . name : return method return None", "docstring_tokens": "Searches for the specified method and returns its descriptor .", "label": 1}, {"idx": "cosqa-train-11475", "doc": "how to detect scrolls in python", "code": "def restore_scrollbar_position(self):\n        \"\"\"Restoring scrollbar position after main window is visible\"\"\"\n        scrollbar_pos = self.get_option('scrollbar_position', None)\n        if scrollbar_pos is not None:\n            self.explorer.treewidget.set_scrollbar_position(scrollbar_pos)", "code_tokens": "def restore_scrollbar_position ( self ) : scrollbar_pos = self . get_option ( 'scrollbar_position' , None ) if scrollbar_pos is not None : self . explorer . treewidget . set_scrollbar_position ( scrollbar_pos )", "docstring_tokens": "Restoring scrollbar position after main window is visible", "label": 1}, {"idx": "cosqa-train-11476", "doc": "how to determine index field type in python", "code": "def _getTypename(self, defn):\n        \"\"\" Returns the SQL typename required to store the given FieldDefinition \"\"\"\n        return 'REAL' if defn.type.float or 'TIME' in defn.type.name or defn.dntoeu else 'INTEGER'", "code_tokens": "def _getTypename ( self , defn ) : return 'REAL' if defn . type . float or 'TIME' in defn . type . name or defn . dntoeu else 'INTEGER'", "docstring_tokens": "Returns the SQL typename required to store the given FieldDefinition", "label": 1}, {"idx": "cosqa-train-11477", "doc": "python nouse wheel scrollbar", "code": "def wheel(delta=1):\n    \"\"\" Sends a wheel event for the provided number of clicks. May be negative to reverse\n    direction. \"\"\"\n    location = get_position()\n    e = Quartz.CGEventCreateMouseEvent(\n        None,\n        Quartz.kCGEventScrollWheel,\n        location,\n        Quartz.kCGMouseButtonLeft)\n    e2 = Quartz.CGEventCreateScrollWheelEvent(\n        None,\n        Quartz.kCGScrollEventUnitLine,\n        1,\n        delta)\n    Quartz.CGEventPost(Quartz.kCGHIDEventTap, e)\n    Quartz.CGEventPost(Quartz.kCGHIDEventTap, e2)", "code_tokens": "def wheel ( delta = 1 ) : location = get_position ( ) e = Quartz . CGEventCreateMouseEvent ( None , Quartz . kCGEventScrollWheel , location , Quartz . kCGMouseButtonLeft ) e2 = Quartz . CGEventCreateScrollWheelEvent ( None , Quartz . kCGScrollEventUnitLine , 1 , delta ) Quartz . CGEventPost ( Quartz . kCGHIDEventTap , e ) Quartz . CGEventPost ( Quartz . kCGHIDEventTap , e2 )", "docstring_tokens": "Sends a wheel event for the provided number of clicks . May be negative to reverse direction .", "label": 1}, {"idx": "cosqa-train-11478", "doc": "how to determine length of python email message in bytes", "code": "def header_length(bytearray):\n    \"\"\"Return the length of s when it is encoded with base64.\"\"\"\n    groups_of_3, leftover = divmod(len(bytearray), 3)\n    # 4 bytes out for each 3 bytes (or nonzero fraction thereof) in.\n    n = groups_of_3 * 4\n    if leftover:\n        n += 4\n    return n", "code_tokens": "def header_length ( bytearray ) : groups_of_3 , leftover = divmod ( len ( bytearray ) , 3 ) # 4 bytes out for each 3 bytes (or nonzero fraction thereof) in. n = groups_of_3 * 4 if leftover : n += 4 return n", "docstring_tokens": "Return the length of s when it is encoded with base64 .", "label": 1}, {"idx": "cosqa-train-11479", "doc": "python np array dtype", "code": "def dict_to_numpy_array(d):\n    \"\"\"\n    Convert a dict of 1d array to a numpy recarray\n    \"\"\"\n    return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))", "code_tokens": "def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )", "docstring_tokens": "Convert a dict of 1d array to a numpy recarray", "label": 1}, {"idx": "cosqa-train-11480", "doc": "how to determine the index of a specific value in python", "code": "def get_list_index(lst, index_or_name):\n    \"\"\"\n    Return the index of an element in the list.\n\n    Args:\n        lst (list): The list.\n        index_or_name (int or str): The value of the reference element, or directly its numeric index.\n\n    Returns:\n        (int) The index of the element in the list.\n    \"\"\"\n    if isinstance(index_or_name, six.integer_types):\n        return index_or_name\n\n    return lst.index(index_or_name)", "code_tokens": "def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )", "docstring_tokens": "Return the index of an element in the list .", "label": 1}, {"idx": "cosqa-train-11481", "doc": "python np interpolate for multiple dimensions", "code": "def get_line_flux(line_wave, wave, flux, **kwargs):\n    \"\"\"Interpolated flux at a given wavelength (calls np.interp).\"\"\"\n    return np.interp(line_wave, wave, flux, **kwargs)", "code_tokens": "def get_line_flux ( line_wave , wave , flux , * * kwargs ) : return np . interp ( line_wave , wave , flux , * * kwargs )", "docstring_tokens": "Interpolated flux at a given wavelength ( calls np . interp ) .", "label": 1}, {"idx": "cosqa-train-11482", "doc": "how to disable ssl check in python", "code": "def disable_insecure_request_warning():\n    \"\"\"Suppress warning about untrusted SSL certificate.\"\"\"\n    import requests\n    from requests.packages.urllib3.exceptions import InsecureRequestWarning\n    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)", "code_tokens": "def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )", "docstring_tokens": "Suppress warning about untrusted SSL certificate .", "label": 1}, {"idx": "cosqa-train-11483", "doc": "python number of non nan rows in a row", "code": "def count_rows_with_nans(X):\n    \"\"\"Count the number of rows in 2D arrays that contain any nan values.\"\"\"\n    if X.ndim == 2:\n        return np.where(np.isnan(X).sum(axis=1) != 0, 1, 0).sum()", "code_tokens": "def count_rows_with_nans ( X ) : if X . ndim == 2 : return np . where ( np . isnan ( X ) . sum ( axis = 1 ) != 0 , 1 , 0 ) . sum ( )", "docstring_tokens": "Count the number of rows in 2D arrays that contain any nan values .", "label": 1}, {"idx": "cosqa-train-11484", "doc": "how to disable ssl verification in python urllib", "code": "def disable_insecure_request_warning():\n    \"\"\"Suppress warning about untrusted SSL certificate.\"\"\"\n    import requests\n    from requests.packages.urllib3.exceptions import InsecureRequestWarning\n    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)", "code_tokens": "def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )", "docstring_tokens": "Suppress warning about untrusted SSL certificate .", "label": 1}, {"idx": "cosqa-train-11485", "doc": "python numpy array dtype", "code": "def dict_to_numpy_array(d):\n    \"\"\"\n    Convert a dict of 1d array to a numpy recarray\n    \"\"\"\n    return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))", "code_tokens": "def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )", "docstring_tokens": "Convert a dict of 1d array to a numpy recarray", "label": 1}, {"idx": "cosqa-train-11486", "doc": "how to do dimensional arrays in python", "code": "def length(self):\n        \"\"\"Array of vector lengths\"\"\"\n        return np.sqrt(np.sum(self**2, axis=1)).view(np.ndarray)", "code_tokens": "def length ( self ) : return np . sqrt ( np . sum ( self ** 2 , axis = 1 ) ) . view ( np . ndarray )", "docstring_tokens": "Array of vector lengths", "label": 0}, {"idx": "cosqa-train-11487", "doc": "python numpy array dtype compare", "code": "def contains_all(self, array):\n        \"\"\"Test if `array` is an array of real numbers.\"\"\"\n        dtype = getattr(array, 'dtype', None)\n        if dtype is None:\n            dtype = np.result_type(*array)\n        return is_real_dtype(dtype)", "code_tokens": "def contains_all ( self , array ) : dtype = getattr ( array , 'dtype' , None ) if dtype is None : dtype = np . result_type ( * array ) return is_real_dtype ( dtype )", "docstring_tokens": "Test if array is an array of real numbers .", "label": 1}, {"idx": "cosqa-train-11488", "doc": "python numpy array from dict", "code": "def setdict(self, D):\n        \"\"\"Set dictionary array.\"\"\"\n\n        self.D = np.asarray(D, dtype=self.dtype)", "code_tokens": "def setdict ( self , D ) : self . D = np . asarray ( D , dtype = self . dtype )", "docstring_tokens": "Set dictionary array .", "label": 1}, {"idx": "cosqa-train-11489", "doc": "how to do non linear curve fitting with new equation python", "code": "def apply_fit(xy,coeffs):\n    \"\"\" Apply the coefficients from a linear fit to\n        an array of x,y positions.\n\n        The coeffs come from the 'coeffs' member of the\n        'fit_arrays()' output.\n    \"\"\"\n    x_new = coeffs[0][2] + coeffs[0][0]*xy[:,0] + coeffs[0][1]*xy[:,1]\n    y_new = coeffs[1][2] + coeffs[1][0]*xy[:,0] + coeffs[1][1]*xy[:,1]\n\n    return x_new,y_new", "code_tokens": "def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "docstring_tokens": "Apply the coefficients from a linear fit to an array of x y positions .", "label": 1}, {"idx": "cosqa-train-11490", "doc": "python numpy array masking a region based on coordinates", "code": "def zoomed_scaled_array_around_mask(self, mask, buffer=1):\n        \"\"\"Extract the 2D region of an array corresponding to the rectangle encompassing all unmasked values.\n\n        This is used to extract and visualize only the region of an image that is used in an analysis.\n\n        Parameters\n        ----------\n        mask : mask.Mask\n            The mask around which the scaled array is extracted.\n        buffer : int\n            The buffer of pixels around the extraction.\n        \"\"\"\n        return self.new_with_array(array=array_util.extracted_array_2d_from_array_2d_and_coordinates(\n            array_2d=self,  y0=mask.zoom_region[0]-buffer, y1=mask.zoom_region[1]+buffer,\n            x0=mask.zoom_region[2]-buffer, x1=mask.zoom_region[3]+buffer))", "code_tokens": "def zoomed_scaled_array_around_mask ( self , mask , buffer = 1 ) : return self . new_with_array ( array = array_util . extracted_array_2d_from_array_2d_and_coordinates ( array_2d = self , y0 = mask . zoom_region [ 0 ] - buffer , y1 = mask . zoom_region [ 1 ] + buffer , x0 = mask . zoom_region [ 2 ] - buffer , x1 = mask . zoom_region [ 3 ] + buffer ) )", "docstring_tokens": "Extract the 2D region of an array corresponding to the rectangle encompassing all unmasked values .", "label": 1}, {"idx": "cosqa-train-11491", "doc": "how to download as a zip file data in python", "code": "def _download(url):\n    \"\"\"Downloads an URL and returns a file-like object open for reading,\n    compatible with zipping.ZipFile (it has a seek() method).\n    \"\"\"\n    fh = StringIO()\n\n    for line in get(url):\n        fh.write(line)\n\n    fh.seek(0)\n    return fh", "code_tokens": "def _download ( url ) : fh = StringIO ( ) for line in get ( url ) : fh . write ( line ) fh . seek ( 0 ) return fh", "docstring_tokens": "Downloads an URL and returns a file - like object open for reading compatible with zipping . ZipFile ( it has a seek () method ) .", "label": 0}, {"idx": "cosqa-train-11492", "doc": "python numpy array rounding numbers", "code": "def round_array(array_in):\n    \"\"\"\n    arr_out = round_array(array_in)\n\n    Rounds an array and recasts it to int. Also works on scalars.\n    \"\"\"\n    if isinstance(array_in, ndarray):\n        return np.round(array_in).astype(int)\n    else:\n        return int(np.round(array_in))", "code_tokens": "def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )", "docstring_tokens": "arr_out = round_array ( array_in )", "label": 1}, {"idx": "cosqa-train-11493", "doc": "how to draw horizontal line in python", "code": "def hline(self, x, y, width, color):\n        \"\"\"Draw a horizontal line up to a given length.\"\"\"\n        self.rect(x, y, width, 1, color, fill=True)", "code_tokens": "def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )", "docstring_tokens": "Draw a horizontal line up to a given length .", "label": 1}, {"idx": "cosqa-train-11494", "doc": "python numpy change dtype to str", "code": "def _numpy_char_to_bytes(arr):\n    \"\"\"Like netCDF4.chartostring, but faster and more flexible.\n    \"\"\"\n    # based on: http://stackoverflow.com/a/10984878/809705\n    arr = np.array(arr, copy=False, order='C')\n    dtype = 'S' + str(arr.shape[-1])\n    return arr.view(dtype).reshape(arr.shape[:-1])", "code_tokens": "def _numpy_char_to_bytes ( arr ) : # based on: http://stackoverflow.com/a/10984878/809705 arr = np . array ( arr , copy = False , order = 'C' ) dtype = 'S' + str ( arr . shape [ - 1 ] ) return arr . view ( dtype ) . reshape ( arr . shape [ : - 1 ] )", "docstring_tokens": "Like netCDF4 . chartostring but faster and more flexible .", "label": 1}, {"idx": "cosqa-train-11495", "doc": "how to dump yaml as dictionary python", "code": "def safe_dump(data, stream=None, **kwds):\n    \"\"\"implementation of safe dumper using Ordered Dict Yaml Dumper\"\"\"\n    return yaml.dump(data, stream=stream, Dumper=ODYD, **kwds)", "code_tokens": "def safe_dump ( data , stream = None , * * kwds ) : return yaml . dump ( data , stream = stream , Dumper = ODYD , * * kwds )", "docstring_tokens": "implementation of safe dumper using Ordered Dict Yaml Dumper", "label": 1}, {"idx": "cosqa-train-11496", "doc": "python numpy compare max function", "code": "def findMax(arr):\n    \"\"\"\n    in comparison to argrelmax() more simple and  reliable peak finder\n    \"\"\"\n    out = np.zeros(shape=arr.shape, dtype=bool)\n    _calcMax(arr, out)\n    return out", "code_tokens": "def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out", "docstring_tokens": "in comparison to argrelmax () more simple and reliable peak finder", "label": 1}, {"idx": "cosqa-train-11497", "doc": "python numpy get random state seed", "code": "def new_random_state(seed=None, fully_random=False):\n    \"\"\"\n    Returns a new random state.\n\n    Parameters\n    ----------\n    seed : None or int, optional\n        Optional seed value to use.\n        The same datatypes are allowed as for ``numpy.random.RandomState(seed)``.\n\n    fully_random : bool, optional\n        Whether to use numpy's random initialization for the\n        RandomState (used if set to True). If False, a seed is sampled from\n        the global random state, which is a bit faster and hence the default.\n\n    Returns\n    -------\n    numpy.random.RandomState\n        The new random state.\n\n    \"\"\"\n    if seed is None:\n        if not fully_random:\n            # sample manually a seed instead of just RandomState(),\n            # because the latter one\n            # is way slower.\n            seed = CURRENT_RANDOM_STATE.randint(SEED_MIN_VALUE, SEED_MAX_VALUE, 1)[0]\n    return np.random.RandomState(seed)", "code_tokens": "def new_random_state ( seed = None , fully_random = False ) : if seed is None : if not fully_random : # sample manually a seed instead of just RandomState(), # because the latter one # is way slower. seed = CURRENT_RANDOM_STATE . randint ( SEED_MIN_VALUE , SEED_MAX_VALUE , 1 ) [ 0 ] return np . random . RandomState ( seed )", "docstring_tokens": "Returns a new random state .", "label": 1}, {"idx": "cosqa-train-11498", "doc": "how to encode the utf code in python", "code": "def to_unicode_repr( _letter ):\n    \"\"\" helpful in situations where browser/app may recognize Unicode encoding\n        in the \\u0b8e type syntax but not actual unicode glyph/code-point\"\"\"\n    # Python 2-3 compatible\n    return u\"u'\"+ u\"\".join( [ u\"\\\\u%04x\"%ord(l) for l in _letter ] ) + u\"'\"", "code_tokens": "def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u\"u'\" + u\"\" . join ( [ u\"\\\\u%04x\" % ord ( l ) for l in _letter ] ) + u\"'\"", "docstring_tokens": "helpful in situations where browser / app may recognize Unicode encoding in the \\ u0b8e type syntax but not actual unicode glyph / code - point", "label": 1}, {"idx": "cosqa-train-11499", "doc": "python numpy index of bool", "code": "def maskIndex(self):\n        \"\"\" Returns a boolean index with True if the value is masked.\n\n            Always has the same shape as the maksedArray.data, event if the mask is a single boolan.\n        \"\"\"\n        if isinstance(self.mask, bool):\n            return np.full(self.data.shape, self.mask, dtype=np.bool)\n        else:\n            return self.mask", "code_tokens": "def maskIndex ( self ) : if isinstance ( self . mask , bool ) : return np . full ( self . data . shape , self . mask , dtype = np . bool ) else : return self . mask", "docstring_tokens": "Returns a boolean index with True if the value is masked .", "label": 1}, {"idx": "cosqa-train-11500", "doc": "how to erase a previous line in python", "code": "def erase_lines(n=1):\n    \"\"\" Erases n lines from the screen and moves the cursor up to follow\n    \"\"\"\n    for _ in range(n):\n        print(codes.cursor[\"up\"], end=\"\")\n        print(codes.cursor[\"eol\"], end=\"\")", "code_tokens": "def erase_lines ( n = 1 ) : for _ in range ( n ) : print ( codes . cursor [ \"up\" ] , end = \"\" ) print ( codes . cursor [ \"eol\" ] , end = \"\" )", "docstring_tokens": "Erases n lines from the screen and moves the cursor up to follow", "label": 1}, {"idx": "cosqa-train-11501", "doc": "python numpy inverse of the matrix", "code": "def MatrixInverse(a, adj):\n    \"\"\"\n    Matrix inversion op.\n    \"\"\"\n    return np.linalg.inv(a if not adj else _adjoint(a)),", "code_tokens": "def MatrixInverse ( a , adj ) : return np . linalg . inv ( a if not adj else _adjoint ( a ) ) ,", "docstring_tokens": "Matrix inversion op .", "label": 1}, {"idx": "cosqa-train-11502", "doc": "how to evaluate the accuracy of a model; python", "code": "def cat_acc(y_true, y_pred):\n    \"\"\"Categorical accuracy\n    \"\"\"\n    return np.mean(y_true.argmax(axis=1) == y_pred.argmax(axis=1))", "code_tokens": "def cat_acc ( y_true , y_pred ) : return np . mean ( y_true . argmax ( axis = 1 ) == y_pred . argmax ( axis = 1 ) )", "docstring_tokens": "Categorical accuracy", "label": 1}, {"idx": "cosqa-train-11503", "doc": "python numpy masked arrays", "code": "def asMaskedArray(self):\n        \"\"\" Creates converts to a masked array\n        \"\"\"\n        return ma.masked_array(data=self.data, mask=self.mask, fill_value=self.fill_value)", "code_tokens": "def asMaskedArray ( self ) : return ma . masked_array ( data = self . data , mask = self . mask , fill_value = self . fill_value )", "docstring_tokens": "Creates converts to a masked array", "label": 1}, {"idx": "cosqa-train-11504", "doc": "how to exclude empty strings from a collection in python", "code": "def _strip_empty_keys(self, params):\n        \"\"\"Added because the Dropbox OAuth2 flow doesn't\n        work when scope is passed in, which is empty.\n        \"\"\"\n        keys = [k for k, v in params.items() if v == '']\n        for key in keys:\n            del params[key]", "code_tokens": "def _strip_empty_keys ( self , params ) : keys = [ k for k , v in params . items ( ) if v == '' ] for key in keys : del params [ key ]", "docstring_tokens": "Added because the Dropbox OAuth2 flow doesn t work when scope is passed in which is empty .", "label": 1}, {"idx": "cosqa-train-11505", "doc": "python numpy masked vailding", "code": "def asMaskedArray(self):\n        \"\"\" Creates converts to a masked array\n        \"\"\"\n        return ma.masked_array(data=self.data, mask=self.mask, fill_value=self.fill_value)", "code_tokens": "def asMaskedArray ( self ) : return ma . masked_array ( data = self . data , mask = self . mask , fill_value = self . fill_value )", "docstring_tokens": "Creates converts to a masked array", "label": 1}, {"idx": "cosqa-train-11506", "doc": "how to execute a python script with a button click in jquery", "code": "def click_by_selector(self, selector):\n    \"\"\"Click the element matching the CSS selector.\"\"\"\n    # No need for separate button press step with selector style.\n    elem = find_element_by_jquery(world.browser, selector)\n    elem.click()", "code_tokens": "def click_by_selector ( self , selector ) : # No need for separate button press step with selector style. elem = find_element_by_jquery ( world . browser , selector ) elem . click ( )", "docstring_tokens": "Click the element matching the CSS selector .", "label": 1}, {"idx": "cosqa-train-11507", "doc": "python numpy nd convolution", "code": "def conv1x1(in_planes, out_planes, stride=1):\n    \"\"\"1x1 convolution\"\"\"\n    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)", "code_tokens": "def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )", "docstring_tokens": "1x1 convolution", "label": 0}, {"idx": "cosqa-train-11508", "doc": "how to execute python functios in django templates", "code": "def managepy(cmd, extra=None):\n    \"\"\"Run manage.py using this component's specific Django settings\"\"\"\n\n    extra = extra.split() if extra else []\n    run_django_cli(['invoke', cmd] + extra)", "code_tokens": "def managepy ( cmd , extra = None ) : extra = extra . split ( ) if extra else [ ] run_django_cli ( [ 'invoke' , cmd ] + extra )", "docstring_tokens": "Run manage . py using this component s specific Django settings", "label": 1}, {"idx": "cosqa-train-11509", "doc": "python numpy read binary data file", "code": "def read_numpy(fh, byteorder, dtype, count, offsetsize):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    dtype = 'b' if dtype[-1] == 's' else byteorder+dtype[-1]\n    return fh.read_array(dtype, count)", "code_tokens": "def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 1}, {"idx": "cosqa-train-11510", "doc": "how to exit from a code in python script", "code": "def fail(message=None, exit_status=None):\n    \"\"\"Prints the specified message and exits the program with the specified\n    exit status.\n\n    \"\"\"\n    print('Error:', message, file=sys.stderr)\n    sys.exit(exit_status or 1)", "code_tokens": "def fail ( message = None , exit_status = None ) : print ( 'Error:' , message , file = sys . stderr ) sys . exit ( exit_status or 1 )", "docstring_tokens": "Prints the specified message and exits the program with the specified exit status .", "label": 1}, {"idx": "cosqa-train-11511", "doc": "python numpy read data from binary file", "code": "def read_numpy(fh, byteorder, dtype, count, offsetsize):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    dtype = 'b' if dtype[-1] == 's' else byteorder+dtype[-1]\n    return fh.read_array(dtype, count)", "code_tokens": "def read_numpy ( fh , byteorder , dtype , count , offsetsize ) : dtype = 'b' if dtype [ - 1 ] == 's' else byteorder + dtype [ - 1 ] return fh . read_array ( dtype , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 1}, {"idx": "cosqa-train-11512", "doc": "how to fetch column names from postgresql python", "code": "def get_table_columns(dbconn, tablename):\n    \"\"\"\n    Return a list of tuples specifying the column name and type\n    \"\"\"\n    cur = dbconn.cursor()\n    cur.execute(\"PRAGMA table_info('%s');\" % tablename)\n    info = cur.fetchall()\n    cols = [(i[1], i[2]) for i in info]\n    return cols", "code_tokens": "def get_table_columns ( dbconn , tablename ) : cur = dbconn . cursor ( ) cur . execute ( \"PRAGMA table_info('%s');\" % tablename ) info = cur . fetchall ( ) cols = [ ( i [ 1 ] , i [ 2 ] ) for i in info ] return cols", "docstring_tokens": "Return a list of tuples specifying the column name and type", "label": 1}, {"idx": "cosqa-train-11513", "doc": "python numpy sum along axis", "code": "def Sum(a, axis, keep_dims):\n    \"\"\"\n    Sum reduction op.\n    \"\"\"\n    return np.sum(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis),\n                  keepdims=keep_dims),", "code_tokens": "def Sum ( a , axis , keep_dims ) : return np . sum ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "docstring_tokens": "Sum reduction op .", "label": 1}, {"idx": "cosqa-train-11514", "doc": "how to fetch prior month in date in python", "code": "def get_previous_month(self):\n        \"\"\"Returns date range for the previous full month.\"\"\"\n        end = utils.get_month_start() - relativedelta(days=1)\n        end = utils.to_datetime(end)\n        start = utils.get_month_start(end)\n        return start, end", "code_tokens": "def get_previous_month ( self ) : end = utils . get_month_start ( ) - relativedelta ( days = 1 ) end = utils . to_datetime ( end ) start = utils . get_month_start ( end ) return start , end", "docstring_tokens": "Returns date range for the previous full month .", "label": 1}, {"idx": "cosqa-train-11515", "doc": "python object has not attributre", "code": "def set_attrs(self):\n        \"\"\" set our object attributes \"\"\"\n        self.attrs.encoding = self.encoding\n        self.attrs.errors = self.errors", "code_tokens": "def set_attrs ( self ) : self . attrs . encoding = self . encoding self . attrs . errors = self . errors", "docstring_tokens": "set our object attributes", "label": 0}, {"idx": "cosqa-train-11516", "doc": "how to figure out min and max in python", "code": "def values(self):\n        \"\"\"Gets the user enter max and min values of where the \n        raster points should appear on the y-axis\n\n        :returns: (float, float) -- (min, max) y-values to bound the raster plot by\n        \"\"\"\n        lower = float(self.lowerSpnbx.value())\n        upper = float(self.upperSpnbx.value())\n        return (lower, upper)", "code_tokens": "def values ( self ) : lower = float ( self . lowerSpnbx . value ( ) ) upper = float ( self . upperSpnbx . value ( ) ) return ( lower , upper )", "docstring_tokens": "Gets the user enter max and min values of where the raster points should appear on the y - axis", "label": 1}, {"idx": "cosqa-train-11517", "doc": "python object of type bytes is not json serializable", "code": "def is_serializable(obj):\n    \"\"\"Return `True` if the given object conforms to the Serializable protocol.\n\n    :rtype: bool\n    \"\"\"\n    if inspect.isclass(obj):\n      return Serializable.is_serializable_type(obj)\n    return isinstance(obj, Serializable) or hasattr(obj, '_asdict')", "code_tokens": "def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )", "docstring_tokens": "Return True if the given object conforms to the Serializable protocol .", "label": 1}, {"idx": "cosqa-train-11518", "doc": "how to filter an image using a mask in python", "code": "def filter_greys_using_image(image, target):\n    \"\"\"Filter out any values in target not in image\n\n    :param image: image containing values to appear in filtered image\n    :param target: the image to filter\n    :rtype: 2d  :class:`numpy.ndarray` containing only value in image\n        and with the same dimensions as target\n\n    \"\"\"\n    maskbase = numpy.array(range(256), dtype=numpy.uint8)\n    mask = numpy.where(numpy.in1d(maskbase, numpy.unique(image)), maskbase, 0)\n    return mask[target]", "code_tokens": "def filter_greys_using_image ( image , target ) : maskbase = numpy . array ( range ( 256 ) , dtype = numpy . uint8 ) mask = numpy . where ( numpy . in1d ( maskbase , numpy . unique ( image ) ) , maskbase , 0 ) return mask [ target ]", "docstring_tokens": "Filter out any values in target not in image : param image : image containing values to appear in filtered image : param target : the image to filter : rtype : 2d : class : numpy . ndarray containing only value in image and with the same dimensions as target", "label": 1}, {"idx": "cosqa-train-11519", "doc": "python on windws check file permissions", "code": "def is_writable_by_others(filename):\n    \"\"\"Check if file or directory is world writable.\"\"\"\n    mode = os.stat(filename)[stat.ST_MODE]\n    return mode & stat.S_IWOTH", "code_tokens": "def is_writable_by_others ( filename ) : mode = os . stat ( filename ) [ stat . ST_MODE ] return mode & stat . S_IWOTH", "docstring_tokens": "Check if file or directory is world writable .", "label": 1}, {"idx": "cosqa-train-11520", "doc": "how to flatten 2d arrays python numpy", "code": "def flatten_array(grid):\n    \"\"\"\n    Takes a multi-dimensional array and returns a 1 dimensional array with the\n    same contents.\n    \"\"\"\n    grid = [grid[i][j] for i in range(len(grid)) for j in range(len(grid[i]))]\n    while type(grid[0]) is list:\n        grid = flatten_array(grid)\n    return grid", "code_tokens": "def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid", "docstring_tokens": "Takes a multi - dimensional array and returns a 1 dimensional array with the same contents .", "label": 1}, {"idx": "cosqa-train-11521", "doc": "python only allow kwargs", "code": "def update(self, **kwargs):\n        \"\"\"Customize the lazy field\"\"\"\n        assert not self.called\n        self.kw.update(kwargs)\n        return self", "code_tokens": "def update ( self , * * kwargs ) : assert not self . called self . kw . update ( kwargs ) return self", "docstring_tokens": "Customize the lazy field", "label": 0}, {"idx": "cosqa-train-11522", "doc": "how to formai in italic on python", "code": "def stylize(text, styles, reset=True):\n    \"\"\"conveniently styles your text as and resets ANSI codes at its end.\"\"\"\n    terminator = attr(\"reset\") if reset else \"\"\n    return \"{}{}{}\".format(\"\".join(styles), text, terminator)", "code_tokens": "def stylize ( text , styles , reset = True ) : terminator = attr ( \"reset\" ) if reset else \"\" return \"{}{}{}\" . format ( \"\" . join ( styles ) , text , terminator )", "docstring_tokens": "conveniently styles your text as and resets ANSI codes at its end .", "label": 1}, {"idx": "cosqa-train-11523", "doc": "python open an excel and save it as something else", "code": "def save_excel(self, fd):\n        \"\"\" Saves the case as an Excel spreadsheet.\n        \"\"\"\n        from pylon.io.excel import ExcelWriter\n        ExcelWriter(self).write(fd)", "code_tokens": "def save_excel ( self , fd ) : from pylon . io . excel import ExcelWriter ExcelWriter ( self ) . write ( fd )", "docstring_tokens": "Saves the case as an Excel spreadsheet .", "label": 1}, {"idx": "cosqa-train-11524", "doc": "how to garbage collect python", "code": "def cleanup_storage(*args):\n    \"\"\"Clean up processes after SIGTERM or SIGINT is received.\"\"\"\n    ShardedClusters().cleanup()\n    ReplicaSets().cleanup()\n    Servers().cleanup()\n    sys.exit(0)", "code_tokens": "def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )", "docstring_tokens": "Clean up processes after SIGTERM or SIGINT is received .", "label": 1}, {"idx": "cosqa-train-11525", "doc": "python open bytesio for reading", "code": "def read_string(buff, byteorder='big'):\n    \"\"\"Read a string from a file-like object.\"\"\"\n    length = read_numeric(USHORT, buff, byteorder)\n    return buff.read(length).decode('utf-8')", "code_tokens": "def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )", "docstring_tokens": "Read a string from a file - like object .", "label": 1}, {"idx": "cosqa-train-11526", "doc": "how to generate a password using python", "code": "def GeneratePassphrase(length=20):\n  \"\"\"Create a 20 char passphrase with easily typeable chars.\"\"\"\n  valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  valid_chars += \"0123456789 ,-_&$#\"\n  return \"\".join(random.choice(valid_chars) for i in range(length))", "code_tokens": "def GeneratePassphrase ( length = 20 ) : valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" valid_chars += \"0123456789 ,-_&$#\" return \"\" . join ( random . choice ( valid_chars ) for i in range ( length ) )", "docstring_tokens": "Create a 20 char passphrase with easily typeable chars .", "label": 1}, {"idx": "cosqa-train-11527", "doc": "python open file should i close it", "code": "def file_read(filename):\n    \"\"\"Read a file and close it.  Returns the file source.\"\"\"\n    fobj = open(filename,'r');\n    source = fobj.read();\n    fobj.close()\n    return source", "code_tokens": "def file_read ( filename ) : fobj = open ( filename , 'r' ) source = fobj . read ( ) fobj . close ( ) return source", "docstring_tokens": "Read a file and close it . Returns the file source .", "label": 1}, {"idx": "cosqa-train-11528", "doc": "python open file to read til end of file", "code": "def _readuntil(f, end=_TYPE_END):\n\t\"\"\"Helper function to read bytes until a certain end byte is hit\"\"\"\n\tbuf = bytearray()\n\tbyte = f.read(1)\n\twhile byte != end:\n\t\tif byte == b'':\n\t\t\traise ValueError('File ended unexpectedly. Expected end byte {}.'.format(end))\n\t\tbuf += byte\n\t\tbyte = f.read(1)\n\treturn buf", "code_tokens": "def _readuntil ( f , end = _TYPE_END ) : buf = bytearray ( ) byte = f . read ( 1 ) while byte != end : if byte == b'' : raise ValueError ( 'File ended unexpectedly. Expected end byte {}.' . format ( end ) ) buf += byte byte = f . read ( 1 ) return buf", "docstring_tokens": "Helper function to read bytes until a certain end byte is hit", "label": 1}, {"idx": "cosqa-train-11529", "doc": "how to generate covariance matrix python", "code": "def _covariance_matrix(self, type='noise'):\n        \"\"\"\n        Constructs the covariance matrix from PCA\n        residuals\n        \"\"\"\n        if type == 'sampling':\n            return self.sigma**2/(self.n-1)\n        elif type == 'noise':\n            return 4*self.sigma*N.var(self.rotated(), axis=0)", "code_tokens": "def _covariance_matrix ( self , type = 'noise' ) : if type == 'sampling' : return self . sigma ** 2 / ( self . n - 1 ) elif type == 'noise' : return 4 * self . sigma * N . var ( self . rotated ( ) , axis = 0 )", "docstring_tokens": "Constructs the covariance matrix from PCA residuals", "label": 1}, {"idx": "cosqa-train-11530", "doc": "python open file with unknown encoding", "code": "def open_with_encoding(filename, encoding, mode='r'):\n    \"\"\"Return opened file with a specific encoding.\"\"\"\n    return io.open(filename, mode=mode, encoding=encoding,\n                   newline='')", "code_tokens": "def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )", "docstring_tokens": "Return opened file with a specific encoding .", "label": 1}, {"idx": "cosqa-train-11531", "doc": "how to get a frequency of a word in python", "code": "def wordfreq(text, is_filename=False):\n    \"\"\"Return a dictionary of words and word counts in a string.\"\"\"\n    if is_filename:\n        with open(text) as f:\n            text = f.read()\n    freqs = {}\n    for word in text.split():\n        lword = word.lower()\n        freqs[lword] = freqs.get(lword, 0) + 1\n    return freqs", "code_tokens": "def wordfreq ( text , is_filename = False ) : if is_filename : with open ( text ) as f : text = f . read ( ) freqs = { } for word in text . split ( ) : lword = word . lower ( ) freqs [ lword ] = freqs . get ( lword , 0 ) + 1 return freqs", "docstring_tokens": "Return a dictionary of words and word counts in a string .", "label": 1}, {"idx": "cosqa-train-11532", "doc": "python open json encoding", "code": "def load_jsonf(fpath, encoding):\n    \"\"\"\n    :param unicode fpath:\n    :param unicode encoding:\n    :rtype: dict | list\n    \"\"\"\n    with codecs.open(fpath, encoding=encoding) as f:\n        return json.load(f)", "code_tokens": "def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )", "docstring_tokens": ": param unicode fpath : : param unicode encoding : : rtype : dict | list", "label": 1}, {"idx": "cosqa-train-11533", "doc": "how to get a list of all globle varibles in python", "code": "def get_all_names(self):\n        \"\"\"Return the list of all cached global names\"\"\"\n        result = set()\n        for module in self.names:\n            result.update(set(self.names[module]))\n        return result", "code_tokens": "def get_all_names ( self ) : result = set ( ) for module in self . names : result . update ( set ( self . names [ module ] ) ) return result", "docstring_tokens": "Return the list of all cached global names", "label": 1}, {"idx": "cosqa-train-11534", "doc": "python opencv conver to gray", "code": "def gray2bgr(img):\n    \"\"\"Convert a grayscale image to BGR image.\n\n    Args:\n        img (ndarray or str): The input image.\n\n    Returns:\n        ndarray: The converted BGR image.\n    \"\"\"\n    img = img[..., None] if img.ndim == 2 else img\n    out_img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n    return out_img", "code_tokens": "def gray2bgr ( img ) : img = img [ ... , None ] if img . ndim == 2 else img out_img = cv2 . cvtColor ( img , cv2 . COLOR_GRAY2BGR ) return out_img", "docstring_tokens": "Convert a grayscale image to BGR image .", "label": 1}, {"idx": "cosqa-train-11535", "doc": "how to get a list of constant in python", "code": "def _get_all_constants():\n    \"\"\"\n    Get list of all uppercase, non-private globals (doesn't start with ``_``).\n\n    Returns:\n        list: Uppercase names defined in `globals()` (variables from this \\\n              module).\n    \"\"\"\n    return [\n        key for key in globals().keys()\n        if all([\n            not key.startswith(\"_\"),          # publicly accesible\n            key.upper() == key,               # uppercase\n            type(globals()[key]) in _ALLOWED  # and with type from _ALLOWED\n        ])\n    ]", "code_tokens": "def _get_all_constants ( ) : return [ key for key in globals ( ) . keys ( ) if all ( [ not key . startswith ( \"_\" ) , # publicly accesible key . upper ( ) == key , # uppercase type ( globals ( ) [ key ] ) in _ALLOWED # and with type from _ALLOWED ] ) ]", "docstring_tokens": "Get list of all uppercase non - private globals ( doesn t start with _ ) .", "label": 1}, {"idx": "cosqa-train-11536", "doc": "python openpyxl how to get cell background color", "code": "def _get_background_color(self):\n        \"\"\"Returns background color rgb tuple of right line\"\"\"\n\n        color = self.cell_attributes[self.key][\"bgcolor\"]\n        return tuple(c / 255.0 for c in color_pack2rgb(color))", "code_tokens": "def _get_background_color ( self ) : color = self . cell_attributes [ self . key ] [ \"bgcolor\" ] return tuple ( c / 255.0 for c in color_pack2rgb ( color ) )", "docstring_tokens": "Returns background color rgb tuple of right line", "label": 1}, {"idx": "cosqa-train-11537", "doc": "how to get a list of lower case letters in python", "code": "def camelcase2list(s, lower=False):\n    \"\"\"Converts a camelcase string to a list.\"\"\"\n    s = re.findall(r'([A-Z][a-z0-9]+)', s)\n    return [w.lower() for w in s] if lower else s", "code_tokens": "def camelcase2list ( s , lower = False ) : s = re . findall ( r'([A-Z][a-z0-9]+)' , s ) return [ w . lower ( ) for w in s ] if lower else s", "docstring_tokens": "Converts a camelcase string to a list .", "label": 1}, {"idx": "cosqa-train-11538", "doc": "python opoengl 3d texture", "code": "def _genTex2D(self):\n        \"\"\"Generate an empty texture in OpenGL\"\"\"\n        for face in range(6):\n            gl.glTexImage2D(self.target0 + face, 0, self.internal_fmt, self.width, self.height, 0,\n                            self.pixel_fmt, gl.GL_UNSIGNED_BYTE, 0)", "code_tokens": "def _genTex2D ( self ) : for face in range ( 6 ) : gl . glTexImage2D ( self . target0 + face , 0 , self . internal_fmt , self . width , self . height , 0 , self . pixel_fmt , gl . GL_UNSIGNED_BYTE , 0 )", "docstring_tokens": "Generate an empty texture in OpenGL", "label": 0}, {"idx": "cosqa-train-11539", "doc": "python oracle all the fields of a table", "code": "def dictfetchall(cursor):\n    \"\"\"Returns all rows from a cursor as a dict (rather than a headerless table)\n\n    From Django Documentation: https://docs.djangoproject.com/en/dev/topics/db/sql/\n    \"\"\"\n    desc = cursor.description\n    return [dict(zip([col[0] for col in desc], row)) for row in cursor.fetchall()]", "code_tokens": "def dictfetchall ( cursor ) : desc = cursor . description return [ dict ( zip ( [ col [ 0 ] for col in desc ] , row ) ) for row in cursor . fetchall ( ) ]", "docstring_tokens": "Returns all rows from a cursor as a dict ( rather than a headerless table )", "label": 1}, {"idx": "cosqa-train-11540", "doc": "how to get a minimum in python using if and else", "code": "def min_or_none(val1, val2):\n    \"\"\"Returns min(val1, val2) returning None only if both values are None\"\"\"\n    return min(val1, val2, key=lambda x: sys.maxint if x is None else x)", "code_tokens": "def min_or_none ( val1 , val2 ) : return min ( val1 , val2 , key = lambda x : sys . maxint if x is None else x )", "docstring_tokens": "Returns min ( val1 val2 ) returning None only if both values are None", "label": 1}, {"idx": "cosqa-train-11541", "doc": "python order a list given a list of new indices", "code": "def _index_ordering(redshift_list):\n        \"\"\"\n\n        :param redshift_list: list of redshifts\n        :return: indexes in acending order to be evaluated (from z=0 to z=z_source)\n        \"\"\"\n        redshift_list = np.array(redshift_list)\n        sort_index = np.argsort(redshift_list)\n        return sort_index", "code_tokens": "def _index_ordering ( redshift_list ) : redshift_list = np . array ( redshift_list ) sort_index = np . argsort ( redshift_list ) return sort_index", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-11542", "doc": "how to get a previous business date in python", "code": "def get_previous(self):\n        \"\"\"Get the billing cycle prior to this one. May return None\"\"\"\n        return BillingCycle.objects.filter(date_range__lt=self.date_range).order_by('date_range').last()", "code_tokens": "def get_previous ( self ) : return BillingCycle . objects . filter ( date_range__lt = self . date_range ) . order_by ( 'date_range' ) . last ( )", "docstring_tokens": "Get the billing cycle prior to this one . May return None", "label": 1}, {"idx": "cosqa-train-11543", "doc": "python output attributes of object", "code": "def _repr(obj):\n    \"\"\"Show the received object as precise as possible.\"\"\"\n    vals = \", \".join(\"{}={!r}\".format(\n        name, getattr(obj, name)) for name in obj._attribs)\n    if vals:\n        t = \"{}(name={}, {})\".format(obj.__class__.__name__, obj.name, vals)\n    else:\n        t = \"{}(name={})\".format(obj.__class__.__name__, obj.name)\n    return t", "code_tokens": "def _repr ( obj ) : vals = \", \" . join ( \"{}={!r}\" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = \"{}(name={}, {})\" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = \"{}(name={})\" . format ( obj . __class__ . __name__ , obj . name ) return t", "docstring_tokens": "Show the received object as precise as possible .", "label": 1}, {"idx": "cosqa-train-11544", "doc": "how to get active window detail in python", "code": "def get_active_window(self):\n        \"\"\"\n        The current active :class:`.Window`.\n        \"\"\"\n        app = get_app()\n\n        try:\n            return self._active_window_for_cli[app]\n        except KeyError:\n            self._active_window_for_cli[app] = self._last_active_window or self.windows[0]\n            return self.windows[0]", "code_tokens": "def get_active_window ( self ) : app = get_app ( ) try : return self . _active_window_for_cli [ app ] except KeyError : self . _active_window_for_cli [ app ] = self . _last_active_window or self . windows [ 0 ] return self . windows [ 0 ]", "docstring_tokens": "The current active : class : . Window .", "label": 1}, {"idx": "cosqa-train-11545", "doc": "python output to asi file", "code": "def write_config(self, outfile):\n        \"\"\"Write the configuration dictionary to an output file.\"\"\"\n        utils.write_yaml(self.config, outfile, default_flow_style=False)", "code_tokens": "def write_config ( self , outfile ) : utils . write_yaml ( self . config , outfile , default_flow_style = False )", "docstring_tokens": "Write the configuration dictionary to an output file .", "label": 1}, {"idx": "cosqa-train-11546", "doc": "how to get all files in a directory in python", "code": "def list_files(directory):\n    \"\"\"Returns all files in a given directory\n    \"\"\"\n    return [f for f in pathlib.Path(directory).iterdir() if f.is_file() and not f.name.startswith('.')]", "code_tokens": "def list_files ( directory ) : return [ f for f in pathlib . Path ( directory ) . iterdir ( ) if f . is_file ( ) and not f . name . startswith ( '.' ) ]", "docstring_tokens": "Returns all files in a given directory", "label": 1}, {"idx": "cosqa-train-11547", "doc": "python panda lambda x multiple conditions", "code": "def All(sequence):\n  \"\"\"\n  :param sequence: Any sequence whose elements can be evaluated as booleans.\n  :returns: true if all elements of the sequence satisfy True and x.\n  \"\"\"\n  return bool(reduce(lambda x, y: x and y, sequence, True))", "code_tokens": "def All ( sequence ) : return bool ( reduce ( lambda x , y : x and y , sequence , True ) )", "docstring_tokens": ": param sequence : Any sequence whose elements can be evaluated as booleans . : returns : true if all elements of the sequence satisfy True and x .", "label": 1}, {"idx": "cosqa-train-11548", "doc": "how to get complete sub set in python function", "code": "def trivial_partition(set_):\n    \"\"\"Returns a parition of given set into 1-element subsets.\n\n    :return: Trivial partition of given set, i.e. iterable containing disjoint\n             1-element sets, each consisting of a single element\n             from given set\n    \"\"\"\n    ensure_countable(set_)\n\n    result = ((x,) for x in set_)\n    return _harmonize_subset_types(set_, result)", "code_tokens": "def trivial_partition ( set_ ) : ensure_countable ( set_ ) result = ( ( x , ) for x in set_ ) return _harmonize_subset_types ( set_ , result )", "docstring_tokens": "Returns a parition of given set into 1 - element subsets .", "label": 0}, {"idx": "cosqa-train-11549", "doc": "python paramiko check stdout", "code": "def report_stdout(host, stdout):\n    \"\"\"Take a stdout and print it's lines to output if lines are present.\n\n    :param host: the host where the process is running\n    :type host: str\n    :param stdout: the std out of that process\n    :type stdout: paramiko.channel.Channel\n    \"\"\"\n    lines = stdout.readlines()\n    if lines:\n        print(\"STDOUT from {host}:\".format(host=host))\n        for line in lines:\n            print(line.rstrip(), file=sys.stdout)", "code_tokens": "def report_stdout ( host , stdout ) : lines = stdout . readlines ( ) if lines : print ( \"STDOUT from {host}:\" . format ( host = host ) ) for line in lines : print ( line . rstrip ( ) , file = sys . stdout )", "docstring_tokens": "Take a stdout and print it s lines to output if lines are present .", "label": 1}, {"idx": "cosqa-train-11550", "doc": "how to get distinct list in python", "code": "def distinct(xs):\n    \"\"\"Get the list of distinct values with preserving order.\"\"\"\n    # don't use collections.OrderedDict because we do support Python 2.6\n    seen = set()\n    return [x for x in xs if x not in seen and not seen.add(x)]", "code_tokens": "def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]", "docstring_tokens": "Get the list of distinct values with preserving order .", "label": 1}, {"idx": "cosqa-train-11551", "doc": "python paramiko ssh read stdout", "code": "def report_stdout(host, stdout):\n    \"\"\"Take a stdout and print it's lines to output if lines are present.\n\n    :param host: the host where the process is running\n    :type host: str\n    :param stdout: the std out of that process\n    :type stdout: paramiko.channel.Channel\n    \"\"\"\n    lines = stdout.readlines()\n    if lines:\n        print(\"STDOUT from {host}:\".format(host=host))\n        for line in lines:\n            print(line.rstrip(), file=sys.stdout)", "code_tokens": "def report_stdout ( host , stdout ) : lines = stdout . readlines ( ) if lines : print ( \"STDOUT from {host}:\" . format ( host = host ) ) for line in lines : print ( line . rstrip ( ) , file = sys . stdout )", "docstring_tokens": "Take a stdout and print it s lines to output if lines are present .", "label": 1}, {"idx": "cosqa-train-11552", "doc": "how to get distinct values from a list in python", "code": "def distinct(xs):\n    \"\"\"Get the list of distinct values with preserving order.\"\"\"\n    # don't use collections.OrderedDict because we do support Python 2.6\n    seen = set()\n    return [x for x in xs if x not in seen and not seen.add(x)]", "code_tokens": "def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]", "docstring_tokens": "Get the list of distinct values with preserving order .", "label": 0}, {"idx": "cosqa-train-11553", "doc": "python parentheses matching with regex", "code": "def match_paren(self, tokens, item):\n        \"\"\"Matches a paren.\"\"\"\n        match, = tokens\n        return self.match(match, item)", "code_tokens": "def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "docstring_tokens": "Matches a paren .", "label": 0}, {"idx": "cosqa-train-11554", "doc": "how to get dpi of a jpeg image python", "code": "def horz_dpi(self):\n        \"\"\"\n        Integer dots per inch for the width of this image. Defaults to 72\n        when not present in the file, as is often the case.\n        \"\"\"\n        pHYs = self._chunks.pHYs\n        if pHYs is None:\n            return 72\n        return self._dpi(pHYs.units_specifier, pHYs.horz_px_per_unit)", "code_tokens": "def horz_dpi ( self ) : pHYs = self . _chunks . pHYs if pHYs is None : return 72 return self . _dpi ( pHYs . units_specifier , pHYs . horz_px_per_unit )", "docstring_tokens": "Integer dots per inch for the width of this image . Defaults to 72 when not present in the file as is often the case .", "label": 1}, {"idx": "cosqa-train-11555", "doc": "how to get impala/hive table metadata by python", "code": "def inventory(self, source_id, fetch=False, fmt='table'):\n        \"\"\"\n        Prints a summary of all objects in the database. Input string or list of strings in **ID** or **unum**\n        for specific objects.\n\n        Parameters\n        ----------\n        source_id: int\n            The id from the SOURCES table whose data across all tables is to be printed.\n        fetch: bool\n            Return the results.\n        fmt: str\n            Returns the data as a dictionary, array, or astropy.table given 'dict', 'array', or 'table'\n\n        Returns\n        -------\n        data_tables: dict\n            Returns a dictionary of astropy tables with the table name as the keys.\n\n        \"\"\"\n        data_tables = {}\n\n        t = self.query(\"SELECT * FROM sqlite_master WHERE type='table'\", fmt='table')\n        all_tables = t['name'].tolist()\n        for table in ['sources'] + [t for t in all_tables if\n                                    t not in ['sources', 'sqlite_sequence']]:\n\n            try:\n\n                # Get the columns, pull out redundant ones, and query the table for this source's data\n                t = self.query(\"PRAGMA table_info({})\".format(table), fmt='table')\n                columns = np.array(t['name'])\n                types = np.array(t['type'])\n\n                if table == 'sources' or 'source_id' in columns:\n\n                    # If printing, only get simple data types and exclude redundant 'source_id' for nicer printing\n                    if not fetch:\n                        columns = columns[\n                            ((types == 'REAL') | (types == 'INTEGER') | (types == 'TEXT')) & (columns != 'source_id')]\n\n                    # Query the table\n                    try:\n                        id = 'id' if table.lower() == 'sources' else 'source_id'\n                        data = self.query(\n                            \"SELECT {} FROM {} WHERE {}={}\".format(','.join(columns), table, id, source_id),\n                            fmt='table')\n\n                        if not data and table.lower() == 'sources':\n                            print(\n                            'No source with id {}. Try db.search() to search the database for a source_id.'.format(\n                                source_id))\n\n                    except:\n                        data = None\n\n                    # If there's data for this table, save it\n                    if data:\n                        if fetch:\n                            data_tables[table] = self.query(\n                                \"SELECT {} FROM {} WHERE {}={}\".format(','.join(columns), table, id, source_id), \\\n                                fetch=True, fmt=fmt)\n                        else:\n                            data = data[[c.lower() for c in columns]]\n                            pprint(data, title=table.upper())\n\n                else:\n                    pass\n\n            except:\n                print('Could not retrieve data from {} table.'.format(table.upper()))\n\n        if fetch: return data_tables", "code_tokens": "def inventory ( self , source_id , fetch = False , fmt = 'table' ) : data_tables = { } t = self . query ( \"SELECT * FROM sqlite_master WHERE type='table'\" , fmt = 'table' ) all_tables = t [ 'name' ] . tolist ( ) for table in [ 'sources' ] + [ t for t in all_tables if t not in [ 'sources' , 'sqlite_sequence' ] ] : try : # Get the columns, pull out redundant ones, and query the table for this source's data t = self . query ( \"PRAGMA table_info({})\" . format ( table ) , fmt = 'table' ) columns = np . array ( t [ 'name' ] ) types = np . array ( t [ 'type' ] ) if table == 'sources' or 'source_id' in columns : # If printing, only get simple data types and exclude redundant 'source_id' for nicer printing if not fetch : columns = columns [ ( ( types == 'REAL' ) | ( types == 'INTEGER' ) | ( types == 'TEXT' ) ) & ( columns != 'source_id' ) ] # Query the table try : id = 'id' if table . lower ( ) == 'sources' else 'source_id' data = self . query ( \"SELECT {} FROM {} WHERE {}={}\" . format ( ',' . join ( columns ) , table , id , source_id ) , fmt = 'table' ) if not data and table . lower ( ) == 'sources' : print ( 'No source with id {}. Try db.search() to search the database for a source_id.' . format ( source_id ) ) except : data = None # If there's data for this table, save it if data : if fetch : data_tables [ table ] = self . query ( \"SELECT {} FROM {} WHERE {}={}\" . format ( ',' . join ( columns ) , table , id , source_id ) , fetch = True , fmt = fmt ) else : data = data [ [ c . lower ( ) for c in columns ] ] pprint ( data , title = table . upper ( ) ) else : pass except : print ( 'Could not retrieve data from {} table.' . format ( table . upper ( ) ) ) if fetch : return data_tables", "docstring_tokens": "Prints a summary of all objects in the database . Input string or list of strings in ** ID ** or ** unum ** for specific objects .", "label": 1}, {"idx": "cosqa-train-11556", "doc": "python parse date string to date time", "code": "def convert_time_string(date_str):\n    \"\"\" Change a date string from the format 2018-08-15T23:55:17 into a datetime object \"\"\"\n    dt, _, _ = date_str.partition(\".\")\n    dt = datetime.strptime(dt, \"%Y-%m-%dT%H:%M:%S\")\n    return dt", "code_tokens": "def convert_time_string ( date_str ) : dt , _ , _ = date_str . partition ( \".\" ) dt = datetime . strptime ( dt , \"%Y-%m-%dT%H:%M:%S\" ) return dt", "docstring_tokens": "Change a date string from the format 2018 - 08 - 15T23 : 55 : 17 into a datetime object", "label": 1}, {"idx": "cosqa-train-11557", "doc": "how to get largest values from a a list python", "code": "def _gcd_array(X):\n    \"\"\"\n    Return the largest real value h such that all elements in x are integer\n    multiples of h.\n    \"\"\"\n    greatest_common_divisor = 0.0\n    for x in X:\n        greatest_common_divisor = _gcd(greatest_common_divisor, x)\n\n    return greatest_common_divisor", "code_tokens": "def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor", "docstring_tokens": "Return the largest real value h such that all elements in x are integer multiples of h .", "label": 1}, {"idx": "cosqa-train-11558", "doc": "python parse ply grammar", "code": "def parse(self, data, lexer=None, *args, **kwargs):\n        \"\"\"Parse the input JSON data string into a python data structure.\n        Args:\n          data: An input data string\n          lexer:  An optional ply.lex instance that overrides the default lexer.\n        Returns:\n          A python dict or list representing the input JSON data.\n        \"\"\"\n        if lexer is None:\n            lexer = self.lexer\n        return self.parser.parse(data, lexer=lexer, *args, **kwargs)", "code_tokens": "def parse ( self , data , lexer = None , * args , * * kwargs ) : if lexer is None : lexer = self . lexer return self . parser . parse ( data , lexer = lexer , * args , * * kwargs )", "docstring_tokens": "Parse the input JSON data string into a python data structure . Args : data : An input data string lexer : An optional ply . lex instance that overrides the default lexer . Returns : A python dict or list representing the input JSON data .", "label": 1}, {"idx": "cosqa-train-11559", "doc": "how to get last n elements in python", "code": "def searchlast(self,n=10):\n        \"\"\"Return the last n results (or possibly less if not found). Note that the last results are not necessarily the best ones! Depending on the search type.\"\"\"            \n        solutions = deque([], n)\n        for solution in self:\n            solutions.append(solution)\n        return solutions", "code_tokens": "def searchlast ( self , n = 10 ) : solutions = deque ( [ ] , n ) for solution in self : solutions . append ( solution ) return solutions", "docstring_tokens": "Return the last n results ( or possibly less if not found ) . Note that the last results are not necessarily the best ones! Depending on the search type .", "label": 1}, {"idx": "cosqa-train-11560", "doc": "python parse query string from url", "code": "def parse_query_string(query):\n    \"\"\"\n    parse_query_string:\n    very simplistic. won't do the right thing with list values\n    \"\"\"\n    result = {}\n    qparts = query.split('&')\n    for item in qparts:\n        key, value = item.split('=')\n        key = key.strip()\n        value = value.strip()\n        result[key] = unquote_plus(value)\n    return result", "code_tokens": "def parse_query_string ( query ) : result = { } qparts = query . split ( '&' ) for item in qparts : key , value = item . split ( '=' ) key = key . strip ( ) value = value . strip ( ) result [ key ] = unquote_plus ( value ) return result", "docstring_tokens": "parse_query_string : very simplistic . won t do the right thing with list values", "label": 1}, {"idx": "cosqa-train-11561", "doc": "how to get lat and long from string python", "code": "def coords_from_query(query):\n    \"\"\"Transform a query line into a (lng, lat) pair of coordinates.\"\"\"\n    try:\n        coords = json.loads(query)\n    except ValueError:\n        vals = re.split(r'[,\\s]+', query.strip())\n        coords = [float(v) for v in vals]\n    return tuple(coords[:2])", "code_tokens": "def coords_from_query ( query ) : try : coords = json . loads ( query ) except ValueError : vals = re . split ( r'[,\\s]+' , query . strip ( ) ) coords = [ float ( v ) for v in vals ] return tuple ( coords [ : 2 ] )", "docstring_tokens": "Transform a query line into a ( lng lat ) pair of coordinates .", "label": 1}, {"idx": "cosqa-train-11562", "doc": "python parse s3 bucket and key from path", "code": "def parse_s3_url(url):\n    \"\"\"\n    Parses S3 URL.\n\n    Returns bucket (domain) and file (full path).\n    \"\"\"\n    bucket = ''\n    path = ''\n    if url:\n        result = urlparse(url)\n        bucket = result.netloc\n        path = result.path.strip('/')\n    return bucket, path", "code_tokens": "def parse_s3_url ( url ) : bucket = '' path = '' if url : result = urlparse ( url ) bucket = result . netloc path = result . path . strip ( '/' ) return bucket , path", "docstring_tokens": "Parses S3 URL .", "label": 1}, {"idx": "cosqa-train-11563", "doc": "how to get method name python", "code": "def get_method_name(method):\n    \"\"\"\n    Returns given method name.\n\n    :param method: Method to retrieve the name.\n    :type method: object\n    :return: Method name.\n    :rtype: unicode\n    \"\"\"\n\n    name = get_object_name(method)\n    if name.startswith(\"__\") and not name.endswith(\"__\"):\n        name = \"_{0}{1}\".format(get_object_name(method.im_class), name)\n    return name", "code_tokens": "def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( \"__\" ) and not name . endswith ( \"__\" ) : name = \"_{0}{1}\" . format ( get_object_name ( method . im_class ) , name ) return name", "docstring_tokens": "Returns given method name .", "label": 1}, {"idx": "cosqa-train-11564", "doc": "python parse string to get datetime object", "code": "def deserialize_date(string):\n    \"\"\"\n    Deserializes string to date.\n\n    :param string: str.\n    :type string: str\n    :return: date.\n    :rtype: date\n    \"\"\"\n    try:\n        from dateutil.parser import parse\n        return parse(string).date()\n    except ImportError:\n        return string", "code_tokens": "def deserialize_date ( string ) : try : from dateutil . parser import parse return parse ( string ) . date ( ) except ImportError : return string", "docstring_tokens": "Deserializes string to date .", "label": 1}, {"idx": "cosqa-train-11565", "doc": "how to get next month python datetime", "code": "def get_month_start_date(self):\n        \"\"\"Returns the first day of the current month\"\"\"\n        now = timezone.now()\n        return timezone.datetime(day=1, month=now.month, year=now.year, tzinfo=now.tzinfo)", "code_tokens": "def get_month_start_date ( self ) : now = timezone . now ( ) return timezone . datetime ( day = 1 , month = now . month , year = now . year , tzinfo = now . tzinfo )", "docstring_tokens": "Returns the first day of the current month", "label": 1}, {"idx": "cosqa-train-11566", "doc": "how to get number of days in year in python", "code": "def gday_of_year(self):\n        \"\"\"Return the number of days since January 1 of the given year.\"\"\"\n        return (self.date - dt.date(self.date.year, 1, 1)).days", "code_tokens": "def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days", "docstring_tokens": "Return the number of days since January 1 of the given year .", "label": 1}, {"idx": "cosqa-train-11567", "doc": "python pass html form values to flask py", "code": "def parse_form(self, req, name, field):\n        \"\"\"Pull a form value from the request.\"\"\"\n        return get_value(req.body_arguments, name, field)", "code_tokens": "def parse_form ( self , req , name , field ) : return get_value ( req . body_arguments , name , field )", "docstring_tokens": "Pull a form value from the request .", "label": 1}, {"idx": "cosqa-train-11568", "doc": "how to get number of days in yearin python", "code": "def gday_of_year(self):\n        \"\"\"Return the number of days since January 1 of the given year.\"\"\"\n        return (self.date - dt.date(self.date.year, 1, 1)).days", "code_tokens": "def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days", "docstring_tokens": "Return the number of days since January 1 of the given year .", "label": 1}, {"idx": "cosqa-train-11569", "doc": "python pass kwargs dict", "code": "def _sourced_dict(self, source=None, **kwargs):\n        \"\"\"Like ``dict(**kwargs)``, but where the ``source`` key is special.\n        \"\"\"\n        if source:\n            kwargs['source'] = source\n        elif self.source:\n            kwargs['source'] = self.source\n        return kwargs", "code_tokens": "def _sourced_dict ( self , source = None , * * kwargs ) : if source : kwargs [ 'source' ] = source elif self . source : kwargs [ 'source' ] = self . source return kwargs", "docstring_tokens": "Like dict ( ** kwargs ) but where the source key is special .", "label": 1}, {"idx": "cosqa-train-11570", "doc": "how to get owner of a folder python", "code": "def get_parent_folder_name(file_path):\n    \"\"\"Finds parent folder of file\n\n    :param file_path: path\n    :return: Name of folder container\n    \"\"\"\n    return os.path.split(os.path.split(os.path.abspath(file_path))[0])[-1]", "code_tokens": "def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]", "docstring_tokens": "Finds parent folder of file", "label": 1}, {"idx": "cosqa-train-11571", "doc": "python pass self object to function", "code": "def do(self):\n        \"\"\"\n        Set a restore point (copy the object), then call the method.\n        :return: obj.do_method(*args)\n        \"\"\"\n        self.restore_point = self.obj.copy()\n        return self.do_method(self.obj, *self.args)", "code_tokens": "def do ( self ) : self . restore_point = self . obj . copy ( ) return self . do_method ( self . obj , * self . args )", "docstring_tokens": "Set a restore point ( copy the object ) then call the method . : return : obj . do_method ( * args )", "label": 0}, {"idx": "cosqa-train-11572", "doc": "how to get python data frame col names", "code": "def get_obj_cols(df):\n    \"\"\"\n    Returns names of 'object' columns in the DataFrame.\n    \"\"\"\n    obj_cols = []\n    for idx, dt in enumerate(df.dtypes):\n        if dt == 'object' or is_category(dt):\n            obj_cols.append(df.columns.values[idx])\n\n    return obj_cols", "code_tokens": "def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols", "docstring_tokens": "Returns names of object columns in the DataFrame .", "label": 1}, {"idx": "cosqa-train-11573", "doc": "python pass variable to yaml file", "code": "def generate_write_yaml_to_file(file_name):\n    \"\"\" generate a method to write the configuration in yaml to the method desired \"\"\"\n    def write_yaml(config):\n        with open(file_name, 'w+') as fh:\n            fh.write(yaml.dump(config))\n    return write_yaml", "code_tokens": "def generate_write_yaml_to_file ( file_name ) : def write_yaml ( config ) : with open ( file_name , 'w+' ) as fh : fh . write ( yaml . dump ( config ) ) return write_yaml", "docstring_tokens": "generate a method to write the configuration in yaml to the method desired", "label": 1}, {"idx": "cosqa-train-11574", "doc": "how to get rid of the bound method statemnt in python", "code": "def method(func):\n    \"\"\"Wrap a function as a method.\"\"\"\n    attr = abc.abstractmethod(func)\n    attr.__imethod__ = True\n    return attr", "code_tokens": "def method ( func ) : attr = abc . abstractmethod ( func ) attr . __imethod__ = True return attr", "docstring_tokens": "Wrap a function as a method .", "label": 1}, {"idx": "cosqa-train-11575", "doc": "python passing parent to child bad", "code": "def add_parent(self, parent):\n        \"\"\"\n        Adds self as child of parent, then adds parent.\n        \"\"\"\n        parent.add_child(self)\n        self.parent = parent\n        return parent", "code_tokens": "def add_parent ( self , parent ) : parent . add_child ( self ) self . parent = parent return parent", "docstring_tokens": "Adds self as child of parent then adds parent .", "label": 1}, {"idx": "cosqa-train-11576", "doc": "how to get row an col indexes sing enumerate python", "code": "def ColumnToIndex (col):\n        \"\"\"convert column to index. Eg: ConvertInIndex(\"AB\") = 28\"\"\"\n        ndx = 0\n        for c in col:\n                ndx = ndx * 26 + ord(c.upper()) - 64\n        return ndx", "code_tokens": "def ColumnToIndex ( col ) : ndx = 0 for c in col : ndx = ndx * 26 + ord ( c . upper ( ) ) - 64 return ndx", "docstring_tokens": "convert column to index . Eg : ConvertInIndex ( AB ) = 28", "label": 1}, {"idx": "cosqa-train-11577", "doc": "python path abspath current file", "code": "def rel_path(filename):\n    \"\"\"\n    Function that gets relative path to the filename\n    \"\"\"\n    return os.path.join(os.getcwd(), os.path.dirname(__file__), filename)", "code_tokens": "def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )", "docstring_tokens": "Function that gets relative path to the filename", "label": 1}, {"idx": "cosqa-train-11578", "doc": "how to get the column names of a data frame in python", "code": "def get_obj_cols(df):\n    \"\"\"\n    Returns names of 'object' columns in the DataFrame.\n    \"\"\"\n    obj_cols = []\n    for idx, dt in enumerate(df.dtypes):\n        if dt == 'object' or is_category(dt):\n            obj_cols.append(df.columns.values[idx])\n\n    return obj_cols", "code_tokens": "def get_obj_cols ( df ) : obj_cols = [ ] for idx , dt in enumerate ( df . dtypes ) : if dt == 'object' or is_category ( dt ) : obj_cols . append ( df . columns . values [ idx ] ) return obj_cols", "docstring_tokens": "Returns names of object columns in the DataFrame .", "label": 1}, {"idx": "cosqa-train-11579", "doc": "python pdb no capture std output", "code": "def set_trace():\n    \"\"\"Start a Pdb instance at the calling frame, with stdout routed to sys.__stdout__.\"\"\"\n    # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py\n    pdb.Pdb(stdout=sys.__stdout__).set_trace(sys._getframe().f_back)", "code_tokens": "def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )", "docstring_tokens": "Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ .", "label": 1}, {"idx": "cosqa-train-11580", "doc": "how to get the complete path of a file in python", "code": "def rel_path(filename):\n    \"\"\"\n    Function that gets relative path to the filename\n    \"\"\"\n    return os.path.join(os.getcwd(), os.path.dirname(__file__), filename)", "code_tokens": "def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )", "docstring_tokens": "Function that gets relative path to the filename", "label": 0}, {"idx": "cosqa-train-11581", "doc": "python pdb print out call stack", "code": "def debug_on_error(type, value, tb):\n    \"\"\"Code due to Thomas Heller - published in Python Cookbook (O'Reilley)\"\"\"\n    traceback.print_exc(type, value, tb)\n    print()\n    pdb.pm()", "code_tokens": "def debug_on_error ( type , value , tb ) : traceback . print_exc ( type , value , tb ) print ( ) pdb . pm ( )", "docstring_tokens": "Code due to Thomas Heller - published in Python Cookbook ( O Reilley )", "label": 1}, {"idx": "cosqa-train-11582", "doc": "how to get the cursor in python", "code": "def get_cursor(self):\n        \"\"\"Returns current grid cursor cell (row, col, tab)\"\"\"\n\n        return self.grid.GetGridCursorRow(), self.grid.GetGridCursorCol(), \\\n            self.grid.current_table", "code_tokens": "def get_cursor ( self ) : return self . grid . GetGridCursorRow ( ) , self . grid . GetGridCursorCol ( ) , self . grid . current_table", "docstring_tokens": "Returns current grid cursor cell ( row col tab )", "label": 1}, {"idx": "cosqa-train-11583", "doc": "python pdb return from function", "code": "def user_return(self, frame, return_value):\n        \"\"\"This function is called when a return trap is set here.\"\"\"\n        pdb.Pdb.user_return(self, frame, return_value)", "code_tokens": "def user_return ( self , frame , return_value ) : pdb . Pdb . user_return ( self , frame , return_value )", "docstring_tokens": "This function is called when a return trap is set here .", "label": 1}, {"idx": "cosqa-train-11584", "doc": "how to get the encoding of a file python", "code": "def smartread(path):\n    \"\"\"Read text from file, automatically detect encoding. ``chardet`` required.\n    \"\"\"\n    with open(path, \"rb\") as f:\n        content = f.read()\n        result = chardet.detect(content)\n        return content.decode(result[\"encoding\"])", "code_tokens": "def smartread ( path ) : with open ( path , \"rb\" ) as f : content = f . read ( ) result = chardet . detect ( content ) return content . decode ( result [ \"encoding\" ] )", "docstring_tokens": "Read text from file automatically detect encoding . chardet required .", "label": 1}, {"idx": "cosqa-train-11585", "doc": "python pdb see stack", "code": "def set_trace():\n    \"\"\"Start a Pdb instance at the calling frame, with stdout routed to sys.__stdout__.\"\"\"\n    # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py\n    pdb.Pdb(stdout=sys.__stdout__).set_trace(sys._getframe().f_back)", "code_tokens": "def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )", "docstring_tokens": "Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ .", "label": 1}, {"idx": "cosqa-train-11586", "doc": "how to get the index of a row python", "code": "def translate_index_to_position(self, index):\n        \"\"\"\n        Given an index for the text, return the corresponding (row, col) tuple.\n        (0-based. Returns (0, 0) for index=0.)\n        \"\"\"\n        # Find start of this line.\n        row, row_index = self._find_line_start_index(index)\n        col = index - row_index\n\n        return row, col", "code_tokens": "def translate_index_to_position ( self , index ) : # Find start of this line. row , row_index = self . _find_line_start_index ( index ) col = index - row_index return row , col", "docstring_tokens": "Given an index for the text return the corresponding ( row col ) tuple . ( 0 - based . Returns ( 0 0 ) for index = 0 . )", "label": 1}, {"idx": "cosqa-train-11587", "doc": "python pdf document size", "code": "def dimensions(path):\n    \"\"\"Get width and height of a PDF\"\"\"\n    pdf = PdfFileReader(path)\n    size = pdf.getPage(0).mediaBox\n    return {'w': float(size[2]), 'h': float(size[3])}", "code_tokens": "def dimensions ( path ) : pdf = PdfFileReader ( path ) size = pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "docstring_tokens": "Get width and height of a PDF", "label": 1}, {"idx": "cosqa-train-11588", "doc": "how to get the intensity phase using python", "code": "def get_data():\n    \"\"\"\n    Currently pretends to talk to an instrument and get back the magnitud\n    and phase of the measurement.\n    \"\"\"\n\n    # pretend we're measuring a noisy resonance at zero\n    y = 1.0 / (1.0 + 1j*(n_x.get_value()-0.002)*1000) + _n.random.rand()*0.1\n\n    # and that it takes time to do so\n    _t.sleep(0.1)\n\n    # return mag phase\n    return abs(y), _n.angle(y, True)", "code_tokens": "def get_data ( ) : # pretend we're measuring a noisy resonance at zero y = 1.0 / ( 1.0 + 1j * ( n_x . get_value ( ) - 0.002 ) * 1000 ) + _n . random . rand ( ) * 0.1 # and that it takes time to do so _t . sleep ( 0.1 ) # return mag phase return abs ( y ) , _n . angle ( y , True )", "docstring_tokens": "Currently pretends to talk to an instrument and get back the magnitud and phase of the measurement .", "label": 1}, {"idx": "cosqa-train-11589", "doc": "python pdf float right", "code": "def _pdf_at_peak(self):\n    \"\"\"Pdf evaluated at the peak.\"\"\"\n    return (self.peak - self.low) / (self.high - self.low)", "code_tokens": "def _pdf_at_peak ( self ) : return ( self . peak - self . low ) / ( self . high - self . low )", "docstring_tokens": "Pdf evaluated at the peak .", "label": 1}, {"idx": "cosqa-train-11590", "doc": "how to get the least value in a column in python", "code": "def find_le(a, x):\n    \"\"\"Find rightmost value less than or equal to x.\"\"\"\n    i = bs.bisect_right(a, x)\n    if i: return i - 1\n    raise ValueError", "code_tokens": "def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError", "docstring_tokens": "Find rightmost value less than or equal to x .", "label": 1}, {"idx": "cosqa-train-11591", "doc": "python pickle custom type", "code": "def _restore_seq_field_pickle(checked_class, item_type, data):\n    \"\"\"Unpickling function for auto-generated PVec/PSet field types.\"\"\"\n    type_ = _seq_field_types[checked_class, item_type]\n    return _restore_pickle(type_, data)", "code_tokens": "def _restore_seq_field_pickle ( checked_class , item_type , data ) : type_ = _seq_field_types [ checked_class , item_type ] return _restore_pickle ( type_ , data )", "docstring_tokens": "Unpickling function for auto - generated PVec / PSet field types .", "label": 1}, {"idx": "cosqa-train-11592", "doc": "how to get the lowest number from a list in python", "code": "def find_lt(a, x):\n    \"\"\"Find rightmost value less than x.\"\"\"\n    i = bs.bisect_left(a, x)\n    if i: return i - 1\n    raise ValueError", "code_tokens": "def find_lt ( a , x ) : i = bs . bisect_left ( a , x ) if i : return i - 1 raise ValueError", "docstring_tokens": "Find rightmost value less than x .", "label": 1}, {"idx": "cosqa-train-11593", "doc": "python pickle dump keras model", "code": "def save(self, f):\n        \"\"\"Save pickled model to file.\"\"\"\n        return pickle.dump((self.perceptron.weights, self.tagdict, self.classes, self.clusters), f, protocol=pickle.HIGHEST_PROTOCOL)", "code_tokens": "def save ( self , f ) : return pickle . dump ( ( self . perceptron . weights , self . tagdict , self . classes , self . clusters ) , f , protocol = pickle . HIGHEST_PROTOCOL )", "docstring_tokens": "Save pickled model to file .", "label": 1}, {"idx": "cosqa-train-11594", "doc": "how to get the start index and end index in python", "code": "def get_idx_rect(index_list):\n    \"\"\"Extract the boundaries from a list of indexes\"\"\"\n    rows, cols = list(zip(*[(i.row(), i.column()) for i in index_list]))\n    return ( min(rows), max(rows), min(cols), max(cols) )", "code_tokens": "def get_idx_rect ( index_list ) : rows , cols = list ( zip ( * [ ( i . row ( ) , i . column ( ) ) for i in index_list ] ) ) return ( min ( rows ) , max ( rows ) , min ( cols ) , max ( cols ) )", "docstring_tokens": "Extract the boundaries from a list of indexes", "label": 1}, {"idx": "cosqa-train-11595", "doc": "python plink problems with m command file", "code": "def locate(command, on):\n    \"\"\"Locate the command's man page.\"\"\"\n    location = find_page_location(command, on)\n    click.echo(location)", "code_tokens": "def locate ( command , on ) : location = find_page_location ( command , on ) click . echo ( location )", "docstring_tokens": "Locate the command s man page .", "label": 1}, {"idx": "cosqa-train-11596", "doc": "how to get the std err and std output in python", "code": "def puts_err(s='', newline=True, stream=STDERR):\n    \"\"\"Prints given string to stderr.\"\"\"\n    puts(s, newline, stream)", "code_tokens": "def puts_err ( s = '' , newline = True , stream = STDERR ) : puts ( s , newline , stream )", "docstring_tokens": "Prints given string to stderr .", "label": 1}, {"idx": "cosqa-train-11597", "doc": "python plot scrollbar button move with scroll", "code": "def set_scrollregion(self, event=None):\n        \"\"\" Set the scroll region on the canvas\"\"\"\n        self.canvas.configure(scrollregion=self.canvas.bbox('all'))", "code_tokens": "def set_scrollregion ( self , event = None ) : self . canvas . configure ( scrollregion = self . canvas . bbox ( 'all' ) )", "docstring_tokens": "Set the scroll region on the canvas", "label": 1}, {"idx": "cosqa-train-11598", "doc": "how to get the user id in windows using python", "code": "def get_nt_system_uid():\n    \"\"\"Get the MachineGuid from\n    HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Cryptography\\MachineGuid\n    \"\"\"\n    try:\n        import _winreg as winreg\n    except ImportError:\n        import winreg\n    lm = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n    try:\n        key = winreg.OpenKey(lm, r\"Software\\Microsoft\\Cryptography\")\n        try:\n            return winreg.QueryValueEx(key, \"MachineGuid\")[0]\n        finally:\n            key.Close()\n    finally:\n        lm.Close()", "code_tokens": "def get_nt_system_uid ( ) : try : import _winreg as winreg except ImportError : import winreg lm = winreg . ConnectRegistry ( None , winreg . HKEY_LOCAL_MACHINE ) try : key = winreg . OpenKey ( lm , r\"Software\\Microsoft\\Cryptography\" ) try : return winreg . QueryValueEx ( key , \"MachineGuid\" ) [ 0 ] finally : key . Close ( ) finally : lm . Close ( )", "docstring_tokens": "Get the MachineGuid from HKEY_LOCAL_MACHINE \\ Software \\ Microsoft \\ Cryptography \\ MachineGuid", "label": 0}, {"idx": "cosqa-train-11599", "doc": "python plot specify figure", "code": "def oplot(self, x, y, **kw):\n        \"\"\"generic plotting method, overplotting any existing plot \"\"\"\n        self.panel.oplot(x, y, **kw)", "code_tokens": "def oplot ( self , x , y , * * kw ) : self . panel . oplot ( x , y , * * kw )", "docstring_tokens": "generic plotting method overplotting any existing plot", "label": 1}, {"idx": "cosqa-train-11600", "doc": "how to get working directory in python", "code": "def get_base_dir():\n    \"\"\"\n    Return the base directory\n    \"\"\"\n    return os.path.split(os.path.abspath(os.path.dirname(__file__)))[0]", "code_tokens": "def get_base_dir ( ) : return os . path . split ( os . path . abspath ( os . path . dirname ( __file__ ) ) ) [ 0 ]", "docstring_tokens": "Return the base directory", "label": 1}, {"idx": "cosqa-train-11601", "doc": "python png to texture2d", "code": "def image_to_texture(image):\n    \"\"\"Converts ``vtkImageData`` to a ``vtkTexture``\"\"\"\n    vtex = vtk.vtkTexture()\n    vtex.SetInputDataObject(image)\n    vtex.Update()\n    return vtex", "code_tokens": "def image_to_texture ( image ) : vtex = vtk . vtkTexture ( ) vtex . SetInputDataObject ( image ) vtex . Update ( ) return vtex", "docstring_tokens": "Converts vtkImageData to a vtkTexture", "label": 1}, {"idx": "cosqa-train-11602", "doc": "how to give encoding for file write in python", "code": "def write_to_file(file_path, contents, encoding=\"utf-8\"):\n    \"\"\"\n    Write helper method\n\n    :type file_path: str|unicode\n    :type contents: str|unicode\n    :type encoding: str|unicode\n    \"\"\"\n    with codecs.open(file_path, \"w\", encoding) as f:\n        f.write(contents)", "code_tokens": "def write_to_file ( file_path , contents , encoding = \"utf-8\" ) : with codecs . open ( file_path , \"w\" , encoding ) as f : f . write ( contents )", "docstring_tokens": "Write helper method", "label": 0}, {"idx": "cosqa-train-11603", "doc": "python pojo object to json", "code": "def as_dict(self):\n        \"\"\"\n        Json-serializable dict representation of PhononDos.\n        \"\"\"\n        return {\"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__,\n                \"frequencies\": list(self.frequencies),\n                \"densities\": list(self.densities)}", "code_tokens": "def as_dict ( self ) : return { \"@module\" : self . __class__ . __module__ , \"@class\" : self . __class__ . __name__ , \"frequencies\" : list ( self . frequencies ) , \"densities\" : list ( self . densities ) }", "docstring_tokens": "Json - serializable dict representation of PhononDos .", "label": 1}, {"idx": "cosqa-train-11604", "doc": "how to have python save a file as", "code": "def pickle_save(thing,fname):\n    \"\"\"save something to a pickle file\"\"\"\n    pickle.dump(thing, open(fname,\"wb\"),pickle.HIGHEST_PROTOCOL)\n    return thing", "code_tokens": "def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , \"wb\" ) , pickle . HIGHEST_PROTOCOL ) return thing", "docstring_tokens": "save something to a pickle file", "label": 1}, {"idx": "cosqa-train-11605", "doc": "python pop from first top array", "code": "def pop(h):\n    \"\"\"Pop the heap value from the heap.\"\"\"\n    n = h.size() - 1\n    h.swap(0, n)\n    down(h, 0, n)\n    return h.pop()", "code_tokens": "def pop ( h ) : n = h . size ( ) - 1 h . swap ( 0 , n ) down ( h , 0 , n ) return h . pop ( )", "docstring_tokens": "Pop the heap value from the heap .", "label": 1}, {"idx": "cosqa-train-11606", "doc": "how to hide a window using a button in python", "code": "def hide(self):\n        \"\"\"Hides the main window of the terminal and sets the visible\n        flag to False.\n        \"\"\"\n        if not HidePrevention(self.window).may_hide():\n            return\n        self.hidden = True\n        self.get_widget('window-root').unstick()\n        self.window.hide()", "code_tokens": "def hide ( self ) : if not HidePrevention ( self . window ) . may_hide ( ) : return self . hidden = True self . get_widget ( 'window-root' ) . unstick ( ) self . window . hide ( )", "docstring_tokens": "Hides the main window of the terminal and sets the visible flag to False .", "label": 1}, {"idx": "cosqa-train-11607", "doc": "python prettify json encoding", "code": "def dumps(obj):\n    \"\"\"Outputs json with formatting edits + object handling.\"\"\"\n    return json.dumps(obj, indent=4, sort_keys=True, cls=CustomEncoder)", "code_tokens": "def dumps ( obj ) : return json . dumps ( obj , indent = 4 , sort_keys = True , cls = CustomEncoder )", "docstring_tokens": "Outputs json with formatting edits + object handling .", "label": 1}, {"idx": "cosqa-train-11608", "doc": "how to identify if variable is not a factoral in python", "code": "def is_floating(self):\n        \"\"\"Returns whether this is a (non-quantized, real) floating point type.\"\"\"\n        return (\n            self.is_numpy_compatible and np.issubdtype(self.as_numpy_dtype, np.floating)\n        ) or self.base_dtype == bfloat16", "code_tokens": "def is_floating ( self ) : return ( self . is_numpy_compatible and np . issubdtype ( self . as_numpy_dtype , np . floating ) ) or self . base_dtype == bfloat16", "docstring_tokens": "Returns whether this is a ( non - quantized real ) floating point type .", "label": 1}, {"idx": "cosqa-train-11609", "doc": "python pretty print namedtuple", "code": "def _prtfmt(self, item_id, dashes):\n        \"\"\"Print object information using a namedtuple and a format pattern.\"\"\"\n        ntprt = self.id2nt[item_id]\n        dct = ntprt._asdict()\n        self.prt.write('{DASHES:{N}}'.format(\n            DASHES=self.fmt_dashes.format(DASHES=dashes, ID=self.nm2prtfmt['ID'].format(**dct)),\n            N=self.dash_len))\n        self.prt.write(\"{INFO}\\n\".format(INFO=self.nm2prtfmt['ITEM'].format(**dct)))", "code_tokens": "def _prtfmt ( self , item_id , dashes ) : ntprt = self . id2nt [ item_id ] dct = ntprt . _asdict ( ) self . prt . write ( '{DASHES:{N}}' . format ( DASHES = self . fmt_dashes . format ( DASHES = dashes , ID = self . nm2prtfmt [ 'ID' ] . format ( * * dct ) ) , N = self . dash_len ) ) self . prt . write ( \"{INFO}\\n\" . format ( INFO = self . nm2prtfmt [ 'ITEM' ] . format ( * * dct ) ) )", "docstring_tokens": "Print object information using a namedtuple and a format pattern .", "label": 1}, {"idx": "cosqa-train-11610", "doc": "how to identify type of input with python", "code": "def _guess_type(val):\n        \"\"\"Guess the input type of the parameter based off the default value, if unknown use text\"\"\"\n        if isinstance(val, bool):\n            return \"choice\"\n        elif isinstance(val, int):\n            return \"number\"\n        elif isinstance(val, float):\n            return \"number\"\n        elif isinstance(val, str):\n            return \"text\"\n        elif hasattr(val, 'read'):\n            return \"file\"\n        else:\n            return \"text\"", "code_tokens": "def _guess_type ( val ) : if isinstance ( val , bool ) : return \"choice\" elif isinstance ( val , int ) : return \"number\" elif isinstance ( val , float ) : return \"number\" elif isinstance ( val , str ) : return \"text\" elif hasattr ( val , 'read' ) : return \"file\" else : return \"text\"", "docstring_tokens": "Guess the input type of the parameter based off the default value if unknown use text", "label": 1}, {"idx": "cosqa-train-11611", "doc": "python pretty print tuple", "code": "def _tuple_repr(data):\n    \"\"\"Return a repr() for a list/tuple\"\"\"\n    if len(data) == 1:\n        return \"(%s,)\" % rpr(data[0])\n    else:\n        return \"(%s)\" % \", \".join([rpr(x) for x in data])", "code_tokens": "def _tuple_repr ( data ) : if len ( data ) == 1 : return \"(%s,)\" % rpr ( data [ 0 ] ) else : return \"(%s)\" % \", \" . join ( [ rpr ( x ) for x in data ] )", "docstring_tokens": "Return a repr () for a list / tuple", "label": 1}, {"idx": "cosqa-train-11612", "doc": "how to impute missing data python", "code": "def impute_data(self,x):\n        \"\"\"Imputes data set containing Nan values\"\"\"\n        imp = Imputer(missing_values='NaN', strategy='mean', axis=0)\n        return imp.fit_transform(x)", "code_tokens": "def impute_data ( self , x ) : imp = Imputer ( missing_values = 'NaN' , strategy = 'mean' , axis = 0 ) return imp . fit_transform ( x )", "docstring_tokens": "Imputes data set containing Nan values", "label": 1}, {"idx": "cosqa-train-11613", "doc": "python pretty print write", "code": "def pretty(obj, verbose=False, max_width=79, newline='\\n'):\n    \"\"\"\n    Pretty print the object's representation.\n    \"\"\"\n    stream = StringIO()\n    printer = RepresentationPrinter(stream, verbose, max_width, newline)\n    printer.pretty(obj)\n    printer.flush()\n    return stream.getvalue()", "code_tokens": "def pretty ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : stream = StringIO ( ) printer = RepresentationPrinter ( stream , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) return stream . getvalue ( )", "docstring_tokens": "Pretty print the object s representation .", "label": 1}, {"idx": "cosqa-train-11614", "doc": "how to indent self python", "code": "def _pad(self):\n    \"\"\"Pads the output with an amount of indentation appropriate for the number of open element.\n\n    This method does nothing if the indent value passed to the constructor is falsy.\n    \"\"\"\n    if self._indent:\n      self.whitespace(self._indent * len(self._open_elements))", "code_tokens": "def _pad ( self ) : if self . _indent : self . whitespace ( self . _indent * len ( self . _open_elements ) )", "docstring_tokens": "Pads the output with an amount of indentation appropriate for the number of open element .", "label": 1}, {"idx": "cosqa-train-11615", "doc": "python prettytable column headers in multiple rows", "code": "def adapter(data, headers, **kwargs):\n    \"\"\"Wrap vertical table in a function for TabularOutputFormatter.\"\"\"\n    keys = ('sep_title', 'sep_character', 'sep_length')\n    return vertical_table(data, headers, **filter_dict_by_key(kwargs, keys))", "code_tokens": "def adapter ( data , headers , * * kwargs ) : keys = ( 'sep_title' , 'sep_character' , 'sep_length' ) return vertical_table ( data , headers , * * filter_dict_by_key ( kwargs , keys ) )", "docstring_tokens": "Wrap vertical table in a function for TabularOutputFormatter .", "label": 1}, {"idx": "cosqa-train-11616", "doc": "how to indicate a sum of a column in python", "code": "def query_sum(queryset, field):\n    \"\"\"\n    Let the DBMS perform a sum on a queryset\n    \"\"\"\n    return queryset.aggregate(s=models.functions.Coalesce(models.Sum(field), 0))['s']", "code_tokens": "def query_sum ( queryset , field ) : return queryset . aggregate ( s = models . functions . Coalesce ( models . Sum ( field ) , 0 ) ) [ 's' ]", "docstring_tokens": "Let the DBMS perform a sum on a queryset", "label": 1}, {"idx": "cosqa-train-11617", "doc": "python prettytable horizontal line", "code": "def top(n, width=WIDTH, style=STYLE):\n    \"\"\"Prints the top row of a table\"\"\"\n    return hrule(n, width, linestyle=STYLES[style].top)", "code_tokens": "def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )", "docstring_tokens": "Prints the top row of a table", "label": 1}, {"idx": "cosqa-train-11618", "doc": "how to initialize an empty array of 10 length in python", "code": "def __init__(self, capacity=10):\n        \"\"\"\n        Initialize python List with capacity of 10 or user given input.\n        Python List type is a dynamic array, so we have to restrict its\n        dynamic nature to make it work like a static array.\n        \"\"\"\n        super().__init__()\n        self._array = [None] * capacity\n        self._front = 0\n        self._rear = 0", "code_tokens": "def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0", "docstring_tokens": "Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array .", "label": 1}, {"idx": "cosqa-train-11619", "doc": "python print \\033 cursor", "code": "def hidden_cursor():\n    \"\"\"Temporarily hide the terminal cursor.\"\"\"\n    if sys.stdout.isatty():\n        _LOGGER.debug('Hiding cursor.')\n        print('\\x1B[?25l', end='')\n        sys.stdout.flush()\n    try:\n        yield\n    finally:\n        if sys.stdout.isatty():\n            _LOGGER.debug('Showing cursor.')\n            print('\\n\\x1B[?25h', end='')\n            sys.stdout.flush()", "code_tokens": "def hidden_cursor ( ) : if sys . stdout . isatty ( ) : _LOGGER . debug ( 'Hiding cursor.' ) print ( '\\x1B[?25l' , end = '' ) sys . stdout . flush ( ) try : yield finally : if sys . stdout . isatty ( ) : _LOGGER . debug ( 'Showing cursor.' ) print ( '\\n\\x1B[?25h' , end = '' ) sys . stdout . flush ( )", "docstring_tokens": "Temporarily hide the terminal cursor .", "label": 1}, {"idx": "cosqa-train-11620", "doc": "how to invert a dictionary in python with multiple keys", "code": "def invertDictMapping(d):\n    \"\"\" Invert mapping of dictionary (i.e. map values to list of keys) \"\"\"\n    inv_map = {}\n    for k, v in d.items():\n        inv_map[v] = inv_map.get(v, [])\n        inv_map[v].append(k)\n    return inv_map", "code_tokens": "def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map", "docstring_tokens": "Invert mapping of dictionary ( i . e . map values to list of keys )", "label": 1}, {"idx": "cosqa-train-11621", "doc": "python print all environment variables", "code": "def show():\n    \"\"\"Show (print out) current environment variables.\"\"\"\n    env = get_environment()\n\n    for key, val in sorted(env.env.items(), key=lambda item: item[0]):\n        click.secho('%s = %s' % (key, val))", "code_tokens": "def show ( ) : env = get_environment ( ) for key , val in sorted ( env . env . items ( ) , key = lambda item : item [ 0 ] ) : click . secho ( '%s = %s' % ( key , val ) )", "docstring_tokens": "Show ( print out ) current environment variables .", "label": 1}, {"idx": "cosqa-train-11622", "doc": "how to iterate on multiple iterator in python", "code": "def peekiter(iterable):\n    \"\"\"Return first row and also iterable with same items as original\"\"\"\n    it = iter(iterable)\n    one = next(it)\n\n    def gen():\n        \"\"\"Generator that returns first and proxy other items from source\"\"\"\n        yield one\n        while True:\n            yield next(it)\n    return (one, gen())", "code_tokens": "def peekiter ( iterable ) : it = iter ( iterable ) one = next ( it ) def gen ( ) : \"\"\"Generator that returns first and proxy other items from source\"\"\" yield one while True : yield next ( it ) return ( one , gen ( ) )", "docstring_tokens": "Return first row and also iterable with same items as original", "label": 1}, {"idx": "cosqa-train-11623", "doc": "python print centered text", "code": "def info(txt):\n    \"\"\"Print, emphasized 'neutral', the given 'txt' message\"\"\"\n\n    print(\"%s# %s%s%s\" % (PR_EMPH_CC, get_time_stamp(), txt, PR_NC))\n    sys.stdout.flush()", "code_tokens": "def info ( txt ) : print ( \"%s# %s%s%s\" % ( PR_EMPH_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "docstring_tokens": "Print emphasized neutral the given txt message", "label": 1}, {"idx": "cosqa-train-11624", "doc": "how to iterate through multiple folders in python", "code": "def get_all_files(folder):\n    \"\"\"\n    Generator that loops through all absolute paths of the files within folder\n\n    Parameters\n    ----------\n    folder: str\n    Root folder start point for recursive search.\n\n    Yields\n    ------\n    fpath: str\n    Absolute path of one file in the folders\n    \"\"\"\n    for path, dirlist, filelist in os.walk(folder):\n        for fn in filelist:\n            yield op.join(path, fn)", "code_tokens": "def get_all_files ( folder ) : for path , dirlist , filelist in os . walk ( folder ) : for fn in filelist : yield op . join ( path , fn )", "docstring_tokens": "Generator that loops through all absolute paths of the files within folder", "label": 1}, {"idx": "cosqa-train-11625", "doc": "python print entire dictionary without ellipses", "code": "def _attrprint(d, delimiter=', '):\n    \"\"\"Print a dictionary of attributes in the DOT format\"\"\"\n    return delimiter.join(('\"%s\"=\"%s\"' % item) for item in sorted(d.items()))", "code_tokens": "def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '\"%s\"=\"%s\"' % item ) for item in sorted ( d . items ( ) ) )", "docstring_tokens": "Print a dictionary of attributes in the DOT format", "label": 1}, {"idx": "cosqa-train-11626", "doc": "how to join 2 data frames in python", "code": "def cross_join(df1, df2):\n    \"\"\"\n    Return a dataframe that is a cross between dataframes\n    df1 and df2\n\n    ref: https://github.com/pydata/pandas/issues/5401\n    \"\"\"\n    if len(df1) == 0:\n        return df2\n\n    if len(df2) == 0:\n        return df1\n\n    # Add as lists so that the new index keeps the items in\n    # the order that they are added together\n    all_columns = pd.Index(list(df1.columns) + list(df2.columns))\n    df1['key'] = 1\n    df2['key'] = 1\n    return pd.merge(df1, df2, on='key').loc[:, all_columns]", "code_tokens": "def cross_join ( df1 , df2 ) : if len ( df1 ) == 0 : return df2 if len ( df2 ) == 0 : return df1 # Add as lists so that the new index keeps the items in # the order that they are added together all_columns = pd . Index ( list ( df1 . columns ) + list ( df2 . columns ) ) df1 [ 'key' ] = 1 df2 [ 'key' ] = 1 return pd . merge ( df1 , df2 , on = 'key' ) . loc [ : , all_columns ]", "docstring_tokens": "Return a dataframe that is a cross between dataframes df1 and df2", "label": 1}, {"idx": "cosqa-train-11627", "doc": "python print function trace", "code": "def debug(ftn, txt):\n    \"\"\"Used for debugging.\"\"\"\n    if debug_p:\n        sys.stdout.write(\"{0}.{1}:{2}\\n\".format(modname, ftn, txt))\n        sys.stdout.flush()", "code_tokens": "def debug ( ftn , txt ) : if debug_p : sys . stdout . write ( \"{0}.{1}:{2}\\n\" . format ( modname , ftn , txt ) ) sys . stdout . flush ( )", "docstring_tokens": "Used for debugging .", "label": 1}, {"idx": "cosqa-train-11628", "doc": "how to join two masked arrays in python", "code": "def _join_masks_from_masked_array(data):\n    \"\"\"Union of masks.\"\"\"\n    if not isinstance(data.mask, np.ndarray):\n        # workaround to handle mask compressed to single value\n        mask = np.empty(data.data.shape, dtype=np.bool)\n        mask.fill(data.mask)\n        return mask\n    mask = data.mask[0].copy()\n    for i in range(1, len(data.mask)):\n        mask = np.logical_or(mask, data.mask[i])\n    return mask[np.newaxis, :, :]", "code_tokens": "def _join_masks_from_masked_array ( data ) : if not isinstance ( data . mask , np . ndarray ) : # workaround to handle mask compressed to single value mask = np . empty ( data . data . shape , dtype = np . bool ) mask . fill ( data . mask ) return mask mask = data . mask [ 0 ] . copy ( ) for i in range ( 1 , len ( data . mask ) ) : mask = np . logical_or ( mask , data . mask [ i ] ) return mask [ np . newaxis , : , : ]", "docstring_tokens": "Union of masks .", "label": 1}, {"idx": "cosqa-train-11629", "doc": "python print help message", "code": "def _help():\n    \"\"\" Display both SQLAlchemy and Python help statements \"\"\"\n\n    statement = '%s%s' % (shelp, phelp % ', '.join(cntx_.keys()))\n    print statement.strip()", "code_tokens": "def _help ( ) : statement = '%s%s' % ( shelp , phelp % ', ' . join ( cntx_ . keys ( ) ) ) print statement . strip ( )", "docstring_tokens": "Display both SQLAlchemy and Python help statements", "label": 1}, {"idx": "cosqa-train-11630", "doc": "how to jump to the end of a line in python", "code": "def go_to_line(self, line):\n        \"\"\"\n        Moves the text cursor to given line.\n\n        :param line: Line to go to.\n        :type line: int\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        cursor = self.textCursor()\n        cursor.setPosition(self.document().findBlockByNumber(line - 1).position())\n        self.setTextCursor(cursor)\n        return True", "code_tokens": "def go_to_line ( self , line ) : cursor = self . textCursor ( ) cursor . setPosition ( self . document ( ) . findBlockByNumber ( line - 1 ) . position ( ) ) self . setTextCursor ( cursor ) return True", "docstring_tokens": "Moves the text cursor to given line .", "label": 1}, {"idx": "cosqa-train-11631", "doc": "python print item appended to list", "code": "def append(self, item):\n        \"\"\" append item and print it to stdout \"\"\"\n        print(item)\n        super(MyList, self).append(item)", "code_tokens": "def append ( self , item ) : print ( item ) super ( MyList , self ) . append ( item )", "docstring_tokens": "append item and print it to stdout", "label": 1}, {"idx": "cosqa-train-11632", "doc": "how to keep pivotable index in python df", "code": "def get_unique_indices(df, axis=1):\n    \"\"\"\n\n    :param df:\n    :param axis:\n    :return:\n    \"\"\"\n    return dict(zip(df.columns.names, dif.columns.levels))", "code_tokens": "def get_unique_indices ( df , axis = 1 ) : return dict ( zip ( df . columns . names , dif . columns . levels ) )", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-11633", "doc": "python print object to a string", "code": "def pretty(obj, verbose=False, max_width=79, newline='\\n'):\n    \"\"\"\n    Pretty print the object's representation.\n    \"\"\"\n    stream = StringIO()\n    printer = RepresentationPrinter(stream, verbose, max_width, newline)\n    printer.pretty(obj)\n    printer.flush()\n    return stream.getvalue()", "code_tokens": "def pretty ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : stream = StringIO ( ) printer = RepresentationPrinter ( stream , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) return stream . getvalue ( )", "docstring_tokens": "Pretty print the object s representation .", "label": 1}, {"idx": "cosqa-train-11634", "doc": "how to know if an array is empty in python", "code": "def contains_empty(features):\n    \"\"\"Check features data are not empty\n\n    :param features: The features data to check.\n    :type features: list of numpy arrays.\n\n    :return: True if one of the array is empty, False else.\n\n    \"\"\"\n    if not features:\n        return True\n    for feature in features:\n        if feature.shape[0] == 0:\n            return True\n    return False", "code_tokens": "def contains_empty ( features ) : if not features : return True for feature in features : if feature . shape [ 0 ] == 0 : return True return False", "docstring_tokens": "Check features data are not empty", "label": 0}, {"idx": "cosqa-train-11635", "doc": "python print object with precision", "code": "def pretty(obj, verbose=False, max_width=79, newline='\\n'):\n    \"\"\"\n    Pretty print the object's representation.\n    \"\"\"\n    stream = StringIO()\n    printer = RepresentationPrinter(stream, verbose, max_width, newline)\n    printer.pretty(obj)\n    printer.flush()\n    return stream.getvalue()", "code_tokens": "def pretty ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : stream = StringIO ( ) printer = RepresentationPrinter ( stream , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) return stream . getvalue ( )", "docstring_tokens": "Pretty print the object s representation .", "label": 1}, {"idx": "cosqa-train-11636", "doc": "how to know queue size in python", "code": "def qsize(self):\n        \"\"\"Return the approximate size of the queue (not reliable!).\"\"\"\n        self.mutex.acquire()\n        n = self._qsize()\n        self.mutex.release()\n        return n", "code_tokens": "def qsize ( self ) : self . mutex . acquire ( ) n = self . _qsize ( ) self . mutex . release ( ) return n", "docstring_tokens": "Return the approximate size of the queue ( not reliable! ) .", "label": 1}, {"idx": "cosqa-train-11637", "doc": "python print on string with newline", "code": "def printOut(value, end='\\n'):\n    \"\"\"\n    This function prints the given String immediately and flushes the output.\n    \"\"\"\n    sys.stdout.write(value)\n    sys.stdout.write(end)\n    sys.stdout.flush()", "code_tokens": "def printOut ( value , end = '\\n' ) : sys . stdout . write ( value ) sys . stdout . write ( end ) sys . stdout . flush ( )", "docstring_tokens": "This function prints the given String immediately and flushes the output .", "label": 0}, {"idx": "cosqa-train-11638", "doc": "how to know size of queue in python", "code": "def qsize(self):\n        \"\"\"Return the approximate size of the queue (not reliable!).\"\"\"\n        self.mutex.acquire()\n        n = self._qsize()\n        self.mutex.release()\n        return n", "code_tokens": "def qsize ( self ) : self . mutex . acquire ( ) n = self . _qsize ( ) self . mutex . release ( ) return n", "docstring_tokens": "Return the approximate size of the queue ( not reliable! ) .", "label": 1}, {"idx": "cosqa-train-11639", "doc": "python print optionparser help", "code": "def help(self, level=0):\n        \"\"\"return the usage string for available options \"\"\"\n        self.cmdline_parser.formatter.output_level = level\n        with _patch_optparse():\n            return self.cmdline_parser.format_help()", "code_tokens": "def help ( self , level = 0 ) : self . cmdline_parser . formatter . output_level = level with _patch_optparse ( ) : return self . cmdline_parser . format_help ( )", "docstring_tokens": "return the usage string for available options", "label": 1}, {"idx": "cosqa-train-11640", "doc": "python print shape of tensor", "code": "def _shape(self):\n        \"\"\"Return the tensor shape of the matrix operator\"\"\"\n        return tuple(reversed(self.output_dims())) + tuple(\n            reversed(self.input_dims()))", "code_tokens": "def _shape ( self ) : return tuple ( reversed ( self . output_dims ( ) ) ) + tuple ( reversed ( self . input_dims ( ) ) )", "docstring_tokens": "Return the tensor shape of the matrix operator", "label": 1}, {"idx": "cosqa-train-11641", "doc": "how to list in array format in python", "code": "def to_list(self):\n        \"\"\"Convert this confusion matrix into a 2x2 plain list of values.\"\"\"\n        return [[int(self.table.cell_values[0][1]), int(self.table.cell_values[0][2])],\n                [int(self.table.cell_values[1][1]), int(self.table.cell_values[1][2])]]", "code_tokens": "def to_list ( self ) : return [ [ int ( self . table . cell_values [ 0 ] [ 1 ] ) , int ( self . table . cell_values [ 0 ] [ 2 ] ) ] , [ int ( self . table . cell_values [ 1 ] [ 1 ] ) , int ( self . table . cell_values [ 1 ] [ 2 ] ) ] ]", "docstring_tokens": "Convert this confusion matrix into a 2x2 plain list of values .", "label": 1}, {"idx": "cosqa-train-11642", "doc": "python print values for specified columns", "code": "def _get_printable_columns(columns, row):\n    \"\"\"Return only the part of the row which should be printed.\n    \"\"\"\n    if not columns:\n        return row\n\n    # Extract the column values, in the order specified.\n    return tuple(row[c] for c in columns)", "code_tokens": "def _get_printable_columns ( columns , row ) : if not columns : return row # Extract the column values, in the order specified. return tuple ( row [ c ] for c in columns )", "docstring_tokens": "Return only the part of the row which should be printed .", "label": 1}, {"idx": "cosqa-train-11643", "doc": "how to list the levels of a categorical variable in python", "code": "def nlevels(self):\n        \"\"\"\n        Get the number of factor levels for each categorical column.\n\n        :returns: A list of the number of levels per column.\n        \"\"\"\n        levels = self.levels()\n        return [len(l) for l in levels] if levels else 0", "code_tokens": "def nlevels ( self ) : levels = self . levels ( ) return [ len ( l ) for l in levels ] if levels else 0", "docstring_tokens": "Get the number of factor levels for each categorical column .", "label": 1}, {"idx": "cosqa-train-11644", "doc": "python printing dictionary in single quotes instead of double quotes", "code": "def _attrprint(d, delimiter=', '):\n    \"\"\"Print a dictionary of attributes in the DOT format\"\"\"\n    return delimiter.join(('\"%s\"=\"%s\"' % item) for item in sorted(d.items()))", "code_tokens": "def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '\"%s\"=\"%s\"' % item ) for item in sorted ( d . items ( ) ) )", "docstring_tokens": "Print a dictionary of attributes in the DOT format", "label": 1}, {"idx": "cosqa-train-11645", "doc": "how to load and execute a sql file in python", "code": "def _get_sql(filename):\n    \"\"\"Returns the contents of the sql file from the given ``filename``.\"\"\"\n    with open(os.path.join(SQL_DIR, filename), 'r') as f:\n        return f.read()", "code_tokens": "def _get_sql ( filename ) : with open ( os . path . join ( SQL_DIR , filename ) , 'r' ) as f : return f . read ( )", "docstring_tokens": "Returns the contents of the sql file from the given filename .", "label": 1}, {"idx": "cosqa-train-11646", "doc": "python process memory usage stats", "code": "def machine_info():\n    \"\"\"Retrieve core and memory information for the current machine.\n    \"\"\"\n    import psutil\n    BYTES_IN_GIG = 1073741824.0\n    free_bytes = psutil.virtual_memory().total\n    return [{\"memory\": float(\"%.1f\" % (free_bytes / BYTES_IN_GIG)), \"cores\": multiprocessing.cpu_count(),\n             \"name\": socket.gethostname()}]", "code_tokens": "def machine_info ( ) : import psutil BYTES_IN_GIG = 1073741824.0 free_bytes = psutil . virtual_memory ( ) . total return [ { \"memory\" : float ( \"%.1f\" % ( free_bytes / BYTES_IN_GIG ) ) , \"cores\" : multiprocessing . cpu_count ( ) , \"name\" : socket . gethostname ( ) } ]", "docstring_tokens": "Retrieve core and memory information for the current machine .", "label": 1}, {"idx": "cosqa-train-11647", "doc": "how to load text file to python", "code": "def Load(file):\n    \"\"\" Loads a model from specified file \"\"\"\n    with open(file, 'rb') as file:\n        model = dill.load(file)\n        return model", "code_tokens": "def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model", "docstring_tokens": "Loads a model from specified file", "label": 1}, {"idx": "cosqa-train-11648", "doc": "python proper way to get access token", "code": "def fetch_token(self, **kwargs):\n        \"\"\"Exchange a code (and 'state' token) for a bearer token\"\"\"\n        return super(AsanaOAuth2Session, self).fetch_token(self.token_url, client_secret=self.client_secret, **kwargs)", "code_tokens": "def fetch_token ( self , * * kwargs ) : return super ( AsanaOAuth2Session , self ) . fetch_token ( self . token_url , client_secret = self . client_secret , * * kwargs )", "docstring_tokens": "Exchange a code ( and state token ) for a bearer token", "label": 1}, {"idx": "cosqa-train-11649", "doc": "how to locate indices based on value in python", "code": "def index(m, val):\n    \"\"\"\n    Return the indices of all the ``val`` in ``m``\n    \"\"\"\n    mm = np.array(m)\n    idx_tuple = np.where(mm == val)\n    idx = idx_tuple[0].tolist()\n\n    return idx", "code_tokens": "def index ( m , val ) : mm = np . array ( m ) idx_tuple = np . where ( mm == val ) idx = idx_tuple [ 0 ] . tolist ( ) return idx", "docstring_tokens": "Return the indices of all the val in m", "label": 1}, {"idx": "cosqa-train-11650", "doc": "python property change event", "code": "def on_property_change(self, name, old_value, new_value):\n        \"\"\"\n        Called by the instance manager when a component property is modified\n\n        :param name: The changed property name\n        :param old_value: The previous property value\n        :param new_value: The new property value\n        \"\"\"\n        if self._registration is not None:\n            # use the registration to trigger the service event\n            self._registration.set_properties({name: new_value})", "code_tokens": "def on_property_change ( self , name , old_value , new_value ) : if self . _registration is not None : # use the registration to trigger the service event self . _registration . set_properties ( { name : new_value } )", "docstring_tokens": "Called by the instance manager when a component property is modified", "label": 1}, {"idx": "cosqa-train-11651", "doc": "how to locate python executable file on windows", "code": "def get_python():\n    \"\"\"Determine the path to the virtualenv python\"\"\"\n    if sys.platform == 'win32':\n        python = path.join(VE_ROOT, 'Scripts', 'python.exe')\n    else:\n        python = path.join(VE_ROOT, 'bin', 'python')\n    return python", "code_tokens": "def get_python ( ) : if sys . platform == 'win32' : python = path . join ( VE_ROOT , 'Scripts' , 'python.exe' ) else : python = path . join ( VE_ROOT , 'bin' , 'python' ) return python", "docstring_tokens": "Determine the path to the virtualenv python", "label": 1}, {"idx": "cosqa-train-11652", "doc": "python property with container", "code": "def get_property(self):\n        \"\"\"Establishes access of GettableProperty values\"\"\"\n\n        scope = self\n\n        def fget(self):\n            \"\"\"Call the HasProperties _get method\"\"\"\n            return self._get(scope.name)\n\n        return property(fget=fget, doc=scope.sphinx())", "code_tokens": "def get_property ( self ) : scope = self def fget ( self ) : \"\"\"Call the HasProperties _get method\"\"\" return self . _get ( scope . name ) return property ( fget = fget , doc = scope . sphinx ( ) )", "docstring_tokens": "Establishes access of GettableProperty values", "label": 1}, {"idx": "cosqa-train-11653", "doc": "how to lowercase text in python", "code": "def to_camel_case(text):\n    \"\"\"Convert to camel case.\n\n    :param str text:\n    :rtype: str\n    :return:\n    \"\"\"\n    split = text.split('_')\n    return split[0] + \"\".join(x.title() for x in split[1:])", "code_tokens": "def to_camel_case ( text ) : split = text . split ( '_' ) return split [ 0 ] + \"\" . join ( x . title ( ) for x in split [ 1 : ] )", "docstring_tokens": "Convert to camel case .", "label": 1}, {"idx": "cosqa-train-11654", "doc": "python proxy objects iterable", "code": "def load(self):\n        \"\"\"Load proxy list from configured proxy source\"\"\"\n        self._list = self._source.load()\n        self._list_iter = itertools.cycle(self._list)", "code_tokens": "def load ( self ) : self . _list = self . _source . load ( ) self . _list_iter = itertools . cycle ( self . _list )", "docstring_tokens": "Load proxy list from configured proxy source", "label": 1}, {"idx": "cosqa-train-11655", "doc": "how to make 80th percentile on python histogram", "code": "def ci(a, which=95, axis=None):\n    \"\"\"Return a percentile range from an array of values.\"\"\"\n    p = 50 - which / 2, 50 + which / 2\n    return percentiles(a, p, axis)", "code_tokens": "def ci ( a , which = 95 , axis = None ) : p = 50 - which / 2 , 50 + which / 2 return percentiles ( a , p , axis )", "docstring_tokens": "Return a percentile range from an array of values .", "label": 1}, {"idx": "cosqa-train-11656", "doc": "python pull image from url", "code": "def url_to_image(url):\n    \"\"\"\n    Fetch an image from url and convert it into a Pillow Image object\n    \"\"\"\n    r = requests.get(url)\n    image = StringIO(r.content)\n    return image", "code_tokens": "def url_to_image ( url ) : r = requests . get ( url ) image = StringIO ( r . content ) return image", "docstring_tokens": "Fetch an image from url and convert it into a Pillow Image object", "label": 1}, {"idx": "cosqa-train-11657", "doc": "how to make a 2d array with booleans in python", "code": "def is_bool_matrix(l):\n    r\"\"\"Checks if l is a 2D numpy array of bools\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 2 and (l.dtype == bool):\n            return True\n    return False", "code_tokens": "def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False", "docstring_tokens": "r Checks if l is a 2D numpy array of bools", "label": 1}, {"idx": "cosqa-train-11658", "doc": "python pull tables from sql database", "code": "def get_tablenames(cur):\n    \"\"\" Conveinience: \"\"\"\n    cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n    tablename_list_ = cur.fetchall()\n    tablename_list = [str(tablename[0]) for tablename in tablename_list_ ]\n    return tablename_list", "code_tokens": "def get_tablenames ( cur ) : cur . execute ( \"SELECT name FROM sqlite_master WHERE type='table'\" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list", "docstring_tokens": "Conveinience :", "label": 1}, {"idx": "cosqa-train-11659", "doc": "how to make a default arguement in function python", "code": "def arg_default(*args, **kwargs):\n    \"\"\"Return default argument value as given by argparse's add_argument().\n\n    The argument is passed through a mocked-up argument parser. This way, we\n    get default parameters even if the feature is called directly and not\n    through the CLI.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(*args, **kwargs)\n    args = vars(parser.parse_args([]))\n    _, default = args.popitem()\n    return default", "code_tokens": "def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default", "docstring_tokens": "Return default argument value as given by argparse s add_argument () .", "label": 1}, {"idx": "cosqa-train-11660", "doc": "python push to history undo", "code": "def end_of_history(event):\n    \"\"\"\n    Move to the end of the input history, i.e., the line currently being entered.\n    \"\"\"\n    event.current_buffer.history_forward(count=10**100)\n    buff = event.current_buffer\n    buff.go_to_history(len(buff._working_lines) - 1)", "code_tokens": "def end_of_history ( event ) : event . current_buffer . history_forward ( count = 10 ** 100 ) buff = event . current_buffer buff . go_to_history ( len ( buff . _working_lines ) - 1 )", "docstring_tokens": "Move to the end of the input history i . e . the line currently being entered .", "label": 1}, {"idx": "cosqa-train-11661", "doc": "how to make a dictionary from a string file python", "code": "def read_dict_from_file(file_path):\n    \"\"\"\n    Read a dictionary of strings from a file\n    \"\"\"\n    with open(file_path) as file:\n        lines = file.read().splitlines()\n\n    obj = {}\n    for line in lines:\n        key, value = line.split(':', maxsplit=1)\n        obj[key] = eval(value)\n\n    return obj", "code_tokens": "def read_dict_from_file ( file_path ) : with open ( file_path ) as file : lines = file . read ( ) . splitlines ( ) obj = { } for line in lines : key , value = line . split ( ':' , maxsplit = 1 ) obj [ key ] = eval ( value ) return obj", "docstring_tokens": "Read a dictionary of strings from a file", "label": 0}, {"idx": "cosqa-train-11662", "doc": "python put variables in a matrix", "code": "def a2s(a):\n    \"\"\"\n     convert 3,3 a matrix to 6 element \"s\" list  (see Tauxe 1998)\n    \"\"\"\n    s = np.zeros((6,), 'f')  # make the a matrix\n    for i in range(3):\n        s[i] = a[i][i]\n    s[3] = a[0][1]\n    s[4] = a[1][2]\n    s[5] = a[0][2]\n    return s", "code_tokens": "def a2s ( a ) : s = np . zeros ( ( 6 , ) , 'f' ) # make the a matrix for i in range ( 3 ) : s [ i ] = a [ i ] [ i ] s [ 3 ] = a [ 0 ] [ 1 ] s [ 4 ] = a [ 1 ] [ 2 ] s [ 5 ] = a [ 0 ] [ 2 ] return s", "docstring_tokens": "convert 3 3 a matrix to 6 element s list ( see Tauxe 1998 )", "label": 1}, {"idx": "cosqa-train-11663", "doc": "how to make a file open at a specific time with python", "code": "def fopen(name, mode='r', buffering=-1):\n    \"\"\"Similar to Python's built-in `open()` function.\"\"\"\n    f = _fopen(name, mode, buffering)\n    return _FileObjectThreadWithContext(f, mode, buffering)", "code_tokens": "def fopen ( name , mode = 'r' , buffering = - 1 ) : f = _fopen ( name , mode , buffering ) return _FileObjectThreadWithContext ( f , mode , buffering )", "docstring_tokens": "Similar to Python s built - in open () function .", "label": 1}, {"idx": "cosqa-train-11664", "doc": "python pykeyboard arrow key", "code": "def on_key_press(self, symbol, modifiers):\n        \"\"\"\n        Pyglet specific key press callback.\n        Forwards and translates the events to :py:func:`keyboard_event`\n        \"\"\"\n        self.keyboard_event(symbol, self.keys.ACTION_PRESS, modifiers)", "code_tokens": "def on_key_press ( self , symbol , modifiers ) : self . keyboard_event ( symbol , self . keys . ACTION_PRESS , modifiers )", "docstring_tokens": "Pyglet specific key press callback . Forwards and translates the events to : py : func : keyboard_event", "label": 1}, {"idx": "cosqa-train-11665", "doc": "how to make a function iterable python", "code": "def map(cls, iterable, func, *a, **kw):\n    \"\"\"\n    Iterable-first replacement of Python's built-in `map()` function.\n    \"\"\"\n\n    return cls(func(x, *a, **kw) for x in iterable)", "code_tokens": "def map ( cls , iterable , func , * a , * * kw ) : return cls ( func ( x , * a , * * kw ) for x in iterable )", "docstring_tokens": "Iterable - first replacement of Python s built - in map () function .", "label": 1}, {"idx": "cosqa-train-11666", "doc": "python pymongo change field value", "code": "def update_one(self, query, doc):\n        \"\"\"\n        Updates one element of the collection\n\n        :param query: dictionary representing the mongo query\n        :param doc: dictionary representing the item to be updated\n        :return: UpdateResult\n        \"\"\"\n        if self.table is None:\n            self.build_table()\n\n        if u\"$set\" in doc:\n            doc = doc[u\"$set\"]\n\n        allcond = self.parse_query(query)\n\n        try:\n            result = self.table.update(doc, allcond)\n        except:\n            # TODO: check table.update result\n            # check what pymongo does in that case\n            result = None\n\n        return UpdateResult(raw_result=result)", "code_tokens": "def update_one ( self , query , doc ) : if self . table is None : self . build_table ( ) if u\"$set\" in doc : doc = doc [ u\"$set\" ] allcond = self . parse_query ( query ) try : result = self . table . update ( doc , allcond ) except : # TODO: check table.update result # check what pymongo does in that case result = None return UpdateResult ( raw_result = result )", "docstring_tokens": "Updates one element of the collection", "label": 1}, {"idx": "cosqa-train-11667", "doc": "how to make a list into a dictionary in python", "code": "def list_of_lists_to_dict(l):\n    \"\"\" Convert list of key,value lists to dict\n\n    [['id', 1], ['id', 2], ['id', 3], ['foo': 4]]\n    {'id': [1, 2, 3], 'foo': [4]}\n    \"\"\"\n    d = {}\n    for key, val in l:\n        d.setdefault(key, []).append(val)\n    return d", "code_tokens": "def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d", "docstring_tokens": "Convert list of key value lists to dict", "label": 0}, {"idx": "cosqa-train-11668", "doc": "python pyodbc get value by column name", "code": "def _get_column_by_db_name(cls, name):\n        \"\"\"\n        Returns the column, mapped by db_field name\n        \"\"\"\n        return cls._columns.get(cls._db_map.get(name, name))", "code_tokens": "def _get_column_by_db_name ( cls , name ) : return cls . _columns . get ( cls . _db_map . get ( name , name ) )", "docstring_tokens": "Returns the column mapped by db_field name", "label": 1}, {"idx": "cosqa-train-11669", "doc": "python pypdf2 read document", "code": "def readme():\n    \"\"\"Try converting the README to an RST document. Return it as is on failure.\"\"\"\n    try:\n        import pypandoc\n        readme_content = pypandoc.convert('README.md', 'rst')\n    except(IOError, ImportError):\n        print(\"Warning: no pypandoc module found.\")\n        try:\n            readme_content = open('README.md').read()\n        except IOError:\n            readme_content = ''\n    return readme_content", "code_tokens": "def readme ( ) : try : import pypandoc readme_content = pypandoc . convert ( 'README.md' , 'rst' ) except ( IOError , ImportError ) : print ( \"Warning: no pypandoc module found.\" ) try : readme_content = open ( 'README.md' ) . read ( ) except IOError : readme_content = '' return readme_content", "docstring_tokens": "Try converting the README to an RST document . Return it as is on failure .", "label": 1}, {"idx": "cosqa-train-11670", "doc": "how to make a norm distribution in python", "code": "def ln_norm(x, mu, sigma=1.0):\n    \"\"\" Natural log of scipy norm function truncated at zero \"\"\"\n    return np.log(stats.norm(loc=mu, scale=sigma).pdf(x))", "code_tokens": "def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )", "docstring_tokens": "Natural log of scipy norm function truncated at zero", "label": 1}, {"idx": "cosqa-train-11671", "doc": "how to make a seconds to time in python", "code": "def time2seconds(t):\n    \"\"\"Returns seconds since 0h00.\"\"\"\n    return t.hour * 3600 + t.minute * 60 + t.second + float(t.microsecond) / 1e6", "code_tokens": "def time2seconds ( t ) : return t . hour * 3600 + t . minute * 60 + t . second + float ( t . microsecond ) / 1e6", "docstring_tokens": "Returns seconds since 0h00 .", "label": 1}, {"idx": "cosqa-train-11672", "doc": "python qcombobox change index not firing event", "code": "def _updateItemComboBoxIndex(self, item, column, num):\n        \"\"\"Callback for comboboxes: notifies us that a combobox for the given item and column has changed\"\"\"\n        item._combobox_current_index[column] = num\n        item._combobox_current_value[column] = item._combobox_option_list[column][num][0]", "code_tokens": "def _updateItemComboBoxIndex ( self , item , column , num ) : item . _combobox_current_index [ column ] = num item . _combobox_current_value [ column ] = item . _combobox_option_list [ column ] [ num ] [ 0 ]", "docstring_tokens": "Callback for comboboxes : notifies us that a combobox for the given item and column has changed", "label": 1}, {"idx": "cosqa-train-11673", "doc": "how to make a username and password on python", "code": "def get_auth():\n    \"\"\"Get authentication.\"\"\"\n    import getpass\n    user = input(\"User Name: \")  # noqa\n    pswd = getpass.getpass('Password: ')\n    return Github(user, pswd)", "code_tokens": "def get_auth ( ) : import getpass user = input ( \"User Name: \" ) # noqa pswd = getpass . getpass ( 'Password: ' ) return Github ( user , pswd )", "docstring_tokens": "Get authentication .", "label": 1}, {"idx": "cosqa-train-11674", "doc": "python querystring value not there", "code": "def parse_querystring(self, req, name, field):\n        \"\"\"Pull a querystring value from the request.\"\"\"\n        return core.get_value(req.args, name, field)", "code_tokens": "def parse_querystring ( self , req , name , field ) : return core . get_value ( req . args , name , field )", "docstring_tokens": "Pull a querystring value from the request .", "label": 1}, {"idx": "cosqa-train-11675", "doc": "how to make an array of one element in python", "code": "def flatten_list(l):\n    \"\"\" Nested lists to single-level list, does not split strings\"\"\"\n    return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "code_tokens": "def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )", "docstring_tokens": "Nested lists to single - level list does not split strings", "label": 1}, {"idx": "cosqa-train-11676", "doc": "python quotion mark and single quote", "code": "def represented_args(args, separator=\" \"):\n    \"\"\"\n    Args:\n        args (list | tuple | None): Arguments to represent\n        separator (str | unicode): Separator to use\n\n    Returns:\n        (str): Quoted as needed textual representation\n    \"\"\"\n    result = []\n    if args:\n        for text in args:\n            result.append(quoted(short(text)))\n    return separator.join(result)", "code_tokens": "def represented_args ( args , separator = \" \" ) : result = [ ] if args : for text in args : result . append ( quoted ( short ( text ) ) ) return separator . join ( result )", "docstring_tokens": "Args : args ( list | tuple | None ) : Arguments to represent separator ( str | unicode ) : Separator to use", "label": 1}, {"idx": "cosqa-train-11677", "doc": "how to make an error message in python", "code": "def err(msg):\n    \"\"\"Pretty-print an error.\"\"\"\n    click.echo(click.style(msg, fg=\"red\", bold=True))", "code_tokens": "def err ( msg ) : click . echo ( click . style ( msg , fg = \"red\" , bold = True ) )", "docstring_tokens": "Pretty - print an error .", "label": 1}, {"idx": "cosqa-train-11678", "doc": "python rabbitmq channel reconnect", "code": "def reconnect(self):\n        \"\"\"Reconnect to rabbitmq server\"\"\"\n        import pika\n        import pika.exceptions\n\n        self.connection = pika.BlockingConnection(pika.URLParameters(self.amqp_url))\n        self.channel = self.connection.channel()\n        try:\n            self.channel.queue_declare(self.name)\n        except pika.exceptions.ChannelClosed:\n            self.connection = pika.BlockingConnection(pika.URLParameters(self.amqp_url))\n            self.channel = self.connection.channel()", "code_tokens": "def reconnect ( self ) : import pika import pika . exceptions self . connection = pika . BlockingConnection ( pika . URLParameters ( self . amqp_url ) ) self . channel = self . connection . channel ( ) try : self . channel . queue_declare ( self . name ) except pika . exceptions . ChannelClosed : self . connection = pika . BlockingConnection ( pika . URLParameters ( self . amqp_url ) ) self . channel = self . connection . channel ( )", "docstring_tokens": "Reconnect to rabbitmq server", "label": 1}, {"idx": "cosqa-train-11679", "doc": "how to make astype list python", "code": "def flatten(l, types=(list, float)):\n    \"\"\"\n    Flat nested list of lists into a single list.\n    \"\"\"\n    l = [item if isinstance(item, types) else [item] for item in l]\n    return [item for sublist in l for item in sublist]", "code_tokens": "def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Flat nested list of lists into a single list .", "label": 1}, {"idx": "cosqa-train-11680", "doc": "how to make matrix sparse python", "code": "def is_sparse_vector(x):\n    \"\"\" x is a 2D sparse matrix with it's first shape equal to 1.\n    \"\"\"\n    return sp.issparse(x) and len(x.shape) == 2 and x.shape[0] == 1", "code_tokens": "def is_sparse_vector ( x ) : return sp . issparse ( x ) and len ( x . shape ) == 2 and x . shape [ 0 ] == 1", "docstring_tokens": "x is a 2D sparse matrix with it s first shape equal to 1 .", "label": 1}, {"idx": "cosqa-train-11681", "doc": "python raise without try", "code": "def _re_raise_as(NewExc, *args, **kw):\n    \"\"\"Raise a new exception using the preserved traceback of the last one.\"\"\"\n    etype, val, tb = sys.exc_info()\n    raise NewExc(*args, **kw), None, tb", "code_tokens": "def _re_raise_as ( NewExc , * args , * * kw ) : etype , val , tb = sys . exc_info ( ) raise NewExc ( * args , * * kw ) , None , tb", "docstring_tokens": "Raise a new exception using the preserved traceback of the last one .", "label": 1}, {"idx": "cosqa-train-11682", "doc": "how to make method into decoractor in python", "code": "def _iterable_to_varargs_method(func):\n    \"\"\"decorator to convert a method taking a iterable to a *args one\"\"\"\n    def wrapped(self, *args, **kwargs):\n        return func(self, args, **kwargs)\n    return wrapped", "code_tokens": "def _iterable_to_varargs_method ( func ) : def wrapped ( self , * args , * * kwargs ) : return func ( self , args , * * kwargs ) return wrapped", "docstring_tokens": "decorator to convert a method taking a iterable to a * args one", "label": 1}, {"idx": "cosqa-train-11683", "doc": "python raising to a power using for loop", "code": "async def power(source, exponent):\n    \"\"\"Raise the elements of an asynchronous sequence to the given power.\"\"\"\n    async with streamcontext(source) as streamer:\n        async for item in streamer:\n            yield item ** exponent", "code_tokens": "async def power ( source , exponent ) : async with streamcontext ( source ) as streamer : async for item in streamer : yield item ** exponent", "docstring_tokens": "Raise the elements of an asynchronous sequence to the given power .", "label": 1}, {"idx": "cosqa-train-11684", "doc": "how to make multi lined code in python", "code": "def  make_html_code( self, lines ):\n        \"\"\" convert a code sequence to HTML \"\"\"\n        line = code_header + '\\n'\n        for l in lines:\n            line = line + html_quote( l ) + '\\n'\n\n        return line + code_footer", "code_tokens": "def make_html_code ( self , lines ) : line = code_header + '\\n' for l in lines : line = line + html_quote ( l ) + '\\n' return line + code_footer", "docstring_tokens": "convert a code sequence to HTML", "label": 1}, {"idx": "cosqa-train-11685", "doc": "python random pseudo gaussian noise", "code": "def rlognormal(mu, tau, size=None):\n    \"\"\"\n    Return random lognormal variates.\n    \"\"\"\n\n    return np.random.lognormal(mu, np.sqrt(1. / tau), size)", "code_tokens": "def rlognormal ( mu , tau , size = None ) : return np . random . lognormal ( mu , np . sqrt ( 1. / tau ) , size )", "docstring_tokens": "Return random lognormal variates .", "label": 1}, {"idx": "cosqa-train-11686", "doc": "how to make python into binding", "code": "def main(ctx, connection):\n    \"\"\"Command line interface for PyBEL.\"\"\"\n    ctx.obj = Manager(connection=connection)\n    ctx.obj.bind()", "code_tokens": "def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )", "docstring_tokens": "Command line interface for PyBEL .", "label": 1}, {"idx": "cosqa-train-11687", "doc": "python random selection from function", "code": "def sometimesish(fn):\n    \"\"\"\n    Has a 50/50 chance of calling a function\n    \"\"\"\n    def wrapped(*args, **kwargs):\n        if random.randint(1, 2) == 1:\n            return fn(*args, **kwargs)\n\n    return wrapped", "code_tokens": "def sometimesish ( fn ) : def wrapped ( * args , * * kwargs ) : if random . randint ( 1 , 2 ) == 1 : return fn ( * args , * * kwargs ) return wrapped", "docstring_tokens": "Has a 50 / 50 chance of calling a function", "label": 1}, {"idx": "cosqa-train-11688", "doc": "how to make sprites move up and down in python", "code": "def move_back(self, dt):\n        \"\"\" If called after an update, the sprite can move back\n        \"\"\"\n        self._position = self._old_position\n        self.rect.topleft = self._position\n        self.feet.midbottom = self.rect.midbottom", "code_tokens": "def move_back ( self , dt ) : self . _position = self . _old_position self . rect . topleft = self . _position self . feet . midbottom = self . rect . midbottom", "docstring_tokens": "If called after an update the sprite can move back", "label": 1}, {"idx": "cosqa-train-11689", "doc": "python random tuple between min and max", "code": "def random_color(_min=MIN_COLOR, _max=MAX_COLOR):\n    \"\"\"Returns a random color between min and max.\"\"\"\n    return color(random.randint(_min, _max))", "code_tokens": "def random_color ( _min = MIN_COLOR , _max = MAX_COLOR ) : return color ( random . randint ( _min , _max ) )", "docstring_tokens": "Returns a random color between min and max .", "label": 1}, {"idx": "cosqa-train-11690", "doc": "how to make text widget scrollable in python", "code": "def startEdit( self ):\n        \"\"\"\n        Rebuilds the pathing based on the parts.\n        \"\"\"\n        self._originalText = self.text()\n        self.scrollWidget().hide()\n        self.setFocus()\n        self.selectAll()", "code_tokens": "def startEdit ( self ) : self . _originalText = self . text ( ) self . scrollWidget ( ) . hide ( ) self . setFocus ( ) self . selectAll ( )", "docstring_tokens": "Rebuilds the pathing based on the parts .", "label": 1}, {"idx": "cosqa-train-11691", "doc": "python read a geojson file", "code": "def _loadfilepath(self, filepath, **kwargs):\n        \"\"\"This loads a geojson file into a geojson python\n        dictionary using the json module.\n        \n        Note: to load with a different text encoding use the encoding argument.\n        \"\"\"\n        with open(filepath, \"r\") as f:\n            data = json.load(f, **kwargs)\n        return data", "code_tokens": "def _loadfilepath ( self , filepath , * * kwargs ) : with open ( filepath , \"r\" ) as f : data = json . load ( f , * * kwargs ) return data", "docstring_tokens": "This loads a geojson file into a geojson python dictionary using the json module . Note : to load with a different text encoding use the encoding argument .", "label": 0}, {"idx": "cosqa-train-11692", "doc": "how to make the legend box outside python", "code": "def mpl_outside_legend(ax, **kwargs):\n    \"\"\" Places a legend box outside a matplotlib Axes instance. \"\"\"\n    box = ax.get_position()\n    ax.set_position([box.x0, box.y0, box.width * 0.75, box.height])\n    # Put a legend to the right of the current axis\n    ax.legend(loc='upper left', bbox_to_anchor=(1, 1), **kwargs)", "code_tokens": "def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )", "docstring_tokens": "Places a legend box outside a matplotlib Axes instance .", "label": 1}, {"idx": "cosqa-train-11693", "doc": "python read a yml file", "code": "def ReadManyFromPath(filepath):\n  \"\"\"Reads a Python object stored in a specified YAML file.\n\n  Args:\n    filepath: A filepath to the YAML file.\n\n  Returns:\n    A Python data structure corresponding to the YAML in the given file.\n  \"\"\"\n  with io.open(filepath, mode=\"r\", encoding=\"utf-8\") as filedesc:\n    return ReadManyFromFile(filedesc)", "code_tokens": "def ReadManyFromPath ( filepath ) : with io . open ( filepath , mode = \"r\" , encoding = \"utf-8\" ) as filedesc : return ReadManyFromFile ( filedesc )", "docstring_tokens": "Reads a Python object stored in a specified YAML file .", "label": 1}, {"idx": "cosqa-train-11694", "doc": "how to make the python garbage collector run", "code": "def _clean_workers(self):\n        \"\"\"Delete periodically workers in workers bag.\"\"\"\n        while self._bag_collector:\n            self._bag_collector.popleft()\n        self._timer_worker_delete.stop()", "code_tokens": "def _clean_workers ( self ) : while self . _bag_collector : self . _bag_collector . popleft ( ) self . _timer_worker_delete . stop ( )", "docstring_tokens": "Delete periodically workers in workers bag .", "label": 1}, {"idx": "cosqa-train-11695", "doc": "python read big and little endian", "code": "def read_data(file, endian, num=1):\n    \"\"\"\n    Read a given number of 32-bits unsigned integers from the given file\n    with the given endianness.\n    \"\"\"\n    res = struct.unpack(endian + 'L' * num, file.read(num * 4))\n    if len(res) == 1:\n        return res[0]\n    return res", "code_tokens": "def read_data ( file , endian , num = 1 ) : res = struct . unpack ( endian + 'L' * num , file . read ( num * 4 ) ) if len ( res ) == 1 : return res [ 0 ] return res", "docstring_tokens": "Read a given number of 32 - bits unsigned integers from the given file with the given endianness .", "label": 1}, {"idx": "cosqa-train-11696", "doc": "how to make toggle button in python", "code": "def disable(self):\n        \"\"\"\n        Disable the button, if in non-expert mode;\n        unset its activity flag come-what-may.\n        \"\"\"\n        if not self._expert:\n            self.config(state='disable')\n        self._active = False", "code_tokens": "def disable ( self ) : if not self . _expert : self . config ( state = 'disable' ) self . _active = False", "docstring_tokens": "Disable the button if in non - expert mode ; unset its activity flag come - what - may .", "label": 0}, {"idx": "cosqa-train-11697", "doc": "python read config, yaml", "code": "def _parse_config(config_file_path):\n    \"\"\" Parse Config File from yaml file. \"\"\"\n    config_file = open(config_file_path, 'r')\n    config = yaml.load(config_file)\n    config_file.close()\n    return config", "code_tokens": "def _parse_config ( config_file_path ) : config_file = open ( config_file_path , 'r' ) config = yaml . load ( config_file ) config_file . close ( ) return config", "docstring_tokens": "Parse Config File from yaml file .", "label": 1}, {"idx": "cosqa-train-11698", "doc": "how to manually apply image filter in python", "code": "def filter_contour(imageFile, opFile):\n    \"\"\" convert an image by applying a contour \"\"\"\n    im = Image.open(imageFile)\n    im1 = im.filter(ImageFilter.CONTOUR)\n    im1.save(opFile)", "code_tokens": "def filter_contour ( imageFile , opFile ) : im = Image . open ( imageFile ) im1 = im . filter ( ImageFilter . CONTOUR ) im1 . save ( opFile )", "docstring_tokens": "convert an image by applying a contour", "label": 1}, {"idx": "cosqa-train-11699", "doc": "python read dicom images", "code": "def numpy(self):\n        \"\"\" Grabs image data and converts it to a numpy array \"\"\"\n        # load GDCM's image reading functionality\n        image_reader = gdcm.ImageReader()\n        image_reader.SetFileName(self.fname)\n        if not image_reader.Read():\n            raise IOError(\"Could not read DICOM image\")\n        pixel_array = self._gdcm_to_numpy(image_reader.GetImage())\n        return pixel_array", "code_tokens": "def numpy ( self ) : # load GDCM's image reading functionality image_reader = gdcm . ImageReader ( ) image_reader . SetFileName ( self . fname ) if not image_reader . Read ( ) : raise IOError ( \"Could not read DICOM image\" ) pixel_array = self . _gdcm_to_numpy ( image_reader . GetImage ( ) ) return pixel_array", "docstring_tokens": "Grabs image data and converts it to a numpy array", "label": 1}, {"idx": "cosqa-train-11700", "doc": "how to measure execution time of python function", "code": "def timedcall(executable_function, *args):\n    \"\"\"!\n    @brief Executes specified method or function with measuring of execution time.\n    \n    @param[in] executable_function (pointer): Pointer to function or method.\n    @param[in] args (*): Arguments of called function or method.\n    \n    @return (tuple) Execution time and result of execution of function or method (execution_time, result_execution).\n    \n    \"\"\"\n    \n    time_start = time.clock();\n    result = executable_function(*args);\n    time_end = time.clock();\n    \n    return (time_end - time_start, result);", "code_tokens": "def timedcall ( executable_function , * args ) : time_start = time . clock ( ) result = executable_function ( * args ) time_end = time . clock ( ) return ( time_end - time_start , result )", "docstring_tokens": "!", "label": 1}, {"idx": "cosqa-train-11701", "doc": "python read file 'int' object is not callable", "code": "def _fast_read(self, infile):\n        \"\"\"Function for fast reading from sensor files.\"\"\"\n        infile.seek(0)\n        return(int(infile.read().decode().strip()))", "code_tokens": "def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )", "docstring_tokens": "Function for fast reading from sensor files .", "label": 1}, {"idx": "cosqa-train-11702", "doc": "how to merge cells in python", "code": "def wr_row_mergeall(self, worksheet, txtstr, fmt, row_idx):\n        \"\"\"Merge all columns and place text string in widened cell.\"\"\"\n        hdridxval = len(self.hdrs) - 1\n        worksheet.merge_range(row_idx, 0, row_idx, hdridxval, txtstr, fmt)\n        return row_idx + 1", "code_tokens": "def wr_row_mergeall ( self , worksheet , txtstr , fmt , row_idx ) : hdridxval = len ( self . hdrs ) - 1 worksheet . merge_range ( row_idx , 0 , row_idx , hdridxval , txtstr , fmt ) return row_idx + 1", "docstring_tokens": "Merge all columns and place text string in widened cell .", "label": 1}, {"idx": "cosqa-train-11703", "doc": "python read file as 0's and 1's", "code": "def _fast_read(self, infile):\n        \"\"\"Function for fast reading from sensor files.\"\"\"\n        infile.seek(0)\n        return(int(infile.read().decode().strip()))", "code_tokens": "def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )", "docstring_tokens": "Function for fast reading from sensor files .", "label": 0}, {"idx": "cosqa-train-11704", "doc": "how to modify tensorflow lite c++ to python", "code": "def _int64_feature(value):\n  \"\"\"Wrapper for inserting int64 features into Example proto.\"\"\"\n  if not isinstance(value, list):\n    value = [value]\n  return tf.train.Feature(int64_list=tf.train.Int64List(value=value))", "code_tokens": "def _int64_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( int64_list = tf . train . Int64List ( value = value ) )", "docstring_tokens": "Wrapper for inserting int64 features into Example proto .", "label": 1}, {"idx": "cosqa-train-11705", "doc": "python read file json with", "code": "def open_json(file_name):\n    \"\"\"\n    returns json contents as string\n    \"\"\"\n    with open(file_name, \"r\") as json_data:\n        data = json.load(json_data)\n        return data", "code_tokens": "def open_json ( file_name ) : with open ( file_name , \"r\" ) as json_data : data = json . load ( json_data ) return data", "docstring_tokens": "returns json contents as string", "label": 1}, {"idx": "cosqa-train-11706", "doc": "how to mount connection string externally for he docker in python", "code": "def attach_to_container(self, container_id):\n        \"\"\" A socket attached to the stdin/stdout of a container. The object returned contains a get_socket() function to get a socket.socket\n        object and  close_socket() to close the connection \"\"\"\n        sock = self._docker.containers.get(container_id).attach_socket(params={\n            'stdin': 1,\n            'stdout': 1,\n            'stderr': 0,\n            'stream': 1,\n        })\n        # fix a problem with docker-py; we must keep a reference of sock at every time\n        return FixDockerSocket(sock)", "code_tokens": "def attach_to_container ( self , container_id ) : sock = self . _docker . containers . get ( container_id ) . attach_socket ( params = { 'stdin' : 1 , 'stdout' : 1 , 'stderr' : 0 , 'stream' : 1 , } ) # fix a problem with docker-py; we must keep a reference of sock at every time return FixDockerSocket ( sock )", "docstring_tokens": "A socket attached to the stdin / stdout of a container . The object returned contains a get_socket () function to get a socket . socket object and close_socket () to close the connection", "label": 1}, {"idx": "cosqa-train-11707", "doc": "python read from stdin till input stops", "code": "def _read_stdin():\n    \"\"\"\n    Generator for reading from standard input in nonblocking mode.\n\n    Other ways of reading from ``stdin`` in python waits, until the buffer is\n    big enough, or until EOF character is sent.\n\n    This functions yields immediately after each line.\n    \"\"\"\n    line = sys.stdin.readline()\n    while line:\n        yield line\n        line = sys.stdin.readline()", "code_tokens": "def _read_stdin ( ) : line = sys . stdin . readline ( ) while line : yield line line = sys . stdin . readline ( )", "docstring_tokens": "Generator for reading from standard input in nonblocking mode .", "label": 1}, {"idx": "cosqa-train-11708", "doc": "how to move a row up in python", "code": "def move_up(lines=1, file=sys.stdout):\n    \"\"\" Move the cursor up a number of lines.\n\n        Esc[ValueA:\n        Moves the cursor up by the specified number of lines without changing\n        columns. If the cursor is already on the top line, ANSI.SYS ignores\n        this sequence.\n    \"\"\"\n    move.up(lines).write(file=file)", "code_tokens": "def move_up ( lines = 1 , file = sys . stdout ) : move . up ( lines ) . write ( file = file )", "docstring_tokens": "Move the cursor up a number of lines .", "label": 1}, {"idx": "cosqa-train-11709", "doc": "python read json as ordered dictionary", "code": "def _read_json_file(self, json_file):\n        \"\"\" Helper function to read JSON file as OrderedDict \"\"\"\n\n        self.log.debug(\"Reading '%s' JSON file...\" % json_file)\n\n        with open(json_file, 'r') as f:\n            return json.load(f, object_pairs_hook=OrderedDict)", "code_tokens": "def _read_json_file ( self , json_file ) : self . log . debug ( \"Reading '%s' JSON file...\" % json_file ) with open ( json_file , 'r' ) as f : return json . load ( f , object_pairs_hook = OrderedDict )", "docstring_tokens": "Helper function to read JSON file as OrderedDict", "label": 1}, {"idx": "cosqa-train-11710", "doc": "how to move the legend on python lower left", "code": "def mpl_outside_legend(ax, **kwargs):\n    \"\"\" Places a legend box outside a matplotlib Axes instance. \"\"\"\n    box = ax.get_position()\n    ax.set_position([box.x0, box.y0, box.width * 0.75, box.height])\n    # Put a legend to the right of the current axis\n    ax.legend(loc='upper left', bbox_to_anchor=(1, 1), **kwargs)", "code_tokens": "def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )", "docstring_tokens": "Places a legend box outside a matplotlib Axes instance .", "label": 1}, {"idx": "cosqa-train-11711", "doc": "python read json from web", "code": "def get(url):\n    \"\"\"Recieving the JSON file from uulm\"\"\"\n    response = urllib.request.urlopen(url)\n    data = response.read()\n    data = data.decode(\"utf-8\")\n    data = json.loads(data)\n    return data", "code_tokens": "def get ( url ) : response = urllib . request . urlopen ( url ) data = response . read ( ) data = data . decode ( \"utf-8\" ) data = json . loads ( data ) return data", "docstring_tokens": "Recieving the JSON file from uulm", "label": 1}, {"idx": "cosqa-train-11712", "doc": "how to normalize a string in python", "code": "def normalize(self, string):\n        \"\"\"Normalize the string according to normalization list\"\"\"\n        return ''.join([self._normalize.get(x, x) for x in nfd(string)])", "code_tokens": "def normalize ( self , string ) : return '' . join ( [ self . _normalize . get ( x , x ) for x in nfd ( string ) ] )", "docstring_tokens": "Normalize the string according to normalization list", "label": 1}, {"idx": "cosqa-train-11713", "doc": "python read json iterate", "code": "def json_iter (path):\n    \"\"\"\n    iterator for JSON-per-line in a file pattern\n    \"\"\"\n    with open(path, 'r') as f:\n        for line in f.readlines():\n            yield json.loads(line)", "code_tokens": "def json_iter ( path ) : with open ( path , 'r' ) as f : for line in f . readlines ( ) : yield json . loads ( line )", "docstring_tokens": "iterator for JSON - per - line in a file pattern", "label": 1}, {"idx": "cosqa-train-11714", "doc": "how to order a dictionary into keys in python", "code": "def flattened_nested_key_indices(nested_dict):\n    \"\"\"\n    Combine the outer and inner keys of nested dictionaries into a single\n    ordering.\n    \"\"\"\n    outer_keys, inner_keys = collect_nested_keys(nested_dict)\n    combined_keys = list(sorted(set(outer_keys + inner_keys)))\n    return {k: i for (i, k) in enumerate(combined_keys)}", "code_tokens": "def flattened_nested_key_indices ( nested_dict ) : outer_keys , inner_keys = collect_nested_keys ( nested_dict ) combined_keys = list ( sorted ( set ( outer_keys + inner_keys ) ) ) return { k : i for ( i , k ) in enumerate ( combined_keys ) }", "docstring_tokens": "Combine the outer and inner keys of nested dictionaries into a single ordering .", "label": 1}, {"idx": "cosqa-train-11715", "doc": "python read one fom stdin", "code": "def read_stdin():\n    \"\"\" Read text from stdin, and print a helpful message for ttys. \"\"\"\n    if sys.stdin.isatty() and sys.stdout.isatty():\n        print('\\nReading from stdin until end of file (Ctrl + D)...')\n\n    return sys.stdin.read()", "code_tokens": "def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )", "docstring_tokens": "Read text from stdin and print a helpful message for ttys .", "label": 1}, {"idx": "cosqa-train-11716", "doc": "how to pad with zero in python", "code": "def zero_pad(m, n=1):\n    \"\"\"Pad a matrix with zeros, on all sides.\"\"\"\n    return np.pad(m, (n, n), mode='constant', constant_values=[0])", "code_tokens": "def zero_pad ( m , n = 1 ) : return np . pad ( m , ( n , n ) , mode = 'constant' , constant_values = [ 0 ] )", "docstring_tokens": "Pad a matrix with zeros on all sides .", "label": 1}, {"idx": "cosqa-train-11717", "doc": "python read pickle to numpy array", "code": "def _openResources(self):\n        \"\"\" Uses numpy.load to open the underlying file\n        \"\"\"\n        arr = np.load(self._fileName, allow_pickle=ALLOW_PICKLE)\n        check_is_an_array(arr)\n        self._array = arr", "code_tokens": "def _openResources ( self ) : arr = np . load ( self . _fileName , allow_pickle = ALLOW_PICKLE ) check_is_an_array ( arr ) self . _array = arr", "docstring_tokens": "Uses numpy . load to open the underlying file", "label": 1}, {"idx": "cosqa-train-11718", "doc": "how to pass lists into json python", "code": "def save_list(key, *values):\n    \"\"\"Convert the given list of parameters to a JSON object.\n\n    JSON object is of the form:\n    { key: [values[0], values[1], ... ] },\n    where values represent the given list of parameters.\n\n    \"\"\"\n    return json.dumps({key: [_get_json(value) for value in values]})", "code_tokens": "def save_list ( key , * values ) : return json . dumps ( { key : [ _get_json ( value ) for value in values ] } )", "docstring_tokens": "Convert the given list of parameters to a JSON object .", "label": 1}, {"idx": "cosqa-train-11719", "doc": "python read text file as corpus", "code": "def read_corpus(file_name):\n    \"\"\"\n    Read and return the data from a corpus json file.\n    \"\"\"\n    with io.open(file_name, encoding='utf-8') as data_file:\n        return yaml.load(data_file)", "code_tokens": "def read_corpus ( file_name ) : with io . open ( file_name , encoding = 'utf-8' ) as data_file : return yaml . load ( data_file )", "docstring_tokens": "Read and return the data from a corpus json file .", "label": 1}, {"idx": "cosqa-train-11720", "doc": "how to pass two dynamic arguements using function in python", "code": "def trigger(self, target: str, trigger: str, parameters: Dict[str, Any]={}):\n\t\t\"\"\"Calls the specified Trigger of another Area with the optionally given parameters.\n\n\t\tArgs:\n\t\t\ttarget: The name of the target Area.\n\t\t\ttrigger: The name of the Trigger.\n\t\t\tparameters: The parameters of the function call.\n\t\t\"\"\"\n\t\tpass", "code_tokens": "def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass", "docstring_tokens": "Calls the specified Trigger of another Area with the optionally given parameters .", "label": 1}, {"idx": "cosqa-train-11721", "doc": "python read top n lines of a file", "code": "def head(filename, n=10):\n    \"\"\" prints the top `n` lines of a file \"\"\"\n    with freader(filename) as fr:\n        for _ in range(n):\n            print(fr.readline().strip())", "code_tokens": "def head ( filename , n = 10 ) : with freader ( filename ) as fr : for _ in range ( n ) : print ( fr . readline ( ) . strip ( ) )", "docstring_tokens": "prints the top n lines of a file", "label": 1}, {"idx": "cosqa-train-11722", "doc": "how to pickle and send over python socket", "code": "def send(socket, data, num_bytes=20):\n    \"\"\"Send data to specified socket.\n\n\n    :param socket: open socket instance\n    :param data: data to send\n    :param num_bytes: number of bytes to read\n\n    :return: received data\n    \"\"\"\n    pickled_data = pickle.dumps(data, -1)\n    length = str(len(pickled_data)).zfill(num_bytes)\n    socket.sendall(length.encode())\n    socket.sendall(pickled_data)", "code_tokens": "def send ( socket , data , num_bytes = 20 ) : pickled_data = pickle . dumps ( data , - 1 ) length = str ( len ( pickled_data ) ) . zfill ( num_bytes ) socket . sendall ( length . encode ( ) ) socket . sendall ( pickled_data )", "docstring_tokens": "Send data to specified socket .", "label": 0}, {"idx": "cosqa-train-11723", "doc": "python read until end", "code": "def _readuntil(f, end=_TYPE_END):\n\t\"\"\"Helper function to read bytes until a certain end byte is hit\"\"\"\n\tbuf = bytearray()\n\tbyte = f.read(1)\n\twhile byte != end:\n\t\tif byte == b'':\n\t\t\traise ValueError('File ended unexpectedly. Expected end byte {}.'.format(end))\n\t\tbuf += byte\n\t\tbyte = f.read(1)\n\treturn buf", "code_tokens": "def _readuntil ( f , end = _TYPE_END ) : buf = bytearray ( ) byte = f . read ( 1 ) while byte != end : if byte == b'' : raise ValueError ( 'File ended unexpectedly. Expected end byte {}.' . format ( end ) ) buf += byte byte = f . read ( 1 ) return buf", "docstring_tokens": "Helper function to read bytes until a certain end byte is hit", "label": 1}, {"idx": "cosqa-train-11724", "doc": "how to pop a value off an stack that is a fixed array in python 3", "code": "def push(h, x):\n    \"\"\"Push a new value into heap.\"\"\"\n    h.push(x)\n    up(h, h.size()-1)", "code_tokens": "def push ( h , x ) : h . push ( x ) up ( h , h . size ( ) - 1 )", "docstring_tokens": "Push a new value into heap .", "label": 1}, {"idx": "cosqa-train-11725", "doc": "python read windows clipboard", "code": "def osx_clipboard_get():\n    \"\"\" Get the clipboard's text on OS X.\n    \"\"\"\n    p = subprocess.Popen(['pbpaste', '-Prefer', 'ascii'],\n        stdout=subprocess.PIPE)\n    text, stderr = p.communicate()\n    # Text comes in with old Mac \\r line endings. Change them to \\n.\n    text = text.replace('\\r', '\\n')\n    return text", "code_tokens": "def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \\r line endings. Change them to \\n. text = text . replace ( '\\r' , '\\n' ) return text", "docstring_tokens": "Get the clipboard s text on OS X .", "label": 0}, {"idx": "cosqa-train-11726", "doc": "how to print an objects attributes python", "code": "def _repr(obj):\n    \"\"\"Show the received object as precise as possible.\"\"\"\n    vals = \", \".join(\"{}={!r}\".format(\n        name, getattr(obj, name)) for name in obj._attribs)\n    if vals:\n        t = \"{}(name={}, {})\".format(obj.__class__.__name__, obj.name, vals)\n    else:\n        t = \"{}(name={})\".format(obj.__class__.__name__, obj.name)\n    return t", "code_tokens": "def _repr ( obj ) : vals = \", \" . join ( \"{}={!r}\" . format ( name , getattr ( obj , name ) ) for name in obj . _attribs ) if vals : t = \"{}(name={}, {})\" . format ( obj . __class__ . __name__ , obj . name , vals ) else : t = \"{}(name={})\" . format ( obj . __class__ . __name__ , obj . name ) return t", "docstring_tokens": "Show the received object as precise as possible .", "label": 0}, {"idx": "cosqa-train-11727", "doc": "python read words to list in lowercase", "code": "def camelcase2list(s, lower=False):\n    \"\"\"Converts a camelcase string to a list.\"\"\"\n    s = re.findall(r'([A-Z][a-z0-9]+)', s)\n    return [w.lower() for w in s] if lower else s", "code_tokens": "def camelcase2list ( s , lower = False ) : s = re . findall ( r'([A-Z][a-z0-9]+)' , s ) return [ w . lower ( ) for w in s ] if lower else s", "docstring_tokens": "Converts a camelcase string to a list .", "label": 1}, {"idx": "cosqa-train-11728", "doc": "how to print only one return value in python", "code": "def print(*a):\n    \"\"\" print just one that returns what you give it instead of None \"\"\"\n    try:\n        _print(*a)\n        return a[0] if len(a) == 1 else a\n    except:\n        _print(*a)", "code_tokens": "def print ( * a ) : try : _print ( * a ) return a [ 0 ] if len ( a ) == 1 else a except : _print ( * a )", "docstring_tokens": "print just one that returns what you give it instead of None", "label": 1}, {"idx": "cosqa-train-11729", "doc": "python received a naive datetime", "code": "def get_naive(dt):\n  \"\"\"Gets a naive datetime from a datetime.\n\n  datetime_tz objects can't just have tzinfo replaced with None, you need to\n  call asdatetime.\n\n  Args:\n    dt: datetime object.\n\n  Returns:\n    datetime object without any timezone information.\n  \"\"\"\n  if not dt.tzinfo:\n    return dt\n  if hasattr(dt, \"asdatetime\"):\n    return dt.asdatetime()\n  return dt.replace(tzinfo=None)", "code_tokens": "def get_naive ( dt ) : if not dt . tzinfo : return dt if hasattr ( dt , \"asdatetime\" ) : return dt . asdatetime ( ) return dt . replace ( tzinfo = None )", "docstring_tokens": "Gets a naive datetime from a datetime .", "label": 1}, {"idx": "cosqa-train-11730", "doc": "how to print out help in python", "code": "def _help():\n    \"\"\" Display both SQLAlchemy and Python help statements \"\"\"\n\n    statement = '%s%s' % (shelp, phelp % ', '.join(cntx_.keys()))\n    print statement.strip()", "code_tokens": "def _help ( ) : statement = '%s%s' % ( shelp , phelp % ', ' . join ( cntx_ . keys ( ) ) ) print statement . strip ( )", "docstring_tokens": "Display both SQLAlchemy and Python help statements", "label": 1}, {"idx": "cosqa-train-11731", "doc": "python recursive schema validation", "code": "def validate(schema, data, owner=None):\n    \"\"\"Validate input data with input schema.\n\n    :param Schema schema: schema able to validate input data.\n    :param data: data to validate.\n    :param Schema owner: input schema parent schema.\n    :raises: Exception if the data is not validated.\n    \"\"\"\n    schema._validate(data=data, owner=owner)", "code_tokens": "def validate ( schema , data , owner = None ) : schema . _validate ( data = data , owner = owner )", "docstring_tokens": "Validate input data with input schema .", "label": 1}, {"idx": "cosqa-train-11732", "doc": "how to print outputs to python cmd window", "code": "def out(self, output, newline=True):\n        \"\"\"Outputs a string to the console (stdout).\"\"\"\n        click.echo(output, nl=newline)", "code_tokens": "def out ( self , output , newline = True ) : click . echo ( output , nl = newline )", "docstring_tokens": "Outputs a string to the console ( stdout ) .", "label": 1}, {"idx": "cosqa-train-11733", "doc": "python recursively flatten a list", "code": "def flat_list(lst):\n    \"\"\"This function flatten given nested list.\n    Argument:\n        nested list\n    Returns:\n        flat list\n    \"\"\"\n    if isinstance(lst, list):\n        for item in lst:\n            for i in flat_list(item):\n                yield i\n    else:\n        yield lst", "code_tokens": "def flat_list ( lst ) : if isinstance ( lst , list ) : for item in lst : for i in flat_list ( item ) : yield i else : yield lst", "docstring_tokens": "This function flatten given nested list . Argument : nested list Returns : flat list", "label": 1}, {"idx": "cosqa-train-11734", "doc": "how to print something bold in python", "code": "def good(txt):\n    \"\"\"Print, emphasized 'good', the given 'txt' message\"\"\"\n\n    print(\"%s# %s%s%s\" % (PR_GOOD_CC, get_time_stamp(), txt, PR_NC))\n    sys.stdout.flush()", "code_tokens": "def good ( txt ) : print ( \"%s# %s%s%s\" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "docstring_tokens": "Print emphasized good the given txt message", "label": 1}, {"idx": "cosqa-train-11735", "doc": "python recursively replace multiple list of text", "code": "def _sub_patterns(patterns, text):\n    \"\"\"\n    Apply re.sub to bunch of (pattern, repl)\n    \"\"\"\n    for pattern, repl in patterns:\n        text = re.sub(pattern, repl, text)\n    return text", "code_tokens": "def _sub_patterns ( patterns , text ) : for pattern , repl in patterns : text = re . sub ( pattern , repl , text ) return text", "docstring_tokens": "Apply re . sub to bunch of ( pattern repl )", "label": 1}, {"idx": "cosqa-train-11736", "doc": "how to print text with different color python", "code": "def printc(cls, txt, color=colors.red):\n        \"\"\"Print in color.\"\"\"\n        print(cls.color_txt(txt, color))", "code_tokens": "def printc ( cls , txt , color = colors . red ) : print ( cls . color_txt ( txt , color ) )", "docstring_tokens": "Print in color .", "label": 1}, {"idx": "cosqa-train-11737", "doc": "python redis all keys with a prefix", "code": "def make_key(self, key, version=None):\n        \"\"\"RedisCache will set prefix+version as prefix for each key.\"\"\"\n        return '{}:{}:{}'.format(\n            self.prefix,\n            version or self.version,\n            key,\n        )", "code_tokens": "def make_key ( self , key , version = None ) : return '{}:{}:{}' . format ( self . prefix , version or self . version , key , )", "docstring_tokens": "RedisCache will set prefix + version as prefix for each key .", "label": 1}, {"idx": "cosqa-train-11738", "doc": "how to print top 5 rows of data frame in python", "code": "def head_and_tail_print(self, n=5):\n        \"\"\"Display the first and last n elements of a DataFrame.\"\"\"\n        from IPython import display\n        display.display(display.HTML(self._head_and_tail_table(n)))", "code_tokens": "def head_and_tail_print ( self , n = 5 ) : from IPython import display display . display ( display . HTML ( self . _head_and_tail_table ( n ) ) )", "docstring_tokens": "Display the first and last n elements of a DataFrame .", "label": 0}, {"idx": "cosqa-train-11739", "doc": "python redis list pop", "code": "def rpop(self, key):\n        \"\"\"Emulate lpop.\"\"\"\n        redis_list = self._get_list(key, 'RPOP')\n\n        if self._encode(key) not in self.redis:\n            return None\n\n        try:\n            value = redis_list.pop()\n            if len(redis_list) == 0:\n                self.delete(key)\n            return value\n        except (IndexError):\n            # Redis returns nil if popping from an empty list\n            return None", "code_tokens": "def rpop ( self , key ) : redis_list = self . _get_list ( key , 'RPOP' ) if self . _encode ( key ) not in self . redis : return None try : value = redis_list . pop ( ) if len ( redis_list ) == 0 : self . delete ( key ) return value except ( IndexError ) : # Redis returns nil if popping from an empty list return None", "docstring_tokens": "Emulate lpop .", "label": 1}, {"idx": "cosqa-train-11740", "doc": "how to produce confusion matrix in python", "code": "def confusion_matrix(links_true, links_pred, total=None):\n    \"\"\"Compute the confusion matrix.\n\n    The confusion matrix is of the following form:\n\n    +----------------------+-----------------------+----------------------+\n    |                      |  Predicted Positives  | Predicted Negatives  |\n    +======================+=======================+======================+\n    | **True Positives**   | True Positives (TP)   | False Negatives (FN) |\n    +----------------------+-----------------------+----------------------+\n    | **True Negatives**   | False Positives (FP)  | True Negatives (TN)  |\n    +----------------------+-----------------------+----------------------+\n\n    The confusion matrix is an informative way to analyse a prediction. The\n    matrix can used to compute measures like precision and recall. The count\n    of true prositives is [0,0], false negatives is [0,1], true negatives\n    is [1,1] and false positives is [1,0].\n\n    Parameters\n    ----------\n    links_true: pandas.MultiIndex, pandas.DataFrame, pandas.Series\n        The true (or actual) links.\n    links_pred: pandas.MultiIndex, pandas.DataFrame, pandas.Series\n        The predicted links.\n    total: int, pandas.MultiIndex\n        The count of all record pairs (both links and non-links). When the\n        argument is a pandas.MultiIndex, the length of the index is used. If\n        the total is None, the number of True Negatives is not computed.\n        Default None.\n\n    Returns\n    -------\n    numpy.array\n        The confusion matrix with TP, TN, FN, FP values.\n\n    Note\n    ----\n    The number of True Negatives is computed based on the total argument.\n    This argument is the number of record pairs of the entire matrix.\n\n    \"\"\"\n\n    links_true = _get_multiindex(links_true)\n    links_pred = _get_multiindex(links_pred)\n\n    tp = true_positives(links_true, links_pred)\n    fp = false_positives(links_true, links_pred)\n    fn = false_negatives(links_true, links_pred)\n\n    if total is None:\n        tn = numpy.nan\n    else:\n        tn = true_negatives(links_true, links_pred, total)\n\n    return numpy.array([[tp, fn], [fp, tn]])", "code_tokens": "def confusion_matrix ( links_true , links_pred , total = None ) : links_true = _get_multiindex ( links_true ) links_pred = _get_multiindex ( links_pred ) tp = true_positives ( links_true , links_pred ) fp = false_positives ( links_true , links_pred ) fn = false_negatives ( links_true , links_pred ) if total is None : tn = numpy . nan else : tn = true_negatives ( links_true , links_pred , total ) return numpy . array ( [ [ tp , fn ] , [ fp , tn ] ] )", "docstring_tokens": "Compute the confusion matrix .", "label": 1}, {"idx": "cosqa-train-11741", "doc": "python redis lpush fixed siz", "code": "def lpush(self, key, *args):\n        \"\"\"Emulate lpush.\"\"\"\n        redis_list = self._get_list(key, 'LPUSH', create=True)\n\n        # Creates the list at this key if it doesn't exist, and appends args to its beginning\n        args_reversed = [self._encode(arg) for arg in args]\n        args_reversed.reverse()\n        updated_list = args_reversed + redis_list\n        self.redis[self._encode(key)] = updated_list\n\n        # Return the length of the list after the push operation\n        return len(updated_list)", "code_tokens": "def lpush ( self , key , * args ) : redis_list = self . _get_list ( key , 'LPUSH' , create = True ) # Creates the list at this key if it doesn't exist, and appends args to its beginning args_reversed = [ self . _encode ( arg ) for arg in args ] args_reversed . reverse ( ) updated_list = args_reversed + redis_list self . redis [ self . _encode ( key ) ] = updated_list # Return the length of the list after the push operation return len ( updated_list )", "docstring_tokens": "Emulate lpush .", "label": 1}, {"idx": "cosqa-train-11742", "doc": "how to profile object memory python3", "code": "def m(name='', **kwargs):\n    \"\"\"\n    Print out memory usage at this point in time\n\n    http://docs.python.org/2/library/resource.html\n    http://stackoverflow.com/a/15448600/5006\n    http://stackoverflow.com/questions/110259/which-python-memory-profiler-is-recommended\n    \"\"\"\n    with Reflect.context(**kwargs) as r:\n        kwargs[\"name\"] = name\n        instance = M_CLASS(r, stream, **kwargs)\n        instance()", "code_tokens": "def m ( name = '' , * * kwargs ) : with Reflect . context ( * * kwargs ) as r : kwargs [ \"name\" ] = name instance = M_CLASS ( r , stream , * * kwargs ) instance ( )", "docstring_tokens": "Print out memory usage at this point in time", "label": 1}, {"idx": "cosqa-train-11743", "doc": "python redis multi subscriber only one", "code": "def connect(self):\n        \"\"\"\n        Connects to publisher\n        \"\"\"\n        self.client = redis.Redis(\n            host=self.host, port=self.port, password=self.password)", "code_tokens": "def connect ( self ) : self . client = redis . Redis ( host = self . host , port = self . port , password = self . password )", "docstring_tokens": "Connects to publisher", "label": 1}, {"idx": "cosqa-train-11744", "doc": "how to push an object into a list python", "code": "def append(self, item):\n        \"\"\" append item and print it to stdout \"\"\"\n        print(item)\n        super(MyList, self).append(item)", "code_tokens": "def append ( self , item ) : print ( item ) super ( MyList , self ) . append ( item )", "docstring_tokens": "append item and print it to stdout", "label": 1}, {"idx": "cosqa-train-11745", "doc": "python regex capital a to lowercase z", "code": "def camel_to_(s):\n    \"\"\"\n    Convert CamelCase to camel_case\n    \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', s)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def camel_to_ ( s ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , s ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert CamelCase to camel_case", "label": 1}, {"idx": "cosqa-train-11746", "doc": "python regex extract domain", "code": "def parse_domain(url):\n    \"\"\" parse the domain from the url \"\"\"\n    domain_match = lib.DOMAIN_REGEX.match(url)\n    if domain_match:\n        return domain_match.group()", "code_tokens": "def parse_domain ( url ) : domain_match = lib . DOMAIN_REGEX . match ( url ) if domain_match : return domain_match . group ( )", "docstring_tokens": "parse the domain from the url", "label": 1}, {"idx": "cosqa-train-11747", "doc": "how to put json in file python", "code": "def save(self, fname):\n        \"\"\" Saves the dictionary in json format\n        :param fname: file to save to\n        \"\"\"\n        with open(fname, 'wb') as f:\n            json.dump(self, f)", "code_tokens": "def save ( self , fname ) : with open ( fname , 'wb' ) as f : json . dump ( self , f )", "docstring_tokens": "Saves the dictionary in json format : param fname : file to save to", "label": 1}, {"idx": "cosqa-train-11748", "doc": "python regex password validation", "code": "def is_password_valid(password):\n    \"\"\"\n    Check if a password is valid\n    \"\"\"\n    pattern = re.compile(r\"^.{4,75}$\")\n    return bool(pattern.match(password))", "code_tokens": "def is_password_valid ( password ) : pattern = re . compile ( r\"^.{4,75}$\" ) return bool ( pattern . match ( password ) )", "docstring_tokens": "Check if a password is valid", "label": 1}, {"idx": "cosqa-train-11749", "doc": "how to put multable arrays into 1 array python", "code": "def pack_triples_numpy(triples):\n    \"\"\"Packs a list of triple indexes into a 2D numpy array.\"\"\"\n    if len(triples) == 0:\n        return np.array([], dtype=np.int64)\n    return np.stack(list(map(_transform_triple_numpy, triples)), axis=0)", "code_tokens": "def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )", "docstring_tokens": "Packs a list of triple indexes into a 2D numpy array .", "label": 1}, {"idx": "cosqa-train-11750", "doc": "python regex replace with lowercase", "code": "def to_snake_case(text):\n    \"\"\"Convert to snake case.\n\n    :param str text:\n    :rtype: str\n    :return:\n    \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def to_snake_case ( text ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert to snake case .", "label": 0}, {"idx": "cosqa-train-11751", "doc": "how to query an url in python and write the json to file", "code": "def download_json(local_filename, url, clobber=False):\n    \"\"\"Download the given JSON file, and pretty-print before we output it.\"\"\"\n    with open(local_filename, 'w') as json_file:\n        json_file.write(json.dumps(requests.get(url).json(), sort_keys=True, indent=2, separators=(',', ': ')))", "code_tokens": "def download_json ( local_filename , url , clobber = False ) : with open ( local_filename , 'w' ) as json_file : json_file . write ( json . dumps ( requests . get ( url ) . json ( ) , sort_keys = True , indent = 2 , separators = ( ',' , ': ' ) ) )", "docstring_tokens": "Download the given JSON file and pretty - print before we output it .", "label": 1}, {"idx": "cosqa-train-11752", "doc": "python regex replace with match count", "code": "def subn_filter(s, find, replace, count=0):\n    \"\"\"A non-optimal implementation of a regex filter\"\"\"\n    return re.gsub(find, replace, count, s)", "code_tokens": "def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )", "docstring_tokens": "A non - optimal implementation of a regex filter", "label": 1}, {"idx": "cosqa-train-11753", "doc": "how to raise value error in python constructor", "code": "def __init__(self, node_def, op, message):\n        \"\"\"Creates an `InvalidArgumentError`.\"\"\"\n        super(InvalidArgumentError, self).__init__(\n            node_def, op, message, INVALID_ARGUMENT\n        )", "code_tokens": "def __init__ ( self , node_def , op , message ) : super ( InvalidArgumentError , self ) . __init__ ( node_def , op , message , INVALID_ARGUMENT )", "docstring_tokens": "Creates an InvalidArgumentError .", "label": 0}, {"idx": "cosqa-train-11754", "doc": "python regex substitute from dictionary", "code": "def substitute(dict_, source):\n    \"\"\" Perform re.sub with the patterns in the given dict\n    Args:\n      dict_: {pattern: repl}\n      source: str\n    \"\"\"\n    d_esc = (re.escape(k) for k in dict_.keys())\n    pattern = re.compile('|'.join(d_esc))\n    return pattern.sub(lambda x: dict_[x.group()], source)", "code_tokens": "def substitute ( dict_ , source ) : d_esc = ( re . escape ( k ) for k in dict_ . keys ( ) ) pattern = re . compile ( '|' . join ( d_esc ) ) return pattern . sub ( lambda x : dict_ [ x . group ( ) ] , source )", "docstring_tokens": "Perform re . sub with the patterns in the given dict Args : dict_ : { pattern : repl } source : str", "label": 1}, {"idx": "cosqa-train-11755", "doc": "how to read a scale as a number python", "code": "def parse_scale(x):\n    \"\"\"Splits a \"%s:%d\" string and returns the string and number.\n\n    :return: A ``(string, int)`` pair extracted from ``x``.\n\n    :raise ValueError: the string ``x`` does not respect the input format.\n    \"\"\"\n    match = re.match(r'^(.+?):(\\d+)$', x)\n    if not match:\n        raise ValueError('Invalid scale \"%s\".' % x)\n    return match.group(1), int(match.group(2))", "code_tokens": "def parse_scale ( x ) : match = re . match ( r'^(.+?):(\\d+)$' , x ) if not match : raise ValueError ( 'Invalid scale \"%s\".' % x ) return match . group ( 1 ) , int ( match . group ( 2 ) )", "docstring_tokens": "Splits a %s : %d string and returns the string and number .", "label": 1}, {"idx": "cosqa-train-11756", "doc": "python relative path from", "code": "def import_path(self):\n    \"\"\"The full remote import path as used in import statements in `.go` source files.\"\"\"\n    return os.path.join(self.remote_root, self.pkg) if self.pkg else self.remote_root", "code_tokens": "def import_path ( self ) : return os . path . join ( self . remote_root , self . pkg ) if self . pkg else self . remote_root", "docstring_tokens": "The full remote import path as used in import statements in . go source files .", "label": 1}, {"idx": "cosqa-train-11757", "doc": "how to read date strings in python", "code": "def _read_date_from_string(str1):\n    \"\"\"\n    Reads the date from a string in the format YYYY/MM/DD and returns\n    :class: datetime.date\n    \"\"\"\n    full_date = [int(x) for x in str1.split('/')]\n    return datetime.date(full_date[0], full_date[1], full_date[2])", "code_tokens": "def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )", "docstring_tokens": "Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date", "label": 1}, {"idx": "cosqa-train-11758", "doc": "python remane multi index", "code": "def cmd_reindex():\n    \"\"\"Uses CREATE INDEX CONCURRENTLY to create a duplicate index, then tries to swap the new index for the original.\n\n    The index swap is done using a short lock timeout to prevent it from interfering with running queries. Retries until\n    the rename succeeds.\n    \"\"\"\n    db = connect(args.database)\n    for idx in args.indexes:\n        pg_reindex(db, idx)", "code_tokens": "def cmd_reindex ( ) : db = connect ( args . database ) for idx in args . indexes : pg_reindex ( db , idx )", "docstring_tokens": "Uses CREATE INDEX CONCURRENTLY to create a duplicate index then tries to swap the new index for the original .", "label": 1}, {"idx": "cosqa-train-11759", "doc": "how to read from a file to a list python", "code": "def get_list_from_file(file_name):\n    \"\"\"read the lines from a file into a list\"\"\"\n    with open(file_name, mode='r', encoding='utf-8') as f1:\n        lst = f1.readlines()\n    return lst", "code_tokens": "def get_list_from_file ( file_name ) : with open ( file_name , mode = 'r' , encoding = 'utf-8' ) as f1 : lst = f1 . readlines ( ) return lst", "docstring_tokens": "read the lines from a file into a list", "label": 1}, {"idx": "cosqa-train-11760", "doc": "python remove accents from arabic", "code": "def unaccentuate(s):\n    \"\"\" Replace accentuated chars in string by their non accentuated equivalent. \"\"\"\n    return \"\".join(c for c in unicodedata.normalize(\"NFKD\", s) if not unicodedata.combining(c))", "code_tokens": "def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "docstring_tokens": "Replace accentuated chars in string by their non accentuated equivalent .", "label": 1}, {"idx": "cosqa-train-11761", "doc": "how to read pickle data in python", "code": "def read_raw(data_path):\n    \"\"\"\n    Parameters\n    ----------\n    data_path : str\n    \"\"\"\n    with open(data_path, 'rb') as f:\n        data = pickle.load(f)\n    return data", "code_tokens": "def read_raw ( data_path ) : with open ( data_path , 'rb' ) as f : data = pickle . load ( f ) return data", "docstring_tokens": "Parameters ---------- data_path : str", "label": 1}, {"idx": "cosqa-train-11762", "doc": "python remove accents from letters", "code": "def unaccentuate(s):\n    \"\"\" Replace accentuated chars in string by their non accentuated equivalent. \"\"\"\n    return \"\".join(c for c in unicodedata.normalize(\"NFKD\", s) if not unicodedata.combining(c))", "code_tokens": "def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "docstring_tokens": "Replace accentuated chars in string by their non accentuated equivalent .", "label": 1}, {"idx": "cosqa-train-11763", "doc": "how to read text from url in python", "code": "def url_read_text(url, verbose=True):\n    r\"\"\"\n    Directly reads text data from url\n    \"\"\"\n    data = url_read(url, verbose)\n    text = data.decode('utf8')\n    return text", "code_tokens": "def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text", "docstring_tokens": "r Directly reads text data from url", "label": 1}, {"idx": "cosqa-train-11764", "doc": "python remove all empty entries form list", "code": "def unique(seq):\n    \"\"\"Return the unique elements of a collection even if those elements are\n       unhashable and unsortable, like dicts and sets\"\"\"\n    cleaned = []\n    for each in seq:\n        if each not in cleaned:\n            cleaned.append(each)\n    return cleaned", "code_tokens": "def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned", "docstring_tokens": "Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets", "label": 0}, {"idx": "cosqa-train-11765", "doc": "how to read utf8 in python", "code": "def read_utf8(fh, byteorder, dtype, count, offsetsize):\n    \"\"\"Read tag data from file and return as unicode string.\"\"\"\n    return fh.read(count).decode('utf-8')", "code_tokens": "def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )", "docstring_tokens": "Read tag data from file and return as unicode string .", "label": 1}, {"idx": "cosqa-train-11766", "doc": "python remove an object to free memory", "code": "def removeFromRegistery(obj) :\n\t\"\"\"Removes an object/rabalist from registery. This is useful if you want to allow the garbage collector to free the memory\n\ttaken by the objects you've already loaded. Be careful might cause some discrepenties in your scripts. For objects,\n\tcascades to free the registeries of related rabalists also\"\"\"\n\t\n\tif isRabaObject(obj) :\n\t\t_unregisterRabaObjectInstance(obj)\n\telif isRabaList(obj) :\n\t\t_unregisterRabaListInstance(obj)", "code_tokens": "def removeFromRegistery ( obj ) : if isRabaObject ( obj ) : _unregisterRabaObjectInstance ( obj ) elif isRabaList ( obj ) : _unregisterRabaListInstance ( obj )", "docstring_tokens": "Removes an object / rabalist from registery . This is useful if you want to allow the garbage collector to free the memory taken by the objects you ve already loaded . Be careful might cause some discrepenties in your scripts . For objects cascades to free the registeries of related rabalists also", "label": 1}, {"idx": "cosqa-train-11767", "doc": "how to read xml file in python", "code": "def xmltreefromfile(filename):\n    \"\"\"Internal function to read an XML file\"\"\"\n    try:\n        return ElementTree.parse(filename, ElementTree.XMLParser(collect_ids=False))\n    except TypeError:\n        return ElementTree.parse(filename, ElementTree.XMLParser())", "code_tokens": "def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )", "docstring_tokens": "Internal function to read an XML file", "label": 1}, {"idx": "cosqa-train-11768", "doc": "python remove axis frame", "code": "def clean_axis(axis):\n    \"\"\"Remove ticks, tick labels, and frame from axis\"\"\"\n    axis.get_xaxis().set_ticks([])\n    axis.get_yaxis().set_ticks([])\n    for spine in list(axis.spines.values()):\n        spine.set_visible(False)", "code_tokens": "def clean_axis ( axis ) : axis . get_xaxis ( ) . set_ticks ( [ ] ) axis . get_yaxis ( ) . set_ticks ( [ ] ) for spine in list ( axis . spines . values ( ) ) : spine . set_visible ( False )", "docstring_tokens": "Remove ticks tick labels and frame from axis", "label": 1}, {"idx": "cosqa-train-11769", "doc": "how to redefine a method python overload", "code": "def method(func):\n    \"\"\"Wrap a function as a method.\"\"\"\n    attr = abc.abstractmethod(func)\n    attr.__imethod__ = True\n    return attr", "code_tokens": "def method ( func ) : attr = abc . abstractmethod ( func ) attr . __imethod__ = True return attr", "docstring_tokens": "Wrap a function as a method .", "label": 1}, {"idx": "cosqa-train-11770", "doc": "python remove directory tree if no files", "code": "def clean_out_dir(directory):\n    \"\"\"\n    Delete all the files and subdirectories in a directory.\n    \"\"\"\n    if not isinstance(directory, path):\n        directory = path(directory)\n    for file_path in directory.files():\n        file_path.remove()\n    for dir_path in directory.dirs():\n        dir_path.rmtree()", "code_tokens": "def clean_out_dir ( directory ) : if not isinstance ( directory , path ) : directory = path ( directory ) for file_path in directory . files ( ) : file_path . remove ( ) for dir_path in directory . dirs ( ) : dir_path . rmtree ( )", "docstring_tokens": "Delete all the files and subdirectories in a directory .", "label": 1}, {"idx": "cosqa-train-11771", "doc": "how to refer to excel column in python xlrd", "code": "def _series_col_letter(self, series):\n        \"\"\"\n        The letter of the Excel worksheet column in which the data for a\n        series appears.\n        \"\"\"\n        column_number = 1 + series.categories.depth + series.index\n        return self._column_reference(column_number)", "code_tokens": "def _series_col_letter ( self , series ) : column_number = 1 + series . categories . depth + series . index return self . _column_reference ( column_number )", "docstring_tokens": "The letter of the Excel worksheet column in which the data for a series appears .", "label": 1}, {"idx": "cosqa-train-11772", "doc": "python remove duplicates from list of files", "code": "def _remove_duplicate_files(xs):\n    \"\"\"Remove files specified multiple times in a list.\n    \"\"\"\n    seen = set([])\n    out = []\n    for x in xs:\n        if x[\"path\"] not in seen:\n            out.append(x)\n            seen.add(x[\"path\"])\n    return out", "code_tokens": "def _remove_duplicate_files ( xs ) : seen = set ( [ ] ) out = [ ] for x in xs : if x [ \"path\" ] not in seen : out . append ( x ) seen . add ( x [ \"path\" ] ) return out", "docstring_tokens": "Remove files specified multiple times in a list .", "label": 1}, {"idx": "cosqa-train-11773", "doc": "how to remove a index in python3", "code": "def _remove_from_index(index, obj):\n    \"\"\"Removes object ``obj`` from the ``index``.\"\"\"\n    try:\n        index.value_map[indexed_value(index, obj)].remove(obj.id)\n    except KeyError:\n        pass", "code_tokens": "def _remove_from_index ( index , obj ) : try : index . value_map [ indexed_value ( index , obj ) ] . remove ( obj . id ) except KeyError : pass", "docstring_tokens": "Removes object obj from the index .", "label": 1}, {"idx": "cosqa-train-11774", "doc": "python remove extra spaces in a string", "code": "def sanitize_word(s):\n    \"\"\"Remove non-alphanumerical characters from metric word.\n    And trim excessive underscores.\n    \"\"\"\n    s = re.sub('[^\\w-]+', '_', s)\n    s = re.sub('__+', '_', s)\n    return s.strip('_')", "code_tokens": "def sanitize_word ( s ) : s = re . sub ( '[^\\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )", "docstring_tokens": "Remove non - alphanumerical characters from metric word . And trim excessive underscores .", "label": 1}, {"idx": "cosqa-train-11775", "doc": "how to remove all the punctuations in text in python", "code": "def remove_punctuation(text, exceptions=[]):\n    \"\"\"\n    Return a string with punctuation removed.\n\n    Parameters:\n        text (str): The text to remove punctuation from.\n        exceptions (list): List of symbols to keep in the given text.\n\n    Return:\n        str: The input text without the punctuation.\n    \"\"\"\n\n    all_but = [\n        r'\\w',\n        r'\\s'\n    ]\n\n    all_but.extend(exceptions)\n\n    pattern = '[^{}]'.format(''.join(all_but))\n\n    return re.sub(pattern, '', text)", "code_tokens": "def remove_punctuation ( text , exceptions = [ ] ) : all_but = [ r'\\w' , r'\\s' ] all_but . extend ( exceptions ) pattern = '[^{}]' . format ( '' . join ( all_but ) ) return re . sub ( pattern , '' , text )", "docstring_tokens": "Return a string with punctuation removed .", "label": 1}, {"idx": "cosqa-train-11776", "doc": "python remove file after read stream", "code": "def __del__(self):\n    \"\"\"Cleans up the file entry.\"\"\"\n    # __del__ can be invoked before __init__ has completed.\n    if hasattr(self, '_encoded_stream'):\n      self._encoded_stream.close()\n      self._encoded_stream = None\n\n    super(EncodedStreamFileEntry, self).__del__()", "code_tokens": "def __del__ ( self ) : # __del__ can be invoked before __init__ has completed. if hasattr ( self , '_encoded_stream' ) : self . _encoded_stream . close ( ) self . _encoded_stream = None super ( EncodedStreamFileEntry , self ) . __del__ ( )", "docstring_tokens": "Cleans up the file entry .", "label": 1}, {"idx": "cosqa-train-11777", "doc": "how to remove blank lines from a text file in python", "code": "def get_stripped_file_lines(filename):\n    \"\"\"\n    Return lines of a file with whitespace removed\n    \"\"\"\n    try:\n        lines = open(filename).readlines()\n    except FileNotFoundError:\n        fatal(\"Could not open file: {!r}\".format(filename))\n\n    return [line.strip() for line in lines]", "code_tokens": "def get_stripped_file_lines ( filename ) : try : lines = open ( filename ) . readlines ( ) except FileNotFoundError : fatal ( \"Could not open file: {!r}\" . format ( filename ) ) return [ line . strip ( ) for line in lines ]", "docstring_tokens": "Return lines of a file with whitespace removed", "label": 1}, {"idx": "cosqa-train-11778", "doc": "python remove first element from list of dictionary", "code": "def pop (self, key):\n        \"\"\"Remove key from dict and return value.\"\"\"\n        if key in self._keys:\n            self._keys.remove(key)\n        super(ListDict, self).pop(key)", "code_tokens": "def pop ( self , key ) : if key in self . _keys : self . _keys . remove ( key ) super ( ListDict , self ) . pop ( key )", "docstring_tokens": "Remove key from dict and return value .", "label": 1}, {"idx": "cosqa-train-11779", "doc": "how to remove comma from python string", "code": "def seq_to_str(obj, sep=\",\"):\n    \"\"\"\n    Given a sequence convert it to a comma separated string.\n    If, however, the argument is a single object, return its string\n    representation.\n    \"\"\"\n    if isinstance(obj, string_classes):\n        return obj\n    elif isinstance(obj, (list, tuple)):\n        return sep.join([str(x) for x in obj])\n    else:\n        return str(obj)", "code_tokens": "def seq_to_str ( obj , sep = \",\" ) : if isinstance ( obj , string_classes ) : return obj elif isinstance ( obj , ( list , tuple ) ) : return sep . join ( [ str ( x ) for x in obj ] ) else : return str ( obj )", "docstring_tokens": "Given a sequence convert it to a comma separated string . If however the argument is a single object return its string representation .", "label": 1}, {"idx": "cosqa-train-11780", "doc": "python remove last element from a stack", "code": "def pop(h):\n    \"\"\"Pop the heap value from the heap.\"\"\"\n    n = h.size() - 1\n    h.swap(0, n)\n    down(h, 0, n)\n    return h.pop()", "code_tokens": "def pop ( h ) : n = h . size ( ) - 1 h . swap ( 0 , n ) down ( h , 0 , n ) return h . pop ( )", "docstring_tokens": "Pop the heap value from the heap .", "label": 1}, {"idx": "cosqa-train-11781", "doc": "how to remove from a specific index python", "code": "def DeleteIndex(self, index):\n        \"\"\"\n        Remove a spent coin based on its index.\n\n        Args:\n            index (int):\n        \"\"\"\n        to_remove = None\n        for i in self.Items:\n            if i.index == index:\n                to_remove = i\n\n        if to_remove:\n            self.Items.remove(to_remove)", "code_tokens": "def DeleteIndex ( self , index ) : to_remove = None for i in self . Items : if i . index == index : to_remove = i if to_remove : self . Items . remove ( to_remove )", "docstring_tokens": "Remove a spent coin based on its index .", "label": 1}, {"idx": "cosqa-train-11782", "doc": "python remove odd mark in twitter", "code": "def urlize_twitter(text):\n    \"\"\"\n    Replace #hashtag and @username references in a tweet with HTML text.\n    \"\"\"\n    html = TwitterText(text).autolink.auto_link()\n    return mark_safe(html.replace(\n        'twitter.com/search?q=', 'twitter.com/search/realtime/'))", "code_tokens": "def urlize_twitter ( text ) : html = TwitterText ( text ) . autolink . auto_link ( ) return mark_safe ( html . replace ( 'twitter.com/search?q=' , 'twitter.com/search/realtime/' ) )", "docstring_tokens": "Replace #hashtag and", "label": 1}, {"idx": "cosqa-train-11783", "doc": "how to remove fullstop in a string in python", "code": "def lowstrip(term):\n    \"\"\"Convert to lowercase and strip spaces\"\"\"\n    term = re.sub('\\s+', ' ', term)\n    term = term.lower()\n    return term", "code_tokens": "def lowstrip ( term ) : term = re . sub ( '\\s+' , ' ' , term ) term = term . lower ( ) return term", "docstring_tokens": "Convert to lowercase and strip spaces", "label": 0}, {"idx": "cosqa-train-11784", "doc": "python remove parenthesis around stringf", "code": "def format_screen(strng):\n    \"\"\"Format a string for screen printing.\n\n    This removes some latex-type format codes.\"\"\"\n    # Paragraph continue\n    par_re = re.compile(r'\\\\$',re.MULTILINE)\n    strng = par_re.sub('',strng)\n    return strng", "code_tokens": "def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng", "docstring_tokens": "Format a string for screen printing .", "label": 1}, {"idx": "cosqa-train-11785", "doc": "how to remove object from list python", "code": "def remove_instance(self, item):\n        \"\"\"Remove `instance` from model\"\"\"\n        self.instances.remove(item)\n        self.remove_item(item)", "code_tokens": "def remove_instance ( self , item ) : self . instances . remove ( item ) self . remove_item ( item )", "docstring_tokens": "Remove instance from model", "label": 1}, {"idx": "cosqa-train-11786", "doc": "python remove repeated elements in list", "code": "def dedupe_list(seq):\n    \"\"\"\n    Utility function to remove duplicates from a list\n    :param seq: The sequence (list) to deduplicate\n    :return: A list with original duplicates removed\n    \"\"\"\n    seen = set()\n    return [x for x in seq if not (x in seen or seen.add(x))]", "code_tokens": "def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed", "label": 1}, {"idx": "cosqa-train-11787", "doc": "how to remove punctuation and special charachhters in python", "code": "def slugify(s, delimiter='-'):\n    \"\"\"\n    Normalize `s` into ASCII and replace non-word characters with `delimiter`.\n    \"\"\"\n    s = unicodedata.normalize('NFKD', to_unicode(s)).encode('ascii', 'ignore').decode('ascii')\n    return RE_SLUG.sub(delimiter, s).strip(delimiter).lower()", "code_tokens": "def slugify ( s , delimiter = '-' ) : s = unicodedata . normalize ( 'NFKD' , to_unicode ( s ) ) . encode ( 'ascii' , 'ignore' ) . decode ( 'ascii' ) return RE_SLUG . sub ( delimiter , s ) . strip ( delimiter ) . lower ( )", "docstring_tokens": "Normalize s into ASCII and replace non - word characters with delimiter .", "label": 1}, {"idx": "cosqa-train-11788", "doc": "python remove rows with empty values in a column", "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True):\n    \"\"\"Clean a pandas dataframe by:\n        1. Filling empty values with Nan\n        2. Dropping columns with all empty values\n\n    Args:\n        df: Pandas DataFrame\n        fill_nan (bool): If any empty values (strings, None, etc) should be replaced with NaN\n        drop_empty_columns (bool): If columns whose values are all empty should be dropped\n\n    Returns:\n        DataFrame: cleaned DataFrame\n\n    \"\"\"\n    if fill_nan:\n        df = df.fillna(value=np.nan)\n    if drop_empty_columns:\n        df = df.dropna(axis=1, how='all')\n    return df.sort_index()", "code_tokens": "def clean_df ( df , fill_nan = True , drop_empty_columns = True ) : if fill_nan : df = df . fillna ( value = np . nan ) if drop_empty_columns : df = df . dropna ( axis = 1 , how = 'all' ) return df . sort_index ( )", "docstring_tokens": "Clean a pandas dataframe by : 1 . Filling empty values with Nan 2 . Dropping columns with all empty values", "label": 1}, {"idx": "cosqa-train-11789", "doc": "how to remove space from keys of a dictonary in python3", "code": "def dict_keys_without_hyphens(a_dict):\n    \"\"\"Return the a new dict with underscores instead of hyphens in keys.\"\"\"\n    return dict(\n        (key.replace('-', '_'), val) for key, val in a_dict.items())", "code_tokens": "def dict_keys_without_hyphens ( a_dict ) : return dict ( ( key . replace ( '-' , '_' ) , val ) for key , val in a_dict . items ( ) )", "docstring_tokens": "Return the a new dict with underscores instead of hyphens in keys .", "label": 0}, {"idx": "cosqa-train-11790", "doc": "python remove zeros from list", "code": "def _remove_blank(l):\n        \"\"\" Removes trailing zeros in the list of integers and returns a new list of integers\"\"\"\n        ret = []\n        for i, _ in enumerate(l):\n            if l[i] == 0:\n                break\n            ret.append(l[i])\n        return ret", "code_tokens": "def _remove_blank ( l ) : ret = [ ] for i , _ in enumerate ( l ) : if l [ i ] == 0 : break ret . append ( l [ i ] ) return ret", "docstring_tokens": "Removes trailing zeros in the list of integers and returns a new list of integers", "label": 1}, {"idx": "cosqa-train-11791", "doc": "how to remove spaces between words in python string", "code": "def strip_accents(text):\n    \"\"\"\n    Strip agents from a string.\n    \"\"\"\n\n    normalized_str = unicodedata.normalize('NFD', text)\n\n    return ''.join([\n        c for c in normalized_str if unicodedata.category(c) != 'Mn'])", "code_tokens": "def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "docstring_tokens": "Strip agents from a string .", "label": 1}, {"idx": "cosqa-train-11792", "doc": "python removing one element from a list would make the list ascending", "code": "def insort_no_dup(lst, item):\n    \"\"\"\n    If item is not in lst, add item to list at its sorted position\n    \"\"\"\n    import bisect\n    ix = bisect.bisect_left(lst, item)\n    if lst[ix] != item: \n        lst[ix:ix] = [item]", "code_tokens": "def insort_no_dup ( lst , item ) : import bisect ix = bisect . bisect_left ( lst , item ) if lst [ ix ] != item : lst [ ix : ix ] = [ item ]", "docstring_tokens": "If item is not in lst add item to list at its sorted position", "label": 0}, {"idx": "cosqa-train-11793", "doc": "how to remove the last comma from a string in python string", "code": "def delistify(x):\n    \"\"\" A basic slug version of a given parameter list. \"\"\"\n    if isinstance(x, list):\n        x = [e.replace(\"'\", \"\") for e in x]\n        return '-'.join(sorted(x))\n    return x", "code_tokens": "def delistify ( x ) : if isinstance ( x , list ) : x = [ e . replace ( \"'\" , \"\" ) for e in x ] return '-' . join ( sorted ( x ) ) return x", "docstring_tokens": "A basic slug version of a given parameter list .", "label": 1}, {"idx": "cosqa-train-11794", "doc": "python reorder list based on list of indices", "code": "def _index_ordering(redshift_list):\n        \"\"\"\n\n        :param redshift_list: list of redshifts\n        :return: indexes in acending order to be evaluated (from z=0 to z=z_source)\n        \"\"\"\n        redshift_list = np.array(redshift_list)\n        sort_index = np.argsort(redshift_list)\n        return sort_index", "code_tokens": "def _index_ordering ( redshift_list ) : redshift_list = np . array ( redshift_list ) sort_index = np . argsort ( redshift_list ) return sort_index", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-11795", "doc": "how to replace multiple substring from a string in python", "code": "def myreplace(astr, thefind, thereplace):\n    \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"\n    alist = astr.split(thefind)\n    new_s = alist.split(thereplace)\n    return new_s", "code_tokens": "def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "docstring_tokens": "in string astr replace all occurences of thefind with thereplace", "label": 1}, {"idx": "cosqa-train-11796", "doc": "python reorganise a data frame", "code": "def _preprocess(df):\n    \"\"\"\n    given a DataFrame where records are stored row-wise, rearrange it\n    such that records are stored column-wise.\n    \"\"\"\n\n    df = df.stack()\n\n    df.index.rename([\"id\", \"time\"], inplace=True)  # .reset_index()\n    df.name = \"value\"\n    df = df.reset_index()\n\n    return df", "code_tokens": "def _preprocess ( df ) : df = df . stack ( ) df . index . rename ( [ \"id\" , \"time\" ] , inplace = True ) # .reset_index() df . name = \"value\" df = df . reset_index ( ) return df", "docstring_tokens": "given a DataFrame where records are stored row - wise rearrange it such that records are stored column - wise .", "label": 1}, {"idx": "cosqa-train-11797", "doc": "how to replace placeholder in a string in python", "code": "def template_substitute(text, **kwargs):\n    \"\"\"\n    Replace placeholders in text by using the data mapping.\n    Other placeholders that is not represented by data is left untouched.\n\n    :param text:   Text to search and replace placeholders.\n    :param data:   Data mapping/dict for placeholder key and values.\n    :return: Potentially modified text with replaced placeholders.\n    \"\"\"\n    for name, value in kwargs.items():\n        placeholder_pattern = \"{%s}\" % name\n        if placeholder_pattern in text:\n            text = text.replace(placeholder_pattern, value)\n    return text", "code_tokens": "def template_substitute ( text , * * kwargs ) : for name , value in kwargs . items ( ) : placeholder_pattern = \"{%s}\" % name if placeholder_pattern in text : text = text . replace ( placeholder_pattern , value ) return text", "docstring_tokens": "Replace placeholders in text by using the data mapping . Other placeholders that is not represented by data is left untouched .", "label": 1}, {"idx": "cosqa-train-11798", "doc": "python replace case sensitive", "code": "def to_snake_case(text):\n    \"\"\"Convert to snake case.\n\n    :param str text:\n    :rtype: str\n    :return:\n    \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def to_snake_case ( text ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert to snake case .", "label": 1}, {"idx": "cosqa-train-11799", "doc": "how to replace underscores with whitespace, python", "code": "def normalise_string(string):\n    \"\"\" Strips trailing whitespace from string, lowercases it and replaces\n        spaces with underscores\n    \"\"\"\n    string = (string.strip()).lower()\n    return re.sub(r'\\W+', '_', string)", "code_tokens": "def normalise_string ( string ) : string = ( string . strip ( ) ) . lower ( ) return re . sub ( r'\\W+' , '_' , string )", "docstring_tokens": "Strips trailing whitespace from string lowercases it and replaces spaces with underscores", "label": 1}, {"idx": "cosqa-train-11800", "doc": "python replace characters in between % %", "code": "def quote(s, unsafe='/'):\n    \"\"\"Pass in a dictionary that has unsafe characters as the keys, and the percent\n    encoded value as the value.\"\"\"\n    res = s.replace('%', '%25')\n    for c in unsafe:\n        res = res.replace(c, '%' + (hex(ord(c)).upper())[2:])\n    return res", "code_tokens": "def quote ( s , unsafe = '/' ) : res = s . replace ( '%' , '%25' ) for c in unsafe : res = res . replace ( c , '%' + ( hex ( ord ( c ) ) . upper ( ) ) [ 2 : ] ) return res", "docstring_tokens": "Pass in a dictionary that has unsafe characters as the keys and the percent encoded value as the value .", "label": 1}, {"idx": "cosqa-train-11801", "doc": "how to reset the file pointer in python", "code": "def rewindbody(self):\n        \"\"\"Rewind the file to the start of the body (if seekable).\"\"\"\n        if not self.seekable:\n            raise IOError, \"unseekable file\"\n        self.fp.seek(self.startofbody)", "code_tokens": "def rewindbody ( self ) : if not self . seekable : raise IOError , \"unseekable file\" self . fp . seek ( self . startofbody )", "docstring_tokens": "Rewind the file to the start of the body ( if seekable ) .", "label": 1}, {"idx": "cosqa-train-11802", "doc": "python replace first n occurrence in string", "code": "def subn_filter(s, find, replace, count=0):\n    \"\"\"A non-optimal implementation of a regex filter\"\"\"\n    return re.gsub(find, replace, count, s)", "code_tokens": "def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )", "docstring_tokens": "A non - optimal implementation of a regex filter", "label": 0}, {"idx": "cosqa-train-11803", "doc": "how to return a match substring in python", "code": "def find_whole_word(w):\n    \"\"\"\n    Scan through string looking for a location where this word produces a match,\n    and return a corresponding MatchObject instance.\n    Return None if no position in the string matches the pattern;\n    note that this is different from finding a zero-length match at some point in the string.\n    \"\"\"\n    return re.compile(r'\\b({0})\\b'.format(w), flags=re.IGNORECASE).search", "code_tokens": "def find_whole_word ( w ) : return re . compile ( r'\\b({0})\\b' . format ( w ) , flags = re . IGNORECASE ) . search", "docstring_tokens": "Scan through string looking for a location where this word produces a match and return a corresponding MatchObject instance . Return None if no position in the string matches the pattern ; note that this is different from finding a zero - length match at some point in the string .", "label": 1}, {"idx": "cosqa-train-11804", "doc": "python replace in place string", "code": "def multi_replace(instr, search_list=[], repl_list=None):\n    \"\"\"\n    Does a string replace with a list of search and replacements\n\n    TODO: rename\n    \"\"\"\n    repl_list = [''] * len(search_list) if repl_list is None else repl_list\n    for ser, repl in zip(search_list, repl_list):\n        instr = instr.replace(ser, repl)\n    return instr", "code_tokens": "def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr", "docstring_tokens": "Does a string replace with a list of search and replacements", "label": 1}, {"idx": "cosqa-train-11805", "doc": "how to return current date and time in python", "code": "def now_time(str=False):\n    \"\"\"Get the current time.\"\"\"\n    if str:\n        return datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    return datetime.datetime.now()", "code_tokens": "def now_time ( str = False ) : if str : return datetime . datetime . now ( ) . strftime ( \"%Y-%m-%d %H:%M:%S\" ) return datetime . datetime . now ( )", "docstring_tokens": "Get the current time .", "label": 0}, {"idx": "cosqa-train-11806", "doc": "python replace many strings", "code": "def replace(s, replace):\n    \"\"\"Replace multiple values in a string\"\"\"\n    for r in replace:\n        s = s.replace(*r)\n    return s", "code_tokens": "def replace ( s , replace ) : for r in replace : s = s . replace ( * r ) return s", "docstring_tokens": "Replace multiple values in a string", "label": 1}, {"idx": "cosqa-train-11807", "doc": "how to return month number python", "code": "def calculate_month(birth_date):\n    \"\"\"\n    Calculates and returns a month number basing on PESEL standard.\n    \"\"\"\n    year = int(birth_date.strftime('%Y'))\n    month = int(birth_date.strftime('%m')) + ((int(year / 100) - 14) % 5) * 20\n\n    return month", "code_tokens": "def calculate_month ( birth_date ) : year = int ( birth_date . strftime ( '%Y' ) ) month = int ( birth_date . strftime ( '%m' ) ) + ( ( int ( year / 100 ) - 14 ) % 5 ) * 20 return month", "docstring_tokens": "Calculates and returns a month number basing on PESEL standard .", "label": 1}, {"idx": "cosqa-train-11808", "doc": "python replace numpy missing values nan", "code": "def fillna(series_or_arr, missing_value=0.0):\n    \"\"\"Fill missing values in pandas objects and numpy arrays.\n\n    Arguments\n    ---------\n    series_or_arr : pandas.Series, numpy.ndarray\n        The numpy array or pandas series for which the missing values\n        need to be replaced.\n    missing_value : float, int, str\n        The value to replace the missing value with. Default 0.0.\n\n    Returns\n    -------\n    pandas.Series, numpy.ndarray\n        The numpy array or pandas series with the missing values\n        filled.\n    \"\"\"\n\n    if pandas.notnull(missing_value):\n        if isinstance(series_or_arr, (numpy.ndarray)):\n            series_or_arr[numpy.isnan(series_or_arr)] = missing_value\n        else:\n            series_or_arr.fillna(missing_value, inplace=True)\n\n    return series_or_arr", "code_tokens": "def fillna ( series_or_arr , missing_value = 0.0 ) : if pandas . notnull ( missing_value ) : if isinstance ( series_or_arr , ( numpy . ndarray ) ) : series_or_arr [ numpy . isnan ( series_or_arr ) ] = missing_value else : series_or_arr . fillna ( missing_value , inplace = True ) return series_or_arr", "docstring_tokens": "Fill missing values in pandas objects and numpy arrays .", "label": 1}, {"idx": "cosqa-train-11809", "doc": "how to round and a number in python", "code": "def get_rounded(self, digits):\n        \"\"\" Return a vector with the elements rounded to the given number of digits. \"\"\"\n        result = self.copy()\n        result.round(digits)\n        return result", "code_tokens": "def get_rounded ( self , digits ) : result = self . copy ( ) result . round ( digits ) return result", "docstring_tokens": "Return a vector with the elements rounded to the given number of digits .", "label": 1}, {"idx": "cosqa-train-11810", "doc": "python replace regex hash comment", "code": "def _add_hash(source):\n    \"\"\"Add a leading hash '#' at the beginning of every line in the source.\"\"\"\n    source = '\\n'.join('# ' + line.rstrip()\n                       for line in source.splitlines())\n    return source", "code_tokens": "def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "docstring_tokens": "Add a leading hash # at the beginning of every line in the source .", "label": 1}, {"idx": "cosqa-train-11811", "doc": "how to run a bash script through python", "code": "def bash(filename):\n    \"\"\"Runs a bash script in the local directory\"\"\"\n    sys.stdout.flush()\n    subprocess.call(\"bash {}\".format(filename), shell=True)", "code_tokens": "def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( \"bash {}\" . format ( filename ) , shell = True )", "docstring_tokens": "Runs a bash script in the local directory", "label": 1}, {"idx": "cosqa-train-11812", "doc": "python request session change user agent", "code": "def copy_user_agent_from_driver(self):\n        \"\"\" Updates requests' session user-agent with the driver's user agent\n\n        This method will start the browser process if its not already running.\n        \"\"\"\n        selenium_user_agent = self.driver.execute_script(\"return navigator.userAgent;\")\n        self.headers.update({\"user-agent\": selenium_user_agent})", "code_tokens": "def copy_user_agent_from_driver ( self ) : selenium_user_agent = self . driver . execute_script ( \"return navigator.userAgent;\" ) self . headers . update ( { \"user-agent\" : selenium_user_agent } )", "docstring_tokens": "Updates requests session user - agent with the driver s user agent", "label": 1}, {"idx": "cosqa-train-11813", "doc": "how to run python script in jupytor", "code": "def jupytext_cli(args=None):\n    \"\"\"Entry point for the jupytext script\"\"\"\n    try:\n        jupytext(args)\n    except (ValueError, TypeError, IOError) as err:\n        sys.stderr.write('[jupytext] Error: ' + str(err) + '\\n')\n        exit(1)", "code_tokens": "def jupytext_cli ( args = None ) : try : jupytext ( args ) except ( ValueError , TypeError , IOError ) as err : sys . stderr . write ( '[jupytext] Error: ' + str ( err ) + '\\n' ) exit ( 1 )", "docstring_tokens": "Entry point for the jupytext script", "label": 0}, {"idx": "cosqa-train-11814", "doc": "python requests disable ssl verification not working", "code": "def disable_insecure_request_warning():\n    \"\"\"Suppress warning about untrusted SSL certificate.\"\"\"\n    import requests\n    from requests.packages.urllib3.exceptions import InsecureRequestWarning\n    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)", "code_tokens": "def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )", "docstring_tokens": "Suppress warning about untrusted SSL certificate .", "label": 1}, {"idx": "cosqa-train-11815", "doc": "how to save a python file as a zip", "code": "def __gzip(filename):\n\t\t\"\"\" Compress a file returning the new filename (.gz)\n\t\t\"\"\"\n\t\tzipname = filename + '.gz'\n\t\tfile_pointer = open(filename,'rb')\n\t\tzip_pointer = gzip.open(zipname,'wb')\n\t\tzip_pointer.writelines(file_pointer)\n\t\tfile_pointer.close()\n\t\tzip_pointer.close()\n\t\treturn zipname", "code_tokens": "def __gzip ( filename ) : zipname = filename + '.gz' file_pointer = open ( filename , 'rb' ) zip_pointer = gzip . open ( zipname , 'wb' ) zip_pointer . writelines ( file_pointer ) file_pointer . close ( ) zip_pointer . close ( ) return zipname", "docstring_tokens": "Compress a file returning the new filename ( . gz )", "label": 1}, {"idx": "cosqa-train-11816", "doc": "python reset clear variable explorer", "code": "def reset_namespace(self):\n        \"\"\"Resets the namespace by removing all names defined by the user\"\"\"\n        self.shellwidget.reset_namespace(warning=self.reset_warning,\n                                         message=True)", "code_tokens": "def reset_namespace ( self ) : self . shellwidget . reset_namespace ( warning = self . reset_warning , message = True )", "docstring_tokens": "Resets the namespace by removing all names defined by the user", "label": 1}, {"idx": "cosqa-train-11817", "doc": "how to save a string to file in python", "code": "def write_str2file(pathname, astr):\n    \"\"\"writes a string to file\"\"\"\n    fname = pathname\n    fhandle = open(fname, 'wb')\n    fhandle.write(astr)\n    fhandle.close()", "code_tokens": "def write_str2file ( pathname , astr ) : fname = pathname fhandle = open ( fname , 'wb' ) fhandle . write ( astr ) fhandle . close ( )", "docstring_tokens": "writes a string to file", "label": 1}, {"idx": "cosqa-train-11818", "doc": "python reshape 1x25 to 5x5", "code": "def batchify(data, batch_size):\n    \"\"\"Reshape data into (num_example, batch_size)\"\"\"\n    nbatch = data.shape[0] // batch_size\n    data = data[:nbatch * batch_size]\n    data = data.reshape((batch_size, nbatch)).T\n    return data", "code_tokens": "def batchify ( data , batch_size ) : nbatch = data . shape [ 0 ] // batch_size data = data [ : nbatch * batch_size ] data = data . reshape ( ( batch_size , nbatch ) ) . T return data", "docstring_tokens": "Reshape data into ( num_example batch_size )", "label": 1}, {"idx": "cosqa-train-11819", "doc": "how to save contents of a variable to a file python", "code": "def save(variable, filename):\n    \"\"\"Save variable on given path using Pickle\n    \n    Args:\n        variable: what to save\n        path (str): path of the output\n    \"\"\"\n    fileObj = open(filename, 'wb')\n    pickle.dump(variable, fileObj)\n    fileObj.close()", "code_tokens": "def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )", "docstring_tokens": "Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output", "label": 1}, {"idx": "cosqa-train-11820", "doc": "python resize image aspect", "code": "def scale_image(image, new_width):\n    \"\"\"Resizes an image preserving the aspect ratio.\n    \"\"\"\n    (original_width, original_height) = image.size\n    aspect_ratio = original_height/float(original_width)\n    new_height = int(aspect_ratio * new_width)\n\n    # This scales it wider than tall, since characters are biased\n    new_image = image.resize((new_width*2, new_height))\n    return new_image", "code_tokens": "def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image", "docstring_tokens": "Resizes an image preserving the aspect ratio .", "label": 1}, {"idx": "cosqa-train-11821", "doc": "how to say yes in a input in python", "code": "def input_yn(conf_mess):\n    \"\"\"Print Confirmation Message and Get Y/N response from user.\"\"\"\n    ui_erase_ln()\n    ui_print(conf_mess)\n    with term.cbreak():\n        input_flush()\n        val = input_by_key()\n    return bool(val.lower() == 'y')", "code_tokens": "def input_yn ( conf_mess ) : ui_erase_ln ( ) ui_print ( conf_mess ) with term . cbreak ( ) : input_flush ( ) val = input_by_key ( ) return bool ( val . lower ( ) == 'y' )", "docstring_tokens": "Print Confirmation Message and Get Y / N response from user .", "label": 1}, {"idx": "cosqa-train-11822", "doc": "python resize image maintaining aspect ratio", "code": "def scale_image(image, new_width):\n    \"\"\"Resizes an image preserving the aspect ratio.\n    \"\"\"\n    (original_width, original_height) = image.size\n    aspect_ratio = original_height/float(original_width)\n    new_height = int(aspect_ratio * new_width)\n\n    # This scales it wider than tall, since characters are biased\n    new_image = image.resize((new_width*2, new_height))\n    return new_image", "code_tokens": "def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image", "docstring_tokens": "Resizes an image preserving the aspect ratio .", "label": 1}, {"idx": "cosqa-train-11823", "doc": "python respond to interrupt ctrl+c", "code": "def signal_handler(signal_name, frame):\n    \"\"\"Quit signal handler.\"\"\"\n    sys.stdout.flush()\n    print(\"\\nSIGINT in frame signal received. Quitting...\")\n    sys.stdout.flush()\n    sys.exit(0)", "code_tokens": "def signal_handler ( signal_name , frame ) : sys . stdout . flush ( ) print ( \"\\nSIGINT in frame signal received. Quitting...\" ) sys . stdout . flush ( ) sys . exit ( 0 )", "docstring_tokens": "Quit signal handler .", "label": 1}, {"idx": "cosqa-train-11824", "doc": "how to see members of a group hdf5 python", "code": "def _read_group_h5(filename, groupname):\n    \"\"\"Return group content.\n\n    Args:\n        filename (:class:`pathlib.Path`): path of hdf5 file.\n        groupname (str): name of group to read.\n    Returns:\n        :class:`numpy.array`: content of group.\n    \"\"\"\n    with h5py.File(filename, 'r') as h5f:\n        data = h5f[groupname][()]\n    return data", "code_tokens": "def _read_group_h5 ( filename , groupname ) : with h5py . File ( filename , 'r' ) as h5f : data = h5f [ groupname ] [ ( ) ] return data", "docstring_tokens": "Return group content .", "label": 1}, {"idx": "cosqa-train-11825", "doc": "python respond to prompt", "code": "def _normal_prompt(self):\n        \"\"\"\n        Flushes the prompt before requesting the input\n\n        :return: The command line\n        \"\"\"\n        sys.stdout.write(self.__get_ps1())\n        sys.stdout.flush()\n        return safe_input()", "code_tokens": "def _normal_prompt ( self ) : sys . stdout . write ( self . __get_ps1 ( ) ) sys . stdout . flush ( ) return safe_input ( )", "docstring_tokens": "Flushes the prompt before requesting the input", "label": 1}, {"idx": "cosqa-train-11826", "doc": "how to see out a vector python", "code": "def normalized(vector):\n    \"\"\"\n    Get unit vector for a given one.\n\n    :param vector:\n        Numpy vector as coordinates in Cartesian space, or an array of such.\n    :returns:\n        Numpy array of the same shape and structure where all vectors are\n        normalized. That is, each coordinate component is divided by its\n        vector's length.\n    \"\"\"\n    length = numpy.sum(vector * vector, axis=-1)\n    length = numpy.sqrt(length.reshape(length.shape + (1, )))\n    return vector / length", "code_tokens": "def normalized ( vector ) : length = numpy . sum ( vector * vector , axis = - 1 ) length = numpy . sqrt ( length . reshape ( length . shape + ( 1 , ) ) ) return vector / length", "docstring_tokens": "Get unit vector for a given one .", "label": 1}, {"idx": "cosqa-train-11827", "doc": "python respose to json", "code": "def json_response(data, status=200):\n    \"\"\"Return a JsonResponse. Make sure you have django installed first.\"\"\"\n    from django.http import JsonResponse\n    return JsonResponse(data=data, status=status, safe=isinstance(data, dict))", "code_tokens": "def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )", "docstring_tokens": "Return a JsonResponse . Make sure you have django installed first .", "label": 1}, {"idx": "cosqa-train-11828", "doc": "how to select percentile range of a dataset in python", "code": "def ci(a, which=95, axis=None):\n    \"\"\"Return a percentile range from an array of values.\"\"\"\n    p = 50 - which / 2, 50 + which / 2\n    return percentiles(a, p, axis)", "code_tokens": "def ci ( a , which = 95 , axis = None ) : p = 50 - which / 2 , 50 + which / 2 return percentiles ( a , p , axis )", "docstring_tokens": "Return a percentile range from an array of values .", "label": 0}, {"idx": "cosqa-train-11829", "doc": "python restful services calling not automate", "code": "def stats(self):\n        \"\"\"\n        Return a new raw REST interface to stats resources\n\n        :rtype: :py:class:`ns1.rest.stats.Stats`\n        \"\"\"\n        import ns1.rest.stats\n        return ns1.rest.stats.Stats(self.config)", "code_tokens": "def stats ( self ) : import ns1 . rest . stats return ns1 . rest . stats . Stats ( self . config )", "docstring_tokens": "Return a new raw REST interface to stats resources", "label": 1}, {"idx": "cosqa-train-11830", "doc": "python retrieve string from file", "code": "def str_from_file(path):\n    \"\"\"\n    Return file contents as string.\n\n    \"\"\"\n    with open(path) as f:\n        s = f.read().strip()\n    return s", "code_tokens": "def str_from_file ( path ) : with open ( path ) as f : s = f . read ( ) . strip ( ) return s", "docstring_tokens": "Return file contents as string .", "label": 1}, {"idx": "cosqa-train-11831", "doc": "how to set a default spacing in python", "code": "def indent(txt, spacing=4):\n    \"\"\"\n    Indent given text using custom spacing, default is set to 4.\n    \"\"\"\n    return prefix(str(txt), ''.join([' ' for _ in range(spacing)]))", "code_tokens": "def indent ( txt , spacing = 4 ) : return prefix ( str ( txt ) , '' . join ( [ ' ' for _ in range ( spacing ) ] ) )", "docstring_tokens": "Indent given text using custom spacing default is set to 4 .", "label": 1}, {"idx": "cosqa-train-11832", "doc": "python return average growth in year span", "code": "def growthfromrange(rangegrowth, startdate, enddate):\n    \"\"\"\n    Annual growth given growth from start date to end date.\n    \"\"\"\n    _yrs = (pd.Timestamp(enddate) - pd.Timestamp(startdate)).total_seconds() /\\\n            dt.timedelta(365.25).total_seconds()\n    return yrlygrowth(rangegrowth, _yrs)", "code_tokens": "def growthfromrange ( rangegrowth , startdate , enddate ) : _yrs = ( pd . Timestamp ( enddate ) - pd . Timestamp ( startdate ) ) . total_seconds ( ) / dt . timedelta ( 365.25 ) . total_seconds ( ) return yrlygrowth ( rangegrowth , _yrs )", "docstring_tokens": "Annual growth given growth from start date to end date .", "label": 1}, {"idx": "cosqa-train-11833", "doc": "how to set an image as background in python", "code": "def copy_image_on_background(image, color=WHITE):\n    \"\"\"\n    Create a new image by copying the image on a *color* background.\n\n    Args:\n        image (PIL.Image.Image): Image to copy\n        color (tuple): Background color usually WHITE or BLACK\n\n    Returns:\n        PIL.Image.Image\n\n    \"\"\"\n    background = Image.new(\"RGB\", image.size, color)\n    background.paste(image, mask=image.split()[3])\n    return background", "code_tokens": "def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( \"RGB\" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background", "docstring_tokens": "Create a new image by copying the image on a * color * background .", "label": 1}, {"idx": "cosqa-train-11834", "doc": "python return index of list item", "code": "def get_list_index(lst, index_or_name):\n    \"\"\"\n    Return the index of an element in the list.\n\n    Args:\n        lst (list): The list.\n        index_or_name (int or str): The value of the reference element, or directly its numeric index.\n\n    Returns:\n        (int) The index of the element in the list.\n    \"\"\"\n    if isinstance(index_or_name, six.integer_types):\n        return index_or_name\n\n    return lst.index(index_or_name)", "code_tokens": "def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )", "docstring_tokens": "Return the index of an element in the list .", "label": 1}, {"idx": "cosqa-train-11835", "doc": "how to set y axis as log python", "code": "def log_y_cb(self, w, val):\n        \"\"\"Toggle linear/log scale for Y-axis.\"\"\"\n        self.tab_plot.logy = val\n        self.plot_two_columns()", "code_tokens": "def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )", "docstring_tokens": "Toggle linear / log scale for Y - axis .", "label": 1}, {"idx": "cosqa-train-11836", "doc": "python return index of match in string list", "code": "def where_is(strings, pattern, n=1, lookup_func=re.match):\n    \"\"\"Return index of the nth match found of pattern in strings\n\n    Parameters\n    ----------\n    strings: list of str\n        List of strings\n\n    pattern: str\n        Pattern to be matched\n\n    nth: int\n        Number of times the match must happen to return the item index.\n\n    lookup_func: callable\n        Function to match each item in strings to the pattern, e.g., re.match or re.search.\n\n    Returns\n    -------\n    index: int\n        Index of the nth item that matches the pattern.\n        If there are no n matches will return -1\n    \"\"\"\n    count = 0\n    for idx, item in enumerate(strings):\n        if lookup_func(pattern, item):\n            count += 1\n            if count == n:\n                return idx\n    return -1", "code_tokens": "def where_is ( strings , pattern , n = 1 , lookup_func = re . match ) : count = 0 for idx , item in enumerate ( strings ) : if lookup_func ( pattern , item ) : count += 1 if count == n : return idx return - 1", "docstring_tokens": "Return index of the nth match found of pattern in strings", "label": 1}, {"idx": "cosqa-train-11837", "doc": "how to show a variable amount of precision in python string format", "code": "def indented_show(text, howmany=1):\n        \"\"\"Print a formatted indented text.\n        \"\"\"\n        print(StrTemplate.pad_indent(text=text, howmany=howmany))", "code_tokens": "def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )", "docstring_tokens": "Print a formatted indented text .", "label": 1}, {"idx": "cosqa-train-11838", "doc": "python return last item of queryset", "code": "def end_index(self):\n        \"\"\"\n        Returns the 1-based index of the last object on this page,\n        relative to total objects found (hits).\n        \"\"\"\n        return ((self.number - 1) * self.paginator.per_page +\n            len(self.object_list))", "code_tokens": "def end_index ( self ) : return ( ( self . number - 1 ) * self . paginator . per_page + len ( self . object_list ) )", "docstring_tokens": "Returns the 1 - based index of the last object on this page relative to total objects found ( hits ) .", "label": 1}, {"idx": "cosqa-train-11839", "doc": "how to show plot after plotting python", "code": "def show(self, title=''):\n        \"\"\"\n        Display Bloch sphere and corresponding data sets.\n        \"\"\"\n        self.render(title=title)\n        if self.fig:\n            plt.show(self.fig)", "code_tokens": "def show ( self , title = '' ) : self . render ( title = title ) if self . fig : plt . show ( self . fig )", "docstring_tokens": "Display Bloch sphere and corresponding data sets .", "label": 1}, {"idx": "cosqa-train-11840", "doc": "python return list index if string", "code": "def get_list_index(lst, index_or_name):\n    \"\"\"\n    Return the index of an element in the list.\n\n    Args:\n        lst (list): The list.\n        index_or_name (int or str): The value of the reference element, or directly its numeric index.\n\n    Returns:\n        (int) The index of the element in the list.\n    \"\"\"\n    if isinstance(index_or_name, six.integer_types):\n        return index_or_name\n\n    return lst.index(index_or_name)", "code_tokens": "def get_list_index ( lst , index_or_name ) : if isinstance ( index_or_name , six . integer_types ) : return index_or_name return lst . index ( index_or_name )", "docstring_tokens": "Return the index of an element in the list .", "label": 1}, {"idx": "cosqa-train-11841", "doc": "python return property objectno not value", "code": "def value(self):\n        \"\"\"Value of property.\"\"\"\n        if self._prop.fget is None:\n            raise AttributeError('Unable to read attribute')\n        return self._prop.fget(self._obj)", "code_tokens": "def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )", "docstring_tokens": "Value of property .", "label": 1}, {"idx": "cosqa-train-11842", "doc": "how to show time complexity python", "code": "def estimate_complexity(self, x,y,z,n):\n        \"\"\" \n        calculates a rough guess of runtime based on product of parameters \n        \"\"\"\n        num_calculations = x * y * z * n\n        run_time = num_calculations / 100000  # a 2014 PC does about 100k calcs in a second (guess based on prior logs)\n        return self.show_time_as_short_string(run_time)", "code_tokens": "def estimate_complexity ( self , x , y , z , n ) : num_calculations = x * y * z * n run_time = num_calculations / 100000 # a 2014 PC does about 100k calcs in a second (guess based on prior logs) return self . show_time_as_short_string ( run_time )", "docstring_tokens": "calculates a rough guess of runtime based on product of parameters", "label": 1}, {"idx": "cosqa-train-11843", "doc": "python return range of array", "code": "def _interval_to_bound_points(array):\n    \"\"\"\n    Helper function which returns an array\n    with the Intervals' boundaries.\n    \"\"\"\n\n    array_boundaries = np.array([x.left for x in array])\n    array_boundaries = np.concatenate(\n        (array_boundaries, np.array([array[-1].right])))\n\n    return array_boundaries", "code_tokens": "def _interval_to_bound_points ( array ) : array_boundaries = np . array ( [ x . left for x in array ] ) array_boundaries = np . concatenate ( ( array_boundaries , np . array ( [ array [ - 1 ] . right ] ) ) ) return array_boundaries", "docstring_tokens": "Helper function which returns an array with the Intervals boundaries .", "label": 1}, {"idx": "cosqa-train-11844", "doc": "how to shuffle the array in python", "code": "def _shuffle(data, idx):\n    \"\"\"Shuffle the data.\"\"\"\n    shuffle_data = []\n\n    for idx_k, idx_v in data:\n        shuffle_data.append((idx_k, mx.ndarray.array(idx_v.asnumpy()[idx], idx_v.context)))\n\n    return shuffle_data", "code_tokens": "def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data", "docstring_tokens": "Shuffle the data .", "label": 1}, {"idx": "cosqa-train-11845", "doc": "python reverse iterator map", "code": "def __reversed__(self):\n        \"\"\"\n        Return a reversed iterable over the items in the dictionary. Items are\n        iterated over in their reverse sort order.\n\n        Iterating views while adding or deleting entries in the dictionary may\n        raise a RuntimeError or fail to iterate over all entries.\n        \"\"\"\n        _dict = self._dict\n        return iter((key, _dict[key]) for key in reversed(self._list))", "code_tokens": "def __reversed__ ( self ) : _dict = self . _dict return iter ( ( key , _dict [ key ] ) for key in reversed ( self . _list ) )", "docstring_tokens": "Return a reversed iterable over the items in the dictionary . Items are iterated over in their reverse sort order .", "label": 1}, {"idx": "cosqa-train-11846", "doc": "how to singularize vector python", "code": "def norm_vec(vector):\n    \"\"\"Normalize the length of a vector to one\"\"\"\n    assert len(vector) == 3\n    v = np.array(vector)\n    return v/np.sqrt(np.sum(v**2))", "code_tokens": "def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )", "docstring_tokens": "Normalize the length of a vector to one", "label": 1}, {"idx": "cosqa-train-11847", "doc": "python rewind file inside with", "code": "def rewindbody(self):\n        \"\"\"Rewind the file to the start of the body (if seekable).\"\"\"\n        if not self.seekable:\n            raise IOError, \"unseekable file\"\n        self.fp.seek(self.startofbody)", "code_tokens": "def rewindbody ( self ) : if not self . seekable : raise IOError , \"unseekable file\" self . fp . seek ( self . startofbody )", "docstring_tokens": "Rewind the file to the start of the body ( if seekable ) .", "label": 1}, {"idx": "cosqa-train-11848", "doc": "how to skip an index in a for loop python", "code": "def stop_at(iterable, idx):\n    \"\"\"Stops iterating before yielding the specified idx.\"\"\"\n    for i, item in enumerate(iterable):\n        if i == idx: return\n        yield item", "code_tokens": "def stop_at ( iterable , idx ) : for i , item in enumerate ( iterable ) : if i == idx : return yield item", "docstring_tokens": "Stops iterating before yielding the specified idx .", "label": 1}, {"idx": "cosqa-train-11849", "doc": "python rotate transform 3d coordinates", "code": "def R_rot_3d(th):\n    \"\"\"Return a 3-dimensional rotation matrix.\n\n    Parameters\n    ----------\n    th: array, shape (n, 3)\n        Angles about which to rotate along each axis.\n\n    Returns\n    -------\n    R: array, shape (n, 3, 3)\n    \"\"\"\n    sx, sy, sz = np.sin(th).T\n    cx, cy, cz = np.cos(th).T\n    R = np.empty((len(th), 3, 3), dtype=np.float)\n\n    R[:, 0, 0] = cy * cz\n    R[:, 0, 1] = -cy * sz\n    R[:, 0, 2] = sy\n\n    R[:, 1, 0] = sx * sy * cz + cx * sz\n    R[:, 1, 1] = -sx * sy * sz + cx * cz\n    R[:, 1, 2] = -sx * cy\n\n    R[:, 2, 0] = -cx * sy * cz + sx * sz\n    R[:, 2, 1] = cx * sy * sz + sx * cz\n    R[:, 2, 2] = cx * cy\n    return R", "code_tokens": "def R_rot_3d ( th ) : sx , sy , sz = np . sin ( th ) . T cx , cy , cz = np . cos ( th ) . T R = np . empty ( ( len ( th ) , 3 , 3 ) , dtype = np . float ) R [ : , 0 , 0 ] = cy * cz R [ : , 0 , 1 ] = - cy * sz R [ : , 0 , 2 ] = sy R [ : , 1 , 0 ] = sx * sy * cz + cx * sz R [ : , 1 , 1 ] = - sx * sy * sz + cx * cz R [ : , 1 , 2 ] = - sx * cy R [ : , 2 , 0 ] = - cx * sy * cz + sx * sz R [ : , 2 , 1 ] = cx * sy * sz + sx * cz R [ : , 2 , 2 ] = cx * cy return R", "docstring_tokens": "Return a 3 - dimensional rotation matrix .", "label": 1}, {"idx": "cosqa-train-11850", "doc": "how to slice in python stack overflow", "code": "def Slice(a, begin, size):\n    \"\"\"\n    Slicing op.\n    \"\"\"\n    return np.copy(a)[[slice(*tpl) for tpl in zip(begin, begin+size)]],", "code_tokens": "def Slice ( a , begin , size ) : return np . copy ( a ) [ [ slice ( * tpl ) for tpl in zip ( begin , begin + size ) ] ] ,", "docstring_tokens": "Slicing op .", "label": 1}, {"idx": "cosqa-train-11851", "doc": "python rotation matrix to rotation vector", "code": "def from_rotation_vector(rot):\n    \"\"\"Convert input 3-vector in axis-angle representation to unit quaternion\n\n    Parameters\n    ----------\n    rot: (Nx3) float array\n        Each vector represents the axis of the rotation, with norm\n        proportional to the angle of the rotation in radians.\n\n    Returns\n    -------\n    q: array of quaternions\n        Unit quaternions resulting in rotations corresponding to input\n        rotations.  Output shape is rot.shape[:-1].\n\n    \"\"\"\n    rot = np.array(rot, copy=False)\n    quats = np.zeros(rot.shape[:-1]+(4,))\n    quats[..., 1:] = rot[...]/2\n    quats = as_quat_array(quats)\n    return np.exp(quats)", "code_tokens": "def from_rotation_vector ( rot ) : rot = np . array ( rot , copy = False ) quats = np . zeros ( rot . shape [ : - 1 ] + ( 4 , ) ) quats [ ... , 1 : ] = rot [ ... ] / 2 quats = as_quat_array ( quats ) return np . exp ( quats )", "docstring_tokens": "Convert input 3 - vector in axis - angle representation to unit quaternion", "label": 1}, {"idx": "cosqa-train-11852", "doc": "how to sort a numpy array and store the index od descending value in python", "code": "def unsort_vector(data, indices_of_increasing):\n    \"\"\"Upermutate 1-D data that is sorted by indices_of_increasing.\"\"\"\n    return numpy.array([data[indices_of_increasing.index(i)] for i in range(len(data))])", "code_tokens": "def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )", "docstring_tokens": "Upermutate 1 - D data that is sorted by indices_of_increasing .", "label": 1}, {"idx": "cosqa-train-11853", "doc": "python round down float to integer", "code": "def intround(value):\n    \"\"\"Given a float returns a rounded int. Should give the same result on\n    both Py2/3\n    \"\"\"\n\n    return int(decimal.Decimal.from_float(\n        value).to_integral_value(decimal.ROUND_HALF_EVEN))", "code_tokens": "def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )", "docstring_tokens": "Given a float returns a rounded int . Should give the same result on both Py2 / 3", "label": 1}, {"idx": "cosqa-train-11854", "doc": "how to sort data in python based on column values", "code": "def sort_data(data, cols):\n    \"\"\"Sort `data` rows and order columns\"\"\"\n    return data.sort_values(cols)[cols + ['value']].reset_index(drop=True)", "code_tokens": "def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )", "docstring_tokens": "Sort data rows and order columns", "label": 1}, {"idx": "cosqa-train-11855", "doc": "python rq get job finished percemtwge", "code": "def rq_job(self):\n        \"\"\"The last RQ Job this ran on\"\"\"\n        if not self.rq_id or not self.rq_origin:\n            return\n        try:\n            return RQJob.fetch(self.rq_id, connection=get_connection(self.rq_origin))\n        except NoSuchJobError:\n            return", "code_tokens": "def rq_job ( self ) : if not self . rq_id or not self . rq_origin : return try : return RQJob . fetch ( self . rq_id , connection = get_connection ( self . rq_origin ) ) except NoSuchJobError : return", "docstring_tokens": "The last RQ Job this ran on", "label": 1}, {"idx": "cosqa-train-11856", "doc": "how to sort items in a key python", "code": "def transcript_sort_key(transcript):\n    \"\"\"\n    Key function used to sort transcripts. Taking the negative of\n    protein sequence length and nucleotide sequence length so that\n    the transcripts with longest sequences come first in the list. This couldn't\n    be accomplished with `reverse=True` since we're also sorting by\n    transcript name (which places TP53-001 before TP53-002).\n    \"\"\"\n    return (\n        -len(transcript.protein_sequence),\n        -len(transcript.sequence),\n        transcript.name\n    )", "code_tokens": "def transcript_sort_key ( transcript ) : return ( - len ( transcript . protein_sequence ) , - len ( transcript . sequence ) , transcript . name )", "docstring_tokens": "Key function used to sort transcripts . Taking the negative of protein sequence length and nucleotide sequence length so that the transcripts with longest sequences come first in the list . This couldn t be accomplished with reverse = True since we re also sorting by transcript name ( which places TP53 - 001 before TP53 - 002 ) .", "label": 1}, {"idx": "cosqa-train-11857", "doc": "python run external command in background", "code": "def execute_in_background(self):\n        \"\"\"Executes a (shell) command in the background\n\n        :return: the process' pid\n        \"\"\"\n        # http://stackoverflow.com/questions/1605520\n        args = shlex.split(self.cmd)\n        p = Popen(args)\n        return p.pid", "code_tokens": "def execute_in_background ( self ) : # http://stackoverflow.com/questions/1605520 args = shlex . split ( self . cmd ) p = Popen ( args ) return p . pid", "docstring_tokens": "Executes a ( shell ) command in the background", "label": 1}, {"idx": "cosqa-train-11858", "doc": "how to sort mapped objects in python", "code": "def csort(objs, key):\n    \"\"\"Order-preserving sorting function.\"\"\"\n    idxs = dict((obj, i) for (i, obj) in enumerate(objs))\n    return sorted(objs, key=lambda obj: (key(obj), idxs[obj]))", "code_tokens": "def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )", "docstring_tokens": "Order - preserving sorting function .", "label": 1}, {"idx": "cosqa-train-11859", "doc": "python run sync function in async function", "code": "async def _thread_coro(self, *args):\n        \"\"\" Coroutine called by MapAsync. It's wrapping the call of\n        run_in_executor to run the synchronous function as thread \"\"\"\n        return await self._loop.run_in_executor(\n            self._executor, self._function, *args)", "code_tokens": "async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "docstring_tokens": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread", "label": 1}, {"idx": "cosqa-train-11860", "doc": "how to sort objects in a set python", "code": "def csort(objs, key):\n    \"\"\"Order-preserving sorting function.\"\"\"\n    idxs = dict((obj, i) for (i, obj) in enumerate(objs))\n    return sorted(objs, key=lambda obj: (key(obj), idxs[obj]))", "code_tokens": "def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )", "docstring_tokens": "Order - preserving sorting function .", "label": 1}, {"idx": "cosqa-train-11861", "doc": "python sanitize path windows", "code": "def normalize_path(filename):\n    \"\"\"Normalize a file/dir name for comparison purposes\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.normpath(_cygwin_patch(filename))))", "code_tokens": "def normalize_path ( filename ) : return os . path . normcase ( os . path . realpath ( os . path . normpath ( _cygwin_patch ( filename ) ) ) )", "docstring_tokens": "Normalize a file / dir name for comparison purposes", "label": 1}, {"idx": "cosqa-train-11862", "doc": "how to specifiy width in format python", "code": "def text_width(string, font_name, font_size):\n    \"\"\"Determine with width in pixels of string.\"\"\"\n    return stringWidth(string, fontName=font_name, fontSize=font_size)", "code_tokens": "def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )", "docstring_tokens": "Determine with width in pixels of string .", "label": 1}, {"idx": "cosqa-train-11863", "doc": "python save a variable to file", "code": "def save(variable, filename):\n    \"\"\"Save variable on given path using Pickle\n    \n    Args:\n        variable: what to save\n        path (str): path of the output\n    \"\"\"\n    fileObj = open(filename, 'wb')\n    pickle.dump(variable, fileObj)\n    fileObj.close()", "code_tokens": "def save ( variable , filename ) : fileObj = open ( filename , 'wb' ) pickle . dump ( variable , fileObj ) fileObj . close ( )", "docstring_tokens": "Save variable on given path using Pickle Args : variable : what to save path ( str ) : path of the output", "label": 1}, {"idx": "cosqa-train-11864", "doc": "how to specify domain name resolution in python", "code": "def _config_win32_domain(self, domain):\n        \"\"\"Configure a Domain registry entry.\"\"\"\n        # we call str() on domain to convert it from unicode to ascii\n        self.domain = dns.name.from_text(str(domain))", "code_tokens": "def _config_win32_domain ( self , domain ) : # we call str() on domain to convert it from unicode to ascii self . domain = dns . name . from_text ( str ( domain ) )", "docstring_tokens": "Configure a Domain registry entry .", "label": 1}, {"idx": "cosqa-train-11865", "doc": "python save array as compressed array", "code": "def _array2cstr(arr):\n    \"\"\" Serializes a numpy array to a compressed base64 string \"\"\"\n    out = StringIO()\n    np.save(out, arr)\n    return b64encode(out.getvalue())", "code_tokens": "def _array2cstr ( arr ) : out = StringIO ( ) np . save ( out , arr ) return b64encode ( out . getvalue ( ) )", "docstring_tokens": "Serializes a numpy array to a compressed base64 string", "label": 1}, {"idx": "cosqa-train-11866", "doc": "how to specify first elment of series python", "code": "def first(series, order_by=None):\n    \"\"\"\n    Returns the first value of a series.\n\n    Args:\n        series (pandas.Series): column to summarize.\n\n    Kwargs:\n        order_by: a pandas.Series or list of series (can be symbolic) to order\n            the input series by before summarization.\n    \"\"\"\n\n    if order_by is not None:\n        series = order_series_by(series, order_by)\n    first_s = series.iloc[0]\n    return first_s", "code_tokens": "def first ( series , order_by = None ) : if order_by is not None : series = order_series_by ( series , order_by ) first_s = series . iloc [ 0 ] return first_s", "docstring_tokens": "Returns the first value of a series .", "label": 1}, {"idx": "cosqa-train-11867", "doc": "python save graph to file", "code": "def to_dotfile(G: nx.DiGraph, filename: str):\n    \"\"\" Output a networkx graph to a DOT file. \"\"\"\n    A = to_agraph(G)\n    A.write(filename)", "code_tokens": "def to_dotfile ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . write ( filename )", "docstring_tokens": "Output a networkx graph to a DOT file .", "label": 1}, {"idx": "cosqa-train-11868", "doc": "how to specify the number of digits in python floats", "code": "def set_sig_figs(n=4):\n    \"\"\"Set the number of significant figures used to print Pint, Pandas, and\n    NumPy quantities.\n\n    Args:\n        n (int): Number of significant figures to display.\n    \"\"\"\n    u.default_format = '.' + str(n) + 'g'\n    pd.options.display.float_format = ('{:,.' + str(n) + '}').format", "code_tokens": "def set_sig_figs ( n = 4 ) : u . default_format = '.' + str ( n ) + 'g' pd . options . display . float_format = ( '{:,.' + str ( n ) + '}' ) . format", "docstring_tokens": "Set the number of significant figures used to print Pint Pandas and NumPy quantities .", "label": 1}, {"idx": "cosqa-train-11869", "doc": "python save keras model", "code": "def save_keras_definition(keras_model, path):\n    \"\"\"\n    Save a Keras model definition to JSON with given path\n    \"\"\"\n    model_json = keras_model.to_json()\n    with open(path, \"w\") as json_file:\n        json_file.write(model_json)", "code_tokens": "def save_keras_definition ( keras_model , path ) : model_json = keras_model . to_json ( ) with open ( path , \"w\" ) as json_file : json_file . write ( model_json )", "docstring_tokens": "Save a Keras model definition to JSON with given path", "label": 1}, {"idx": "cosqa-train-11870", "doc": "how to specify type in python", "code": "def get_kind(self, value):\n        \"\"\"Return the kind (type) of the attribute\"\"\"\n        if isinstance(value, float):\n            return 'f'\n        elif isinstance(value, int):\n            return 'i'\n        else:\n            raise ValueError(\"Only integer or floating point values can be stored.\")", "code_tokens": "def get_kind ( self , value ) : if isinstance ( value , float ) : return 'f' elif isinstance ( value , int ) : return 'i' else : raise ValueError ( \"Only integer or floating point values can be stored.\" )", "docstring_tokens": "Return the kind ( type ) of the attribute", "label": 0}, {"idx": "cosqa-train-11871", "doc": "python save url image to local", "code": "def get_local_image(self, src):\n        \"\"\"\\\n        returns the bytes of the image file on disk\n        \"\"\"\n        return ImageUtils.store_image(self.fetcher, self.article.link_hash, src, self.config)", "code_tokens": "def get_local_image ( self , src ) : return ImageUtils . store_image ( self . fetcher , self . article . link_hash , src , self . config )", "docstring_tokens": "\\ returns the bytes of the image file on disk", "label": 0}, {"idx": "cosqa-train-11872", "doc": "how to splice a confusion matrix python sklearn", "code": "def incidence(boundary):\n    \"\"\"\n    given an Nxm matrix containing boundary info between simplices,\n    compute indidence info matrix\n    not very reusable; should probably not be in this lib\n    \"\"\"\n    return GroupBy(boundary).split(np.arange(boundary.size) // boundary.shape[1])", "code_tokens": "def incidence ( boundary ) : return GroupBy ( boundary ) . split ( np . arange ( boundary . size ) // boundary . shape [ 1 ] )", "docstring_tokens": "given an Nxm matrix containing boundary info between simplices compute indidence info matrix not very reusable ; should probably not be in this lib", "label": 0}, {"idx": "cosqa-train-11873", "doc": "python scale down an image", "code": "def set_scale(self, scale, no_reset=False):\n        \"\"\"Scale the image in a channel.\n        Also see :meth:`zoom_to`.\n\n        Parameters\n        ----------\n        scale : tuple of float\n            Scaling factors for the image in the X and Y axes.\n\n        no_reset : bool\n            Do not reset ``autozoom`` setting.\n\n        \"\"\"\n        return self.scale_to(*scale[:2], no_reset=no_reset)", "code_tokens": "def set_scale ( self , scale , no_reset = False ) : return self . scale_to ( * scale [ : 2 ] , no_reset = no_reset )", "docstring_tokens": "Scale the image in a channel . Also see : meth : zoom_to .", "label": 1}, {"idx": "cosqa-train-11874", "doc": "how to split a list into unequal size chunks python", "code": "def _chunks(l, n):\n    \"\"\" Yield successive n-sized chunks from l.\n\n    http://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks-in-python\n    \"\"\"\n    for i in xrange(0, len(l), n):\n        yield l[i:i+n]", "code_tokens": "def _chunks ( l , n ) : for i in xrange ( 0 , len ( l ) , n ) : yield l [ i : i + n ]", "docstring_tokens": "Yield successive n - sized chunks from l .", "label": 1}, {"idx": "cosqa-train-11875", "doc": "python scipy matplotlib multiple regression def", "code": "def linregress(x, y, return_stats=False):\n    \"\"\"linear regression calculation\n\n    Parameters\n    ----\n    x :         independent variable (series)\n    y :         dependent variable (series)\n    return_stats : returns statistical values as well if required (bool)\n    \n\n    Returns\n    ----\n    list of parameters (and statistics)\n    \"\"\"\n    a1, a0, r_value, p_value, stderr = scipy.stats.linregress(x, y)\n\n    retval = a1, a0\n    if return_stats:\n        retval += r_value, p_value, stderr\n\n    return retval", "code_tokens": "def linregress ( x , y , return_stats = False ) : a1 , a0 , r_value , p_value , stderr = scipy . stats . linregress ( x , y ) retval = a1 , a0 if return_stats : retval += r_value , p_value , stderr return retval", "docstring_tokens": "linear regression calculation", "label": 1}, {"idx": "cosqa-train-11876", "doc": "how to split a string by every character in python", "code": "def _split(string, splitters):\n    \"\"\"Splits a string into parts at multiple characters\"\"\"\n    part = ''\n    for character in string:\n        if character in splitters:\n            yield part\n            part = ''\n        else:\n            part += character\n    yield part", "code_tokens": "def _split ( string , splitters ) : part = '' for character in string : if character in splitters : yield part part = '' else : part += character yield part", "docstring_tokens": "Splits a string into parts at multiple characters", "label": 1}, {"idx": "cosqa-train-11877", "doc": "python script for running hive query", "code": "def run_hive_script(script):\n    \"\"\"\n    Runs the contents of the given script in hive and returns stdout.\n    \"\"\"\n    if not os.path.isfile(script):\n        raise RuntimeError(\"Hive script: {0} does not exist.\".format(script))\n    return run_hive(['-f', script])", "code_tokens": "def run_hive_script ( script ) : if not os . path . isfile ( script ) : raise RuntimeError ( \"Hive script: {0} does not exist.\" . format ( script ) ) return run_hive ( [ '-f' , script ] )", "docstring_tokens": "Runs the contents of the given script in hive and returns stdout .", "label": 1}, {"idx": "cosqa-train-11878", "doc": "how to stop python execution externally", "code": "def stop_button_click_handler(self):\n        \"\"\"Method to handle what to do when the stop button is pressed\"\"\"\n        self.stop_button.setDisabled(True)\n        # Interrupt computations or stop debugging\n        if not self.shellwidget._reading:\n            self.interrupt_kernel()\n        else:\n            self.shellwidget.write_to_stdin('exit')", "code_tokens": "def stop_button_click_handler ( self ) : self . stop_button . setDisabled ( True ) # Interrupt computations or stop debugging\n if not self . shellwidget . _reading : self . interrupt_kernel ( ) else : self . shellwidget . write_to_stdin ( 'exit' )", "docstring_tokens": "Method to handle what to do when the stop button is pressed", "label": 1}, {"idx": "cosqa-train-11879", "doc": "python script to load json files into mongodb", "code": "def load_db(file, db, verbose=True):\n    \"\"\"\n    Load :class:`mongomock.database.Database` from a local file.\n\n    :param file: file path.\n    :param db: instance of :class:`mongomock.database.Database`.\n    :param verbose: bool, toggle on log.\n    :return: loaded db.\n    \"\"\"\n    db_data = json.load(file, verbose=verbose)\n    return _load(db_data, db)", "code_tokens": "def load_db ( file , db , verbose = True ) : db_data = json . load ( file , verbose = verbose ) return _load ( db_data , db )", "docstring_tokens": "Load : class : mongomock . database . Database from a local file .", "label": 1}, {"idx": "cosqa-train-11880", "doc": "how to stop python service", "code": "def stop(self, reason=None):\n        \"\"\"Shutdown the service with a reason.\"\"\"\n        self.logger.info('stopping')\n        self.loop.stop(pyev.EVBREAK_ALL)", "code_tokens": "def stop ( self , reason = None ) : self . logger . info ( 'stopping' ) self . loop . stop ( pyev . EVBREAK_ALL )", "docstring_tokens": "Shutdown the service with a reason .", "label": 1}, {"idx": "cosqa-train-11881", "doc": "python script write pid", "code": "def _write_pidfile(pidfile):\n    \"\"\" Write file with current process ID.\n    \"\"\"\n    pid = str(os.getpid())\n    handle = open(pidfile, 'w')\n    try:\n        handle.write(\"%s\\n\" % pid)\n    finally:\n        handle.close()", "code_tokens": "def _write_pidfile ( pidfile ) : pid = str ( os . getpid ( ) ) handle = open ( pidfile , 'w' ) try : handle . write ( \"%s\\n\" % pid ) finally : handle . close ( )", "docstring_tokens": "Write file with current process ID .", "label": 1}, {"idx": "cosqa-train-11882", "doc": "how to store my coding errors of python in logfile", "code": "def on_error(e):  # pragma: no cover\n    \"\"\"Error handler\n\n    RuntimeError or ValueError exceptions raised by commands will be handled\n    by this function.\n    \"\"\"\n    exname = {'RuntimeError': 'Runtime error', 'Value Error': 'Value error'}\n    sys.stderr.write('{}: {}\\n'.format(exname[e.__class__.__name__], str(e)))\n    sys.stderr.write('See file slam_error.log for additional details.\\n')\n    sys.exit(1)", "code_tokens": "def on_error ( e ) : # pragma: no cover exname = { 'RuntimeError' : 'Runtime error' , 'Value Error' : 'Value error' } sys . stderr . write ( '{}: {}\\n' . format ( exname [ e . __class__ . __name__ ] , str ( e ) ) ) sys . stderr . write ( 'See file slam_error.log for additional details.\\n' ) sys . exit ( 1 )", "docstring_tokens": "Error handler", "label": 1}, {"idx": "cosqa-train-11883", "doc": "python script write pid file", "code": "def _write_pidfile(pidfile):\n    \"\"\" Write file with current process ID.\n    \"\"\"\n    pid = str(os.getpid())\n    handle = open(pidfile, 'w')\n    try:\n        handle.write(\"%s\\n\" % pid)\n    finally:\n        handle.close()", "code_tokens": "def _write_pidfile ( pidfile ) : pid = str ( os . getpid ( ) ) handle = open ( pidfile , 'w' ) try : handle . write ( \"%s\\n\" % pid ) finally : handle . close ( )", "docstring_tokens": "Write file with current process ID .", "label": 1}, {"idx": "cosqa-train-11884", "doc": "how to store the output of curl command in python using logger", "code": "def dump_to_log(self, logger):\n        \"\"\"Send the cmd info and collected stdout to logger.\"\"\"\n        logger.error(\"Execution ended in %s for cmd %s\", self._retcode, self._cmd)\n        for line in self._collected_stdout:\n            logger.error(STDOUT_LOG_PREFIX + line)", "code_tokens": "def dump_to_log ( self , logger ) : logger . error ( \"Execution ended in %s for cmd %s\" , self . _retcode , self . _cmd ) for line in self . _collected_stdout : logger . error ( STDOUT_LOG_PREFIX + line )", "docstring_tokens": "Send the cmd info and collected stdout to logger .", "label": 1}, {"idx": "cosqa-train-11885", "doc": "python see if char is ready for reading", "code": "def _stdin_ready_posix():\n    \"\"\"Return True if there's something to read on stdin (posix version).\"\"\"\n    infds, outfds, erfds = select.select([sys.stdin],[],[],0)\n    return bool(infds)", "code_tokens": "def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )", "docstring_tokens": "Return True if there s something to read on stdin ( posix version ) .", "label": 1}, {"idx": "cosqa-train-11886", "doc": "how to strip commas out and create list python\\", "code": "def readCommaList(fileList):\n    \"\"\" Return a list of the files with the commas removed. \"\"\"\n    names=fileList.split(',')\n    fileList=[]\n    for item in names:\n        fileList.append(item)\n    return fileList", "code_tokens": "def readCommaList ( fileList ) : names = fileList . split ( ',' ) fileList = [ ] for item in names : fileList . append ( item ) return fileList", "docstring_tokens": "Return a list of the files with the commas removed .", "label": 1}, {"idx": "cosqa-train-11887", "doc": "python select longest string in a dictionary", "code": "def find_largest_contig(contig_lengths_dict):\n    \"\"\"\n    Determine the largest contig for each strain\n    :param contig_lengths_dict: dictionary of strain name: reverse-sorted list of all contig lengths\n    :return: longest_contig_dict: dictionary of strain name: longest contig\n    \"\"\"\n    # Initialise the dictionary\n    longest_contig_dict = dict()\n    for file_name, contig_lengths in contig_lengths_dict.items():\n        # As the list is sorted in descending order, the largest contig is the first entry in the list\n        longest_contig_dict[file_name] = contig_lengths[0]\n    return longest_contig_dict", "code_tokens": "def find_largest_contig ( contig_lengths_dict ) : # Initialise the dictionary longest_contig_dict = dict ( ) for file_name , contig_lengths in contig_lengths_dict . items ( ) : # As the list is sorted in descending order, the largest contig is the first entry in the list longest_contig_dict [ file_name ] = contig_lengths [ 0 ] return longest_contig_dict", "docstring_tokens": "Determine the largest contig for each strain : param contig_lengths_dict : dictionary of strain name : reverse - sorted list of all contig lengths : return : longest_contig_dict : dictionary of strain name : longest contig", "label": 1}, {"idx": "cosqa-train-11888", "doc": "how to strip file of whitespace in python", "code": "def get_stripped_file_lines(filename):\n    \"\"\"\n    Return lines of a file with whitespace removed\n    \"\"\"\n    try:\n        lines = open(filename).readlines()\n    except FileNotFoundError:\n        fatal(\"Could not open file: {!r}\".format(filename))\n\n    return [line.strip() for line in lines]", "code_tokens": "def get_stripped_file_lines ( filename ) : try : lines = open ( filename ) . readlines ( ) except FileNotFoundError : fatal ( \"Could not open file: {!r}\" . format ( filename ) ) return [ line . strip ( ) for line in lines ]", "docstring_tokens": "Return lines of a file with whitespace removed", "label": 1}, {"idx": "cosqa-train-11889", "doc": "python select random element from set", "code": "def random_choice(sequence):\n    \"\"\" Same as :meth:`random.choice`, but also supports :class:`set` type to be passed as sequence. \"\"\"\n    return random.choice(tuple(sequence) if isinstance(sequence, set) else sequence)", "code_tokens": "def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )", "docstring_tokens": "Same as : meth : random . choice but also supports : class : set type to be passed as sequence .", "label": 1}, {"idx": "cosqa-train-11890", "doc": "how to strip first word in a string before the space python", "code": "def lowstrip(term):\n    \"\"\"Convert to lowercase and strip spaces\"\"\"\n    term = re.sub('\\s+', ' ', term)\n    term = term.lower()\n    return term", "code_tokens": "def lowstrip ( term ) : term = re . sub ( '\\s+' , ' ' , term ) term = term . lower ( ) return term", "docstring_tokens": "Convert to lowercase and strip spaces", "label": 1}, {"idx": "cosqa-train-11891", "doc": "python select rows that are not null", "code": "def selectnotnone(table, field, complement=False):\n    \"\"\"Select rows where the given field is not `None`.\"\"\"\n\n    return select(table, field, lambda v: v is not None,\n                  complement=complement)", "code_tokens": "def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )", "docstring_tokens": "Select rows where the given field is not None .", "label": 0}, {"idx": "cosqa-train-11892", "doc": "how to strip spaces from elements of a list python", "code": "def strip_spaces(value, sep=None, join=True):\n    \"\"\"Cleans trailing whitespaces and replaces also multiple whitespaces with a single space.\"\"\"\n    value = value.strip()\n    value = [v.strip() for v in value.split(sep)]\n    join_sep = sep or ' '\n    return join_sep.join(value) if join else value", "code_tokens": "def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value", "docstring_tokens": "Cleans trailing whitespaces and replaces also multiple whitespaces with a single space .", "label": 1}, {"idx": "cosqa-train-11893", "doc": "python select the last row", "code": "def get_last(self, table=None):\n        \"\"\"Just the last entry.\"\"\"\n        if table is None: table = self.main_table\n        query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table\n        return self.own_cursor.execute(query).fetchone()", "code_tokens": "def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )", "docstring_tokens": "Just the last entry .", "label": 1}, {"idx": "cosqa-train-11894", "doc": "how to swap a lower case letter for a capitol in python", "code": "def to_snake_case(name):\n    \"\"\" Given a name in camelCase return in snake_case \"\"\"\n    s1 = FIRST_CAP_REGEX.sub(r'\\1_\\2', name)\n    return ALL_CAP_REGEX.sub(r'\\1_\\2', s1).lower()", "code_tokens": "def to_snake_case ( name ) : s1 = FIRST_CAP_REGEX . sub ( r'\\1_\\2' , name ) return ALL_CAP_REGEX . sub ( r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Given a name in camelCase return in snake_case", "label": 1}, {"idx": "cosqa-train-11895", "doc": "python separate upper letter with underscore", "code": "def camelcase_underscore(name):\n    \"\"\" Convert camelcase names to underscore \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def camelcase_underscore ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert camelcase names to underscore", "label": 1}, {"idx": "cosqa-train-11896", "doc": "how to take fourier transform python", "code": "def translate_fourier(image, dx):\n    \"\"\" Translate an image in fourier-space with plane waves \"\"\"\n    N = image.shape[0]\n\n    f = 2*np.pi*np.fft.fftfreq(N)\n    kx,ky,kz = np.meshgrid(*(f,)*3, indexing='ij')\n    kv = np.array([kx,ky,kz]).T\n\n    q = np.fft.fftn(image)*np.exp(-1.j*(kv*dx).sum(axis=-1)).T\n    return np.real(np.fft.ifftn(q))", "code_tokens": "def translate_fourier ( image , dx ) : N = image . shape [ 0 ] f = 2 * np . pi * np . fft . fftfreq ( N ) kx , ky , kz = np . meshgrid ( * ( f , ) * 3 , indexing = 'ij' ) kv = np . array ( [ kx , ky , kz ] ) . T q = np . fft . fftn ( image ) * np . exp ( - 1.j * ( kv * dx ) . sum ( axis = - 1 ) ) . T return np . real ( np . fft . ifftn ( q ) )", "docstring_tokens": "Translate an image in fourier - space with plane waves", "label": 1}, {"idx": "cosqa-train-11897", "doc": "python seperating sentence into list", "code": "def split_into_sentences(s):\n  \"\"\"Split text into list of sentences.\"\"\"\n  s = re.sub(r\"\\s+\", \" \", s)\n  s = re.sub(r\"[\\\\.\\\\?\\\\!]\", \"\\n\", s)\n  return s.split(\"\\n\")", "code_tokens": "def split_into_sentences ( s ) : s = re . sub ( r\"\\s+\" , \" \" , s ) s = re . sub ( r\"[\\\\.\\\\?\\\\!]\" , \"\\n\" , s ) return s . split ( \"\\n\" )", "docstring_tokens": "Split text into list of sentences .", "label": 1}, {"idx": "cosqa-train-11898", "doc": "how to take global path in python", "code": "def import_path(self):\n    \"\"\"The full remote import path as used in import statements in `.go` source files.\"\"\"\n    return os.path.join(self.remote_root, self.pkg) if self.pkg else self.remote_root", "code_tokens": "def import_path ( self ) : return os . path . join ( self . remote_root , self . pkg ) if self . pkg else self . remote_root", "docstring_tokens": "The full remote import path as used in import statements in . go source files .", "label": 1}, {"idx": "cosqa-train-11899", "doc": "python serializers reference before define", "code": "def is_serializable(obj):\n    \"\"\"Return `True` if the given object conforms to the Serializable protocol.\n\n    :rtype: bool\n    \"\"\"\n    if inspect.isclass(obj):\n      return Serializable.is_serializable_type(obj)\n    return isinstance(obj, Serializable) or hasattr(obj, '_asdict')", "code_tokens": "def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )", "docstring_tokens": "Return True if the given object conforms to the Serializable protocol .", "label": 1}, {"idx": "cosqa-train-11900", "doc": "python series has none", "code": "def remove_series(self, series):\n        \"\"\"Removes a :py:class:`.Series` from the chart.\n\n        :param Series series: The :py:class:`.Series` to remove.\n        :raises ValueError: if you try to remove the last\\\n        :py:class:`.Series`.\"\"\"\n\n        if len(self.all_series()) == 1:\n            raise ValueError(\"Cannot remove last series from %s\" % str(self))\n        self._all_series.remove(series)\n        series._chart = None", "code_tokens": "def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( \"Cannot remove last series from %s\" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None", "docstring_tokens": "Removes a : py : class : . Series from the chart .", "label": 1}, {"idx": "cosqa-train-11901", "doc": "how to take the ip from my machine python", "code": "def get_own_ip():\n    \"\"\"Get the host's ip number.\n    \"\"\"\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    try:\n        sock.connect((\"8.8.8.8\", 80))\n    except socket.gaierror:\n        ip_ = \"127.0.0.1\"\n    else:\n        ip_ = sock.getsockname()[0]\n    finally:\n        sock.close()\n    return ip_", "code_tokens": "def get_own_ip ( ) : sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) try : sock . connect ( ( \"8.8.8.8\" , 80 ) ) except socket . gaierror : ip_ = \"127.0.0.1\" else : ip_ = sock . getsockname ( ) [ 0 ] finally : sock . close ( ) return ip_", "docstring_tokens": "Get the host s ip number .", "label": 1}, {"idx": "cosqa-train-11902", "doc": "python series'value non zero index", "code": "def reduce_fn(x):\n    \"\"\"\n    Aggregation function to get the first non-zero value.\n    \"\"\"\n    values = x.values if pd and isinstance(x, pd.Series) else x\n    for v in values:\n        if not is_nan(v):\n            return v\n    return np.NaN", "code_tokens": "def reduce_fn ( x ) : values = x . values if pd and isinstance ( x , pd . Series ) else x for v in values : if not is_nan ( v ) : return v return np . NaN", "docstring_tokens": "Aggregation function to get the first non - zero value .", "label": 1}, {"idx": "cosqa-train-11903", "doc": "how to tell if python code is running", "code": "def IPYTHON_MAIN():\n    \"\"\"Decide if the Ipython command line is running code.\"\"\"\n    import pkg_resources\n\n    runner_frame = inspect.getouterframes(inspect.currentframe())[-2]\n    return (\n        getattr(runner_frame, \"function\", None)\n        == pkg_resources.load_entry_point(\"ipython\", \"console_scripts\", \"ipython\").__name__\n    )", "code_tokens": "def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , \"function\" , None ) == pkg_resources . load_entry_point ( \"ipython\" , \"console_scripts\" , \"ipython\" ) . __name__ )", "docstring_tokens": "Decide if the Ipython command line is running code .", "label": 1}, {"idx": "cosqa-train-11904", "doc": "python set access time of file", "code": "def set_file_mtime(path, mtime, atime=None):\n  \"\"\"Set access and modification times on a file.\"\"\"\n  if not atime:\n    atime = mtime\n  f = open(path, 'a')\n  try:\n    os.utime(path, (atime, mtime))\n  finally:\n    f.close()", "code_tokens": "def set_file_mtime ( path , mtime , atime = None ) : if not atime : atime = mtime f = open ( path , 'a' ) try : os . utime ( path , ( atime , mtime ) ) finally : f . close ( )", "docstring_tokens": "Set access and modification times on a file .", "label": 1}, {"idx": "cosqa-train-11905", "doc": "how to tell if verbose is selected in python", "code": "def print_verbose(*args, **kwargs):\n    \"\"\"Utility to print something only if verbose=True is given\n    \"\"\"\n    if kwargs.pop('verbose', False) is True:\n        gprint(*args, **kwargs)", "code_tokens": "def print_verbose ( * args , * * kwargs ) : if kwargs . pop ( 'verbose' , False ) is True : gprint ( * args , * * kwargs )", "docstring_tokens": "Utility to print something only if verbose = True is given", "label": 1}, {"idx": "cosqa-train-11906", "doc": "python set all columns to lower", "code": "def clean_colnames(df):\n    \"\"\" Cleans the column names on a DataFrame\n    Parameters:\n    df - DataFrame\n        The DataFrame to clean\n    \"\"\"\n    col_list = []\n    for index in range(_dutils.cols(df)):\n        col_list.append(df.columns[index].strip().lower().replace(' ','_'))\n    df.columns = col_list", "code_tokens": "def clean_colnames ( df ) : col_list = [ ] for index in range ( _dutils . cols ( df ) ) : col_list . append ( df . columns [ index ] . strip ( ) . lower ( ) . replace ( ' ' , '_' ) ) df . columns = col_list", "docstring_tokens": "Cleans the column names on a DataFrame Parameters : df - DataFrame The DataFrame to clean", "label": 1}, {"idx": "cosqa-train-11907", "doc": "how to trapezoidal integrate in python", "code": "def trapz2(f, x=None, y=None, dx=1.0, dy=1.0):\n    \"\"\"Double integrate.\"\"\"\n    return numpy.trapz(numpy.trapz(f, x=y, dx=dy), x=x, dx=dx)", "code_tokens": "def trapz2 ( f , x = None , y = None , dx = 1.0 , dy = 1.0 ) : return numpy . trapz ( numpy . trapz ( f , x = y , dx = dy ) , x = x , dx = dx )", "docstring_tokens": "Double integrate .", "label": 1}, {"idx": "cosqa-train-11908", "doc": "python set property to magicmock", "code": "def mock_add_spec(self, spec, spec_set=False):\n        \"\"\"Add a spec to a mock. `spec` can either be an object or a\n        list of strings. Only attributes on the `spec` can be fetched as\n        attributes from the mock.\n\n        If `spec_set` is True then only attributes on the spec can be set.\"\"\"\n        self._mock_add_spec(spec, spec_set)\n        self._mock_set_magics()", "code_tokens": "def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )", "docstring_tokens": "Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock .", "label": 1}, {"idx": "cosqa-train-11909", "doc": "how to traspose a matrix using python", "code": "def transpose(table):\n    \"\"\"\n    transpose matrix\n    \"\"\"\n    t = []\n    for i in range(0, len(table[0])):\n        t.append([row[i] for row in table])\n    return t", "code_tokens": "def transpose ( table ) : t = [ ] for i in range ( 0 , len ( table [ 0 ] ) ) : t . append ( [ row [ i ] for row in table ] ) return t", "docstring_tokens": "transpose matrix", "label": 1}, {"idx": "cosqa-train-11910", "doc": "python set y axis log", "code": "def log_y_cb(self, w, val):\n        \"\"\"Toggle linear/log scale for Y-axis.\"\"\"\n        self.tab_plot.logy = val\n        self.plot_two_columns()", "code_tokens": "def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )", "docstring_tokens": "Toggle linear / log scale for Y - axis .", "label": 1}, {"idx": "cosqa-train-11911", "doc": "how to traverse a python tree", "code": "def walk_tree(root):\n    \"\"\"Pre-order depth-first\"\"\"\n    yield root\n\n    for child in root.children:\n        for el in walk_tree(child):\n            yield el", "code_tokens": "def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el", "docstring_tokens": "Pre - order depth - first", "label": 1}, {"idx": "cosqa-train-11912", "doc": "python setting a variable to a node", "code": "def set_attr(self, name, value):\n    \"\"\" Sets the value of an attribute. \"\"\"\n    self.exec_script(\"node.setAttribute(%s, %s)\" % (repr(name), repr(value)))", "code_tokens": "def set_attr ( self , name , value ) : self . exec_script ( \"node.setAttribute(%s, %s)\" % ( repr ( name ) , repr ( value ) ) )", "docstring_tokens": "Sets the value of an attribute .", "label": 1}, {"idx": "cosqa-train-11913", "doc": "how to tune the camera resolution in python", "code": "def match_aspect_to_viewport(self):\n        \"\"\"Updates Camera.aspect to match the viewport's aspect ratio.\"\"\"\n        viewport = self.viewport\n        self.aspect = float(viewport.width) / viewport.height", "code_tokens": "def match_aspect_to_viewport ( self ) : viewport = self . viewport self . aspect = float ( viewport . width ) / viewport . height", "docstring_tokens": "Updates Camera . aspect to match the viewport s aspect ratio .", "label": 1}, {"idx": "cosqa-train-11914", "doc": "python setting specific tab width", "code": "def _set_tab_width(self, tab_width):\n        \"\"\" Sets the width (in terms of space characters) for tab characters.\n        \"\"\"\n        font_metrics = QtGui.QFontMetrics(self.font)\n        self._control.setTabStopWidth(tab_width * font_metrics.width(' '))\n\n        self._tab_width = tab_width", "code_tokens": "def _set_tab_width ( self , tab_width ) : font_metrics = QtGui . QFontMetrics ( self . font ) self . _control . setTabStopWidth ( tab_width * font_metrics . width ( ' ' ) ) self . _tab_width = tab_width", "docstring_tokens": "Sets the width ( in terms of space characters ) for tab characters .", "label": 1}, {"idx": "cosqa-train-11915", "doc": "how to turn a comma seperated string to list python", "code": "def split_elements(value):\n    \"\"\"Split a string with comma or space-separated elements into a list.\"\"\"\n    l = [v.strip() for v in value.split(',')]\n    if len(l) == 1:\n        l = value.split()\n    return l", "code_tokens": "def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l", "docstring_tokens": "Split a string with comma or space - separated elements into a list .", "label": 0}, {"idx": "cosqa-train-11916", "doc": "python setuptools specify dependencies", "code": "def main(argv, version=DEFAULT_VERSION):\n    \"\"\"Install or upgrade setuptools and EasyInstall\"\"\"\n    tarball = download_setuptools()\n    _install(tarball, _build_install_args(argv))", "code_tokens": "def main ( argv , version = DEFAULT_VERSION ) : tarball = download_setuptools ( ) _install ( tarball , _build_install_args ( argv ) )", "docstring_tokens": "Install or upgrade setuptools and EasyInstall", "label": 1}, {"idx": "cosqa-train-11917", "doc": "how to turn a list into a slice in python", "code": "def iget_list_column_slice(list_, start=None, stop=None, stride=None):\n    \"\"\" iterator version of get_list_column \"\"\"\n    if isinstance(start, slice):\n        slice_ = start\n    else:\n        slice_ = slice(start, stop, stride)\n    return (row[slice_] for row in list_)", "code_tokens": "def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )", "docstring_tokens": "iterator version of get_list_column", "label": 1}, {"idx": "cosqa-train-11918", "doc": "python shape extraction from image using numpy geometric shapes", "code": "def get_shape_mask(self, shape_obj):\n        \"\"\"\n        Return full mask where True marks pixels within the given shape.\n        \"\"\"\n        wd, ht = self.get_size()\n        yi = np.mgrid[:ht].reshape(-1, 1)\n        xi = np.mgrid[:wd].reshape(1, -1)\n        pts = np.asarray((xi, yi)).T\n        contains = shape_obj.contains_pts(pts)\n        return contains", "code_tokens": "def get_shape_mask ( self , shape_obj ) : wd , ht = self . get_size ( ) yi = np . mgrid [ : ht ] . reshape ( - 1 , 1 ) xi = np . mgrid [ : wd ] . reshape ( 1 , - 1 ) pts = np . asarray ( ( xi , yi ) ) . T contains = shape_obj . contains_pts ( pts ) return contains", "docstring_tokens": "Return full mask where True marks pixels within the given shape .", "label": 1}, {"idx": "cosqa-train-11919", "doc": "how to turn a list of string to upper case in python", "code": "def upcaseTokens(s,l,t):\n    \"\"\"Helper parse action to convert tokens to upper case.\"\"\"\n    return [ tt.upper() for tt in map(_ustr,t) ]", "code_tokens": "def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]", "docstring_tokens": "Helper parse action to convert tokens to upper case .", "label": 1}, {"idx": "cosqa-train-11920", "doc": "python show cursor location", "code": "def move(self, x, y):\n        \"\"\"Move the virtual cursor.\n\n        Args:\n            x (int): x-coordinate to place the cursor.\n            y (int): y-coordinate to place the cursor.\n\n        .. seealso:: :any:`get_cursor`, :any:`print_str`, :any:`write`\n        \"\"\"\n        self._cursor = self._normalizePoint(x, y)", "code_tokens": "def move ( self , x , y ) : self . _cursor = self . _normalizePoint ( x , y )", "docstring_tokens": "Move the virtual cursor .", "label": 1}, {"idx": "cosqa-train-11921", "doc": "how to turn a str into a datetime python", "code": "def parse_datetime(dt_str):\n    \"\"\"Parse datetime.\"\"\"\n    date_format = \"%Y-%m-%dT%H:%M:%S %z\"\n    dt_str = dt_str.replace(\"Z\", \" +0000\")\n    return datetime.datetime.strptime(dt_str, date_format)", "code_tokens": "def parse_datetime ( dt_str ) : date_format = \"%Y-%m-%dT%H:%M:%S %z\" dt_str = dt_str . replace ( \"Z\" , \" +0000\" ) return datetime . datetime . strptime ( dt_str , date_format )", "docstring_tokens": "Parse datetime .", "label": 0}, {"idx": "cosqa-train-11922", "doc": "python show time without colon", "code": "def now_time(str=False):\n    \"\"\"Get the current time.\"\"\"\n    if str:\n        return datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    return datetime.datetime.now()", "code_tokens": "def now_time ( str = False ) : if str : return datetime . datetime . now ( ) . strftime ( \"%Y-%m-%d %H:%M:%S\" ) return datetime . datetime . now ( )", "docstring_tokens": "Get the current time .", "label": 1}, {"idx": "cosqa-train-11923", "doc": "how to turn somethibg into an array python", "code": "def _listify(collection):\n        \"\"\"This is a workaround where Collections are no longer iterable\n        when using JPype.\"\"\"\n        new_list = []\n        for index in range(len(collection)):\n            new_list.append(collection[index])\n        return new_list", "code_tokens": "def _listify ( collection ) : new_list = [ ] for index in range ( len ( collection ) ) : new_list . append ( collection [ index ] ) return new_list", "docstring_tokens": "This is a workaround where Collections are no longer iterable when using JPype .", "label": 0}, {"idx": "cosqa-train-11924", "doc": "python sign value numpy", "code": "def Softsign(a):\n    \"\"\"\n    Softsign op.\n    \"\"\"\n    return np.divide(a, np.add(np.abs(a), 1)),", "code_tokens": "def Softsign ( a ) : return np . divide ( a , np . add ( np . abs ( a ) , 1 ) ) ,", "docstring_tokens": "Softsign op .", "label": 1}, {"idx": "cosqa-train-11925", "doc": "how to type cast all elements in a list in python", "code": "def coerce(self, value):\n        \"\"\"Convert from whatever is given to a list of scalars for the lookup_field.\"\"\"\n        if isinstance(value, dict):\n            value = [value]\n        if not isiterable_notstring(value):\n            value = [value]\n        return [coerce_single_instance(self.lookup_field, v) for v in value]", "code_tokens": "def coerce ( self , value ) : if isinstance ( value , dict ) : value = [ value ] if not isiterable_notstring ( value ) : value = [ value ] return [ coerce_single_instance ( self . lookup_field , v ) for v in value ]", "docstring_tokens": "Convert from whatever is given to a list of scalars for the lookup_field .", "label": 1}, {"idx": "cosqa-train-11926", "doc": "python signed binary string to int", "code": "def bin_to_int(string):\n    \"\"\"Convert a one element byte string to signed int for python 2 support.\"\"\"\n    if isinstance(string, str):\n        return struct.unpack(\"b\", string)[0]\n    else:\n        return struct.unpack(\"b\", bytes([string]))[0]", "code_tokens": "def bin_to_int ( string ) : if isinstance ( string , str ) : return struct . unpack ( \"b\" , string ) [ 0 ] else : return struct . unpack ( \"b\" , bytes ( [ string ] ) ) [ 0 ]", "docstring_tokens": "Convert a one element byte string to signed int for python 2 support .", "label": 1}, {"idx": "cosqa-train-11927", "doc": "how to union join table based on column python", "code": "def merge(left, right, how='inner', key=None, left_key=None, right_key=None,\n          left_as='left', right_as='right'):\n    \"\"\" Performs a join using the union join function. \"\"\"\n    return join(left, right, how, key, left_key, right_key,\n                join_fn=make_union_join(left_as, right_as))", "code_tokens": "def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "docstring_tokens": "Performs a join using the union join function .", "label": 1}, {"idx": "cosqa-train-11928", "doc": "python single asterik expansion", "code": "def _expand(self, str, local_vars={}):\n        \"\"\"Expand $vars in a string.\"\"\"\n        return ninja_syntax.expand(str, self.vars, local_vars)", "code_tokens": "def _expand ( self , str , local_vars = { } ) : return ninja_syntax . expand ( str , self . vars , local_vars )", "docstring_tokens": "Expand $vars in a string .", "label": 1}, {"idx": "cosqa-train-11929", "doc": "how to unzip a python file in windows", "code": "def _unzip_handle(handle):\n    \"\"\"Transparently unzip the file handle\"\"\"\n    if isinstance(handle, basestring):\n        handle = _gzip_open_filename(handle)\n    else:\n        handle = _gzip_open_handle(handle)\n    return handle", "code_tokens": "def _unzip_handle ( handle ) : if isinstance ( handle , basestring ) : handle = _gzip_open_filename ( handle ) else : handle = _gzip_open_handle ( handle ) return handle", "docstring_tokens": "Transparently unzip the file handle", "label": 1}, {"idx": "cosqa-train-11930", "doc": "python singleton double check locking", "code": "def _synced(method, self, args, kwargs):\n    \"\"\"Underlying synchronized wrapper.\"\"\"\n    with self._lock:\n        return method(*args, **kwargs)", "code_tokens": "def _synced ( method , self , args , kwargs ) : with self . _lock : return method ( * args , * * kwargs )", "docstring_tokens": "Underlying synchronized wrapper .", "label": 1}, {"idx": "cosqa-train-11931", "doc": "how to use a function to prompt user for inputs python", "code": "def string_input(prompt=''):\n    \"\"\"Python 3 input()/Python 2 raw_input()\"\"\"\n    v = sys.version[0]\n    if v == '3':\n        return input(prompt)\n    else:\n        return raw_input(prompt)", "code_tokens": "def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )", "docstring_tokens": "Python 3 input () / Python 2 raw_input ()", "label": 1}, {"idx": "cosqa-train-11932", "doc": "python singleton instance global", "code": "def singleton_per_scope(_cls, _scope=None, _renew=False, *args, **kwargs):\n    \"\"\"Instanciate a singleton per scope.\"\"\"\n\n    result = None\n\n    singletons = SINGLETONS_PER_SCOPES.setdefault(_scope, {})\n\n    if _renew or _cls not in singletons:\n        singletons[_cls] = _cls(*args, **kwargs)\n\n    result = singletons[_cls]\n\n    return result", "code_tokens": "def singleton_per_scope ( _cls , _scope = None , _renew = False , * args , * * kwargs ) : result = None singletons = SINGLETONS_PER_SCOPES . setdefault ( _scope , { } ) if _renew or _cls not in singletons : singletons [ _cls ] = _cls ( * args , * * kwargs ) result = singletons [ _cls ] return result", "docstring_tokens": "Instanciate a singleton per scope .", "label": 1}, {"idx": "cosqa-train-11933", "doc": "how to use a method that ends with yield python", "code": "def connected_socket(address, timeout=3):\n    \"\"\" yields a connected socket \"\"\"\n    sock = socket.create_connection(address, timeout)\n    yield sock\n    sock.close()", "code_tokens": "def connected_socket ( address , timeout = 3 ) : sock = socket . create_connection ( address , timeout ) yield sock sock . close ( )", "docstring_tokens": "yields a connected socket", "label": 0}, {"idx": "cosqa-train-11934", "doc": "python skip comment quots", "code": "def ignore_comments(iterator):\n    \"\"\"\n    Strips and filters empty or commented lines.\n    \"\"\"\n    for line in iterator:\n        line = COMMENT_RE.sub('', line)\n        line = line.strip()\n        if line:\n            yield line", "code_tokens": "def ignore_comments ( iterator ) : for line in iterator : line = COMMENT_RE . sub ( '' , line ) line = line . strip ( ) if line : yield line", "docstring_tokens": "Strips and filters empty or commented lines .", "label": 1}, {"idx": "cosqa-train-11935", "doc": "how to use assertitemsequal in python to compare lists", "code": "def expect_all(a, b):\n    \"\"\"\\\n    Asserts that two iterables contain the same values.\n    \"\"\"\n    assert all(_a == _b for _a, _b in zip_longest(a, b))", "code_tokens": "def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )", "docstring_tokens": "\\ Asserts that two iterables contain the same values .", "label": 1}, {"idx": "cosqa-train-11936", "doc": "python skip lines that are empty or only spaces", "code": "def filter_useless_pass(source):\n    \"\"\"Yield code with useless \"pass\" lines removed.\"\"\"\n    try:\n        marked_lines = frozenset(useless_pass_line_numbers(source))\n    except (SyntaxError, tokenize.TokenError):\n        marked_lines = frozenset()\n\n    sio = io.StringIO(source)\n    for line_number, line in enumerate(sio.readlines(), start=1):\n        if line_number not in marked_lines:\n            yield line", "code_tokens": "def filter_useless_pass ( source ) : try : marked_lines = frozenset ( useless_pass_line_numbers ( source ) ) except ( SyntaxError , tokenize . TokenError ) : marked_lines = frozenset ( ) sio = io . StringIO ( source ) for line_number , line in enumerate ( sio . readlines ( ) , start = 1 ) : if line_number not in marked_lines : yield line", "docstring_tokens": "Yield code with useless pass lines removed .", "label": 1}, {"idx": "cosqa-train-11937", "doc": "how to use defaultdict for frequency of words in python", "code": "def wordfreq(text, is_filename=False):\n    \"\"\"Return a dictionary of words and word counts in a string.\"\"\"\n    if is_filename:\n        with open(text) as f:\n            text = f.read()\n    freqs = {}\n    for word in text.split():\n        lword = word.lower()\n        freqs[lword] = freqs.get(lword, 0) + 1\n    return freqs", "code_tokens": "def wordfreq ( text , is_filename = False ) : if is_filename : with open ( text ) as f : text = f . read ( ) freqs = { } for word in text . split ( ) : lword = word . lower ( ) freqs [ lword ] = freqs . get ( lword , 0 ) + 1 return freqs", "docstring_tokens": "Return a dictionary of words and word counts in a string .", "label": 1}, {"idx": "cosqa-train-11938", "doc": "python sklearn how to output graph of decision tree", "code": "def cric__decision_tree():\n    \"\"\" Decision Tree\n    \"\"\"\n    model = sklearn.tree.DecisionTreeClassifier(random_state=0, max_depth=4)\n\n    # we want to explain the raw probability outputs of the trees\n    model.predict = lambda X: model.predict_proba(X)[:,1]\n    \n    return model", "code_tokens": "def cric__decision_tree ( ) : model = sklearn . tree . DecisionTreeClassifier ( random_state = 0 , max_depth = 4 ) # we want to explain the raw probability outputs of the trees model . predict = lambda X : model . predict_proba ( X ) [ : , 1 ] return model", "docstring_tokens": "Decision Tree", "label": 1}, {"idx": "cosqa-train-11939", "doc": "how to use dictionary funtion to replace in python", "code": "def copy_and_update(dictionary, update):\n    \"\"\"Returns an updated copy of the dictionary without modifying the original\"\"\"\n    newdict = dictionary.copy()\n    newdict.update(update)\n    return newdict", "code_tokens": "def copy_and_update ( dictionary , update ) : newdict = dictionary . copy ( ) newdict . update ( update ) return newdict", "docstring_tokens": "Returns an updated copy of the dictionary without modifying the original", "label": 1}, {"idx": "cosqa-train-11940", "doc": "python sklearn onehotencoder string values", "code": "def one_hot2string(arr, vocab):\n    \"\"\"Convert a one-hot encoded array back to string\n    \"\"\"\n    tokens = one_hot2token(arr)\n    indexToLetter = _get_index_dict(vocab)\n\n    return [''.join([indexToLetter[x] for x in row]) for row in tokens]", "code_tokens": "def one_hot2string ( arr , vocab ) : tokens = one_hot2token ( arr ) indexToLetter = _get_index_dict ( vocab ) return [ '' . join ( [ indexToLetter [ x ] for x in row ] ) for row in tokens ]", "docstring_tokens": "Convert a one - hot encoded array back to string", "label": 1}, {"idx": "cosqa-train-11941", "doc": "how to use division and remainder in python", "code": "def generic_div(a, b):\n    \"\"\"Simple function to divide two numbers\"\"\"\n    logger.debug('Called generic_div({}, {})'.format(a, b))\n    return a / b", "code_tokens": "def generic_div ( a , b ) : logger . debug ( 'Called generic_div({}, {})' . format ( a , b ) ) return a / b", "docstring_tokens": "Simple function to divide two numbers", "label": 1}, {"idx": "cosqa-train-11942", "doc": "python solve for a log equation", "code": "def glog(x,l = 2):\n    \"\"\"\n    Generalised logarithm\n\n    :param x: number\n    :param p: number added befor logarithm \n\n    \"\"\"\n    return np.log((x+np.sqrt(x**2+l**2))/2)/np.log(l)", "code_tokens": "def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )", "docstring_tokens": "Generalised logarithm", "label": 1}, {"idx": "cosqa-train-11943", "doc": "how to use lambda function for descending order sorting in python", "code": "def csort(objs, key):\n    \"\"\"Order-preserving sorting function.\"\"\"\n    idxs = dict((obj, i) for (i, obj) in enumerate(objs))\n    return sorted(objs, key=lambda obj: (key(obj), idxs[obj]))", "code_tokens": "def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )", "docstring_tokens": "Order - preserving sorting function .", "label": 0}, {"idx": "cosqa-train-11944", "doc": "python sort indices of array", "code": "def argsort_indices(a, axis=-1):\n    \"\"\"Like argsort, but returns an index suitable for sorting the\n    the original array even if that array is multidimensional\n    \"\"\"\n    a = np.asarray(a)\n    ind = list(np.ix_(*[np.arange(d) for d in a.shape]))\n    ind[axis] = a.argsort(axis)\n    return tuple(ind)", "code_tokens": "def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )", "docstring_tokens": "Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional", "label": 1}, {"idx": "cosqa-train-11945", "doc": "how to use max function for a matrix python", "code": "def SegmentMax(a, ids):\n    \"\"\"\n    Segmented max op.\n    \"\"\"\n    func = lambda idxs: np.amax(a[idxs], axis=0)\n    return seg_map(func, a, ids),", "code_tokens": "def SegmentMax ( a , ids ) : func = lambda idxs : np . amax ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,", "docstring_tokens": "Segmented max op .", "label": 1}, {"idx": "cosqa-train-11946", "doc": "python sort list of file names", "code": "def sort_filenames(filenames):\n    \"\"\"\n    sort a list of files by filename only, ignoring the directory names\n    \"\"\"\n    basenames = [os.path.basename(x) for x in filenames]\n    indexes = [i[0] for i in sorted(enumerate(basenames), key=lambda x:x[1])]\n    return [filenames[x] for x in indexes]", "code_tokens": "def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "docstring_tokens": "sort a list of files by filename only ignoring the directory names", "label": 1}, {"idx": "cosqa-train-11947", "doc": "how to use percentage on python 3", "code": "def ratio_and_percentage(current, total, time_remaining):\n    \"\"\"Returns the progress ratio and percentage.\"\"\"\n    return \"{} / {} ({}% completed)\".format(current, total, int(current / total * 100))", "code_tokens": "def ratio_and_percentage ( current , total , time_remaining ) : return \"{} / {} ({}% completed)\" . format ( current , total , int ( current / total * 100 ) )", "docstring_tokens": "Returns the progress ratio and percentage .", "label": 1}, {"idx": "cosqa-train-11948", "doc": "python sort list of filenames", "code": "def sort_filenames(filenames):\n    \"\"\"\n    sort a list of files by filename only, ignoring the directory names\n    \"\"\"\n    basenames = [os.path.basename(x) for x in filenames]\n    indexes = [i[0] for i in sorted(enumerate(basenames), key=lambda x:x[1])]\n    return [filenames[x] for x in indexes]", "code_tokens": "def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "docstring_tokens": "sort a list of files by filename only ignoring the directory names", "label": 1}, {"idx": "cosqa-train-11949", "doc": "how to use python configparser with include files", "code": "def include_raw_constructor(self, loader, node):\n        \"\"\"\n        Called when PyYaml encounters '!include-raw'\n        \"\"\"\n\n        path = convert_path(node.value)\n\n        with open(path, 'r') as f:\n            config = f.read()\n\n            config = self.inject_include_info(path, config, include_type='include-raw')\n\n            self.add_file(path, config)\n\n            return config", "code_tokens": "def include_raw_constructor ( self , loader , node ) : path = convert_path ( node . value ) with open ( path , 'r' ) as f : config = f . read ( ) config = self . inject_include_info ( path , config , include_type = 'include-raw' ) self . add_file ( path , config ) return config", "docstring_tokens": "Called when PyYaml encounters !include - raw", "label": 1}, {"idx": "cosqa-train-11950", "doc": "python sort values into new columns", "code": "def sort_data(data, cols):\n    \"\"\"Sort `data` rows and order columns\"\"\"\n    return data.sort_values(cols)[cols + ['value']].reset_index(drop=True)", "code_tokens": "def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )", "docstring_tokens": "Sort data rows and order columns", "label": 1}, {"idx": "cosqa-train-11951", "doc": "how to use python in interactive mode", "code": "def isInteractive():\n    \"\"\"\n    A basic check of if the program is running in interactive mode\n    \"\"\"\n    if sys.stdout.isatty() and os.name != 'nt':\n        #Hopefully everything but ms supports '\\r'\n        try:\n            import threading\n        except ImportError:\n            return False\n        else:\n            return True\n    else:\n        return False", "code_tokens": "def isInteractive ( ) : if sys . stdout . isatty ( ) and os . name != 'nt' : #Hopefully everything but ms supports '\\r' try : import threading except ImportError : return False else : return True else : return False", "docstring_tokens": "A basic check of if the program is running in interactive mode", "label": 1}, {"idx": "cosqa-train-11952", "doc": "python sorted lambda comparison", "code": "def _sort_lambda(sortedby='cpu_percent',\n                 sortedby_secondary='memory_percent'):\n    \"\"\"Return a sort lambda function for the sortedbykey\"\"\"\n    ret = None\n    if sortedby == 'io_counters':\n        ret = _sort_io_counters\n    elif sortedby == 'cpu_times':\n        ret = _sort_cpu_times\n    return ret", "code_tokens": "def _sort_lambda ( sortedby = 'cpu_percent' , sortedby_secondary = 'memory_percent' ) : ret = None if sortedby == 'io_counters' : ret = _sort_io_counters elif sortedby == 'cpu_times' : ret = _sort_cpu_times return ret", "docstring_tokens": "Return a sort lambda function for the sortedbykey", "label": 1}, {"idx": "cosqa-train-11953", "doc": "how to use python to plot gaussian distribution", "code": "def gaussian_variogram_model(m, d):\n    \"\"\"Gaussian model, m is [psill, range, nugget]\"\"\"\n    psill = float(m[0])\n    range_ = float(m[1])\n    nugget = float(m[2])\n    return psill * (1. - np.exp(-d**2./(range_*4./7.)**2.)) + nugget", "code_tokens": "def gaussian_variogram_model ( m , d ) : psill = float ( m [ 0 ] ) range_ = float ( m [ 1 ] ) nugget = float ( m [ 2 ] ) return psill * ( 1. - np . exp ( - d ** 2. / ( range_ * 4. / 7. ) ** 2. ) ) + nugget", "docstring_tokens": "Gaussian model m is [ psill range nugget ]", "label": 1}, {"idx": "cosqa-train-11954", "doc": "python specify utf8 without codecs", "code": "def safe_unicode(string):\n    \"\"\"If Python 2, replace non-ascii characters and return encoded string.\"\"\"\n    if not PY3:\n        uni = string.replace(u'\\u2019', \"'\")\n        return uni.encode('utf-8')\n        \n    return string", "code_tokens": "def safe_unicode ( string ) : if not PY3 : uni = string . replace ( u'\\u2019' , \"'\" ) return uni . encode ( 'utf-8' ) return string", "docstring_tokens": "If Python 2 replace non - ascii characters and return encoded string .", "label": 1}, {"idx": "cosqa-train-11955", "doc": "how to use the getattr function in the python", "code": "def get_attr(self, method_name):\n        \"\"\"Get attribute from the target object\"\"\"\n        return self.attrs.get(method_name) or self.get_callable_attr(method_name)", "code_tokens": "def get_attr ( self , method_name ) : return self . attrs . get ( method_name ) or self . get_callable_attr ( method_name )", "docstring_tokens": "Get attribute from the target object", "label": 1}, {"idx": "cosqa-train-11956", "doc": "python sphinx autosummary change directory name", "code": "def _set_module_names_for_sphinx(modules: List, new_name: str):\n    \"\"\" Trick sphinx into displaying the desired module in these objects' documentation. \"\"\"\n    for obj in modules:\n        obj.__module__ = new_name", "code_tokens": "def _set_module_names_for_sphinx ( modules : List , new_name : str ) : for obj in modules : obj . __module__ = new_name", "docstring_tokens": "Trick sphinx into displaying the desired module in these objects documentation .", "label": 1}, {"idx": "cosqa-train-11957", "doc": "how to use the makedir command in python", "code": "def makedirs(path, mode=0o777, exist_ok=False):\n    \"\"\"A wrapper of os.makedirs().\"\"\"\n    os.makedirs(path, mode, exist_ok)", "code_tokens": "def makedirs ( path , mode = 0o777 , exist_ok = False ) : os . makedirs ( path , mode , exist_ok )", "docstring_tokens": "A wrapper of os . makedirs () .", "label": 1}, {"idx": "cosqa-train-11958", "doc": "python sphinx documentation as a text file", "code": "def read_sphinx_environment(pth):\n    \"\"\"Read the sphinx environment.pickle file at path `pth`.\"\"\"\n\n    with open(pth, 'rb') as fo:\n        env = pickle.load(fo)\n    return env", "code_tokens": "def read_sphinx_environment ( pth ) : with open ( pth , 'rb' ) as fo : env = pickle . load ( fo ) return env", "docstring_tokens": "Read the sphinx environment . pickle file at path pth .", "label": 1}, {"idx": "cosqa-train-11959", "doc": "how to use x and y coordinates in python", "code": "def __call__(self, xy):\n        \"\"\"Project x and y\"\"\"\n        x, y = xy\n        return (self.x(x), self.y(y))", "code_tokens": "def __call__ ( self , xy ) : x , y = xy return ( self . x ( x ) , self . y ( y ) )", "docstring_tokens": "Project x and y", "label": 1}, {"idx": "cosqa-train-11960", "doc": "python sphinx figure with caption", "code": "def _set_module_names_for_sphinx(modules: List, new_name: str):\n    \"\"\" Trick sphinx into displaying the desired module in these objects' documentation. \"\"\"\n    for obj in modules:\n        obj.__module__ = new_name", "code_tokens": "def _set_module_names_for_sphinx ( modules : List , new_name : str ) : for obj in modules : obj . __module__ = new_name", "docstring_tokens": "Trick sphinx into displaying the desired module in these objects documentation .", "label": 1}, {"idx": "cosqa-train-11961", "doc": "how to ush python flush method", "code": "def send(self, *args, **kwargs):\n        \"\"\"Writes the passed chunk and flushes it to the client.\"\"\"\n        self.write(*args, **kwargs)\n        self.flush()", "code_tokens": "def send ( self , * args , * * kwargs ) : self . write ( * args , * * kwargs ) self . flush ( )", "docstring_tokens": "Writes the passed chunk and flushes it to the client .", "label": 1}, {"idx": "cosqa-train-11962", "doc": "python splinter set checkbox state", "code": "def set_value(self, value):\n        \"\"\"Set value of the checkbox.\n\n        Parameters\n        ----------\n        value : bool\n            value for the checkbox\n\n        \"\"\"\n        if value:\n            self.setCheckState(Qt.Checked)\n        else:\n            self.setCheckState(Qt.Unchecked)", "code_tokens": "def set_value ( self , value ) : if value : self . setCheckState ( Qt . Checked ) else : self . setCheckState ( Qt . Unchecked )", "docstring_tokens": "Set value of the checkbox .", "label": 1}, {"idx": "cosqa-train-11963", "doc": "how to utilize line labels in python", "code": "def parsePoint(line):\n    \"\"\"\n    Parse a line of text into an MLlib LabeledPoint object.\n    \"\"\"\n    values = [float(s) for s in line.split(' ')]\n    if values[0] == -1:   # Convert -1 labels to 0 for MLlib\n        values[0] = 0\n    return LabeledPoint(values[0], values[1:])", "code_tokens": "def parsePoint ( line ) : values = [ float ( s ) for s in line . split ( ' ' ) ] if values [ 0 ] == - 1 : # Convert -1 labels to 0 for MLlib values [ 0 ] = 0 return LabeledPoint ( values [ 0 ] , values [ 1 : ] )", "docstring_tokens": "Parse a line of text into an MLlib LabeledPoint object .", "label": 1}, {"idx": "cosqa-train-11964", "doc": "python split a list into n parts", "code": "def chunked(l, n):\n    \"\"\"Chunk one big list into few small lists.\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunked ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Chunk one big list into few small lists .", "label": 1}, {"idx": "cosqa-train-11965", "doc": "how to validate a url in python", "code": "def is_valid_url(url):\n    \"\"\"Checks if a given string is an url\"\"\"\n    pieces = urlparse(url)\n    return all([pieces.scheme, pieces.netloc])", "code_tokens": "def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )", "docstring_tokens": "Checks if a given string is an url", "label": 1}, {"idx": "cosqa-train-11966", "doc": "python split array to chunk", "code": "def chunks(arr, size):\n    \"\"\"Splits a list into chunks\n\n    :param arr: list to split\n    :type arr: :class:`list`\n    :param size: number of elements in each chunk\n    :type size: :class:`int`\n    :return: generator object\n    :rtype: :class:`generator`\n    \"\"\"\n    for i in _range(0, len(arr), size):\n        yield arr[i:i+size]", "code_tokens": "def chunks ( arr , size ) : for i in _range ( 0 , len ( arr ) , size ) : yield arr [ i : i + size ]", "docstring_tokens": "Splits a list into chunks", "label": 1}, {"idx": "cosqa-train-11967", "doc": "how to validate url in python", "code": "def is_valid_url(url):\n    \"\"\"Checks if a given string is an url\"\"\"\n    pieces = urlparse(url)\n    return all([pieces.scheme, pieces.netloc])", "code_tokens": "def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )", "docstring_tokens": "Checks if a given string is an url", "label": 0}, {"idx": "cosqa-train-11968", "doc": "python split into chunks by value", "code": "def group(data, num):\n    \"\"\" Split data into chunks of num chars each \"\"\"\n    return [data[i:i+num] for i in range(0, len(data), num)]", "code_tokens": "def group ( data , num ) : return [ data [ i : i + num ] for i in range ( 0 , len ( data ) , num ) ]", "docstring_tokens": "Split data into chunks of num chars each", "label": 0}, {"idx": "cosqa-train-11969", "doc": "how to write a python code that will give all results if you remove for letters", "code": "def clean(self, text):\n        \"\"\"Remove all unwanted characters from text.\"\"\"\n        return ''.join([c for c in text if c in self.alphabet])", "code_tokens": "def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )", "docstring_tokens": "Remove all unwanted characters from text .", "label": 1}, {"idx": "cosqa-train-11970", "doc": "python split string into chunks of fixed length", "code": "def schunk(string, size):\n    \"\"\"Splits string into n sized chunks.\"\"\"\n    return [string[i:i+size] for i in range(0, len(string), size)]", "code_tokens": "def schunk ( string , size ) : return [ string [ i : i + size ] for i in range ( 0 , len ( string ) , size ) ]", "docstring_tokens": "Splits string into n sized chunks .", "label": 1}, {"idx": "cosqa-train-11971", "doc": "how to write code for decimal and binary conversions in python", "code": "def type_converter(text):\n    \"\"\" I convert strings into integers, floats, and strings! \"\"\"\n    if text.isdigit():\n        return int(text), int\n\n    try:\n        return float(text), float\n    except ValueError:\n        return text, STRING_TYPE", "code_tokens": "def type_converter ( text ) : if text . isdigit ( ) : return int ( text ) , int try : return float ( text ) , float except ValueError : return text , STRING_TYPE", "docstring_tokens": "I convert strings into integers floats and strings!", "label": 1}, {"idx": "cosqa-train-11972", "doc": "python split string on length", "code": "def split_len(s, length):\n    \"\"\"split string *s* into list of strings no longer than *length*\"\"\"\n    return [s[i:i+length] for i in range(0, len(s), length)]", "code_tokens": "def split_len ( s , length ) : return [ s [ i : i + length ] for i in range ( 0 , len ( s ) , length ) ]", "docstring_tokens": "split string * s * into list of strings no longer than * length *", "label": 1}, {"idx": "cosqa-train-11973", "doc": "how to write code python to accept post request from javascript", "code": "def set_json_item(key, value):\n    \"\"\" manipulate json data on the fly\n    \"\"\"\n    data = get_json()\n    data[key] = value\n\n    request = get_request()\n    request[\"BODY\"] = json.dumps(data)", "code_tokens": "def set_json_item ( key , value ) : data = get_json ( ) data [ key ] = value request = get_request ( ) request [ \"BODY\" ] = json . dumps ( data )", "docstring_tokens": "manipulate json data on the fly", "label": 0}, {"idx": "cosqa-train-11974", "doc": "how to write dictionary to file as json python", "code": "def _write_json(file, contents):\n    \"\"\"Write a dict to a JSON file.\"\"\"\n    with open(file, 'w') as f:\n        return json.dump(contents, f, indent=2, sort_keys=True)", "code_tokens": "def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )", "docstring_tokens": "Write a dict to a JSON file .", "label": 1}, {"idx": "cosqa-train-11975", "doc": "python split up compressed file into chunks", "code": "def _file_chunks(self, data, chunk_size):\n        \"\"\" Yield compressed chunks from a data array\"\"\"\n        for i in xrange(0, len(data), chunk_size):\n            yield self.compressor(data[i:i+chunk_size])", "code_tokens": "def _file_chunks ( self , data , chunk_size ) : for i in xrange ( 0 , len ( data ) , chunk_size ) : yield self . compressor ( data [ i : i + chunk_size ] )", "docstring_tokens": "Yield compressed chunks from a data array", "label": 1}, {"idx": "cosqa-train-11976", "doc": "how to write function to excel in python", "code": "def save_excel(self, fd):\n        \"\"\" Saves the case as an Excel spreadsheet.\n        \"\"\"\n        from pylon.io.excel import ExcelWriter\n        ExcelWriter(self).write(fd)", "code_tokens": "def save_excel ( self , fd ) : from pylon . io . excel import ExcelWriter ExcelWriter ( self ) . write ( fd )", "docstring_tokens": "Saves the case as an Excel spreadsheet .", "label": 0}, {"idx": "cosqa-train-11977", "doc": "python sql query string remove parentheses", "code": "def filter_query(s):\n    \"\"\"\n    Filters given query with the below regex\n    and returns lists of quoted and unquoted strings\n    \"\"\"\n    matches = re.findall(r'(?:\"([^\"]*)\")|([^\"]*)', s)\n    result_quoted = [t[0].strip() for t in matches if t[0]]\n    result_unquoted = [t[1].strip() for t in matches if t[1]]\n    return result_quoted, result_unquoted", "code_tokens": "def filter_query ( s ) : matches = re . findall ( r'(?:\"([^\"]*)\")|([^\"]*)' , s ) result_quoted = [ t [ 0 ] . strip ( ) for t in matches if t [ 0 ] ] result_unquoted = [ t [ 1 ] . strip ( ) for t in matches if t [ 1 ] ] return result_quoted , result_unquoted", "docstring_tokens": "Filters given query with the below regex and returns lists of quoted and unquoted strings", "label": 1}, {"idx": "cosqa-train-11978", "doc": "how to write print in two line in python", "code": "def stdoutwriteline(*args):\n    \"\"\"\n    @type args: tuple\n    @return: None\n    \"\"\"\n    s = \"\"\n\n    for i in args:\n        s += str(i) + \" \"\n\n    s = s.strip()\n    sys.stdout.write(str(s) + \"\\n\")\n    sys.stdout.flush()\n\n    return s", "code_tokens": "def stdoutwriteline ( * args ) : s = \"\" for i in args : s += str ( i ) + \" \" s = s . strip ( ) sys . stdout . write ( str ( s ) + \"\\n\" ) sys . stdout . flush ( ) return s", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-11979", "doc": "python sql update pass value", "code": "def update(table, values, where=(), **kwargs):\n    \"\"\"Convenience wrapper for database UPDATE.\"\"\"\n    where = dict(where, **kwargs).items()\n    sql, args = makeSQL(\"UPDATE\", table, values=values, where=where)\n    return execute(sql, args).rowcount", "code_tokens": "def update ( table , values , where = ( ) , * * kwargs ) : where = dict ( where , * * kwargs ) . items ( ) sql , args = makeSQL ( \"UPDATE\" , table , values = values , where = where ) return execute ( sql , args ) . rowcount", "docstring_tokens": "Convenience wrapper for database UPDATE .", "label": 1}, {"idx": "cosqa-train-11980", "doc": "how to zip files to directory in python", "code": "def unzip_file_to_dir(path_to_zip, output_directory):\n    \"\"\"\n    Extract a ZIP archive to a directory\n    \"\"\"\n    z = ZipFile(path_to_zip, 'r')\n    z.extractall(output_directory)\n    z.close()", "code_tokens": "def unzip_file_to_dir ( path_to_zip , output_directory ) : z = ZipFile ( path_to_zip , 'r' ) z . extractall ( output_directory ) z . close ( )", "docstring_tokens": "Extract a ZIP archive to a directory", "label": 0}, {"idx": "cosqa-train-11981", "doc": "python sqlalchemy bulk insert", "code": "def bulk_query(self, query, *multiparams):\n        \"\"\"Bulk insert or update.\"\"\"\n\n        with self.get_connection() as conn:\n            conn.bulk_query(query, *multiparams)", "code_tokens": "def bulk_query ( self , query , * multiparams ) : with self . get_connection ( ) as conn : conn . bulk_query ( query , * multiparams )", "docstring_tokens": "Bulk insert or update .", "label": 1}, {"idx": "cosqa-train-11982", "doc": "hwo to access elements in a counter python", "code": "def counter(items):\n    \"\"\"\n    Simplest required implementation of collections.Counter. Required as 2.6\n    does not have Counter in collections.\n    \"\"\"\n    results = {}\n    for item in items:\n        results[item] = results.get(item, 0) + 1\n    return results", "code_tokens": "def counter ( items ) : results = { } for item in items : results [ item ] = results . get ( item , 0 ) + 1 return results", "docstring_tokens": "Simplest required implementation of collections . Counter . Required as 2 . 6 does not have Counter in collections .", "label": 1}, {"idx": "cosqa-train-11983", "doc": "python sqlalchemy model *", "code": "def save(self):\n        \"\"\"Saves the updated model to the current entity db.\n        \"\"\"\n        self.session.add(self)\n        self.session.flush()\n        return self", "code_tokens": "def save ( self ) : self . session . add ( self ) self . session . flush ( ) return self", "docstring_tokens": "Saves the updated model to the current entity db .", "label": 1}, {"idx": "cosqa-train-11984", "doc": "hyphen in python dict key", "code": "def dict_keys_without_hyphens(a_dict):\n    \"\"\"Return the a new dict with underscores instead of hyphens in keys.\"\"\"\n    return dict(\n        (key.replace('-', '_'), val) for key, val in a_dict.items())", "code_tokens": "def dict_keys_without_hyphens ( a_dict ) : return dict ( ( key . replace ( '-' , '_' ) , val ) for key , val in a_dict . items ( ) )", "docstring_tokens": "Return the a new dict with underscores instead of hyphens in keys .", "label": 1}, {"idx": "cosqa-train-11985", "doc": "python sqlalchemy model to dict", "code": "def to_dict(self):\n        \"\"\"Serialize representation of the table for local caching.\"\"\"\n        return {'schema': self.schema, 'name': self.name, 'columns': [col.to_dict() for col in self._columns],\n                'foreign_keys': self.foreign_keys.to_dict(), 'ref_keys': self.ref_keys.to_dict()}", "code_tokens": "def to_dict ( self ) : return { 'schema' : self . schema , 'name' : self . name , 'columns' : [ col . to_dict ( ) for col in self . _columns ] , 'foreign_keys' : self . foreign_keys . to_dict ( ) , 'ref_keys' : self . ref_keys . to_dict ( ) }", "docstring_tokens": "Serialize representation of the table for local caching .", "label": 1}, {"idx": "cosqa-train-11986", "doc": "identifying most frequent word in sentance using python", "code": "def get_least_distinct_words(vocab, topic_word_distrib, doc_topic_distrib, doc_lengths, n=None):\n    \"\"\"\n    Order the words from `vocab` by \"distinctiveness score\" (Chuang et al. 2012) from least to most distinctive.\n    Optionally only return the `n` least distinctive words.\n\n    J. Chuang, C. Manning, J. Heer 2012: \"Termite: Visualization Techniques for Assessing Textual Topic Models\"\n    \"\"\"\n    return _words_by_distinctiveness_score(vocab, topic_word_distrib, doc_topic_distrib, doc_lengths, n,\n                                           least_to_most=True)", "code_tokens": "def get_least_distinct_words ( vocab , topic_word_distrib , doc_topic_distrib , doc_lengths , n = None ) : return _words_by_distinctiveness_score ( vocab , topic_word_distrib , doc_topic_distrib , doc_lengths , n , least_to_most = True )", "docstring_tokens": "Order the words from vocab by distinctiveness score ( Chuang et al . 2012 ) from least to most distinctive . Optionally only return the n least distinctive words .", "label": 1}, {"idx": "cosqa-train-11987", "doc": "python sqlalchemy sync tables", "code": "def createdb():\n    \"\"\"Create database tables from sqlalchemy models\"\"\"\n    manager.db.engine.echo = True\n    manager.db.create_all()\n    set_alembic_revision()", "code_tokens": "def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )", "docstring_tokens": "Create database tables from sqlalchemy models", "label": 1}, {"idx": "cosqa-train-11988", "doc": "if get key del key python", "code": "def delete(self, key_name):\n        \"\"\"Delete the key and return true if the key was deleted, else false\n        \"\"\"\n        self.db.remove(Query().name == key_name)\n        return self.get(key_name) == {}", "code_tokens": "def delete ( self , key_name ) : self . db . remove ( Query ( ) . name == key_name ) return self . get ( key_name ) == { }", "docstring_tokens": "Delete the key and return true if the key was deleted else false", "label": 1}, {"idx": "cosqa-train-11989", "doc": "python sqlalchemy truncate table", "code": "def teardown(self):\n        \"\"\"Cleanup cache tables.\"\"\"\n        for table_spec in reversed(self._table_specs):\n            with self._conn:\n                table_spec.teardown(self._conn)", "code_tokens": "def teardown ( self ) : for table_spec in reversed ( self . _table_specs ) : with self . _conn : table_spec . teardown ( self . _conn )", "docstring_tokens": "Cleanup cache tables .", "label": 0}, {"idx": "cosqa-train-11990", "doc": "if value is string plus anything python", "code": "def is_string(obj):\n    \"\"\"Is this a string.\n\n    :param object obj:\n    :rtype: bool\n    \"\"\"\n    if PYTHON3:\n        str_type = (bytes, str)\n    else:\n        str_type = (bytes, str, unicode)\n    return isinstance(obj, str_type)", "code_tokens": "def is_string ( obj ) : if PYTHON3 : str_type = ( bytes , str ) else : str_type = ( bytes , str , unicode ) return isinstance ( obj , str_type )", "docstring_tokens": "Is this a string .", "label": 1}, {"idx": "cosqa-train-11991", "doc": "python sqlite fetch to dictionary", "code": "def sqliteRowsToDicts(sqliteRows):\n    \"\"\"\n    Unpacks sqlite rows as returned by fetchall\n    into an array of simple dicts.\n\n    :param sqliteRows: array of rows returned from fetchall DB call\n    :return:  array of dicts, keyed by the column names.\n    \"\"\"\n    return map(lambda r: dict(zip(r.keys(), r)), sqliteRows)", "code_tokens": "def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )", "docstring_tokens": "Unpacks sqlite rows as returned by fetchall into an array of simple dicts .", "label": 1}, {"idx": "cosqa-train-11992", "doc": "ihow to call help function in python", "code": "def show_intro(self):\n        \"\"\"Show intro to IPython help\"\"\"\n        from IPython.core.usage import interactive_usage\n        self.main.help.show_rich_text(interactive_usage)", "code_tokens": "def show_intro ( self ) : from IPython . core . usage import interactive_usage self . main . help . show_rich_text ( interactive_usage )", "docstring_tokens": "Show intro to IPython help", "label": 0}, {"idx": "cosqa-train-11993", "doc": "python sqlite get dictionary instead of list", "code": "def sqliteRowsToDicts(sqliteRows):\n    \"\"\"\n    Unpacks sqlite rows as returned by fetchall\n    into an array of simple dicts.\n\n    :param sqliteRows: array of rows returned from fetchall DB call\n    :return:  array of dicts, keyed by the column names.\n    \"\"\"\n    return map(lambda r: dict(zip(r.keys(), r)), sqliteRows)", "code_tokens": "def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )", "docstring_tokens": "Unpacks sqlite rows as returned by fetchall into an array of simple dicts .", "label": 1}, {"idx": "cosqa-train-11994", "doc": "image normalization matrix python", "code": "def denorm(self,arr):\n        \"\"\"Reverse the normalization done to a batch of images.\n\n        Arguments:\n            arr: of shape/size (N,3,sz,sz)\n        \"\"\"\n        if type(arr) is not np.ndarray: arr = to_np(arr)\n        if len(arr.shape)==3: arr = arr[None]\n        return self.transform.denorm(np.rollaxis(arr,1,4))", "code_tokens": "def denorm ( self , arr ) : if type ( arr ) is not np . ndarray : arr = to_np ( arr ) if len ( arr . shape ) == 3 : arr = arr [ None ] return self . transform . denorm ( np . rollaxis ( arr , 1 , 4 ) )", "docstring_tokens": "Reverse the normalization done to a batch of images .", "label": 1}, {"idx": "cosqa-train-11995", "doc": "python sqlite table names in database", "code": "def get_table_names(connection):\n\t\"\"\"\n\tReturn a list of the table names in the database.\n\t\"\"\"\n\tcursor = connection.cursor()\n\tcursor.execute(\"SELECT name FROM sqlite_master WHERE type == 'table'\")\n\treturn [name for (name,) in cursor]", "code_tokens": "def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( \"SELECT name FROM sqlite_master WHERE type == 'table'\" ) return [ name for ( name , ) in cursor ]", "docstring_tokens": "Return a list of the table names in the database .", "label": 1}, {"idx": "cosqa-train-11996", "doc": "image segmentation kmeans python", "code": "def region_from_segment(image, segment):\n    \"\"\"given a segment (rectangle) and an image, returns it's corresponding subimage\"\"\"\n    x, y, w, h = segment\n    return image[y:y + h, x:x + w]", "code_tokens": "def region_from_segment ( image , segment ) : x , y , w , h = segment return image [ y : y + h , x : x + w ]", "docstring_tokens": "given a segment ( rectangle ) and an image returns it s corresponding subimage", "label": 1}, {"idx": "cosqa-train-11997", "doc": "python squeeze nested list", "code": "def flatten(lis):\n    \"\"\"Given a list, possibly nested to any level, return it flattened.\"\"\"\n    new_lis = []\n    for item in lis:\n        if isinstance(item, collections.Sequence) and not isinstance(item, basestring):\n            new_lis.extend(flatten(item))\n        else:\n            new_lis.append(item)\n    return new_lis", "code_tokens": "def flatten ( lis ) : new_lis = [ ] for item in lis : if isinstance ( item , collections . Sequence ) and not isinstance ( item , basestring ) : new_lis . extend ( flatten ( item ) ) else : new_lis . append ( item ) return new_lis", "docstring_tokens": "Given a list possibly nested to any level return it flattened .", "label": 1}, {"idx": "cosqa-train-11998", "doc": "implement downsampling python array", "code": "def downsample_with_striding(array, factor):\n    \"\"\"Downsample x by factor using striding.\n\n    @return: The downsampled array, of the same type as x.\n    \"\"\"\n    return array[tuple(np.s_[::f] for f in factor)]", "code_tokens": "def downsample_with_striding ( array , factor ) : return array [ tuple ( np . s_ [ : : f ] for f in factor ) ]", "docstring_tokens": "Downsample x by factor using striding .", "label": 1}, {"idx": "cosqa-train-11999", "doc": "python stack multiple 2d arrays", "code": "def column_stack_2d(data):\n    \"\"\"Perform column-stacking on a list of 2d data blocks.\"\"\"\n    return list(list(itt.chain.from_iterable(_)) for _ in zip(*data))", "code_tokens": "def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )", "docstring_tokens": "Perform column - stacking on a list of 2d data blocks .", "label": 1}]