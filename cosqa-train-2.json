[{"idx": "cosqa-train-4000", "doc": "show the percentage format in python graph", "code": "def show_approx(self, numfmt='%.3g'):\n        \"\"\"Show the probabilities rounded and sorted by key, for the\n        sake of portable doctests.\"\"\"\n        return ', '.join([('%s: ' + numfmt) % (v, p)\n                          for (v, p) in sorted(self.prob.items())])", "code_tokens": "def show_approx ( self , numfmt = '%.3g' ) : return ', ' . join ( [ ( '%s: ' + numfmt ) % ( v , p ) for ( v , p ) in sorted ( self . prob . items ( ) ) ] )", "docstring_tokens": "Show the probabilities rounded and sorted by key for the sake of portable doctests .", "label": 0}, {"idx": "cosqa-train-4001", "doc": "python bar plot changing width", "code": "def _change_height(self, ax, new_value):\n        \"\"\"Make bars in horizontal bar chart thinner\"\"\"\n        for patch in ax.patches:\n            current_height = patch.get_height()\n            diff = current_height - new_value\n\n            # we change the bar height\n            patch.set_height(new_value)\n\n            # we recenter the bar\n            patch.set_y(patch.get_y() + diff * .5)", "code_tokens": "def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )", "docstring_tokens": "Make bars in horizontal bar chart thinner", "label": 0}, {"idx": "cosqa-train-4002", "doc": "single element to array in python", "code": "def _transform_triple_numpy(x):\n    \"\"\"Transform triple index into a 1-D numpy array.\"\"\"\n    return np.array([x.head, x.relation, x.tail], dtype=np.int64)", "code_tokens": "def _transform_triple_numpy ( x ) : return np . array ( [ x . head , x . relation , x . tail ] , dtype = np . int64 )", "docstring_tokens": "Transform triple index into a 1 - D numpy array .", "label": 0}, {"idx": "cosqa-train-4003", "doc": "python beautifulsoup get text without inner tag", "code": "def text(el, strip=True):\n    \"\"\"\n    Return the text of a ``BeautifulSoup`` element\n    \"\"\"\n    if not el:\n        return \"\"\n\n    text = el.text\n    if strip:\n        text = text.strip()\n    return text", "code_tokens": "def text ( el , strip = True ) : if not el : return \"\" text = el . text if strip : text = text . strip ( ) return text", "docstring_tokens": "Return the text of a BeautifulSoup element", "label": 0}, {"idx": "cosqa-train-4004", "doc": "single underscore and double underscroll in python", "code": "def underscore(text):\n    \"\"\"Converts text that may be camelcased into an underscored format\"\"\"\n    return UNDERSCORE[1].sub(r'\\1_\\2', UNDERSCORE[0].sub(r'\\1_\\2', text)).lower()", "code_tokens": "def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\\1_\\2' , UNDERSCORE [ 0 ] . sub ( r'\\1_\\2' , text ) ) . lower ( )", "docstring_tokens": "Converts text that may be camelcased into an underscored format", "label": 0}, {"idx": "cosqa-train-4005", "doc": "python boto3 hiding credentials", "code": "def get_boto_session(\n        region,\n        aws_access_key_id=None,\n        aws_secret_access_key=None,\n        aws_session_token=None\n        ):\n    \"\"\"Get a boto3 session.\"\"\"\n    return boto3.session.Session(\n        region_name=region,\n        aws_secret_access_key=aws_secret_access_key,\n        aws_access_key_id=aws_access_key_id,\n        aws_session_token=aws_session_token\n    )", "code_tokens": "def get_boto_session ( region , aws_access_key_id = None , aws_secret_access_key = None , aws_session_token = None ) : return boto3 . session . Session ( region_name = region , aws_secret_access_key = aws_secret_access_key , aws_access_key_id = aws_access_key_id , aws_session_token = aws_session_token )", "docstring_tokens": "Get a boto3 session .", "label": 0}, {"idx": "cosqa-train-4006", "doc": "singleton and null in python", "code": "def singleton(class_):\n    \"\"\"Singleton definition.\n\n    Method 1 from\n    https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python\n    \"\"\"\n    instances = {}\n\n    def get_instance(*args, **kwargs):\n        if class_ not in instances:\n            instances[class_] = class_(*args, **kwargs)\n        return instances[class_]\n    return get_instance", "code_tokens": "def singleton ( class_ ) : instances = { } def get_instance ( * args , * * kwargs ) : if class_ not in instances : instances [ class_ ] = class_ ( * args , * * kwargs ) return instances [ class_ ] return get_instance", "docstring_tokens": "Singleton definition .", "label": 0}, {"idx": "cosqa-train-4007", "doc": "python bottle use https not http", "code": "def start():\n    \"\"\"Starts the web server.\"\"\"\n    global app\n    bottle.run(app, host=conf.WebHost, port=conf.WebPort,\n               debug=conf.WebAutoReload, reloader=conf.WebAutoReload,\n               quiet=conf.WebQuiet)", "code_tokens": "def start ( ) : global app bottle . run ( app , host = conf . WebHost , port = conf . WebPort , debug = conf . WebAutoReload , reloader = conf . WebAutoReload , quiet = conf . WebQuiet )", "docstring_tokens": "Starts the web server .", "label": 0}, {"idx": "cosqa-train-4008", "doc": "skip c comments regex python", "code": "def lines(input):\n    \"\"\"Remove comments and empty lines\"\"\"\n    for raw_line in input:\n        line = raw_line.strip()\n        if line and not line.startswith('#'):\n            yield strip_comments(line)", "code_tokens": "def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )", "docstring_tokens": "Remove comments and empty lines", "label": 0}, {"idx": "cosqa-train-4009", "doc": "python bufferedreader return to beginning", "code": "def get_iter_string_reader(stdin):\n    \"\"\" return an iterator that returns a chunk of a string every time it is\n    called.  notice that even though bufsize_type might be line buffered, we're\n    not doing any line buffering here.  that's because our StreamBufferer\n    handles all buffering.  we just need to return a reasonable-sized chunk. \"\"\"\n    bufsize = 1024\n    iter_str = (stdin[i:i + bufsize] for i in range(0, len(stdin), bufsize))\n    return get_iter_chunk_reader(iter_str)", "code_tokens": "def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )", "docstring_tokens": "return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk .", "label": 0}, {"idx": "cosqa-train-4010", "doc": "slice with step is not supported python", "code": "def is_full_slice(obj, l):\n    \"\"\"\n    We have a full length slice.\n    \"\"\"\n    return (isinstance(obj, slice) and obj.start == 0 and obj.stop == l and\n            obj.step is None)", "code_tokens": "def is_full_slice ( obj , l ) : return ( isinstance ( obj , slice ) and obj . start == 0 and obj . stop == l and obj . step is None )", "docstring_tokens": "We have a full length slice .", "label": 1}, {"idx": "cosqa-train-4011", "doc": "python build string from list items", "code": "def _make_cmd_list(cmd_list):\n    \"\"\"\n    Helper function to easily create the proper json formated string from a list of strs\n    :param cmd_list: list of strings\n    :return: str json formatted\n    \"\"\"\n    cmd = ''\n    for i in cmd_list:\n        cmd = cmd + '\"' + i + '\",'\n    cmd = cmd[:-1]\n    return cmd", "code_tokens": "def _make_cmd_list ( cmd_list ) : cmd = '' for i in cmd_list : cmd = cmd + '\"' + i + '\",' cmd = cmd [ : - 1 ] return cmd", "docstring_tokens": "Helper function to easily create the proper json formated string from a list of strs : param cmd_list : list of strings : return : str json formatted", "label": 0}, {"idx": "cosqa-train-4012", "doc": "sliding batches python iterator", "code": "def ibatch(iterable, size):\n    \"\"\"Yield a series of batches from iterable, each size elements long.\"\"\"\n    source = iter(iterable)\n    while True:\n        batch = itertools.islice(source, size)\n        yield itertools.chain([next(batch)], batch)", "code_tokens": "def ibatch ( iterable , size ) : source = iter ( iterable ) while True : batch = itertools . islice ( source , size ) yield itertools . chain ( [ next ( batch ) ] , batch )", "docstring_tokens": "Yield a series of batches from iterable each size elements long .", "label": 0}, {"idx": "cosqa-train-4013", "doc": "python butterworth bandpass filter float numbers", "code": "def filtered_image(self, im):\n        \"\"\"Returns a filtered image after applying the Fourier-space filters\"\"\"\n        q = np.fft.fftn(im)\n        for k,v in self.filters:\n            q[k] -= v\n        return np.real(np.fft.ifftn(q))", "code_tokens": "def filtered_image ( self , im ) : q = np . fft . fftn ( im ) for k , v in self . filters : q [ k ] -= v return np . real ( np . fft . ifftn ( q ) )", "docstring_tokens": "Returns a filtered image after applying the Fourier - space filters", "label": 0}, {"idx": "cosqa-train-4014", "doc": "sort list by long name python", "code": "def sort_by_name(self):\n        \"\"\"Sort list elements by name.\"\"\"\n        super(JSSObjectList, self).sort(key=lambda k: k.name)", "code_tokens": "def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )", "docstring_tokens": "Sort list elements by name .", "label": 0}, {"idx": "cosqa-train-4015", "doc": "python bypass ssl certificate verification", "code": "def disable_cert_validation():\n    \"\"\"Context manager to temporarily disable certificate validation in the standard SSL\n    library.\n\n    Note: This should not be used in production code but is sometimes useful for\n    troubleshooting certificate validation issues.\n\n    By design, the standard SSL library does not provide a way to disable verification\n    of the server side certificate. However, a patch to disable validation is described\n    by the library developers. This context manager allows applying the patch for\n    specific sections of code.\n\n    \"\"\"\n    current_context = ssl._create_default_https_context\n    ssl._create_default_https_context = ssl._create_unverified_context\n    try:\n        yield\n    finally:\n        ssl._create_default_https_context = current_context", "code_tokens": "def disable_cert_validation ( ) : current_context = ssl . _create_default_https_context ssl . _create_default_https_context = ssl . _create_unverified_context try : yield finally : ssl . _create_default_https_context = current_context", "docstring_tokens": "Context manager to temporarily disable certificate validation in the standard SSL library .", "label": 1}, {"idx": "cosqa-train-4016", "doc": "sort values python multiple columns in data frame", "code": "def sort_data(data, cols):\n    \"\"\"Sort `data` rows and order columns\"\"\"\n    return data.sort_values(cols)[cols + ['value']].reset_index(drop=True)", "code_tokens": "def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )", "docstring_tokens": "Sort data rows and order columns", "label": 0}, {"idx": "cosqa-train-4017", "doc": "python cache method response", "code": "def get_cache(self, decorated_function, *args, **kwargs):\n\t\t\"\"\" :meth:`WCacheStorage.get_cache` method implementation\n\t\t\"\"\"\n\t\thas_value = self.has(decorated_function, *args, **kwargs)\n\t\tcached_value = None\n\t\tif has_value is True:\n\t\t\tcached_value = self.get_result(decorated_function, *args, **kwargs)\n\t\treturn WCacheStorage.CacheEntry(has_value=has_value, cached_value=cached_value)", "code_tokens": "def get_cache ( self , decorated_function , * args , * * kwargs ) : has_value = self . has ( decorated_function , * args , * * kwargs ) cached_value = None if has_value is True : cached_value = self . get_result ( decorated_function , * args , * * kwargs ) return WCacheStorage . CacheEntry ( has_value = has_value , cached_value = cached_value )", "docstring_tokens": ": meth : WCacheStorage . get_cache method implementation", "label": 0}, {"idx": "cosqa-train-4018", "doc": "sorting an array with index python", "code": "def unsort_vector(data, indices_of_increasing):\n    \"\"\"Upermutate 1-D data that is sorted by indices_of_increasing.\"\"\"\n    return numpy.array([data[indices_of_increasing.index(i)] for i in range(len(data))])", "code_tokens": "def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )", "docstring_tokens": "Upermutate 1 - D data that is sorted by indices_of_increasing .", "label": 0}, {"idx": "cosqa-train-4019", "doc": "python calculate distance between two coordinates", "code": "def _calculate_distance(latlon1, latlon2):\n    \"\"\"Calculates the distance between two points on earth.\n    \"\"\"\n    lat1, lon1 = latlon1\n    lat2, lon2 = latlon2\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    R = 6371  # radius of the earth in kilometers\n    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * (np.sin(dlon / 2))**2\n    c = 2 * np.pi * R * np.arctan2(np.sqrt(a), np.sqrt(1 - a)) / 180\n    return c", "code_tokens": "def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c", "docstring_tokens": "Calculates the distance between two points on earth .", "label": 0}, {"idx": "cosqa-train-4020", "doc": "spacy load mat file python", "code": "def loadmat(filename):\n    \"\"\"This function should be called instead of direct spio.loadmat\n    as it cures the problem of not properly recovering python dictionaries\n    from mat files. It calls the function check keys to cure all entries\n    which are still mat-objects\n    \"\"\"\n    data = sploadmat(filename, struct_as_record=False, squeeze_me=True)\n    return _check_keys(data)", "code_tokens": "def loadmat ( filename ) : data = sploadmat ( filename , struct_as_record = False , squeeze_me = True ) return _check_keys ( data )", "docstring_tokens": "This function should be called instead of direct spio . loadmat as it cures the problem of not properly recovering python dictionaries from mat files . It calls the function check keys to cure all entries which are still mat - objects", "label": 1}, {"idx": "cosqa-train-4021", "doc": "python call aync def as sync", "code": "async def _thread_coro(self, *args):\n        \"\"\" Coroutine called by MapAsync. It's wrapping the call of\n        run_in_executor to run the synchronous function as thread \"\"\"\n        return await self._loop.run_in_executor(\n            self._executor, self._function, *args)", "code_tokens": "async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "docstring_tokens": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread", "label": 0}, {"idx": "cosqa-train-4022", "doc": "specify accept mime type python bottle", "code": "def python_mime(fn):\n    \"\"\"\n    Decorator, which adds correct MIME type for python source to the decorated\n    bottle API function.\n    \"\"\"\n    @wraps(fn)\n    def python_mime_decorator(*args, **kwargs):\n        response.content_type = \"text/x-python\"\n\n        return fn(*args, **kwargs)\n\n    return python_mime_decorator", "code_tokens": "def python_mime ( fn ) : @ wraps ( fn ) def python_mime_decorator ( * args , * * kwargs ) : response . content_type = \"text/x-python\" return fn ( * args , * * kwargs ) return python_mime_decorator", "docstring_tokens": "Decorator which adds correct MIME type for python source to the decorated bottle API function .", "label": 0}, {"idx": "cosqa-train-4023", "doc": "python call pytest in file", "code": "def run_tests(self):\n\t\t\"\"\"\n\t\tInvoke pytest, replacing argv. Return result code.\n\t\t\"\"\"\n\t\twith _save_argv(_sys.argv[:1] + self.addopts):\n\t\t\tresult_code = __import__('pytest').main()\n\t\t\tif result_code:\n\t\t\t\traise SystemExit(result_code)", "code_tokens": "def run_tests ( self ) : with _save_argv ( _sys . argv [ : 1 ] + self . addopts ) : result_code = __import__ ( 'pytest' ) . main ( ) if result_code : raise SystemExit ( result_code )", "docstring_tokens": "Invoke pytest replacing argv . Return result code .", "label": 0}, {"idx": "cosqa-train-4024", "doc": "specify how a priorityqueue compares its elements python", "code": "def swap_priority(self, key1, key2):\n        \"\"\"\n        Fast way to swap the priority level of two items in the pqdict. Raises\n        ``KeyError`` if either key does not exist.\n\n        \"\"\"\n        heap = self._heap\n        position = self._position\n        if key1 not in self or key2 not in self:\n            raise KeyError\n        pos1, pos2 = position[key1], position[key2]\n        heap[pos1].key, heap[pos2].key = key2, key1\n        position[key1], position[key2] = pos2, pos1", "code_tokens": "def swap_priority ( self , key1 , key2 ) : heap = self . _heap position = self . _position if key1 not in self or key2 not in self : raise KeyError pos1 , pos2 = position [ key1 ] , position [ key2 ] heap [ pos1 ] . key , heap [ pos2 ] . key = key2 , key1 position [ key1 ] , position [ key2 ] = pos2 , pos1", "docstring_tokens": "Fast way to swap the priority level of two items in the pqdict . Raises KeyError if either key does not exist .", "label": 0}, {"idx": "cosqa-train-4025", "doc": "python call recursive on subdirectory get all files", "code": "def recursively_get_files_from_directory(directory):\n    \"\"\"\n    Return all filenames under recursively found in a directory\n    \"\"\"\n    return [\n        os.path.join(root, filename)\n        for root, directories, filenames in os.walk(directory)\n        for filename in filenames\n    ]", "code_tokens": "def recursively_get_files_from_directory ( directory ) : return [ os . path . join ( root , filename ) for root , directories , filenames in os . walk ( directory ) for filename in filenames ]", "docstring_tokens": "Return all filenames under recursively found in a directory", "label": 1}, {"idx": "cosqa-train-4026", "doc": "sphinx python sub headings", "code": "def _set_module_names_for_sphinx(modules: List, new_name: str):\n    \"\"\" Trick sphinx into displaying the desired module in these objects' documentation. \"\"\"\n    for obj in modules:\n        obj.__module__ = new_name", "code_tokens": "def _set_module_names_for_sphinx ( modules : List , new_name : str ) : for obj in modules : obj . __module__ = new_name", "docstring_tokens": "Trick sphinx into displaying the desired module in these objects documentation .", "label": 0}, {"idx": "cosqa-train-4027", "doc": "python call to deprecated function", "code": "def _depr(fn, usage, stacklevel=3):\n    \"\"\"Internal convenience function for deprecation warnings\"\"\"\n    warn('{0} is deprecated. Use {1} instead'.format(fn, usage),\n         stacklevel=stacklevel, category=DeprecationWarning)", "code_tokens": "def _depr ( fn , usage , stacklevel = 3 ) : warn ( '{0} is deprecated. Use {1} instead' . format ( fn , usage ) , stacklevel = stacklevel , category = DeprecationWarning )", "docstring_tokens": "Internal convenience function for deprecation warnings", "label": 1}, {"idx": "cosqa-train-4028", "doc": "split array into chunks python", "code": "def chunks(arr, size):\n    \"\"\"Splits a list into chunks\n\n    :param arr: list to split\n    :type arr: :class:`list`\n    :param size: number of elements in each chunk\n    :type size: :class:`int`\n    :return: generator object\n    :rtype: :class:`generator`\n    \"\"\"\n    for i in _range(0, len(arr), size):\n        yield arr[i:i+size]", "code_tokens": "def chunks ( arr , size ) : for i in _range ( 0 , len ( arr ) , size ) : yield arr [ i : i + size ]", "docstring_tokens": "Splits a list into chunks", "label": 0}, {"idx": "cosqa-train-4029", "doc": "python callafter only once", "code": "def _run_once(self):\n    \"\"\"Run once, should be called only from loop()\"\"\"\n    try:\n      self.do_wait()\n      self._execute_wakeup_tasks()\n      self._trigger_timers()\n    except Exception as e:\n      Log.error(\"Error occured during _run_once(): \" + str(e))\n      Log.error(traceback.format_exc())\n      self.should_exit = True", "code_tokens": "def _run_once ( self ) : try : self . do_wait ( ) self . _execute_wakeup_tasks ( ) self . _trigger_timers ( ) except Exception as e : Log . error ( \"Error occured during _run_once(): \" + str ( e ) ) Log . error ( traceback . format_exc ( ) ) self . should_exit = True", "docstring_tokens": "Run once should be called only from loop ()", "label": 0}, {"idx": "cosqa-train-4030", "doc": "split string into n parts python", "code": "def _split_str(s, n):\n    \"\"\"\n    split string into list of strings by specified number.\n    \"\"\"\n    length = len(s)\n    return [s[i:i + n] for i in range(0, length, n)]", "code_tokens": "def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]", "docstring_tokens": "split string into list of strings by specified number .", "label": 1}, {"idx": "cosqa-train-4031", "doc": "python camelcase to dash", "code": "def camelcase_to_slash(name):\n    \"\"\" Converts CamelCase to camel/case\n\n    code ripped from http://stackoverflow.com/questions/1175208/does-the-python-standard-library-have-function-to-convert-camelcase-to-camel-cas\n    \"\"\"\n\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1/\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1/\\2', s1).lower()", "code_tokens": "def camelcase_to_slash ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1/\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1/\\2' , s1 ) . lower ( )", "docstring_tokens": "Converts CamelCase to camel / case", "label": 0}, {"idx": "cosqa-train-4032", "doc": "sqlalchemy sqlite datetime type only accepts python", "code": "def from_pydatetime(cls, pydatetime):\n        \"\"\"\n        Creates sql datetime2 object from Python datetime object\n        ignoring timezone\n        @param pydatetime: Python datetime object\n        @return: sql datetime2 object\n        \"\"\"\n        return cls(date=Date.from_pydate(pydatetime.date),\n                   time=Time.from_pytime(pydatetime.time))", "code_tokens": "def from_pydatetime ( cls , pydatetime ) : return cls ( date = Date . from_pydate ( pydatetime . date ) , time = Time . from_pytime ( pydatetime . time ) )", "docstring_tokens": "Creates sql datetime2 object from Python datetime object ignoring timezone", "label": 0}, {"idx": "cosqa-train-4033", "doc": "python can you use strings in a conditional", "code": "def is_identifier(string):\n    \"\"\"Check if string could be a valid python identifier\n\n    :param string: string to be tested\n    :returns: True if string can be a python identifier, False otherwise\n    :rtype: bool\n    \"\"\"\n    matched = PYTHON_IDENTIFIER_RE.match(string)\n    return bool(matched) and not keyword.iskeyword(string)", "code_tokens": "def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )", "docstring_tokens": "Check if string could be a valid python identifier", "label": 0}, {"idx": "cosqa-train-4034", "doc": "sqlite datetime type only accepts python datetime", "code": "def from_pydatetime(cls, pydatetime):\n        \"\"\"\n        Creates sql datetime2 object from Python datetime object\n        ignoring timezone\n        @param pydatetime: Python datetime object\n        @return: sql datetime2 object\n        \"\"\"\n        return cls(date=Date.from_pydate(pydatetime.date),\n                   time=Time.from_pytime(pydatetime.time))", "code_tokens": "def from_pydatetime ( cls , pydatetime ) : return cls ( date = Date . from_pydate ( pydatetime . date ) , time = Time . from_pytime ( pydatetime . time ) )", "docstring_tokens": "Creates sql datetime2 object from Python datetime object ignoring timezone", "label": 0}, {"idx": "cosqa-train-4035", "doc": "python canvas scroll width", "code": "def set_scrollregion(self, event=None):\n        \"\"\" Set the scroll region on the canvas\"\"\"\n        self.canvas.configure(scrollregion=self.canvas.bbox('all'))", "code_tokens": "def set_scrollregion ( self , event = None ) : self . canvas . configure ( scrollregion = self . canvas . bbox ( 'all' ) )", "docstring_tokens": "Set the scroll region on the canvas", "label": 0}, {"idx": "cosqa-train-4036", "doc": "squish python how to check if services is running", "code": "def is_alive(self):\n        \"\"\"\n        Will test whether the ACS service is up and alive.\n        \"\"\"\n        response = self.get_monitoring_heartbeat()\n        if response.status_code == 200 and response.content == 'alive':\n            return True\n\n        return False", "code_tokens": "def is_alive ( self ) : response = self . get_monitoring_heartbeat ( ) if response . status_code == 200 and response . content == 'alive' : return True return False", "docstring_tokens": "Will test whether the ACS service is up and alive .", "label": 0}, {"idx": "cosqa-train-4037", "doc": "python capital to lowercase", "code": "def to_capitalized_camel_case(snake_case_string):\n    \"\"\"\n    Convert a string from snake case to camel case with the first letter capitalized. For example, \"some_var\"\n    would become \"SomeVar\".\n\n    :param snake_case_string: Snake-cased string to convert to camel case.\n    :returns: Camel-cased version of snake_case_string.\n    \"\"\"\n    parts = snake_case_string.split('_')\n    return ''.join([i.title() for i in parts])", "code_tokens": "def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )", "docstring_tokens": "Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar .", "label": 0}, {"idx": "cosqa-train-4038", "doc": "stack overflow python isinstance method", "code": "def _subclassed(base, *classes):\n        \"\"\"Check if all classes are subclassed from base.\n        \"\"\"\n        return all(map(lambda obj: isinstance(obj, base), classes))", "code_tokens": "def _subclassed ( base , * classes ) : return all ( map ( lambda obj : isinstance ( obj , base ) , classes ) )", "docstring_tokens": "Check if all classes are subclassed from base .", "label": 0}, {"idx": "cosqa-train-4039", "doc": "stack overflow python port scanner", "code": "def _port_not_in_use():\n    \"\"\"Use the port 0 trick to find a port not in use.\"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    port = 0\n    s.bind(('', port))\n    _, port = s.getsockname()\n    return port", "code_tokens": "def _port_not_in_use ( ) : s = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) port = 0 s . bind ( ( '' , port ) ) _ , port = s . getsockname ( ) return port", "docstring_tokens": "Use the port 0 trick to find a port not in use .", "label": 0}, {"idx": "cosqa-train-4040", "doc": "python cast list to csv", "code": "def list_to_csv(value):\n    \"\"\"\n    Converts list to string with comma separated values. For string is no-op.\n    \"\"\"\n    if isinstance(value, (list, tuple, set)):\n        value = \",\".join(value)\n    return value", "code_tokens": "def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = \",\" . join ( value ) return value", "docstring_tokens": "Converts list to string with comma separated values . For string is no - op .", "label": 1}, {"idx": "cosqa-train-4041", "doc": "stackoverflow python change shared array", "code": "def copy(a):\n    \"\"\" Copy an array to the shared memory. \n\n        Notes\n        -----\n        copy is not always necessary because the private memory is always copy-on-write.\n\n        Use :code:`a = copy(a)` to immediately dereference the old 'a' on private memory\n    \"\"\"\n    shared = anonymousmemmap(a.shape, dtype=a.dtype)\n    shared[:] = a[:]\n    return shared", "code_tokens": "def copy ( a ) : shared = anonymousmemmap ( a . shape , dtype = a . dtype ) shared [ : ] = a [ : ] return shared", "docstring_tokens": "Copy an array to the shared memory .", "label": 0}, {"idx": "cosqa-train-4042", "doc": "python casting a variable into a datetime", "code": "def _datetime_to_date(arg):\n    \"\"\"\n    convert datetime/str to date\n    :param arg:\n    :return:\n    \"\"\"\n    _arg = parse(arg)\n    if isinstance(_arg, datetime.datetime):\n        _arg = _arg.date()\n    return _arg", "code_tokens": "def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "docstring_tokens": "convert datetime / str to date : param arg : : return :", "label": 0}, {"idx": "cosqa-train-4043", "doc": "stamping a pdf programmatically python", "code": "def append_pdf(input_pdf: bytes, output_writer: PdfFileWriter):\n    \"\"\"\n    Appends a PDF to a pyPDF writer. Legacy interface.\n    \"\"\"\n    append_memory_pdf_to_writer(input_pdf=input_pdf,\n                                writer=output_writer)", "code_tokens": "def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )", "docstring_tokens": "Appends a PDF to a pyPDF writer . Legacy interface .", "label": 0}, {"idx": "cosqa-train-4044", "doc": "python cdll load dll", "code": "def load(self, name):\n        \"\"\"Loads and returns foreign library.\"\"\"\n        name = ctypes.util.find_library(name)\n        return ctypes.cdll.LoadLibrary(name)", "code_tokens": "def load ( self , name ) : name = ctypes . util . find_library ( name ) return ctypes . cdll . LoadLibrary ( name )", "docstring_tokens": "Loads and returns foreign library .", "label": 0}, {"idx": "cosqa-train-4045", "doc": "standard deviation in groub by python", "code": "def weighted_std(values, weights):\n    \"\"\" Calculate standard deviation weighted by errors \"\"\"\n    average = np.average(values, weights=weights)\n    variance = np.average((values-average)**2, weights=weights)\n    return np.sqrt(variance)", "code_tokens": "def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )", "docstring_tokens": "Calculate standard deviation weighted by errors", "label": 1}, {"idx": "cosqa-train-4046", "doc": "python change array to categorical", "code": "def _maybe_to_categorical(array):\n    \"\"\"\n    Coerce to a categorical if a series is given.\n\n    Internal use ONLY.\n    \"\"\"\n    if isinstance(array, (ABCSeries, ABCCategoricalIndex)):\n        return array._values\n    elif isinstance(array, np.ndarray):\n        return Categorical(array)\n    return array", "code_tokens": "def _maybe_to_categorical ( array ) : if isinstance ( array , ( ABCSeries , ABCCategoricalIndex ) ) : return array . _values elif isinstance ( array , np . ndarray ) : return Categorical ( array ) return array", "docstring_tokens": "Coerce to a categorical if a series is given .", "label": 0}, {"idx": "cosqa-train-4047", "doc": "standard deviation of column python 3", "code": "def circstd(dts, axis=2):\n    \"\"\"Circular standard deviation\"\"\"\n    R = np.abs(np.exp(1.0j * dts).mean(axis=axis))\n    return np.sqrt(-2.0 * np.log(R))", "code_tokens": "def circstd ( dts , axis = 2 ) : R = np . abs ( np . exp ( 1.0j * dts ) . mean ( axis = axis ) ) return np . sqrt ( - 2.0 * np . log ( R ) )", "docstring_tokens": "Circular standard deviation", "label": 0}, {"idx": "cosqa-train-4048", "doc": "python change combobox value", "code": "def onchange(self, value):\n        \"\"\"Called when a new DropDownItem gets selected.\n        \"\"\"\n        log.debug('combo box. selected %s' % value)\n        self.select_by_value(value)\n        return (value, )", "code_tokens": "def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )", "docstring_tokens": "Called when a new DropDownItem gets selected .", "label": 0}, {"idx": "cosqa-train-4049", "doc": "store cookies python back end", "code": "def save_config_value(request, response, key, value):\n    \"\"\"Sets value of key `key` to `value` in both session and cookies.\"\"\"\n    request.session[key] = value\n    response.set_cookie(key, value, expires=one_year_from_now())\n    return response", "code_tokens": "def save_config_value ( request , response , key , value ) : request . session [ key ] = value response . set_cookie ( key , value , expires = one_year_from_now ( ) ) return response", "docstring_tokens": "Sets value of key key to value in both session and cookies .", "label": 1}, {"idx": "cosqa-train-4050", "doc": "python change label with set method", "code": "def set_label ( self, object, label ):\n        \"\"\" Sets the label for a specified object.\n        \"\"\"\n        label_name = self.label\n        if label_name[:1] != '=':\n            xsetattr( object, label_name, label )", "code_tokens": "def set_label ( self , object , label ) : label_name = self . label if label_name [ : 1 ] != '=' : xsetattr ( object , label_name , label )", "docstring_tokens": "Sets the label for a specified object .", "label": 0}, {"idx": "cosqa-train-4051", "doc": "python change the file permission", "code": "def add_exec_permission_to(target_file):\n    \"\"\"Add executable permissions to the file\n\n    :param target_file: the target file whose permission to be changed\n    \"\"\"\n    mode = os.stat(target_file).st_mode\n    os.chmod(target_file, mode | stat.S_IXUSR)", "code_tokens": "def add_exec_permission_to ( target_file ) : mode = os . stat ( target_file ) . st_mode os . chmod ( target_file , mode | stat . S_IXUSR )", "docstring_tokens": "Add executable permissions to the file", "label": 0}, {"idx": "cosqa-train-4052", "doc": "stream opened in read mode in python", "code": "def next (self):    # File-like object.\n\n        \"\"\"This is to support iterators over a file-like object.\n        \"\"\"\n\n        result = self.readline()\n        if result == self._empty_buffer:\n            raise StopIteration\n        return result", "code_tokens": "def next ( self ) : # File-like object. result = self . readline ( ) if result == self . _empty_buffer : raise StopIteration return result", "docstring_tokens": "This is to support iterators over a file - like object .", "label": 0}, {"idx": "cosqa-train-4053", "doc": "python change type to numeric", "code": "def _to_numeric(val):\n    \"\"\"\n    Helper function for conversion of various data types into numeric representation.\n    \"\"\"\n    if isinstance(val, (int, float, datetime.datetime, datetime.timedelta)):\n        return val\n    return float(val)", "code_tokens": "def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )", "docstring_tokens": "Helper function for conversion of various data types into numeric representation .", "label": 0}, {"idx": "cosqa-train-4054", "doc": "strftime python millisecond precision", "code": "def fmt_duration(secs):\n    \"\"\"Format a duration in seconds.\"\"\"\n    return ' '.join(fmt.human_duration(secs, 0, precision=2, short=True).strip().split())", "code_tokens": "def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )", "docstring_tokens": "Format a duration in seconds .", "label": 0}, {"idx": "cosqa-train-4055", "doc": "python chech if a string is a sub string of another string", "code": "def _is_subsequence_of(self, sub, sup):\n        \"\"\"\n        Parameters\n        ----------\n        sub : str\n        sup : str\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        return bool(re.search(\".*\".join(sub), sup))", "code_tokens": "def _is_subsequence_of ( self , sub , sup ) : return bool ( re . search ( \".*\" . join ( sub ) , sup ) )", "docstring_tokens": "Parameters ---------- sub : str sup : str", "label": 1}, {"idx": "cosqa-train-4056", "doc": "strftime to epoch and back python", "code": "def AmericanDateToEpoch(self, date_str):\n    \"\"\"Take a US format date and return epoch.\"\"\"\n    try:\n      epoch = time.strptime(date_str, \"%m/%d/%Y\")\n      return int(calendar.timegm(epoch)) * 1000000\n    except ValueError:\n      return 0", "code_tokens": "def AmericanDateToEpoch ( self , date_str ) : try : epoch = time . strptime ( date_str , \"%m/%d/%Y\" ) return int ( calendar . timegm ( epoch ) ) * 1000000 except ValueError : return 0", "docstring_tokens": "Take a US format date and return epoch .", "label": 0}, {"idx": "cosqa-train-4057", "doc": "python check 2 file content same", "code": "def cmp_contents(filename1, filename2):\n    \"\"\" Returns True if contents of the files are the same\n\n    Parameters\n    ----------\n    filename1 : str\n        filename of first file to compare\n    filename2 : str\n        filename of second file to compare\n\n    Returns\n    -------\n    tf : bool\n        True if binary contents of `filename1` is same as binary contents of\n        `filename2`, False otherwise.\n    \"\"\"\n    with open_readable(filename1, 'rb') as fobj:\n        contents1 = fobj.read()\n    with open_readable(filename2, 'rb') as fobj:\n        contents2 = fobj.read()\n    return contents1 == contents2", "code_tokens": "def cmp_contents ( filename1 , filename2 ) : with open_readable ( filename1 , 'rb' ) as fobj : contents1 = fobj . read ( ) with open_readable ( filename2 , 'rb' ) as fobj : contents2 = fobj . read ( ) return contents1 == contents2", "docstring_tokens": "Returns True if contents of the files are the same", "label": 0}, {"idx": "cosqa-train-4058", "doc": "string to dateframe in python", "code": "def _parse(self, date_str, format='%Y-%m-%d'):\n        \"\"\"\n        helper function for parsing FRED date string into datetime\n        \"\"\"\n        rv = pd.to_datetime(date_str, format=format)\n        if hasattr(rv, 'to_pydatetime'):\n            rv = rv.to_pydatetime()\n        return rv", "code_tokens": "def _parse ( self , date_str , format = '%Y-%m-%d' ) : rv = pd . to_datetime ( date_str , format = format ) if hasattr ( rv , 'to_pydatetime' ) : rv = rv . to_pydatetime ( ) return rv", "docstring_tokens": "helper function for parsing FRED date string into datetime", "label": 0}, {"idx": "cosqa-train-4059", "doc": "python check a field exist", "code": "def has_field(mc, field_name):\n    \"\"\"\n    detect if a model has a given field has\n\n    :param field_name:\n    :param mc:\n    :return:\n    \"\"\"\n    try:\n        mc._meta.get_field(field_name)\n    except FieldDoesNotExist:\n        return False\n    return True", "code_tokens": "def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True", "docstring_tokens": "detect if a model has a given field has", "label": 0}, {"idx": "cosqa-train-4060", "doc": "strip object in loop python", "code": "def _removeTags(tags, objects):\n    \"\"\" Removes tags from objects \"\"\"\n    for t in tags:\n        for o in objects:\n            o.tags.remove(t)\n\n    return True", "code_tokens": "def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True", "docstring_tokens": "Removes tags from objects", "label": 1}, {"idx": "cosqa-train-4061", "doc": "python check api url data change", "code": "def _is_valid_api_url(self, url):\n        \"\"\"Callback for is_valid_api_url.\"\"\"\n        # Check response is a JSON with ok: 1\n        data = {}\n        try:\n            r = requests.get(url, proxies=self.proxy_servers)\n            content = to_text_string(r.content, encoding='utf-8')\n            data = json.loads(content)\n        except Exception as error:\n            logger.error(str(error))\n\n        return data.get('ok', 0) == 1", "code_tokens": "def _is_valid_api_url ( self , url ) : # Check response is a JSON with ok: 1 data = { } try : r = requests . get ( url , proxies = self . proxy_servers ) content = to_text_string ( r . content , encoding = 'utf-8' ) data = json . loads ( content ) except Exception as error : logger . error ( str ( error ) ) return data . get ( 'ok' , 0 ) == 1", "docstring_tokens": "Callback for is_valid_api_url .", "label": 0}, {"idx": "cosqa-train-4062", "doc": "styling long lines in python", "code": "def straight_line_show(title, length=100, linestyle=\"=\", pad=0):\n        \"\"\"Print a formatted straight line.\n        \"\"\"\n        print(StrTemplate.straight_line(\n            title=title, length=length, linestyle=linestyle, pad=pad))", "code_tokens": "def straight_line_show ( title , length = 100 , linestyle = \"=\" , pad = 0 ) : print ( StrTemplate . straight_line ( title = title , length = length , linestyle = linestyle , pad = pad ) )", "docstring_tokens": "Print a formatted straight line .", "label": 0}, {"idx": "cosqa-train-4063", "doc": "python check cuda complibility", "code": "def cudaMalloc(count, ctype=None):\n    \"\"\"\n    Allocate device memory.\n\n    Allocate memory on the device associated with the current active\n    context.\n\n    Parameters\n    ----------\n    count : int\n        Number of bytes of memory to allocate\n    ctype : _ctypes.SimpleType, optional\n        ctypes type to cast returned pointer.\n\n    Returns\n    -------\n    ptr : ctypes pointer\n        Pointer to allocated device memory.\n\n    \"\"\"\n\n    ptr = ctypes.c_void_p()\n    status = _libcudart.cudaMalloc(ctypes.byref(ptr), count)\n    cudaCheckStatus(status)\n    if ctype != None:\n        ptr = ctypes.cast(ptr, ctypes.POINTER(ctype))\n    return ptr", "code_tokens": "def cudaMalloc ( count , ctype = None ) : ptr = ctypes . c_void_p ( ) status = _libcudart . cudaMalloc ( ctypes . byref ( ptr ) , count ) cudaCheckStatus ( status ) if ctype != None : ptr = ctypes . cast ( ptr , ctypes . POINTER ( ctype ) ) return ptr", "docstring_tokens": "Allocate device memory .", "label": 1}, {"idx": "cosqa-train-4064", "doc": "subprocess python get the output of the command and save it to a variable", "code": "def check_output(args):\n    \"\"\"Runs command and returns the output as string.\"\"\"\n    log.debug('run: %s', args)\n    out = subprocess.check_output(args=args).decode('utf-8')\n    log.debug('out: %r', out)\n    return out", "code_tokens": "def check_output ( args ) : log . debug ( 'run: %s' , args ) out = subprocess . check_output ( args = args ) . decode ( 'utf-8' ) log . debug ( 'out: %r' , out ) return out", "docstring_tokens": "Runs command and returns the output as string .", "label": 0}, {"idx": "cosqa-train-4065", "doc": "python check enum has value", "code": "def check(self, var):\n        \"\"\"Check whether the provided value is a valid enum constant.\"\"\"\n        if not isinstance(var, _str_type): return False\n        return _enum_mangle(var) in self._consts", "code_tokens": "def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts", "docstring_tokens": "Check whether the provided value is a valid enum constant .", "label": 0}, {"idx": "cosqa-train-4066", "doc": "substract datetime strings python", "code": "def convert_time_string(date_str):\n    \"\"\" Change a date string from the format 2018-08-15T23:55:17 into a datetime object \"\"\"\n    dt, _, _ = date_str.partition(\".\")\n    dt = datetime.strptime(dt, \"%Y-%m-%dT%H:%M:%S\")\n    return dt", "code_tokens": "def convert_time_string ( date_str ) : dt , _ , _ = date_str . partition ( \".\" ) dt = datetime . strptime ( dt , \"%Y-%m-%dT%H:%M:%S\" ) return dt", "docstring_tokens": "Change a date string from the format 2018 - 08 - 15T23 : 55 : 17 into a datetime object", "label": 1}, {"idx": "cosqa-train-4067", "doc": "python check enum with value exists", "code": "def check(self, var):\n        \"\"\"Check whether the provided value is a valid enum constant.\"\"\"\n        if not isinstance(var, _str_type): return False\n        return _enum_mangle(var) in self._consts", "code_tokens": "def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts", "docstring_tokens": "Check whether the provided value is a valid enum constant .", "label": 0}, {"idx": "cosqa-train-4068", "doc": "sum along an axis python", "code": "def Sum(a, axis, keep_dims):\n    \"\"\"\n    Sum reduction op.\n    \"\"\"\n    return np.sum(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis),\n                  keepdims=keep_dims),", "code_tokens": "def Sum ( a , axis , keep_dims ) : return np . sum ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "docstring_tokens": "Sum reduction op .", "label": 0}, {"idx": "cosqa-train-4069", "doc": "sum iterator of map in python exicise", "code": "def _accumulate(sequence, func):\n    \"\"\"\n    Python2 accumulate implementation taken from\n    https://docs.python.org/3/library/itertools.html#itertools.accumulate\n    \"\"\"\n    iterator = iter(sequence)\n    total = next(iterator)\n    yield total\n    for element in iterator:\n        total = func(total, element)\n        yield total", "code_tokens": "def _accumulate ( sequence , func ) : iterator = iter ( sequence ) total = next ( iterator ) yield total for element in iterator : total = func ( total , element ) yield total", "docstring_tokens": "Python2 accumulate implementation taken from https : // docs . python . org / 3 / library / itertools . html#itertools . accumulate", "label": 0}, {"idx": "cosqa-train-4070", "doc": "python check for git", "code": "def is_git_repo():\n    \"\"\"Check whether the current folder is a Git repo.\"\"\"\n    cmd = \"git\", \"rev-parse\", \"--git-dir\"\n    try:\n        subprocess.run(cmd, stdout=subprocess.DEVNULL, check=True)\n        return True\n    except subprocess.CalledProcessError:\n        return False", "code_tokens": "def is_git_repo ( ) : cmd = \"git\" , \"rev-parse\" , \"--git-dir\" try : subprocess . run ( cmd , stdout = subprocess . DEVNULL , check = True ) return True except subprocess . CalledProcessError : return False", "docstring_tokens": "Check whether the current folder is a Git repo .", "label": 0}, {"idx": "cosqa-train-4071", "doc": "sum over all axis but one python", "code": "def Sum(a, axis, keep_dims):\n    \"\"\"\n    Sum reduction op.\n    \"\"\"\n    return np.sum(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis),\n                  keepdims=keep_dims),", "code_tokens": "def Sum ( a , axis , keep_dims ) : return np . sum ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "docstring_tokens": "Sum reduction op .", "label": 0}, {"idx": "cosqa-train-4072", "doc": "python check for linux", "code": "def is_archlinux():\n    \"\"\"return True if the current distribution is running on debian like OS.\"\"\"\n    if platform.system().lower() == 'linux':\n        if platform.linux_distribution() == ('', '', ''):\n            # undefined distribution. Fixed in python 3.\n            if os.path.exists('/etc/arch-release'):\n                return True\n    return False", "code_tokens": "def is_archlinux ( ) : if platform . system ( ) . lower ( ) == 'linux' : if platform . linux_distribution ( ) == ( '' , '' , '' ) : # undefined distribution. Fixed in python 3. if os . path . exists ( '/etc/arch-release' ) : return True return False", "docstring_tokens": "return True if the current distribution is running on debian like OS .", "label": 0}, {"idx": "cosqa-train-4073", "doc": "swap case string function python", "code": "def to_snake_case(s):\n    \"\"\"Converts camel-case identifiers to snake-case.\"\"\"\n    return re.sub('([^_A-Z])([A-Z])', lambda m: m.group(1) + '_' + m.group(2).lower(), s)", "code_tokens": "def to_snake_case ( s ) : return re . sub ( '([^_A-Z])([A-Z])' , lambda m : m . group ( 1 ) + '_' + m . group ( 2 ) . lower ( ) , s )", "docstring_tokens": "Converts camel - case identifiers to snake - case .", "label": 0}, {"idx": "cosqa-train-4074", "doc": "python check if a match group exists", "code": "def group_exists(groupname):\n    \"\"\"Check if a group exists\"\"\"\n    try:\n        grp.getgrnam(groupname)\n        group_exists = True\n    except KeyError:\n        group_exists = False\n    return group_exists", "code_tokens": "def group_exists ( groupname ) : try : grp . getgrnam ( groupname ) group_exists = True except KeyError : group_exists = False return group_exists", "docstring_tokens": "Check if a group exists", "label": 0}, {"idx": "cosqa-train-4075", "doc": "swap columns in a matrix python", "code": "def _swap_rows(self, i, j):\n        \"\"\"Swap i and j rows\n\n        As the side effect, determinant flips.\n\n        \"\"\"\n\n        L = np.eye(3, dtype='intc')\n        L[i, i] = 0\n        L[j, j] = 0\n        L[i, j] = 1\n        L[j, i] = 1\n        self._L.append(L.copy())\n        self._A = np.dot(L, self._A)", "code_tokens": "def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )", "docstring_tokens": "Swap i and j rows", "label": 0}, {"idx": "cosqa-train-4076", "doc": "python check if all items in list are equal", "code": "def allsame(list_, strict=True):\n    \"\"\"\n    checks to see if list is equal everywhere\n\n    Args:\n        list_ (list):\n\n    Returns:\n        True if all items in the list are equal\n    \"\"\"\n    if len(list_) == 0:\n        return True\n    first_item = list_[0]\n    return list_all_eq_to(list_, first_item, strict)", "code_tokens": "def allsame ( list_ , strict = True ) : if len ( list_ ) == 0 : return True first_item = list_ [ 0 ] return list_all_eq_to ( list_ , first_item , strict )", "docstring_tokens": "checks to see if list is equal everywhere", "label": 0}, {"idx": "cosqa-train-4077", "doc": "swap function in python lists", "code": "def lazy_reverse_binmap(f, xs):\n    \"\"\"\n    Same as lazy_binmap, except the parameters are flipped for the binary function\n    \"\"\"\n    return (f(y, x) for x, y in zip(xs, xs[1:]))", "code_tokens": "def lazy_reverse_binmap ( f , xs ) : return ( f ( y , x ) for x , y in zip ( xs , xs [ 1 : ] ) )", "docstring_tokens": "Same as lazy_binmap except the parameters are flipped for the binary function", "label": 0}, {"idx": "cosqa-train-4078", "doc": "python check if column is in list of strings", "code": "def isin(self, column, compare_list):\n        \"\"\"\n        Returns a boolean list where each elements is whether that element in the column is in the compare_list.\n\n        :param column: single column name, does not work for multiple columns\n        :param compare_list: list of items to compare to\n        :return: list of booleans\n        \"\"\"\n        return [x in compare_list for x in self._data[self._columns.index(column)]]", "code_tokens": "def isin ( self , column , compare_list ) : return [ x in compare_list for x in self . _data [ self . _columns . index ( column ) ] ]", "docstring_tokens": "Returns a boolean list where each elements is whether that element in the column is in the compare_list .", "label": 0}, {"idx": "cosqa-train-4079", "doc": "symbols is not defined python", "code": "def jsonify(symbol):\n    \"\"\" returns json format for symbol \"\"\"\n    try:\n        # all symbols have a toJson method, try it\n        return json.dumps(symbol.toJson(), indent='  ')\n    except AttributeError:\n        pass\n    return json.dumps(symbol, indent='  ')", "code_tokens": "def jsonify ( symbol ) : try : # all symbols have a toJson method, try it return json . dumps ( symbol . toJson ( ) , indent = '  ' ) except AttributeError : pass return json . dumps ( symbol , indent = '  ' )", "docstring_tokens": "returns json format for symbol", "label": 0}, {"idx": "cosqa-train-4080", "doc": "python check if connecg to html port", "code": "def is_http_running_on(port):\n  \"\"\" Check if an http server runs on a given port.\n\n  Args:\n    The port to check.\n  Returns:\n    True if it is used by an http server. False otherwise.\n  \"\"\"\n  try:\n    conn = httplib.HTTPConnection('127.0.0.1:' + str(port))\n    conn.connect()\n    conn.close()\n    return True\n  except Exception:\n    return False", "code_tokens": "def is_http_running_on ( port ) : try : conn = httplib . HTTPConnection ( '127.0.0.1:' + str ( port ) ) conn . connect ( ) conn . close ( ) return True except Exception : return False", "docstring_tokens": "Check if an http server runs on a given port .", "label": 0}, {"idx": "cosqa-train-4081", "doc": "table widget width of column in python", "code": "def table_width(self):\n        \"\"\"Return the width of the table including padding and borders.\"\"\"\n        outer_widths = max_dimensions(self.table_data, self.padding_left, self.padding_right)[2]\n        outer_border = 2 if self.outer_border else 0\n        inner_border = 1 if self.inner_column_border else 0\n        return table_width(outer_widths, outer_border, inner_border)", "code_tokens": "def table_width ( self ) : outer_widths = max_dimensions ( self . table_data , self . padding_left , self . padding_right ) [ 2 ] outer_border = 2 if self . outer_border else 0 inner_border = 1 if self . inner_column_border else 0 return table_width ( outer_widths , outer_border , inner_border )", "docstring_tokens": "Return the width of the table including padding and borders .", "label": 0}, {"idx": "cosqa-train-4082", "doc": "python check if dictionary key is equal to a specific string", "code": "def __contains__ (self, key):\n        \"\"\"Check lowercase key item.\"\"\"\n        assert isinstance(key, basestring)\n        return dict.__contains__(self, key.lower())", "code_tokens": "def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "docstring_tokens": "Check lowercase key item .", "label": 0}, {"idx": "cosqa-train-4083", "doc": "take a screenshot python webdriver", "code": "def save_as_png(self, filename, width=300, height=250, render_time=1):\n        \"\"\"Open saved html file in an virtual browser and save a screen shot to PNG format.\"\"\"\n        self.driver.set_window_size(width, height)\n        self.driver.get('file://{path}/{filename}'.format(\n            path=os.getcwd(), filename=filename + \".html\"))\n        time.sleep(render_time)\n        self.driver.save_screenshot(filename + \".png\")", "code_tokens": "def save_as_png ( self , filename , width = 300 , height = 250 , render_time = 1 ) : self . driver . set_window_size ( width , height ) self . driver . get ( 'file://{path}/{filename}' . format ( path = os . getcwd ( ) , filename = filename + \".html\" ) ) time . sleep ( render_time ) self . driver . save_screenshot ( filename + \".png\" )", "docstring_tokens": "Open saved html file in an virtual browser and save a screen shot to PNG format .", "label": 0}, {"idx": "cosqa-train-4084", "doc": "python check if field value is null", "code": "def is_all_field_none(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n\n        if self._type_ is not None:\n            return False\n\n        if self._value is not None:\n            return False\n\n        if self._name is not None:\n            return False\n\n        return True", "code_tokens": "def is_all_field_none ( self ) : if self . _type_ is not None : return False if self . _value is not None : return False if self . _name is not None : return False return True", "docstring_tokens": ": rtype : bool", "label": 1}, {"idx": "cosqa-train-4085", "doc": "take log to array in python", "code": "def to_distribution_values(self, values):\n        \"\"\"\n        Returns numpy array of natural logarithms of ``values``.\n        \"\"\"\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            # avoid RuntimeWarning: divide by zero encountered in log\n            return numpy.log(values)", "code_tokens": "def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( \"ignore\" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )", "docstring_tokens": "Returns numpy array of natural logarithms of values .", "label": 0}, {"idx": "cosqa-train-4086", "doc": "python check if file is json", "code": "def is_json_file(filename, show_warnings = False):\n    \"\"\"Check configuration file type is JSON\n    Return a boolean indicating wheather the file is JSON format or not\n    \"\"\"\n    try:\n        config_dict = load_config(filename, file_type = \"json\")\n        is_json = True\n    except:\n        is_json = False\n    return(is_json)", "code_tokens": "def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = \"json\" ) is_json = True except : is_json = False return ( is_json )", "docstring_tokens": "Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not", "label": 0}, {"idx": "cosqa-train-4087", "doc": "taking the log of an array in python", "code": "def to_distribution_values(self, values):\n        \"\"\"\n        Returns numpy array of natural logarithms of ``values``.\n        \"\"\"\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            # avoid RuntimeWarning: divide by zero encountered in log\n            return numpy.log(values)", "code_tokens": "def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( \"ignore\" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )", "docstring_tokens": "Returns numpy array of natural logarithms of values .", "label": 0}, {"idx": "cosqa-train-4088", "doc": "python check if instance of list", "code": "def is_listish(obj):\n    \"\"\"Check if something quacks like a list.\"\"\"\n    if isinstance(obj, (list, tuple, set)):\n        return True\n    return is_sequence(obj)", "code_tokens": "def is_listish ( obj ) : if isinstance ( obj , ( list , tuple , set ) ) : return True return is_sequence ( obj )", "docstring_tokens": "Check if something quacks like a list .", "label": 0}, {"idx": "cosqa-train-4089", "doc": "tensorflow python activation function attributes", "code": "def softplus(attrs, inputs, proto_obj):\n    \"\"\"Applies the sofplus activation function element-wise to the input.\"\"\"\n    new_attrs = translation_utils._add_extra_attributes(attrs, {'act_type' : 'softrelu'})\n    return 'Activation', new_attrs, inputs", "code_tokens": "def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs", "docstring_tokens": "Applies the sofplus activation function element - wise to the input .", "label": 0}, {"idx": "cosqa-train-4090", "doc": "python check if int timestamp", "code": "def is_timestamp(instance):\n    \"\"\"Validates data is a timestamp\"\"\"\n    if not isinstance(instance, (int, str)):\n        return True\n    return datetime.fromtimestamp(int(instance))", "code_tokens": "def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )", "docstring_tokens": "Validates data is a timestamp", "label": 0}, {"idx": "cosqa-train-4091", "doc": "test array dimension python", "code": "def get_dimension_array(array):\n    \"\"\"\n    Get dimension of an array getting the number of rows and the max num of\n    columns.\n    \"\"\"\n    if all(isinstance(el, list) for el in array):\n        result = [len(array), len(max([x for x in array], key=len,))]\n\n    # elif array and isinstance(array, list):\n    else:\n        result = [len(array), 1]\n\n    return result", "code_tokens": "def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result", "docstring_tokens": "Get dimension of an array getting the number of rows and the max num of columns .", "label": 0}, {"idx": "cosqa-train-4092", "doc": "python check if is date", "code": "def is_date(thing):\n    \"\"\"Checks if the given thing represents a date\n\n    :param thing: The object to check if it is a date\n    :type thing: arbitrary object\n    :returns: True if we have a date object\n    :rtype: bool\n    \"\"\"\n    # known date types\n    date_types = (datetime.datetime,\n                  datetime.date,\n                  DateTime)\n    return isinstance(thing, date_types)", "code_tokens": "def is_date ( thing ) : # known date types date_types = ( datetime . datetime , datetime . date , DateTime ) return isinstance ( thing , date_types )", "docstring_tokens": "Checks if the given thing represents a date", "label": 0}, {"idx": "cosqa-train-4093", "doc": "test for equality in python", "code": "def hard_equals(a, b):\n    \"\"\"Implements the '===' operator.\"\"\"\n    if type(a) != type(b):\n        return False\n    return a == b", "code_tokens": "def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b", "docstring_tokens": "Implements the === operator .", "label": 0}, {"idx": "cosqa-train-4094", "doc": "python check if line starts with comment", "code": "def _get_line_no_from_comments(py_line):\n    \"\"\"Return the line number parsed from the comment or 0.\"\"\"\n    matched = LINECOL_COMMENT_RE.match(py_line)\n    if matched:\n        return int(matched.group(1))\n    else:\n        return 0", "code_tokens": "def _get_line_no_from_comments ( py_line ) : matched = LINECOL_COMMENT_RE . match ( py_line ) if matched : return int ( matched . group ( 1 ) ) else : return 0", "docstring_tokens": "Return the line number parsed from the comment or 0 .", "label": 0}, {"idx": "cosqa-train-4095", "doc": "test if exist before using getattr python", "code": "def get_attr(self, method_name):\n        \"\"\"Get attribute from the target object\"\"\"\n        return self.attrs.get(method_name) or self.get_callable_attr(method_name)", "code_tokens": "def get_attr ( self , method_name ) : return self . attrs . get ( method_name ) or self . get_callable_attr ( method_name )", "docstring_tokens": "Get attribute from the target object", "label": 0}, {"idx": "cosqa-train-4096", "doc": "python check if list is all integers", "code": "def is_iterable_of_int(l):\n    r\"\"\" Checks if l is iterable and contains only integral types \"\"\"\n    if not is_iterable(l):\n        return False\n\n    return all(is_int(value) for value in l)", "code_tokens": "def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )", "docstring_tokens": "r Checks if l is iterable and contains only integral types", "label": 0}, {"idx": "cosqa-train-4097", "doc": "test if python object is iterable", "code": "def is_lazy_iterable(obj):\n    \"\"\"\n    Returns whether *obj* is iterable lazily, such as generators, range objects, etc.\n    \"\"\"\n    return isinstance(obj,\n        (types.GeneratorType, collections.MappingView, six.moves.range, enumerate))", "code_tokens": "def is_lazy_iterable ( obj ) : return isinstance ( obj , ( types . GeneratorType , collections . MappingView , six . moves . range , enumerate ) )", "docstring_tokens": "Returns whether * obj * is iterable lazily such as generators range objects etc .", "label": 1}, {"idx": "cosqa-train-4098", "doc": "python check if log handler enabled", "code": "def should_skip_logging(func):\n    \"\"\"\n    Should we skip logging for this handler?\n\n    \"\"\"\n    disabled = strtobool(request.headers.get(\"x-request-nolog\", \"false\"))\n    return disabled or getattr(func, SKIP_LOGGING, False)", "code_tokens": "def should_skip_logging ( func ) : disabled = strtobool ( request . headers . get ( \"x-request-nolog\" , \"false\" ) ) return disabled or getattr ( func , SKIP_LOGGING , False )", "docstring_tokens": "Should we skip logging for this handler?", "label": 0}, {"idx": "cosqa-train-4099", "doc": "test whether an object is an iterable type python", "code": "def is_iterable_but_not_string(obj):\n    \"\"\"\n    Determine whether or not obj is iterable but not a string (eg, a list, set, tuple etc).\n    \"\"\"\n    return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)", "code_tokens": "def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )", "docstring_tokens": "Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) .", "label": 0}, {"idx": "cosqa-train-4100", "doc": "python check if object is numpy array", "code": "def is_integer_array(val):\n    \"\"\"\n    Checks whether a variable is a numpy integer array.\n\n    Parameters\n    ----------\n    val\n        The variable to check.\n\n    Returns\n    -------\n    bool\n        True if the variable is a numpy integer array. Otherwise False.\n\n    \"\"\"\n    return is_np_array(val) and issubclass(val.dtype.type, np.integer)", "code_tokens": "def is_integer_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . integer )", "docstring_tokens": "Checks whether a variable is a numpy integer array .", "label": 0}, {"idx": "cosqa-train-4101", "doc": "the method is not allowed for the requested url python flask", "code": "def can_route(self, endpoint, method=None, **kwargs):\n        \"\"\"Make sure we can route to the given endpoint or url.\n\n        This checks for `http.get` permission (or other methods) on the ACL of\n        route functions, attached via the `ACL` decorator.\n\n        :param endpoint: A URL or endpoint to check for permission to access.\n        :param method: The HTTP method to check; defaults to `'GET'`.\n        :param **kwargs: The context to pass to predicates.\n\n        \"\"\"\n\n        view = flask.current_app.view_functions.get(endpoint)\n        if not view:\n            endpoint, args = flask._request_ctx.top.match(endpoint)\n            view = flask.current_app.view_functions.get(endpoint)\n        if not view:\n            return False\n\n        return self.can('http.' + (method or 'GET').lower(), view, **kwargs)", "code_tokens": "def can_route ( self , endpoint , method = None , * * kwargs ) : view = flask . current_app . view_functions . get ( endpoint ) if not view : endpoint , args = flask . _request_ctx . top . match ( endpoint ) view = flask . current_app . view_functions . get ( endpoint ) if not view : return False return self . can ( 'http.' + ( method or 'GET' ) . lower ( ) , view , * * kwargs )", "docstring_tokens": "Make sure we can route to the given endpoint or url .", "label": 0}, {"idx": "cosqa-train-4102", "doc": "python check if process exists by name", "code": "def pid_exists(pid):\n    \"\"\" Determines if a system process identifer exists in process table.\n        \"\"\"\n    try:\n        os.kill(pid, 0)\n    except OSError as exc:\n        return exc.errno == errno.EPERM\n    else:\n        return True", "code_tokens": "def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True", "docstring_tokens": "Determines if a system process identifer exists in process table .", "label": 0}, {"idx": "cosqa-train-4103", "doc": "the most counted python", "code": "def best(self):\n        \"\"\"\n        Returns the element with the highest probability.\n        \"\"\"\n        b = (-1e999999, None)\n        for k, c in iteritems(self.counts):\n            b = max(b, (c, k))\n        return b[1]", "code_tokens": "def best ( self ) : b = ( - 1e999999 , None ) for k , c in iteritems ( self . counts ) : b = max ( b , ( c , k ) ) return b [ 1 ]", "docstring_tokens": "Returns the element with the highest probability .", "label": 0}, {"idx": "cosqa-train-4104", "doc": "python check if the file type is is image", "code": "def is_image(filename):\n    \"\"\"Determine if given filename is an image.\"\"\"\n    # note: isfile() also accepts symlinks\n    return os.path.isfile(filename) and filename.lower().endswith(ImageExts)", "code_tokens": "def is_image ( filename ) : # note: isfile() also accepts symlinks return os . path . isfile ( filename ) and filename . lower ( ) . endswith ( ImageExts )", "docstring_tokens": "Determine if given filename is an image .", "label": 0}, {"idx": "cosqa-train-4105", "doc": "time hour minute format python", "code": "def format_time(time):\n    \"\"\" Formats the given time into HH:MM:SS \"\"\"\n    h, r = divmod(time / 1000, 3600)\n    m, s = divmod(r, 60)\n\n    return \"%02d:%02d:%02d\" % (h, m, s)", "code_tokens": "def format_time ( time ) : h , r = divmod ( time / 1000 , 3600 ) m , s = divmod ( r , 60 ) return \"%02d:%02d:%02d\" % ( h , m , s )", "docstring_tokens": "Formats the given time into HH : MM : SS", "label": 0}, {"idx": "cosqa-train-4106", "doc": "python check if usb device is located behind a hub", "code": "def kernelDriverActive(self, interface):\n        \"\"\"\n        Tell whether a kernel driver is active on given interface number.\n        \"\"\"\n        result = libusb1.libusb_kernel_driver_active(self.__handle, interface)\n        if result == 0:\n            return False\n        elif result == 1:\n            return True\n        raiseUSBError(result)", "code_tokens": "def kernelDriverActive ( self , interface ) : result = libusb1 . libusb_kernel_driver_active ( self . __handle , interface ) if result == 0 : return False elif result == 1 : return True raiseUSBError ( result )", "docstring_tokens": "Tell whether a kernel driver is active on given interface number .", "label": 0}, {"idx": "cosqa-train-4107", "doc": "timedelta get millisecond python", "code": "def timedelta2millisecond(td):\n    \"\"\"Get milliseconds from a timedelta.\"\"\"\n    milliseconds = td.days * 24 * 60 * 60 * 1000\n    milliseconds += td.seconds * 1000\n    milliseconds += td.microseconds / 1000\n    return milliseconds", "code_tokens": "def timedelta2millisecond ( td ) : milliseconds = td . days * 24 * 60 * 60 * 1000 milliseconds += td . seconds * 1000 milliseconds += td . microseconds / 1000 return milliseconds", "docstring_tokens": "Get milliseconds from a timedelta .", "label": 1}, {"idx": "cosqa-train-4108", "doc": "python check if val is float", "code": "def test_value(self, value):\n        \"\"\"Test if value is an instance of float.\"\"\"\n        if not isinstance(value, float):\n            raise ValueError('expected float value: ' + str(type(value)))", "code_tokens": "def test_value ( self , value ) : if not isinstance ( value , float ) : raise ValueError ( 'expected float value: ' + str ( type ( value ) ) )", "docstring_tokens": "Test if value is an instance of float .", "label": 0}, {"idx": "cosqa-train-4109", "doc": "timestamp in python data type casting", "code": "def dt_to_ts(value):\n    \"\"\" If value is a datetime, convert to timestamp \"\"\"\n    if not isinstance(value, datetime):\n        return value\n    return calendar.timegm(value.utctimetuple()) + value.microsecond / 1000000.0", "code_tokens": "def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0", "docstring_tokens": "If value is a datetime convert to timestamp", "label": 0}, {"idx": "cosqa-train-4110", "doc": "python check if value defined", "code": "def is_valid_variable_name(string_to_check):\n    \"\"\"\n    Returns whether the provided name is a valid variable name in Python\n\n    :param string_to_check: the string to be checked\n    :return: True or False\n    \"\"\"\n\n    try:\n\n        parse('{} = None'.format(string_to_check))\n        return True\n\n    except (SyntaxError, ValueError, TypeError):\n\n        return False", "code_tokens": "def is_valid_variable_name ( string_to_check ) : try : parse ( '{} = None' . format ( string_to_check ) ) return True except ( SyntaxError , ValueError , TypeError ) : return False", "docstring_tokens": "Returns whether the provided name is a valid variable name in Python", "label": 1}, {"idx": "cosqa-train-4111", "doc": "timing how long a function takes to complete in python", "code": "def speedtest(func, *args, **kwargs):\n    \"\"\" Test the speed of a function. \"\"\"\n    n = 100\n    start = time.time()\n    for i in range(n): func(*args,**kwargs)\n    end = time.time()\n    return (end-start)/n", "code_tokens": "def speedtest ( func , * args , * * kwargs ) : n = 100 start = time . time ( ) for i in range ( n ) : func ( * args , * * kwargs ) end = time . time ( ) return ( end - start ) / n", "docstring_tokens": "Test the speed of a function .", "label": 0}, {"idx": "cosqa-train-4112", "doc": "python check if variable is a numpy type", "code": "def is_integer_array(val):\n    \"\"\"\n    Checks whether a variable is a numpy integer array.\n\n    Parameters\n    ----------\n    val\n        The variable to check.\n\n    Returns\n    -------\n    bool\n        True if the variable is a numpy integer array. Otherwise False.\n\n    \"\"\"\n    return is_np_array(val) and issubclass(val.dtype.type, np.integer)", "code_tokens": "def is_integer_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . integer )", "docstring_tokens": "Checks whether a variable is a numpy integer array .", "label": 0}, {"idx": "cosqa-train-4113", "doc": "tkinter python flexible column width", "code": "def _column_resized(self, col, old_width, new_width):\n        \"\"\"Update the column width.\"\"\"\n        self.dataTable.setColumnWidth(col, new_width)\n        self._update_layout()", "code_tokens": "def _column_resized ( self , col , old_width , new_width ) : self . dataTable . setColumnWidth ( col , new_width ) self . _update_layout ( )", "docstring_tokens": "Update the column width .", "label": 0}, {"idx": "cosqa-train-4114", "doc": "python check if windows is activated", "code": "def inside_softimage():\n    \"\"\"Returns a boolean indicating if the code is executed inside softimage.\"\"\"\n    try:\n        import maya\n        return False\n    except ImportError:\n        pass\n    try:\n        from win32com.client import Dispatch as disp\n        disp('XSI.Application')\n        return True\n    except:\n        return False", "code_tokens": "def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False", "docstring_tokens": "Returns a boolean indicating if the code is executed inside softimage .", "label": 0}, {"idx": "cosqa-train-4115", "doc": "to check with datatype in python", "code": "def make_kind_check(python_types, numpy_kind):\n    \"\"\"\n    Make a function that checks whether a scalar or array is of a given kind\n    (e.g. float, int, datetime, timedelta).\n    \"\"\"\n    def check(value):\n        if hasattr(value, 'dtype'):\n            return value.dtype.kind == numpy_kind\n        return isinstance(value, python_types)\n    return check", "code_tokens": "def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check", "docstring_tokens": "Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) .", "label": 0}, {"idx": "cosqa-train-4116", "doc": "python check is buildin type", "code": "def is_builtin_type(tp):\n    \"\"\"Checks if the given type is a builtin one.\n    \"\"\"\n    return hasattr(__builtins__, tp.__name__) and tp is getattr(__builtins__, tp.__name__)", "code_tokens": "def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )", "docstring_tokens": "Checks if the given type is a builtin one .", "label": 0}, {"idx": "cosqa-train-4117", "doc": "to get distinct elements in the list python", "code": "def distinct(xs):\n    \"\"\"Get the list of distinct values with preserving order.\"\"\"\n    # don't use collections.OrderedDict because we do support Python 2.6\n    seen = set()\n    return [x for x in xs if x not in seen and not seen.add(x)]", "code_tokens": "def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]", "docstring_tokens": "Get the list of distinct values with preserving order .", "label": 0}, {"idx": "cosqa-train-4118", "doc": "transform a table into python data frame", "code": "def from_df(data_frame):\n        \"\"\"Parses data and builds an instance of this class\n\n        :param data_frame: pandas DataFrame\n        :return: SqlTable\n        \"\"\"\n        labels = data_frame.keys().tolist()\n        data = data_frame.values.tolist()\n        return SqlTable(labels, data, \"{:.3f}\", \"\\n\")", "code_tokens": "def from_df ( data_frame ) : labels = data_frame . keys ( ) . tolist ( ) data = data_frame . values . tolist ( ) return SqlTable ( labels , data , \"{:.3f}\" , \"\\n\" )", "docstring_tokens": "Parses data and builds an instance of this class", "label": 0}, {"idx": "cosqa-train-4119", "doc": "python check len of value", "code": "def check_length(value, length):\n    \"\"\"\n    Checks length of value\n\n    @param value: value to check\n    @type value: C{str}\n\n    @param length: length checking for\n    @type length: C{int}\n\n    @return: None when check successful\n\n    @raise ValueError: check failed\n    \"\"\"\n    _length = len(value)\n    if _length != length:\n        raise ValueError(\"length must be %d, not %d\" % \\\n                         (length, _length))", "code_tokens": "def check_length ( value , length ) : _length = len ( value ) if _length != length : raise ValueError ( \"length must be %d, not %d\" % ( length , _length ) )", "docstring_tokens": "Checks length of value", "label": 0}, {"idx": "cosqa-train-4120", "doc": "transpose 3d matrix python", "code": "def transpose(table):\n    \"\"\"\n    transpose matrix\n    \"\"\"\n    t = []\n    for i in range(0, len(table[0])):\n        t.append([row[i] for row in table])\n    return t", "code_tokens": "def transpose ( table ) : t = [ ] for i in range ( 0 , len ( table [ 0 ] ) ) : t . append ( [ row [ i ] for row in table ] ) return t", "docstring_tokens": "transpose matrix", "label": 0}, {"idx": "cosqa-train-4121", "doc": "python check lowercase key in a dict", "code": "def __contains__ (self, key):\n        \"\"\"Check lowercase key item.\"\"\"\n        assert isinstance(key, basestring)\n        return dict.__contains__(self, key.lower())", "code_tokens": "def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "docstring_tokens": "Check lowercase key item .", "label": 0}, {"idx": "cosqa-train-4122", "doc": "truncate multiple tables at once python", "code": "def truncate(self, table):\n        \"\"\"Empty a table by deleting all of its rows.\"\"\"\n        if isinstance(table, (list, set, tuple)):\n            for t in table:\n                self._truncate(t)\n        else:\n            self._truncate(table)", "code_tokens": "def truncate ( self , table ) : if isinstance ( table , ( list , set , tuple ) ) : for t in table : self . _truncate ( t ) else : self . _truncate ( table )", "docstring_tokens": "Empty a table by deleting all of its rows .", "label": 0}, {"idx": "cosqa-train-4123", "doc": "python check rsa private key and public key match", "code": "def rsa_eq(key1, key2):\n    \"\"\"\n    Only works for RSAPublic Keys\n\n    :param key1:\n    :param key2:\n    :return:\n    \"\"\"\n    pn1 = key1.public_numbers()\n    pn2 = key2.public_numbers()\n    # Check if two RSA keys are in fact the same\n    if pn1 == pn2:\n        return True\n    else:\n        return False", "code_tokens": "def rsa_eq ( key1 , key2 ) : pn1 = key1 . public_numbers ( ) pn2 = key2 . public_numbers ( ) # Check if two RSA keys are in fact the same if pn1 == pn2 : return True else : return False", "docstring_tokens": "Only works for RSAPublic Keys", "label": 0}, {"idx": "cosqa-train-4124", "doc": "trunkcate string at token python", "code": "def tokenize(string):\n    \"\"\"Match and yield all the tokens of the input string.\"\"\"\n    for match in TOKENS_REGEX.finditer(string):\n        yield Token(match.lastgroup, match.group().strip(), match.span())", "code_tokens": "def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "docstring_tokens": "Match and yield all the tokens of the input string .", "label": 0}, {"idx": "cosqa-train-4125", "doc": "python check status code belong to 200", "code": "def raise_for_not_ok_status(response):\n    \"\"\"\n    Raises a `requests.exceptions.HTTPError` if the response has a non-200\n    status code.\n    \"\"\"\n    if response.code != OK:\n        raise HTTPError('Non-200 response code (%s) for url: %s' % (\n            response.code, uridecode(response.request.absoluteURI)))\n\n    return response", "code_tokens": "def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response", "docstring_tokens": "Raises a requests . exceptions . HTTPError if the response has a non - 200 status code .", "label": 0}, {"idx": "cosqa-train-4126", "doc": "tunnel request through a proxy requests python", "code": "def dispatch(self, request, *args, **kwargs):\n        \"\"\"Dispatch all HTTP methods to the proxy.\"\"\"\n        self.request = DownstreamRequest(request)\n        self.args = args\n        self.kwargs = kwargs\n\n        self._verify_config()\n\n        self.middleware = MiddlewareSet(self.proxy_middleware)\n\n        return self.proxy()", "code_tokens": "def dispatch ( self , request , * args , * * kwargs ) : self . request = DownstreamRequest ( request ) self . args = args self . kwargs = kwargs self . _verify_config ( ) self . middleware = MiddlewareSet ( self . proxy_middleware ) return self . proxy ( )", "docstring_tokens": "Dispatch all HTTP methods to the proxy .", "label": 1}, {"idx": "cosqa-train-4127", "doc": "python check to see if all list items are unique", "code": "def unique(input_list):\n    \"\"\"\n    Return a list of unique items (similar to set functionality).\n\n    Parameters\n    ----------\n    input_list : list\n        A list containg some items that can occur more than once.\n\n    Returns\n    -------\n    list\n        A list with only unique occurances of an item.\n\n    \"\"\"\n    output = []\n    for item in input_list:\n        if item not in output:\n            output.append(item)\n    return output", "code_tokens": "def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output", "docstring_tokens": "Return a list of unique items ( similar to set functionality ) .", "label": 0}, {"idx": "cosqa-train-4128", "doc": "turn all keys in dictionary to lowercase python", "code": "def keys_to_snake_case(camel_case_dict):\n    \"\"\"\n    Make a copy of a dictionary with all keys converted to snake case. This is just calls to_snake_case on\n    each of the keys in the dictionary and returns a new dictionary.\n\n    :param camel_case_dict: Dictionary with the keys to convert.\n    :type camel_case_dict: Dictionary.\n\n    :return: Dictionary with the keys converted to snake case.\n    \"\"\"\n    return dict((to_snake_case(key), value) for (key, value) in camel_case_dict.items())", "code_tokens": "def keys_to_snake_case ( camel_case_dict ) : return dict ( ( to_snake_case ( key ) , value ) for ( key , value ) in camel_case_dict . items ( ) )", "docstring_tokens": "Make a copy of a dictionary with all keys converted to snake case . This is just calls to_snake_case on each of the keys in the dictionary and returns a new dictionary .", "label": 0}, {"idx": "cosqa-train-4129", "doc": "python check to see if it is running as administrator", "code": "def is_admin(self):\n        \"\"\"Is the user a system administrator\"\"\"\n        return self.role == self.roles.administrator.value and self.state == State.approved", "code_tokens": "def is_admin ( self ) : return self . role == self . roles . administrator . value and self . state == State . approved", "docstring_tokens": "Is the user a system administrator", "label": 0}, {"idx": "cosqa-train-4130", "doc": "turn boolean array into 1,0 python", "code": "def abs_img(img):\n    \"\"\" Return an image with the binarised version of the data of `img`.\"\"\"\n    bool_img = np.abs(read_img(img).get_data())\n    return bool_img.astype(int)", "code_tokens": "def abs_img ( img ) : bool_img = np . abs ( read_img ( img ) . get_data ( ) ) return bool_img . astype ( int )", "docstring_tokens": "Return an image with the binarised version of the data of img .", "label": 0}, {"idx": "cosqa-train-4131", "doc": "python check varible type", "code": "def is_timestamp(obj):\n    \"\"\"\n    Yaml either have automatically converted it to a datetime object\n    or it is a string that will be validated later.\n    \"\"\"\n    return isinstance(obj, datetime.datetime) or is_string(obj) or is_int(obj) or is_float(obj)", "code_tokens": "def is_timestamp ( obj ) : return isinstance ( obj , datetime . datetime ) or is_string ( obj ) or is_int ( obj ) or is_float ( obj )", "docstring_tokens": "Yaml either have automatically converted it to a datetime object or it is a string that will be validated later .", "label": 0}, {"idx": "cosqa-train-4132", "doc": "turn list of string into dictionary python function", "code": "def str_dict(some_dict):\n    \"\"\"Convert dict of ascii str/unicode to dict of str, if necessary\"\"\"\n    return {str(k): str(v) for k, v in some_dict.items()}", "code_tokens": "def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }", "docstring_tokens": "Convert dict of ascii str / unicode to dict of str if necessary", "label": 0}, {"idx": "cosqa-train-4133", "doc": "python checking for string or number", "code": "def type_converter(text):\n    \"\"\" I convert strings into integers, floats, and strings! \"\"\"\n    if text.isdigit():\n        return int(text), int\n\n    try:\n        return float(text), float\n    except ValueError:\n        return text, STRING_TYPE", "code_tokens": "def type_converter ( text ) : if text . isdigit ( ) : return int ( text ) , int try : return float ( text ) , float except ValueError : return text , STRING_TYPE", "docstring_tokens": "I convert strings into integers floats and strings!", "label": 1}, {"idx": "cosqa-train-4134", "doc": "turn matrix into a list python", "code": "def to_list(self):\n        \"\"\"Convert this confusion matrix into a 2x2 plain list of values.\"\"\"\n        return [[int(self.table.cell_values[0][1]), int(self.table.cell_values[0][2])],\n                [int(self.table.cell_values[1][1]), int(self.table.cell_values[1][2])]]", "code_tokens": "def to_list ( self ) : return [ [ int ( self . table . cell_values [ 0 ] [ 1 ] ) , int ( self . table . cell_values [ 0 ] [ 2 ] ) ] , [ int ( self . table . cell_values [ 1 ] [ 1 ] ) , int ( self . table . cell_values [ 1 ] [ 2 ] ) ] ]", "docstring_tokens": "Convert this confusion matrix into a 2x2 plain list of values .", "label": 0}, {"idx": "cosqa-train-4135", "doc": "python checking if a number is complex", "code": "def is_complex(dtype):\n  \"\"\"Returns whether this is a complex floating point type.\"\"\"\n  dtype = tf.as_dtype(dtype)\n  if hasattr(dtype, 'is_complex'):\n    return dtype.is_complex\n  return np.issubdtype(np.dtype(dtype), np.complex)", "code_tokens": "def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )", "docstring_tokens": "Returns whether this is a complex floating point type .", "label": 0}, {"idx": "cosqa-train-4136", "doc": "turnoff python post mortem", "code": "def stop_capture(self):\n        \"\"\"Stop listening for output from the stenotype machine.\"\"\"\n        super(Treal, self).stop_capture()\n        if self._machine:\n            self._machine.close()\n        self._stopped()", "code_tokens": "def stop_capture ( self ) : super ( Treal , self ) . stop_capture ( ) if self . _machine : self . _machine . close ( ) self . _stopped ( )", "docstring_tokens": "Stop listening for output from the stenotype machine .", "label": 0}, {"idx": "cosqa-train-4137", "doc": "python checking if a sql table record exist", "code": "def _tableExists(self, tableName):\n        cursor=_conn.execute(\"\"\"\n            SELECT * FROM sqlite_master WHERE name ='{0}' and type='table';\n        \"\"\".format(tableName))\n        exists = cursor.fetchone() is not None\n        cursor.close()\n        return exists", "code_tokens": "def _tableExists ( self , tableName ) : cursor = _conn . execute ( \"\"\"\n            SELECT * FROM sqlite_master WHERE name ='{0}' and type='table';\n        \"\"\" . format ( tableName ) ) exists = cursor . fetchone ( ) is not None cursor . close ( ) return exists", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-4138", "doc": "twitter api get users statuses python", "code": "def search_for_tweets_about(user_id, params):\n    \"\"\" Search twitter API \"\"\"\n    url = \"https://api.twitter.com/1.1/search/tweets.json\"\n    response = make_twitter_request(url, user_id, params)\n    return process_tweets(response.json()[\"statuses\"])", "code_tokens": "def search_for_tweets_about ( user_id , params ) : url = \"https://api.twitter.com/1.1/search/tweets.json\" response = make_twitter_request ( url , user_id , params ) return process_tweets ( response . json ( ) [ \"statuses\" ] )", "docstring_tokens": "Search twitter API", "label": 0}, {"idx": "cosqa-train-4139", "doc": "python checking if file is an image", "code": "def is_image(filename):\n    \"\"\"Determine if given filename is an image.\"\"\"\n    # note: isfile() also accepts symlinks\n    return os.path.isfile(filename) and filename.lower().endswith(ImageExts)", "code_tokens": "def is_image ( filename ) : # note: isfile() also accepts symlinks return os . path . isfile ( filename ) and filename . lower ( ) . endswith ( ImageExts )", "docstring_tokens": "Determine if given filename is an image .", "label": 0}, {"idx": "cosqa-train-4140", "doc": "typecast elemts in a list python", "code": "def coerce(self, value):\n        \"\"\"Convert from whatever is given to a list of scalars for the lookup_field.\"\"\"\n        if isinstance(value, dict):\n            value = [value]\n        if not isiterable_notstring(value):\n            value = [value]\n        return [coerce_single_instance(self.lookup_field, v) for v in value]", "code_tokens": "def coerce ( self , value ) : if isinstance ( value , dict ) : value = [ value ] if not isiterable_notstring ( value ) : value = [ value ] return [ coerce_single_instance ( self . lookup_field , v ) for v in value ]", "docstring_tokens": "Convert from whatever is given to a list of scalars for the lookup_field .", "label": 0}, {"idx": "cosqa-train-4141", "doc": "python chmod not working in windows", "code": "def chmod_plus_w(path):\n  \"\"\"Equivalent of unix `chmod +w path`\"\"\"\n  path_mode = os.stat(path).st_mode\n  path_mode &= int('777', 8)\n  path_mode |= stat.S_IWRITE\n  os.chmod(path, path_mode)", "code_tokens": "def chmod_plus_w ( path ) : path_mode = os . stat ( path ) . st_mode path_mode &= int ( '777' , 8 ) path_mode |= stat . S_IWRITE os . chmod ( path , path_mode )", "docstring_tokens": "Equivalent of unix chmod + w path", "label": 0}, {"idx": "cosqa-train-4142", "doc": "ubuntu font list python", "code": "def get_font_list():\n    \"\"\"Returns a sorted list of all system font names\"\"\"\n\n    font_map = pangocairo.cairo_font_map_get_default()\n    font_list = [f.get_name() for f in font_map.list_families()]\n    font_list.sort()\n\n    return font_list", "code_tokens": "def get_font_list ( ) : font_map = pangocairo . cairo_font_map_get_default ( ) font_list = [ f . get_name ( ) for f in font_map . list_families ( ) ] font_list . sort ( ) return font_list", "docstring_tokens": "Returns a sorted list of all system font names", "label": 0}, {"idx": "cosqa-train-4143", "doc": "python choose folder tkinter", "code": "def on_source_directory_chooser_clicked(self):\n        \"\"\"Autoconnect slot activated when tbSourceDir is clicked.\"\"\"\n\n        title = self.tr('Set the source directory for script and scenario')\n        self.choose_directory(self.source_directory, title)", "code_tokens": "def on_source_directory_chooser_clicked ( self ) : title = self . tr ( 'Set the source directory for script and scenario' ) self . choose_directory ( self . source_directory , title )", "docstring_tokens": "Autoconnect slot activated when tbSourceDir is clicked .", "label": 0}, {"idx": "cosqa-train-4144", "doc": "python chunk iterator itertools", "code": "def chunks(iterable, chunk):\n    \"\"\"Yield successive n-sized chunks from an iterable.\"\"\"\n    for i in range(0, len(iterable), chunk):\n        yield iterable[i:i + chunk]", "code_tokens": "def chunks ( iterable , chunk ) : for i in range ( 0 , len ( iterable ) , chunk ) : yield iterable [ i : i + chunk ]", "docstring_tokens": "Yield successive n - sized chunks from an iterable .", "label": 0}, {"idx": "cosqa-train-4145", "doc": "unhasable type list in python to replace with a hashable list", "code": "def dedupe_list(l):\n    \"\"\"Remove duplicates from a list preserving the order.\n\n    We might be tempted to use the list(set(l)) idiom, but it doesn't preserve\n    the order, which hinders testability and does not work for lists with\n    unhashable elements.\n    \"\"\"\n    result = []\n\n    for el in l:\n        if el not in result:\n            result.append(el)\n\n    return result", "code_tokens": "def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result", "docstring_tokens": "Remove duplicates from a list preserving the order .", "label": 1}, {"idx": "cosqa-train-4146", "doc": "python clear memory cache for loop", "code": "def invalidate_cache(cpu, address, size):\n        \"\"\" remove decoded instruction from instruction cache \"\"\"\n        cache = cpu.instruction_cache\n        for offset in range(size):\n            if address + offset in cache:\n                del cache[address + offset]", "code_tokens": "def invalidate_cache ( cpu , address , size ) : cache = cpu . instruction_cache for offset in range ( size ) : if address + offset in cache : del cache [ address + offset ]", "docstring_tokens": "remove decoded instruction from instruction cache", "label": 0}, {"idx": "cosqa-train-4147", "doc": "unique permutations algorithm of string in python", "code": "def make_unique_ngrams(s, n):\n    \"\"\"Make a set of unique n-grams from a string.\"\"\"\n    return set(s[i:i + n] for i in range(len(s) - n + 1))", "code_tokens": "def make_unique_ngrams ( s , n ) : return set ( s [ i : i + n ] for i in range ( len ( s ) - n + 1 ) )", "docstring_tokens": "Make a set of unique n - grams from a string .", "label": 0}, {"idx": "cosqa-train-4148", "doc": "python clear to show progress", "code": "def finished(self):\n        \"\"\"\n        Must be called to print final progress label.\n        \"\"\"\n        self.progress_bar.set_state(ProgressBar.STATE_DONE)\n        self.progress_bar.show()", "code_tokens": "def finished ( self ) : self . progress_bar . set_state ( ProgressBar . STATE_DONE ) self . progress_bar . show ( )", "docstring_tokens": "Must be called to print final progress label .", "label": 0}, {"idx": "cosqa-train-4149", "doc": "unique values of columns with frequencies python andas", "code": "def get_unique_indices(df, axis=1):\n    \"\"\"\n\n    :param df:\n    :param axis:\n    :return:\n    \"\"\"\n    return dict(zip(df.columns.names, dif.columns.levels))", "code_tokens": "def get_unique_indices ( df , axis = 1 ) : return dict ( zip ( df . columns . names , dif . columns . levels ) )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-4150", "doc": "python clear variables at start of code", "code": "def clear_globals_reload_modules(self):\n        \"\"\"Clears globals and reloads modules\"\"\"\n\n        self.code_array.clear_globals()\n        self.code_array.reload_modules()\n\n        # Clear result cache\n        self.code_array.result_cache.clear()", "code_tokens": "def clear_globals_reload_modules ( self ) : self . code_array . clear_globals ( ) self . code_array . reload_modules ( ) # Clear result cache self . code_array . result_cache . clear ( )", "docstring_tokens": "Clears globals and reloads modules", "label": 0}, {"idx": "cosqa-train-4151", "doc": "uniquify 2d list python", "code": "def uniquify_list(L):\n    \"\"\"Same order unique list using only a list compression.\"\"\"\n    return [e for i, e in enumerate(L) if L.index(e) == i]", "code_tokens": "def uniquify_list ( L ) : return [ e for i , e in enumerate ( L ) if L . index ( e ) == i ]", "docstring_tokens": "Same order unique list using only a list compression .", "label": 0}, {"idx": "cosqa-train-4152", "doc": "python close shutdown socket", "code": "def stop(self, dummy_signum=None, dummy_frame=None):\n        \"\"\" Shutdown process (this method is also a signal handler) \"\"\"\n        logging.info('Shutting down ...')\n        self.socket.close()\n        sys.exit(0)", "code_tokens": "def stop ( self , dummy_signum = None , dummy_frame = None ) : logging . info ( 'Shutting down ...' ) self . socket . close ( ) sys . exit ( 0 )", "docstring_tokens": "Shutdown process ( this method is also a signal handler )", "label": 0}, {"idx": "cosqa-train-4153", "doc": "unpack all tuples python", "code": "def compose_all(tups):\n  \"\"\"Compose all given tuples together.\"\"\"\n  from . import ast  # I weep for humanity\n  return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))", "code_tokens": "def compose_all ( tups ) : from . import ast # I weep for humanity return functools . reduce ( lambda x , y : x . compose ( y ) , map ( ast . make_tuple , tups ) , ast . make_tuple ( { } ) )", "docstring_tokens": "Compose all given tuples together .", "label": 0}, {"idx": "cosqa-train-4154", "doc": "python close task manager", "code": "def shutdown():\n    \"\"\"Manually shutdown the async API.\n\n    Cancels all related tasks and all the socket transportation.\n    \"\"\"\n    global handler, transport, protocol\n    if handler is not None:\n        handler.close()\n        transport.close()\n        handler = None\n        transport = None\n        protocol = None", "code_tokens": "def shutdown ( ) : global handler , transport , protocol if handler is not None : handler . close ( ) transport . close ( ) handler = None transport = None protocol = None", "docstring_tokens": "Manually shutdown the async API .", "label": 0}, {"idx": "cosqa-train-4155", "doc": "unstring a python array", "code": "def convert_array(array):\n    \"\"\"\n    Converts an ARRAY string stored in the database back into a Numpy array.\n\n    Parameters\n    ----------\n    array: ARRAY\n        The array object to be converted back into a Numpy array.\n\n    Returns\n    -------\n    array\n            The converted Numpy array.\n\n    \"\"\"\n    out = io.BytesIO(array)\n    out.seek(0)\n    return np.load(out)", "code_tokens": "def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )", "docstring_tokens": "Converts an ARRAY string stored in the database back into a Numpy array .", "label": 1}, {"idx": "cosqa-train-4156", "doc": "python cmp overload for objects", "code": "def __cmp__(self, other):\n        \"\"\"Comparsion not implemented.\"\"\"\n        # Stops python 2 from allowing comparsion of arbitrary objects\n        raise TypeError('unorderable types: {}, {}'\n                        ''.format(self.__class__.__name__, type(other)))", "code_tokens": "def __cmp__ ( self , other ) : # Stops python 2 from allowing comparsion of arbitrary objects raise TypeError ( 'unorderable types: {}, {}' '' . format ( self . __class__ . __name__ , type ( other ) ) )", "docstring_tokens": "Comparsion not implemented .", "label": 0}, {"idx": "cosqa-train-4157", "doc": "unsupported media type json python", "code": "def parse(self, data, mimetype):\n        \"\"\"\n        Parses a byte array containing a JSON document and returns a Python object.\n        :param data: The byte array containing a JSON document.\n        :param MimeType mimetype: The mimetype chose to parse the data.\n        :return: A Python object.\n        \"\"\"\n        encoding = mimetype.params.get('charset') or 'utf-8'\n\n        return json.loads(data.decode(encoding))", "code_tokens": "def parse ( self , data , mimetype ) : encoding = mimetype . params . get ( 'charset' ) or 'utf-8' return json . loads ( data . decode ( encoding ) )", "docstring_tokens": "Parses a byte array containing a JSON document and returns a Python object . : param data : The byte array containing a JSON document . : param MimeType mimetype : The mimetype chose to parse the data . : return : A Python object .", "label": 1}, {"idx": "cosqa-train-4158", "doc": "python code for checking extension of file uploaded by user", "code": "def is_valid_image_extension(file_path):\n    \"\"\"is_valid_image_extension.\"\"\"\n    valid_extensions = ['.jpeg', '.jpg', '.gif', '.png']\n    _, extension = os.path.splitext(file_path)\n    return extension.lower() in valid_extensions", "code_tokens": "def is_valid_image_extension ( file_path ) : valid_extensions = [ '.jpeg' , '.jpg' , '.gif' , '.png' ] _ , extension = os . path . splitext ( file_path ) return extension . lower ( ) in valid_extensions", "docstring_tokens": "is_valid_image_extension .", "label": 0}, {"idx": "cosqa-train-4159", "doc": "unzip file using url python", "code": "def install_from_zip(url):\n    \"\"\"Download and unzip from url.\"\"\"\n    fname = 'tmp.zip'\n    downlad_file(url, fname)\n    unzip_file(fname)\n    print(\"Removing {}\".format(fname))\n    os.unlink(fname)", "code_tokens": "def install_from_zip ( url ) : fname = 'tmp.zip' downlad_file ( url , fname ) unzip_file ( fname ) print ( \"Removing {}\" . format ( fname ) ) os . unlink ( fname )", "docstring_tokens": "Download and unzip from url .", "label": 0}, {"idx": "cosqa-train-4160", "doc": "python code the distance between two points points of lat and lon", "code": "def Distance(lat1, lon1, lat2, lon2):\n    \"\"\"Get distance between pairs of lat-lon points\"\"\"\n\n    az12, az21, dist = wgs84_geod.inv(lon1, lat1, lon2, lat2)\n    return az21, dist", "code_tokens": "def Distance ( lat1 , lon1 , lat2 , lon2 ) : az12 , az21 , dist = wgs84_geod . inv ( lon1 , lat1 , lon2 , lat2 ) return az21 , dist", "docstring_tokens": "Get distance between pairs of lat - lon points", "label": 0}, {"idx": "cosqa-train-4161", "doc": "update cancekked halfway and spyder python not loading", "code": "def restart(self, reset=False):\n        \"\"\"\n        Quit and Restart Spyder application.\n\n        If reset True it allows to reset spyder on restart.\n        \"\"\"\n        # Get start path to use in restart script\n        spyder_start_directory = get_module_path('spyder')\n        restart_script = osp.join(spyder_start_directory, 'app', 'restart.py')\n\n        # Get any initial argument passed when spyder was started\n        # Note: Variables defined in bootstrap.py and spyder/app/start.py\n        env = os.environ.copy()\n        bootstrap_args = env.pop('SPYDER_BOOTSTRAP_ARGS', None)\n        spyder_args = env.pop('SPYDER_ARGS')\n\n        # Get current process and python running spyder\n        pid = os.getpid()\n        python = sys.executable\n\n        # Check if started with bootstrap.py\n        if bootstrap_args is not None:\n            spyder_args = bootstrap_args\n            is_bootstrap = True\n        else:\n            is_bootstrap = False\n\n        # Pass variables as environment variables (str) to restarter subprocess\n        env['SPYDER_ARGS'] = spyder_args\n        env['SPYDER_PID'] = str(pid)\n        env['SPYDER_IS_BOOTSTRAP'] = str(is_bootstrap)\n        env['SPYDER_RESET'] = str(reset)\n\n        if DEV:\n            if os.name == 'nt':\n                env['PYTHONPATH'] = ';'.join(sys.path)\n            else:\n                env['PYTHONPATH'] = ':'.join(sys.path)\n\n        # Build the command and popen arguments depending on the OS\n        if os.name == 'nt':\n            # Hide flashing command prompt\n            startupinfo = subprocess.STARTUPINFO()\n            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n            shell = False\n        else:\n            startupinfo = None\n            shell = True\n\n        command = '\"{0}\" \"{1}\"'\n        command = command.format(python, restart_script)\n\n        try:\n            if self.closing(True):\n                subprocess.Popen(command, shell=shell, env=env,\n                                 startupinfo=startupinfo)\n                self.console.quit()\n        except Exception as error:\n            # If there is an error with subprocess, Spyder should not quit and\n            # the error can be inspected in the internal console\n            print(error)  # spyder: test-skip\n            print(command)", "code_tokens": "def restart ( self , reset = False ) : # Get start path to use in restart script\n spyder_start_directory = get_module_path ( 'spyder' ) restart_script = osp . join ( spyder_start_directory , 'app' , 'restart.py' ) # Get any initial argument passed when spyder was started\n # Note: Variables defined in bootstrap.py and spyder/app/start.py\n env = os . environ . copy ( ) bootstrap_args = env . pop ( 'SPYDER_BOOTSTRAP_ARGS' , None ) spyder_args = env . pop ( 'SPYDER_ARGS' ) # Get current process and python running spyder\n pid = os . getpid ( ) python = sys . executable # Check if started with bootstrap.py\n if bootstrap_args is not None : spyder_args = bootstrap_args is_bootstrap = True else : is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess\n env [ 'SPYDER_ARGS' ] = spyder_args env [ 'SPYDER_PID' ] = str ( pid ) env [ 'SPYDER_IS_BOOTSTRAP' ] = str ( is_bootstrap ) env [ 'SPYDER_RESET' ] = str ( reset ) if DEV : if os . name == 'nt' : env [ 'PYTHONPATH' ] = ';' . join ( sys . path ) else : env [ 'PYTHONPATH' ] = ':' . join ( sys . path ) # Build the command and popen arguments depending on the OS\n if os . name == 'nt' : # Hide flashing command prompt\n startupinfo = subprocess . STARTUPINFO ( ) startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW shell = False else : startupinfo = None shell = True command = '\"{0}\" \"{1}\"' command = command . format ( python , restart_script ) try : if self . closing ( True ) : subprocess . Popen ( command , shell = shell , env = env , startupinfo = startupinfo ) self . console . quit ( ) except Exception as error : # If there is an error with subprocess, Spyder should not quit and\n # the error can be inspected in the internal console\n print ( error ) # spyder: test-skip\n print ( command )", "docstring_tokens": "Quit and Restart Spyder application . If reset True it allows to reset spyder on restart .", "label": 1}, {"idx": "cosqa-train-4162", "doc": "python code to connect to cloudant db", "code": "def get_conn(self):\n        \"\"\"\n        Opens a connection to the cloudant service and closes it automatically if used as context manager.\n\n        .. note::\n            In the connection form:\n            - 'host' equals the 'Account' (optional)\n            - 'login' equals the 'Username (or API Key)' (required)\n            - 'password' equals the 'Password' (required)\n\n        :return: an authorized cloudant session context manager object.\n        :rtype: cloudant\n        \"\"\"\n        conn = self.get_connection(self.cloudant_conn_id)\n\n        self._validate_connection(conn)\n\n        cloudant_session = cloudant(user=conn.login, passwd=conn.password, account=conn.host)\n\n        return cloudant_session", "code_tokens": "def get_conn ( self ) : conn = self . get_connection ( self . cloudant_conn_id ) self . _validate_connection ( conn ) cloudant_session = cloudant ( user = conn . login , passwd = conn . password , account = conn . host ) return cloudant_session", "docstring_tokens": "Opens a connection to the cloudant service and closes it automatically if used as context manager .", "label": 0}, {"idx": "cosqa-train-4163", "doc": "update element on the heap heapq python", "code": "def push(self, el):\n        \"\"\" Put a new element in the queue. \"\"\"\n        count = next(self.counter)\n        heapq.heappush(self._queue, (el, count))", "code_tokens": "def push ( self , el ) : count = next ( self . counter ) heapq . heappush ( self . _queue , ( el , count ) )", "docstring_tokens": "Put a new element in the queue .", "label": 0}, {"idx": "cosqa-train-4164", "doc": "python code to replace particular string in the existing file each line", "code": "def replace_all(filepath, searchExp, replaceExp):\n    \"\"\"\n    Replace all the ocurrences (in a file) of a string with another value.\n    \"\"\"\n    for line in fileinput.input(filepath, inplace=1):\n        if searchExp in line:\n            line = line.replace(searchExp, replaceExp)\n        sys.stdout.write(line)", "code_tokens": "def replace_all ( filepath , searchExp , replaceExp ) : for line in fileinput . input ( filepath , inplace = 1 ) : if searchExp in line : line = line . replace ( searchExp , replaceExp ) sys . stdout . write ( line )", "docstring_tokens": "Replace all the ocurrences ( in a file ) of a string with another value .", "label": 1}, {"idx": "cosqa-train-4165", "doc": "update progress bar python tkinter", "code": "def update_target(self, name, current, total):\n        \"\"\"Updates progress bar for a specified target.\"\"\"\n        self.refresh(self._bar(name, current, total))", "code_tokens": "def update_target ( self , name , current , total ) : self . refresh ( self . _bar ( name , current , total ) )", "docstring_tokens": "Updates progress bar for a specified target .", "label": 0}, {"idx": "cosqa-train-4166", "doc": "python code to validate mac address", "code": "def is_valid_ipv6(ip_str):\n    \"\"\"\n    Check the validity of an IPv6 address\n    \"\"\"\n    try:\n        socket.inet_pton(socket.AF_INET6, ip_str)\n    except socket.error:\n        return False\n    return True", "code_tokens": "def is_valid_ipv6 ( ip_str ) : try : socket . inet_pton ( socket . AF_INET6 , ip_str ) except socket . error : return False return True", "docstring_tokens": "Check the validity of an IPv6 address", "label": 0}, {"idx": "cosqa-train-4167", "doc": "python column top 5", "code": "def table_top_abs(self):\n        \"\"\"Returns the absolute position of table top\"\"\"\n        table_height = np.array([0, 0, self.table_full_size[2]])\n        return string_to_array(self.floor.get(\"pos\")) + table_height", "code_tokens": "def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( \"pos\" ) ) + table_height", "docstring_tokens": "Returns the absolute position of table top", "label": 0}, {"idx": "cosqa-train-4168", "doc": "use latex in python squared", "code": "def print_display_png(o):\n    \"\"\"\n    A function to display sympy expression using display style LaTeX in PNG.\n    \"\"\"\n    s = latex(o, mode='plain')\n    s = s.strip('$')\n    # As matplotlib does not support display style, dvipng backend is\n    # used here.\n    png = latex_to_png('$$%s$$' % s, backend='dvipng')\n    return png", "code_tokens": "def print_display_png ( o ) : s = latex ( o , mode = 'plain' ) s = s . strip ( '$' ) # As matplotlib does not support display style, dvipng backend is # used here. png = latex_to_png ( '$$%s$$' % s , backend = 'dvipng' ) return png", "docstring_tokens": "A function to display sympy expression using display style LaTeX in PNG .", "label": 0}, {"idx": "cosqa-train-4169", "doc": "python comma delineated string to list", "code": "def _str_to_list(s):\n    \"\"\"Converts a comma separated string to a list\"\"\"\n    _list = s.split(\",\")\n    return list(map(lambda i: i.lstrip(), _list))", "code_tokens": "def _str_to_list ( s ) : _list = s . split ( \",\" ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )", "docstring_tokens": "Converts a comma separated string to a list", "label": 0}, {"idx": "cosqa-train-4170", "doc": "use python to calculate distance between two points in 2d", "code": "def dist(x1, x2, axis=0):\n    \"\"\"Return the distance between two points.\n\n    Set axis=1 if x1 is a vector and x2 a matrix to get a vector of distances.\n    \"\"\"\n    return np.linalg.norm(x2 - x1, axis=axis)", "code_tokens": "def dist ( x1 , x2 , axis = 0 ) : return np . linalg . norm ( x2 - x1 , axis = axis )", "docstring_tokens": "Return the distance between two points .", "label": 0}, {"idx": "cosqa-train-4171", "doc": "python comments function indented", "code": "def get_indentation(func):\n    \"\"\"Extracts a function's indentation as a string,\n    In contrast to an inspect.indentsize based implementation,\n    this function preserves tabs if present.\n    \"\"\"\n    src_lines = getsourcelines(func)[0]\n    for line in src_lines:\n        if not (line.startswith('@') or line.startswith('def') or line.lstrip().startswith('#')):\n            return line[:len(line) - len(line.lstrip())]\n    return pytypes.default_indent", "code_tokens": "def get_indentation ( func ) : src_lines = getsourcelines ( func ) [ 0 ] for line in src_lines : if not ( line . startswith ( '@' ) or line . startswith ( 'def' ) or line . lstrip ( ) . startswith ( '#' ) ) : return line [ : len ( line ) - len ( line . lstrip ( ) ) ] return pytypes . default_indent", "docstring_tokens": "Extracts a function s indentation as a string In contrast to an inspect . indentsize based implementation this function preserves tabs if present .", "label": 1}, {"idx": "cosqa-train-4172", "doc": "use python to word count and remove punctuation", "code": "def counter_from_str(self, string):\n        \"\"\"Build word frequency list from incoming string.\"\"\"\n        string_list = [chars for chars in string if chars not in self.punctuation]\n        string_joined = ''.join(string_list)\n        tokens = self.punkt.word_tokenize(string_joined)\n        return Counter(tokens)", "code_tokens": "def counter_from_str ( self , string ) : string_list = [ chars for chars in string if chars not in self . punctuation ] string_joined = '' . join ( string_list ) tokens = self . punkt . word_tokenize ( string_joined ) return Counter ( tokens )", "docstring_tokens": "Build word frequency list from incoming string .", "label": 0}, {"idx": "cosqa-train-4173", "doc": "python compare two strings if length is known speed", "code": "def count_string_diff(a,b):\n    \"\"\"Return the number of characters in two strings that don't exactly match\"\"\"\n    shortest = min(len(a), len(b))\n    return sum(a[i] != b[i] for i in range(shortest))", "code_tokens": "def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )", "docstring_tokens": "Return the number of characters in two strings that don t exactly match", "label": 0}, {"idx": "cosqa-train-4174", "doc": "usinf multiindex for a data frame python", "code": "def _make_index(df, cols=META_IDX):\n    \"\"\"Create an index from the columns of a dataframe\"\"\"\n    return pd.MultiIndex.from_tuples(\n        pd.unique(list(zip(*[df[col] for col in cols]))), names=tuple(cols))", "code_tokens": "def _make_index ( df , cols = META_IDX ) : return pd . MultiIndex . from_tuples ( pd . unique ( list ( zip ( * [ df [ col ] for col in cols ] ) ) ) , names = tuple ( cols ) )", "docstring_tokens": "Create an index from the columns of a dataframe", "label": 0}, {"idx": "cosqa-train-4175", "doc": "python compile string function", "code": "def _try_compile(source, name):\n    \"\"\"Attempts to compile the given source, first as an expression and\n       then as a statement if the first approach fails.\n\n       Utility function to accept strings in functions that otherwise\n       expect code objects\n    \"\"\"\n    try:\n        c = compile(source, name, 'eval')\n    except SyntaxError:\n        c = compile(source, name, 'exec')\n    return c", "code_tokens": "def _try_compile ( source , name ) : try : c = compile ( source , name , 'eval' ) except SyntaxError : c = compile ( source , name , 'exec' ) return c", "docstring_tokens": "Attempts to compile the given source first as an expression and then as a statement if the first approach fails .", "label": 0}, {"idx": "cosqa-train-4176", "doc": "using a function with lambda expressions with sorted python", "code": "def _sort_lambda(sortedby='cpu_percent',\n                 sortedby_secondary='memory_percent'):\n    \"\"\"Return a sort lambda function for the sortedbykey\"\"\"\n    ret = None\n    if sortedby == 'io_counters':\n        ret = _sort_io_counters\n    elif sortedby == 'cpu_times':\n        ret = _sort_cpu_times\n    return ret", "code_tokens": "def _sort_lambda ( sortedby = 'cpu_percent' , sortedby_secondary = 'memory_percent' ) : ret = None if sortedby == 'io_counters' : ret = _sort_io_counters elif sortedby == 'cpu_times' : ret = _sort_cpu_times return ret", "docstring_tokens": "Return a sort lambda function for the sortedbykey", "label": 0}, {"idx": "cosqa-train-4177", "doc": "python comprehension to sum", "code": "def _accumulate(sequence, func):\n    \"\"\"\n    Python2 accumulate implementation taken from\n    https://docs.python.org/3/library/itertools.html#itertools.accumulate\n    \"\"\"\n    iterator = iter(sequence)\n    total = next(iterator)\n    yield total\n    for element in iterator:\n        total = func(total, element)\n        yield total", "code_tokens": "def _accumulate ( sequence , func ) : iterator = iter ( sequence ) total = next ( iterator ) yield total for element in iterator : total = func ( total , element ) yield total", "docstring_tokens": "Python2 accumulate implementation taken from https : // docs . python . org / 3 / library / itertools . html#itertools . accumulate", "label": 0}, {"idx": "cosqa-train-4178", "doc": "using an iterator in python to go from 1 to 100", "code": "def items(self, limit=0):\n        \"\"\"Return iterator for items in each page\"\"\"\n        i = ItemIterator(self.iterator)\n        i.limit = limit\n        return i", "code_tokens": "def items ( self , limit = 0 ) : i = ItemIterator ( self . iterator ) i . limit = limit return i", "docstring_tokens": "Return iterator for items in each page", "label": 1}, {"idx": "cosqa-train-4179", "doc": "python configparser how to set defaults", "code": "def __init__(self, root_section='lago', defaults={}):\n        \"\"\"__init__\n        Args:\n            root_section (str): root section in the init\n            defaults (dict): Default dictonary to load, can be empty.\n        \"\"\"\n\n        self.root_section = root_section\n        self._defaults = defaults\n        self._config = defaultdict(dict)\n        self._config.update(self.load())\n        self._parser = None", "code_tokens": "def __init__ ( self , root_section = 'lago' , defaults = { } ) : self . root_section = root_section self . _defaults = defaults self . _config = defaultdict ( dict ) self . _config . update ( self . load ( ) ) self . _parser = None", "docstring_tokens": "__init__ Args : root_section ( str ) : root section in the init defaults ( dict ) : Default dictonary to load can be empty .", "label": 0}, {"idx": "cosqa-train-4180", "doc": "using cnn layers in keras python conv2d", "code": "def conv2d(x_input, w_matrix):\n    \"\"\"conv2d returns a 2d convolution layer with full stride.\"\"\"\n    return tf.nn.conv2d(x_input, w_matrix, strides=[1, 1, 1, 1], padding='SAME')", "code_tokens": "def conv2d ( x_input , w_matrix ) : return tf . nn . conv2d ( x_input , w_matrix , strides = [ 1 , 1 , 1 , 1 ] , padding = 'SAME' )", "docstring_tokens": "conv2d returns a 2d convolution layer with full stride .", "label": 0}, {"idx": "cosqa-train-4181", "doc": "python configparser to get the whole sections", "code": "def items(self, section_name):\n        \"\"\":return: list((option, value), ...) pairs of all items in the given section\"\"\"\n        return [(k, v) for k, v in super(GitConfigParser, self).items(section_name) if k != '__name__']", "code_tokens": "def items ( self , section_name ) : return [ ( k , v ) for k , v in super ( GitConfigParser , self ) . items ( section_name ) if k != '__name__' ]", "docstring_tokens": ": return : list (( option value ) ... ) pairs of all items in the given section", "label": 0}, {"idx": "cosqa-train-4182", "doc": "using min with lists python", "code": "def SegmentMin(a, ids):\n    \"\"\"\n    Segmented min op.\n    \"\"\"\n    func = lambda idxs: np.amin(a[idxs], axis=0)\n    return seg_map(func, a, ids),", "code_tokens": "def SegmentMin ( a , ids ) : func = lambda idxs : np . amin ( a [ idxs ] , axis = 0 ) return seg_map ( func , a , ids ) ,", "docstring_tokens": "Segmented min op .", "label": 0}, {"idx": "cosqa-train-4183", "doc": "python connect to local redis", "code": "def __connect():\n    \"\"\"\n    Connect to a redis instance.\n    \"\"\"\n    global redis_instance\n    if use_tcp_socket:\n        redis_instance = redis.StrictRedis(host=hostname, port=port)\n    else:\n        redis_instance = redis.StrictRedis(unix_socket_path=unix_socket)", "code_tokens": "def __connect ( ) : global redis_instance if use_tcp_socket : redis_instance = redis . StrictRedis ( host = hostname , port = port ) else : redis_instance = redis . StrictRedis ( unix_socket_path = unix_socket )", "docstring_tokens": "Connect to a redis instance .", "label": 0}, {"idx": "cosqa-train-4184", "doc": "using percent function in python", "code": "def percent_d(data, period):\n    \"\"\"\n    %D.\n\n    Formula:\n    %D = SMA(%K, 3)\n    \"\"\"\n    p_k = percent_k(data, period)\n    percent_d = sma(p_k, 3)\n    return percent_d", "code_tokens": "def percent_d ( data , period ) : p_k = percent_k ( data , period ) percent_d = sma ( p_k , 3 ) return percent_d", "docstring_tokens": "%D .", "label": 0}, {"idx": "cosqa-train-4185", "doc": "python connects points on a line graphic", "code": "def line_segment(X0, X1):\n    r\"\"\"\n    Calculate the voxel coordinates of a straight line between the two given\n    end points\n\n    Parameters\n    ----------\n    X0 and X1 : array_like\n        The [x, y] or [x, y, z] coordinates of the start and end points of\n        the line.\n\n    Returns\n    -------\n    coords : list of lists\n        A list of lists containing the X, Y, and Z coordinates of all voxels\n        that should be drawn between the start and end points to create a solid\n        line.\n    \"\"\"\n    X0 = sp.around(X0).astype(int)\n    X1 = sp.around(X1).astype(int)\n    if len(X0) == 3:\n        L = sp.amax(sp.absolute([[X1[0]-X0[0]], [X1[1]-X0[1]], [X1[2]-X0[2]]])) + 1\n        x = sp.rint(sp.linspace(X0[0], X1[0], L)).astype(int)\n        y = sp.rint(sp.linspace(X0[1], X1[1], L)).astype(int)\n        z = sp.rint(sp.linspace(X0[2], X1[2], L)).astype(int)\n        return [x, y, z]\n    else:\n        L = sp.amax(sp.absolute([[X1[0]-X0[0]], [X1[1]-X0[1]]])) + 1\n        x = sp.rint(sp.linspace(X0[0], X1[0], L)).astype(int)\n        y = sp.rint(sp.linspace(X0[1], X1[1], L)).astype(int)\n        return [x, y]", "code_tokens": "def line_segment ( X0 , X1 ) : X0 = sp . around ( X0 ) . astype ( int ) X1 = sp . around ( X1 ) . astype ( int ) if len ( X0 ) == 3 : L = sp . amax ( sp . absolute ( [ [ X1 [ 0 ] - X0 [ 0 ] ] , [ X1 [ 1 ] - X0 [ 1 ] ] , [ X1 [ 2 ] - X0 [ 2 ] ] ] ) ) + 1 x = sp . rint ( sp . linspace ( X0 [ 0 ] , X1 [ 0 ] , L ) ) . astype ( int ) y = sp . rint ( sp . linspace ( X0 [ 1 ] , X1 [ 1 ] , L ) ) . astype ( int ) z = sp . rint ( sp . linspace ( X0 [ 2 ] , X1 [ 2 ] , L ) ) . astype ( int ) return [ x , y , z ] else : L = sp . amax ( sp . absolute ( [ [ X1 [ 0 ] - X0 [ 0 ] ] , [ X1 [ 1 ] - X0 [ 1 ] ] ] ) ) + 1 x = sp . rint ( sp . linspace ( X0 [ 0 ] , X1 [ 0 ] , L ) ) . astype ( int ) y = sp . rint ( sp . linspace ( X0 [ 1 ] , X1 [ 1 ] , L ) ) . astype ( int ) return [ x , y ]", "docstring_tokens": "r Calculate the voxel coordinates of a straight line between the two given end points", "label": 0}, {"idx": "cosqa-train-4186", "doc": "using python regexp finditer", "code": "def iter_finds(regex_obj, s):\n    \"\"\"Generate all matches found within a string for a regex and yield each match as a string\"\"\"\n    if isinstance(regex_obj, str):\n        for m in re.finditer(regex_obj, s):\n            yield m.group()\n    else:\n        for m in regex_obj.finditer(s):\n            yield m.group()", "code_tokens": "def iter_finds ( regex_obj , s ) : if isinstance ( regex_obj , str ) : for m in re . finditer ( regex_obj , s ) : yield m . group ( ) else : for m in regex_obj . finditer ( s ) : yield m . group ( )", "docstring_tokens": "Generate all matches found within a string for a regex and yield each match as a string", "label": 0}, {"idx": "cosqa-train-4187", "doc": "python contour points spline interpolation opencv", "code": "def get_line_flux(line_wave, wave, flux, **kwargs):\n    \"\"\"Interpolated flux at a given wavelength (calls np.interp).\"\"\"\n    return np.interp(line_wave, wave, flux, **kwargs)", "code_tokens": "def get_line_flux ( line_wave , wave , flux , * * kwargs ) : return np . interp ( line_wave , wave , flux , * * kwargs )", "docstring_tokens": "Interpolated flux at a given wavelength ( calls np . interp ) .", "label": 0}, {"idx": "cosqa-train-4188", "doc": "using python to format and display json", "code": "def to_json(data):\n    \"\"\"Return data as a JSON string.\"\"\"\n    return json.dumps(data, default=lambda x: x.__dict__, sort_keys=True, indent=4)", "code_tokens": "def to_json ( data ) : return json . dumps ( data , default = lambda x : x . __dict__ , sort_keys = True , indent = 4 )", "docstring_tokens": "Return data as a JSON string .", "label": 0}, {"idx": "cosqa-train-4189", "doc": "python convention to make a method private", "code": "def method(func):\n    \"\"\"Wrap a function as a method.\"\"\"\n    attr = abc.abstractmethod(func)\n    attr.__imethod__ = True\n    return attr", "code_tokens": "def method ( func ) : attr = abc . abstractmethod ( func ) attr . __imethod__ = True return attr", "docstring_tokens": "Wrap a function as a method .", "label": 0}, {"idx": "cosqa-train-4190", "doc": "using spotify api in python", "code": "def version(self):\n        \"\"\"Spotify version information\"\"\"\n        url: str = get_url(\"/service/version.json\")\n        params = {\"service\": \"remote\"}\n        r = self._request(url=url, params=params)\n        return r.json()", "code_tokens": "def version ( self ) : url : str = get_url ( \"/service/version.json\" ) params = { \"service\" : \"remote\" } r = self . _request ( url = url , params = params ) return r . json ( )", "docstring_tokens": "Spotify version information", "label": 0}, {"idx": "cosqa-train-4191", "doc": "python conver epoch to datetime", "code": "def _dt_to_epoch(dt):\n        \"\"\"Convert datetime to epoch seconds.\"\"\"\n        try:\n            epoch = dt.timestamp()\n        except AttributeError:  # py2\n            epoch = (dt - datetime(1970, 1, 1)).total_seconds()\n        return epoch", "code_tokens": "def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch", "docstring_tokens": "Convert datetime to epoch seconds .", "label": 0}, {"idx": "cosqa-train-4192", "doc": "using the product of a function in an equation python", "code": "def multiply(traj):\n    \"\"\"Sophisticated simulation of multiplication\"\"\"\n    z=traj.x*traj.y\n    traj.f_add_result('z',z=z, comment='I am the product of two reals!')", "code_tokens": "def multiply ( traj ) : z = traj . x * traj . y traj . f_add_result ( 'z' , z = z , comment = 'I am the product of two reals!' )", "docstring_tokens": "Sophisticated simulation of multiplication", "label": 0}, {"idx": "cosqa-train-4193", "doc": "python coordinates offset vurve", "code": "def getOffset(self, loc):\n        \"\"\" Returns the offset between the given point and this point \"\"\"\n        return Location(loc.x - self.x, loc.y - self.y)", "code_tokens": "def getOffset ( self , loc ) : return Location ( loc . x - self . x , loc . y - self . y )", "docstring_tokens": "Returns the offset between the given point and this point", "label": 0}, {"idx": "cosqa-train-4194", "doc": "vs code python output viewer", "code": "def stdout_display():\n    \"\"\" Print results straight to stdout \"\"\"\n    if sys.version_info[0] == 2:\n        yield SmartBuffer(sys.stdout)\n    else:\n        yield SmartBuffer(sys.stdout.buffer)", "code_tokens": "def stdout_display ( ) : if sys . version_info [ 0 ] == 2 : yield SmartBuffer ( sys . stdout ) else : yield SmartBuffer ( sys . stdout . buffer )", "docstring_tokens": "Print results straight to stdout", "label": 0}, {"idx": "cosqa-train-4195", "doc": "python copy map iterator for next loop", "code": "def peekiter(iterable):\n    \"\"\"Return first row and also iterable with same items as original\"\"\"\n    it = iter(iterable)\n    one = next(it)\n\n    def gen():\n        \"\"\"Generator that returns first and proxy other items from source\"\"\"\n        yield one\n        while True:\n            yield next(it)\n    return (one, gen())", "code_tokens": "def peekiter ( iterable ) : it = iter ( iterable ) one = next ( it ) def gen ( ) : \"\"\"Generator that returns first and proxy other items from source\"\"\" yield one while True : yield next ( it ) return ( one , gen ( ) )", "docstring_tokens": "Return first row and also iterable with same items as original", "label": 0}, {"idx": "cosqa-train-4196", "doc": "vs code python tensorflow", "code": "def unit_ball_L2(shape):\n  \"\"\"A tensorflow variable tranfomed to be constrained in a L2 unit ball.\n\n  EXPERIMENTAL: Do not use for adverserial examples if you need to be confident\n  they are strong attacks. We are not yet confident in this code.\n  \"\"\"\n  x = tf.Variable(tf.zeros(shape))\n  return constrain_L2(x)", "code_tokens": "def unit_ball_L2 ( shape ) : x = tf . Variable ( tf . zeros ( shape ) ) return constrain_L2 ( x )", "docstring_tokens": "A tensorflow variable tranfomed to be constrained in a L2 unit ball .", "label": 0}, {"idx": "cosqa-train-4197", "doc": "python correlation analysis for multiple columns", "code": "def correlation(df, rowvar=False):\n    \"\"\"\n    Calculate column-wise Pearson correlations using ``numpy.ma.corrcoef``\n\n    Input data is masked to ignore NaNs when calculating correlations. Data is returned as\n    a Pandas ``DataFrame`` of column_n x column_n dimensions, with column index copied to\n    both axes.\n\n    :param df: Pandas DataFrame\n    :return: Pandas DataFrame (n_columns x n_columns) of column-wise correlations\n    \"\"\"\n\n    # Create a correlation matrix for all correlations\n    # of the columns (filled with na for all values)\n    df = df.copy()\n    maskv = np.ma.masked_where(np.isnan(df.values), df.values)\n    cdf = np.ma.corrcoef(maskv, rowvar=False)\n    cdf = pd.DataFrame(np.array(cdf))\n    cdf.columns = df.columns\n    cdf.index = df.columns\n    cdf = cdf.sort_index(level=0, axis=1)\n    cdf = cdf.sort_index(level=0)\n    return cdf", "code_tokens": "def correlation ( df , rowvar = False ) : # Create a correlation matrix for all correlations # of the columns (filled with na for all values) df = df . copy ( ) maskv = np . ma . masked_where ( np . isnan ( df . values ) , df . values ) cdf = np . ma . corrcoef ( maskv , rowvar = False ) cdf = pd . DataFrame ( np . array ( cdf ) ) cdf . columns = df . columns cdf . index = df . columns cdf = cdf . sort_index ( level = 0 , axis = 1 ) cdf = cdf . sort_index ( level = 0 ) return cdf", "docstring_tokens": "Calculate column - wise Pearson correlations using numpy . ma . corrcoef", "label": 0}, {"idx": "cosqa-train-4198", "doc": "webdriver python assert element present", "code": "def assert_visible(self, locator, msg=None):\n        \"\"\"\n        Hard assert for whether and element is present and visible in the current window/frame\n\n        :params locator: the locator of the element to search for\n        :params msg: (Optional) msg explaining the difference\n        \"\"\"\n        e = driver.find_elements_by_locator(locator)\n        if len(e) == 0:\n            raise AssertionError(\"Element at %s was not found\" % locator)\n        assert e.is_displayed()", "code_tokens": "def assert_visible ( self , locator , msg = None ) : e = driver . find_elements_by_locator ( locator ) if len ( e ) == 0 : raise AssertionError ( \"Element at %s was not found\" % locator ) assert e . is_displayed ( )", "docstring_tokens": "Hard assert for whether and element is present and visible in the current window / frame", "label": 0}, {"idx": "cosqa-train-4199", "doc": "python count all factors of a number", "code": "def _factor_generator(n):\n    \"\"\"\n    From a given natural integer, returns the prime factors and their multiplicity\n    :param n: Natural integer\n    :return:\n    \"\"\"\n    p = prime_factors(n)\n    factors = {}\n    for p1 in p:\n        try:\n            factors[p1] += 1\n        except KeyError:\n            factors[p1] = 1\n    return factors", "code_tokens": "def _factor_generator ( n ) : p = prime_factors ( n ) factors = { } for p1 in p : try : factors [ p1 ] += 1 except KeyError : factors [ p1 ] = 1 return factors", "docstring_tokens": "From a given natural integer returns the prime factors and their multiplicity : param n : Natural integer : return :", "label": 0}, {"idx": "cosqa-train-4200", "doc": "what color tuple is equal to black in python", "code": "def rgba_bytes_tuple(self, x):\n        \"\"\"Provides the color corresponding to value `x` in the\n        form of a tuple (R,G,B,A) with int values between 0 and 255.\n        \"\"\"\n        return tuple(int(u*255.9999) for u in self.rgba_floats_tuple(x))", "code_tokens": "def rgba_bytes_tuple ( self , x ) : return tuple ( int ( u * 255.9999 ) for u in self . rgba_floats_tuple ( x ) )", "docstring_tokens": "Provides the color corresponding to value x in the form of a tuple ( R G B A ) with int values between 0 and 255 .", "label": 0}, {"idx": "cosqa-train-4201", "doc": "what do you use to delete the first occurrence of an item from the list? python", "code": "def pop(self, index=-1):\n\t\t\"\"\"Remove and return the item at index.\"\"\"\n\t\tvalue = self._list.pop(index)\n\t\tdel self._dict[value]\n\t\treturn value", "code_tokens": "def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value", "docstring_tokens": "Remove and return the item at index .", "label": 0}, {"idx": "cosqa-train-4202", "doc": "python count number of nan in an array", "code": "def count_rows_with_nans(X):\n    \"\"\"Count the number of rows in 2D arrays that contain any nan values.\"\"\"\n    if X.ndim == 2:\n        return np.where(np.isnan(X).sum(axis=1) != 0, 1, 0).sum()", "code_tokens": "def count_rows_with_nans ( X ) : if X . ndim == 2 : return np . where ( np . isnan ( X ) . sum ( axis = 1 ) != 0 , 1 , 0 ) . sum ( )", "docstring_tokens": "Count the number of rows in 2D arrays that contain any nan values .", "label": 0}, {"idx": "cosqa-train-4203", "doc": "what does the gradient function in python do", "code": "def compute_gradient(self):\n        \"\"\"Compute the gradient of the current model using the training set\n        \"\"\"\n        delta = self.predict(self.X) - self.y\n        return delta.dot(self.X) / len(self.X)", "code_tokens": "def compute_gradient ( self ) : delta = self . predict ( self . X ) - self . y return delta . dot ( self . X ) / len ( self . X )", "docstring_tokens": "Compute the gradient of the current model using the training set", "label": 0}, {"idx": "cosqa-train-4204", "doc": "python count number of tabs in line", "code": "def _get_indent_length(line):\n    \"\"\"Return the length of the indentation on the given token's line.\"\"\"\n    result = 0\n    for char in line:\n        if char == \" \":\n            result += 1\n        elif char == \"\\t\":\n            result += _TAB_LENGTH\n        else:\n            break\n    return result", "code_tokens": "def _get_indent_length ( line ) : result = 0 for char in line : if char == \" \" : result += 1 elif char == \"\\t\" : result += _TAB_LENGTH else : break return result", "docstring_tokens": "Return the length of the indentation on the given token s line .", "label": 0}, {"idx": "cosqa-train-4205", "doc": "what to imput to close window python", "code": "def quit(self):\n        \"\"\" Quits the application (called when the last window is closed)\n        \"\"\"\n        logger.debug(\"ArgosApplication.quit called\")\n        assert len(self.mainWindows) == 0, \\\n            \"Bug: still {} windows present at application quit!\".format(len(self.mainWindows))\n        self.qApplication.quit()", "code_tokens": "def quit ( self ) : logger . debug ( \"ArgosApplication.quit called\" ) assert len ( self . mainWindows ) == 0 , \"Bug: still {} windows present at application quit!\" . format ( len ( self . mainWindows ) ) self . qApplication . quit ( )", "docstring_tokens": "Quits the application ( called when the last window is closed )", "label": 1}, {"idx": "cosqa-train-4206", "doc": "python count white space", "code": "def _count_leading_whitespace(text):\n  \"\"\"Returns the number of characters at the beginning of text that are whitespace.\"\"\"\n  idx = 0\n  for idx, char in enumerate(text):\n    if not char.isspace():\n      return idx\n  return idx + 1", "code_tokens": "def _count_leading_whitespace ( text ) : idx = 0 for idx , char in enumerate ( text ) : if not char . isspace ( ) : return idx return idx + 1", "docstring_tokens": "Returns the number of characters at the beginning of text that are whitespace .", "label": 0}, {"idx": "cosqa-train-4207", "doc": "what {} represents in python", "code": "def state(self):\n        \"\"\"Return internal state, useful for testing.\"\"\"\n        return {'c': self.c, 's0': self.s0, 's1': self.s1, 's2': self.s2}", "code_tokens": "def state ( self ) : return { 'c' : self . c , 's0' : self . s0 , 's1' : self . s1 , 's2' : self . s2 }", "docstring_tokens": "Return internal state useful for testing .", "label": 0}, {"idx": "cosqa-train-4208", "doc": "python count words in a sentance", "code": "def count(lines):\n  \"\"\" Counts the word frequences in a list of sentences.\n\n  Note:\n    This is a helper function for parallel execution of `Vocabulary.from_text`\n    method.\n  \"\"\"\n  words = [w for l in lines for w in l.strip().split()]\n  return Counter(words)", "code_tokens": "def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )", "docstring_tokens": "Counts the word frequences in a list of sentences .", "label": 0}, {"idx": "cosqa-train-4209", "doc": "what's a indent block in python", "code": "def indent(self):\n        \"\"\"\n        Begins an indented block. Must be used in a 'with' code block.\n        All calls to the logger inside of the block will be indented.\n        \"\"\"\n        blk = IndentBlock(self, self._indent)\n        self._indent += 1\n        return blk", "code_tokens": "def indent ( self ) : blk = IndentBlock ( self , self . _indent ) self . _indent += 1 return blk", "docstring_tokens": "Begins an indented block . Must be used in a with code block . All calls to the logger inside of the block will be indented .", "label": 0}, {"idx": "cosqa-train-4210", "doc": "python counter get nlargest", "code": "def nlargest(self, n=None):\n\t\t\"\"\"List the n most common elements and their counts.\n\n\t\tList is from the most\n\t\tcommon to the least.  If n is None, the list all element counts.\n\n\t\tRun time should be O(m log m) where m is len(self)\n\t\tArgs:\n\t\t\tn (int): The number of elements to return\n\t\t\"\"\"\n\t\tif n is None:\n\t\t\treturn sorted(self.counts(), key=itemgetter(1), reverse=True)\n\t\telse:\n\t\t\treturn heapq.nlargest(n, self.counts(), key=itemgetter(1))", "code_tokens": "def nlargest ( self , n = None ) : if n is None : return sorted ( self . counts ( ) , key = itemgetter ( 1 ) , reverse = True ) else : return heapq . nlargest ( n , self . counts ( ) , key = itemgetter ( 1 ) )", "docstring_tokens": "List the n most common elements and their counts .", "label": 0}, {"idx": "cosqa-train-4211", "doc": "while copying it shold create a new file if the file already exist in python", "code": "def _replace_file(path, content):\n  \"\"\"Writes a file if it doesn't already exist with the same content.\n\n  This is useful because cargo uses timestamps to decide whether to compile things.\"\"\"\n  if os.path.exists(path):\n    with open(path, 'r') as f:\n      if content == f.read():\n        print(\"Not overwriting {} because it is unchanged\".format(path), file=sys.stderr)\n        return\n\n  with open(path, 'w') as f:\n    f.write(content)", "code_tokens": "def _replace_file ( path , content ) : if os . path . exists ( path ) : with open ( path , 'r' ) as f : if content == f . read ( ) : print ( \"Not overwriting {} because it is unchanged\" . format ( path ) , file = sys . stderr ) return with open ( path , 'w' ) as f : f . write ( content )", "docstring_tokens": "Writes a file if it doesn t already exist with the same content .", "label": 0}, {"idx": "cosqa-train-4212", "doc": "python coverage coverage file location", "code": "def get_cov(config):\n    \"\"\"Returns the coverage object of pytest-cov.\"\"\"\n\n    # Check with hasplugin to avoid getplugin exception in older pytest.\n    if config.pluginmanager.hasplugin('_cov'):\n        plugin = config.pluginmanager.getplugin('_cov')\n        if plugin.cov_controller:\n            return plugin.cov_controller.cov\n    return None", "code_tokens": "def get_cov ( config ) : # Check with hasplugin to avoid getplugin exception in older pytest. if config . pluginmanager . hasplugin ( '_cov' ) : plugin = config . pluginmanager . getplugin ( '_cov' ) if plugin . cov_controller : return plugin . cov_controller . cov return None", "docstring_tokens": "Returns the coverage object of pytest - cov .", "label": 1}, {"idx": "cosqa-train-4213", "doc": "will python join add a delimiter for none", "code": "def _py2_and_3_joiner(sep, joinable):\n    \"\"\"\n    Allow '\\n'.join(...) statements to work in Py2 and Py3.\n    :param sep:\n    :param joinable:\n    :return:\n    \"\"\"\n    if ISPY3:\n        sep = bytes(sep, DEFAULT_ENCODING)\n    joined = sep.join(joinable)\n    return joined.decode(DEFAULT_ENCODING) if ISPY3 else joined", "code_tokens": "def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "docstring_tokens": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return :", "label": 0}, {"idx": "cosqa-train-4214", "doc": "python create a directory from a path", "code": "def create_path(path):\n    \"\"\"Creates a absolute path in the file system.\n\n    :param path: The path to be created\n    \"\"\"\n    import os\n    if not os.path.exists(path):\n        os.makedirs(path)", "code_tokens": "def create_path ( path ) : import os if not os . path . exists ( path ) : os . makedirs ( path )", "docstring_tokens": "Creates a absolute path in the file system .", "label": 0}, {"idx": "cosqa-train-4215", "doc": "windows python set fd as nonblock", "code": "def setblocking(fd, blocking):\n    \"\"\"Set the O_NONBLOCK flag for a file descriptor. Availability: Unix.\"\"\"\n    if not fcntl:\n        warnings.warn('setblocking() not supported on Windows')\n    flags = fcntl.fcntl(fd, fcntl.F_GETFL)\n    if blocking:\n        flags |= os.O_NONBLOCK\n    else:\n        flags &= ~os.O_NONBLOCK\n    fcntl.fcntl(fd, fcntl.F_SETFL, flags)", "code_tokens": "def setblocking ( fd , blocking ) : if not fcntl : warnings . warn ( 'setblocking() not supported on Windows' ) flags = fcntl . fcntl ( fd , fcntl . F_GETFL ) if blocking : flags |= os . O_NONBLOCK else : flags &= ~ os . O_NONBLOCK fcntl . fcntl ( fd , fcntl . F_SETFL , flags )", "docstring_tokens": "Set the O_NONBLOCK flag for a file descriptor . Availability : Unix .", "label": 0}, {"idx": "cosqa-train-4216", "doc": "python create a randomly sized rectangle", "code": "def from_rectangle(box):\n        \"\"\" Create a vector randomly within the given rectangle. \"\"\"\n        x = box.left + box.width * random.uniform(0, 1)\n        y = box.bottom + box.height * random.uniform(0, 1)\n        return Vector(x, y)", "code_tokens": "def from_rectangle ( box ) : x = box . left + box . width * random . uniform ( 0 , 1 ) y = box . bottom + box . height * random . uniform ( 0 , 1 ) return Vector ( x , y )", "docstring_tokens": "Create a vector randomly within the given rectangle .", "label": 0}, {"idx": "cosqa-train-4217", "doc": "working with clipboard in python", "code": "def paste(xsel=False):\n    \"\"\"Returns system clipboard contents.\"\"\"\n    selection = \"primary\" if xsel else \"clipboard\"\n    try:\n        return subprocess.Popen([\"xclip\", \"-selection\", selection, \"-o\"], stdout=subprocess.PIPE).communicate()[0].decode(\"utf-8\")\n    except OSError as why:\n        raise XclipNotFound", "code_tokens": "def paste ( xsel = False ) : selection = \"primary\" if xsel else \"clipboard\" try : return subprocess . Popen ( [ \"xclip\" , \"-selection\" , selection , \"-o\" ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] . decode ( \"utf-8\" ) except OSError as why : raise XclipNotFound", "docstring_tokens": "Returns system clipboard contents .", "label": 0}, {"idx": "cosqa-train-4218", "doc": "python create kill process", "code": "def process_kill(pid, sig=None):\n    \"\"\"Send signal to process.\n    \"\"\"\n    sig = sig or signal.SIGTERM\n    os.kill(pid, sig)", "code_tokens": "def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )", "docstring_tokens": "Send signal to process .", "label": 0}, {"idx": "cosqa-train-4219", "doc": "working with git in python without gitpython", "code": "def check_git():\n    \"\"\"Check if git command is available.\"\"\"\n    try:\n        with open(os.devnull, \"wb\") as devnull:\n            subprocess.check_call([\"git\", \"--version\"], stdout=devnull, stderr=devnull)\n    except:\n        raise RuntimeError(\"Please make sure git is installed and on your path.\")", "code_tokens": "def check_git ( ) : try : with open ( os . devnull , \"wb\" ) as devnull : subprocess . check_call ( [ \"git\" , \"--version\" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( \"Please make sure git is installed and on your path.\" )", "docstring_tokens": "Check if git command is available .", "label": 0}, {"idx": "cosqa-train-4220", "doc": "python create objects with dictionary", "code": "def fromDict(cls, _dict):\n        \"\"\" Builds instance from dictionary of properties. \"\"\"\n        obj = cls()\n        obj.__dict__.update(_dict)\n        return obj", "code_tokens": "def fromDict ( cls , _dict ) : obj = cls ( ) obj . __dict__ . update ( _dict ) return obj", "docstring_tokens": "Builds instance from dictionary of properties .", "label": 0}, {"idx": "cosqa-train-4221", "doc": "write a python program to read last n line of a file", "code": "def get_readline_tail(self, n=10):\n        \"\"\"Get the last n items in readline history.\"\"\"\n        end = self.shell.readline.get_current_history_length() + 1\n        start = max(end-n, 1)\n        ghi = self.shell.readline.get_history_item\n        return [ghi(x) for x in range(start, end)]", "code_tokens": "def get_readline_tail ( self , n = 10 ) : end = self . shell . readline . get_current_history_length ( ) + 1 start = max ( end - n , 1 ) ghi = self . shell . readline . get_history_item return [ ghi ( x ) for x in range ( start , end ) ]", "docstring_tokens": "Get the last n items in readline history .", "label": 0}, {"idx": "cosqa-train-4222", "doc": "python create sentance from string array", "code": "def surface(cls, predstr):\n        \"\"\"Instantiate a Pred from its quoted string representation.\"\"\"\n        lemma, pos, sense, _ = split_pred_string(predstr)\n        return cls(Pred.SURFACE, lemma, pos, sense, predstr)", "code_tokens": "def surface ( cls , predstr ) : lemma , pos , sense , _ = split_pred_string ( predstr ) return cls ( Pred . SURFACE , lemma , pos , sense , predstr )", "docstring_tokens": "Instantiate a Pred from its quoted string representation .", "label": 1}, {"idx": "cosqa-train-4223", "doc": "write csv from matrix python", "code": "def csv_matrix_print(classes, table):\n    \"\"\"\n    Return matrix as csv data.\n\n    :param classes: classes list\n    :type classes:list\n    :param table: table\n    :type table:dict\n    :return:\n    \"\"\"\n    result = \"\"\n    classes.sort()\n    for i in classes:\n        for j in classes:\n            result += str(table[i][j]) + \",\"\n        result = result[:-1] + \"\\n\"\n    return result[:-1]", "code_tokens": "def csv_matrix_print ( classes , table ) : result = \"\" classes . sort ( ) for i in classes : for j in classes : result += str ( table [ i ] [ j ] ) + \",\" result = result [ : - 1 ] + \"\\n\" return result [ : - 1 ]", "docstring_tokens": "Return matrix as csv data .", "label": 0}, {"idx": "cosqa-train-4224", "doc": "python create single element tuple", "code": "def _ensure_element(tup, elem):\n    \"\"\"\n    Create a tuple containing all elements of tup, plus elem.\n\n    Returns the new tuple and the index of elem in the new tuple.\n    \"\"\"\n    try:\n        return tup, tup.index(elem)\n    except ValueError:\n        return tuple(chain(tup, (elem,))), len(tup)", "code_tokens": "def _ensure_element ( tup , elem ) : try : return tup , tup . index ( elem ) except ValueError : return tuple ( chain ( tup , ( elem , ) ) ) , len ( tup )", "docstring_tokens": "Create a tuple containing all elements of tup plus elem .", "label": 0}, {"idx": "cosqa-train-4225", "doc": "write non ascii charachters python", "code": "def to_unicode_repr( _letter ):\n    \"\"\" helpful in situations where browser/app may recognize Unicode encoding\n        in the \\u0b8e type syntax but not actual unicode glyph/code-point\"\"\"\n    # Python 2-3 compatible\n    return u\"u'\"+ u\"\".join( [ u\"\\\\u%04x\"%ord(l) for l in _letter ] ) + u\"'\"", "code_tokens": "def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u\"u'\" + u\"\" . join ( [ u\"\\\\u%04x\" % ord ( l ) for l in _letter ] ) + u\"'\"", "docstring_tokens": "helpful in situations where browser / app may recognize Unicode encoding in the \\ u0b8e type syntax but not actual unicode glyph / code - point", "label": 0}, {"idx": "cosqa-train-4226", "doc": "python create string out of list of values", "code": "def vectorize(values):\n    \"\"\"\n    Takes a value or list of values and returns a single result, joined by \",\"\n    if necessary.\n    \"\"\"\n    if isinstance(values, list):\n        return ','.join(str(v) for v in values)\n    return values", "code_tokens": "def vectorize ( values ) : if isinstance ( values , list ) : return ',' . join ( str ( v ) for v in values ) return values", "docstring_tokens": "Takes a value or list of values and returns a single result joined by if necessary .", "label": 0}, {"idx": "cosqa-train-4227", "doc": "wxpython 'bitmap' object has no attribute 'ok'", "code": "def set_icon(self, bmp):\n        \"\"\"Sets main window icon to given wx.Bitmap\"\"\"\n\n        _icon = wx.EmptyIcon()\n        _icon.CopyFromBitmap(bmp)\n        self.SetIcon(_icon)", "code_tokens": "def set_icon ( self , bmp ) : _icon = wx . EmptyIcon ( ) _icon . CopyFromBitmap ( bmp ) self . SetIcon ( _icon )", "docstring_tokens": "Sets main window icon to given wx . Bitmap", "label": 0}, {"idx": "cosqa-train-4228", "doc": "python create symlink in windows", "code": "def create_symlink(source, link_name):\n    \"\"\"\n    Creates symbolic link for either operating system.\n\n    http://stackoverflow.com/questions/6260149/os-symlink-support-in-windows\n    \"\"\"\n    os_symlink = getattr(os, \"symlink\", None)\n    if isinstance(os_symlink, collections.Callable):\n        os_symlink(source, link_name)\n    else:\n        import ctypes\n        csl = ctypes.windll.kernel32.CreateSymbolicLinkW\n        csl.argtypes = (ctypes.c_wchar_p, ctypes.c_wchar_p, ctypes.c_uint32)\n        csl.restype = ctypes.c_ubyte\n        flags = 1 if os.path.isdir(source) else 0\n        if csl(link_name, source, flags) == 0:\n            raise ctypes.WinError()", "code_tokens": "def create_symlink ( source , link_name ) : os_symlink = getattr ( os , \"symlink\" , None ) if isinstance ( os_symlink , collections . Callable ) : os_symlink ( source , link_name ) else : import ctypes csl = ctypes . windll . kernel32 . CreateSymbolicLinkW csl . argtypes = ( ctypes . c_wchar_p , ctypes . c_wchar_p , ctypes . c_uint32 ) csl . restype = ctypes . c_ubyte flags = 1 if os . path . isdir ( source ) else 0 if csl ( link_name , source , flags ) == 0 : raise ctypes . WinError ( )", "docstring_tokens": "Creates symbolic link for either operating system . http : // stackoverflow . com / questions / 6260149 / os - symlink - support - in - windows", "label": 0}, {"idx": "cosqa-train-4229", "doc": "wxpython default background color", "code": "def _update_bordercolor(self, bordercolor):\n        \"\"\"Updates background color\"\"\"\n\n        border_color = wx.SystemSettings_GetColour(wx.SYS_COLOUR_ACTIVEBORDER)\n        border_color.SetRGB(bordercolor)\n\n        self.linecolor_choice.SetColour(border_color)", "code_tokens": "def _update_bordercolor ( self , bordercolor ) : border_color = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_ACTIVEBORDER ) border_color . SetRGB ( bordercolor ) self . linecolor_choice . SetColour ( border_color )", "docstring_tokens": "Updates background color", "label": 0}, {"idx": "cosqa-train-4230", "doc": "python create varaiable from string", "code": "def autoconvert(string):\n    \"\"\"Try to convert variables into datatypes.\"\"\"\n    for fn in (boolify, int, float):\n        try:\n            return fn(string)\n        except ValueError:\n            pass\n    return string", "code_tokens": "def autoconvert ( string ) : for fn in ( boolify , int , float ) : try : return fn ( string ) except ValueError : pass return string", "docstring_tokens": "Try to convert variables into datatypes .", "label": 0}, {"idx": "cosqa-train-4231", "doc": "wxpython frame disable close button", "code": "def on_close(self, evt):\n    \"\"\"\n    Pop-up menu and wx.EVT_CLOSE closing event\n    \"\"\"\n    self.stop() # DoseWatcher\n    if evt.EventObject is not self: # Avoid deadlocks\n      self.Close() # wx.Frame\n    evt.Skip()", "code_tokens": "def on_close ( self , evt ) : self . stop ( ) # DoseWatcher if evt . EventObject is not self : # Avoid deadlocks self . Close ( ) # wx.Frame evt . Skip ( )", "docstring_tokens": "Pop - up menu and wx . EVT_CLOSE closing event", "label": 1}, {"idx": "cosqa-train-4232", "doc": "python creating cursor connection to stored procedure as opposed to tables", "code": "def connect(*args, **kwargs):\n    \"\"\"Create database connection, use TraceCursor as the cursor_factory.\"\"\"\n    kwargs['cursor_factory'] = TraceCursor\n    conn = pg_connect(*args, **kwargs)\n    return conn", "code_tokens": "def connect ( * args , * * kwargs ) : kwargs [ 'cursor_factory' ] = TraceCursor conn = pg_connect ( * args , * * kwargs ) return conn", "docstring_tokens": "Create database connection use TraceCursor as the cursor_factory .", "label": 0}, {"idx": "cosqa-train-4233", "doc": "wxpython get the maximum resolution of the screen", "code": "def get_screen_resolution(self):\n        \"\"\"Return the screen resolution of the primary screen.\"\"\"\n        widget = QDesktopWidget()\n        geometry = widget.availableGeometry(widget.primaryScreen())\n        return geometry.width(), geometry.height()", "code_tokens": "def get_screen_resolution ( self ) : widget = QDesktopWidget ( ) geometry = widget . availableGeometry ( widget . primaryScreen ( ) ) return geometry . width ( ) , geometry . height ( )", "docstring_tokens": "Return the screen resolution of the primary screen .", "label": 0}, {"idx": "cosqa-train-4234", "doc": "python creatte range tuple", "code": "def from_tuple(tup):\n    \"\"\"Convert a tuple into a range with error handling.\n\n    Parameters\n    ----------\n    tup : tuple (len 2 or 3)\n        The tuple to turn into a range.\n\n    Returns\n    -------\n    range : range\n        The range from the tuple.\n\n    Raises\n    ------\n    ValueError\n        Raised when the tuple length is not 2 or 3.\n    \"\"\"\n    if len(tup) not in (2, 3):\n        raise ValueError(\n            'tuple must contain 2 or 3 elements, not: %d (%r' % (\n                len(tup),\n                tup,\n            ),\n        )\n    return range(*tup)", "code_tokens": "def from_tuple ( tup ) : if len ( tup ) not in ( 2 , 3 ) : raise ValueError ( 'tuple must contain 2 or 3 elements, not: %d (%r' % ( len ( tup ) , tup , ) , ) return range ( * tup )", "docstring_tokens": "Convert a tuple into a range with error handling .", "label": 0}, {"idx": "cosqa-train-4235", "doc": "python crop image out of boundary", "code": "def _trim(image):\n    \"\"\"Trim a PIL image and remove white space.\"\"\"\n    background = PIL.Image.new(image.mode, image.size, image.getpixel((0, 0)))\n    diff = PIL.ImageChops.difference(image, background)\n    diff = PIL.ImageChops.add(diff, diff, 2.0, -100)\n    bbox = diff.getbbox()\n    if bbox:\n        image = image.crop(bbox)\n    return image", "code_tokens": "def _trim ( image ) : background = PIL . Image . new ( image . mode , image . size , image . getpixel ( ( 0 , 0 ) ) ) diff = PIL . ImageChops . difference ( image , background ) diff = PIL . ImageChops . add ( diff , diff , 2.0 , - 100 ) bbox = diff . getbbox ( ) if bbox : image = image . crop ( bbox ) return image", "docstring_tokens": "Trim a PIL image and remove white space .", "label": 0}, {"idx": "cosqa-train-4236", "doc": "python ctypes array of ints", "code": "def cint8_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes int pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)):\n        return np.fromiter(cptr, dtype=np.int8, count=length)\n    else:\n        raise RuntimeError('Expected int pointer')", "code_tokens": "def cint8_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int8 ) ) : return np . fromiter ( cptr , dtype = np . int8 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "docstring_tokens": "Convert a ctypes int pointer array to a numpy array .", "label": 0}, {"idx": "cosqa-train-4237", "doc": "python coroutine call coroutine", "code": "def submit(self, fn, *args, **kwargs):\n        \"\"\"Submit an operation\"\"\"\n        corofn = asyncio.coroutine(lambda: fn(*args, **kwargs))\n        return run_coroutine_threadsafe(corofn(), self.loop)", "code_tokens": "def submit ( self , fn , * args , * * kwargs ) : corofn = asyncio . coroutine ( lambda : fn ( * args , * * kwargs ) ) return run_coroutine_threadsafe ( corofn ( ) , self . loop )", "docstring_tokens": "Submit an operation", "label": 0}, {"idx": "cosqa-train-4238", "doc": "\"load javascript file from python\"", "code": "def import_js(path, lib_name, globals):\n    \"\"\"Imports from javascript source file.\n      globals is your globals()\"\"\"\n    with codecs.open(path_as_local(path), \"r\", \"utf-8\") as f:\n        js = f.read()\n    e = EvalJs()\n    e.execute(js)\n    var = e.context['var']\n    globals[lib_name] = var.to_python()", "code_tokens": "def import_js ( path , lib_name , globals ) : with codecs . open ( path_as_local ( path ) , \"r\" , \"utf-8\" ) as f : js = f . read ( ) e = EvalJs ( ) e . execute ( js ) var = e . context [ 'var' ] globals [ lib_name ] = var . to_python ( )", "docstring_tokens": "Imports from javascript source file . globals is your globals ()", "label": 0}, {"idx": "cosqa-train-4239", "doc": "python correlation matrix with objects", "code": "def sample_correlations(self):\n        \"\"\"Returns an `ExpMatrix` containing all pairwise sample correlations.\n\n        Returns\n        -------\n        `ExpMatrix`\n            The sample correlation matrix.\n\n        \"\"\"\n        C = np.corrcoef(self.X.T)\n        corr_matrix = ExpMatrix(genes=self.samples, samples=self.samples, X=C)\n        return corr_matrix", "code_tokens": "def sample_correlations ( self ) : C = np . corrcoef ( self . X . T ) corr_matrix = ExpMatrix ( genes = self . samples , samples = self . samples , X = C ) return corr_matrix", "docstring_tokens": "Returns an ExpMatrix containing all pairwise sample correlations .", "label": 0}, {"idx": "cosqa-train-4240", "doc": "how to \"copy a folder\" in python", "code": "def clone_with_copy(src_path, dest_path):\n    \"\"\"Clone a directory try by copying it.\n\n   Args:\n        src_path: The directory to be copied.\n        dest_path: The location to copy the directory to.\n    \"\"\"\n    log.info('Cloning directory tree %s to %s', src_path, dest_path)\n    shutil.copytree(src_path, dest_path)", "code_tokens": "def clone_with_copy ( src_path , dest_path ) : log . info ( 'Cloning directory tree %s to %s' , src_path , dest_path ) shutil . copytree ( src_path , dest_path )", "docstring_tokens": "Clone a directory try by copying it .", "label": 1}, {"idx": "cosqa-train-4241", "doc": "python count unique elements in list of list", "code": "def count_list(the_list):\n    \"\"\"\n    Generates a count of the number of times each unique item appears in a list\n    \"\"\"\n    count = the_list.count\n    result = [(item, count(item)) for item in set(the_list)]\n    result.sort()\n    return result", "code_tokens": "def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result", "docstring_tokens": "Generates a count of the number of times each unique item appears in a list", "label": 0}, {"idx": "cosqa-train-4242", "doc": "max heap with \"double link\" list python", "code": "def heappop_max(heap):\n    \"\"\"Maxheap version of a heappop.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup_max(heap, 0)\n        return returnitem\n    return lastelt", "code_tokens": "def heappop_max ( heap ) : lastelt = heap . pop ( ) # raises appropriate IndexError if heap is empty if heap : returnitem = heap [ 0 ] heap [ 0 ] = lastelt _siftup_max ( heap , 0 ) return returnitem return lastelt", "docstring_tokens": "Maxheap version of a heappop .", "label": 0}, {"idx": "cosqa-train-4243", "doc": "python coverage report multiple files", "code": "def coverage():\n    \"\"\"check code coverage quickly with the default Python\"\"\"\n    run(\"coverage run --source {PROJECT_NAME} -m py.test\".format(PROJECT_NAME=PROJECT_NAME))\n    run(\"coverage report -m\")\n    run(\"coverage html\")\n\n    webbrowser.open('file://' + os.path.realpath(\"htmlcov/index.html\"), new=2)", "code_tokens": "def coverage ( ) : run ( \"coverage run --source {PROJECT_NAME} -m py.test\" . format ( PROJECT_NAME = PROJECT_NAME ) ) run ( \"coverage report -m\" ) run ( \"coverage html\" ) webbrowser . open ( 'file://' + os . path . realpath ( \"htmlcov/index.html\" ) , new = 2 )", "docstring_tokens": "check code coverage quickly with the default Python", "label": 0}, {"idx": "cosqa-train-4244", "doc": "python pass method to function \"must be called with instance\"", "code": "def action(self):\n        \"\"\"\n        This class overrides this method\n        \"\"\"\n        self.return_value = self.function(*self.args, **self.kwargs)", "code_tokens": "def action ( self ) : self . return_value = self . function ( * self . args , * * self . kwargs )", "docstring_tokens": "This class overrides this method", "label": 0}, {"idx": "cosqa-train-4245", "doc": "python covert bytes to integer", "code": "def string_to_int( s ):\n  \"\"\"Convert a string of bytes into an integer, as per X9.62.\"\"\"\n  result = 0\n  for c in s:\n    if not isinstance(c, int): c = ord( c )\n    result = 256 * result + c\n  return result", "code_tokens": "def string_to_int ( s ) : result = 0 for c in s : if not isinstance ( c , int ) : c = ord ( c ) result = 256 * result + c return result", "docstring_tokens": "Convert a string of bytes into an integer as per X9 . 62 .", "label": 0}, {"idx": "cosqa-train-4246", "doc": "python turn string into one hot vector \"alphabet\"", "code": "def one_hot2string(arr, vocab):\n    \"\"\"Convert a one-hot encoded array back to string\n    \"\"\"\n    tokens = one_hot2token(arr)\n    indexToLetter = _get_index_dict(vocab)\n\n    return [''.join([indexToLetter[x] for x in row]) for row in tokens]", "code_tokens": "def one_hot2string ( arr , vocab ) : tokens = one_hot2token ( arr ) indexToLetter = _get_index_dict ( vocab ) return [ '' . join ( [ indexToLetter [ x ] for x in row ] ) for row in tokens ]", "docstring_tokens": "Convert a one - hot encoded array back to string", "label": 1}, {"idx": "cosqa-train-4247", "doc": "python create a drop down from list", "code": "def new_from_list(cls, items, **kwargs):\n        \"\"\"Populates the ListView with a string list.\n\n        Args:\n            items (list): list of strings to fill the widget with.\n        \"\"\"\n        obj = cls(**kwargs)\n        for item in items:\n            obj.append(ListItem(item))\n        return obj", "code_tokens": "def new_from_list ( cls , items , * * kwargs ) : obj = cls ( * * kwargs ) for item in items : obj . append ( ListItem ( item ) ) return obj", "docstring_tokens": "Populates the ListView with a string list .", "label": 0}, {"idx": "cosqa-train-4248", "doc": "read csv into list without \" and , python", "code": "def csvtolist(inputstr):\n    \"\"\" converts a csv string into a list \"\"\"\n    reader = csv.reader([inputstr], skipinitialspace=True)\n    output = []\n    for r in reader:\n        output += r\n    return output", "code_tokens": "def csvtolist ( inputstr ) : reader = csv . reader ( [ inputstr ] , skipinitialspace = True ) output = [ ] for r in reader : output += r return output", "docstring_tokens": "converts a csv string into a list", "label": 1}, {"idx": "cosqa-train-4249", "doc": "python create a naive datetime", "code": "def get_naive(dt):\n  \"\"\"Gets a naive datetime from a datetime.\n\n  datetime_tz objects can't just have tzinfo replaced with None, you need to\n  call asdatetime.\n\n  Args:\n    dt: datetime object.\n\n  Returns:\n    datetime object without any timezone information.\n  \"\"\"\n  if not dt.tzinfo:\n    return dt\n  if hasattr(dt, \"asdatetime\"):\n    return dt.asdatetime()\n  return dt.replace(tzinfo=None)", "code_tokens": "def get_naive ( dt ) : if not dt . tzinfo : return dt if hasattr ( dt , \"asdatetime\" ) : return dt . asdatetime ( ) return dt . replace ( tzinfo = None )", "docstring_tokens": "Gets a naive datetime from a datetime .", "label": 0}, {"idx": "cosqa-train-4250", "doc": "sqlalchemy my sql \"python keyword\" for column name", "code": "def putkeyword(self, keyword, value, makesubrecord=False):\n        \"\"\"Put the value of a column keyword.\n        (see :func:`table.putcolkeyword`)\"\"\"\n        return self._table.putcolkeyword(self._column, keyword, value, makesubrecord)", "code_tokens": "def putkeyword ( self , keyword , value , makesubrecord = False ) : return self . _table . putcolkeyword ( self . _column , keyword , value , makesubrecord )", "docstring_tokens": "Put the value of a column keyword . ( see : func : table . putcolkeyword )", "label": 1}, {"idx": "cosqa-train-4251", "doc": "python create a variable header", "code": "def format_op_hdr():\n    \"\"\"\n    Build the header\n    \"\"\"\n    txt = 'Base Filename'.ljust(36) + ' '\n    txt += 'Lines'.rjust(7) + ' '\n    txt += 'Words'.rjust(7) + '  '\n    txt += 'Unique'.ljust(8) + ''\n    return txt", "code_tokens": "def format_op_hdr ( ) : txt = 'Base Filename' . ljust ( 36 ) + ' ' txt += 'Lines' . rjust ( 7 ) + ' ' txt += 'Words' . rjust ( 7 ) + '  ' txt += 'Unique' . ljust ( 8 ) + '' return txt", "docstring_tokens": "Build the header", "label": 0}, {"idx": "cosqa-train-4252", "doc": "% in python accepts float", "code": "def setValue(self, p_float):\n        \"\"\"Override method to set a value to show it as 0 to 100.\n\n        :param p_float: The float number that want to be set.\n        :type p_float: float\n        \"\"\"\n        p_float = p_float * 100\n\n        super(PercentageSpinBox, self).setValue(p_float)", "code_tokens": "def setValue ( self , p_float ) : p_float = p_float * 100 super ( PercentageSpinBox , self ) . setValue ( p_float )", "docstring_tokens": "Override method to set a value to show it as 0 to 100 .", "label": 0}, {"idx": "cosqa-train-4253", "doc": "python create adjacency matrix", "code": "def get_adjacent_matrix(self):\n        \"\"\"Get adjacency matrix.\n\n        Returns:\n            :param adj: adjacency matrix\n            :type adj: np.ndarray\n        \"\"\"\n        edges = self.edges\n        num_edges = len(edges) + 1\n        adj = np.zeros([num_edges, num_edges])\n\n        for k in range(num_edges - 1):\n            adj[edges[k].L, edges[k].R] = 1\n            adj[edges[k].R, edges[k].L] = 1\n\n        return adj", "code_tokens": "def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj", "docstring_tokens": "Get adjacency matrix .", "label": 0}, {"idx": "cosqa-train-4254", "doc": "+python django data translator unit", "code": "def format_arg(value):\n    \"\"\"\n    :param value:\n        Some value in a dataset.\n    :type value:\n        varies\n    :return:\n        unicode representation of that value\n    :rtype:\n        `unicode`\n    \"\"\"\n    translator = repr if isinstance(value, six.string_types) else six.text_type\n    return translator(value)", "code_tokens": "def format_arg ( value ) : translator = repr if isinstance ( value , six . string_types ) else six . text_type return translator ( value )", "docstring_tokens": ": param value : Some value in a dataset . : type value : varies : return : unicode representation of that value : rtype : unicode", "label": 0}, {"idx": "cosqa-train-4255", "doc": "python create folder including parents", "code": "def makedirs(directory):\n    \"\"\" Resursively create a named directory. \"\"\"\n    parent = os.path.dirname(os.path.abspath(directory))\n    if not os.path.exists(parent):\n        makedirs(parent)\n    os.mkdir(directory)", "code_tokens": "def makedirs ( directory ) : parent = os . path . dirname ( os . path . abspath ( directory ) ) if not os . path . exists ( parent ) : makedirs ( parent ) os . mkdir ( directory )", "docstring_tokens": "Resursively create a named directory .", "label": 1}, {"idx": "cosqa-train-4256", "doc": "0x hex value to hsv python code", "code": "def hex_to_hsv(color):\n    \"\"\"\n    Converts from hex to hsv\n\n    Parameters:\n    -----------\n            color : string\n                    Color representation on color\n\n    Example:\n            hex_to_hsv('#ff9933')\n    \"\"\"\n    color = normalize(color)\n    color = color[1:]\n    # color=tuple(ord(c)/255.0 for c in color.decode('hex'))\n    color = (int(color[0:2], base=16) / 255.0, int(color[2:4],\n                                                   base=16) / 255.0, int(color[4:6], base=16) / 255.0)\n    return colorsys.rgb_to_hsv(*color)", "code_tokens": "def hex_to_hsv ( color ) : color = normalize ( color ) color = color [ 1 : ] # color=tuple(ord(c)/255.0 for c in color.decode('hex')) color = ( int ( color [ 0 : 2 ] , base = 16 ) / 255.0 , int ( color [ 2 : 4 ] , base = 16 ) / 255.0 , int ( color [ 4 : 6 ] , base = 16 ) / 255.0 ) return colorsys . rgb_to_hsv ( * color )", "docstring_tokens": "Converts from hex to hsv", "label": 0}, {"idx": "cosqa-train-4257", "doc": "python create new schema postgresql", "code": "def create_db_schema(cls, cur, schema_name):\n        \"\"\"\n        Create Postgres schema script and execute it on cursor\n        \"\"\"\n        create_schema_script = \"CREATE SCHEMA {0} ;\\n\".format(schema_name)\n        cur.execute(create_schema_script)", "code_tokens": "def create_db_schema ( cls , cur , schema_name ) : create_schema_script = \"CREATE SCHEMA {0} ;\\n\" . format ( schema_name ) cur . execute ( create_schema_script )", "docstring_tokens": "Create Postgres schema script and execute it on cursor", "label": 0}, {"idx": "cosqa-train-4258", "doc": "24hr format to time in python", "code": "def format_time(time):\n    \"\"\" Formats the given time into HH:MM:SS \"\"\"\n    h, r = divmod(time / 1000, 3600)\n    m, s = divmod(r, 60)\n\n    return \"%02d:%02d:%02d\" % (h, m, s)", "code_tokens": "def format_time ( time ) : h , r = divmod ( time / 1000 , 3600 ) m , s = divmod ( r , 60 ) return \"%02d:%02d:%02d\" % ( h , m , s )", "docstring_tokens": "Formats the given time into HH : MM : SS", "label": 1}, {"idx": "cosqa-train-4259", "doc": "python create object with dict", "code": "def fromDict(cls, _dict):\n        \"\"\" Builds instance from dictionary of properties. \"\"\"\n        obj = cls()\n        obj.__dict__.update(_dict)\n        return obj", "code_tokens": "def fromDict ( cls , _dict ) : obj = cls ( ) obj . __dict__ . update ( _dict ) return obj", "docstring_tokens": "Builds instance from dictionary of properties .", "label": 1}, {"idx": "cosqa-train-4260", "doc": "2d rotation matrix given angle python", "code": "def create_rot2d(angle):\n    \"\"\"Create 2D rotation matrix\"\"\"\n    ca = math.cos(angle)\n    sa = math.sin(angle)\n    return np.array([[ca, -sa], [sa, ca]])", "code_tokens": "def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )", "docstring_tokens": "Create 2D rotation matrix", "label": 0}, {"idx": "cosqa-train-4261", "doc": "python create one hot numpy", "code": "def one_hot(x, size, dtype=np.float32):\n  \"\"\"Make a n+1 dim one-hot array from n dim int-categorical array.\"\"\"\n  return np.array(x[..., np.newaxis] == np.arange(size), dtype)", "code_tokens": "def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )", "docstring_tokens": "Make a n + 1 dim one - hot array from n dim int - categorical array .", "label": 0}, {"idx": "cosqa-train-4262", "doc": "3d lists coordinates in python", "code": "def list(self):\n        \"\"\"position in 3d space\"\"\"\n        return [self._pos3d.x, self._pos3d.y, self._pos3d.z]", "code_tokens": "def list ( self ) : return [ self . _pos3d . x , self . _pos3d . y , self . _pos3d . z ]", "docstring_tokens": "position in 3d space", "label": 0}, {"idx": "cosqa-train-4263", "doc": "python create random sparse matrix invertable", "code": "def sp_rand(m,n,a):\n    \"\"\"\n    Generates an mxn sparse 'd' matrix with round(a*m*n) nonzeros.\n    \"\"\"\n    if m == 0 or n == 0: return spmatrix([], [], [], (m,n))\n    nnz = min(max(0, int(round(a*m*n))), m*n)\n    nz = matrix(random.sample(range(m*n), nnz), tc='i')\n    return spmatrix(normal(nnz,1), nz%m, matrix([int(ii) for ii in nz/m]), (m,n))", "code_tokens": "def sp_rand ( m , n , a ) : if m == 0 or n == 0 : return spmatrix ( [ ] , [ ] , [ ] , ( m , n ) ) nnz = min ( max ( 0 , int ( round ( a * m * n ) ) ) , m * n ) nz = matrix ( random . sample ( range ( m * n ) , nnz ) , tc = 'i' ) return spmatrix ( normal ( nnz , 1 ) , nz % m , matrix ( [ int ( ii ) for ii in nz / m ] ) , ( m , n ) )", "docstring_tokens": "Generates an mxn sparse d matrix with round ( a * m * n ) nonzeros .", "label": 0}, {"idx": "cosqa-train-4264", "doc": "90 degree rotation of array in python", "code": "def create_rot2d(angle):\n    \"\"\"Create 2D rotation matrix\"\"\"\n    ca = math.cos(angle)\n    sa = math.sin(angle)\n    return np.array([[ca, -sa], [sa, ca]])", "code_tokens": "def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )", "docstring_tokens": "Create 2D rotation matrix", "label": 1}, {"idx": "cosqa-train-4265", "doc": "python create table dynamically", "code": "def append_table(self, name, **kwargs):\n        \"\"\"Create a new table.\"\"\"\n        self.stack.append(Table(name, **kwargs))", "code_tokens": "def append_table ( self , name , * * kwargs ) : self . stack . append ( Table ( name , * * kwargs ) )", "docstring_tokens": "Create a new table .", "label": 0}, {"idx": "cosqa-train-4266", "doc": "a canvas is not a widget used in python to create a graphic design", "code": "def build_gui(self, container):\n        \"\"\"\n        This is responsible for building the viewer's UI.  It should\n        place the UI in `container`.  Override this to make a custom\n        UI.\n        \"\"\"\n        vbox = Widgets.VBox()\n        vbox.set_border_width(0)\n\n        w = Viewers.GingaViewerWidget(viewer=self)\n        vbox.add_widget(w, stretch=1)\n\n        # need to put this in an hbox with an expanding label or the\n        # browser wants to resize the canvas, distorting it\n        hbox = Widgets.HBox()\n        hbox.add_widget(vbox, stretch=0)\n        hbox.add_widget(Widgets.Label(''), stretch=1)\n\n        container.set_widget(hbox)", "code_tokens": "def build_gui ( self , container ) : vbox = Widgets . VBox ( ) vbox . set_border_width ( 0 ) w = Viewers . GingaViewerWidget ( viewer = self ) vbox . add_widget ( w , stretch = 1 ) # need to put this in an hbox with an expanding label or the # browser wants to resize the canvas, distorting it hbox = Widgets . HBox ( ) hbox . add_widget ( vbox , stretch = 0 ) hbox . add_widget ( Widgets . Label ( '' ) , stretch = 1 ) container . set_widget ( hbox )", "docstring_tokens": "This is responsible for building the viewer s UI . It should place the UI in container . Override this to make a custom UI .", "label": 0}, {"idx": "cosqa-train-4267", "doc": "python create timespan from seconds", "code": "def timespan(start_time):\n    \"\"\"Return time in milliseconds from start_time\"\"\"\n\n    timespan = datetime.datetime.now() - start_time\n    timespan_ms = timespan.total_seconds() * 1000\n    return timespan_ms", "code_tokens": "def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms", "docstring_tokens": "Return time in milliseconds from start_time", "label": 0}, {"idx": "cosqa-train-4268", "doc": "a pythonobject is not attached to a node", "code": "def add_object(self, obj):\n        \"\"\"Add object to local and app environment storage\n\n        :param obj: Instance of a .NET object\n        \"\"\"\n        if obj.top_level_object:\n            if isinstance(obj, DotNetNamespace):\n                self.namespaces[obj.name] = obj\n        self.objects[obj.id] = obj", "code_tokens": "def add_object ( self , obj ) : if obj . top_level_object : if isinstance ( obj , DotNetNamespace ) : self . namespaces [ obj . name ] = obj self . objects [ obj . id ] = obj", "docstring_tokens": "Add object to local and app environment storage", "label": 0}, {"idx": "cosqa-train-4269", "doc": "python createa a 2d gaussian", "code": "def get_2D_samples_gauss(n, m, sigma, random_state=None):\n    \"\"\" Deprecated see  make_2D_samples_gauss   \"\"\"\n    return make_2D_samples_gauss(n, m, sigma, random_state=None)", "code_tokens": "def get_2D_samples_gauss ( n , m , sigma , random_state = None ) : return make_2D_samples_gauss ( n , m , sigma , random_state = None )", "docstring_tokens": "Deprecated see make_2D_samples_gauss", "label": 1}, {"idx": "cosqa-train-4270", "doc": "access metadata python pdf", "code": "def security(self):\n        \"\"\"Print security object information for a pdf document\"\"\"\n        return {k: v for i in self.pdf.resolvedObjects.items() for k, v in i[1].items()}", "code_tokens": "def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "docstring_tokens": "Print security object information for a pdf document", "label": 0}, {"idx": "cosqa-train-4271", "doc": "python creating an object based on clas name", "code": "def str_to_class(class_name):\n    \"\"\"\n    Returns a class based on class name    \n    \"\"\"\n    mod_str, cls_str = class_name.rsplit('.', 1)\n    mod = __import__(mod_str, globals(), locals(), [''])\n    cls = getattr(mod, cls_str)\n    return cls", "code_tokens": "def str_to_class ( class_name ) : mod_str , cls_str = class_name . rsplit ( '.' , 1 ) mod = __import__ ( mod_str , globals ( ) , locals ( ) , [ '' ] ) cls = getattr ( mod , cls_str ) return cls", "docstring_tokens": "Returns a class based on class name", "label": 1}, {"idx": "cosqa-train-4272", "doc": "accessing a column in a matrix python", "code": "def get_column(self, X, column):\n        \"\"\"Return a column of the given matrix.\n\n        Args:\n            X: `numpy.ndarray` or `pandas.DataFrame`.\n            column: `int` or `str`.\n\n        Returns:\n            np.ndarray: Selected column.\n        \"\"\"\n        if isinstance(X, pd.DataFrame):\n            return X[column].values\n\n        return X[:, column]", "code_tokens": "def get_column ( self , X , column ) : if isinstance ( X , pd . DataFrame ) : return X [ column ] . values return X [ : , column ]", "docstring_tokens": "Return a column of the given matrix .", "label": 0}, {"idx": "cosqa-train-4273", "doc": "python csv reader next method", "code": "def next(self):\n        \"\"\"Retrieve the next row.\"\"\"\n        # I'm pretty sure this is the completely wrong way to go about this, but\n        # oh well, this works.\n        if not hasattr(self, '_iter'):\n            self._iter = self.readrow_as_dict()\n        return self._iter.next()", "code_tokens": "def next ( self ) : # I'm pretty sure this is the completely wrong way to go about this, but # oh well, this works. if not hasattr ( self , '_iter' ) : self . _iter = self . readrow_as_dict ( ) return self . _iter . next ( )", "docstring_tokens": "Retrieve the next row .", "label": 0}, {"idx": "cosqa-train-4274", "doc": "add a year to a datetime python", "code": "def move_datetime_year(dt, direction, num_shifts):\n    \"\"\"\n    Move datetime 1 year in the chosen direction.\n    unit is a no-op, to keep the API the same as the day case\n    \"\"\"\n    delta = relativedelta(years=+num_shifts)\n    return _move_datetime(dt, direction, delta)", "code_tokens": "def move_datetime_year ( dt , direction , num_shifts ) : delta = relativedelta ( years = + num_shifts ) return _move_datetime ( dt , direction , delta )", "docstring_tokens": "Move datetime 1 year in the chosen direction . unit is a no - op to keep the API the same as the day case", "label": 0}, {"idx": "cosqa-train-4275", "doc": "python ctypes allocate buffer", "code": "def getBuffer(x):\n    \"\"\"\n    Copy @x into a (modifiable) ctypes byte array\n    \"\"\"\n    b = bytes(x)\n    return (c_ubyte * len(b)).from_buffer_copy(bytes(x))", "code_tokens": "def getBuffer ( x ) : b = bytes ( x ) return ( c_ubyte * len ( b ) ) . from_buffer_copy ( bytes ( x ) )", "docstring_tokens": "Copy", "label": 0}, {"idx": "cosqa-train-4276", "doc": "python ctypes cast void * to structure pointer", "code": "def cint8_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes int pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)):\n        return np.fromiter(cptr, dtype=np.int8, count=length)\n    else:\n        raise RuntimeError('Expected int pointer')", "code_tokens": "def cint8_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int8 ) ) : return np . fromiter ( cptr , dtype = np . int8 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "docstring_tokens": "Convert a ctypes int pointer array to a numpy array .", "label": 0}, {"idx": "cosqa-train-4277", "doc": "add indentations to output with code in python", "code": "def dumped(text, level, indent=2):\n    \"\"\"Put curly brackets round an indented text\"\"\"\n    return indented(\"{\\n%s\\n}\" % indented(text, level + 1, indent) or \"None\", level, indent) + \"\\n\"", "code_tokens": "def dumped ( text , level , indent = 2 ) : return indented ( \"{\\n%s\\n}\" % indented ( text , level + 1 , indent ) or \"None\" , level , indent ) + \"\\n\"", "docstring_tokens": "Put curly brackets round an indented text", "label": 0}, {"idx": "cosqa-train-4278", "doc": "python ctypes float array", "code": "def cfloat32_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes float pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_float)):\n        return np.fromiter(cptr, dtype=np.float32, count=length)\n    else:\n        raise RuntimeError('Expected float pointer')", "code_tokens": "def cfloat32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_float ) ) : return np . fromiter ( cptr , dtype = np . float32 , count = length ) else : raise RuntimeError ( 'Expected float pointer' )", "docstring_tokens": "Convert a ctypes float pointer array to a numpy array .", "label": 0}, {"idx": "cosqa-train-4279", "doc": "add jar path to python", "code": "def version_jar(self):\n\t\t\"\"\"\n\t\tSpecial case of version() when the executable is a JAR file.\n\t\t\"\"\"\n\t\tcmd = config.get_command('java')\n\t\tcmd.append('-jar')\n\t\tcmd += self.cmd\n\t\tself.version(cmd=cmd, path=self.cmd[0])", "code_tokens": "def version_jar ( self ) : cmd = config . get_command ( 'java' ) cmd . append ( '-jar' ) cmd += self . cmd self . version ( cmd = cmd , path = self . cmd [ 0 ] )", "docstring_tokens": "Special case of version () when the executable is a JAR file .", "label": 1}, {"idx": "cosqa-train-4280", "doc": "python ctypes string to c string", "code": "def c_str(string):\n    \"\"\"\"Convert a python string to C string.\"\"\"\n    if not isinstance(string, str):\n        string = string.decode('ascii')\n    return ctypes.c_char_p(string.encode('utf-8'))", "code_tokens": "def c_str ( string ) : if not isinstance ( string , str ) : string = string . decode ( 'ascii' ) return ctypes . c_char_p ( string . encode ( 'utf-8' ) )", "docstring_tokens": "Convert a python string to C string .", "label": 0}, {"idx": "cosqa-train-4281", "doc": "add new line after every write in python", "code": "def write_line(self, line, count=1):\n        \"\"\"writes the line and count newlines after the line\"\"\"\n        self.write(line)\n        self.write_newlines(count)", "code_tokens": "def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )", "docstring_tokens": "writes the line and count newlines after the line", "label": 0}, {"idx": "cosqa-train-4282", "doc": "python ctypes to int", "code": "def cint8_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes int pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)):\n        return np.fromiter(cptr, dtype=np.int8, count=length)\n    else:\n        raise RuntimeError('Expected int pointer')", "code_tokens": "def cint8_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int8 ) ) : return np . fromiter ( cptr , dtype = np . int8 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "docstring_tokens": "Convert a ctypes int pointer array to a numpy array .", "label": 0}, {"idx": "cosqa-train-4283", "doc": "add noise to the images python", "code": "def shot_noise(x, severity=1):\n  \"\"\"Shot noise corruption to images.\n\n  Args:\n    x: numpy array, uncorrupted image, assumed to have uint8 pixel in [0,255].\n    severity: integer, severity of corruption.\n\n  Returns:\n    numpy array, image with uint8 pixels in [0,255]. Added shot noise.\n  \"\"\"\n  c = [60, 25, 12, 5, 3][severity - 1]\n  x = np.array(x) / 255.\n  x_clip = np.clip(np.random.poisson(x * c) / float(c), 0, 1) * 255\n  return around_and_astype(x_clip)", "code_tokens": "def shot_noise ( x , severity = 1 ) : c = [ 60 , 25 , 12 , 5 , 3 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( np . random . poisson ( x * c ) / float ( c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )", "docstring_tokens": "Shot noise corruption to images .", "label": 1}, {"idx": "cosqa-train-4284", "doc": "python custom context manager", "code": "def __enter__(self):\n        \"\"\" Implements the context manager protocol. Specially useful for asserting exceptions\n        \"\"\"\n        clone = self.clone()\n        self._contexts.append(clone)\n        self.reset()\n        return self", "code_tokens": "def __enter__ ( self ) : clone = self . clone ( ) self . _contexts . append ( clone ) self . reset ( ) return self", "docstring_tokens": "Implements the context manager protocol . Specially useful for asserting exceptions", "label": 0}, {"idx": "cosqa-train-4285", "doc": "add python libraries to aws lambda", "code": "def custodian_archive(packages=None):\n    \"\"\"Create a lambda code archive for running custodian.\n\n    Lambda archive currently always includes `c7n` and\n    `pkg_resources`. Add additional packages in the mode block.\n\n    Example policy that includes additional packages\n\n    .. code-block:: yaml\n\n        policy:\n          name: lambda-archive-example\n          resource: s3\n          mode:\n            packages:\n              - botocore\n\n    packages: List of additional packages to include in the lambda archive.\n\n    \"\"\"\n    modules = {'c7n', 'pkg_resources'}\n    if packages:\n        modules = filter(None, modules.union(packages))\n    return PythonPackageArchive(*sorted(modules))", "code_tokens": "def custodian_archive ( packages = None ) : modules = { 'c7n' , 'pkg_resources' } if packages : modules = filter ( None , modules . union ( packages ) ) return PythonPackageArchive ( * sorted ( modules ) )", "docstring_tokens": "Create a lambda code archive for running custodian .", "label": 1}, {"idx": "cosqa-train-4286", "doc": "python cut data into a few intervals", "code": "def group(data, num):\n    \"\"\" Split data into chunks of num chars each \"\"\"\n    return [data[i:i+num] for i in range(0, len(data), num)]", "code_tokens": "def group ( data , num ) : return [ data [ i : i + num ] for i in range ( 0 , len ( data ) , num ) ]", "docstring_tokens": "Split data into chunks of num chars each", "label": 1}, {"idx": "cosqa-train-4287", "doc": "adjacency matrix in python dictioanry", "code": "def get_adjacent_matrix(self):\n        \"\"\"Get adjacency matrix.\n\n        Returns:\n            :param adj: adjacency matrix\n            :type adj: np.ndarray\n        \"\"\"\n        edges = self.edges\n        num_edges = len(edges) + 1\n        adj = np.zeros([num_edges, num_edges])\n\n        for k in range(num_edges - 1):\n            adj[edges[k].L, edges[k].R] = 1\n            adj[edges[k].R, edges[k].L] = 1\n\n        return adj", "code_tokens": "def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj", "docstring_tokens": "Get adjacency matrix .", "label": 0}, {"idx": "cosqa-train-4288", "doc": "python cv2 open raw image file", "code": "def imdecode(image_path):\n    \"\"\"Return BGR image read by opencv\"\"\"\n    import os\n    assert os.path.exists(image_path), image_path + ' not found'\n    im = cv2.imread(image_path)\n    return im", "code_tokens": "def imdecode ( image_path ) : import os assert os . path . exists ( image_path ) , image_path + ' not found' im = cv2 . imread ( image_path ) return im", "docstring_tokens": "Return BGR image read by opencv", "label": 0}, {"idx": "cosqa-train-4289", "doc": "adjust width of columns in xlsx python", "code": "def _xls2col_widths(self, worksheet, tab):\n        \"\"\"Updates col_widths in code_array\"\"\"\n\n        for col in xrange(worksheet.ncols):\n            try:\n                xls_width = worksheet.colinfo_map[col].width\n                pys_width = self.xls_width2pys_width(xls_width)\n                self.code_array.col_widths[col, tab] = pys_width\n\n            except KeyError:\n                pass", "code_tokens": "def _xls2col_widths ( self , worksheet , tab ) : for col in xrange ( worksheet . ncols ) : try : xls_width = worksheet . colinfo_map [ col ] . width pys_width = self . xls_width2pys_width ( xls_width ) self . code_array . col_widths [ col , tab ] = pys_width except KeyError : pass", "docstring_tokens": "Updates col_widths in code_array", "label": 0}, {"idx": "cosqa-train-4290", "doc": "python data frame how to drop a column", "code": "def del_Unnamed(df):\n    \"\"\"\n    Deletes all the unnamed columns\n\n    :param df: pandas dataframe\n    \"\"\"\n    cols_del=[c for c in df.columns if 'Unnamed' in c]\n    return df.drop(cols_del,axis=1)", "code_tokens": "def del_Unnamed ( df ) : cols_del = [ c for c in df . columns if 'Unnamed' in c ] return df . drop ( cols_del , axis = 1 )", "docstring_tokens": "Deletes all the unnamed columns", "label": 1}, {"idx": "cosqa-train-4291", "doc": "all bigquery fields returning as objects python", "code": "def to_query_parameters(parameters):\n    \"\"\"Converts DB-API parameter values into query parameters.\n\n    :type parameters: Mapping[str, Any] or Sequence[Any]\n    :param parameters: A dictionary or sequence of query parameter values.\n\n    :rtype: List[google.cloud.bigquery.query._AbstractQueryParameter]\n    :returns: A list of query parameters.\n    \"\"\"\n    if parameters is None:\n        return []\n\n    if isinstance(parameters, collections_abc.Mapping):\n        return to_query_parameters_dict(parameters)\n\n    return to_query_parameters_list(parameters)", "code_tokens": "def to_query_parameters ( parameters ) : if parameters is None : return [ ] if isinstance ( parameters , collections_abc . Mapping ) : return to_query_parameters_dict ( parameters ) return to_query_parameters_list ( parameters )", "docstring_tokens": "Converts DB - API parameter values into query parameters .", "label": 1}, {"idx": "cosqa-train-4292", "doc": "python date replace month", "code": "def replace_month_abbr_with_num(date_str, lang=DEFAULT_DATE_LANG):\n    \"\"\"Replace month strings occurrences with month number.\"\"\"\n    num, abbr = get_month_from_date_str(date_str, lang)\n    return re.sub(abbr, str(num), date_str, flags=re.IGNORECASE)", "code_tokens": "def replace_month_abbr_with_num ( date_str , lang = DEFAULT_DATE_LANG ) : num , abbr = get_month_from_date_str ( date_str , lang ) return re . sub ( abbr , str ( num ) , date_str , flags = re . IGNORECASE )", "docstring_tokens": "Replace month strings occurrences with month number .", "label": 0}, {"idx": "cosqa-train-4293", "doc": "allow permission to overwrite file python", "code": "def chmod_add_excute(filename):\n        \"\"\"\n        Adds execute permission to file.\n        :param filename:\n        :return:\n        \"\"\"\n        st = os.stat(filename)\n        os.chmod(filename, st.st_mode | stat.S_IEXEC)", "code_tokens": "def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "docstring_tokens": "Adds execute permission to file . : param filename : : return :", "label": 1}, {"idx": "cosqa-train-4294", "doc": "python datetime drop microsecond", "code": "def ToDatetime(self):\n    \"\"\"Converts Timestamp to datetime.\"\"\"\n    return datetime.utcfromtimestamp(\n        self.seconds + self.nanos / float(_NANOS_PER_SECOND))", "code_tokens": "def ToDatetime ( self ) : return datetime . utcfromtimestamp ( self . seconds + self . nanos / float ( _NANOS_PER_SECOND ) )", "docstring_tokens": "Converts Timestamp to datetime .", "label": 0}, {"idx": "cosqa-train-4295", "doc": "amax python for3d numpy aray", "code": "def Max(a, axis, keep_dims):\n    \"\"\"\n    Max reduction op.\n    \"\"\"\n    return np.amax(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis),\n                   keepdims=keep_dims),", "code_tokens": "def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "docstring_tokens": "Max reduction op .", "label": 0}, {"idx": "cosqa-train-4296", "doc": "python datetime from string with timezone", "code": "def parse_datetime(dt_str, format):\n    \"\"\"Create a timezone-aware datetime object from a datetime string.\"\"\"\n    t = time.strptime(dt_str, format)\n    return datetime(t[0], t[1], t[2], t[3], t[4], t[5], t[6], pytz.UTC)", "code_tokens": "def parse_datetime ( dt_str , format ) : t = time . strptime ( dt_str , format ) return datetime ( t [ 0 ] , t [ 1 ] , t [ 2 ] , t [ 3 ] , t [ 4 ] , t [ 5 ] , t [ 6 ] , pytz . UTC )", "docstring_tokens": "Create a timezone - aware datetime object from a datetime string .", "label": 1}, {"idx": "cosqa-train-4297", "doc": "angle between two vectors using python", "code": "def vec_angle(a, b):\n    \"\"\"\n    Calculate angle between two vectors\n    \"\"\"\n    cosang = np.dot(a, b)\n    sinang = fast_norm(np.cross(a, b))\n    return np.arctan2(sinang, cosang)", "code_tokens": "def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )", "docstring_tokens": "Calculate angle between two vectors", "label": 0}, {"idx": "cosqa-train-4298", "doc": "python datetime into posix timestamp", "code": "def date_to_timestamp(date):\n    \"\"\"\n        date to unix timestamp in milliseconds\n    \"\"\"\n    date_tuple = date.timetuple()\n    timestamp = calendar.timegm(date_tuple) * 1000\n    return timestamp", "code_tokens": "def date_to_timestamp ( date ) : date_tuple = date . timetuple ( ) timestamp = calendar . timegm ( date_tuple ) * 1000 return timestamp", "docstring_tokens": "date to unix timestamp in milliseconds", "label": 0}, {"idx": "cosqa-train-4299", "doc": "ansi color sequence for python", "code": "def ansi(color, text):\n    \"\"\"Wrap text in an ansi escape sequence\"\"\"\n    code = COLOR_CODES[color]\n    return '\\033[1;{0}m{1}{2}'.format(code, text, RESET_TERM)", "code_tokens": "def ansi ( color , text ) : code = COLOR_CODES [ color ] return '\\033[1;{0}m{1}{2}' . format ( code , text , RESET_TERM )", "docstring_tokens": "Wrap text in an ansi escape sequence", "label": 0}, {"idx": "cosqa-train-4300", "doc": "python datetime is valid date", "code": "def _converter(self, value):\n        \"\"\"Convert raw input value of the field.\"\"\"\n        if not isinstance(value, datetime.date):\n            raise TypeError('{0} is not valid date'.format(value))\n        return value", "code_tokens": "def _converter ( self , value ) : if not isinstance ( value , datetime . date ) : raise TypeError ( '{0} is not valid date' . format ( value ) ) return value", "docstring_tokens": "Convert raw input value of the field .", "label": 0}, {"idx": "cosqa-train-4301", "doc": "append to a map in python", "code": "def set_as_object(self, value):\n        \"\"\"\n        Sets a new value to map element\n\n        :param value: a new element or map value.\n        \"\"\"\n        self.clear()\n        map = MapConverter.to_map(value)\n        self.append(map)", "code_tokens": "def set_as_object ( self , value ) : self . clear ( ) map = MapConverter . to_map ( value ) self . append ( map )", "docstring_tokens": "Sets a new value to map element", "label": 0}, {"idx": "cosqa-train-4302", "doc": "python datetime milliseconds to utc", "code": "def datetime_to_timestamp(dt):\n    \"\"\"Convert a UTC datetime to a Unix timestamp\"\"\"\n    delta = dt - datetime.utcfromtimestamp(0)\n    return delta.seconds + delta.days * 24 * 3600", "code_tokens": "def datetime_to_timestamp ( dt ) : delta = dt - datetime . utcfromtimestamp ( 0 ) return delta . seconds + delta . days * 24 * 3600", "docstring_tokens": "Convert a UTC datetime to a Unix timestamp", "label": 0}, {"idx": "cosqa-train-4303", "doc": "apply dictionary to replace letter in string python", "code": "def replace_all(text, dic):\n    \"\"\"Takes a string and dictionary. replaces all occurrences of i with j\"\"\"\n\n    for i, j in dic.iteritems():\n        text = text.replace(i, j)\n    return text", "code_tokens": "def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text", "docstring_tokens": "Takes a string and dictionary . replaces all occurrences of i with j", "label": 0}, {"idx": "cosqa-train-4304", "doc": "python datetime subtract timezone", "code": "def to_pydatetime(self):\n        \"\"\"\n        Converts datetimeoffset object into Python's datetime.datetime object\n        @return: time zone aware datetime.datetime\n        \"\"\"\n        dt = datetime.datetime.combine(self._date.to_pydate(), self._time.to_pytime())\n        from .tz import FixedOffsetTimezone\n        return dt.replace(tzinfo=_utc).astimezone(FixedOffsetTimezone(self._offset))", "code_tokens": "def to_pydatetime ( self ) : dt = datetime . datetime . combine ( self . _date . to_pydate ( ) , self . _time . to_pytime ( ) ) from . tz import FixedOffsetTimezone return dt . replace ( tzinfo = _utc ) . astimezone ( FixedOffsetTimezone ( self . _offset ) )", "docstring_tokens": "Converts datetimeoffset object into Python s datetime . datetime object", "label": 0}, {"idx": "cosqa-train-4305", "doc": "apply function in python to normalize data containing strings", "code": "def normalize(self, string):\n        \"\"\"Normalize the string according to normalization list\"\"\"\n        return ''.join([self._normalize.get(x, x) for x in nfd(string)])", "code_tokens": "def normalize ( self , string ) : return '' . join ( [ self . _normalize . get ( x , x ) for x in nfd ( string ) ] )", "docstring_tokens": "Normalize the string according to normalization list", "label": 0}, {"idx": "cosqa-train-4306", "doc": "python datetime to milliseconds since epoch", "code": "def _DateToEpoch(date):\n  \"\"\"Converts python datetime to epoch microseconds.\"\"\"\n  tz_zero = datetime.datetime.utcfromtimestamp(0)\n  diff_sec = int((date - tz_zero).total_seconds())\n  return diff_sec * 1000000", "code_tokens": "def _DateToEpoch ( date ) : tz_zero = datetime . datetime . utcfromtimestamp ( 0 ) diff_sec = int ( ( date - tz_zero ) . total_seconds ( ) ) return diff_sec * 1000000", "docstring_tokens": "Converts python datetime to epoch microseconds .", "label": 0}, {"idx": "cosqa-train-4307", "doc": "apply logging filter to all loggers python", "code": "def __enter__(self):\n        \"\"\"Enable the download log filter.\"\"\"\n        self.logger = logging.getLogger('pip.download')\n        self.logger.addFilter(self)", "code_tokens": "def __enter__ ( self ) : self . logger = logging . getLogger ( 'pip.download' ) self . logger . addFilter ( self )", "docstring_tokens": "Enable the download log filter .", "label": 0}, {"idx": "cosqa-train-4308", "doc": "python datetime to utc time", "code": "def datetime_local_to_utc(local):\n    \"\"\"\n    Simple function to convert naive :std:`datetime.datetime` object containing\n    local time to a naive :std:`datetime.datetime` object with UTC time.\n    \"\"\"\n    timestamp = time.mktime(local.timetuple())\n    return datetime.datetime.utcfromtimestamp(timestamp)", "code_tokens": "def datetime_local_to_utc ( local ) : timestamp = time . mktime ( local . timetuple ( ) ) return datetime . datetime . utcfromtimestamp ( timestamp )", "docstring_tokens": "Simple function to convert naive : std : datetime . datetime object containing local time to a naive : std : datetime . datetime object with UTC time .", "label": 0}, {"idx": "cosqa-train-4309", "doc": "area of triangle cross product in numpy python", "code": "def triangle_area(pt1, pt2, pt3):\n    r\"\"\"Return the area of a triangle.\n\n    Parameters\n    ----------\n    pt1: (X,Y) ndarray\n        Starting vertex of a triangle\n    pt2: (X,Y) ndarray\n        Second vertex of a triangle\n    pt3: (X,Y) ndarray\n        Ending vertex of a triangle\n\n    Returns\n    -------\n    area: float\n        Area of the given triangle.\n\n    \"\"\"\n    a = 0.0\n\n    a += pt1[0] * pt2[1] - pt2[0] * pt1[1]\n    a += pt2[0] * pt3[1] - pt3[0] * pt2[1]\n    a += pt3[0] * pt1[1] - pt1[0] * pt3[1]\n\n    return abs(a) / 2", "code_tokens": "def triangle_area ( pt1 , pt2 , pt3 ) : a = 0.0 a += pt1 [ 0 ] * pt2 [ 1 ] - pt2 [ 0 ] * pt1 [ 1 ] a += pt2 [ 0 ] * pt3 [ 1 ] - pt3 [ 0 ] * pt2 [ 1 ] a += pt3 [ 0 ] * pt1 [ 1 ] - pt1 [ 0 ] * pt3 [ 1 ] return abs ( a ) / 2", "docstring_tokens": "r Return the area of a triangle .", "label": 1}, {"idx": "cosqa-train-4310", "doc": "python datetime with nano second and timezone", "code": "def ToDatetime(self):\n    \"\"\"Converts Timestamp to datetime.\"\"\"\n    return datetime.utcfromtimestamp(\n        self.seconds + self.nanos / float(_NANOS_PER_SECOND))", "code_tokens": "def ToDatetime ( self ) : return datetime . utcfromtimestamp ( self . seconds + self . nanos / float ( _NANOS_PER_SECOND ) )", "docstring_tokens": "Converts Timestamp to datetime .", "label": 0}, {"idx": "cosqa-train-4311", "doc": "argparse how to make a arguement the default python", "code": "def parse_command_args():\n    \"\"\"Command line parser.\"\"\"\n    parser = argparse.ArgumentParser(description='Register PB devices.')\n    parser.add_argument('num_pb', type=int,\n                        help='Number of PBs devices to register.')\n    return parser.parse_args()", "code_tokens": "def parse_command_args ( ) : parser = argparse . ArgumentParser ( description = 'Register PB devices.' ) parser . add_argument ( 'num_pb' , type = int , help = 'Number of PBs devices to register.' ) return parser . parse_args ( )", "docstring_tokens": "Command line parser .", "label": 1}, {"idx": "cosqa-train-4312", "doc": "python datetimes get quarter", "code": "def previous_quarter(d):\n    \"\"\"\n    Retrieve the previous quarter for dt\n    \"\"\"\n    from django_toolkit.datetime_util import quarter as datetime_quarter\n    return quarter( (datetime_quarter(datetime(d.year, d.month, d.day))[0] + timedelta(days=-1)).date() )", "code_tokens": "def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )", "docstring_tokens": "Retrieve the previous quarter for dt", "label": 0}, {"idx": "cosqa-train-4313", "doc": "array length in python django", "code": "def __len__(self):\n        \"\"\" This will equal 124 for the V1 database. \"\"\"\n        length = 0\n        for typ, siz, _ in self.format:\n            length += siz\n        return length", "code_tokens": "def __len__ ( self ) : length = 0 for typ , siz , _ in self . format : length += siz return length", "docstring_tokens": "This will equal 124 for the V1 database .", "label": 0}, {"idx": "cosqa-train-4314", "doc": "python decoding a single byte to an int", "code": "def string_to_int( s ):\n  \"\"\"Convert a string of bytes into an integer, as per X9.62.\"\"\"\n  result = 0\n  for c in s:\n    if not isinstance(c, int): c = ord( c )\n    result = 256 * result + c\n  return result", "code_tokens": "def string_to_int ( s ) : result = 0 for c in s : if not isinstance ( c , int ) : c = ord ( c ) result = 256 * result + c return result", "docstring_tokens": "Convert a string of bytes into an integer as per X9 . 62 .", "label": 0}, {"idx": "cosqa-train-4315", "doc": "array minus last n elements python", "code": "def tail(self, n=10):\n        \"\"\"\n        Get an SArray that contains the last n elements in the SArray.\n\n        Parameters\n        ----------\n        n : int\n            The number of elements to fetch\n\n        Returns\n        -------\n        out : SArray\n            A new SArray which contains the last n rows of the current SArray.\n        \"\"\"\n        with cython_context():\n            return SArray(_proxy=self.__proxy__.tail(n))", "code_tokens": "def tail ( self , n = 10 ) : with cython_context ( ) : return SArray ( _proxy = self . __proxy__ . tail ( n ) )", "docstring_tokens": "Get an SArray that contains the last n elements in the SArray .", "label": 1}, {"idx": "cosqa-train-4316", "doc": "array to scalar comparison python", "code": "def is_scalar(value):\n    \"\"\"Test if the given value is a scalar.\n\n    This function also works with memory mapped array values, in contrast to the numpy is_scalar method.\n\n    Args:\n        value: the value to test for being a scalar value\n\n    Returns:\n        boolean: if the given value is a scalar or not\n    \"\"\"\n    return np.isscalar(value) or (isinstance(value, np.ndarray) and (len(np.squeeze(value).shape) == 0))", "code_tokens": "def is_scalar ( value ) : return np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and ( len ( np . squeeze ( value ) . shape ) == 0 ) )", "docstring_tokens": "Test if the given value is a scalar .", "label": 0}, {"idx": "cosqa-train-4317", "doc": "python dedupe list with order", "code": "def purge_duplicates(list_in):\n    \"\"\"Remove duplicates from list while preserving order.\n\n    Parameters\n    ----------\n    list_in: Iterable\n\n    Returns\n    -------\n    list\n        List of first occurences in order\n    \"\"\"\n    _list = []\n    for item in list_in:\n        if item not in _list:\n            _list.append(item)\n    return _list", "code_tokens": "def purge_duplicates ( list_in ) : _list = [ ] for item in list_in : if item not in _list : _list . append ( item ) return _list", "docstring_tokens": "Remove duplicates from list while preserving order .", "label": 0}, {"idx": "cosqa-train-4318", "doc": "ask if a method can see a variable python", "code": "def is_parameter(self):\n        \"\"\"Whether this is a function parameter.\"\"\"\n        return (isinstance(self.scope, CodeFunction)\n                and self in self.scope.parameters)", "code_tokens": "def is_parameter ( self ) : return ( isinstance ( self . scope , CodeFunction ) and self in self . scope . parameters )", "docstring_tokens": "Whether this is a function parameter .", "label": 1}, {"idx": "cosqa-train-4319", "doc": "python default to nothing", "code": "def input_int_default(question=\"\", default=0):\n    \"\"\"A function that works for both, Python 2.x and Python 3.x.\n       It asks the user for input and returns it as a string.\n    \"\"\"\n    answer = input_string(question)\n    if answer == \"\" or answer == \"yes\":\n        return default\n    else:\n        return int(answer)", "code_tokens": "def input_int_default ( question = \"\" , default = 0 ) : answer = input_string ( question ) if answer == \"\" or answer == \"yes\" : return default else : return int ( answer )", "docstring_tokens": "A function that works for both Python 2 . x and Python 3 . x . It asks the user for input and returns it as a string .", "label": 0}, {"idx": "cosqa-train-4320", "doc": "aspect ratio python figures", "code": "def figsize(x=8, y=7., aspect=1.):\n    \"\"\" manually set the default figure size of plots\n    ::Arguments::\n        x (float): x-axis size\n        y (float): y-axis size\n        aspect (float): aspect ratio scalar\n    \"\"\"\n    # update rcparams with adjusted figsize params\n    mpl.rcParams.update({'figure.figsize': (x*aspect, y)})", "code_tokens": "def figsize ( x = 8 , y = 7. , aspect = 1. ) : # update rcparams with adjusted figsize params mpl . rcParams . update ( { 'figure.figsize' : ( x * aspect , y ) } )", "docstring_tokens": "manually set the default figure size of plots :: Arguments :: x ( float ) : x - axis size y ( float ) : y - axis size aspect ( float ) : aspect ratio scalar", "label": 0}, {"idx": "cosqa-train-4321", "doc": "python define function within a functino", "code": "def export(defn):\n    \"\"\"Decorator to explicitly mark functions that are exposed in a lib.\"\"\"\n    globals()[defn.__name__] = defn\n    __all__.append(defn.__name__)\n    return defn", "code_tokens": "def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "docstring_tokens": "Decorator to explicitly mark functions that are exposed in a lib .", "label": 0}, {"idx": "cosqa-train-4322", "doc": "assert function with a list and an int python", "code": "def assert_list(self, putative_list, expected_type=string_types, key_arg=None):\n    \"\"\"\n    :API: public\n    \"\"\"\n    return assert_list(putative_list, expected_type, key_arg=key_arg,\n                       raise_type=lambda msg: TargetDefinitionException(self, msg))", "code_tokens": "def assert_list ( self , putative_list , expected_type = string_types , key_arg = None ) : return assert_list ( putative_list , expected_type , key_arg = key_arg , raise_type = lambda msg : TargetDefinitionException ( self , msg ) )", "docstring_tokens": ": API : public", "label": 0}, {"idx": "cosqa-train-4323", "doc": "python delet a cell", "code": "def delete_cell(self,  key):\n        \"\"\"Deletes key cell\"\"\"\n\n        try:\n            self.code_array.pop(key)\n\n        except KeyError:\n            pass\n\n        self.grid.code_array.result_cache.clear()", "code_tokens": "def delete_cell ( self , key ) : try : self . code_array . pop ( key ) except KeyError : pass self . grid . code_array . result_cache . clear ( )", "docstring_tokens": "Deletes key cell", "label": 1}, {"idx": "cosqa-train-4324", "doc": "assertion error python how to solve", "code": "def process_instance(self, instance):\n        self.log.debug(\"e = mc^2\")\n        self.log.info(\"About to fail..\")\n        self.log.warning(\"Failing.. soooon..\")\n        self.log.critical(\"Ok, you're done.\")\n        assert False, \"\"\"ValidateFailureMock was destined to fail..\n\nHere's some extended information about what went wrong.\n\nIt has quite the long string associated with it, including\na few newlines and a list.\n\n- Item 1\n- Item 2\n\n\"\"\"", "code_tokens": "def process_instance ( self , instance ) : self . log . debug ( \"e = mc^2\" ) self . log . info ( \"About to fail..\" ) self . log . warning ( \"Failing.. soooon..\" ) self . log . critical ( \"Ok, you're done.\" ) assert False , \"\"\"ValidateFailureMock was destined to fail..\n\nHere's some extended information about what went wrong.\n\nIt has quite the long string associated with it, including\na few newlines and a list.\n\n- Item 1\n- Item 2\n\n\"\"\"", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-4325", "doc": "python delete a singleton", "code": "def pop():\n        \"\"\"Remove instance from instance list\"\"\"\n        pid = os.getpid()\n        thread = threading.current_thread()\n        Wdb._instances.pop((pid, thread))", "code_tokens": "def pop ( ) : pid = os . getpid ( ) thread = threading . current_thread ( ) Wdb . _instances . pop ( ( pid , thread ) )", "docstring_tokens": "Remove instance from instance list", "label": 0}, {"idx": "cosqa-train-4326", "doc": "asyncio python synchronous access", "code": "def runcoro(async_function):\n    \"\"\"\n    Runs an asynchronous function without needing to use await - useful for lambda\n\n    Args:\n        async_function (Coroutine): The asynchronous function to run\n    \"\"\"\n\n    future = _asyncio.run_coroutine_threadsafe(async_function, client.loop)\n    result = future.result()\n    return result", "code_tokens": "def runcoro ( async_function ) : future = _asyncio . run_coroutine_threadsafe ( async_function , client . loop ) result = future . result ( ) return result", "docstring_tokens": "Runs an asynchronous function without needing to use await - useful for lambda", "label": 1}, {"idx": "cosqa-train-4327", "doc": "python delete directory not empty", "code": "def safe_rmtree(directory):\n  \"\"\"Delete a directory if it's present. If it's not present, no-op.\"\"\"\n  if os.path.exists(directory):\n    shutil.rmtree(directory, True)", "code_tokens": "def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )", "docstring_tokens": "Delete a directory if it s present . If it s not present no - op .", "label": 0}, {"idx": "cosqa-train-4328", "doc": "att tzinfo to datetime python", "code": "def datetime_from_timestamp(timestamp, content):\n    \"\"\"\n    Helper function to add timezone information to datetime,\n    so that datetime is comparable to other datetime objects in recent versions\n    that now also have timezone information.\n    \"\"\"\n    return set_date_tzinfo(\n        datetime.fromtimestamp(timestamp),\n        tz_name=content.settings.get('TIMEZONE', None))", "code_tokens": "def datetime_from_timestamp ( timestamp , content ) : return set_date_tzinfo ( datetime . fromtimestamp ( timestamp ) , tz_name = content . settings . get ( 'TIMEZONE' , None ) )", "docstring_tokens": "Helper function to add timezone information to datetime so that datetime is comparable to other datetime objects in recent versions that now also have timezone information .", "label": 0}, {"idx": "cosqa-train-4329", "doc": "python delete item from deque", "code": "def remove(self, key):\n        \"\"\"remove the value found at key from the queue\"\"\"\n        item = self.item_finder.pop(key)\n        item[-1] = None\n        self.removed_count += 1", "code_tokens": "def remove ( self , key ) : item = self . item_finder . pop ( key ) item [ - 1 ] = None self . removed_count += 1", "docstring_tokens": "remove the value found at key from the queue", "label": 0}, {"idx": "cosqa-train-4330", "doc": "python deleting rows with empty variables", "code": "def drop_empty(rows):\n    \"\"\"Transpose the columns into rows, remove all of the rows that are empty after the first cell, then\n    transpose back. The result is that columns that have a header but no data in the body are removed, assuming\n    the header is the first row. \"\"\"\n    return zip(*[col for col in zip(*rows) if bool(filter(bool, col[1:]))])", "code_tokens": "def drop_empty ( rows ) : return zip ( * [ col for col in zip ( * rows ) if bool ( filter ( bool , col [ 1 : ] ) ) ] )", "docstring_tokens": "Transpose the columns into rows remove all of the rows that are empty after the first cell then transpose back . The result is that columns that have a header but no data in the body are removed assuming the header is the first row .", "label": 0}, {"idx": "cosqa-train-4331", "doc": "aws compiled python to lambda", "code": "def lambda_from_file(python_file):\n    \"\"\"\n    Reads a python file and returns a awslambda.Code object\n    :param python_file:\n    :return:\n    \"\"\"\n    lambda_function = []\n    with open(python_file, 'r') as f:\n        lambda_function.extend(f.read().splitlines())\n\n    return awslambda.Code(ZipFile=(Join('\\n', lambda_function)))", "code_tokens": "def lambda_from_file ( python_file ) : lambda_function = [ ] with open ( python_file , 'r' ) as f : lambda_function . extend ( f . read ( ) . splitlines ( ) ) return awslambda . Code ( ZipFile = ( Join ( '\\n' , lambda_function ) ) )", "docstring_tokens": "Reads a python file and returns a awslambda . Code object : param python_file : : return :", "label": 0}, {"idx": "cosqa-train-4332", "doc": "python desiredcapabilities chrome useragent", "code": "def copy_user_agent_from_driver(self):\n        \"\"\" Updates requests' session user-agent with the driver's user agent\n\n        This method will start the browser process if its not already running.\n        \"\"\"\n        selenium_user_agent = self.driver.execute_script(\"return navigator.userAgent;\")\n        self.headers.update({\"user-agent\": selenium_user_agent})", "code_tokens": "def copy_user_agent_from_driver ( self ) : selenium_user_agent = self . driver . execute_script ( \"return navigator.userAgent;\" ) self . headers . update ( { \"user-agent\" : selenium_user_agent } )", "docstring_tokens": "Updates requests session user - agent with the driver s user agent", "label": 0}, {"idx": "cosqa-train-4333", "doc": "axesgrid every subplot has its x and y axis python", "code": "def show_xticklabels(self, row, column):\n        \"\"\"Show the x-axis tick labels for a subplot.\n\n        :param row,column: specify the subplot.\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.show_xticklabels()", "code_tokens": "def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "docstring_tokens": "Show the x - axis tick labels for a subplot .", "label": 0}, {"idx": "cosqa-train-4334", "doc": "axisobject set xlim python", "code": "def set_xlimits_widgets(self, set_min=True, set_max=True):\n        \"\"\"Populate axis limits GUI with current plot values.\"\"\"\n        xmin, xmax = self.tab_plot.ax.get_xlim()\n        if set_min:\n            self.w.x_lo.set_text('{0}'.format(xmin))\n        if set_max:\n            self.w.x_hi.set_text('{0}'.format(xmax))", "code_tokens": "def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )", "docstring_tokens": "Populate axis limits GUI with current plot values .", "label": 0}, {"idx": "cosqa-train-4335", "doc": "python detect if self networking is alive", "code": "def is_connected(self):\n        \"\"\"\n        Return true if the socket managed by this connection is connected\n\n        :rtype: bool\n        \"\"\"\n        try:\n            return self.socket is not None and self.socket.getsockname()[1] != 0 and BaseTransport.is_connected(self)\n        except socket.error:\n            return False", "code_tokens": "def is_connected ( self ) : try : return self . socket is not None and self . socket . getsockname ( ) [ 1 ] != 0 and BaseTransport . is_connected ( self ) except socket . error : return False", "docstring_tokens": "Return true if the socket managed by this connection is connected", "label": 0}, {"idx": "cosqa-train-4336", "doc": "bearing calculation python using lat and long", "code": "def get_lons_from_cartesian(x__, y__):\n    \"\"\"Get longitudes from cartesian coordinates.\n    \"\"\"\n    return rad2deg(arccos(x__ / sqrt(x__ ** 2 + y__ ** 2))) * sign(y__)", "code_tokens": "def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )", "docstring_tokens": "Get longitudes from cartesian coordinates .", "label": 0}, {"idx": "cosqa-train-4337", "doc": "python detect interactive mode", "code": "def determine_interactive(self):\n\t\t\"\"\"Determine whether we're in an interactive shell.\n\t\tSets interactivity off if appropriate.\n\t\tcf http://stackoverflow.com/questions/24861351/how-to-detect-if-python-script-is-being-run-as-a-background-process\n\t\t\"\"\"\n\t\ttry:\n\t\t\tif not sys.stdout.isatty() or os.getpgrp() != os.tcgetpgrp(sys.stdout.fileno()):\n\t\t\t\tself.interactive = 0\n\t\t\t\treturn False\n\t\texcept Exception:\n\t\t\tself.interactive = 0\n\t\t\treturn False\n\t\tif self.interactive == 0:\n\t\t\treturn False\n\t\treturn True", "code_tokens": "def determine_interactive ( self ) : try : if not sys . stdout . isatty ( ) or os . getpgrp ( ) != os . tcgetpgrp ( sys . stdout . fileno ( ) ) : self . interactive = 0 return False except Exception : self . interactive = 0 return False if self . interactive == 0 : return False return True", "docstring_tokens": "Determine whether we re in an interactive shell . Sets interactivity off if appropriate . cf http : // stackoverflow . com / questions / 24861351 / how - to - detect - if - python - script - is - being - run - as - a - background - process", "label": 1}, {"idx": "cosqa-train-4338", "doc": "best way to read xml in python", "code": "def xmltreefromfile(filename):\n    \"\"\"Internal function to read an XML file\"\"\"\n    try:\n        return ElementTree.parse(filename, ElementTree.XMLParser(collect_ids=False))\n    except TypeError:\n        return ElementTree.parse(filename, ElementTree.XMLParser())", "code_tokens": "def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )", "docstring_tokens": "Internal function to read an XML file", "label": 1}, {"idx": "cosqa-train-4339", "doc": "best way to swap rows in a matrix in python for partial pivoting", "code": "def _swap_rows(self, i, j):\n        \"\"\"Swap i and j rows\n\n        As the side effect, determinant flips.\n\n        \"\"\"\n\n        L = np.eye(3, dtype='intc')\n        L[i, i] = 0\n        L[j, j] = 0\n        L[i, j] = 1\n        L[j, i] = 1\n        self._L.append(L.copy())\n        self._A = np.dot(L, self._A)", "code_tokens": "def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )", "docstring_tokens": "Swap i and j rows", "label": 0}, {"idx": "cosqa-train-4340", "doc": "python detect pid exist", "code": "def pid_exists(pid):\n    \"\"\" Determines if a system process identifer exists in process table.\n        \"\"\"\n    try:\n        os.kill(pid, 0)\n    except OSError as exc:\n        return exc.errno == errno.EPERM\n    else:\n        return True", "code_tokens": "def pid_exists ( pid ) : try : os . kill ( pid , 0 ) except OSError as exc : return exc . errno == errno . EPERM else : return True", "docstring_tokens": "Determines if a system process identifer exists in process table .", "label": 0}, {"idx": "cosqa-train-4341", "doc": "bigquery python create table from query", "code": "def create_bigquery_table(self, database, schema, table_name, callback,\n                              sql):\n        \"\"\"Create a bigquery table. The caller must supply a callback\n        that takes one argument, a `google.cloud.bigquery.Table`, and mutates\n        it.\n        \"\"\"\n        conn = self.get_thread_connection()\n        client = conn.handle\n\n        view_ref = self.table_ref(database, schema, table_name, conn)\n        view = google.cloud.bigquery.Table(view_ref)\n        callback(view)\n\n        with self.exception_handler(sql):\n            client.create_table(view)", "code_tokens": "def create_bigquery_table ( self , database , schema , table_name , callback , sql ) : conn = self . get_thread_connection ( ) client = conn . handle view_ref = self . table_ref ( database , schema , table_name , conn ) view = google . cloud . bigquery . Table ( view_ref ) callback ( view ) with self . exception_handler ( sql ) : client . create_table ( view )", "docstring_tokens": "Create a bigquery table . The caller must supply a callback that takes one argument a google . cloud . bigquery . Table and mutates it .", "label": 1}, {"idx": "cosqa-train-4342", "doc": "python determine file extensions", "code": "def _guess_extract_method(fname):\n  \"\"\"Guess extraction method, given file name (or path).\"\"\"\n  for method, extensions in _EXTRACTION_METHOD_TO_EXTS:\n    for ext in extensions:\n      if fname.endswith(ext):\n        return method\n  return ExtractMethod.NO_EXTRACT", "code_tokens": "def _guess_extract_method ( fname ) : for method , extensions in _EXTRACTION_METHOD_TO_EXTS : for ext in extensions : if fname . endswith ( ext ) : return method return ExtractMethod . NO_EXTRACT", "docstring_tokens": "Guess extraction method given file name ( or path ) .", "label": 0}, {"idx": "cosqa-train-4343", "doc": "blender python dot notation to bracket string", "code": "def _dotify(cls, data):\n    \"\"\"Add dots.\"\"\"\n    return ''.join(char if char in cls.PRINTABLE_DATA else '.' for char in data)", "code_tokens": "def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )", "docstring_tokens": "Add dots .", "label": 0}, {"idx": "cosqa-train-4344", "doc": "python determine how matrix is singuar", "code": "def is_sparse_vector(x):\n    \"\"\" x is a 2D sparse matrix with it's first shape equal to 1.\n    \"\"\"\n    return sp.issparse(x) and len(x.shape) == 2 and x.shape[0] == 1", "code_tokens": "def is_sparse_vector ( x ) : return sp . issparse ( x ) and len ( x . shape ) == 2 and x . shape [ 0 ] == 1", "docstring_tokens": "x is a 2D sparse matrix with it s first shape equal to 1 .", "label": 0}, {"idx": "cosqa-train-4345", "doc": "boost python compiled python code", "code": "def xeval(source, optimize=True):\n    \"\"\"Compiles to native Python bytecode and runs program, returning the\n    topmost value on the stack.\n\n    Args:\n        optimize: Whether to optimize the code after parsing it.\n\n    Returns:\n        None: If the stack is empty\n        obj: If the stack contains a single value\n        [obj, obj, ...]: If the stack contains many values\n    \"\"\"\n    native = xcompile(source, optimize=optimize)\n    return native()", "code_tokens": "def xeval ( source , optimize = True ) : native = xcompile ( source , optimize = optimize ) return native ( )", "docstring_tokens": "Compiles to native Python bytecode and runs program returning the topmost value on the stack .", "label": 0}, {"idx": "cosqa-train-4346", "doc": "python determine if enum has key/value pair", "code": "def check(self, var):\n        \"\"\"Check whether the provided value is a valid enum constant.\"\"\"\n        if not isinstance(var, _str_type): return False\n        return _enum_mangle(var) in self._consts", "code_tokens": "def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts", "docstring_tokens": "Check whether the provided value is a valid enum constant .", "label": 0}, {"idx": "cosqa-train-4347", "doc": "bootstrap sampling with variable subsets in python", "code": "def bootstrap_indexes(data, n_samples=10000):\n    \"\"\"\nGiven data points data, where axis 0 is considered to delineate points, return\nan generator for sets of bootstrap indexes. This can be used as a list\nof bootstrap indexes (with list(bootstrap_indexes(data))) as well.\n    \"\"\"\n    for _ in xrange(n_samples):\n        yield randint(data.shape[0], size=(data.shape[0],))", "code_tokens": "def bootstrap_indexes ( data , n_samples = 10000 ) : for _ in xrange ( n_samples ) : yield randint ( data . shape [ 0 ] , size = ( data . shape [ 0 ] , ) )", "docstring_tokens": "Given data points data where axis 0 is considered to delineate points return an generator for sets of bootstrap indexes . This can be used as a list of bootstrap indexes ( with list ( bootstrap_indexes ( data ))) as well .", "label": 0}, {"idx": "cosqa-train-4348", "doc": "python determine if inside functions", "code": "def is_callable(*p):\n    \"\"\" True if all the args are functions and / or subroutines\n    \"\"\"\n    import symbols\n    return all(isinstance(x, symbols.FUNCTION) for x in p)", "code_tokens": "def is_callable ( * p ) : import symbols return all ( isinstance ( x , symbols . FUNCTION ) for x in p )", "docstring_tokens": "True if all the args are functions and / or subroutines", "label": 0}, {"idx": "cosqa-train-4349", "doc": "boto3 python list ec2 instances in multiple accounts", "code": "def _aws_get_instance_by_tag(region, name, tag, raw):\n    \"\"\"Get all instances matching a tag.\"\"\"\n    client = boto3.session.Session().client('ec2', region)\n    matching_reservations = client.describe_instances(Filters=[{'Name': tag, 'Values': [name]}]).get('Reservations', [])\n    instances = []\n    [[instances.append(_aws_instance_from_dict(region, instance, raw))  # pylint: disable=expression-not-assigned\n      for instance in reservation.get('Instances')] for reservation in matching_reservations if reservation]\n    return instances", "code_tokens": "def _aws_get_instance_by_tag ( region , name , tag , raw ) : client = boto3 . session . Session ( ) . client ( 'ec2' , region ) matching_reservations = client . describe_instances ( Filters = [ { 'Name' : tag , 'Values' : [ name ] } ] ) . get ( 'Reservations' , [ ] ) instances = [ ] [ [ instances . append ( _aws_instance_from_dict ( region , instance , raw ) ) # pylint: disable=expression-not-assigned for instance in reservation . get ( 'Instances' ) ] for reservation in matching_reservations if reservation ] return instances", "docstring_tokens": "Get all instances matching a tag .", "label": 0}, {"idx": "cosqa-train-4350", "doc": "python determine if string is file with file extension", "code": "def is_image(filename):\n    \"\"\"Determine if given filename is an image.\"\"\"\n    # note: isfile() also accepts symlinks\n    return os.path.isfile(filename) and filename.lower().endswith(ImageExts)", "code_tokens": "def is_image ( filename ) : # note: isfile() also accepts symlinks return os . path . isfile ( filename ) and filename . lower ( ) . endswith ( ImageExts )", "docstring_tokens": "Determine if given filename is an image .", "label": 1}, {"idx": "cosqa-train-4351", "doc": "bottle python static files", "code": "def default_static_path():\n    \"\"\"\n        Return the path to the javascript bundle\n    \"\"\"\n    fdir = os.path.dirname(__file__)\n    return os.path.abspath(os.path.join(fdir, '../assets/'))", "code_tokens": "def default_static_path ( ) : fdir = os . path . dirname ( __file__ ) return os . path . abspath ( os . path . join ( fdir , '../assets/' ) )", "docstring_tokens": "Return the path to the javascript bundle", "label": 0}, {"idx": "cosqa-train-4352", "doc": "python determine the width of a character", "code": "def display_len(text):\n    \"\"\"\n    Get the display length of a string. This can differ from the character\n    length if the string contains wide characters.\n    \"\"\"\n    text = unicodedata.normalize('NFD', text)\n    return sum(char_width(char) for char in text)", "code_tokens": "def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )", "docstring_tokens": "Get the display length of a string . This can differ from the character length if the string contains wide characters .", "label": 0}, {"idx": "cosqa-train-4353", "doc": "boxplot for multiple columns python", "code": "def compute_boxplot(self, series):\n        \"\"\"\n        Compute boxplot for given pandas Series.\n        \"\"\"\n        from matplotlib.cbook import boxplot_stats\n        series = series[series.notnull()]\n        if len(series.values) == 0:\n            return {}\n        elif not is_numeric_dtype(series):\n            return self.non_numeric_stats(series)\n        stats = boxplot_stats(list(series.values))[0]\n        stats['count'] = len(series.values)\n        stats['fliers'] = \"|\".join(map(str, stats['fliers']))\n        return stats", "code_tokens": "def compute_boxplot ( self , series ) : from matplotlib . cbook import boxplot_stats series = series [ series . notnull ( ) ] if len ( series . values ) == 0 : return { } elif not is_numeric_dtype ( series ) : return self . non_numeric_stats ( series ) stats = boxplot_stats ( list ( series . values ) ) [ 0 ] stats [ 'count' ] = len ( series . values ) stats [ 'fliers' ] = \"|\" . join ( map ( str , stats [ 'fliers' ] ) ) return stats", "docstring_tokens": "Compute boxplot for given pandas Series .", "label": 0}, {"idx": "cosqa-train-4354", "doc": "python determning if file is text", "code": "def IsBinary(self, filename):\n\t\t\"\"\"Returns true if the guessed mimetyped isnt't in text group.\"\"\"\n\t\tmimetype = mimetypes.guess_type(filename)[0]\n\t\tif not mimetype:\n\t\t\treturn False  # e.g. README, \"real\" binaries usually have an extension\n\t\t# special case for text files which don't start with text/\n\t\tif mimetype in TEXT_MIMETYPES:\n\t\t\treturn False\n\t\treturn not mimetype.startswith(\"text/\")", "code_tokens": "def IsBinary ( self , filename ) : mimetype = mimetypes . guess_type ( filename ) [ 0 ] if not mimetype : return False # e.g. README, \"real\" binaries usually have an extension # special case for text files which don't start with text/ if mimetype in TEXT_MIMETYPES : return False return not mimetype . startswith ( \"text/\" )", "docstring_tokens": "Returns true if the guessed mimetyped isnt t in text group .", "label": 0}, {"idx": "cosqa-train-4355", "doc": "bring an item to the front of a list python", "code": "def list_move_to_front(l,value='other'):\n    \"\"\"if the value is in the list, move it to the front and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n        l.insert(0,value)\n    return l", "code_tokens": "def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l", "docstring_tokens": "if the value is in the list move it to the front and return it .", "label": 0}, {"idx": "cosqa-train-4356", "doc": "bs get element by id python", "code": "def retrieve_by_id(self, id_):\n        \"\"\"Return a JSSObject for the element with ID id_\"\"\"\n        items_with_id = [item for item in self if item.id == int(id_)]\n        if len(items_with_id) == 1:\n            return items_with_id[0].retrieve()", "code_tokens": "def retrieve_by_id ( self , id_ ) : items_with_id = [ item for item in self if item . id == int ( id_ ) ] if len ( items_with_id ) == 1 : return items_with_id [ 0 ] . retrieve ( )", "docstring_tokens": "Return a JSSObject for the element with ID id_", "label": 0}, {"idx": "cosqa-train-4357", "doc": "python dict delete empty", "code": "def purge_dict(idict):\n    \"\"\"Remove null items from a dictionary \"\"\"\n    odict = {}\n    for key, val in idict.items():\n        if is_null(val):\n            continue\n        odict[key] = val\n    return odict", "code_tokens": "def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict", "docstring_tokens": "Remove null items from a dictionary", "label": 0}, {"idx": "cosqa-train-4358", "doc": "build rpm with python", "code": "def install_rpm_py():\n    \"\"\"Install RPM Python binding.\"\"\"\n    python_path = sys.executable\n    cmd = '{0} install.py'.format(python_path)\n    exit_status = os.system(cmd)\n    if exit_status != 0:\n        raise Exception('Command failed: {0}'.format(cmd))", "code_tokens": "def install_rpm_py ( ) : python_path = sys . executable cmd = '{0} install.py' . format ( python_path ) exit_status = os . system ( cmd ) if exit_status != 0 : raise Exception ( 'Command failed: {0}' . format ( cmd ) )", "docstring_tokens": "Install RPM Python binding .", "label": 0}, {"idx": "cosqa-train-4359", "doc": "python dict iterate update", "code": "def update(self, other_dict):\n        \"\"\"update() extends rather than replaces existing key lists.\"\"\"\n        for key, value in iter_multi_items(other_dict):\n            MultiDict.add(self, key, value)", "code_tokens": "def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )", "docstring_tokens": "update () extends rather than replaces existing key lists .", "label": 0}, {"idx": "cosqa-train-4360", "doc": "python dict to matrix numpy", "code": "def C_dict2array(C):\n    \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"\n    return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "code_tokens": "def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )", "docstring_tokens": "Convert an OrderedDict containing C values to a 1D array .", "label": 0}, {"idx": "cosqa-train-4361", "doc": "bypass ssl python requests", "code": "def enable_ssl(self, *args, **kwargs):\n        \"\"\"\n        Transforms the regular socket.socket to an ssl.SSLSocket for secure\n        connections. Any arguments are passed to ssl.wrap_socket:\n        http://docs.python.org/dev/library/ssl.html#ssl.wrap_socket\n        \"\"\"\n        if self.handshake_sent:\n            raise SSLError('can only enable SSL before handshake')\n\n        self.secure = True\n        self.sock = ssl.wrap_socket(self.sock, *args, **kwargs)", "code_tokens": "def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )", "docstring_tokens": "Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket", "label": 0}, {"idx": "cosqa-train-4362", "doc": "python dict to urlstring", "code": "def dict_to_querystring(dictionary):\n    \"\"\"Converts a dict to a querystring suitable to be appended to a URL.\"\"\"\n    s = u\"\"\n    for d in dictionary.keys():\n        s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d])\n    return s[:-1]", "code_tokens": "def dict_to_querystring ( dictionary ) : s = u\"\" for d in dictionary . keys ( ) : s = unicode . format ( u\"{0}{1}={2}&\" , s , d , dictionary [ d ] ) return s [ : - 1 ]", "docstring_tokens": "Converts a dict to a querystring suitable to be appended to a URL .", "label": 1}, {"idx": "cosqa-train-4363", "doc": "c++ timespec to python", "code": "def convert_timeval(seconds_since_epoch):\n    \"\"\"Convert time into C style timeval.\"\"\"\n    frac, whole = math.modf(seconds_since_epoch)\n    microseconds = math.floor(frac * 1000000)\n    seconds = math.floor(whole)\n    return seconds, microseconds", "code_tokens": "def convert_timeval ( seconds_since_epoch ) : frac , whole = math . modf ( seconds_since_epoch ) microseconds = math . floor ( frac * 1000000 ) seconds = math . floor ( whole ) return seconds , microseconds", "docstring_tokens": "Convert time into C style timeval .", "label": 0}, {"idx": "cosqa-train-4364", "doc": "python dictionary clone idempotent", "code": "def copy(self):\n        \"\"\"\n        Return a copy of the dictionary.\n\n        This is a middle-deep copy; the copy is independent of the original in\n        all attributes that have mutable types except for:\n\n        * The values in the dictionary\n\n        Note that the Python functions :func:`py:copy.copy` and\n        :func:`py:copy.deepcopy` can be used to create completely shallow or\n        completely deep copies of objects of this class.\n        \"\"\"\n        result = NocaseDict()\n        result._data = self._data.copy()  # pylint: disable=protected-access\n        return result", "code_tokens": "def copy ( self ) : result = NocaseDict ( ) result . _data = self . _data . copy ( ) # pylint: disable=protected-access return result", "docstring_tokens": "Return a copy of the dictionary .", "label": 0}, {"idx": "cosqa-train-4365", "doc": "calculate annual growth python", "code": "def growthfromrange(rangegrowth, startdate, enddate):\n    \"\"\"\n    Annual growth given growth from start date to end date.\n    \"\"\"\n    _yrs = (pd.Timestamp(enddate) - pd.Timestamp(startdate)).total_seconds() /\\\n            dt.timedelta(365.25).total_seconds()\n    return yrlygrowth(rangegrowth, _yrs)", "code_tokens": "def growthfromrange ( rangegrowth , startdate , enddate ) : _yrs = ( pd . Timestamp ( enddate ) - pd . Timestamp ( startdate ) ) . total_seconds ( ) / dt . timedelta ( 365.25 ) . total_seconds ( ) return yrlygrowth ( rangegrowth , _yrs )", "docstring_tokens": "Annual growth given growth from start date to end date .", "label": 0}, {"idx": "cosqa-train-4366", "doc": "python dictionary keys values consistent", "code": "def make_symmetric(dict):\n    \"\"\"Makes the given dictionary symmetric. Values are assumed to be unique.\"\"\"\n    for key, value in list(dict.items()):\n        dict[value] = key\n    return dict", "code_tokens": "def make_symmetric ( dict ) : for key , value in list ( dict . items ( ) ) : dict [ value ] = key return dict", "docstring_tokens": "Makes the given dictionary symmetric . Values are assumed to be unique .", "label": 0}, {"idx": "cosqa-train-4367", "doc": "calculate expoential wieghted moving average in python", "code": "def double_exponential_moving_average(data, period):\n    \"\"\"\n    Double Exponential Moving Average.\n\n    Formula:\n    DEMA = 2*EMA - EMA(EMA)\n    \"\"\"\n    catch_errors.check_for_period_error(data, period)\n\n    dema = (2 * ema(data, period)) - ema(ema(data, period), period)\n    return dema", "code_tokens": "def double_exponential_moving_average ( data , period ) : catch_errors . check_for_period_error ( data , period ) dema = ( 2 * ema ( data , period ) ) - ema ( ema ( data , period ) , period ) return dema", "docstring_tokens": "Double Exponential Moving Average .", "label": 0}, {"idx": "cosqa-train-4368", "doc": "python dictionary pop multiple keys", "code": "def multi_pop(d, *args):\n    \"\"\" pops multiple keys off a dict like object \"\"\"\n    retval = {}\n    for key in args:\n        if key in d:\n            retval[key] = d.pop(key)\n    return retval", "code_tokens": "def multi_pop ( d , * args ) : retval = { } for key in args : if key in d : retval [ key ] = d . pop ( key ) return retval", "docstring_tokens": "pops multiple keys off a dict like object", "label": 0}, {"idx": "cosqa-train-4369", "doc": "calculate inverse of matrix in python", "code": "def inh(table):\n    \"\"\"\n    inverse hyperbolic sine transformation\n    \"\"\"\n    t = []\n    for i in table:\n        t.append(np.ndarray.tolist(np.arcsinh(i)))\n    return t", "code_tokens": "def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "docstring_tokens": "inverse hyperbolic sine transformation", "label": 0}, {"idx": "cosqa-train-4370", "doc": "python dictionary update missing keys", "code": "def dict_update_newkeys(dict_, dict2):\n    \"\"\" Like dict.update, but does not overwrite items \"\"\"\n    for key, val in six.iteritems(dict2):\n        if key not in dict_:\n            dict_[key] = val", "code_tokens": "def dict_update_newkeys ( dict_ , dict2 ) : for key , val in six . iteritems ( dict2 ) : if key not in dict_ : dict_ [ key ] = val", "docstring_tokens": "Like dict . update but does not overwrite items", "label": 1}, {"idx": "cosqa-train-4371", "doc": "calculate normalized vector python", "code": "def v_normalize(v):\n    \"\"\"\n    Normalizes the given vector.\n    \n    The vector given may have any number of dimensions.\n    \"\"\"\n    vmag = v_magnitude(v)\n    return [ v[i]/vmag  for i in range(len(v)) ]", "code_tokens": "def v_normalize ( v ) : vmag = v_magnitude ( v ) return [ v [ i ] / vmag for i in range ( len ( v ) ) ]", "docstring_tokens": "Normalizes the given vector . The vector given may have any number of dimensions .", "label": 0}, {"idx": "cosqa-train-4372", "doc": "python dictionary update recursively", "code": "def recursively_update(d, d2):\n  \"\"\"dict.update but which merges child dicts (dict2 takes precedence where there's conflict).\"\"\"\n  for k, v in d2.items():\n    if k in d:\n      if isinstance(v, dict):\n        recursively_update(d[k], v)\n        continue\n    d[k] = v", "code_tokens": "def recursively_update ( d , d2 ) : for k , v in d2 . items ( ) : if k in d : if isinstance ( v , dict ) : recursively_update ( d [ k ] , v ) continue d [ k ] = v", "docstring_tokens": "dict . update but which merges child dicts ( dict2 takes precedence where there s conflict ) .", "label": 0}, {"idx": "cosqa-train-4373", "doc": "calculate number of days from months python datetime", "code": "def _days_in_month(date):\n    \"\"\"The number of days in the month of the given date\"\"\"\n    if date.month == 12:\n        reference = type(date)(date.year + 1, 1, 1)\n    else:\n        reference = type(date)(date.year, date.month + 1, 1)\n    return (reference - timedelta(days=1)).day", "code_tokens": "def _days_in_month ( date ) : if date . month == 12 : reference = type ( date ) ( date . year + 1 , 1 , 1 ) else : reference = type ( date ) ( date . year , date . month + 1 , 1 ) return ( reference - timedelta ( days = 1 ) ) . day", "docstring_tokens": "The number of days in the month of the given date", "label": 0}, {"idx": "cosqa-train-4374", "doc": "python dictionary update without replacement", "code": "def update(self, other_dict):\n        \"\"\"update() extends rather than replaces existing key lists.\"\"\"\n        for key, value in iter_multi_items(other_dict):\n            MultiDict.add(self, key, value)", "code_tokens": "def update ( self , other_dict ) : for key , value in iter_multi_items ( other_dict ) : MultiDict . add ( self , key , value )", "docstring_tokens": "update () extends rather than replaces existing key lists .", "label": 1}, {"idx": "cosqa-train-4375", "doc": "calculate number of non nan in array python", "code": "def count_rows_with_nans(X):\n    \"\"\"Count the number of rows in 2D arrays that contain any nan values.\"\"\"\n    if X.ndim == 2:\n        return np.where(np.isnan(X).sum(axis=1) != 0, 1, 0).sum()", "code_tokens": "def count_rows_with_nans ( X ) : if X . ndim == 2 : return np . where ( np . isnan ( X ) . sum ( axis = 1 ) != 0 , 1 , 0 ) . sum ( )", "docstring_tokens": "Count the number of rows in 2D arrays that contain any nan values .", "label": 0}, {"idx": "cosqa-train-4376", "doc": "python different c types for array", "code": "def c_array(ctype, values):\n    \"\"\"Convert a python string to c array.\"\"\"\n    if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype):\n        return (ctype * len(values)).from_buffer_copy(values)\n    return (ctype * len(values))(*values)", "code_tokens": "def c_array ( ctype , values ) : if isinstance ( values , np . ndarray ) and values . dtype . itemsize == ctypes . sizeof ( ctype ) : return ( ctype * len ( values ) ) . from_buffer_copy ( values ) return ( ctype * len ( values ) ) ( * values )", "docstring_tokens": "Convert a python string to c array .", "label": 0}, {"idx": "cosqa-train-4377", "doc": "calculate std deviation python", "code": "def stderr(a):\n    \"\"\"\n    Calculate the standard error of a.\n    \"\"\"\n    return np.nanstd(a) / np.sqrt(sum(np.isfinite(a)))", "code_tokens": "def stderr ( a ) : return np . nanstd ( a ) / np . sqrt ( sum ( np . isfinite ( a ) ) )", "docstring_tokens": "Calculate the standard error of a .", "label": 0}, {"idx": "cosqa-train-4378", "doc": "python directory permission check", "code": "def is_readable_dir(path):\n  \"\"\"Returns whether a path names an existing directory we can list and read files from.\"\"\"\n  return os.path.isdir(path) and os.access(path, os.R_OK) and os.access(path, os.X_OK)", "code_tokens": "def is_readable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . R_OK ) and os . access ( path , os . X_OK )", "docstring_tokens": "Returns whether a path names an existing directory we can list and read files from .", "label": 0}, {"idx": "cosqa-train-4379", "doc": "call a python function from javascript", "code": "def import_js(path, lib_name, globals):\n    \"\"\"Imports from javascript source file.\n      globals is your globals()\"\"\"\n    with codecs.open(path_as_local(path), \"r\", \"utf-8\") as f:\n        js = f.read()\n    e = EvalJs()\n    e.execute(js)\n    var = e.context['var']\n    globals[lib_name] = var.to_python()", "code_tokens": "def import_js ( path , lib_name , globals ) : with codecs . open ( path_as_local ( path ) , \"r\" , \"utf-8\" ) as f : js = f . read ( ) e = EvalJs ( ) e . execute ( js ) var = e . context [ 'var' ] globals [ lib_name ] = var . to_python ( )", "docstring_tokens": "Imports from javascript source file . globals is your globals ()", "label": 0}, {"idx": "cosqa-train-4380", "doc": "python disable certificate validation globally", "code": "def disable_cert_validation():\n    \"\"\"Context manager to temporarily disable certificate validation in the standard SSL\n    library.\n\n    Note: This should not be used in production code but is sometimes useful for\n    troubleshooting certificate validation issues.\n\n    By design, the standard SSL library does not provide a way to disable verification\n    of the server side certificate. However, a patch to disable validation is described\n    by the library developers. This context manager allows applying the patch for\n    specific sections of code.\n\n    \"\"\"\n    current_context = ssl._create_default_https_context\n    ssl._create_default_https_context = ssl._create_unverified_context\n    try:\n        yield\n    finally:\n        ssl._create_default_https_context = current_context", "code_tokens": "def disable_cert_validation ( ) : current_context = ssl . _create_default_https_context ssl . _create_default_https_context = ssl . _create_unverified_context try : yield finally : ssl . _create_default_https_context = current_context", "docstring_tokens": "Context manager to temporarily disable certificate validation in the standard SSL library .", "label": 0}, {"idx": "cosqa-train-4381", "doc": "can functions have multiple returns python", "code": "def many_until1(these, term):\n    \"\"\"Like many_until but must consume at least one of these.\n    \"\"\"\n    first = [these()]\n    these_results, term_result = many_until(these, term)\n    return (first + these_results, term_result)", "code_tokens": "def many_until1 ( these , term ) : first = [ these ( ) ] these_results , term_result = many_until ( these , term ) return ( first + these_results , term_result )", "docstring_tokens": "Like many_until but must consume at least one of these .", "label": 1}, {"idx": "cosqa-train-4382", "doc": "python disable ssl certificate verify", "code": "def disable_cert_validation():\n    \"\"\"Context manager to temporarily disable certificate validation in the standard SSL\n    library.\n\n    Note: This should not be used in production code but is sometimes useful for\n    troubleshooting certificate validation issues.\n\n    By design, the standard SSL library does not provide a way to disable verification\n    of the server side certificate. However, a patch to disable validation is described\n    by the library developers. This context manager allows applying the patch for\n    specific sections of code.\n\n    \"\"\"\n    current_context = ssl._create_default_https_context\n    ssl._create_default_https_context = ssl._create_unverified_context\n    try:\n        yield\n    finally:\n        ssl._create_default_https_context = current_context", "code_tokens": "def disable_cert_validation ( ) : current_context = ssl . _create_default_https_context ssl . _create_default_https_context = ssl . _create_unverified_context try : yield finally : ssl . _create_default_https_context = current_context", "docstring_tokens": "Context manager to temporarily disable certificate validation in the standard SSL library .", "label": 0}, {"idx": "cosqa-train-4383", "doc": "can i clear the window in python after creating something", "code": "def reject(self):\n        \"\"\"\n        Rejects the snapshot and closes the widget.\n        \"\"\"\n        if self.hideWindow():\n            self.hideWindow().show()\n            \n        self.close()\n        self.deleteLater()", "code_tokens": "def reject ( self ) : if self . hideWindow ( ) : self . hideWindow ( ) . show ( ) self . close ( ) self . deleteLater ( )", "docstring_tokens": "Rejects the snapshot and closes the widget .", "label": 0}, {"idx": "cosqa-train-4384", "doc": "python disable type conversions to numeric", "code": "def robust_int(v):\n    \"\"\"Parse an int robustly, ignoring commas and other cruft. \"\"\"\n\n    if isinstance(v, int):\n        return v\n\n    if isinstance(v, float):\n        return int(v)\n\n    v = str(v).replace(',', '')\n\n    if not v:\n        return None\n\n    return int(v)", "code_tokens": "def robust_int ( v ) : if isinstance ( v , int ) : return v if isinstance ( v , float ) : return int ( v ) v = str ( v ) . replace ( ',' , '' ) if not v : return None return int ( v )", "docstring_tokens": "Parse an int robustly ignoring commas and other cruft .", "label": 0}, {"idx": "cosqa-train-4385", "doc": "can python send function send a maximum number of bytes", "code": "def send(socket, data, num_bytes=20):\n    \"\"\"Send data to specified socket.\n\n\n    :param socket: open socket instance\n    :param data: data to send\n    :param num_bytes: number of bytes to read\n\n    :return: received data\n    \"\"\"\n    pickled_data = pickle.dumps(data, -1)\n    length = str(len(pickled_data)).zfill(num_bytes)\n    socket.sendall(length.encode())\n    socket.sendall(pickled_data)", "code_tokens": "def send ( socket , data , num_bytes = 20 ) : pickled_data = pickle . dumps ( data , - 1 ) length = str ( len ( pickled_data ) ) . zfill ( num_bytes ) socket . sendall ( length . encode ( ) ) socket . sendall ( pickled_data )", "docstring_tokens": "Send data to specified socket .", "label": 0}, {"idx": "cosqa-train-4386", "doc": "python discard imaginary complex int", "code": "def _trim_zeros_complex(str_complexes, na_rep='NaN'):\n    \"\"\"\n    Separates the real and imaginary parts from the complex number, and\n    executes the _trim_zeros_float method on each of those.\n    \"\"\"\n    def separate_and_trim(str_complex, na_rep):\n        num_arr = str_complex.split('+')\n        return (_trim_zeros_float([num_arr[0]], na_rep) +\n                ['+'] +\n                _trim_zeros_float([num_arr[1][:-1]], na_rep) +\n                ['j'])\n\n    return [''.join(separate_and_trim(x, na_rep)) for x in str_complexes]", "code_tokens": "def _trim_zeros_complex ( str_complexes , na_rep = 'NaN' ) : def separate_and_trim ( str_complex , na_rep ) : num_arr = str_complex . split ( '+' ) return ( _trim_zeros_float ( [ num_arr [ 0 ] ] , na_rep ) + [ '+' ] + _trim_zeros_float ( [ num_arr [ 1 ] [ : - 1 ] ] , na_rep ) + [ 'j' ] ) return [ '' . join ( separate_and_trim ( x , na_rep ) ) for x in str_complexes ]", "docstring_tokens": "Separates the real and imaginary parts from the complex number and executes the _trim_zeros_float method on each of those .", "label": 0}, {"idx": "cosqa-train-4387", "doc": "can python use uniccode characters", "code": "def to_unicode_repr( _letter ):\n    \"\"\" helpful in situations where browser/app may recognize Unicode encoding\n        in the \\u0b8e type syntax but not actual unicode glyph/code-point\"\"\"\n    # Python 2-3 compatible\n    return u\"u'\"+ u\"\".join( [ u\"\\\\u%04x\"%ord(l) for l in _letter ] ) + u\"'\"", "code_tokens": "def to_unicode_repr ( _letter ) : # Python 2-3 compatible return u\"u'\" + u\"\" . join ( [ u\"\\\\u%04x\" % ord ( l ) for l in _letter ] ) + u\"'\"", "docstring_tokens": "helpful in situations where browser / app may recognize Unicode encoding in the \\ u0b8e type syntax but not actual unicode glyph / code - point", "label": 1}, {"idx": "cosqa-train-4388", "doc": "python display a graphviz graph object", "code": "def _text_to_graphiz(self, text):\n        \"\"\"create a graphviz graph from text\"\"\"\n        dot = Source(text, format='svg')\n        return dot.pipe().decode('utf-8')", "code_tokens": "def _text_to_graphiz ( self , text ) : dot = Source ( text , format = 'svg' ) return dot . pipe ( ) . decode ( 'utf-8' )", "docstring_tokens": "create a graphviz graph from text", "label": 0}, {"idx": "cosqa-train-4389", "doc": "capital letter function python", "code": "def to_identifier(s):\n  \"\"\"\n  Convert snake_case to camel_case.\n  \"\"\"\n  if s.startswith('GPS'):\n      s = 'Gps' + s[3:]\n  return ''.join([i.capitalize() for i in s.split('_')]) if '_' in s else s", "code_tokens": "def to_identifier ( s ) : if s . startswith ( 'GPS' ) : s = 'Gps' + s [ 3 : ] return '' . join ( [ i . capitalize ( ) for i in s . split ( '_' ) ] ) if '_' in s else s", "docstring_tokens": "Convert snake_case to camel_case .", "label": 0}, {"idx": "cosqa-train-4390", "doc": "python display shape without window", "code": "def display(self):\n        \"\"\" Get screen width and height \"\"\"\n        w, h = self.session.window_size()\n        return Display(w*self.scale, h*self.scale)", "code_tokens": "def display ( self ) : w , h = self . session . window_size ( ) return Display ( w * self . scale , h * self . scale )", "docstring_tokens": "Get screen width and height", "label": 0}, {"idx": "cosqa-train-4391", "doc": "capitalize elements in a list python", "code": "def _snake_to_camel_case(value):\n    \"\"\"Convert snake case string to camel case.\"\"\"\n    words = value.split(\"_\")\n    return words[0] + \"\".join(map(str.capitalize, words[1:]))", "code_tokens": "def _snake_to_camel_case ( value ) : words = value . split ( \"_\" ) return words [ 0 ] + \"\" . join ( map ( str . capitalize , words [ 1 : ] ) )", "docstring_tokens": "Convert snake case string to camel case .", "label": 0}, {"idx": "cosqa-train-4392", "doc": "python distance between points in graphs", "code": "def direct2dDistance(self, point):\n        \"\"\"consider the distance between two mapPoints, ignoring all terrain, pathing issues\"\"\"\n        if not isinstance(point, MapPoint): return 0.0\n        return  ((self.x-point.x)**2 + (self.y-point.y)**2)**(0.5) # simple distance formula", "code_tokens": "def direct2dDistance ( self , point ) : if not isinstance ( point , MapPoint ) : return 0.0 return ( ( self . x - point . x ) ** 2 + ( self . y - point . y ) ** 2 ) ** ( 0.5 ) # simple distance formula", "docstring_tokens": "consider the distance between two mapPoints ignoring all terrain pathing issues", "label": 0}, {"idx": "cosqa-train-4393", "doc": "capitalize function in python for lists", "code": "def _snake_to_camel_case(value):\n    \"\"\"Convert snake case string to camel case.\"\"\"\n    words = value.split(\"_\")\n    return words[0] + \"\".join(map(str.capitalize, words[1:]))", "code_tokens": "def _snake_to_camel_case ( value ) : words = value . split ( \"_\" ) return words [ 0 ] + \"\" . join ( map ( str . capitalize , words [ 1 : ] ) )", "docstring_tokens": "Convert snake case string to camel case .", "label": 0}, {"idx": "cosqa-train-4394", "doc": "python django delete killed", "code": "def deleted(self, instance):\n        \"\"\"\n        Convenience method for deleting a model (automatically commits the\n        delete to the database and returns with an HTTP 204 status code)\n        \"\"\"\n        self.session_manager.delete(instance, commit=True)\n        return '', HTTPStatus.NO_CONTENT", "code_tokens": "def deleted ( self , instance ) : self . session_manager . delete ( instance , commit = True ) return '' , HTTPStatus . NO_CONTENT", "docstring_tokens": "Convenience method for deleting a model ( automatically commits the delete to the database and returns with an HTTP 204 status code )", "label": 0}, {"idx": "cosqa-train-4395", "doc": "capitolize first letter python", "code": "def to_identifier(s):\n  \"\"\"\n  Convert snake_case to camel_case.\n  \"\"\"\n  if s.startswith('GPS'):\n      s = 'Gps' + s[3:]\n  return ''.join([i.capitalize() for i in s.split('_')]) if '_' in s else s", "code_tokens": "def to_identifier ( s ) : if s . startswith ( 'GPS' ) : s = 'Gps' + s [ 3 : ] return '' . join ( [ i . capitalize ( ) for i in s . split ( '_' ) ] ) if '_' in s else s", "docstring_tokens": "Convert snake_case to camel_case .", "label": 0}, {"idx": "cosqa-train-4396", "doc": "python django how to show images", "code": "def show_image(self, key):\n        \"\"\"Show image (item is a PIL image)\"\"\"\n        data = self.model.get_data()\n        data[key].show()", "code_tokens": "def show_image ( self , key ) : data = self . model . get_data ( ) data [ key ] . show ( )", "docstring_tokens": "Show image ( item is a PIL image )", "label": 0}, {"idx": "cosqa-train-4397", "doc": "capture output from python call subprocess", "code": "def check_output(args):\n    \"\"\"Runs command and returns the output as string.\"\"\"\n    log.debug('run: %s', args)\n    out = subprocess.check_output(args=args).decode('utf-8')\n    log.debug('out: %r', out)\n    return out", "code_tokens": "def check_output ( args ) : log . debug ( 'run: %s' , args ) out = subprocess . check_output ( args = args ) . decode ( 'utf-8' ) log . debug ( 'out: %r' , out ) return out", "docstring_tokens": "Runs command and returns the output as string .", "label": 0}, {"idx": "cosqa-train-4398", "doc": "python django js assert", "code": "def page_title(step, title):\n    \"\"\"\n    Check that the page title matches the given one.\n    \"\"\"\n\n    with AssertContextManager(step):\n        assert_equals(world.browser.title, title)", "code_tokens": "def page_title ( step , title ) : with AssertContextManager ( step ) : assert_equals ( world . browser . title , title )", "docstring_tokens": "Check that the page title matches the given one .", "label": 0}, {"idx": "cosqa-train-4399", "doc": "capture python back traces in logs", "code": "def __run(self):\n    \"\"\"Hacked run function, which installs the trace.\"\"\"\n    sys.settrace(self.globaltrace)\n    self.__run_backup()\n    self.run = self.__run_backup", "code_tokens": "def __run ( self ) : sys . settrace ( self . globaltrace ) self . __run_backup ( ) self . run = self . __run_backup", "docstring_tokens": "Hacked run function which installs the trace .", "label": 0}, {"idx": "cosqa-train-4400", "doc": "python django makemigrations from model changes", "code": "def main():\n    \"\"\"Parse the command line and run :func:`migrate`.\"\"\"\n    parser = get_args_parser()\n    args = parser.parse_args()\n    config = Config.from_parse_args(args)\n    migrate(config)", "code_tokens": "def main ( ) : parser = get_args_parser ( ) args = parser . parse_args ( ) config = Config . from_parse_args ( args ) migrate ( config )", "docstring_tokens": "Parse the command line and run : func : migrate .", "label": 0}, {"idx": "cosqa-train-4401", "doc": "case insensitve matching python", "code": "def is_equal_strings_ignore_case(first, second):\n    \"\"\"The function compares strings ignoring case\"\"\"\n    if first and second:\n        return first.upper() == second.upper()\n    else:\n        return not (first or second)", "code_tokens": "def is_equal_strings_ignore_case ( first , second ) : if first and second : return first . upper ( ) == second . upper ( ) else : return not ( first or second )", "docstring_tokens": "The function compares strings ignoring case", "label": 0}, {"idx": "cosqa-train-4402", "doc": "python django mock httprequest", "code": "def requests_post(url, data=None, json=None, **kwargs):\n    \"\"\"Requests-mock requests.post wrapper.\"\"\"\n    return requests_request('post', url, data=data, json=json, **kwargs)", "code_tokens": "def requests_post ( url , data = None , json = None , * * kwargs ) : return requests_request ( 'post' , url , data = data , json = json , * * kwargs )", "docstring_tokens": "Requests - mock requests . post wrapper .", "label": 0}, {"idx": "cosqa-train-4403", "doc": "cast a variable to tz in python", "code": "def __to_localdatetime(val):\n    \"\"\"Convert val into a local datetime for tz Europe/Amsterdam.\"\"\"\n    try:\n        dt = datetime.strptime(val, __DATE_FORMAT)\n        dt = pytz.timezone(__TIMEZONE).localize(dt)\n        return dt\n    except (ValueError, TypeError):\n        return None", "code_tokens": "def __to_localdatetime ( val ) : try : dt = datetime . strptime ( val , __DATE_FORMAT ) dt = pytz . timezone ( __TIMEZONE ) . localize ( dt ) return dt except ( ValueError , TypeError ) : return None", "docstring_tokens": "Convert val into a local datetime for tz Europe / Amsterdam .", "label": 1}, {"idx": "cosqa-train-4404", "doc": "python django register database routers", "code": "def merge(database=None, directory=None, verbose=None):\n    \"\"\"Merge migrations into one.\"\"\"\n    router = get_router(directory, database, verbose)\n    router.merge()", "code_tokens": "def merge ( database = None , directory = None , verbose = None ) : router = get_router ( directory , database , verbose ) router . merge ( )", "docstring_tokens": "Merge migrations into one .", "label": 0}, {"idx": "cosqa-train-4405", "doc": "cast input string to boolean python", "code": "def strToBool(val):\n    \"\"\"\n    Helper function to turn a string representation of \"true\" into\n    boolean True.\n    \"\"\"\n    if isinstance(val, str):\n        val = val.lower()\n\n    return val in ['true', 'on', 'yes', True]", "code_tokens": "def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]", "docstring_tokens": "Helper function to turn a string representation of true into boolean True .", "label": 1}, {"idx": "cosqa-train-4406", "doc": "python docstring dictionary param", "code": "def _add_params_docstring(params):\n    \"\"\" Add params to doc string\n    \"\"\"\n    p_string = \"\\nAccepts the following paramters: \\n\"\n    for param in params:\n         p_string += \"name: %s, required: %s, description: %s \\n\" % (param['name'], param['required'], param['description'])\n    return p_string", "code_tokens": "def _add_params_docstring ( params ) : p_string = \"\\nAccepts the following paramters: \\n\" for param in params : p_string += \"name: %s, required: %s, description: %s \\n\" % ( param [ 'name' ] , param [ 'required' ] , param [ 'description' ] ) return p_string", "docstring_tokens": "Add params to doc string", "label": 1}, {"idx": "cosqa-train-4407", "doc": "cast string as datetime object python", "code": "def deserialize_date(string):\n    \"\"\"\n    Deserializes string to date.\n\n    :param string: str.\n    :type string: str\n    :return: date.\n    :rtype: date\n    \"\"\"\n    try:\n        from dateutil.parser import parse\n        return parse(string).date()\n    except ImportError:\n        return string", "code_tokens": "def deserialize_date ( string ) : try : from dateutil . parser import parse return parse ( string ) . date ( ) except ImportError : return string", "docstring_tokens": "Deserializes string to date .", "label": 0}, {"idx": "cosqa-train-4408", "doc": "python docstring varible representation", "code": "def _add_params_docstring(params):\n    \"\"\" Add params to doc string\n    \"\"\"\n    p_string = \"\\nAccepts the following paramters: \\n\"\n    for param in params:\n         p_string += \"name: %s, required: %s, description: %s \\n\" % (param['name'], param['required'], param['description'])\n    return p_string", "code_tokens": "def _add_params_docstring ( params ) : p_string = \"\\nAccepts the following paramters: \\n\" for param in params : p_string += \"name: %s, required: %s, description: %s \\n\" % ( param [ 'name' ] , param [ 'required' ] , param [ 'description' ] ) return p_string", "docstring_tokens": "Add params to doc string", "label": 0}, {"idx": "cosqa-train-4409", "doc": "cast string to enum python", "code": "def from_string(cls, string):\n        \"\"\"\n        Simply logs a warning if the desired enum value is not found.\n\n        :param string:\n        :return:\n        \"\"\"\n\n        # find enum value\n        for attr in dir(cls):\n            value = getattr(cls, attr)\n            if value == string:\n                return value\n\n        # if not found, log warning and return the value passed in\n        logger.warning(\"{} is not a valid enum value for {}.\".format(string, cls.__name__))\n        return string", "code_tokens": "def from_string ( cls , string ) : # find enum value for attr in dir ( cls ) : value = getattr ( cls , attr ) if value == string : return value # if not found, log warning and return the value passed in logger . warning ( \"{} is not a valid enum value for {}.\" . format ( string , cls . __name__ ) ) return string", "docstring_tokens": "Simply logs a warning if the desired enum value is not found .", "label": 0}, {"idx": "cosqa-train-4410", "doc": "python docx section header", "code": "def fill_document(doc):\n    \"\"\"Add a section, a subsection and some text to the document.\n\n    :param doc: the document\n    :type doc: :class:`pylatex.document.Document` instance\n    \"\"\"\n    with doc.create(Section('A section')):\n        doc.append('Some regular text and some ')\n        doc.append(italic('italic text. '))\n\n        with doc.create(Subsection('A subsection')):\n            doc.append('Also some crazy characters: $&#{}')", "code_tokens": "def fill_document ( doc ) : with doc . create ( Section ( 'A section' ) ) : doc . append ( 'Some regular text and some ' ) doc . append ( italic ( 'italic text. ' ) ) with doc . create ( Subsection ( 'A subsection' ) ) : doc . append ( 'Also some crazy characters: $&#{}' )", "docstring_tokens": "Add a section a subsection and some text to the document .", "label": 0}, {"idx": "cosqa-train-4411", "doc": "cast timestamp datatype python", "code": "def timestamp_to_datetime(timestamp):\n    \"\"\"Convert an ARF timestamp to a datetime.datetime object (naive local time)\"\"\"\n    from datetime import datetime, timedelta\n    obj = datetime.fromtimestamp(timestamp[0])\n    return obj + timedelta(microseconds=int(timestamp[1]))", "code_tokens": "def timestamp_to_datetime ( timestamp ) : from datetime import datetime , timedelta obj = datetime . fromtimestamp ( timestamp [ 0 ] ) return obj + timedelta ( microseconds = int ( timestamp [ 1 ] ) )", "docstring_tokens": "Convert an ARF timestamp to a datetime . datetime object ( naive local time )", "label": 1}, {"idx": "cosqa-train-4412", "doc": "python dot notation for dict", "code": "def _attrprint(d, delimiter=', '):\n    \"\"\"Print a dictionary of attributes in the DOT format\"\"\"\n    return delimiter.join(('\"%s\"=\"%s\"' % item) for item in sorted(d.items()))", "code_tokens": "def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '\"%s\"=\"%s\"' % item ) for item in sorted ( d . items ( ) ) )", "docstring_tokens": "Print a dictionary of attributes in the DOT format", "label": 0}, {"idx": "cosqa-train-4413", "doc": "cautoonverter from java to python", "code": "def callJavaFunc(func, *args):\n    \"\"\" Call Java Function \"\"\"\n    gateway = _get_gateway()\n    args = [_py2java(gateway, a) for a in args]\n    result = func(*args)\n    return _java2py(gateway, result)", "code_tokens": "def callJavaFunc ( func , * args ) : gateway = _get_gateway ( ) args = [ _py2java ( gateway , a ) for a in args ] result = func ( * args ) return _java2py ( gateway , result )", "docstring_tokens": "Call Java Function", "label": 0}, {"idx": "cosqa-train-4414", "doc": "python double underscore attributes", "code": "def underscore(text):\n    \"\"\"Converts text that may be camelcased into an underscored format\"\"\"\n    return UNDERSCORE[1].sub(r'\\1_\\2', UNDERSCORE[0].sub(r'\\1_\\2', text)).lower()", "code_tokens": "def underscore ( text ) : return UNDERSCORE [ 1 ] . sub ( r'\\1_\\2' , UNDERSCORE [ 0 ] . sub ( r'\\1_\\2' , text ) ) . lower ( )", "docstring_tokens": "Converts text that may be camelcased into an underscored format", "label": 0}, {"idx": "cosqa-train-4415", "doc": "change a bytes object to str python", "code": "def to_str(obj):\n    \"\"\"Attempts to convert given object to a string object\n    \"\"\"\n    if not isinstance(obj, str) and PY3 and isinstance(obj, bytes):\n        obj = obj.decode('utf-8')\n    return obj if isinstance(obj, string_types) else str(obj)", "code_tokens": "def to_str ( obj ) : if not isinstance ( obj , str ) and PY3 and isinstance ( obj , bytes ) : obj = obj . decode ( 'utf-8' ) return obj if isinstance ( obj , string_types ) else str ( obj )", "docstring_tokens": "Attempts to convert given object to a string object", "label": 0}, {"idx": "cosqa-train-4416", "doc": "python double underscore function name", "code": "def ucamel_method(func):\n    \"\"\"\n    Decorator to ensure the given snake_case method is also written in\n    UpperCamelCase in the given namespace. That was mainly written to\n    avoid confusion when using wxPython and its UpperCamelCaseMethods.\n    \"\"\"\n    frame_locals = inspect.currentframe().f_back.f_locals\n    frame_locals[snake2ucamel(func.__name__)] = func\n    return func", "code_tokens": "def ucamel_method ( func ) : frame_locals = inspect . currentframe ( ) . f_back . f_locals frame_locals [ snake2ucamel ( func . __name__ ) ] = func return func", "docstring_tokens": "Decorator to ensure the given snake_case method is also written in UpperCamelCase in the given namespace . That was mainly written to avoid confusion when using wxPython and its UpperCamelCaseMethods .", "label": 0}, {"idx": "cosqa-train-4417", "doc": "change aspect ratio of graph python", "code": "def image_set_aspect(aspect=1.0, axes=\"gca\"):\n    \"\"\"\n    sets the aspect ratio of the current zoom level of the imshow image\n    \"\"\"\n    if axes is \"gca\": axes = _pylab.gca()\n\n    e = axes.get_images()[0].get_extent()\n    axes.set_aspect(abs((e[1]-e[0])/(e[3]-e[2]))/aspect)", "code_tokens": "def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "docstring_tokens": "sets the aspect ratio of the current zoom level of the imshow image", "label": 0}, {"idx": "cosqa-train-4418", "doc": "python draft4validator validate schema", "code": "def validate(self):\n        \"\"\"Validate the configuration file.\"\"\"\n        validator = Draft4Validator(self.SCHEMA)\n        if not validator.is_valid(self.config):\n            for err in validator.iter_errors(self.config):\n                LOGGER.error(str(err.message))\n            validator.validate(self.config)", "code_tokens": "def validate ( self ) : validator = Draft4Validator ( self . SCHEMA ) if not validator . is_valid ( self . config ) : for err in validator . iter_errors ( self . config ) : LOGGER . error ( str ( err . message ) ) validator . validate ( self . config )", "docstring_tokens": "Validate the configuration file .", "label": 1}, {"idx": "cosqa-train-4419", "doc": "change data type to date not time python", "code": "def _converter(self, value):\n        \"\"\"Convert raw input value of the field.\"\"\"\n        if not isinstance(value, datetime.date):\n            raise TypeError('{0} is not valid date'.format(value))\n        return value", "code_tokens": "def _converter ( self , value ) : if not isinstance ( value , datetime . date ) : raise TypeError ( '{0} is not valid date' . format ( value ) ) return value", "docstring_tokens": "Convert raw input value of the field .", "label": 1}, {"idx": "cosqa-train-4420", "doc": "python draw bounding box on a image", "code": "def bbox(self):\n        \"\"\"\n        The minimal `~photutils.aperture.BoundingBox` for the cutout\n        region with respect to the original (large) image.\n        \"\"\"\n\n        return BoundingBox(self.slices[1].start, self.slices[1].stop,\n                           self.slices[0].start, self.slices[0].stop)", "code_tokens": "def bbox ( self ) : return BoundingBox ( self . slices [ 1 ] . start , self . slices [ 1 ] . stop , self . slices [ 0 ] . start , self . slices [ 0 ] . stop )", "docstring_tokens": "The minimal ~photutils . aperture . BoundingBox for the cutout region with respect to the original ( large ) image .", "label": 0}, {"idx": "cosqa-train-4421", "doc": "change delimiters in a list in python", "code": "def linedelimited (inlist,delimiter):\n    \"\"\"\nReturns a string composed of elements in inlist, with each element\nseparated by 'delimiter.'  Used by function writedelimited.  Use '\\t'\nfor tab-delimiting.\n\nUsage:   linedelimited (inlist,delimiter)\n\"\"\"\n    outstr = ''\n    for item in inlist:\n        if type(item) != StringType:\n            item = str(item)\n        outstr = outstr + item + delimiter\n    outstr = outstr[0:-1]\n    return outstr", "code_tokens": "def linedelimited ( inlist , delimiter ) : outstr = '' for item in inlist : if type ( item ) != StringType : item = str ( item ) outstr = outstr + item + delimiter outstr = outstr [ 0 : - 1 ] return outstr", "docstring_tokens": "Returns a string composed of elements in inlist with each element separated by delimiter . Used by function writedelimited . Use \\ t for tab - delimiting .", "label": 0}, {"idx": "cosqa-train-4422", "doc": "python drawing lines between coordinates", "code": "def _draw_lines_internal(self, coords, colour, bg):\n        \"\"\"Helper to draw lines connecting a set of nodes that are scaled for the Screen.\"\"\"\n        for i, (x, y) in enumerate(coords):\n            if i == 0:\n                self._screen.move(x, y)\n            else:\n                self._screen.draw(x, y, colour=colour, bg=bg, thin=True)", "code_tokens": "def _draw_lines_internal ( self , coords , colour , bg ) : for i , ( x , y ) in enumerate ( coords ) : if i == 0 : self . _screen . move ( x , y ) else : self . _screen . draw ( x , y , colour = colour , bg = bg , thin = True )", "docstring_tokens": "Helper to draw lines connecting a set of nodes that are scaled for the Screen .", "label": 1}, {"idx": "cosqa-train-4423", "doc": "change directory cd function in python", "code": "def change_dir(directory):\n  \"\"\"\n  Wraps a function to run in a given directory.\n\n  \"\"\"\n  def cd_decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n      org_path = os.getcwd()\n      os.chdir(directory)\n      func(*args, **kwargs)\n      os.chdir(org_path)\n    return wrapper\n  return cd_decorator", "code_tokens": "def change_dir ( directory ) : def cd_decorator ( func ) : @ wraps ( func ) def wrapper ( * args , * * kwargs ) : org_path = os . getcwd ( ) os . chdir ( directory ) func ( * args , * * kwargs ) os . chdir ( org_path ) return wrapper return cd_decorator", "docstring_tokens": "Wraps a function to run in a given directory .", "label": 0}, {"idx": "cosqa-train-4424", "doc": "python drop columns that may or may not exist", "code": "def remove_non_magic_cols(self):\n        \"\"\"\n        Remove all non-MagIC columns from all tables.\n        \"\"\"\n        for table_name in self.tables:\n            table = self.tables[table_name]\n            table.remove_non_magic_cols_from_table()", "code_tokens": "def remove_non_magic_cols ( self ) : for table_name in self . tables : table = self . tables [ table_name ] table . remove_non_magic_cols_from_table ( )", "docstring_tokens": "Remove all non - MagIC columns from all tables .", "label": 0}, {"idx": "cosqa-train-4425", "doc": "python dynamic text input tkinter", "code": "def TextWidget(*args, **kw):\n    \"\"\"Forces a parameter value to be text\"\"\"\n    kw['value'] = str(kw['value'])\n    kw.pop('options', None)\n    return TextInput(*args,**kw)", "code_tokens": "def TextWidget ( * args , * * kw ) : kw [ 'value' ] = str ( kw [ 'value' ] ) kw . pop ( 'options' , None ) return TextInput ( * args , * * kw )", "docstring_tokens": "Forces a parameter value to be text", "label": 0}, {"idx": "cosqa-train-4426", "doc": "change numpy type to integer in python", "code": "def scale_dtype(arr, dtype):\n    \"\"\"Convert an array from 0..1 to dtype, scaling up linearly\n    \"\"\"\n    max_int = np.iinfo(dtype).max\n    return (arr * max_int).astype(dtype)", "code_tokens": "def scale_dtype ( arr , dtype ) : max_int = np . iinfo ( dtype ) . max return ( arr * max_int ) . astype ( dtype )", "docstring_tokens": "Convert an array from 0 .. 1 to dtype scaling up linearly", "label": 0}, {"idx": "cosqa-train-4427", "doc": "python dynamically set function name", "code": "def export(defn):\n    \"\"\"Decorator to explicitly mark functions that are exposed in a lib.\"\"\"\n    globals()[defn.__name__] = defn\n    __all__.append(defn.__name__)\n    return defn", "code_tokens": "def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "docstring_tokens": "Decorator to explicitly mark functions that are exposed in a lib .", "label": 0}, {"idx": "cosqa-train-4428", "doc": "change shape of an array in python", "code": "def shape_list(l,shape,dtype):\n    \"\"\" Shape a list of lists into the appropriate shape and data type \"\"\"\n    return np.array(l, dtype=dtype).reshape(shape)", "code_tokens": "def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )", "docstring_tokens": "Shape a list of lists into the appropriate shape and data type", "label": 0}, {"idx": "cosqa-train-4429", "doc": "python efficiently check if a image is valid jpeg", "code": "def ffmpeg_works():\n  \"\"\"Tries to encode images with ffmpeg to check if it works.\"\"\"\n  images = np.zeros((2, 32, 32, 3), dtype=np.uint8)\n  try:\n    _encode_gif(images, 2)\n    return True\n  except (IOError, OSError):\n    return False", "code_tokens": "def ffmpeg_works ( ) : images = np . zeros ( ( 2 , 32 , 32 , 3 ) , dtype = np . uint8 ) try : _encode_gif ( images , 2 ) return True except ( IOError , OSError ) : return False", "docstring_tokens": "Tries to encode images with ffmpeg to check if it works .", "label": 0}, {"idx": "cosqa-train-4430", "doc": "change the data type of datarframe column python", "code": "def _to_corrected_pandas_type(dt):\n    \"\"\"\n    When converting Spark SQL records to Pandas DataFrame, the inferred data type may be wrong.\n    This method gets the corrected data type for Pandas if that type may be inferred uncorrectly.\n    \"\"\"\n    import numpy as np\n    if type(dt) == ByteType:\n        return np.int8\n    elif type(dt) == ShortType:\n        return np.int16\n    elif type(dt) == IntegerType:\n        return np.int32\n    elif type(dt) == FloatType:\n        return np.float32\n    else:\n        return None", "code_tokens": "def _to_corrected_pandas_type ( dt ) : import numpy as np if type ( dt ) == ByteType : return np . int8 elif type ( dt ) == ShortType : return np . int16 elif type ( dt ) == IntegerType : return np . int32 elif type ( dt ) == FloatType : return np . float32 else : return None", "docstring_tokens": "When converting Spark SQL records to Pandas DataFrame the inferred data type may be wrong . This method gets the corrected data type for Pandas if that type may be inferred uncorrectly .", "label": 0}, {"idx": "cosqa-train-4431", "doc": "python elasticsearch accurate matching", "code": "def get_record_by_name(self, index, name):\n        \"\"\"\n        Searches for a single document in the given index on the 'name' field .\n        Performs a case-insensitive search by utilizing Elasticsearch's `match_phrase` query.\n    \n        Args:\n            index: `str`. The name of an Elasticsearch index (i.e. biosamples).\n            name: `str`. The value of a document's name key to search for.\n    \n        Returns:\n            `dict` containing the document that was indexed into Elasticsearch.\n    \n        Raises:\n            `MultipleHitsException`: More than 1 hit is returned.\n        \"\"\"\n        result = self.ES.search(\n            index=index,\n            body={\n                \"query\": {\n                    \"match_phrase\": {\n                        \"name\": name,\n                    }\n                }\n            }\n        )\n        hits = result[\"hits\"][\"hits\"]\n        if not hits:\n            return {}\n        elif len(hits) == 1:\n            return hits[0][\"_source\"]\n        else:\n            # Mult. records found with same prefix. See if a single record whose name attr matches\n            # the match phrase exactly (in a lower-case comparison).  \n            for h in hits:\n                source = h[\"_source\"]\n                record_name = source[\"name\"]\n                if record_name.lower().strip() == name.lower().strip():\n                    return source\n            msg = \"match_phrase search found multiple records matching query '{}' for index '{}'.\".format(name, index)\n            raise MultipleHitsException(msg)", "code_tokens": "def get_record_by_name ( self , index , name ) : result = self . ES . search ( index = index , body = { \"query\" : { \"match_phrase\" : { \"name\" : name , } } } ) hits = result [ \"hits\" ] [ \"hits\" ] if not hits : return { } elif len ( hits ) == 1 : return hits [ 0 ] [ \"_source\" ] else : # Mult. records found with same prefix. See if a single record whose name attr matches # the match phrase exactly (in a lower-case comparison).   for h in hits : source = h [ \"_source\" ] record_name = source [ \"name\" ] if record_name . lower ( ) . strip ( ) == name . lower ( ) . strip ( ) : return source msg = \"match_phrase search found multiple records matching query '{}' for index '{}'.\" . format ( name , index ) raise MultipleHitsException ( msg )", "docstring_tokens": "Searches for a single document in the given index on the name field . Performs a case - insensitive search by utilizing Elasticsearch s match_phrase query . Args : index : str . The name of an Elasticsearch index ( i . e . biosamples ) . name : str . The value of a document s name key to search for . Returns : dict containing the document that was indexed into Elasticsearch . Raises : MultipleHitsException : More than 1 hit is returned .", "label": 0}, {"idx": "cosqa-train-4432", "doc": "change timestamp column to datetime format column in python", "code": "def add_datetime(dataframe, timestamp_key='UNIXTIME'):\n    \"\"\"Add an additional DATETIME column with standar datetime format.\n\n    This currently manipulates the incoming DataFrame!\n    \"\"\"\n\n    def convert_data(timestamp):\n        return datetime.fromtimestamp(float(timestamp) / 1e3, UTC_TZ)\n\n    try:\n        log.debug(\"Adding DATETIME column to the data\")\n        converted = dataframe[timestamp_key].apply(convert_data)\n        dataframe['DATETIME'] = converted\n    except KeyError:\n        log.warning(\"Could not add DATETIME column\")", "code_tokens": "def add_datetime ( dataframe , timestamp_key = 'UNIXTIME' ) : def convert_data ( timestamp ) : return datetime . fromtimestamp ( float ( timestamp ) / 1e3 , UTC_TZ ) try : log . debug ( \"Adding DATETIME column to the data\" ) converted = dataframe [ timestamp_key ] . apply ( convert_data ) dataframe [ 'DATETIME' ] = converted except KeyError : log . warning ( \"Could not add DATETIME column\" )", "docstring_tokens": "Add an additional DATETIME column with standar datetime format .", "label": 0}, {"idx": "cosqa-train-4433", "doc": "python elasticsearch delete by query example", "code": "def clear_es():\n        \"\"\"Clear all indexes in the es core\"\"\"\n        # TODO: should receive a catalog slug.\n        ESHypermap.es.indices.delete(ESHypermap.index_name, ignore=[400, 404])\n        LOGGER.debug('Elasticsearch: Index cleared')", "code_tokens": "def clear_es ( ) : # TODO: should receive a catalog slug. ESHypermap . es . indices . delete ( ESHypermap . index_name , ignore = [ 400 , 404 ] ) LOGGER . debug ( 'Elasticsearch: Index cleared' )", "docstring_tokens": "Clear all indexes in the es core", "label": 0}, {"idx": "cosqa-train-4434", "doc": "change user agent for my crawler python", "code": "def copy_user_agent_from_driver(self):\n        \"\"\" Updates requests' session user-agent with the driver's user agent\n\n        This method will start the browser process if its not already running.\n        \"\"\"\n        selenium_user_agent = self.driver.execute_script(\"return navigator.userAgent;\")\n        self.headers.update({\"user-agent\": selenium_user_agent})", "code_tokens": "def copy_user_agent_from_driver ( self ) : selenium_user_agent = self . driver . execute_script ( \"return navigator.userAgent;\" ) self . headers . update ( { \"user-agent\" : selenium_user_agent } )", "docstring_tokens": "Updates requests session user - agent with the driver s user agent", "label": 0}, {"idx": "cosqa-train-4435", "doc": "python elasticsearch get all indices", "code": "def keys(self):\n        \"\"\"Return ids of all indexed documents.\"\"\"\n        result = []\n        if self.fresh_index is not None:\n            result += self.fresh_index.keys()\n        if self.opt_index is not None:\n            result += self.opt_index.keys()\n        return result", "code_tokens": "def keys ( self ) : result = [ ] if self . fresh_index is not None : result += self . fresh_index . keys ( ) if self . opt_index is not None : result += self . opt_index . keys ( ) return result", "docstring_tokens": "Return ids of all indexed documents .", "label": 0}, {"idx": "cosqa-train-4436", "doc": "change year of datetime python", "code": "def move_datetime_year(dt, direction, num_shifts):\n    \"\"\"\n    Move datetime 1 year in the chosen direction.\n    unit is a no-op, to keep the API the same as the day case\n    \"\"\"\n    delta = relativedelta(years=+num_shifts)\n    return _move_datetime(dt, direction, delta)", "code_tokens": "def move_datetime_year ( dt , direction , num_shifts ) : delta = relativedelta ( years = + num_shifts ) return _move_datetime ( dt , direction , delta )", "docstring_tokens": "Move datetime 1 year in the chosen direction . unit is a no - op to keep the API the same as the day case", "label": 0}, {"idx": "cosqa-train-4437", "doc": "python elasticsearch get all results", "code": "def all_documents(index=INDEX_NAME):\n    \"\"\"\n    Get all documents from the given index.\n\n    Returns full Elasticsearch objects so you can get metadata too.\n    \"\"\"\n    query = {\n        'query': {\n            'match_all': {}\n        }\n    }\n    for result in raw_query(query, index=index):\n        yield result", "code_tokens": "def all_documents ( index = INDEX_NAME ) : query = { 'query' : { 'match_all' : { } } } for result in raw_query ( query , index = index ) : yield result", "docstring_tokens": "Get all documents from the given index .", "label": 0}, {"idx": "cosqa-train-4438", "doc": "changing an array to a list python", "code": "def flat(l):\n    \"\"\"\nReturns the flattened version of a '2D' list.  List-correlate to the a.flat()\nmethod of NumPy arrays.\n\nUsage:    flat(l)\n\"\"\"\n    newl = []\n    for i in range(len(l)):\n        for j in range(len(l[i])):\n            newl.append(l[i][j])\n    return newl", "code_tokens": "def flat ( l ) : newl = [ ] for i in range ( len ( l ) ) : for j in range ( len ( l [ i ] ) ) : newl . append ( l [ i ] [ j ] ) return newl", "docstring_tokens": "Returns the flattened version of a 2D list . List - correlate to the a . flat () method of NumPy arrays .", "label": 1}, {"idx": "cosqa-train-4439", "doc": "python element tree get an element by name", "code": "def get_by(self, name):\n    \"\"\"get element by name\"\"\"\n    return next((item for item in self if item.name == name), None)", "code_tokens": "def get_by ( self , name ) : return next ( ( item for item in self if item . name == name ) , None )", "docstring_tokens": "get element by name", "label": 0}, {"idx": "cosqa-train-4440", "doc": "python element wise sign", "code": "def Softsign(a):\n    \"\"\"\n    Softsign op.\n    \"\"\"\n    return np.divide(a, np.add(np.abs(a), 1)),", "code_tokens": "def Softsign ( a ) : return np . divide ( a , np . add ( np . abs ( a ) , 1 ) ) ,", "docstring_tokens": "Softsign op .", "label": 0}, {"idx": "cosqa-train-4441", "doc": "changing window title in python", "code": "def title(msg):\n    \"\"\"Sets the title of the console window.\"\"\"\n    if sys.platform.startswith(\"win\"):\n        ctypes.windll.kernel32.SetConsoleTitleW(tounicode(msg))", "code_tokens": "def title ( msg ) : if sys . platform . startswith ( \"win\" ) : ctypes . windll . kernel32 . SetConsoleTitleW ( tounicode ( msg ) )", "docstring_tokens": "Sets the title of the console window .", "label": 0}, {"idx": "cosqa-train-4442", "doc": "cheat engine python value type", "code": "def _extract_value(self, value):\n        \"\"\"If the value is true/false/null replace with Python equivalent.\"\"\"\n        return ModelEndpoint._value_map.get(smart_str(value).lower(), value)", "code_tokens": "def _extract_value ( self , value ) : return ModelEndpoint . _value_map . get ( smart_str ( value ) . lower ( ) , value )", "docstring_tokens": "If the value is true / false / null replace with Python equivalent .", "label": 0}, {"idx": "cosqa-train-4443", "doc": "python elementtree get attribute", "code": "def __getattribute__(self, attr):\n        \"\"\"Retrieve attr from current active etree implementation\"\"\"\n        if (attr not in object.__getattribute__(self, '__dict__')\n                and attr not in Etree.__dict__):\n            return object.__getattribute__(self._etree, attr)\n        return object.__getattribute__(self, attr)", "code_tokens": "def __getattribute__ ( self , attr ) : if ( attr not in object . __getattribute__ ( self , '__dict__' ) and attr not in Etree . __dict__ ) : return object . __getattribute__ ( self . _etree , attr ) return object . __getattribute__ ( self , attr )", "docstring_tokens": "Retrieve attr from current active etree implementation", "label": 0}, {"idx": "cosqa-train-4444", "doc": "check base64 encoding in python", "code": "def decode_unicode_string(string):\n    \"\"\"\n    Decode string encoded by `unicode_string`\n    \"\"\"\n    if string.startswith('[BASE64-DATA]') and string.endswith('[/BASE64-DATA]'):\n        return base64.b64decode(string[len('[BASE64-DATA]'):-len('[/BASE64-DATA]')])\n    return string", "code_tokens": "def decode_unicode_string ( string ) : if string . startswith ( '[BASE64-DATA]' ) and string . endswith ( '[/BASE64-DATA]' ) : return base64 . b64decode ( string [ len ( '[BASE64-DATA]' ) : - len ( '[/BASE64-DATA]' ) ] ) return string", "docstring_tokens": "Decode string encoded by unicode_string", "label": 0}, {"idx": "cosqa-train-4445", "doc": "python elementtree get parent node", "code": "def root_parent(self, category=None):\n        \"\"\" Returns the topmost parent of the current category. \"\"\"\n        return next(filter(lambda c: c.is_root, self.hierarchy()))", "code_tokens": "def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )", "docstring_tokens": "Returns the topmost parent of the current category .", "label": 0}, {"idx": "cosqa-train-4446", "doc": "check contents of a tuple in a list python", "code": "def is_list_of_list(item):\n    \"\"\"\n    check whether the item is list (tuple)\n    and consist of list (tuple) elements\n    \"\"\"\n    if (\n        type(item) in (list, tuple)\n        and len(item)\n        and isinstance(item[0], (list, tuple))\n    ):\n        return True\n    return False", "code_tokens": "def is_list_of_list ( item ) : if ( type ( item ) in ( list , tuple ) and len ( item ) and isinstance ( item [ 0 ] , ( list , tuple ) ) ) : return True return False", "docstring_tokens": "check whether the item is list ( tuple ) and consist of list ( tuple ) elements", "label": 1}, {"idx": "cosqa-train-4447", "doc": "python elementtree replace value", "code": "def add_element_to_doc(doc, tag, value):\n    \"\"\"Set text value of an etree.Element of tag, appending a new element with given tag if it doesn't exist.\"\"\"\n    element = doc.find(\".//%s\" % tag)\n    if element is None:\n        element = etree.SubElement(doc, tag)\n    element.text = value", "code_tokens": "def add_element_to_doc ( doc , tag , value ) : element = doc . find ( \".//%s\" % tag ) if element is None : element = etree . SubElement ( doc , tag ) element . text = value", "docstring_tokens": "Set text value of an etree . Element of tag appending a new element with given tag if it doesn t exist .", "label": 0}, {"idx": "cosqa-train-4448", "doc": "check for element in array except for one python", "code": "def isin(value, values):\n    \"\"\" Check that value is in values \"\"\"\n    for i, v in enumerate(value):\n        if v not in np.array(values)[:, i]:\n            return False\n    return True", "code_tokens": "def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True", "docstring_tokens": "Check that value is in values", "label": 0}, {"idx": "cosqa-train-4449", "doc": "python encoding is invalude for open", "code": "def read_from_file(file_path, encoding=\"utf-8\"):\n    \"\"\"\n    Read helper method\n\n    :type file_path: str|unicode\n    :type encoding: str|unicode\n    :rtype: str|unicode\n    \"\"\"\n    with codecs.open(file_path, \"r\", encoding) as f:\n        return f.read()", "code_tokens": "def read_from_file ( file_path , encoding = \"utf-8\" ) : with codecs . open ( file_path , \"r\" , encoding ) as f : return f . read ( )", "docstring_tokens": "Read helper method", "label": 0}, {"idx": "cosqa-train-4450", "doc": "check for not nonetype python", "code": "def is_sequence(obj):\n    \"\"\"Check if `obj` is a sequence, but not a string or bytes.\"\"\"\n    return isinstance(obj, Sequence) and not (\n        isinstance(obj, str) or BinaryClass.is_valid_type(obj))", "code_tokens": "def is_sequence ( obj ) : return isinstance ( obj , Sequence ) and not ( isinstance ( obj , str ) or BinaryClass . is_valid_type ( obj ) )", "docstring_tokens": "Check if obj is a sequence but not a string or bytes .", "label": 0}, {"idx": "cosqa-train-4451", "doc": "python english word spelling corrector text with no space", "code": "def _to_lower_alpha_only(s):\n    \"\"\"Return a lowercased string with non alphabetic chars removed.\n\n    White spaces are not to be removed.\"\"\"\n    s = re.sub(r'\\n', ' ',  s.lower())\n    return re.sub(r'[^a-z\\s]', '', s)", "code_tokens": "def _to_lower_alpha_only ( s ) : s = re . sub ( r'\\n' , ' ' , s . lower ( ) ) return re . sub ( r'[^a-z\\s]' , '' , s )", "docstring_tokens": "Return a lowercased string with non alphabetic chars removed .", "label": 0}, {"idx": "cosqa-train-4452", "doc": "check for values in an array python", "code": "def isin(value, values):\n    \"\"\" Check that value is in values \"\"\"\n    for i, v in enumerate(value):\n        if v not in np.array(values)[:, i]:\n            return False\n    return True", "code_tokens": "def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True", "docstring_tokens": "Check that value is in values", "label": 0}, {"idx": "cosqa-train-4453", "doc": "python enum index name", "code": "def write_enum(fo, datum, schema):\n    \"\"\"An enum is encoded by a int, representing the zero-based position of\n    the symbol in the schema.\"\"\"\n    index = schema['symbols'].index(datum)\n    write_int(fo, index)", "code_tokens": "def write_enum ( fo , datum , schema ) : index = schema [ 'symbols' ] . index ( datum ) write_int ( fo , index )", "docstring_tokens": "An enum is encoded by a int representing the zero - based position of the symbol in the schema .", "label": 0}, {"idx": "cosqa-train-4454", "doc": "check if a connection is made to a port python", "code": "def is_http_running_on(port):\n  \"\"\" Check if an http server runs on a given port.\n\n  Args:\n    The port to check.\n  Returns:\n    True if it is used by an http server. False otherwise.\n  \"\"\"\n  try:\n    conn = httplib.HTTPConnection('127.0.0.1:' + str(port))\n    conn.connect()\n    conn.close()\n    return True\n  except Exception:\n    return False", "code_tokens": "def is_http_running_on ( port ) : try : conn = httplib . HTTPConnection ( '127.0.0.1:' + str ( port ) ) conn . connect ( ) conn . close ( ) return True except Exception : return False", "docstring_tokens": "Check if an http server runs on a given port .", "label": 1}, {"idx": "cosqa-train-4455", "doc": "python excetion text on several lines", "code": "def make_exception_message(exc):\n    \"\"\"\n    An exception is passed in and this function\n    returns the proper string depending on the result\n    so it is readable enough.\n    \"\"\"\n    if str(exc):\n        return '%s: %s\\n' % (exc.__class__.__name__, exc)\n    else:\n        return '%s\\n' % (exc.__class__.__name__)", "code_tokens": "def make_exception_message ( exc ) : if str ( exc ) : return '%s: %s\\n' % ( exc . __class__ . __name__ , exc ) else : return '%s\\n' % ( exc . __class__ . __name__ )", "docstring_tokens": "An exception is passed in and this function returns the proper string depending on the result so it is readable enough .", "label": 1}, {"idx": "cosqa-train-4456", "doc": "python exec globals locals", "code": "def exec_function(ast, globals_map):\n    \"\"\"Execute a python code object in the given environment.\n\n    Args:\n      globals_map: Dictionary to use as the globals context.\n    Returns:\n      locals_map: Dictionary of locals from the environment after execution.\n    \"\"\"\n    locals_map = globals_map\n    exec ast in globals_map, locals_map\n    return locals_map", "code_tokens": "def exec_function ( ast , globals_map ) : locals_map = globals_map exec ast in globals_map , locals_map return locals_map", "docstring_tokens": "Execute a python code object in the given environment .", "label": 0}, {"idx": "cosqa-train-4457", "doc": "check if a key exist json python", "code": "def task_property_present_predicate(service, task, prop):\n    \"\"\" True if the json_element passed is present for the task specified.\n    \"\"\"\n    try:\n        response = get_service_task(service, task)\n    except Exception as e:\n        pass\n\n    return (response is not None) and (prop in response)", "code_tokens": "def task_property_present_predicate ( service , task , prop ) : try : response = get_service_task ( service , task ) except Exception as e : pass return ( response is not None ) and ( prop in response )", "docstring_tokens": "True if the json_element passed is present for the task specified .", "label": 0}, {"idx": "cosqa-train-4458", "doc": "python exit too quick", "code": "def fast_exit(code):\n    \"\"\"Exit without garbage collection, this speeds up exit by about 10ms for\n    things like bash completion.\n    \"\"\"\n    sys.stdout.flush()\n    sys.stderr.flush()\n    os._exit(code)", "code_tokens": "def fast_exit ( code ) : sys . stdout . flush ( ) sys . stderr . flush ( ) os . _exit ( code )", "docstring_tokens": "Exit without garbage collection this speeds up exit by about 10ms for things like bash completion .", "label": 0}, {"idx": "cosqa-train-4459", "doc": "check if a number is in type of float python", "code": "def is_float_array(val):\n    \"\"\"\n    Checks whether a variable is a numpy float array.\n\n    Parameters\n    ----------\n    val\n        The variable to check.\n\n    Returns\n    -------\n    bool\n        True if the variable is a numpy float array. Otherwise False.\n\n    \"\"\"\n    return is_np_array(val) and issubclass(val.dtype.type, np.floating)", "code_tokens": "def is_float_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . floating )", "docstring_tokens": "Checks whether a variable is a numpy float array .", "label": 0}, {"idx": "cosqa-train-4460", "doc": "python expand array into **kwargs", "code": "def prepare_query_params(**kwargs):\n    \"\"\"\n    Prepares given parameters to be used in querystring.\n    \"\"\"\n    return [\n        (sub_key, sub_value)\n        for key, value in kwargs.items()\n        for sub_key, sub_value in expand(value, key)\n        if sub_value is not None\n    ]", "code_tokens": "def prepare_query_params ( * * kwargs ) : return [ ( sub_key , sub_value ) for key , value in kwargs . items ( ) for sub_key , sub_value in expand ( value , key ) if sub_value is not None ]", "docstring_tokens": "Prepares given parameters to be used in querystring .", "label": 0}, {"idx": "cosqa-train-4461", "doc": "check if a variable is iterable python", "code": "def is_iterable_but_not_string(obj):\n    \"\"\"\n    Determine whether or not obj is iterable but not a string (eg, a list, set, tuple etc).\n    \"\"\"\n    return hasattr(obj, '__iter__') and not isinstance(obj, str) and not isinstance(obj, bytes)", "code_tokens": "def is_iterable_but_not_string ( obj ) : return hasattr ( obj , '__iter__' ) and not isinstance ( obj , str ) and not isinstance ( obj , bytes )", "docstring_tokens": "Determine whether or not obj is iterable but not a string ( eg a list set tuple etc ) .", "label": 1}, {"idx": "cosqa-train-4462", "doc": "python expand environment variables in string", "code": "def expandvars_dict(settings):\n    \"\"\"Expands all environment variables in a settings dictionary.\"\"\"\n    return dict(\n        (key, os.path.expandvars(value))\n        for key, value in settings.iteritems()\n    )", "code_tokens": "def expandvars_dict ( settings ) : return dict ( ( key , os . path . expandvars ( value ) ) for key , value in settings . iteritems ( ) )", "docstring_tokens": "Expands all environment variables in a settings dictionary .", "label": 0}, {"idx": "cosqa-train-4463", "doc": "check if address is valid python", "code": "def is_valid_ipv6(ip_str):\n    \"\"\"\n    Check the validity of an IPv6 address\n    \"\"\"\n    try:\n        socket.inet_pton(socket.AF_INET6, ip_str)\n    except socket.error:\n        return False\n    return True", "code_tokens": "def is_valid_ipv6 ( ip_str ) : try : socket . inet_pton ( socket . AF_INET6 , ip_str ) except socket . error : return False return True", "docstring_tokens": "Check the validity of an IPv6 address", "label": 1}, {"idx": "cosqa-train-4464", "doc": "python extract all numbers in a string", "code": "def get_numbers(s):\n    \"\"\"Extracts all integers from a string an return them in a list\"\"\"\n\n    result = map(int, re.findall(r'[0-9]+', unicode(s)))\n    return result + [1] * (2 - len(result))", "code_tokens": "def get_numbers ( s ) : result = map ( int , re . findall ( r'[0-9]+' , unicode ( s ) ) ) return result + [ 1 ] * ( 2 - len ( result ) )", "docstring_tokens": "Extracts all integers from a string an return them in a list", "label": 1}, {"idx": "cosqa-train-4465", "doc": "check if an object is nested arbitrarily deep within a tuple python", "code": "def is_nested_object(obj):\n    \"\"\"\n    return a boolean if we have a nested object, e.g. a Series with 1 or\n    more Series elements\n\n    This may not be necessarily be performant.\n\n    \"\"\"\n\n    if isinstance(obj, ABCSeries) and is_object_dtype(obj):\n\n        if any(isinstance(v, ABCSeries) for v in obj.values):\n            return True\n\n    return False", "code_tokens": "def is_nested_object ( obj ) : if isinstance ( obj , ABCSeries ) and is_object_dtype ( obj ) : if any ( isinstance ( v , ABCSeries ) for v in obj . values ) : return True return False", "docstring_tokens": "return a boolean if we have a nested object e . g . a Series with 1 or more Series elements", "label": 1}, {"idx": "cosqa-train-4466", "doc": "python extract text with indentation in txt file", "code": "def get_indent(text):\n    \"\"\"Get indent of text.\n\n    https://stackoverflow.com/questions/2268532/grab-a-lines-whitespace-\n    indention-with-python\n    \"\"\"\n    indent = ''\n\n    ret = re.match(r'(\\s*)', text)\n    if ret:\n        indent = ret.group(1)\n\n    return indent", "code_tokens": "def get_indent ( text ) : indent = '' ret = re . match ( r'(\\s*)' , text ) if ret : indent = ret . group ( 1 ) return indent", "docstring_tokens": "Get indent of text . https : // stackoverflow . com / questions / 2268532 / grab - a - lines - whitespace - indention - with - python", "label": 0}, {"idx": "cosqa-train-4467", "doc": "check if datetime obj none in python", "code": "def is_date(thing):\n    \"\"\"Checks if the given thing represents a date\n\n    :param thing: The object to check if it is a date\n    :type thing: arbitrary object\n    :returns: True if we have a date object\n    :rtype: bool\n    \"\"\"\n    # known date types\n    date_types = (datetime.datetime,\n                  datetime.date,\n                  DateTime)\n    return isinstance(thing, date_types)", "code_tokens": "def is_date ( thing ) : # known date types date_types = ( datetime . datetime , datetime . date , DateTime ) return isinstance ( thing , date_types )", "docstring_tokens": "Checks if the given thing represents a date", "label": 0}, {"idx": "cosqa-train-4468", "doc": "python fastest way to load data", "code": "def get_data(self):\n        \"\"\"\n        Fetch the data field if it does not exist.\n        \"\"\"\n        try:\n            return DocumentDataDict(self.__dict__['data'])\n        except KeyError:\n            self._lazy_load()\n            return DocumentDataDict(self.__dict__['data'])", "code_tokens": "def get_data ( self ) : try : return DocumentDataDict ( self . __dict__ [ 'data' ] ) except KeyError : self . _lazy_load ( ) return DocumentDataDict ( self . __dict__ [ 'data' ] )", "docstring_tokens": "Fetch the data field if it does not exist .", "label": 1}, {"idx": "cosqa-train-4469", "doc": "check if dtype is string python", "code": "def _isstring(dtype):\n    \"\"\"Given a numpy dtype, determines whether it is a string. Returns True\n    if the dtype is string or unicode.\n    \"\"\"\n    return dtype.type == numpy.unicode_ or dtype.type == numpy.string_", "code_tokens": "def _isstring ( dtype ) : return dtype . type == numpy . unicode_ or dtype . type == numpy . string_", "docstring_tokens": "Given a numpy dtype determines whether it is a string . Returns True if the dtype is string or unicode .", "label": 1}, {"idx": "cosqa-train-4470", "doc": "python fastest way to test if object is callable", "code": "def is_function(self):\n        \"\"\"return True if callback is a vanilla plain jane function\"\"\"\n        if self.is_instance() or self.is_class(): return False\n        return isinstance(self.callback, (Callable, classmethod))", "code_tokens": "def is_function ( self ) : if self . is_instance ( ) or self . is_class ( ) : return False return isinstance ( self . callback , ( Callable , classmethod ) )", "docstring_tokens": "return True if callback is a vanilla plain jane function", "label": 0}, {"idx": "cosqa-train-4471", "doc": "check if env exists python", "code": "def launched():\n    \"\"\"Test whether the current python environment is the correct lore env.\n\n    :return:  :any:`True` if the environment is launched\n    :rtype: bool\n    \"\"\"\n    if not PREFIX:\n        return False\n\n    return os.path.realpath(sys.prefix) == os.path.realpath(PREFIX)", "code_tokens": "def launched ( ) : if not PREFIX : return False return os . path . realpath ( sys . prefix ) == os . path . realpath ( PREFIX )", "docstring_tokens": "Test whether the current python environment is the correct lore env .", "label": 0}, {"idx": "cosqa-train-4472", "doc": "python ffmpeg was not found", "code": "def ffmpeg_version():\n    \"\"\"Returns the available ffmpeg version\n\n    Returns\n    ----------\n    version : str\n        version number as string\n    \"\"\"\n\n    cmd = [\n        'ffmpeg',\n        '-version'\n    ]\n\n    output = sp.check_output(cmd)\n    aac_codecs = [\n        x for x in\n        output.splitlines() if \"ffmpeg version \" in str(x)\n    ][0]\n    hay = aac_codecs.decode('ascii')\n    match = re.findall(r'ffmpeg version (\\d+\\.)?(\\d+\\.)?(\\*|\\d+)', hay)\n    if match:\n        return \"\".join(match[0])\n    else:\n        return None", "code_tokens": "def ffmpeg_version ( ) : cmd = [ 'ffmpeg' , '-version' ] output = sp . check_output ( cmd ) aac_codecs = [ x for x in output . splitlines ( ) if \"ffmpeg version \" in str ( x ) ] [ 0 ] hay = aac_codecs . decode ( 'ascii' ) match = re . findall ( r'ffmpeg version (\\d+\\.)?(\\d+\\.)?(\\*|\\d+)' , hay ) if match : return \"\" . join ( match [ 0 ] ) else : return None", "docstring_tokens": "Returns the available ffmpeg version", "label": 0}, {"idx": "cosqa-train-4473", "doc": "check if file is json python", "code": "def is_json_file(filename, show_warnings = False):\n    \"\"\"Check configuration file type is JSON\n    Return a boolean indicating wheather the file is JSON format or not\n    \"\"\"\n    try:\n        config_dict = load_config(filename, file_type = \"json\")\n        is_json = True\n    except:\n        is_json = False\n    return(is_json)", "code_tokens": "def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = \"json\" ) is_json = True except : is_json = False return ( is_json )", "docstring_tokens": "Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not", "label": 0}, {"idx": "cosqa-train-4474", "doc": "python fft high frequency resolution", "code": "def fft_freqs(n_fft, fs):\n    \"\"\"Return frequencies for DFT\n\n    Parameters\n    ----------\n    n_fft : int\n        Number of points in the FFT.\n    fs : float\n        The sampling rate.\n    \"\"\"\n    return np.arange(0, (n_fft // 2 + 1)) / float(n_fft) * float(fs)", "code_tokens": "def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )", "docstring_tokens": "Return frequencies for DFT", "label": 0}, {"idx": "cosqa-train-4475", "doc": "check if files are same python", "code": "def is_same_file (filename1, filename2):\n    \"\"\"Check if filename1 and filename2 point to the same file object.\n    There can be false negatives, ie. the result is False, but it is\n    the same file anyway. Reason is that network filesystems can create\n    different paths to the same physical file.\n    \"\"\"\n    if filename1 == filename2:\n        return True\n    if os.name == 'posix':\n        return os.path.samefile(filename1, filename2)\n    return is_same_filename(filename1, filename2)", "code_tokens": "def is_same_file ( filename1 , filename2 ) : if filename1 == filename2 : return True if os . name == 'posix' : return os . path . samefile ( filename1 , filename2 ) return is_same_filename ( filename1 , filename2 )", "docstring_tokens": "Check if filename1 and filename2 point to the same file object . There can be false negatives ie . the result is False but it is the same file anyway . Reason is that network filesystems can create different paths to the same physical file .", "label": 1}, {"idx": "cosqa-train-4476", "doc": "python fft returrn frequencies", "code": "def fft_freqs(n_fft, fs):\n    \"\"\"Return frequencies for DFT\n\n    Parameters\n    ----------\n    n_fft : int\n        Number of points in the FFT.\n    fs : float\n        The sampling rate.\n    \"\"\"\n    return np.arange(0, (n_fft // 2 + 1)) / float(n_fft) * float(fs)", "code_tokens": "def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )", "docstring_tokens": "Return frequencies for DFT", "label": 0}, {"idx": "cosqa-train-4477", "doc": "check if input is integer or list python", "code": "def is_iterable_of_int(l):\n    r\"\"\" Checks if l is iterable and contains only integral types \"\"\"\n    if not is_iterable(l):\n        return False\n\n    return all(is_int(value) for value in l)", "code_tokens": "def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )", "docstring_tokens": "r Checks if l is iterable and contains only integral types", "label": 0}, {"idx": "cosqa-train-4478", "doc": "python file opens then closes", "code": "def file_read(filename):\n    \"\"\"Read a file and close it.  Returns the file source.\"\"\"\n    fobj = open(filename,'r');\n    source = fobj.read();\n    fobj.close()\n    return source", "code_tokens": "def file_read ( filename ) : fobj = open ( filename , 'r' ) source = fobj . read ( ) fobj . close ( ) return source", "docstring_tokens": "Read a file and close it . Returns the file source .", "label": 0}, {"idx": "cosqa-train-4479", "doc": "check if linux python", "code": "def is_archlinux():\n    \"\"\"return True if the current distribution is running on debian like OS.\"\"\"\n    if platform.system().lower() == 'linux':\n        if platform.linux_distribution() == ('', '', ''):\n            # undefined distribution. Fixed in python 3.\n            if os.path.exists('/etc/arch-release'):\n                return True\n    return False", "code_tokens": "def is_archlinux ( ) : if platform . system ( ) . lower ( ) == 'linux' : if platform . linux_distribution ( ) == ( '' , '' , '' ) : # undefined distribution. Fixed in python 3. if os . path . exists ( '/etc/arch-release' ) : return True return False", "docstring_tokens": "return True if the current distribution is running on debian like OS .", "label": 1}, {"idx": "cosqa-train-4480", "doc": "python fillna with value for specific columns", "code": "def _maybe_fill(arr, fill_value=np.nan):\n    \"\"\"\n    if we have a compatible fill_value and arr dtype, then fill\n    \"\"\"\n    if _isna_compat(arr, fill_value):\n        arr.fill(fill_value)\n    return arr", "code_tokens": "def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr", "docstring_tokens": "if we have a compatible fill_value and arr dtype then fill", "label": 1}, {"idx": "cosqa-train-4481", "doc": "check if object is sequence python", "code": "def _is_proper_sequence(seq):\n    \"\"\"Returns is seq is sequence and not string.\"\"\"\n    return (isinstance(seq, collections.abc.Sequence) and\n            not isinstance(seq, str))", "code_tokens": "def _is_proper_sequence ( seq ) : return ( isinstance ( seq , collections . abc . Sequence ) and not isinstance ( seq , str ) )", "docstring_tokens": "Returns is seq is sequence and not string .", "label": 1}, {"idx": "cosqa-train-4482", "doc": "python filter columns in a defintion", "code": "def get_column_definition(self, table, column):\n        \"\"\"Retrieve the column definition statement for a column from a table.\"\"\"\n        # Parse column definitions for match\n        for col in self.get_column_definition_all(table):\n            if col.strip('`').startswith(column):\n                return col.strip(',')", "code_tokens": "def get_column_definition ( self , table , column ) : # Parse column definitions for match for col in self . get_column_definition_all ( table ) : if col . strip ( '`' ) . startswith ( column ) : return col . strip ( ',' )", "docstring_tokens": "Retrieve the column definition statement for a column from a table .", "label": 0}, {"idx": "cosqa-train-4483", "doc": "check if sentence is palindrome python", "code": "def is_palindrome(string, strict=True):\n    \"\"\"\n    Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n    :param string: String to check.\n    :type string: str\n    :param strict: True if white spaces matter (default), false otherwise.\n    :type strict: bool\n    :return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),\n    False otherwise\n    \"\"\"\n    if is_full_string(string):\n        if strict:\n            return reverse(string) == string\n        return is_palindrome(SPACES_RE.sub('', string))\n    return False", "code_tokens": "def is_palindrome ( string , strict = True ) : if is_full_string ( string ) : if strict : return reverse ( string ) == string return is_palindrome ( SPACES_RE . sub ( '' , string ) ) return False", "docstring_tokens": "Checks if the string is a palindrome ( https : // en . wikipedia . org / wiki / Palindrome ) .", "label": 0}, {"idx": "cosqa-train-4484", "doc": "python filter entries in dictionary", "code": "def filter_dict_by_key(d, keys):\n    \"\"\"Filter the dict *d* to remove keys not in *keys*.\"\"\"\n    return {k: v for k, v in d.items() if k in keys}", "code_tokens": "def filter_dict_by_key ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "docstring_tokens": "Filter the dict * d * to remove keys not in * keys * .", "label": 0}, {"idx": "cosqa-train-4485", "doc": "check if two strings are the same python", "code": "def eqstr(a, b):\n    \"\"\"\n    Determine whether two strings are equivalent.\n\n    http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/eqstr_c.html\n\n    :param a: Arbitrary character string.\n    :type a: str\n    :param b: Arbitrary character string.\n    :type b: str\n    :return: True if A and B are equivalent.\n    :rtype: bool\n    \"\"\"\n    return bool(libspice.eqstr_c(stypes.stringToCharP(a), stypes.stringToCharP(b)))", "code_tokens": "def eqstr ( a , b ) : return bool ( libspice . eqstr_c ( stypes . stringToCharP ( a ) , stypes . stringToCharP ( b ) ) )", "docstring_tokens": "Determine whether two strings are equivalent .", "label": 1}, {"idx": "cosqa-train-4486", "doc": "python filter nulls numpy", "code": "def remove_na_arraylike(arr):\n    \"\"\"\n    Return array-like containing only true/non-NaN values, possibly empty.\n    \"\"\"\n    if is_extension_array_dtype(arr):\n        return arr[notna(arr)]\n    else:\n        return arr[notna(lib.values_from_object(arr))]", "code_tokens": "def remove_na_arraylike ( arr ) : if is_extension_array_dtype ( arr ) : return arr [ notna ( arr ) ] else : return arr [ notna ( lib . values_from_object ( arr ) ) ]", "docstring_tokens": "Return array - like containing only true / non - NaN values possibly empty .", "label": 0}, {"idx": "cosqa-train-4487", "doc": "check if value is float in python", "code": "def test_value(self, value):\n        \"\"\"Test if value is an instance of float.\"\"\"\n        if not isinstance(value, float):\n            raise ValueError('expected float value: ' + str(type(value)))", "code_tokens": "def test_value ( self , value ) : if not isinstance ( value , float ) : raise ValueError ( 'expected float value: ' + str ( type ( value ) ) )", "docstring_tokens": "Test if value is an instance of float .", "label": 0}, {"idx": "cosqa-train-4488", "doc": "python finding a a value in list of tuples", "code": "def tuple_search(t, i, v):\n    \"\"\"\n    Search tuple array by index and value\n    :param t: tuple array\n    :param i: index of the value in each tuple\n    :param v: value\n    :return: the first tuple in the array with the specific index / value\n    \"\"\"\n    for e in t:\n        if e[i] == v:\n            return e\n    return None", "code_tokens": "def tuple_search ( t , i , v ) : for e in t : if e [ i ] == v : return e return None", "docstring_tokens": "Search tuple array by index and value : param t : tuple array : param i : index of the value in each tuple : param v : value : return : the first tuple in the array with the specific index / value", "label": 1}, {"idx": "cosqa-train-4489", "doc": "check if variable is a string in python 3", "code": "def is_valid_variable_name(string_to_check):\n    \"\"\"\n    Returns whether the provided name is a valid variable name in Python\n\n    :param string_to_check: the string to be checked\n    :return: True or False\n    \"\"\"\n\n    try:\n\n        parse('{} = None'.format(string_to_check))\n        return True\n\n    except (SyntaxError, ValueError, TypeError):\n\n        return False", "code_tokens": "def is_valid_variable_name ( string_to_check ) : try : parse ( '{} = None' . format ( string_to_check ) ) return True except ( SyntaxError , ValueError , TypeError ) : return False", "docstring_tokens": "Returns whether the provided name is a valid variable name in Python", "label": 0}, {"idx": "cosqa-train-4490", "doc": "python finding factors of a number", "code": "def _factor_generator(n):\n    \"\"\"\n    From a given natural integer, returns the prime factors and their multiplicity\n    :param n: Natural integer\n    :return:\n    \"\"\"\n    p = prime_factors(n)\n    factors = {}\n    for p1 in p:\n        try:\n            factors[p1] += 1\n        except KeyError:\n            factors[p1] = 1\n    return factors", "code_tokens": "def _factor_generator ( n ) : p = prime_factors ( n ) factors = { } for p1 in p : try : factors [ p1 ] += 1 except KeyError : factors [ p1 ] = 1 return factors", "docstring_tokens": "From a given natural integer returns the prime factors and their multiplicity : param n : Natural integer : return :", "label": 0}, {"idx": "cosqa-train-4491", "doc": "check if variable is string or int or double using python", "code": "def contains_geometric_info(var):\n    \"\"\" Check whether the passed variable is a tuple with two floats or integers \"\"\"\n    return isinstance(var, tuple) and len(var) == 2 and all(isinstance(val, (int, float)) for val in var)", "code_tokens": "def contains_geometric_info ( var ) : return isinstance ( var , tuple ) and len ( var ) == 2 and all ( isinstance ( val , ( int , float ) ) for val in var )", "docstring_tokens": "Check whether the passed variable is a tuple with two floats or integers", "label": 0}, {"idx": "cosqa-train-4492", "doc": "python finding the first element or blank in array", "code": "def findfirst(f, coll):\n    \"\"\"Return first occurrence matching f, otherwise None\"\"\"\n    result = list(dropwhile(f, coll))\n    return result[0] if result else None", "code_tokens": "def findfirst ( f , coll ) : result = list ( dropwhile ( f , coll ) ) return result [ 0 ] if result else None", "docstring_tokens": "Return first occurrence matching f otherwise None", "label": 0}, {"idx": "cosqa-train-4493", "doc": "check matrix empty python", "code": "def contains_empty(features):\n    \"\"\"Check features data are not empty\n\n    :param features: The features data to check.\n    :type features: list of numpy arrays.\n\n    :return: True if one of the array is empty, False else.\n\n    \"\"\"\n    if not features:\n        return True\n    for feature in features:\n        if feature.shape[0] == 0:\n            return True\n    return False", "code_tokens": "def contains_empty ( features ) : if not features : return True for feature in features : if feature . shape [ 0 ] == 0 : return True return False", "docstring_tokens": "Check features data are not empty", "label": 0}, {"idx": "cosqa-train-4494", "doc": "python fit random points to a gaussian distribution", "code": "def fit_gaussian(x, y, yerr, p0):\n    \"\"\" Fit a Gaussian to the data \"\"\"\n    try:\n        popt, pcov = curve_fit(gaussian, x, y, sigma=yerr, p0=p0, absolute_sigma=True)\n    except RuntimeError:\n        return [0],[0]\n    return popt, pcov", "code_tokens": "def fit_gaussian ( x , y , yerr , p0 ) : try : popt , pcov = curve_fit ( gaussian , x , y , sigma = yerr , p0 = p0 , absolute_sigma = True ) except RuntimeError : return [ 0 ] , [ 0 ] return popt , pcov", "docstring_tokens": "Fit a Gaussian to the data", "label": 1}, {"idx": "cosqa-train-4495", "doc": "check python var valid", "code": "def is_valid_variable_name(string_to_check):\n    \"\"\"\n    Returns whether the provided name is a valid variable name in Python\n\n    :param string_to_check: the string to be checked\n    :return: True or False\n    \"\"\"\n\n    try:\n\n        parse('{} = None'.format(string_to_check))\n        return True\n\n    except (SyntaxError, ValueError, TypeError):\n\n        return False", "code_tokens": "def is_valid_variable_name ( string_to_check ) : try : parse ( '{} = None' . format ( string_to_check ) ) return True except ( SyntaxError , ValueError , TypeError ) : return False", "docstring_tokens": "Returns whether the provided name is a valid variable name in Python", "label": 0}, {"idx": "cosqa-train-4496", "doc": "check that object is iterable in python", "code": "def is_lazy_iterable(obj):\n    \"\"\"\n    Returns whether *obj* is iterable lazily, such as generators, range objects, etc.\n    \"\"\"\n    return isinstance(obj,\n        (types.GeneratorType, collections.MappingView, six.moves.range, enumerate))", "code_tokens": "def is_lazy_iterable ( obj ) : return isinstance ( obj , ( types . GeneratorType , collections . MappingView , six . moves . range , enumerate ) )", "docstring_tokens": "Returns whether * obj * is iterable lazily such as generators range objects etc .", "label": 0}, {"idx": "cosqa-train-4497", "doc": "python flask blueprint has no attribute 'name'", "code": "def initialize_api(flask_app):\n    \"\"\"Initialize an API.\"\"\"\n    if not flask_restplus:\n        return\n\n    api = flask_restplus.Api(version=\"1.0\", title=\"My Example API\")\n    api.add_resource(HelloWorld, \"/hello\")\n\n    blueprint = flask.Blueprint(\"api\", __name__, url_prefix=\"/api\")\n    api.init_app(blueprint)\n    flask_app.register_blueprint(blueprint)", "code_tokens": "def initialize_api ( flask_app ) : if not flask_restplus : return api = flask_restplus . Api ( version = \"1.0\" , title = \"My Example API\" ) api . add_resource ( HelloWorld , \"/hello\" ) blueprint = flask . Blueprint ( \"api\" , __name__ , url_prefix = \"/api\" ) api . init_app ( blueprint ) flask_app . register_blueprint ( blueprint )", "docstring_tokens": "Initialize an API .", "label": 0}, {"idx": "cosqa-train-4498", "doc": "check to see if lower case key is in python dictionary", "code": "def __contains__ (self, key):\n        \"\"\"Check lowercase key item.\"\"\"\n        assert isinstance(key, basestring)\n        return dict.__contains__(self, key.lower())", "code_tokens": "def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "docstring_tokens": "Check lowercase key item .", "label": 0}, {"idx": "cosqa-train-4499", "doc": "python flask config object", "code": "def init_app(self, app):\n        \"\"\"Initialize Flask application.\"\"\"\n        app.config.from_pyfile('{0}.cfg'.format(app.name), silent=True)", "code_tokens": "def init_app ( self , app ) : app . config . from_pyfile ( '{0}.cfg' . format ( app . name ) , silent = True )", "docstring_tokens": "Initialize Flask application .", "label": 0}, {"idx": "cosqa-train-4500", "doc": "check two matrixs equal python", "code": "def converged(matrix1, matrix2):\n    \"\"\"\n    Check for convergence by determining if \n    matrix1 and matrix2 are approximately equal.\n    \n    :param matrix1: The matrix to compare with matrix2\n    :param matrix2: The matrix to compare with matrix1\n    :returns: True if matrix1 and matrix2 approximately equal\n    \"\"\"\n    if isspmatrix(matrix1) or isspmatrix(matrix2):\n        return sparse_allclose(matrix1, matrix2)\n\n    return np.allclose(matrix1, matrix2)", "code_tokens": "def converged ( matrix1 , matrix2 ) : if isspmatrix ( matrix1 ) or isspmatrix ( matrix2 ) : return sparse_allclose ( matrix1 , matrix2 ) return np . allclose ( matrix1 , matrix2 )", "docstring_tokens": "Check for convergence by determining if matrix1 and matrix2 are approximately equal . : param matrix1 : The matrix to compare with matrix2 : param matrix2 : The matrix to compare with matrix1 : returns : True if matrix1 and matrix2 approximately equal", "label": 0}, {"idx": "cosqa-train-4501", "doc": "check valid regex string python", "code": "def is_valid_regex(string):\n    \"\"\"\n    Checks whether the re module can compile the given regular expression.\n\n    Parameters\n    ----------\n    string: str\n\n    Returns\n    -------\n    boolean\n    \"\"\"\n    try:\n        re.compile(string)\n        is_valid = True\n    except re.error:\n        is_valid = False\n    return is_valid", "code_tokens": "def is_valid_regex ( string ) : try : re . compile ( string ) is_valid = True except re . error : is_valid = False return is_valid", "docstring_tokens": "Checks whether the re module can compile the given regular expression .", "label": 0}, {"idx": "cosqa-train-4502", "doc": "python flask rendor template css", "code": "def render_template(template_name, **context):\n    \"\"\"Render a template into a response.\"\"\"\n    tmpl = jinja_env.get_template(template_name)\n    context[\"url_for\"] = url_for\n    return Response(tmpl.render(context), mimetype=\"text/html\")", "code_tokens": "def render_template ( template_name , * * context ) : tmpl = jinja_env . get_template ( template_name ) context [ \"url_for\" ] = url_for return Response ( tmpl . render ( context ) , mimetype = \"text/html\" )", "docstring_tokens": "Render a template into a response .", "label": 0}, {"idx": "cosqa-train-4503", "doc": "checking data type in python dtype", "code": "def make_kind_check(python_types, numpy_kind):\n    \"\"\"\n    Make a function that checks whether a scalar or array is of a given kind\n    (e.g. float, int, datetime, timedelta).\n    \"\"\"\n    def check(value):\n        if hasattr(value, 'dtype'):\n            return value.dtype.kind == numpy_kind\n        return isinstance(value, python_types)\n    return check", "code_tokens": "def make_kind_check ( python_types , numpy_kind ) : def check ( value ) : if hasattr ( value , 'dtype' ) : return value . dtype . kind == numpy_kind return isinstance ( value , python_types ) return check", "docstring_tokens": "Make a function that checks whether a scalar or array is of a given kind ( e . g . float int datetime timedelta ) .", "label": 1}, {"idx": "cosqa-train-4504", "doc": "python flask response word", "code": "def getFlaskResponse(responseString, httpStatus=200):\n    \"\"\"\n    Returns a Flask response object for the specified data and HTTP status.\n    \"\"\"\n    return flask.Response(responseString, status=httpStatus, mimetype=MIMETYPE)", "code_tokens": "def getFlaskResponse ( responseString , httpStatus = 200 ) : return flask . Response ( responseString , status = httpStatus , mimetype = MIMETYPE )", "docstring_tokens": "Returns a Flask response object for the specified data and HTTP status .", "label": 0}, {"idx": "cosqa-train-4505", "doc": "checking for equality between two objects python", "code": "def __eq__(self, other):\n        \"\"\"Determine if two objects are equal.\"\"\"\n        return isinstance(other, self.__class__) \\\n            and self._freeze() == other._freeze()", "code_tokens": "def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) and self . _freeze ( ) == other . _freeze ( )", "docstring_tokens": "Determine if two objects are equal .", "label": 1}, {"idx": "cosqa-train-4506", "doc": "python flask return content type", "code": "async def json_or_text(response):\n    \"\"\"Turns response into a properly formatted json or text object\"\"\"\n    text = await response.text()\n    if response.headers['Content-Type'] == 'application/json; charset=utf-8':\n        return json.loads(text)\n    return text", "code_tokens": "async def json_or_text ( response ) : text = await response . text ( ) if response . headers [ 'Content-Type' ] == 'application/json; charset=utf-8' : return json . loads ( text ) return text", "docstring_tokens": "Turns response into a properly formatted json or text object", "label": 0}, {"idx": "cosqa-train-4507", "doc": "choose random from set python", "code": "def random_choice(sequence):\n    \"\"\" Same as :meth:`random.choice`, but also supports :class:`set` type to be passed as sequence. \"\"\"\n    return random.choice(tuple(sequence) if isinstance(sequence, set) else sequence)", "code_tokens": "def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )", "docstring_tokens": "Same as : meth : random . choice but also supports : class : set type to be passed as sequence .", "label": 0}, {"idx": "cosqa-train-4508", "doc": "python flatten a list", "code": "def flatten(l):\n    \"\"\"Flatten a nested list.\"\"\"\n    return sum(map(flatten, l), []) \\\n        if isinstance(l, list) or isinstance(l, tuple) else [l]", "code_tokens": "def flatten ( l ) : return sum ( map ( flatten , l ) , [ ] ) if isinstance ( l , list ) or isinstance ( l , tuple ) else [ l ]", "docstring_tokens": "Flatten a nested list .", "label": 0}, {"idx": "cosqa-train-4509", "doc": "closest element in an array integer python", "code": "def closest(xarr, val):\n    \"\"\" Return the index of the closest in xarr to value val \"\"\"\n    idx_closest = np.argmin(np.abs(np.array(xarr) - val))\n    return idx_closest", "code_tokens": "def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest", "docstring_tokens": "Return the index of the closest in xarr to value val", "label": 0}, {"idx": "cosqa-train-4510", "doc": "python flatten numpy array reshape", "code": "def flatten_array(grid):\n    \"\"\"\n    Takes a multi-dimensional array and returns a 1 dimensional array with the\n    same contents.\n    \"\"\"\n    grid = [grid[i][j] for i in range(len(grid)) for j in range(len(grid[i]))]\n    while type(grid[0]) is list:\n        grid = flatten_array(grid)\n    return grid", "code_tokens": "def flatten_array ( grid ) : grid = [ grid [ i ] [ j ] for i in range ( len ( grid ) ) for j in range ( len ( grid [ i ] ) ) ] while type ( grid [ 0 ] ) is list : grid = flatten_array ( grid ) return grid", "docstring_tokens": "Takes a multi - dimensional array and returns a 1 dimensional array with the same contents .", "label": 0}, {"idx": "cosqa-train-4511", "doc": "code to avoid scrapping duplicate links using beautifulsoup in python", "code": "def get_duckduckgo_links(limit, params, headers):\n\t\"\"\"\n\tfunction to fetch links equal to limit\n\n\tduckduckgo pagination is not static, so there is a limit on\n\tmaximum number of links that can be scraped\n\t\"\"\"\n\tresp = s.get('https://duckduckgo.com/html', params = params, headers = headers)\n\tlinks = scrape_links(resp.content, engine = 'd')\n\treturn links[:limit]", "code_tokens": "def get_duckduckgo_links ( limit , params , headers ) : resp = s . get ( 'https://duckduckgo.com/html' , params = params , headers = headers ) links = scrape_links ( resp . content , engine = 'd' ) return links [ : limit ]", "docstring_tokens": "function to fetch links equal to limit", "label": 0}, {"idx": "cosqa-train-4512", "doc": "python float to string constant size", "code": "def fmt_sz(intval):\n    \"\"\" Format a byte sized value.\n    \"\"\"\n    try:\n        return fmt.human_size(intval)\n    except (ValueError, TypeError):\n        return \"N/A\".rjust(len(fmt.human_size(0)))", "code_tokens": "def fmt_sz ( intval ) : try : return fmt . human_size ( intval ) except ( ValueError , TypeError ) : return \"N/A\" . rjust ( len ( fmt . human_size ( 0 ) ) )", "docstring_tokens": "Format a byte sized value .", "label": 0}, {"idx": "cosqa-train-4513", "doc": "codec python read utf8 file", "code": "def read_utf8(fh, byteorder, dtype, count, offsetsize):\n    \"\"\"Read tag data from file and return as unicode string.\"\"\"\n    return fh.read(count).decode('utf-8')", "code_tokens": "def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )", "docstring_tokens": "Read tag data from file and return as unicode string .", "label": 0}, {"idx": "cosqa-train-4514", "doc": "python for loop with a skip", "code": "def skip(self, n):\n        \"\"\"Skip the specified number of elements in the list.\n\n        If the number skipped is greater than the number of elements in\n        the list, hasNext() becomes false and available() returns zero\n        as there are no more elements to retrieve.\n\n        arg:    n (cardinal): the number of elements to skip\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        try:\n            self._iter_object.skip(n)\n        except AttributeError:\n            for i in range(0, n):\n                self.next()", "code_tokens": "def skip ( self , n ) : try : self . _iter_object . skip ( n ) except AttributeError : for i in range ( 0 , n ) : self . next ( )", "docstring_tokens": "Skip the specified number of elements in the list .", "label": 0}, {"idx": "cosqa-train-4515", "doc": "codecs open( read utf 8 python", "code": "def read_utf8(fh, byteorder, dtype, count, offsetsize):\n    \"\"\"Read tag data from file and return as unicode string.\"\"\"\n    return fh.read(count).decode('utf-8')", "code_tokens": "def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )", "docstring_tokens": "Read tag data from file and return as unicode string .", "label": 0}, {"idx": "cosqa-train-4516", "doc": "python for none values replace", "code": "def replace_nones(dict_or_list):\n    \"\"\"Update a dict or list in place to replace\n    'none' string values with Python None.\"\"\"\n\n    def replace_none_in_value(value):\n        if isinstance(value, basestring) and value.lower() == \"none\":\n            return None\n        return value\n\n    items = dict_or_list.iteritems() if isinstance(dict_or_list, dict) else enumerate(dict_or_list)\n\n    for accessor, value in items:\n        if isinstance(value, (dict, list)):\n            replace_nones(value)\n        else:\n            dict_or_list[accessor] = replace_none_in_value(value)", "code_tokens": "def replace_nones ( dict_or_list ) : def replace_none_in_value ( value ) : if isinstance ( value , basestring ) and value . lower ( ) == \"none\" : return None return value items = dict_or_list . iteritems ( ) if isinstance ( dict_or_list , dict ) else enumerate ( dict_or_list ) for accessor , value in items : if isinstance ( value , ( dict , list ) ) : replace_nones ( value ) else : dict_or_list [ accessor ] = replace_none_in_value ( value )", "docstring_tokens": "Update a dict or list in place to replace none string values with Python None .", "label": 0}, {"idx": "cosqa-train-4517", "doc": "codecs python byte encoding", "code": "def b(s):\n\t\"\"\" Encodes Unicode strings to byte strings, if necessary. \"\"\"\n\n\treturn s if isinstance(s, bytes) else s.encode(locale.getpreferredencoding())", "code_tokens": "def b ( s ) : return s if isinstance ( s , bytes ) else s . encode ( locale . getpreferredencoding ( ) )", "docstring_tokens": "Encodes Unicode strings to byte strings if necessary .", "label": 0}, {"idx": "cosqa-train-4518", "doc": "python format string varaible", "code": "def safe_format(s, **kwargs):\n  \"\"\"\n  :type s str\n  \"\"\"\n  return string.Formatter().vformat(s, (), defaultdict(str, **kwargs))", "code_tokens": "def safe_format ( s , * * kwargs ) : return string . Formatter ( ) . vformat ( s , ( ) , defaultdict ( str , * * kwargs ) )", "docstring_tokens": ": type s str", "label": 1}, {"idx": "cosqa-train-4519", "doc": "python format width pad", "code": "def _pad(self, text):\n        \"\"\"Pad the text.\"\"\"\n        top_bottom = (\"\\n\" * self._padding) + \" \"\n        right_left = \" \" * self._padding * self.PAD_WIDTH\n        return top_bottom + right_left + text + right_left + top_bottom", "code_tokens": "def _pad ( self , text ) : top_bottom = ( \"\\n\" * self . _padding ) + \" \" right_left = \" \" * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom", "docstring_tokens": "Pad the text .", "label": 0}, {"idx": "cosqa-train-4520", "doc": "color string changer python", "code": "def write_color(string, name, style='normal', when='auto'):\n    \"\"\" Write the given colored string to standard out. \"\"\"\n    write(color(string, name, style, when))", "code_tokens": "def write_color ( string , name , style = 'normal' , when = 'auto' ) : write ( color ( string , name , style , when ) )", "docstring_tokens": "Write the given colored string to standard out .", "label": 0}, {"idx": "cosqa-train-4521", "doc": "python ftp directory list to know if it is a folder or file", "code": "def isdir(self, path):\n        \"\"\"Return true if the path refers to an existing directory.\n\n        Parameters\n        ----------\n        path : str\n            Path of directory on the remote side to check.\n        \"\"\"\n        result = True\n        try:\n            self.sftp_client.lstat(path)\n        except FileNotFoundError:\n            result = False\n\n        return result", "code_tokens": "def isdir ( self , path ) : result = True try : self . sftp_client . lstat ( path ) except FileNotFoundError : result = False return result", "docstring_tokens": "Return true if the path refers to an existing directory .", "label": 0}, {"idx": "cosqa-train-4522", "doc": "column names for array python", "code": "def from_array(cls, arr):\n        \"\"\"Convert a structured NumPy array into a Table.\"\"\"\n        return cls().with_columns([(f, arr[f]) for f in arr.dtype.names])", "code_tokens": "def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )", "docstring_tokens": "Convert a structured NumPy array into a Table .", "label": 0}, {"idx": "cosqa-train-4523", "doc": "python ftp server for windows", "code": "def connect():\n    \"\"\"Connect to FTP server, login and return an ftplib.FTP instance.\"\"\"\n    ftp_class = ftplib.FTP if not SSL else ftplib.FTP_TLS\n    ftp = ftp_class(timeout=TIMEOUT)\n    ftp.connect(HOST, PORT)\n    ftp.login(USER, PASSWORD)\n    if SSL:\n        ftp.prot_p()  # secure data connection\n    return ftp", "code_tokens": "def connect ( ) : ftp_class = ftplib . FTP if not SSL else ftplib . FTP_TLS ftp = ftp_class ( timeout = TIMEOUT ) ftp . connect ( HOST , PORT ) ftp . login ( USER , PASSWORD ) if SSL : ftp . prot_p ( ) # secure data connection return ftp", "docstring_tokens": "Connect to FTP server login and return an ftplib . FTP instance .", "label": 1}, {"idx": "cosqa-train-4524", "doc": "combine 2 maps python", "code": "def _merge_maps(m1, m2):\n    \"\"\"merge two Mapping objects, keeping the type of the first mapping\"\"\"\n    return type(m1)(chain(m1.items(), m2.items()))", "code_tokens": "def _merge_maps ( m1 , m2 ) : return type ( m1 ) ( chain ( m1 . items ( ) , m2 . items ( ) ) )", "docstring_tokens": "merge two Mapping objects keeping the type of the first mapping", "label": 0}, {"idx": "cosqa-train-4525", "doc": "python ftp write file filedata", "code": "def write(url, content, **args):\n    \"\"\"Put an object into a ftps URL.\"\"\"\n    with FTPSResource(url, **args) as resource:\n        resource.write(content)", "code_tokens": "def write ( url , content , * * args ) : with FTPSResource ( url , * * args ) as resource : resource . write ( content )", "docstring_tokens": "Put an object into a ftps URL .", "label": 1}, {"idx": "cosqa-train-4526", "doc": "combine multiple lists into dictionary in python", "code": "def cartesian_lists(d):\n    \"\"\"\n    turns a dict of lists into a list of dicts that represents\n    the cartesian product of the initial lists\n\n    Example\n    -------\n    cartesian_lists({'a':[0, 2], 'b':[3, 4, 5]}\n    returns\n    [ {'a':0, 'b':3}, {'a':0, 'b':4}, ... {'a':2, 'b':5} ]\n\n    \"\"\"\n    return [{k: v for k, v in zip(d.keys(), args)}\n            for args in itertools.product(*d.values())]", "code_tokens": "def cartesian_lists ( d ) : return [ { k : v for k , v in zip ( d . keys ( ) , args ) } for args in itertools . product ( * d . values ( ) ) ]", "docstring_tokens": "turns a dict of lists into a list of dicts that represents the cartesian product of the initial lists", "label": 0}, {"idx": "cosqa-train-4527", "doc": "python func to print multiple doc", "code": "def see_doc(obj_with_doc):\n    \"\"\"Copy docstring from existing object to the decorated callable.\"\"\"\n    def decorator(fn):\n        fn.__doc__ = obj_with_doc.__doc__\n        return fn\n    return decorator", "code_tokens": "def see_doc ( obj_with_doc ) : def decorator ( fn ) : fn . __doc__ = obj_with_doc . __doc__ return fn return decorator", "docstring_tokens": "Copy docstring from existing object to the decorated callable .", "label": 0}, {"idx": "cosqa-train-4528", "doc": "compare 2 arrays in python and calculate same results", "code": "def compare(a, b):\n    \"\"\"\n     Compare items in 2 arrays. Returns sum(abs(a(i)-b(i)))\n    \"\"\"\n    s=0\n    for i in range(len(a)):\n        s=s+abs(a[i]-b[i])\n    return s", "code_tokens": "def compare ( a , b ) : s = 0 for i in range ( len ( a ) ) : s = s + abs ( a [ i ] - b [ i ] ) return s", "docstring_tokens": "Compare items in 2 arrays . Returns sum ( abs ( a ( i ) - b ( i )))", "label": 1}, {"idx": "cosqa-train-4529", "doc": "python function acceps scalar and array", "code": "def is_scalar(value):\n    \"\"\"Test if the given value is a scalar.\n\n    This function also works with memory mapped array values, in contrast to the numpy is_scalar method.\n\n    Args:\n        value: the value to test for being a scalar value\n\n    Returns:\n        boolean: if the given value is a scalar or not\n    \"\"\"\n    return np.isscalar(value) or (isinstance(value, np.ndarray) and (len(np.squeeze(value).shape) == 0))", "code_tokens": "def is_scalar ( value ) : return np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and ( len ( np . squeeze ( value ) . shape ) == 0 ) )", "docstring_tokens": "Test if the given value is a scalar .", "label": 0}, {"idx": "cosqa-train-4530", "doc": "compare python flask and iis", "code": "def iiscgi(application):\n\t\"\"\"A specialized version of the reference WSGI-CGI server to adapt to Microsoft IIS quirks.\n\t\n\tThis is not a production quality interface and will behave badly under load.\n\t\"\"\"\n\ttry:\n\t\tfrom wsgiref.handlers import IISCGIHandler\n\texcept ImportError:\n\t\tprint(\"Python 3.2 or newer is required.\")\n\t\n\tif not __debug__:\n\t\twarnings.warn(\"Interactive debugging and other persistence-based processes will not work.\")\n\t\n\tIISCGIHandler().run(application)", "code_tokens": "def iiscgi ( application ) : try : from wsgiref . handlers import IISCGIHandler except ImportError : print ( \"Python 3.2 or newer is required.\" ) if not __debug__ : warnings . warn ( \"Interactive debugging and other persistence-based processes will not work.\" ) IISCGIHandler ( ) . run ( application )", "docstring_tokens": "A specialized version of the reference WSGI - CGI server to adapt to Microsoft IIS quirks . This is not a production quality interface and will behave badly under load .", "label": 0}, {"idx": "cosqa-train-4531", "doc": "python function args as dict", "code": "def arguments_as_dict(cls, *args, **kwargs):\n        \"\"\"\n        Generate the arguments dictionary provided to :py:meth:`generate_name` and :py:meth:`calculate_total_steps`.\n\n        This makes it possible to fetch arguments by name regardless of\n        whether they were passed as positional or keyword arguments.  Unnamed\n        positional arguments are provided as a tuple under the key ``pos``.\n        \"\"\"\n        all_args = (None, ) + args\n        return inspect.getcallargs(cls.run, *all_args, **kwargs)", "code_tokens": "def arguments_as_dict ( cls , * args , * * kwargs ) : all_args = ( None , ) + args return inspect . getcallargs ( cls . run , * all_args , * * kwargs )", "docstring_tokens": "Generate the arguments dictionary provided to : py : meth : generate_name and : py : meth : calculate_total_steps .", "label": 0}, {"idx": "cosqa-train-4532", "doc": "compare str and int in python", "code": "def is_int(string):\n    \"\"\"\n    Checks if a string is an integer. If the string value is an integer\n    return True, otherwise return False. \n    \n    Args:\n        string: a string to test.\n\n    Returns: \n        boolean\n    \"\"\"\n    try:\n        a = float(string)\n        b = int(a)\n    except ValueError:\n        return False\n    else:\n        return a == b", "code_tokens": "def is_int ( string ) : try : a = float ( string ) b = int ( a ) except ValueError : return False else : return a == b", "docstring_tokens": "Checks if a string is an integer . If the string value is an integer return True otherwise return False . Args : string : a string to test .", "label": 0}, {"idx": "cosqa-train-4533", "doc": "python function argurments kwargs setattr", "code": "def update(self, **kwargs):\n    \"\"\"Creates or updates a property for the instance for each parameter.\"\"\"\n    for key, value in kwargs.items():\n      setattr(self, key, value)", "code_tokens": "def update ( self , * * kwargs ) : for key , value in kwargs . items ( ) : setattr ( self , key , value )", "docstring_tokens": "Creates or updates a property for the instance for each parameter .", "label": 0}, {"idx": "cosqa-train-4534", "doc": "compare two file data in python", "code": "def cmp_contents(filename1, filename2):\n    \"\"\" Returns True if contents of the files are the same\n\n    Parameters\n    ----------\n    filename1 : str\n        filename of first file to compare\n    filename2 : str\n        filename of second file to compare\n\n    Returns\n    -------\n    tf : bool\n        True if binary contents of `filename1` is same as binary contents of\n        `filename2`, False otherwise.\n    \"\"\"\n    with open_readable(filename1, 'rb') as fobj:\n        contents1 = fobj.read()\n    with open_readable(filename2, 'rb') as fobj:\n        contents2 = fobj.read()\n    return contents1 == contents2", "code_tokens": "def cmp_contents ( filename1 , filename2 ) : with open_readable ( filename1 , 'rb' ) as fobj : contents1 = fobj . read ( ) with open_readable ( filename2 , 'rb' ) as fobj : contents2 = fobj . read ( ) return contents1 == contents2", "docstring_tokens": "Returns True if contents of the files are the same", "label": 0}, {"idx": "cosqa-train-4535", "doc": "python function calculate hamming distance function", "code": "def hamming(s, t):\n    \"\"\"\n    Calculate the Hamming distance between two strings. From Wikipedia article: Iterative with two matrix rows.\n\n    :param s: string 1\n    :type s: str\n    :param t: string 2\n    :type s: str\n    :return: Hamming distance\n    :rtype: float\n    \"\"\"\n    if len(s) != len(t):\n        raise ValueError('Hamming distance needs strings of equal length.')\n    return sum(s_ != t_ for s_, t_ in zip(s, t))", "code_tokens": "def hamming ( s , t ) : if len ( s ) != len ( t ) : raise ValueError ( 'Hamming distance needs strings of equal length.' ) return sum ( s_ != t_ for s_ , t_ in zip ( s , t ) )", "docstring_tokens": "Calculate the Hamming distance between two strings . From Wikipedia article : Iterative with two matrix rows .", "label": 1}, {"idx": "cosqa-train-4536", "doc": "comparing float and int in python", "code": "def _check_for_int(x):\n    \"\"\"\n    This is a compatibility function that takes a C{float} and converts it to an\n    C{int} if the values are equal.\n    \"\"\"\n    try:\n        y = int(x)\n    except (OverflowError, ValueError):\n        pass\n    else:\n        # There is no way in AMF0 to distinguish between integers and floats\n        if x == x and y == x:\n            return y\n\n    return x", "code_tokens": "def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x", "docstring_tokens": "This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal .", "label": 0}, {"idx": "cosqa-train-4537", "doc": "python function get free disk space linux", "code": "def get_free_mb(folder):\n    \"\"\" Return folder/drive free space (in bytes)\n    \"\"\"\n    if platform.system() == 'Windows':\n        free_bytes = ctypes.c_ulonglong(0)\n        ctypes.windll.kernel32.GetDiskFreeSpaceExW(ctypes.c_wchar_p(folder), None, None, ctypes.pointer(free_bytes))\n        return free_bytes.value/1024/1024\n    else:\n        st = os.statvfs(folder)\n        return st.f_bavail * st.f_frsize/1024/1024", "code_tokens": "def get_free_mb ( folder ) : if platform . system ( ) == 'Windows' : free_bytes = ctypes . c_ulonglong ( 0 ) ctypes . windll . kernel32 . GetDiskFreeSpaceExW ( ctypes . c_wchar_p ( folder ) , None , None , ctypes . pointer ( free_bytes ) ) return free_bytes . value / 1024 / 1024 else : st = os . statvfs ( folder ) return st . f_bavail * st . f_frsize / 1024 / 1024", "docstring_tokens": "Return folder / drive free space ( in bytes )", "label": 0}, {"idx": "cosqa-train-4538", "doc": "comparing float to int python", "code": "def _check_for_int(x):\n    \"\"\"\n    This is a compatibility function that takes a C{float} and converts it to an\n    C{int} if the values are equal.\n    \"\"\"\n    try:\n        y = int(x)\n    except (OverflowError, ValueError):\n        pass\n    else:\n        # There is no way in AMF0 to distinguish between integers and floats\n        if x == x and y == x:\n            return y\n\n    return x", "code_tokens": "def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x", "docstring_tokens": "This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal .", "label": 1}, {"idx": "cosqa-train-4539", "doc": "python function maybe static", "code": "def static_method(cls, f):\n        \"\"\"Decorator which dynamically binds static methods to the model for later use.\"\"\"\n        setattr(cls, f.__name__, staticmethod(f))\n        return f", "code_tokens": "def static_method ( cls , f ) : setattr ( cls , f . __name__ , staticmethod ( f ) ) return f", "docstring_tokens": "Decorator which dynamically binds static methods to the model for later use .", "label": 0}, {"idx": "cosqa-train-4540", "doc": "comparing lengths of two strings python", "code": "def count_string_diff(a,b):\n    \"\"\"Return the number of characters in two strings that don't exactly match\"\"\"\n    shortest = min(len(a), len(b))\n    return sum(a[i] != b[i] for i in range(shortest))", "code_tokens": "def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )", "docstring_tokens": "Return the number of characters in two strings that don t exactly match", "label": 1}, {"idx": "cosqa-train-4541", "doc": "python function providing default as null value", "code": "def min_or_none(val1, val2):\n    \"\"\"Returns min(val1, val2) returning None only if both values are None\"\"\"\n    return min(val1, val2, key=lambda x: sys.maxint if x is None else x)", "code_tokens": "def min_or_none ( val1 , val2 ) : return min ( val1 , val2 , key = lambda x : sys . maxint if x is None else x )", "docstring_tokens": "Returns min ( val1 val2 ) returning None only if both values are None", "label": 1}, {"idx": "cosqa-train-4542", "doc": "compile a python file", "code": "def execfile(fname, variables):\n    \"\"\" This is builtin in python2, but we have to roll our own on py3. \"\"\"\n    with open(fname) as f:\n        code = compile(f.read(), fname, 'exec')\n        exec(code, variables)", "code_tokens": "def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )", "docstring_tokens": "This is builtin in python2 but we have to roll our own on py3 .", "label": 0}, {"idx": "cosqa-train-4543", "doc": "python function returning a list of all entities is called", "code": "def filtany(entities, **kw):\n  \"\"\"Filter a set of entities based on method return. Use keyword arguments.\n  \n  Example:\n    filtmeth(entities, id='123')\n    filtmeth(entities, name='bart')\n\n  Multiple filters are 'OR'.\n  \"\"\"\n  ret = set()\n  for k,v in kw.items():\n    for entity in entities:\n      if getattr(entity, k)() == v:\n        ret.add(entity)\n  return ret", "code_tokens": "def filtany ( entities , * * kw ) : ret = set ( ) for k , v in kw . items ( ) : for entity in entities : if getattr ( entity , k ) ( ) == v : ret . add ( entity ) return ret", "docstring_tokens": "Filter a set of entities based on method return . Use keyword arguments . Example : filtmeth ( entities id = 123 ) filtmeth ( entities name = bart )", "label": 1}, {"idx": "cosqa-train-4544", "doc": "compute amount of memory used by object python", "code": "def get_size(objects):\n    \"\"\"Compute the total size of all elements in objects.\"\"\"\n    res = 0\n    for o in objects:\n        try:\n            res += _getsizeof(o)\n        except AttributeError:\n            print(\"IGNORING: type=%s; o=%s\" % (str(type(o)), str(o)))\n    return res", "code_tokens": "def get_size ( objects ) : res = 0 for o in objects : try : res += _getsizeof ( o ) except AttributeError : print ( \"IGNORING: type=%s; o=%s\" % ( str ( type ( o ) ) , str ( o ) ) ) return res", "docstring_tokens": "Compute the total size of all elements in objects .", "label": 1}, {"idx": "cosqa-train-4545", "doc": "python function to generate numbers in a sin wave", "code": "def sine_wave(i, frequency=FREQUENCY, framerate=FRAMERATE, amplitude=AMPLITUDE):\n    \"\"\"\n    Returns value of a sine wave at a given frequency and framerate\n    for a given sample i\n    \"\"\"\n    omega = 2.0 * pi * float(frequency)\n    sine = sin(omega * (float(i) / float(framerate)))\n    return float(amplitude) * sine", "code_tokens": "def sine_wave ( i , frequency = FREQUENCY , framerate = FRAMERATE , amplitude = AMPLITUDE ) : omega = 2.0 * pi * float ( frequency ) sine = sin ( omega * ( float ( i ) / float ( framerate ) ) ) return float ( amplitude ) * sine", "docstring_tokens": "Returns value of a sine wave at a given frequency and framerate for a given sample i", "label": 1}, {"idx": "cosqa-train-4546", "doc": "compute cdf python given array and weights", "code": "def _cdf(self, xloc, dist, cache):\n        \"\"\"Cumulative distribution function.\"\"\"\n        return evaluation.evaluate_forward(dist, numpy.e**xloc, cache=cache)", "code_tokens": "def _cdf ( self , xloc , dist , cache ) : return evaluation . evaluate_forward ( dist , numpy . e ** xloc , cache = cache )", "docstring_tokens": "Cumulative distribution function .", "label": 0}, {"idx": "cosqa-train-4547", "doc": "compute manhattan heuristic in python", "code": "def manhattan(h1, h2): # # 7 us @array, 31 us @list \\w 100 bins\n    r\"\"\"\n    Equal to Minowski distance with :math:`p=1`.\n    \n    See also\n    --------\n    minowski\n    \"\"\"\n    h1, h2 = __prepare_histogram(h1, h2)\n    return scipy.sum(scipy.absolute(h1 - h2))", "code_tokens": "def manhattan ( h1 , h2 ) : # # 7 us @array, 31 us @list \\w 100 bins h1 , h2 = __prepare_histogram ( h1 , h2 ) return scipy . sum ( scipy . absolute ( h1 - h2 ) )", "docstring_tokens": "r Equal to Minowski distance with : math : p = 1 . See also -------- minowski", "label": 0}, {"idx": "cosqa-train-4548", "doc": "python function to return values from a website", "code": "def data_from_techshop_ws(tws_url):\n    \"\"\"Scrapes data from techshop.ws.\"\"\"\n\n    r = requests.get(tws_url)\n    if r.status_code == 200:\n        data = BeautifulSoup(r.text, \"lxml\")\n    else:\n        data = \"There was an error while accessing data on techshop.ws.\"\n\n    return data", "code_tokens": "def data_from_techshop_ws ( tws_url ) : r = requests . get ( tws_url ) if r . status_code == 200 : data = BeautifulSoup ( r . text , \"lxml\" ) else : data = \"There was an error while accessing data on techshop.ws.\" return data", "docstring_tokens": "Scrapes data from techshop . ws .", "label": 0}, {"idx": "cosqa-train-4549", "doc": "compute skew python numpy", "code": "def deskew(S):\n    \"\"\"Converts a skew-symmetric cross-product matrix to its corresponding\n    vector. Only works for 3x3 matrices.\n\n    Parameters\n    ----------\n    S : :obj:`numpy.ndarray` of float\n        A 3x3 skew-symmetric matrix.\n\n    Returns\n    -------\n    :obj:`numpy.ndarray` of float\n        A 3-entry vector that corresponds to the given cross product matrix.\n    \"\"\"\n    x = np.zeros(3)\n    x[0] = S[2,1]\n    x[1] = S[0,2]\n    x[2] = S[1,0]\n    return x", "code_tokens": "def deskew ( S ) : x = np . zeros ( 3 ) x [ 0 ] = S [ 2 , 1 ] x [ 1 ] = S [ 0 , 2 ] x [ 2 ] = S [ 1 , 0 ] return x", "docstring_tokens": "Converts a skew - symmetric cross - product matrix to its corresponding vector . Only works for 3x3 matrices .", "label": 1}, {"idx": "cosqa-train-4550", "doc": "python function to strip whitespace", "code": "def text_remove_empty_lines(text):\n    \"\"\"\n    Whitespace normalization:\n\n      - Strip empty lines\n      - Strip trailing whitespace\n    \"\"\"\n    lines = [ line.rstrip()  for line in text.splitlines()  if line.strip() ]\n    return \"\\n\".join(lines)", "code_tokens": "def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return \"\\n\" . join ( lines )", "docstring_tokens": "Whitespace normalization :", "label": 0}, {"idx": "cosqa-train-4551", "doc": "compute the gradient using a kernel and an image python", "code": "def average_gradient(data, *kwargs):\n    \"\"\" Compute average gradient norm of an image\n    \"\"\"\n    return np.average(np.array(np.gradient(data))**2)", "code_tokens": "def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )", "docstring_tokens": "Compute average gradient norm of an image", "label": 0}, {"idx": "cosqa-train-4552", "doc": "python function to uncompress the zipfiles and put them in a directory", "code": "def unzip_file_to_dir(path_to_zip, output_directory):\n    \"\"\"\n    Extract a ZIP archive to a directory\n    \"\"\"\n    z = ZipFile(path_to_zip, 'r')\n    z.extractall(output_directory)\n    z.close()", "code_tokens": "def unzip_file_to_dir ( path_to_zip , output_directory ) : z = ZipFile ( path_to_zip , 'r' ) z . extractall ( output_directory ) z . close ( )", "docstring_tokens": "Extract a ZIP archive to a directory", "label": 0}, {"idx": "cosqa-train-4553", "doc": "computing distance matrix in python", "code": "def get_distance_matrix(x):\n    \"\"\"Get distance matrix given a matrix. Used in testing.\"\"\"\n    square = nd.sum(x ** 2.0, axis=1, keepdims=True)\n    distance_square = square + square.transpose() - (2.0 * nd.dot(x, x.transpose()))\n    return nd.sqrt(distance_square)", "code_tokens": "def get_distance_matrix ( x ) : square = nd . sum ( x ** 2.0 , axis = 1 , keepdims = True ) distance_square = square + square . transpose ( ) - ( 2.0 * nd . dot ( x , x . transpose ( ) ) ) return nd . sqrt ( distance_square )", "docstring_tokens": "Get distance matrix given a matrix . Used in testing .", "label": 1}, {"idx": "cosqa-train-4554", "doc": "python functions equivalent to average deviation", "code": "def _mean_absolute_error(y, y_pred, w):\n    \"\"\"Calculate the mean absolute error.\"\"\"\n    return np.average(np.abs(y_pred - y), weights=w)", "code_tokens": "def _mean_absolute_error ( y , y_pred , w ) : return np . average ( np . abs ( y_pred - y ) , weights = w )", "docstring_tokens": "Calculate the mean absolute error .", "label": 0}, {"idx": "cosqa-train-4555", "doc": "computing fft on rows in a matrix in python", "code": "def dft(blk, freqs, normalize=True):\n  \"\"\"\n  Complex non-optimized Discrete Fourier Transform\n\n  Finds the DFT for values in a given frequency list, in order, over the data\n  block seen as periodic.\n\n  Parameters\n  ----------\n  blk :\n    An iterable with well-defined length. Don't use this function with Stream\n    objects!\n  freqs :\n    List of frequencies to find the DFT, in rad/sample. FFT implementations\n    like numpy.fft.ftt finds the coefficients for N frequencies equally\n    spaced as ``line(N, 0, 2 * pi, finish=False)`` for N frequencies.\n  normalize :\n    If True (default), the coefficient sums are divided by ``len(blk)``,\n    and the coefficient for the DC level (frequency equals to zero) is the\n    mean of the block. If False, that coefficient would be the sum of the\n    data in the block.\n\n  Returns\n  -------\n  A list of DFT values for each frequency, in the same order that they appear\n  in the freqs input.\n\n  Note\n  ----\n  This isn't a FFT implementation, and performs :math:`O(M . N)` float\n  pointing operations, with :math:`M` and :math:`N` equals to the length of\n  the inputs. This function can find the DFT for any specific frequency, with\n  no need for zero padding or finding all frequencies in a linearly spaced\n  band grid with N frequency bins at once.\n\n  \"\"\"\n  dft_data = (sum(xn * cexp(-1j * n * f) for n, xn in enumerate(blk))\n                                         for f in freqs)\n  if normalize:\n    lblk = len(blk)\n    return [v / lblk for v in dft_data]\n  return list(dft_data)", "code_tokens": "def dft ( blk , freqs , normalize = True ) : dft_data = ( sum ( xn * cexp ( - 1j * n * f ) for n , xn in enumerate ( blk ) ) for f in freqs ) if normalize : lblk = len ( blk ) return [ v / lblk for v in dft_data ] return list ( dft_data )", "docstring_tokens": "Complex non - optimized Discrete Fourier Transform", "label": 0}, {"idx": "cosqa-train-4556", "doc": "python generalised extreme value", "code": "def softmax(xs):\n    \"\"\"Stable implementation of the softmax function.\"\"\"\n    ys = xs - np.max(xs)\n    exps = np.exp(ys)\n    return exps / exps.sum(axis=0)", "code_tokens": "def softmax ( xs ) : ys = xs - np . max ( xs ) exps = np . exp ( ys ) return exps / exps . sum ( axis = 0 )", "docstring_tokens": "Stable implementation of the softmax function .", "label": 0}, {"idx": "cosqa-train-4557", "doc": "concatenate filename with datetime python", "code": "def timestamp_filename(basename, ext=None):\n    \"\"\"\n    Return a string of the form [basename-TIMESTAMP.ext]\n    where TIMESTAMP is of the form YYYYMMDD-HHMMSS-MILSEC\n    \"\"\"\n    dt = datetime.now().strftime('%Y%m%d-%H%M%S-%f')\n    if ext:\n        return '%s-%s.%s' % (basename, dt, ext)\n    return '%s-%s' % (basename, dt)", "code_tokens": "def timestamp_filename ( basename , ext = None ) : dt = datetime . now ( ) . strftime ( '%Y%m%d-%H%M%S-%f' ) if ext : return '%s-%s.%s' % ( basename , dt , ext ) return '%s-%s' % ( basename , dt )", "docstring_tokens": "Return a string of the form [ basename - TIMESTAMP . ext ] where TIMESTAMP is of the form YYYYMMDD - HHMMSS - MILSEC", "label": 1}, {"idx": "cosqa-train-4558", "doc": "python generate a guid", "code": "def random_id(length):\n    \"\"\"Generates a random ID of given length\"\"\"\n\n    def char():\n        \"\"\"Generate single random char\"\"\"\n\n        return random.choice(string.ascii_letters + string.digits)\n\n    return \"\".join(char() for _ in range(length))", "code_tokens": "def random_id ( length ) : def char ( ) : \"\"\"Generate single random char\"\"\" return random . choice ( string . ascii_letters + string . digits ) return \"\" . join ( char ( ) for _ in range ( length ) )", "docstring_tokens": "Generates a random ID of given length", "label": 0}, {"idx": "cosqa-train-4559", "doc": "configure python to trust ssl", "code": "def enable_ssl(self, *args, **kwargs):\n        \"\"\"\n        Transforms the regular socket.socket to an ssl.SSLSocket for secure\n        connections. Any arguments are passed to ssl.wrap_socket:\n        http://docs.python.org/dev/library/ssl.html#ssl.wrap_socket\n        \"\"\"\n        if self.handshake_sent:\n            raise SSLError('can only enable SSL before handshake')\n\n        self.secure = True\n        self.sock = ssl.wrap_socket(self.sock, *args, **kwargs)", "code_tokens": "def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )", "docstring_tokens": "Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket", "label": 0}, {"idx": "cosqa-train-4560", "doc": "python generate a numpy array of zeros", "code": "def zeros(self, name, **kwargs):\n        \"\"\"Create an array. Keyword arguments as per\n        :func:`zarr.creation.zeros`.\"\"\"\n        return self._write_op(self._zeros_nosync, name, **kwargs)", "code_tokens": "def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )", "docstring_tokens": "Create an array . Keyword arguments as per : func : zarr . creation . zeros .", "label": 0}, {"idx": "cosqa-train-4561", "doc": "connect to rest server with bearer token requests python", "code": "def auth_request(self, url, headers, body):\n        \"\"\"Perform auth request for token.\"\"\"\n\n        return self.req.post(url, headers, body=body)", "code_tokens": "def auth_request ( self , url , headers , body ) : return self . req . post ( url , headers , body = body )", "docstring_tokens": "Perform auth request for token .", "label": 0}, {"idx": "cosqa-train-4562", "doc": "python generate a temporary file with random file name", "code": "def get_incomplete_path(filename):\n  \"\"\"Returns a temporary filename based on filename.\"\"\"\n  random_suffix = \"\".join(\n      random.choice(string.ascii_uppercase + string.digits) for _ in range(6))\n  return filename + \".incomplete\" + random_suffix", "code_tokens": "def get_incomplete_path ( filename ) : random_suffix = \"\" . join ( random . choice ( string . ascii_uppercase + string . digits ) for _ in range ( 6 ) ) return filename + \".incomplete\" + random_suffix", "docstring_tokens": "Returns a temporary filename based on filename .", "label": 0}, {"idx": "cosqa-train-4563", "doc": "construct adjacency matrix python", "code": "def adjacency(tree):\n    \"\"\"\n    Construct the adjacency matrix of the tree\n    :param tree:\n    :return:\n    \"\"\"\n    dd = ids(tree)\n    N = len(dd)\n    A = np.zeros((N, N))\n\n    def _adj(node):\n        if np.isscalar(node):\n            return\n        elif isinstance(node, tuple) and len(node) == 2:\n            A[dd[node], dd[node[0]]] = 1\n            A[dd[node[0]], dd[node]] = 1\n            _adj(node[0])\n\n            A[dd[node], dd[node[1]]] = 1\n            A[dd[node[1]], dd[node]] = 1\n            _adj(node[1])\n\n    _adj(tree)\n    return A", "code_tokens": "def adjacency ( tree ) : dd = ids ( tree ) N = len ( dd ) A = np . zeros ( ( N , N ) ) def _adj ( node ) : if np . isscalar ( node ) : return elif isinstance ( node , tuple ) and len ( node ) == 2 : A [ dd [ node ] , dd [ node [ 0 ] ] ] = 1 A [ dd [ node [ 0 ] ] , dd [ node ] ] = 1 _adj ( node [ 0 ] ) A [ dd [ node ] , dd [ node [ 1 ] ] ] = 1 A [ dd [ node [ 1 ] ] , dd [ node ] ] = 1 _adj ( node [ 1 ] ) _adj ( tree ) return A", "docstring_tokens": "Construct the adjacency matrix of the tree : param tree : : return :", "label": 0}, {"idx": "cosqa-train-4564", "doc": "python generate guid string", "code": "def generate_random_id(size=6, chars=string.ascii_uppercase + string.digits):\n    \"\"\"Generate random id numbers.\"\"\"\n    return \"\".join(random.choice(chars) for x in range(size))", "code_tokens": "def generate_random_id ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return \"\" . join ( random . choice ( chars ) for x in range ( size ) )", "docstring_tokens": "Generate random id numbers .", "label": 0}, {"idx": "cosqa-train-4565", "doc": "construct tensorflow tensor from python list", "code": "def nest(thing):\n    \"\"\"Use tensorflows nest function if available, otherwise just wrap object in an array\"\"\"\n    tfutil = util.get_module('tensorflow.python.util')\n    if tfutil:\n        return tfutil.nest.flatten(thing)\n    else:\n        return [thing]", "code_tokens": "def nest ( thing ) : tfutil = util . get_module ( 'tensorflow.python.util' ) if tfutil : return tfutil . nest . flatten ( thing ) else : return [ thing ]", "docstring_tokens": "Use tensorflows nest function if available otherwise just wrap object in an array", "label": 0}, {"idx": "cosqa-train-4566", "doc": "python generate json based on jsonschema definition", "code": "def get_ref_dict(self, schema):\n        \"\"\"Method to create a dictionary containing a JSON reference to the\n        schema in the spec\n        \"\"\"\n        schema_key = make_schema_key(schema)\n        ref_schema = build_reference(\n            \"schema\", self.openapi_version.major, self.refs[schema_key]\n        )\n        if getattr(schema, \"many\", False):\n            return {\"type\": \"array\", \"items\": ref_schema}\n        return ref_schema", "code_tokens": "def get_ref_dict ( self , schema ) : schema_key = make_schema_key ( schema ) ref_schema = build_reference ( \"schema\" , self . openapi_version . major , self . refs [ schema_key ] ) if getattr ( schema , \"many\" , False ) : return { \"type\" : \"array\" , \"items\" : ref_schema } return ref_schema", "docstring_tokens": "Method to create a dictionary containing a JSON reference to the schema in the spec", "label": 0}, {"idx": "cosqa-train-4567", "doc": "consume paged responses python api", "code": "def _iter_response(self, url, params=None):\n        \"\"\"Return an enumerable that iterates through a multi-page API request\"\"\"\n        if params is None:\n            params = {}\n        params['page_number'] = 1\n\n        # Last page lists itself as next page\n        while True:\n            response = self._request(url, params)\n\n            for item in response['result_data']:\n                yield item\n\n            # Last page lists itself as next page\n            if response['service_meta']['next_page_number'] == params['page_number']:\n                break\n\n            params['page_number'] += 1", "code_tokens": "def _iter_response ( self , url , params = None ) : if params is None : params = { } params [ 'page_number' ] = 1 # Last page lists itself as next page while True : response = self . _request ( url , params ) for item in response [ 'result_data' ] : yield item # Last page lists itself as next page if response [ 'service_meta' ] [ 'next_page_number' ] == params [ 'page_number' ] : break params [ 'page_number' ] += 1", "docstring_tokens": "Return an enumerable that iterates through a multi - page API request", "label": 0}, {"idx": "cosqa-train-4568", "doc": "python generate single period of sine wave", "code": "def sine_wave(frequency):\n  \"\"\"Emit a sine wave at the given frequency.\"\"\"\n  xs = tf.reshape(tf.range(_samples(), dtype=tf.float32), [1, _samples(), 1])\n  ts = xs / FLAGS.sample_rate\n  return tf.sin(2 * math.pi * frequency * ts)", "code_tokens": "def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )", "docstring_tokens": "Emit a sine wave at the given frequency .", "label": 0}, {"idx": "cosqa-train-4569", "doc": "content type flask python", "code": "def text_response(self, contents, code=200, headers={}):\n        \"\"\"shortcut to return simple plain/text messages in the response.\n\n        :param contents: a string with the response contents\n        :param code: the http status code\n        :param headers: a dict with optional headers\n        :returns: a :py:class:`flask.Response` with the ``text/plain`` **Content-Type** header.\n        \"\"\"\n        return Response(contents, status=code, headers={\n            'Content-Type': 'text/plain'\n        })", "code_tokens": "def text_response ( self , contents , code = 200 , headers = { } ) : return Response ( contents , status = code , headers = { 'Content-Type' : 'text/plain' } )", "docstring_tokens": "shortcut to return simple plain / text messages in the response .", "label": 0}, {"idx": "cosqa-train-4570", "doc": "python generic name for a string", "code": "def make_name(estimator):\n  \"\"\"Helper function that returns the name of estimator or the given string\n  if a string is given\n  \"\"\"\n  if estimator is not None:\n    if isinstance(estimator, six.string_types):\n      estimator_name = estimator\n    else:\n      estimator_name = estimator.__class__.__name__\n  else:\n    estimator_name = None\n  return estimator_name", "code_tokens": "def make_name ( estimator ) : if estimator is not None : if isinstance ( estimator , six . string_types ) : estimator_name = estimator else : estimator_name = estimator . __class__ . __name__ else : estimator_name = None return estimator_name", "docstring_tokens": "Helper function that returns the name of estimator or the given string if a string is given", "label": 0}, {"idx": "cosqa-train-4571", "doc": "context menu click event python", "code": "def OnContextMenu(self, event):\n        \"\"\"Context menu event handler\"\"\"\n\n        self.grid.PopupMenu(self.grid.contextmenu)\n\n        event.Skip()", "code_tokens": "def OnContextMenu ( self , event ) : self . grid . PopupMenu ( self . grid . contextmenu ) event . Skip ( )", "docstring_tokens": "Context menu event handler", "label": 0}, {"idx": "cosqa-train-4572", "doc": "python get a list of all files in a directory using pathlib", "code": "def list_files(directory):\n    \"\"\"Returns all files in a given directory\n    \"\"\"\n    return [f for f in pathlib.Path(directory).iterdir() if f.is_file() and not f.name.startswith('.')]", "code_tokens": "def list_files ( directory ) : return [ f for f in pathlib . Path ( directory ) . iterdir ( ) if f . is_file ( ) and not f . name . startswith ( '.' ) ]", "docstring_tokens": "Returns all files in a given directory", "label": 0}, {"idx": "cosqa-train-4573", "doc": "control window position python", "code": "def OnMove(self, event):\n        \"\"\"Main window move event\"\"\"\n\n        # Store window position in config\n        position = self.main_window.GetScreenPositionTuple()\n\n        config[\"window_position\"] = repr(position)", "code_tokens": "def OnMove ( self , event ) : # Store window position in config position = self . main_window . GetScreenPositionTuple ( ) config [ \"window_position\" ] = repr ( position )", "docstring_tokens": "Main window move event", "label": 0}, {"idx": "cosqa-train-4574", "doc": "python get a list of the files in a directory", "code": "def list_files(directory):\n    \"\"\"Returns all files in a given directory\n    \"\"\"\n    return [f for f in pathlib.Path(directory).iterdir() if f.is_file() and not f.name.startswith('.')]", "code_tokens": "def list_files ( directory ) : return [ f for f in pathlib . Path ( directory ) . iterdir ( ) if f . is_file ( ) and not f . name . startswith ( '.' ) ]", "docstring_tokens": "Returns all files in a given directory", "label": 0}, {"idx": "cosqa-train-4575", "doc": "converty query to string python", "code": "def filter_query_string(query):\n    \"\"\"\n        Return a version of the query string with the _e, _k and _s values\n        removed.\n    \"\"\"\n    return '&'.join([q for q in query.split('&')\n        if not (q.startswith('_k=') or q.startswith('_e=') or q.startswith('_s'))])", "code_tokens": "def filter_query_string ( query ) : return '&' . join ( [ q for q in query . split ( '&' ) if not ( q . startswith ( '_k=' ) or q . startswith ( '_e=' ) or q . startswith ( '_s' ) ) ] )", "docstring_tokens": "Return a version of the query string with the _e _k and _s values removed .", "label": 0}, {"idx": "cosqa-train-4576", "doc": "python get a list of unique items", "code": "def unique_items(seq):\n    \"\"\"Return the unique items from iterable *seq* (in order).\"\"\"\n    seen = set()\n    return [x for x in seq if not (x in seen or seen.add(x))]", "code_tokens": "def unique_items ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Return the unique items from iterable * seq * ( in order ) .", "label": 0}, {"idx": "cosqa-train-4577", "doc": "coolwarm python color palette", "code": "def adjust(cols, light):\n    \"\"\"Create palette.\"\"\"\n    raw_colors = [cols[0], *cols, \"#FFFFFF\",\n                  \"#000000\", *cols, \"#FFFFFF\"]\n\n    return colors.generic_adjust(raw_colors, light)", "code_tokens": "def adjust ( cols , light ) : raw_colors = [ cols [ 0 ] , * cols , \"#FFFFFF\" , \"#000000\" , * cols , \"#FFFFFF\" ] return colors . generic_adjust ( raw_colors , light )", "docstring_tokens": "Create palette .", "label": 0}, {"idx": "cosqa-train-4578", "doc": "python get a median datetime", "code": "def median_date(dt_list):\n    \"\"\"Calcuate median datetime from datetime list\n    \"\"\"\n    #dt_list_sort = sorted(dt_list)\n    idx = len(dt_list)/2\n    if len(dt_list) % 2 == 0:\n        md = mean_date([dt_list[idx-1], dt_list[idx]])\n    else:\n        md = dt_list[idx]\n    return md", "code_tokens": "def median_date ( dt_list ) : #dt_list_sort = sorted(dt_list) idx = len ( dt_list ) / 2 if len ( dt_list ) % 2 == 0 : md = mean_date ( [ dt_list [ idx - 1 ] , dt_list [ idx ] ] ) else : md = dt_list [ idx ] return md", "docstring_tokens": "Calcuate median datetime from datetime list", "label": 0}, {"idx": "cosqa-train-4579", "doc": "coordinates on a grid in python", "code": "def RadiusGrid(gridSize):\n    \"\"\"\n    Return a square grid with values of the distance from the centre \n    of the grid to each gridpoint\n    \"\"\"\n    x,y=np.mgrid[0:gridSize,0:gridSize]\n    x = x-(gridSize-1.0)/2.0\n    y = y-(gridSize-1.0)/2.0\n    return np.abs(x+1j*y)", "code_tokens": "def RadiusGrid ( gridSize ) : x , y = np . mgrid [ 0 : gridSize , 0 : gridSize ] x = x - ( gridSize - 1.0 ) / 2.0 y = y - ( gridSize - 1.0 ) / 2.0 return np . abs ( x + 1j * y )", "docstring_tokens": "Return a square grid with values of the distance from the centre of the grid to each gridpoint", "label": 0}, {"idx": "cosqa-train-4580", "doc": "python get abspath from relative path", "code": "def __absolute__(self, uri):\n        \"\"\" Get the absolute uri for a file\n\n        :param uri: URI of the resource to be retrieved\n        :return: Absolute Path\n        \"\"\"\n        return op.abspath(op.join(self.__path__, uri))", "code_tokens": "def __absolute__ ( self , uri ) : return op . abspath ( op . join ( self . __path__ , uri ) )", "docstring_tokens": "Get the absolute uri for a file", "label": 1}, {"idx": "cosqa-train-4581", "doc": "corrcoef python returns nan", "code": "def autocorr_coeff(x, t, tau1, tau2):\n    \"\"\"Calculate the autocorrelation coefficient.\"\"\"\n    return corr_coeff(x, x, t, tau1, tau2)", "code_tokens": "def autocorr_coeff ( x , t , tau1 , tau2 ) : return corr_coeff ( x , x , t , tau1 , tau2 )", "docstring_tokens": "Calculate the autocorrelation coefficient .", "label": 0}, {"idx": "cosqa-train-4582", "doc": "python get active browser url", "code": "def url(self):\n        \"\"\" The url of this window \"\"\"\n        with switch_window(self._browser, self.name):\n            return self._browser.url", "code_tokens": "def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "docstring_tokens": "The url of this window", "label": 0}, {"idx": "cosqa-train-4583", "doc": "count number of spaces in python string text", "code": "def indentsize(line):\n    \"\"\"Return the indent size, in spaces, at the start of a line of text.\"\"\"\n    expline = string.expandtabs(line)\n    return len(expline) - len(string.lstrip(expline))", "code_tokens": "def indentsize ( line ) : expline = string . expandtabs ( line ) return len ( expline ) - len ( string . lstrip ( expline ) )", "docstring_tokens": "Return the indent size in spaces at the start of a line of text .", "label": 0}, {"idx": "cosqa-train-4584", "doc": "python get all child objects", "code": "def as_list(self):\n        \"\"\"Return all child objects in nested lists of strings.\"\"\"\n        return [self.name, self.value, [x.as_list for x in self.children]]", "code_tokens": "def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]", "docstring_tokens": "Return all child objects in nested lists of strings .", "label": 1}, {"idx": "cosqa-train-4585", "doc": "count the number of open brackets in a string using python", "code": "def paren_change(inputstring, opens=opens, closes=closes):\n    \"\"\"Determine the parenthetical change of level (num closes - num opens).\"\"\"\n    count = 0\n    for c in inputstring:\n        if c in opens:  # open parens/brackets/braces\n            count -= 1\n        elif c in closes:  # close parens/brackets/braces\n            count += 1\n    return count", "code_tokens": "def paren_change ( inputstring , opens = opens , closes = closes ) : count = 0 for c in inputstring : if c in opens : # open parens/brackets/braces count -= 1 elif c in closes : # close parens/brackets/braces count += 1 return count", "docstring_tokens": "Determine the parenthetical change of level ( num closes - num opens ) .", "label": 1}, {"idx": "cosqa-train-4586", "doc": "python get all days in a month", "code": "def get_month_start_end_day():\n    \"\"\"\n    Get the month start date a nd end date\n    \"\"\"\n    t = date.today()\n    n = mdays[t.month]\n    return (date(t.year, t.month, 1), date(t.year, t.month, n))", "code_tokens": "def get_month_start_end_day ( ) : t = date . today ( ) n = mdays [ t . month ] return ( date ( t . year , t . month , 1 ) , date ( t . year , t . month , n ) )", "docstring_tokens": "Get the month start date a nd end date", "label": 0}, {"idx": "cosqa-train-4587", "doc": "count the number of total nan values in a column python", "code": "def count(data, axis=None):\n    \"\"\"Count the number of non-NA in this array along the given axis or axes\n    \"\"\"\n    return np.sum(np.logical_not(isnull(data)), axis=axis)", "code_tokens": "def count ( data , axis = None ) : return np . sum ( np . logical_not ( isnull ( data ) ) , axis = axis )", "docstring_tokens": "Count the number of non - NA in this array along the given axis or axes", "label": 0}, {"idx": "cosqa-train-4588", "doc": "python get all permutation list", "code": "def circ_permutation(items):\n    \"\"\"Calculate the circular permutation for a given list of items.\"\"\"\n    permutations = []\n    for i in range(len(items)):\n        permutations.append(items[i:] + items[:i])\n    return permutations", "code_tokens": "def circ_permutation ( items ) : permutations = [ ] for i in range ( len ( items ) ) : permutations . append ( items [ i : ] + items [ : i ] ) return permutations", "docstring_tokens": "Calculate the circular permutation for a given list of items .", "label": 0}, {"idx": "cosqa-train-4589", "doc": "create a comma seperated string into a list python", "code": "def string_to_list(string, sep=\",\", filter_empty=False):\n    \"\"\"Transforma una string con elementos separados por `sep` en una lista.\"\"\"\n    return [value.strip() for value in string.split(sep)\n            if (not filter_empty or value)]", "code_tokens": "def string_to_list ( string , sep = \",\" , filter_empty = False ) : return [ value . strip ( ) for value in string . split ( sep ) if ( not filter_empty or value ) ]", "docstring_tokens": "Transforma una string con elementos separados por sep en una lista .", "label": 0}, {"idx": "cosqa-train-4590", "doc": "python get appdata folder", "code": "def data_directory():\n    \"\"\"Return the absolute path to the directory containing the package data.\"\"\"\n    package_directory = os.path.abspath(os.path.dirname(__file__))\n    return os.path.join(package_directory, \"data\")", "code_tokens": "def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , \"data\" )", "docstring_tokens": "Return the absolute path to the directory containing the package data .", "label": 0}, {"idx": "cosqa-train-4591", "doc": "create a new line in python without enter", "code": "def go_to_new_line(self):\n        \"\"\"Go to the end of the current line and create a new line\"\"\"\n        self.stdkey_end(False, False)\n        self.insert_text(self.get_line_separator())", "code_tokens": "def go_to_new_line ( self ) : self . stdkey_end ( False , False ) self . insert_text ( self . get_line_separator ( ) )", "docstring_tokens": "Go to the end of the current line and create a new line", "label": 0}, {"idx": "cosqa-train-4592", "doc": "python get audio volume", "code": "def calc_volume(self, sample: np.ndarray):\n        \"\"\"Find the RMS of the audio\"\"\"\n        return sqrt(np.mean(np.square(sample)))", "code_tokens": "def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )", "docstring_tokens": "Find the RMS of the audio", "label": 0}, {"idx": "cosqa-train-4593", "doc": "create a set of all letters in a string python", "code": "def make_unique_ngrams(s, n):\n    \"\"\"Make a set of unique n-grams from a string.\"\"\"\n    return set(s[i:i + n] for i in range(len(s) - n + 1))", "code_tokens": "def make_unique_ngrams ( s , n ) : return set ( s [ i : i + n ] for i in range ( len ( s ) - n + 1 ) )", "docstring_tokens": "Make a set of unique n - grams from a string .", "label": 0}, {"idx": "cosqa-train-4594", "doc": "python get byte length of stream", "code": "def read_string(buff, byteorder='big'):\n    \"\"\"Read a string from a file-like object.\"\"\"\n    length = read_numeric(USHORT, buff, byteorder)\n    return buff.read(length).decode('utf-8')", "code_tokens": "def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )", "docstring_tokens": "Read a string from a file - like object .", "label": 0}, {"idx": "cosqa-train-4595", "doc": "create conda env with specific python", "code": "def create_conda_env(sandbox_dir, env_name, dependencies, options=()):\n    \"\"\"\n    Create a conda environment inside the current sandbox for the given list of dependencies and options.\n\n    Parameters\n    ----------\n    sandbox_dir : str\n    env_name : str\n    dependencies : list\n        List of conda specs\n    options\n        List of additional options to pass to conda.  Things like [\"-c\", \"conda-forge\"]\n\n    Returns\n    -------\n    (env_dir, env_name)\n    \"\"\"\n\n    env_dir = os.path.join(sandbox_dir, env_name)\n    cmdline = [\"conda\", \"create\", \"--yes\", \"--copy\", \"--quiet\", \"-p\", env_dir] + list(options) + dependencies\n\n    log.info(\"Creating conda environment: \")\n    log.info(\"  command line: %s\", cmdline)\n    subprocess.check_call(cmdline, stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n    log.debug(\"Environment created\")\n\n    return env_dir, env_name", "code_tokens": "def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ \"conda\" , \"create\" , \"--yes\" , \"--copy\" , \"--quiet\" , \"-p\" , env_dir ] + list ( options ) + dependencies log . info ( \"Creating conda environment: \" ) log . info ( \"  command line: %s\" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( \"Environment created\" ) return env_dir , env_name", "docstring_tokens": "Create a conda environment inside the current sandbox for the given list of dependencies and options .", "label": 0}, {"idx": "cosqa-train-4596", "doc": "create dense matrix from sparse matrix in python", "code": "def sparse_to_matrix(sparse):\n    \"\"\"\n    Take a sparse (n,3) list of integer indexes of filled cells,\n    turn it into a dense (m,o,p) matrix.\n\n    Parameters\n    -----------\n    sparse: (n,3) int, index of filled cells\n\n    Returns\n    ------------\n    dense: (m,o,p) bool, matrix of filled cells\n    \"\"\"\n\n    sparse = np.asanyarray(sparse, dtype=np.int)\n    if not util.is_shape(sparse, (-1, 3)):\n        raise ValueError('sparse must be (n,3)!')\n\n    shape = sparse.max(axis=0) + 1\n    matrix = np.zeros(np.product(shape), dtype=np.bool)\n    multiplier = np.array([np.product(shape[1:]), shape[2], 1])\n\n    index = (sparse * multiplier).sum(axis=1)\n    matrix[index] = True\n\n    dense = matrix.reshape(shape)\n    return dense", "code_tokens": "def sparse_to_matrix ( sparse ) : sparse = np . asanyarray ( sparse , dtype = np . int ) if not util . is_shape ( sparse , ( - 1 , 3 ) ) : raise ValueError ( 'sparse must be (n,3)!' ) shape = sparse . max ( axis = 0 ) + 1 matrix = np . zeros ( np . product ( shape ) , dtype = np . bool ) multiplier = np . array ( [ np . product ( shape [ 1 : ] ) , shape [ 2 ] , 1 ] ) index = ( sparse * multiplier ) . sum ( axis = 1 ) matrix [ index ] = True dense = matrix . reshape ( shape ) return dense", "docstring_tokens": "Take a sparse ( n 3 ) list of integer indexes of filled cells turn it into a dense ( m o p ) matrix .", "label": 0}, {"idx": "cosqa-train-4597", "doc": "python get command window width", "code": "def get_size(self):\n        \"\"\"see doc in Term class\"\"\"\n        self.curses.setupterm()\n        return self.curses.tigetnum('cols'), self.curses.tigetnum('lines')", "code_tokens": "def get_size ( self ) : self . curses . setupterm ( ) return self . curses . tigetnum ( 'cols' ) , self . curses . tigetnum ( 'lines' )", "docstring_tokens": "see doc in Term class", "label": 1}, {"idx": "cosqa-train-4598", "doc": "create folder if not exists with pathlib python", "code": "def ensure_dir_exists(directory):\n    \"\"\"Se asegura de que un directorio exista.\"\"\"\n    if directory and not os.path.exists(directory):\n        os.makedirs(directory)", "code_tokens": "def ensure_dir_exists ( directory ) : if directory and not os . path . exists ( directory ) : os . makedirs ( directory )", "docstring_tokens": "Se asegura de que un directorio exista .", "label": 0}, {"idx": "cosqa-train-4599", "doc": "python get coordinates of mouse", "code": "def get_mouse_location(self):\n        \"\"\"\n        Get the current mouse location (coordinates and screen number).\n\n        :return: a namedtuple with ``x``, ``y`` and ``screen_num`` fields\n        \"\"\"\n        x = ctypes.c_int(0)\n        y = ctypes.c_int(0)\n        screen_num = ctypes.c_int(0)\n        _libxdo.xdo_get_mouse_location(\n            self._xdo, ctypes.byref(x), ctypes.byref(y),\n            ctypes.byref(screen_num))\n        return mouse_location(x.value, y.value, screen_num.value)", "code_tokens": "def get_mouse_location ( self ) : x = ctypes . c_int ( 0 ) y = ctypes . c_int ( 0 ) screen_num = ctypes . c_int ( 0 ) _libxdo . xdo_get_mouse_location ( self . _xdo , ctypes . byref ( x ) , ctypes . byref ( y ) , ctypes . byref ( screen_num ) ) return mouse_location ( x . value , y . value , screen_num . value )", "docstring_tokens": "Get the current mouse location ( coordinates and screen number ) .", "label": 1}, {"idx": "cosqa-train-4600", "doc": "create list from unique values python", "code": "def unique(input_list):\n    \"\"\"\n    Return a list of unique items (similar to set functionality).\n\n    Parameters\n    ----------\n    input_list : list\n        A list containg some items that can occur more than once.\n\n    Returns\n    -------\n    list\n        A list with only unique occurances of an item.\n\n    \"\"\"\n    output = []\n    for item in input_list:\n        if item not in output:\n            output.append(item)\n    return output", "code_tokens": "def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output", "docstring_tokens": "Return a list of unique items ( similar to set functionality ) .", "label": 1}, {"idx": "cosqa-train-4601", "doc": "create property file python", "code": "def write_property(fh, key, value):\n  \"\"\"\n    Write a single property to the file in Java properties format.\n\n    :param fh: a writable file-like object\n    :param key: the key to write\n    :param value: the value to write\n  \"\"\"\n  if key is COMMENT:\n    write_comment(fh, value)\n    return\n\n  _require_string(key, 'keys')\n  _require_string(value, 'values')\n\n  fh.write(_escape_key(key))\n  fh.write(b'=')\n  fh.write(_escape_value(value))\n  fh.write(b'\\n')", "code_tokens": "def write_property ( fh , key , value ) : if key is COMMENT : write_comment ( fh , value ) return _require_string ( key , 'keys' ) _require_string ( value , 'values' ) fh . write ( _escape_key ( key ) ) fh . write ( b'=' ) fh . write ( _escape_value ( value ) ) fh . write ( b'\\n' )", "docstring_tokens": "Write a single property to the file in Java properties format .", "label": 0}, {"idx": "cosqa-train-4602", "doc": "python get current git branch of file", "code": "def get_current_branch():\n    \"\"\"\n    Return the current branch\n    \"\"\"\n    cmd = [\"git\", \"rev-parse\", \"--abbrev-ref\", \"HEAD\"]\n    output = subprocess.check_output(cmd, stderr=subprocess.STDOUT)\n    return output.strip().decode(\"utf-8\")", "code_tokens": "def get_current_branch ( ) : cmd = [ \"git\" , \"rev-parse\" , \"--abbrev-ref\" , \"HEAD\" ] output = subprocess . check_output ( cmd , stderr = subprocess . STDOUT ) return output . strip ( ) . decode ( \"utf-8\" )", "docstring_tokens": "Return the current branch", "label": 0}, {"idx": "cosqa-train-4603", "doc": "create python object from dictionary vars", "code": "def from_dict(cls, d):\n        \"\"\"Create an instance from a dictionary.\"\"\"\n        return cls(**{k: v for k, v in d.items() if k in cls.ENTRIES})", "code_tokens": "def from_dict ( cls , d ) : return cls ( * * { k : v for k , v in d . items ( ) if k in cls . ENTRIES } )", "docstring_tokens": "Create an instance from a dictionary .", "label": 1}, {"idx": "cosqa-train-4604", "doc": "python get current memory usage never decrease", "code": "def memory_used(self):\n        \"\"\"To know the allocated memory at function termination.\n\n        ..versionadded:: 4.1\n\n        This property might return None if the function is still running.\n\n        This function should help to show memory leaks or ram greedy code.\n        \"\"\"\n        if self._end_memory:\n            memory_used = self._end_memory - self._start_memory\n            return memory_used\n        else:\n            return None", "code_tokens": "def memory_used ( self ) : if self . _end_memory : memory_used = self . _end_memory - self . _start_memory return memory_used else : return None", "docstring_tokens": "To know the allocated memory at function termination .", "label": 1}, {"idx": "cosqa-train-4605", "doc": "creating a colorbar without a scalar mappable python", "code": "def colorbar(height, length, colormap):\n    \"\"\"Return the channels of a colorbar.\n    \"\"\"\n    cbar = np.tile(np.arange(length) * 1.0 / (length - 1), (height, 1))\n    cbar = (cbar * (colormap.values.max() - colormap.values.min())\n            + colormap.values.min())\n\n    return colormap.colorize(cbar)", "code_tokens": "def colorbar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . colorize ( cbar )", "docstring_tokens": "Return the channels of a colorbar .", "label": 1}, {"idx": "cosqa-train-4606", "doc": "python get date from string as date", "code": "def _read_date_from_string(str1):\n    \"\"\"\n    Reads the date from a string in the format YYYY/MM/DD and returns\n    :class: datetime.date\n    \"\"\"\n    full_date = [int(x) for x in str1.split('/')]\n    return datetime.date(full_date[0], full_date[1], full_date[2])", "code_tokens": "def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )", "docstring_tokens": "Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date", "label": 0}, {"idx": "cosqa-train-4607", "doc": "creating a range of list to the value n python", "code": "def chunk_list(l, n):\n    \"\"\"Return `n` size lists from a given list `l`\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Return n size lists from a given list l", "label": 0}, {"idx": "cosqa-train-4608", "doc": "python get default ini value", "code": "def _get_config_or_default(self, key, default, as_type=lambda x: x):\n        \"\"\"Return a main config value, or default if it does not exist.\"\"\"\n\n        if self.main_config.has_option(self.main_section, key):\n            return as_type(self.main_config.get(self.main_section, key))\n        return default", "code_tokens": "def _get_config_or_default ( self , key , default , as_type = lambda x : x ) : if self . main_config . has_option ( self . main_section , key ) : return as_type ( self . main_config . get ( self . main_section , key ) ) return default", "docstring_tokens": "Return a main config value or default if it does not exist .", "label": 1}, {"idx": "cosqa-train-4609", "doc": "cstring to byte array python", "code": "def bytes_to_c_array(data):\n    \"\"\"\n    Make a C array using the given string.\n    \"\"\"\n    chars = [\n        \"'{}'\".format(encode_escape(i))\n        for i in decode_escape(data)\n    ]\n    return ', '.join(chars) + ', 0'", "code_tokens": "def bytes_to_c_array ( data ) : chars = [ \"'{}'\" . format ( encode_escape ( i ) ) for i in decode_escape ( data ) ] return ', ' . join ( chars ) + ', 0'", "docstring_tokens": "Make a C array using the given string .", "label": 0}, {"idx": "cosqa-train-4610", "doc": "python get default stdout handler", "code": "def disable_stdout_buffering():\n    \"\"\"This turns off stdout buffering so that outputs are immediately\n    materialized and log messages show up before the program exits\"\"\"\n    stdout_orig = sys.stdout\n    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)\n    # NOTE(brandyn): This removes the original stdout\n    return stdout_orig", "code_tokens": "def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig", "docstring_tokens": "This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits", "label": 0}, {"idx": "cosqa-train-4611", "doc": "ctypes pointer to python buffer", "code": "def pointer(self):\n        \"\"\"Get a ctypes void pointer to the memory mapped region.\n\n        :type: ctypes.c_void_p\n        \"\"\"\n        return ctypes.cast(ctypes.pointer(ctypes.c_uint8.from_buffer(self.mapping, 0)), ctypes.c_void_p)", "code_tokens": "def pointer ( self ) : return ctypes . cast ( ctypes . pointer ( ctypes . c_uint8 . from_buffer ( self . mapping , 0 ) ) , ctypes . c_void_p )", "docstring_tokens": "Get a ctypes void pointer to the memory mapped region .", "label": 0}, {"idx": "cosqa-train-4612", "doc": "python get dimension of 2d list", "code": "def get_list_dimensions(_list):\n    \"\"\"\n    Takes a nested list and returns the size of each dimension followed\n    by the element type in the list\n    \"\"\"\n    if isinstance(_list, list) or isinstance(_list, tuple):\n        return [len(_list)] + get_list_dimensions(_list[0])\n    return []", "code_tokens": "def get_list_dimensions ( _list ) : if isinstance ( _list , list ) or isinstance ( _list , tuple ) : return [ len ( _list ) ] + get_list_dimensions ( _list [ 0 ] ) return [ ]", "docstring_tokens": "Takes a nested list and returns the size of each dimension followed by the element type in the list", "label": 0}, {"idx": "cosqa-train-4613", "doc": "ctypes python load windows dll in linux", "code": "def load(self, name):\n        \"\"\"Loads and returns foreign library.\"\"\"\n        name = ctypes.util.find_library(name)\n        return ctypes.cdll.LoadLibrary(name)", "code_tokens": "def load ( self , name ) : name = ctypes . util . find_library ( name ) return ctypes . cdll . LoadLibrary ( name )", "docstring_tokens": "Loads and returns foreign library .", "label": 0}, {"idx": "cosqa-train-4614", "doc": "python get dpi from image", "code": "def horz_dpi(self):\n        \"\"\"\n        Integer dots per inch for the width of this image. Defaults to 72\n        when not present in the file, as is often the case.\n        \"\"\"\n        pHYs = self._chunks.pHYs\n        if pHYs is None:\n            return 72\n        return self._dpi(pHYs.units_specifier, pHYs.horz_px_per_unit)", "code_tokens": "def horz_dpi ( self ) : pHYs = self . _chunks . pHYs if pHYs is None : return 72 return self . _dpi ( pHYs . units_specifier , pHYs . horz_px_per_unit )", "docstring_tokens": "Integer dots per inch for the width of this image . Defaults to 72 when not present in the file as is often the case .", "label": 0}, {"idx": "cosqa-train-4615", "doc": "python get earliest from list", "code": "def newest_file(file_iterable):\n  \"\"\"\n  Returns the name of the newest file given an iterable of file names.\n\n  \"\"\"\n  return max(file_iterable, key=lambda fname: os.path.getmtime(fname))", "code_tokens": "def newest_file ( file_iterable ) : return max ( file_iterable , key = lambda fname : os . path . getmtime ( fname ) )", "docstring_tokens": "Returns the name of the newest file given an iterable of file names .", "label": 0}, {"idx": "cosqa-train-4616", "doc": "customing the color in a scatter plot in python", "code": "def plot_target(target, ax):\n    \"\"\"Ajoute la target au plot\"\"\"\n    ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)", "code_tokens": "def plot_target ( target , ax ) : ax . scatter ( target [ 0 ] , target [ 1 ] , target [ 2 ] , c = \"red\" , s = 80 )", "docstring_tokens": "Ajoute la target au plot", "label": 0}, {"idx": "cosqa-train-4617", "doc": "python get ext of filename", "code": "def remove_ext(fname):\n    \"\"\"Removes the extension from a filename\n    \"\"\"\n    bn = os.path.basename(fname)\n    return os.path.splitext(bn)[0]", "code_tokens": "def remove_ext ( fname ) : bn = os . path . basename ( fname ) return os . path . splitext ( bn ) [ 0 ]", "docstring_tokens": "Removes the extension from a filename", "label": 0}, {"idx": "cosqa-train-4618", "doc": "cut down size of list python", "code": "def _crop_list_to_size(l, size):\n    \"\"\"Make a list a certain size\"\"\"\n    for x in range(size - len(l)):\n        l.append(False)\n    for x in range(len(l) - size):\n        l.pop()\n    return l", "code_tokens": "def _crop_list_to_size ( l , size ) : for x in range ( size - len ( l ) ) : l . append ( False ) for x in range ( len ( l ) - size ) : l . pop ( ) return l", "docstring_tokens": "Make a list a certain size", "label": 0}, {"idx": "cosqa-train-4619", "doc": "python get first day of month fro month year", "code": "def get_month_start(day=None):\n    \"\"\"Returns the first day of the given month.\"\"\"\n    day = add_timezone(day or datetime.date.today())\n    return day.replace(day=1)", "code_tokens": "def get_month_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( day = 1 )", "docstring_tokens": "Returns the first day of the given month .", "label": 0}, {"idx": "cosqa-train-4620", "doc": "cv2 python scale image", "code": "def uint8sc(im):\n    \"\"\"Scale the image to uint8\n\n    Parameters:\n    -----------\n    im: 2d array\n        The image\n\n    Returns:\n    --------\n    im: 2d array (dtype uint8)\n        The scaled image to uint8\n    \"\"\"\n    im = np.asarray(im)\n    immin = im.min()\n    immax = im.max()\n    imrange = immax - immin\n    return cv2.convertScaleAbs(im - immin, alpha=255 / imrange)", "code_tokens": "def uint8sc ( im ) : im = np . asarray ( im ) immin = im . min ( ) immax = im . max ( ) imrange = immax - immin return cv2 . convertScaleAbs ( im - immin , alpha = 255 / imrange )", "docstring_tokens": "Scale the image to uint8", "label": 0}, {"idx": "cosqa-train-4621", "doc": "python get fully qualified name", "code": "def qualified_name_import(cls):\n    \"\"\"Full name of a class, including the module. Like qualified_class_name, but when you already have a class \"\"\"\n\n    parts = qualified_name(cls).split('.')\n\n    return \"from {} import {}\".format('.'.join(parts[:-1]), parts[-1])", "code_tokens": "def qualified_name_import ( cls ) : parts = qualified_name ( cls ) . split ( '.' ) return \"from {} import {}\" . format ( '.' . join ( parts [ : - 1 ] ) , parts [ - 1 ] )", "docstring_tokens": "Full name of a class including the module . Like qualified_class_name but when you already have a class", "label": 0}, {"idx": "cosqa-train-4622", "doc": "python get global var with name", "code": "def getvariable(name):\n    \"\"\"Get the value of a local variable somewhere in the call stack.\"\"\"\n    import inspect\n    fr = inspect.currentframe()\n    try:\n        while fr:\n            fr = fr.f_back\n            vars = fr.f_locals\n            if name in vars:\n                return vars[name]\n    except:\n        pass\n    return None", "code_tokens": "def getvariable ( name ) : import inspect fr = inspect . currentframe ( ) try : while fr : fr = fr . f_back vars = fr . f_locals if name in vars : return vars [ name ] except : pass return None", "docstring_tokens": "Get the value of a local variable somewhere in the call stack .", "label": 0}, {"idx": "cosqa-train-4623", "doc": "de duplicate list in python", "code": "def unique(list):\n    \"\"\" Returns a copy of the list without duplicates.\n    \"\"\"\n    unique = []; [unique.append(x) for x in list if x not in unique]\n    return unique", "code_tokens": "def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique", "docstring_tokens": "Returns a copy of the list without duplicates .", "label": 0}, {"idx": "cosqa-train-4624", "doc": "python get http file size", "code": "def server(self):\n        \"\"\"Returns the size of remote files\n        \"\"\"\n        try:\n            tar = urllib2.urlopen(self.registry)\n            meta = tar.info()\n            return int(meta.getheaders(\"Content-Length\")[0])\n        except (urllib2.URLError, IndexError):\n            return \" \"", "code_tokens": "def server ( self ) : try : tar = urllib2 . urlopen ( self . registry ) meta = tar . info ( ) return int ( meta . getheaders ( \"Content-Length\" ) [ 0 ] ) except ( urllib2 . URLError , IndexError ) : return \" \"", "docstring_tokens": "Returns the size of remote files", "label": 0}, {"idx": "cosqa-train-4625", "doc": "decision tree categorical python", "code": "def cric__decision_tree():\n    \"\"\" Decision Tree\n    \"\"\"\n    model = sklearn.tree.DecisionTreeClassifier(random_state=0, max_depth=4)\n\n    # we want to explain the raw probability outputs of the trees\n    model.predict = lambda X: model.predict_proba(X)[:,1]\n    \n    return model", "code_tokens": "def cric__decision_tree ( ) : model = sklearn . tree . DecisionTreeClassifier ( random_state = 0 , max_depth = 4 ) # we want to explain the raw probability outputs of the trees model . predict = lambda X : model . predict_proba ( X ) [ : , 1 ] return model", "docstring_tokens": "Decision Tree", "label": 0}, {"idx": "cosqa-train-4626", "doc": "python get index in iterator", "code": "def index(self, elem):\n        \"\"\"Find the index of elem in the reversed iterator.\"\"\"\n        return _coconut.len(self._iter) - self._iter.index(elem) - 1", "code_tokens": "def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1", "docstring_tokens": "Find the index of elem in the reversed iterator .", "label": 1}, {"idx": "cosqa-train-4627", "doc": "decompile the python code", "code": "def xeval(source, optimize=True):\n    \"\"\"Compiles to native Python bytecode and runs program, returning the\n    topmost value on the stack.\n\n    Args:\n        optimize: Whether to optimize the code after parsing it.\n\n    Returns:\n        None: If the stack is empty\n        obj: If the stack contains a single value\n        [obj, obj, ...]: If the stack contains many values\n    \"\"\"\n    native = xcompile(source, optimize=optimize)\n    return native()", "code_tokens": "def xeval ( source , optimize = True ) : native = xcompile ( source , optimize = optimize ) return native ( )", "docstring_tokens": "Compiles to native Python bytecode and runs program returning the topmost value on the stack .", "label": 0}, {"idx": "cosqa-train-4628", "doc": "python get instance by string", "code": "def load_object_by_name(object_name):\n    \"\"\"Load an object from a module by name\"\"\"\n    mod_name, attr = object_name.rsplit('.', 1)\n    mod = import_module(mod_name)\n    return getattr(mod, attr)", "code_tokens": "def load_object_by_name ( object_name ) : mod_name , attr = object_name . rsplit ( '.' , 1 ) mod = import_module ( mod_name ) return getattr ( mod , attr )", "docstring_tokens": "Load an object from a module by name", "label": 0}, {"idx": "cosqa-train-4629", "doc": "defining object equality in python", "code": "def __eq__(self, other):\n        \"\"\"Determine if two objects are equal.\"\"\"\n        return isinstance(other, self.__class__) \\\n            and self._freeze() == other._freeze()", "code_tokens": "def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) and self . _freeze ( ) == other . _freeze ( )", "docstring_tokens": "Determine if two objects are equal .", "label": 1}, {"idx": "cosqa-train-4630", "doc": "python get item at index", "code": "def __getitem__(self, index):\n    \"\"\"Get the item at the given index.\n\n    Index is a tuple of (row, col)\n    \"\"\"\n    row, col = index\n    return self.rows[row][col]", "code_tokens": "def __getitem__ ( self , index ) : row , col = index return self . rows [ row ] [ col ]", "docstring_tokens": "Get the item at the given index .", "label": 0}, {"idx": "cosqa-train-4631", "doc": "deleating all references in python", "code": "def _release(self):\n        \"\"\"Destroy self since closures cannot be called again.\"\"\"\n        del self.funcs\n        del self.variables\n        del self.variable_values\n        del self.satisfied", "code_tokens": "def _release ( self ) : del self . funcs del self . variables del self . variable_values del self . satisfied", "docstring_tokens": "Destroy self since closures cannot be called again .", "label": 0}, {"idx": "cosqa-train-4632", "doc": "python get iterator to values in dict", "code": "def itervalues(d, **kw):\n    \"\"\"Return an iterator over the values of a dictionary.\"\"\"\n    if not PY2:\n        return iter(d.values(**kw))\n    return d.itervalues(**kw)", "code_tokens": "def itervalues ( d , * * kw ) : if not PY2 : return iter ( d . values ( * * kw ) ) return d . itervalues ( * * kw )", "docstring_tokens": "Return an iterator over the values of a dictionary .", "label": 0}, {"idx": "cosqa-train-4633", "doc": "delete a directory in python", "code": "def safe_rmtree(directory):\n  \"\"\"Delete a directory if it's present. If it's not present, no-op.\"\"\"\n  if os.path.exists(directory):\n    shutil.rmtree(directory, True)", "code_tokens": "def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )", "docstring_tokens": "Delete a directory if it s present . If it s not present no - op .", "label": 0}, {"idx": "cosqa-train-4634", "doc": "python get last record in file", "code": "def last(self):\n        \"\"\"Get the last object in file.\"\"\"\n        # End of file\n        self.__file.seek(0, 2)\n\n        # Get the last struct\n        data = self.get(self.length - 1)\n\n        return data", "code_tokens": "def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data", "docstring_tokens": "Get the last object in file .", "label": 1}, {"idx": "cosqa-train-4635", "doc": "delete a label in python", "code": "def del_label(self, name):\n        \"\"\"Delete a label by name.\"\"\"\n        labels_tag = self.root[0]\n        labels_tag.remove(self._find_label(name))", "code_tokens": "def del_label ( self , name ) : labels_tag = self . root [ 0 ] labels_tag . remove ( self . _find_label ( name ) )", "docstring_tokens": "Delete a label by name .", "label": 0}, {"idx": "cosqa-train-4636", "doc": "python get list of properties on instance", "code": "def get_properties(cls):\n        \"\"\"Get all properties of the MessageFlags class.\"\"\"\n        property_names = [p for p in dir(cls)\n                          if isinstance(getattr(cls, p), property)]\n        return property_names", "code_tokens": "def get_properties ( cls ) : property_names = [ p for p in dir ( cls ) if isinstance ( getattr ( cls , p ) , property ) ] return property_names", "docstring_tokens": "Get all properties of the MessageFlags class .", "label": 0}, {"idx": "cosqa-train-4637", "doc": "delete all files except one in python", "code": "def cleanup(self):\n        \"\"\"Clean up any temporary files.\"\"\"\n        for file in glob.glob(self.basename + '*'):\n            os.unlink(file)", "code_tokens": "def cleanup ( self ) : for file in glob . glob ( self . basename + '*' ) : os . unlink ( file )", "docstring_tokens": "Clean up any temporary files .", "label": 1}, {"idx": "cosqa-train-4638", "doc": "python get longitude and latitude by name", "code": "def get_coordinates_by_full_name(self, name):\n        \"\"\"Retrieves a person's coordinates by full name\"\"\"\n        person = self.get_person_by_full_name(name)\n        if not person:\n            return '', ''\n        return person.latitude, person.longitude", "code_tokens": "def get_coordinates_by_full_name ( self , name ) : person = self . get_person_by_full_name ( name ) if not person : return '' , '' return person . latitude , person . longitude", "docstring_tokens": "Retrieves a person s coordinates by full name", "label": 0}, {"idx": "cosqa-train-4639", "doc": "delete element in deque python", "code": "def remove(self, key):\n        \"\"\"remove the value found at key from the queue\"\"\"\n        item = self.item_finder.pop(key)\n        item[-1] = None\n        self.removed_count += 1", "code_tokens": "def remove ( self , key ) : item = self . item_finder . pop ( key ) item [ - 1 ] = None self . removed_count += 1", "docstring_tokens": "remove the value found at key from the queue", "label": 0}, {"idx": "cosqa-train-4640", "doc": "python get median between 2 values", "code": "def getMedian(numericValues):\n    \"\"\"\n    Gets the median of a list of values\n    Returns a float/int\n    \"\"\"\n    theValues = sorted(numericValues)\n\n    if len(theValues) % 2 == 1:\n        return theValues[(len(theValues) + 1) / 2 - 1]\n    else:\n        lower = theValues[len(theValues) / 2 - 1]\n        upper = theValues[len(theValues) / 2]\n\n        return (float(lower + upper)) / 2", "code_tokens": "def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2", "docstring_tokens": "Gets the median of a list of values Returns a float / int", "label": 0}, {"idx": "cosqa-train-4641", "doc": "delete empty elements from a list in python", "code": "def unique(seq):\n    \"\"\"Return the unique elements of a collection even if those elements are\n       unhashable and unsortable, like dicts and sets\"\"\"\n    cleaned = []\n    for each in seq:\n        if each not in cleaned:\n            cleaned.append(each)\n    return cleaned", "code_tokens": "def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned", "docstring_tokens": "Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets", "label": 1}, {"idx": "cosqa-train-4642", "doc": "python get model name from model", "code": "def get_model(name):\n    \"\"\"\n    Convert a model's verbose name to the model class. This allows us to\n    use the models verbose name in steps.\n    \"\"\"\n\n    model = MODELS.get(name.lower(), None)\n\n    assert model, \"Could not locate model by name '%s'\" % name\n\n    return model", "code_tokens": "def get_model ( name ) : model = MODELS . get ( name . lower ( ) , None ) assert model , \"Could not locate model by name '%s'\" % name return model", "docstring_tokens": "Convert a model s verbose name to the model class . This allows us to use the models verbose name in steps .", "label": 0}, {"idx": "cosqa-train-4643", "doc": "delete zero components in a matrix python", "code": "def check_precomputed_distance_matrix(X):\n    \"\"\"Perform check_array(X) after removing infinite values (numpy.inf) from the given distance matrix.\n    \"\"\"\n    tmp = X.copy()\n    tmp[np.isinf(tmp)] = 1\n    check_array(tmp)", "code_tokens": "def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "docstring_tokens": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix .", "label": 0}, {"idx": "cosqa-train-4644", "doc": "python get music pause", "code": "def pause(self):\n        \"\"\"Pause the music\"\"\"\n        mixer.music.pause()\n        self.pause_time = self.get_time()\n        self.paused = True", "code_tokens": "def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True", "docstring_tokens": "Pause the music", "label": 1}, {"idx": "cosqa-train-4645", "doc": "deleting files in a directory in python", "code": "def clean_out_dir(directory):\n    \"\"\"\n    Delete all the files and subdirectories in a directory.\n    \"\"\"\n    if not isinstance(directory, path):\n        directory = path(directory)\n    for file_path in directory.files():\n        file_path.remove()\n    for dir_path in directory.dirs():\n        dir_path.rmtree()", "code_tokens": "def clean_out_dir ( directory ) : if not isinstance ( directory , path ) : directory = path ( directory ) for file_path in directory . files ( ) : file_path . remove ( ) for dir_path in directory . dirs ( ) : dir_path . rmtree ( )", "docstring_tokens": "Delete all the files and subdirectories in a directory .", "label": 1}, {"idx": "cosqa-train-4646", "doc": "python get n last values in array", "code": "def tail(self, n=10):\n        \"\"\"\n        Get an SArray that contains the last n elements in the SArray.\n\n        Parameters\n        ----------\n        n : int\n            The number of elements to fetch\n\n        Returns\n        -------\n        out : SArray\n            A new SArray which contains the last n rows of the current SArray.\n        \"\"\"\n        with cython_context():\n            return SArray(_proxy=self.__proxy__.tail(n))", "code_tokens": "def tail ( self , n = 10 ) : with cython_context ( ) : return SArray ( _proxy = self . __proxy__ . tail ( n ) )", "docstring_tokens": "Get an SArray that contains the last n elements in the SArray .", "label": 0}, {"idx": "cosqa-train-4647", "doc": "detect mounted image python windows", "code": "def inside_softimage():\n    \"\"\"Returns a boolean indicating if the code is executed inside softimage.\"\"\"\n    try:\n        import maya\n        return False\n    except ImportError:\n        pass\n    try:\n        from win32com.client import Dispatch as disp\n        disp('XSI.Application')\n        return True\n    except:\n        return False", "code_tokens": "def inside_softimage ( ) : try : import maya return False except ImportError : pass try : from win32com . client import Dispatch as disp disp ( 'XSI.Application' ) return True except : return False", "docstring_tokens": "Returns a boolean indicating if the code is executed inside softimage .", "label": 0}, {"idx": "cosqa-train-4648", "doc": "python get name of type from type object", "code": "def typename(obj):\n    \"\"\"Returns the type of obj as a string. More descriptive and specific than\n    type(obj), and safe for any object, unlike __class__.\"\"\"\n    if hasattr(obj, '__class__'):\n        return getattr(obj, '__class__').__name__\n    else:\n        return type(obj).__name__", "code_tokens": "def typename ( obj ) : if hasattr ( obj , '__class__' ) : return getattr ( obj , '__class__' ) . __name__ else : return type ( obj ) . __name__", "docstring_tokens": "Returns the type of obj as a string . More descriptive and specific than type ( obj ) and safe for any object unlike __class__ .", "label": 0}, {"idx": "cosqa-train-4649", "doc": "determine data type from value python", "code": "def datatype(dbtype, description, cursor):\n    \"\"\"Google AppEngine Helper to convert a data type into a string.\"\"\"\n    dt = cursor.db.introspection.get_field_type(dbtype, description)\n    if type(dt) is tuple:\n        return dt[0]\n    else:\n        return dt", "code_tokens": "def datatype ( dbtype , description , cursor ) : dt = cursor . db . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt", "docstring_tokens": "Google AppEngine Helper to convert a data type into a string .", "label": 1}, {"idx": "cosqa-train-4650", "doc": "python get next month datetime", "code": "def get_month_start_date(self):\n        \"\"\"Returns the first day of the current month\"\"\"\n        now = timezone.now()\n        return timezone.datetime(day=1, month=now.month, year=now.year, tzinfo=now.tzinfo)", "code_tokens": "def get_month_start_date ( self ) : now = timezone . now ( ) return timezone . datetime ( day = 1 , month = now . month , year = now . year , tzinfo = now . tzinfo )", "docstring_tokens": "Returns the first day of the current month", "label": 0}, {"idx": "cosqa-train-4651", "doc": "determine data type in python datafram", "code": "def _to_corrected_pandas_type(dt):\n    \"\"\"\n    When converting Spark SQL records to Pandas DataFrame, the inferred data type may be wrong.\n    This method gets the corrected data type for Pandas if that type may be inferred uncorrectly.\n    \"\"\"\n    import numpy as np\n    if type(dt) == ByteType:\n        return np.int8\n    elif type(dt) == ShortType:\n        return np.int16\n    elif type(dt) == IntegerType:\n        return np.int32\n    elif type(dt) == FloatType:\n        return np.float32\n    else:\n        return None", "code_tokens": "def _to_corrected_pandas_type ( dt ) : import numpy as np if type ( dt ) == ByteType : return np . int8 elif type ( dt ) == ShortType : return np . int16 elif type ( dt ) == IntegerType : return np . int32 elif type ( dt ) == FloatType : return np . float32 else : return None", "docstring_tokens": "When converting Spark SQL records to Pandas DataFrame the inferred data type may be wrong . This method gets the corrected data type for Pandas if that type may be inferred uncorrectly .", "label": 0}, {"idx": "cosqa-train-4652", "doc": "python get parent directory name", "code": "def get_parent_dir(name):\n    \"\"\"Get the parent directory of a filename.\"\"\"\n    parent_dir = os.path.dirname(os.path.dirname(name))\n    if parent_dir:\n        return parent_dir\n    return os.path.abspath('.')", "code_tokens": "def get_parent_dir ( name ) : parent_dir = os . path . dirname ( os . path . dirname ( name ) ) if parent_dir : return parent_dir return os . path . abspath ( '.' )", "docstring_tokens": "Get the parent directory of a filename .", "label": 1}, {"idx": "cosqa-train-4653", "doc": "determine distance between two lat long python", "code": "def _calculate_distance(latlon1, latlon2):\n    \"\"\"Calculates the distance between two points on earth.\n    \"\"\"\n    lat1, lon1 = latlon1\n    lat2, lon2 = latlon2\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    R = 6371  # radius of the earth in kilometers\n    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * (np.sin(dlon / 2))**2\n    c = 2 * np.pi * R * np.arctan2(np.sqrt(a), np.sqrt(1 - a)) / 180\n    return c", "code_tokens": "def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c", "docstring_tokens": "Calculates the distance between two points on earth .", "label": 0}, {"idx": "cosqa-train-4654", "doc": "python get property by name string", "code": "def get_property_by_name(pif, name):\n    \"\"\"Get a property by name\"\"\"\n    return next((x for x in pif.properties if x.name == name), None)", "code_tokens": "def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )", "docstring_tokens": "Get a property by name", "label": 0}, {"idx": "cosqa-train-4655", "doc": "determine the size of a 2d list python", "code": "def get_dimension_array(array):\n    \"\"\"\n    Get dimension of an array getting the number of rows and the max num of\n    columns.\n    \"\"\"\n    if all(isinstance(el, list) for el in array):\n        result = [len(array), len(max([x for x in array], key=len,))]\n\n    # elif array and isinstance(array, list):\n    else:\n        result = [len(array), 1]\n\n    return result", "code_tokens": "def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result", "docstring_tokens": "Get dimension of an array getting the number of rows and the max num of columns .", "label": 0}, {"idx": "cosqa-train-4656", "doc": "python get property by string", "code": "def get_propety_by_name(pif, name):\n    \"\"\"Get a property by name\"\"\"\n    warn(\"This method has been deprecated in favor of get_property_by_name\")\n    return next((x for x in pif.properties if x.name == name), None)", "code_tokens": "def get_propety_by_name ( pif , name ) : warn ( \"This method has been deprecated in favor of get_property_by_name\" ) return next ( ( x for x in pif . properties if x . name == name ) , None )", "docstring_tokens": "Get a property by name", "label": 0}, {"idx": "cosqa-train-4657", "doc": "dictionary to html python", "code": "def dict_to_html_attrs(dict_):\n    \"\"\"\n    Banana banana\n    \"\"\"\n    res = ' '.join('%s=\"%s\"' % (k, v) for k, v in dict_.items())\n    return res", "code_tokens": "def dict_to_html_attrs ( dict_ ) : res = ' ' . join ( '%s=\"%s\"' % ( k , v ) for k , v in dict_ . items ( ) ) return res", "docstring_tokens": "Banana banana", "label": 1}, {"idx": "cosqa-train-4658", "doc": "python get redis values", "code": "def get(self, key):  \n        \"\"\" get a set of keys from redis \"\"\"\n        res = self.connection.get(key)\n        print(res)\n        return res", "code_tokens": "def get ( self , key ) : res = self . connection . get ( key ) print ( res ) return res", "docstring_tokens": "get a set of keys from redis", "label": 0}, {"idx": "cosqa-train-4659", "doc": "dictionary update method python with string variable", "code": "def update(self, params):\n        \"\"\"Update the dev_info data from a dictionary.\n\n        Only updates if it already exists in the device.\n        \"\"\"\n        dev_info = self.json_state.get('deviceInfo')\n        dev_info.update({k: params[k] for k in params if dev_info.get(k)})", "code_tokens": "def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )", "docstring_tokens": "Update the dev_info data from a dictionary .", "label": 0}, {"idx": "cosqa-train-4660", "doc": "python get size of buffer", "code": "def _nbytes(buf):\n    \"\"\"Return byte-size of a memoryview or buffer.\"\"\"\n    if isinstance(buf, memoryview):\n        if PY3:\n            # py3 introduces nbytes attribute\n            return buf.nbytes\n        else:\n            # compute nbytes on py2\n            size = buf.itemsize\n            for dim in buf.shape:\n                size *= dim\n            return size\n    else:\n        # not a memoryview, raw bytes/ py2 buffer\n        return len(buf)", "code_tokens": "def _nbytes ( buf ) : if isinstance ( buf , memoryview ) : if PY3 : # py3 introduces nbytes attribute return buf . nbytes else : # compute nbytes on py2 size = buf . itemsize for dim in buf . shape : size *= dim return size else : # not a memoryview, raw bytes/ py2 buffer return len ( buf )", "docstring_tokens": "Return byte - size of a memoryview or buffer .", "label": 0}, {"idx": "cosqa-train-4661", "doc": "difflib to compare two dictionaries python", "code": "def compare_dict(da, db):\n    \"\"\"\n    Compare differencs from two dicts\n    \"\"\"\n    sa = set(da.items())\n    sb = set(db.items())\n    \n    diff = sa & sb\n    return dict(sa - diff), dict(sb - diff)", "code_tokens": "def compare_dict ( da , db ) : sa = set ( da . items ( ) ) sb = set ( db . items ( ) ) diff = sa & sb return dict ( sa - diff ) , dict ( sb - diff )", "docstring_tokens": "Compare differencs from two dicts", "label": 0}, {"idx": "cosqa-train-4662", "doc": "python get the latest modified folder in directory", "code": "def dir_modtime(dpath):\n    \"\"\"\n    Returns the latest modification time of all files/subdirectories in a\n    directory\n    \"\"\"\n    return max(os.path.getmtime(d) for d, _, _ in os.walk(dpath))", "code_tokens": "def dir_modtime ( dpath ) : return max ( os . path . getmtime ( d ) for d , _ , _ in os . walk ( dpath ) )", "docstring_tokens": "Returns the latest modification time of all files / subdirectories in a directory", "label": 0}, {"idx": "cosqa-train-4663", "doc": "disable max path limit lenght in python", "code": "def _increase_file_handle_limit():\n    \"\"\"Raise the open file handles permitted by the Dusty daemon process\n    and its child processes. The number we choose here needs to be within\n    the OS X default kernel hard limit, which is 10240.\"\"\"\n    logging.info('Increasing file handle limit to {}'.format(constants.FILE_HANDLE_LIMIT))\n    resource.setrlimit(resource.RLIMIT_NOFILE,\n                       (constants.FILE_HANDLE_LIMIT, resource.RLIM_INFINITY))", "code_tokens": "def _increase_file_handle_limit ( ) : logging . info ( 'Increasing file handle limit to {}' . format ( constants . FILE_HANDLE_LIMIT ) ) resource . setrlimit ( resource . RLIMIT_NOFILE , ( constants . FILE_HANDLE_LIMIT , resource . RLIM_INFINITY ) )", "docstring_tokens": "Raise the open file handles permitted by the Dusty daemon process and its child processes . The number we choose here needs to be within the OS X default kernel hard limit which is 10240 .", "label": 0}, {"idx": "cosqa-train-4664", "doc": "python get the number of fields in a table", "code": "def count_rows(self, table_name):\n        \"\"\"Return the number of entries in a table by counting them.\"\"\"\n        self.table_must_exist(table_name)\n        query = \"SELECT COUNT (*) FROM `%s`\" % table_name.lower()\n        self.own_cursor.execute(query)\n        return int(self.own_cursor.fetchone()[0])", "code_tokens": "def count_rows ( self , table_name ) : self . table_must_exist ( table_name ) query = \"SELECT COUNT (*) FROM `%s`\" % table_name . lower ( ) self . own_cursor . execute ( query ) return int ( self . own_cursor . fetchone ( ) [ 0 ] )", "docstring_tokens": "Return the number of entries in a table by counting them .", "label": 1}, {"idx": "cosqa-train-4665", "doc": "discord python api get user from id", "code": "def get_user_by_id(self, id):\n        \"\"\"Retrieve a User object by ID.\"\"\"\n        return self.db_adapter.get_object(self.UserClass, id=id)", "code_tokens": "def get_user_by_id ( self , id ) : return self . db_adapter . get_object ( self . UserClass , id = id )", "docstring_tokens": "Retrieve a User object by ID .", "label": 0}, {"idx": "cosqa-train-4666", "doc": "python get the numbr of microseconds in a timedelta", "code": "def datetime_delta_to_ms(delta):\n    \"\"\"\n    Given a datetime.timedelta object, return the delta in milliseconds\n    \"\"\"\n    delta_ms = delta.days * 24 * 60 * 60 * 1000\n    delta_ms += delta.seconds * 1000\n    delta_ms += delta.microseconds / 1000\n    delta_ms = int(delta_ms)\n    return delta_ms", "code_tokens": "def datetime_delta_to_ms ( delta ) : delta_ms = delta . days * 24 * 60 * 60 * 1000 delta_ms += delta . seconds * 1000 delta_ms += delta . microseconds / 1000 delta_ms = int ( delta_ms ) return delta_ms", "docstring_tokens": "Given a datetime . timedelta object return the delta in milliseconds", "label": 0}, {"idx": "cosqa-train-4667", "doc": "display an image from an url in python", "code": "def url_to_image(url):\n    \"\"\"\n    Fetch an image from url and convert it into a Pillow Image object\n    \"\"\"\n    r = requests.get(url)\n    image = StringIO(r.content)\n    return image", "code_tokens": "def url_to_image ( url ) : r = requests . get ( url ) image = StringIO ( r . content ) return image", "docstring_tokens": "Fetch an image from url and convert it into a Pillow Image object", "label": 0}, {"idx": "cosqa-train-4668", "doc": "python get total seconds gtom datetime64", "code": "def dt2ts(dt):\n    \"\"\"Converts to float representing number of seconds since 1970-01-01 GMT.\"\"\"\n    # Note: no assertion to really keep this fast\n    assert isinstance(dt, (datetime.datetime, datetime.date))\n    ret = time.mktime(dt.timetuple())\n    if isinstance(dt, datetime.datetime):\n        ret += 1e-6 * dt.microsecond\n    return ret", "code_tokens": "def dt2ts ( dt ) : # Note: no assertion to really keep this fast\n assert isinstance ( dt , ( datetime . datetime , datetime . date ) ) ret = time . mktime ( dt . timetuple ( ) ) if isinstance ( dt , datetime . datetime ) : ret += 1e-6 * dt . microsecond return ret", "docstring_tokens": "Converts to float representing number of seconds since 1970 - 01 - 01 GMT .", "label": 1}, {"idx": "cosqa-train-4669", "doc": "display dictionary in order in python", "code": "def Print(self):\n        \"\"\"Prints the values and freqs/probs in ascending order.\"\"\"\n        for val, prob in sorted(self.d.iteritems()):\n            print(val, prob)", "code_tokens": "def Print ( self ) : for val , prob in sorted ( self . d . iteritems ( ) ) : print ( val , prob )", "docstring_tokens": "Prints the values and freqs / probs in ascending order .", "label": 0}, {"idx": "cosqa-train-4670", "doc": "python get tuple from string", "code": "def ver_to_tuple(value):\n    \"\"\"\n    Convert version like string to a tuple of integers.\n    \"\"\"\n    return tuple(int(_f) for _f in re.split(r'\\D+', value) if _f)", "code_tokens": "def ver_to_tuple ( value ) : return tuple ( int ( _f ) for _f in re . split ( r'\\D+' , value ) if _f )", "docstring_tokens": "Convert version like string to a tuple of integers .", "label": 0}, {"idx": "cosqa-train-4671", "doc": "displaying an image in a widget using python", "code": "def get_plain_image_as_widget(self):\n        \"\"\"Used for generating thumbnails.  Does not include overlaid\n        graphics.\n        \"\"\"\n        arr = self.getwin_array(order=self.rgb_order)\n        image = self._get_qimage(arr, self.qimg_fmt)\n        return image", "code_tokens": "def get_plain_image_as_widget ( self ) : arr = self . getwin_array ( order = self . rgb_order ) image = self . _get_qimage ( arr , self . qimg_fmt ) return image", "docstring_tokens": "Used for generating thumbnails . Does not include overlaid graphics .", "label": 0}, {"idx": "cosqa-train-4672", "doc": "python get unique pid", "code": "def generate_unique_host_id():\n    \"\"\"Generate a unique ID, that is somewhat guaranteed to be unique among all\n    instances running at the same time.\"\"\"\n    host = \".\".join(reversed(socket.gethostname().split(\".\")))\n    pid = os.getpid()\n    return \"%s.%d\" % (host, pid)", "code_tokens": "def generate_unique_host_id ( ) : host = \".\" . join ( reversed ( socket . gethostname ( ) . split ( \".\" ) ) ) pid = os . getpid ( ) return \"%s.%d\" % ( host , pid )", "docstring_tokens": "Generate a unique ID that is somewhat guaranteed to be unique among all instances running at the same time .", "label": 0}, {"idx": "cosqa-train-4673", "doc": "distance between two vectors python", "code": "def vector_distance(a, b):\n    \"\"\"The Euclidean distance between two vectors.\"\"\"\n    a = np.array(a)\n    b = np.array(b)\n    return np.linalg.norm(a - b)", "code_tokens": "def vector_distance ( a , b ) : a = np . array ( a ) b = np . array ( b ) return np . linalg . norm ( a - b )", "docstring_tokens": "The Euclidean distance between two vectors .", "label": 1}, {"idx": "cosqa-train-4674", "doc": "python get user by pid", "code": "def get_user_by_id(self, id):\n        \"\"\"Retrieve a User object by ID.\"\"\"\n        return self.db_adapter.get_object(self.UserClass, id=id)", "code_tokens": "def get_user_by_id ( self , id ) : return self . db_adapter . get_object ( self . UserClass , id = id )", "docstring_tokens": "Retrieve a User object by ID .", "label": 1}, {"idx": "cosqa-train-4675", "doc": "docker python script doesn't see env variables", "code": "def parse_env_var(s):\n    \"\"\"Parse an environment variable string\n\n    Returns a key-value tuple\n\n    Apply the same logic as `docker run -e`:\n    \"If the operator names an environment variable without specifying a value,\n    then the current value of the named variable is propagated into the\n    container's environment\n    \"\"\"\n    parts = s.split('=', 1)\n    if len(parts) == 2:\n        k, v = parts\n        return (k, v)\n\n    k = parts[0]\n    return (k, os.getenv(k, ''))", "code_tokens": "def parse_env_var ( s ) : parts = s . split ( '=' , 1 ) if len ( parts ) == 2 : k , v = parts return ( k , v ) k = parts [ 0 ] return ( k , os . getenv ( k , '' ) )", "docstring_tokens": "Parse an environment variable string", "label": 0}, {"idx": "cosqa-train-4676", "doc": "python get user from email address", "code": "def get_user_id_from_email(self, email):\n        \"\"\" Uses the get-all-user-accounts Portals API to retrieve the\n        user-id by supplying an email. \"\"\"\n        accts = self.get_all_user_accounts()\n\n        for acct in accts:\n            if acct['email'] == email:\n                return acct['id']\n        return None", "code_tokens": "def get_user_id_from_email ( self , email ) : accts = self . get_all_user_accounts ( ) for acct in accts : if acct [ 'email' ] == email : return acct [ 'id' ] return None", "docstring_tokens": "Uses the get - all - user - accounts Portals API to retrieve the user - id by supplying an email .", "label": 0}, {"idx": "cosqa-train-4677", "doc": "does python auto create files if they don't exist", "code": "def check_create_folder(filename):\n    \"\"\"Check if the folder exisits. If not, create the folder\"\"\"\n    os.makedirs(os.path.dirname(filename), exist_ok=True)", "code_tokens": "def check_create_folder ( filename ) : os . makedirs ( os . path . dirname ( filename ) , exist_ok = True )", "docstring_tokens": "Check if the folder exisits . If not create the folder", "label": 0}, {"idx": "cosqa-train-4678", "doc": "python get windows userid ans password", "code": "def get_nt_system_uid():\n    \"\"\"Get the MachineGuid from\n    HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Cryptography\\MachineGuid\n    \"\"\"\n    try:\n        import _winreg as winreg\n    except ImportError:\n        import winreg\n    lm = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n    try:\n        key = winreg.OpenKey(lm, r\"Software\\Microsoft\\Cryptography\")\n        try:\n            return winreg.QueryValueEx(key, \"MachineGuid\")[0]\n        finally:\n            key.Close()\n    finally:\n        lm.Close()", "code_tokens": "def get_nt_system_uid ( ) : try : import _winreg as winreg except ImportError : import winreg lm = winreg . ConnectRegistry ( None , winreg . HKEY_LOCAL_MACHINE ) try : key = winreg . OpenKey ( lm , r\"Software\\Microsoft\\Cryptography\" ) try : return winreg . QueryValueEx ( key , \"MachineGuid\" ) [ 0 ] finally : key . Close ( ) finally : lm . Close ( )", "docstring_tokens": "Get the MachineGuid from HKEY_LOCAL_MACHINE \\ Software \\ Microsoft \\ Cryptography \\ MachineGuid", "label": 0}, {"idx": "cosqa-train-4679", "doc": "does python file read comments", "code": "def parse_comments_for_file(filename):\n    \"\"\"\n    Return a list of all parsed comments in a file.  Mostly for testing &\n    interactive use.\n    \"\"\"\n    return [parse_comment(strip_stars(comment), next_line)\n            for comment, next_line in get_doc_comments(read_file(filename))]", "code_tokens": "def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]", "docstring_tokens": "Return a list of all parsed comments in a file . Mostly for testing & interactive use .", "label": 0}, {"idx": "cosqa-train-4680", "doc": "python get x,y indexes of certain elements in a matrix", "code": "def get_inputs_from_cm(index, cm):\n    \"\"\"Return indices of inputs to the node with the given index.\"\"\"\n    return tuple(i for i in range(cm.shape[0]) if cm[i][index])", "code_tokens": "def get_inputs_from_cm ( index , cm ) : return tuple ( i for i in range ( cm . shape [ 0 ] ) if cm [ i ] [ index ] )", "docstring_tokens": "Return indices of inputs to the node with the given index .", "label": 1}, {"idx": "cosqa-train-4681", "doc": "does python print include linefeed", "code": "def raw_print(*args, **kw):\n    \"\"\"Raw print to sys.__stdout__, otherwise identical interface to print().\"\"\"\n\n    print(*args, sep=kw.get('sep', ' '), end=kw.get('end', '\\n'),\n          file=sys.__stdout__)\n    sys.__stdout__.flush()", "code_tokens": "def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )", "docstring_tokens": "Raw print to sys . __stdout__ otherwise identical interface to print () .", "label": 0}, {"idx": "cosqa-train-4682", "doc": "python getargs bool wrong behavior", "code": "def process_bool_arg(arg):\n    \"\"\" Determine True/False from argument \"\"\"\n    if isinstance(arg, bool):\n        return arg\n    elif isinstance(arg, basestring):\n        if arg.lower() in [\"true\", \"1\"]:\n            return True\n        elif arg.lower() in [\"false\", \"0\"]:\n            return False", "code_tokens": "def process_bool_arg ( arg ) : if isinstance ( arg , bool ) : return arg elif isinstance ( arg , basestring ) : if arg . lower ( ) in [ \"true\" , \"1\" ] : return True elif arg . lower ( ) in [ \"false\" , \"0\" ] : return False", "docstring_tokens": "Determine True / False from argument", "label": 0}, {"idx": "cosqa-train-4683", "doc": "dot file python parser", "code": "def graph_from_dot_file(path):\n    \"\"\"Load graph as defined by a DOT file.\n    \n    The file is assumed to be in DOT format. It will\n    be loaded, parsed and a Dot class will be returned, \n    representing the graph.\n    \"\"\"\n    \n    fd = file(path, 'rb')\n    data = fd.read()\n    fd.close()\n    \n    return graph_from_dot_data(data)", "code_tokens": "def graph_from_dot_file ( path ) : fd = file ( path , 'rb' ) data = fd . read ( ) fd . close ( ) return graph_from_dot_data ( data )", "docstring_tokens": "Load graph as defined by a DOT file . The file is assumed to be in DOT format . It will be loaded parsed and a Dot class will be returned representing the graph .", "label": 0}, {"idx": "cosqa-train-4684", "doc": "python getattribute data member", "code": "def getAttributeData(self, name, channel=None):\n        \"\"\" Returns a attribut \"\"\"\n        return self._getNodeData(name, self._ATTRIBUTENODE, channel)", "code_tokens": "def getAttributeData ( self , name , channel = None ) : return self . _getNodeData ( name , self . _ATTRIBUTENODE , channel )", "docstring_tokens": "Returns a attribut", "label": 0}, {"idx": "cosqa-train-4685", "doc": "dot product between two 1d arrays python and put result in 2d array", "code": "def dot(self, w):\n        \"\"\"Return the dotproduct between self and another vector.\"\"\"\n\n        return sum([x * y for x, y in zip(self, w)])", "code_tokens": "def dot ( self , w ) : return sum ( [ x * y for x , y in zip ( self , w ) ] )", "docstring_tokens": "Return the dotproduct between self and another vector .", "label": 0}, {"idx": "cosqa-train-4686", "doc": "python getlogger not working", "code": "def __getLogger(cls):\n    \"\"\" Get the logger for this object.\n\n    :returns: (Logger) A Logger object.\n    \"\"\"\n    if cls.__logger is None:\n      cls.__logger = opf_utils.initLogger(cls)\n    return cls.__logger", "code_tokens": "def __getLogger ( cls ) : if cls . __logger is None : cls . __logger = opf_utils . initLogger ( cls ) return cls . __logger", "docstring_tokens": "Get the logger for this object .", "label": 0}, {"idx": "cosqa-train-4687", "doc": "dot source eqivalent in python", "code": "def depgraph_to_dotsrc(dep_graph, show_cycles, nodot, reverse):\n    \"\"\"Convert the dependency graph (DepGraph class) to dot source code.\n    \"\"\"\n    if show_cycles:\n        dotsrc = cycles2dot(dep_graph, reverse=reverse)\n    elif not nodot:\n        dotsrc = dep2dot(dep_graph, reverse=reverse)\n    else:\n        dotsrc = None\n    return dotsrc", "code_tokens": "def depgraph_to_dotsrc ( dep_graph , show_cycles , nodot , reverse ) : if show_cycles : dotsrc = cycles2dot ( dep_graph , reverse = reverse ) elif not nodot : dotsrc = dep2dot ( dep_graph , reverse = reverse ) else : dotsrc = None return dotsrc", "docstring_tokens": "Convert the dependency graph ( DepGraph class ) to dot source code .", "label": 0}, {"idx": "cosqa-train-4688", "doc": "python git commit hook", "code": "def commit(self, message=None, amend=False, stage=True):\n        \"\"\"Commit any changes, optionally staging all changes beforehand.\"\"\"\n        return git_commit(self.repo_dir, message=message,\n                          amend=amend, stage=stage)", "code_tokens": "def commit ( self , message = None , amend = False , stage = True ) : return git_commit ( self . repo_dir , message = message , amend = amend , stage = stage )", "docstring_tokens": "Commit any changes optionally staging all changes beforehand .", "label": 0}, {"idx": "cosqa-train-4689", "doc": "draw a histogram of the probability distribution in python", "code": "def plot(self):\n        \"\"\"Plot the empirical histogram versus best-fit distribution's PDF.\"\"\"\n        plt.plot(self.bin_edges, self.hist, self.bin_edges, self.best_pdf)", "code_tokens": "def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )", "docstring_tokens": "Plot the empirical histogram versus best - fit distribution s PDF .", "label": 1}, {"idx": "cosqa-train-4690", "doc": "python give file excute premission", "code": "def chmod_add_excute(filename):\n        \"\"\"\n        Adds execute permission to file.\n        :param filename:\n        :return:\n        \"\"\"\n        st = os.stat(filename)\n        os.chmod(filename, st.st_mode | stat.S_IEXEC)", "code_tokens": "def chmod_add_excute ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "docstring_tokens": "Adds execute permission to file . : param filename : : return :", "label": 1}, {"idx": "cosqa-train-4691", "doc": "draw a horizontal line python graphics", "code": "def hline(self, x, y, width, color):\n        \"\"\"Draw a horizontal line up to a given length.\"\"\"\n        self.rect(x, y, width, 1, color, fill=True)", "code_tokens": "def hline ( self , x , y , width , color ) : self . rect ( x , y , width , 1 , color , fill = True )", "docstring_tokens": "Draw a horizontal line up to a given length .", "label": 0}, {"idx": "cosqa-train-4692", "doc": "python give image buffer", "code": "def get_buffer(self, data_np, header, format, output=None):\n        \"\"\"Get image as a buffer in (format).\n        Format should be 'jpeg', 'png', etc.\n        \"\"\"\n        if not have_pil:\n            raise Exception(\"Install PIL to use this method\")\n        image = PILimage.fromarray(data_np)\n        buf = output\n        if buf is None:\n            buf = BytesIO()\n        image.save(buf, format)\n        return buf", "code_tokens": "def get_buffer ( self , data_np , header , format , output = None ) : if not have_pil : raise Exception ( \"Install PIL to use this method\" ) image = PILimage . fromarray ( data_np ) buf = output if buf is None : buf = BytesIO ( ) image . save ( buf , format ) return buf", "docstring_tokens": "Get image as a buffer in ( format ) . Format should be jpeg png etc .", "label": 0}, {"idx": "cosqa-train-4693", "doc": "drop column in a python data frame", "code": "def del_Unnamed(df):\n    \"\"\"\n    Deletes all the unnamed columns\n\n    :param df: pandas dataframe\n    \"\"\"\n    cols_del=[c for c in df.columns if 'Unnamed' in c]\n    return df.drop(cols_del,axis=1)", "code_tokens": "def del_Unnamed ( df ) : cols_del = [ c for c in df . columns if 'Unnamed' in c ] return df . drop ( cols_del , axis = 1 )", "docstring_tokens": "Deletes all the unnamed columns", "label": 0}, {"idx": "cosqa-train-4694", "doc": "python given number turn into date", "code": "def int_to_date(date):\n    \"\"\"\n    Convert an int of form yyyymmdd to a python date object.\n    \"\"\"\n\n    year = date // 10**4\n    month = date % 10**4 // 10**2\n    day = date % 10**2\n\n    return datetime.date(year, month, day)", "code_tokens": "def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )", "docstring_tokens": "Convert an int of form yyyymmdd to a python date object .", "label": 1}, {"idx": "cosqa-train-4695", "doc": "dynamic 2d array without using builtin functions in python", "code": "def poke_array(self, store, name, elemtype, elements, container, visited, _stack):\n        \"\"\"abstract method\"\"\"\n        raise NotImplementedError", "code_tokens": "def poke_array ( self , store , name , elemtype , elements , container , visited , _stack ) : raise NotImplementedError", "docstring_tokens": "abstract method", "label": 0}, {"idx": "cosqa-train-4696", "doc": "python global variables in def", "code": "def set_global(node: Node, key: str, value: Any):\n    \"\"\"Adds passed value to node's globals\"\"\"\n    node.node_globals[key] = value", "code_tokens": "def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "docstring_tokens": "Adds passed value to node s globals", "label": 1}, {"idx": "cosqa-train-4697", "doc": "dynamic left aligning the text and specifying a width in python", "code": "def wrap(text, width=70, **kwargs):\n    \"\"\"Wrap a single paragraph of text, returning a list of wrapped lines.\n\n    Reformat the single paragraph in 'text' so it fits in lines of no\n    more than 'width' columns, and return a list of wrapped lines.  By\n    default, tabs in 'text' are expanded with string.expandtabs(), and\n    all other whitespace characters (including newline) are converted to\n    space.  See TextWrapper class for available keyword args to customize\n    wrapping behaviour.\n    \"\"\"\n    w = TextWrapper(width=width, **kwargs)\n    return w.wrap(text)", "code_tokens": "def wrap ( text , width = 70 , * * kwargs ) : w = TextWrapper ( width = width , * * kwargs ) return w . wrap ( text )", "docstring_tokens": "Wrap a single paragraph of text returning a list of wrapped lines .", "label": 0}, {"idx": "cosqa-train-4698", "doc": "python grab every n elements", "code": "def split_every(iterable, n):  # TODO: Remove this, or make it return a generator.\n    \"\"\"\n    A generator of n-length chunks of an input iterable\n    \"\"\"\n    i = iter(iterable)\n    piece = list(islice(i, n))\n    while piece:\n        yield piece\n        piece = list(islice(i, n))", "code_tokens": "def split_every ( iterable , n ) : # TODO: Remove this, or make it return a generator. i = iter ( iterable ) piece = list ( islice ( i , n ) ) while piece : yield piece piece = list ( islice ( i , n ) )", "docstring_tokens": "A generator of n - length chunks of an input iterable", "label": 1}, {"idx": "cosqa-train-4699", "doc": "efficient way of removing nan from a python array", "code": "def remove_na_arraylike(arr):\n    \"\"\"\n    Return array-like containing only true/non-NaN values, possibly empty.\n    \"\"\"\n    if is_extension_array_dtype(arr):\n        return arr[notna(arr)]\n    else:\n        return arr[notna(lib.values_from_object(arr))]", "code_tokens": "def remove_na_arraylike ( arr ) : if is_extension_array_dtype ( arr ) : return arr [ notna ( arr ) ] else : return arr [ notna ( lib . values_from_object ( arr ) ) ]", "docstring_tokens": "Return array - like containing only true / non - NaN values possibly empty .", "label": 0}, {"idx": "cosqa-train-4700", "doc": "python groupby multiple keys iterate", "code": "def group_by(iterable, key_func):\n    \"\"\"Wrap itertools.groupby to make life easier.\"\"\"\n    groups = (\n        list(sub) for key, sub in groupby(iterable, key_func)\n    )\n    return zip(groups, groups)", "code_tokens": "def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "docstring_tokens": "Wrap itertools . groupby to make life easier .", "label": 0}, {"idx": "cosqa-train-4701", "doc": "eit request header in python flask", "code": "def get_trace_id_from_flask():\n    \"\"\"Get trace_id from flask request headers.\n\n    :rtype: str\n    :returns: TraceID in HTTP request headers.\n    \"\"\"\n    if flask is None or not flask.request:\n        return None\n\n    header = flask.request.headers.get(_FLASK_TRACE_HEADER)\n\n    if header is None:\n        return None\n\n    trace_id = header.split(\"/\", 1)[0]\n\n    return trace_id", "code_tokens": "def get_trace_id_from_flask ( ) : if flask is None or not flask . request : return None header = flask . request . headers . get ( _FLASK_TRACE_HEADER ) if header is None : return None trace_id = header . split ( \"/\" , 1 ) [ 0 ] return trace_id", "docstring_tokens": "Get trace_id from flask request headers .", "label": 1}, {"idx": "cosqa-train-4702", "doc": "python handle string with forward slash in it", "code": "def norm_slash(name):\n    \"\"\"Normalize path slashes.\"\"\"\n\n    if isinstance(name, str):\n        return name.replace('/', \"\\\\\") if not is_case_sensitive() else name\n    else:\n        return name.replace(b'/', b\"\\\\\") if not is_case_sensitive() else name", "code_tokens": "def norm_slash ( name ) : if isinstance ( name , str ) : return name . replace ( '/' , \"\\\\\" ) if not is_case_sensitive ( ) else name else : return name . replace ( b'/' , b\"\\\\\" ) if not is_case_sensitive ( ) else name", "docstring_tokens": "Normalize path slashes .", "label": 0}, {"idx": "cosqa-train-4703", "doc": "elasticsearch python api scroll", "code": "def scan(client, query=None, scroll='5m', raise_on_error=True,\n         preserve_order=False, size=1000, **kwargs):\n    \"\"\"\n    Simple abstraction on top of the\n    :meth:`~elasticsearch.Elasticsearch.scroll` api - a simple iterator that\n    yields all hits as returned by underlining scroll requests.\n    By default scan does not return results in any pre-determined order. To\n    have a standard order in the returned documents (either by score or\n    explicit sort definition) when scrolling, use ``preserve_order=True``. This\n    may be an expensive operation and will negate the performance benefits of\n    using ``scan``.\n    :arg client: instance of :class:`~elasticsearch.Elasticsearch` to use\n    :arg query: body for the :meth:`~elasticsearch.Elasticsearch.search` api\n    :arg scroll: Specify how long a consistent view of the index should be\n        maintained for scrolled search\n    :arg raise_on_error: raises an exception (``ScanError``) if an error is\n        encountered (some shards fail to execute). By default we raise.\n    :arg preserve_order: don't set the ``search_type`` to ``scan`` - this will\n        cause the scroll to paginate with preserving the order. Note that this\n        can be an extremely expensive operation and can easily lead to\n        unpredictable results, use with caution.\n    :arg size: size (per shard) of the batch send at each iteration.\n    Any additional keyword arguments will be passed to the initial\n    :meth:`~elasticsearch.Elasticsearch.search` call::\n        scan(es,\n            query={\"query\": {\"match\": {\"title\": \"python\"}}},\n            index=\"orders-*\",\n            doc_type=\"books\"\n        )\n    \"\"\"\n    if not preserve_order:\n        kwargs['search_type'] = 'scan'\n    # initial search\n    resp = client.search(body=query, scroll=scroll, size=size, **kwargs)\n\n    scroll_id = resp.get('_scroll_id')\n    if scroll_id is None:\n        return\n\n    first_run = True\n    while True:\n        # if we didn't set search_type to scan initial search contains data\n        if preserve_order and first_run:\n            first_run = False\n        else:\n            resp = client.scroll(scroll_id, scroll=scroll)\n\n        for hit in resp['hits']['hits']:\n            yield hit\n\n        # check if we have any errrors\n        if resp[\"_shards\"][\"failed\"]:\n            logger.warning(\n                'Scroll request has failed on %d shards out of %d.',\n                resp['_shards']['failed'], resp['_shards']['total']\n            )\n            if raise_on_error:\n                raise ScanError(\n                    'Scroll request has failed on %d shards out of %d.' %\n                    (resp['_shards']['failed'], resp['_shards']['total'])\n                )\n\n        scroll_id = resp.get('_scroll_id')\n        # end of scroll\n        if scroll_id is None or not resp['hits']['hits']:\n            break", "code_tokens": "def scan ( client , query = None , scroll = '5m' , raise_on_error = True , preserve_order = False , size = 1000 , * * kwargs ) : if not preserve_order : kwargs [ 'search_type' ] = 'scan' # initial search resp = client . search ( body = query , scroll = scroll , size = size , * * kwargs ) scroll_id = resp . get ( '_scroll_id' ) if scroll_id is None : return first_run = True while True : # if we didn't set search_type to scan initial search contains data if preserve_order and first_run : first_run = False else : resp = client . scroll ( scroll_id , scroll = scroll ) for hit in resp [ 'hits' ] [ 'hits' ] : yield hit # check if we have any errrors if resp [ \"_shards\" ] [ \"failed\" ] : logger . warning ( 'Scroll request has failed on %d shards out of %d.' , resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) if raise_on_error : raise ScanError ( 'Scroll request has failed on %d shards out of %d.' % ( resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) ) scroll_id = resp . get ( '_scroll_id' ) # end of scroll if scroll_id is None or not resp [ 'hits' ] [ 'hits' ] : break", "docstring_tokens": "Simple abstraction on top of the : meth : ~elasticsearch . Elasticsearch . scroll api - a simple iterator that yields all hits as returned by underlining scroll requests . By default scan does not return results in any pre - determined order . To have a standard order in the returned documents ( either by score or explicit sort definition ) when scrolling use preserve_order = True . This may be an expensive operation and will negate the performance benefits of using scan . : arg client : instance of : class : ~elasticsearch . Elasticsearch to use : arg query : body for the : meth : ~elasticsearch . Elasticsearch . search api : arg scroll : Specify how long a consistent view of the index should be maintained for scrolled search : arg raise_on_error : raises an exception ( ScanError ) if an error is encountered ( some shards fail to execute ) . By default we raise . : arg preserve_order : don t set the search_type to scan - this will cause the scroll to paginate with preserving the order . Note that this can be an extremely expensive operation and can easily lead to unpredictable results use with caution . : arg size : size ( per shard ) of the batch send at each iteration . Any additional keyword arguments will be passed to the initial : meth : ~elasticsearch . Elasticsearch . search call :: scan ( es query = { query : { match : { title : python }}} index = orders - * doc_type = books )", "label": 0}, {"idx": "cosqa-train-4704", "doc": "python hangs in git bash", "code": "def check_git():\n    \"\"\"Check if git command is available.\"\"\"\n    try:\n        with open(os.devnull, \"wb\") as devnull:\n            subprocess.check_call([\"git\", \"--version\"], stdout=devnull, stderr=devnull)\n    except:\n        raise RuntimeError(\"Please make sure git is installed and on your path.\")", "code_tokens": "def check_git ( ) : try : with open ( os . devnull , \"wb\" ) as devnull : subprocess . check_call ( [ \"git\" , \"--version\" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( \"Please make sure git is installed and on your path.\" )", "docstring_tokens": "Check if git command is available .", "label": 0}, {"idx": "cosqa-train-4705", "doc": "eliminate duplicates in a list in python", "code": "def remove_duplicates(lst):\n    \"\"\"\n    Emulate what a Python ``set()`` does, but keeping the element's order.\n    \"\"\"\n    dset = set()\n    return [l for l in lst if l not in dset and not dset.add(l)]", "code_tokens": "def remove_duplicates ( lst ) : dset = set ( ) return [ l for l in lst if l not in dset and not dset . add ( l ) ]", "docstring_tokens": "Emulate what a Python set () does but keeping the element s order .", "label": 1}, {"idx": "cosqa-train-4706", "doc": "python hashlib built in", "code": "def double_sha256(data):\n    \"\"\"A standard compound hash.\"\"\"\n    return bytes_as_revhex(hashlib.sha256(hashlib.sha256(data).digest()).digest())", "code_tokens": "def double_sha256 ( data ) : return bytes_as_revhex ( hashlib . sha256 ( hashlib . sha256 ( data ) . digest ( ) ) . digest ( ) )", "docstring_tokens": "A standard compound hash .", "label": 0}, {"idx": "cosqa-train-4707", "doc": "python hdf5 how to see groups", "code": "def _read_group_h5(filename, groupname):\n    \"\"\"Return group content.\n\n    Args:\n        filename (:class:`pathlib.Path`): path of hdf5 file.\n        groupname (str): name of group to read.\n    Returns:\n        :class:`numpy.array`: content of group.\n    \"\"\"\n    with h5py.File(filename, 'r') as h5f:\n        data = h5f[groupname][()]\n    return data", "code_tokens": "def _read_group_h5 ( filename , groupname ) : with h5py . File ( filename , 'r' ) as h5f : data = h5f [ groupname ] [ ( ) ] return data", "docstring_tokens": "Return group content .", "label": 0}, {"idx": "cosqa-train-4708", "doc": "enum python name value", "code": "def Value(self, name):\n    \"\"\"Returns the value coresponding to the given enum name.\"\"\"\n    if name in self._enum_type.values_by_name:\n      return self._enum_type.values_by_name[name].number\n    raise ValueError('Enum %s has no value defined for name %s' % (\n        self._enum_type.name, name))", "code_tokens": "def Value ( self , name ) : if name in self . _enum_type . values_by_name : return self . _enum_type . values_by_name [ name ] . number raise ValueError ( 'Enum %s has no value defined for name %s' % ( self . _enum_type . name , name ) )", "docstring_tokens": "Returns the value coresponding to the given enum name .", "label": 0}, {"idx": "cosqa-train-4709", "doc": "python heappush max heap", "code": "def _heapify_max(x):\n    \"\"\"Transform list into a maxheap, in-place, in O(len(x)) time.\"\"\"\n    n = len(x)\n    for i in reversed(range(n//2)):\n        _siftup_max(x, i)", "code_tokens": "def _heapify_max ( x ) : n = len ( x ) for i in reversed ( range ( n // 2 ) ) : _siftup_max ( x , i )", "docstring_tokens": "Transform list into a maxheap in - place in O ( len ( x )) time .", "label": 1}, {"idx": "cosqa-train-4710", "doc": "eric6 automatic syntax check chang to python2", "code": "def async_comp_check(self, original, loc, tokens):\n        \"\"\"Check for Python 3.6 async comprehension.\"\"\"\n        return self.check_py(\"36\", \"async comprehension\", original, loc, tokens)", "code_tokens": "def async_comp_check ( self , original , loc , tokens ) : return self . check_py ( \"36\" , \"async comprehension\" , original , loc , tokens )", "docstring_tokens": "Check for Python 3 . 6 async comprehension .", "label": 0}, {"idx": "cosqa-train-4711", "doc": "python hhow to see the btye size of a btye arry", "code": "def _size_36():\n    \"\"\" returns the rows, columns of terminal \"\"\"\n    from shutil import get_terminal_size\n    dim = get_terminal_size()\n    if isinstance(dim, list):\n        return dim[0], dim[1]\n    return dim.lines, dim.columns", "code_tokens": "def _size_36 ( ) : from shutil import get_terminal_size dim = get_terminal_size ( ) if isinstance ( dim , list ) : return dim [ 0 ] , dim [ 1 ] return dim . lines , dim . columns", "docstring_tokens": "returns the rows columns of terminal", "label": 0}, {"idx": "cosqa-train-4712", "doc": "example overload str methods python", "code": "def __str__(self):\n        \"\"\"Executes self.function to convert LazyString instance to a real\n        str.\"\"\"\n        if not hasattr(self, '_str'):\n            self._str=self.function(*self.args, **self.kwargs)\n        return self._str", "code_tokens": "def __str__ ( self ) : if not hasattr ( self , '_str' ) : self . _str = self . function ( * self . args , * * self . kwargs ) return self . _str", "docstring_tokens": "Executes self . function to convert LazyString instance to a real str .", "label": 0}, {"idx": "cosqa-train-4713", "doc": "python histogram of oriented gradients overlay on image", "code": "def average_gradient(data, *kwargs):\n    \"\"\" Compute average gradient norm of an image\n    \"\"\"\n    return np.average(np.array(np.gradient(data))**2)", "code_tokens": "def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )", "docstring_tokens": "Compute average gradient norm of an image", "label": 0}, {"idx": "cosqa-train-4714", "doc": "examples of inner join in python", "code": "def merge(left, right, how='inner', key=None, left_key=None, right_key=None,\n          left_as='left', right_as='right'):\n    \"\"\" Performs a join using the union join function. \"\"\"\n    return join(left, right, how, key, left_key, right_key,\n                join_fn=make_union_join(left_as, right_as))", "code_tokens": "def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "docstring_tokens": "Performs a join using the union join function .", "label": 0}, {"idx": "cosqa-train-4715", "doc": "python histogram with custom bin edges", "code": "def _histplot_op(ax, data, **kwargs):\n    \"\"\"Add a histogram for the data to the axes.\"\"\"\n    bins = get_bins(data)\n    ax.hist(data, bins=bins, align=\"left\", density=True, **kwargs)\n    return ax", "code_tokens": "def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "docstring_tokens": "Add a histogram for the data to the axes .", "label": 0}, {"idx": "cosqa-train-4716", "doc": "exclude some tests in coverage python", "code": "def cover(session):\n    \"\"\"Run the final coverage report.\n    This outputs the coverage report aggregating coverage from the unit\n    test runs (not system test runs), and then erases coverage data.\n    \"\"\"\n    session.interpreter = 'python3.6'\n    session.install('coverage', 'pytest-cov')\n    session.run('coverage', 'report', '--show-missing', '--fail-under=100')\n    session.run('coverage', 'erase')", "code_tokens": "def cover ( session ) : session . interpreter = 'python3.6' session . install ( 'coverage' , 'pytest-cov' ) session . run ( 'coverage' , 'report' , '--show-missing' , '--fail-under=100' ) session . run ( 'coverage' , 'erase' )", "docstring_tokens": "Run the final coverage report . This outputs the coverage report aggregating coverage from the unit test runs ( not system test runs ) and then erases coverage data .", "label": 0}, {"idx": "cosqa-train-4717", "doc": "python how do you remove a directory if it is not empty", "code": "def safe_rmtree(directory):\n  \"\"\"Delete a directory if it's present. If it's not present, no-op.\"\"\"\n  if os.path.exists(directory):\n    shutil.rmtree(directory, True)", "code_tokens": "def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )", "docstring_tokens": "Delete a directory if it s present . If it s not present no - op .", "label": 0}, {"idx": "cosqa-train-4718", "doc": "exit is not defined python", "code": "def fail(message=None, exit_status=None):\n    \"\"\"Prints the specified message and exits the program with the specified\n    exit status.\n\n    \"\"\"\n    print('Error:', message, file=sys.stderr)\n    sys.exit(exit_status or 1)", "code_tokens": "def fail ( message = None , exit_status = None ) : print ( 'Error:' , message , file = sys . stderr ) sys . exit ( exit_status or 1 )", "docstring_tokens": "Prints the specified message and exits the program with the specified exit status .", "label": 0}, {"idx": "cosqa-train-4719", "doc": "python how to access a file", "code": "def get_file_string(filepath):\n    \"\"\"Get string from file.\"\"\"\n    with open(os.path.abspath(filepath)) as f:\n        return f.read()", "code_tokens": "def get_file_string ( filepath ) : with open ( os . path . abspath ( filepath ) ) as f : return f . read ( )", "docstring_tokens": "Get string from file .", "label": 0}, {"idx": "cosqa-train-4720", "doc": "extrect dict from list od dict python", "code": "def _from_list_dict(cls, list_dic):\n        \"\"\"Takes a list of dict like objects and uses `champ_id` field as Id\"\"\"\n        return cls({_convert_id(dic[cls.CHAMP_ID]): dict(dic) for dic in list_dic})", "code_tokens": "def _from_list_dict ( cls , list_dic ) : return cls ( { _convert_id ( dic [ cls . CHAMP_ID ] ) : dict ( dic ) for dic in list_dic } )", "docstring_tokens": "Takes a list of dict like objects and uses champ_id field as Id", "label": 0}, {"idx": "cosqa-train-4721", "doc": "python how to access context global", "code": "def export_context(cls, context):\n\t\t\"\"\" Export the specified context to be capable context transferring\n\n\t\t:param context: context to export\n\t\t:return: tuple\n\t\t\"\"\"\n\t\tif context is None:\n\t\t\treturn\n\t\tresult = [(x.context_name(), x.context_value()) for x in context]\n\t\tresult.reverse()\n\t\treturn tuple(result)", "code_tokens": "def export_context ( cls , context ) : if context is None : return result = [ ( x . context_name ( ) , x . context_value ( ) ) for x in context ] result . reverse ( ) return tuple ( result )", "docstring_tokens": "Export the specified context to be capable context transferring", "label": 0}, {"idx": "cosqa-train-4722", "doc": "file name and number of pages for pdf file using python", "code": "def get_filesize(self, pdf):\n        \"\"\"Compute the filesize of the PDF\n        \"\"\"\n        try:\n            filesize = float(pdf.get_size())\n            return filesize / 1024\n        except (POSKeyError, TypeError):\n            return 0", "code_tokens": "def get_filesize ( self , pdf ) : try : filesize = float ( pdf . get_size ( ) ) return filesize / 1024 except ( POSKeyError , TypeError ) : return 0", "docstring_tokens": "Compute the filesize of the PDF", "label": 0}, {"idx": "cosqa-train-4723", "doc": "python how to access environment variable definitions", "code": "def _get_os_environ_dict(keys):\n  \"\"\"Return a dictionary of key/values from os.environ.\"\"\"\n  return {k: os.environ.get(k, _UNDEFINED) for k in keys}", "code_tokens": "def _get_os_environ_dict ( keys ) : return { k : os . environ . get ( k , _UNDEFINED ) for k in keys }", "docstring_tokens": "Return a dictionary of key / values from os . environ .", "label": 0}, {"idx": "cosqa-train-4724", "doc": "file parsing in python definition", "code": "def parse(filename):\n    \"\"\"Parse ASDL from the given file and return a Module node describing it.\"\"\"\n    with open(filename) as f:\n        parser = ASDLParser()\n        return parser.parse(f.read())", "code_tokens": "def parse ( filename ) : with open ( filename ) as f : parser = ASDLParser ( ) return parser . parse ( f . read ( ) )", "docstring_tokens": "Parse ASDL from the given file and return a Module node describing it .", "label": 0}, {"idx": "cosqa-train-4725", "doc": "python how to account for a timeout", "code": "def set_timeout(scope, timeout):\n    \"\"\"\n    Defines the time after which Exscript fails if it does not receive a\n    prompt from the remote host.\n\n    :type  timeout: int\n    :param timeout: The timeout in seconds.\n    \"\"\"\n    conn = scope.get('__connection__')\n    conn.set_timeout(int(timeout[0]))\n    return True", "code_tokens": "def set_timeout ( scope , timeout ) : conn = scope . get ( '__connection__' ) conn . set_timeout ( int ( timeout [ 0 ] ) ) return True", "docstring_tokens": "Defines the time after which Exscript fails if it does not receive a prompt from the remote host .", "label": 0}, {"idx": "cosqa-train-4726", "doc": "file transfer python paramiko ssh", "code": "def send_file(self, local_path, remote_path, user='root', unix_mode=None):\n        \"\"\"Upload a local file on the remote host.\n        \"\"\"\n        self.enable_user(user)\n        return self.ssh_pool.send_file(user, local_path, remote_path, unix_mode=unix_mode)", "code_tokens": "def send_file ( self , local_path , remote_path , user = 'root' , unix_mode = None ) : self . enable_user ( user ) return self . ssh_pool . send_file ( user , local_path , remote_path , unix_mode = unix_mode )", "docstring_tokens": "Upload a local file on the remote host .", "label": 0}, {"idx": "cosqa-train-4727", "doc": "python how to add a line to the middle of a file", "code": "def prepend_line(filepath, line):\n    \"\"\"Rewrite a file adding a line to its beginning.\n    \"\"\"\n    with open(filepath) as f:\n        lines = f.readlines()\n\n    lines.insert(0, line)\n\n    with open(filepath, 'w') as f:\n        f.writelines(lines)", "code_tokens": "def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )", "docstring_tokens": "Rewrite a file adding a line to its beginning .", "label": 0}, {"idx": "cosqa-train-4728", "doc": "fill a 2 dimensional list with inputs python", "code": "def _fill_array_from_list(the_list, the_array):\n        \"\"\"Fill an `array` from a `list`\"\"\"\n        for i, val in enumerate(the_list):\n            the_array[i] = val\n        return the_array", "code_tokens": "def _fill_array_from_list ( the_list , the_array ) : for i , val in enumerate ( the_list ) : the_array [ i ] = val return the_array", "docstring_tokens": "Fill an array from a list", "label": 0}, {"idx": "cosqa-train-4729", "doc": "python how to add attributes to objects", "code": "def assign_to(self, obj):\n    \"\"\"Assign `x` and `y` to an object that has properties `x` and `y`.\"\"\"\n    obj.x = self.x\n    obj.y = self.y", "code_tokens": "def assign_to ( self , obj ) : obj . x = self . x obj . y = self . y", "docstring_tokens": "Assign x and y to an object that has properties x and y .", "label": 0}, {"idx": "cosqa-train-4730", "doc": "filter function in python with none", "code": "def BROADCAST_FILTER_NOT(func):\n        \"\"\"\n        Composes the passed filters into an and-joined filter.\n        \"\"\"\n        return lambda u, command, *args, **kwargs: not func(u, command, *args, **kwargs)", "code_tokens": "def BROADCAST_FILTER_NOT ( func ) : return lambda u , command , * args , * * kwargs : not func ( u , command , * args , * * kwargs )", "docstring_tokens": "Composes the passed filters into an and - joined filter .", "label": 0}, {"idx": "cosqa-train-4731", "doc": "python how to cast string to timestamp with timezone", "code": "def clean_time(time_string):\n    \"\"\"Return a datetime from the Amazon-provided datetime string\"\"\"\n    # Get a timezone-aware datetime object from the string\n    time = dateutil.parser.parse(time_string)\n    if not settings.USE_TZ:\n        # If timezone support is not active, convert the time to UTC and\n        # remove the timezone field\n        time = time.astimezone(timezone.utc).replace(tzinfo=None)\n    return time", "code_tokens": "def clean_time ( time_string ) : # Get a timezone-aware datetime object from the string time = dateutil . parser . parse ( time_string ) if not settings . USE_TZ : # If timezone support is not active, convert the time to UTC and # remove the timezone field time = time . astimezone ( timezone . utc ) . replace ( tzinfo = None ) return time", "docstring_tokens": "Return a datetime from the Amazon - provided datetime string", "label": 0}, {"idx": "cosqa-train-4732", "doc": "filter list based on indice number python", "code": "def filter_list_by_indices(lst, indices):\n    \"\"\"Return a modified list containing only the indices indicated.\n\n    Args:\n        lst: Original list of values\n        indices: List of indices to keep from the original list\n\n    Returns:\n        list: Filtered list of values\n\n    \"\"\"\n    return [x for i, x in enumerate(lst) if i in indices]", "code_tokens": "def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]", "docstring_tokens": "Return a modified list containing only the indices indicated .", "label": 1}, {"idx": "cosqa-train-4733", "doc": "python how to change an object's attributes", "code": "def populate_obj(obj, attrs):\n    \"\"\"Populates an object's attributes using the provided dict\n    \"\"\"\n    for k, v in attrs.iteritems():\n        setattr(obj, k, v)", "code_tokens": "def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "docstring_tokens": "Populates an object s attributes using the provided dict", "label": 0}, {"idx": "cosqa-train-4734", "doc": "filter none in a list python", "code": "def filter_none(list_of_points):\n    \"\"\"\n    \n    :param list_of_points: \n    :return: list_of_points with None's removed\n    \"\"\"\n    remove_elementnone = filter(lambda p: p is not None, list_of_points)\n    remove_sublistnone = filter(lambda p: not contains_none(p), remove_elementnone)\n    return list(remove_sublistnone)", "code_tokens": "def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "docstring_tokens": ": param list_of_points : : return : list_of_points with None s removed", "label": 1}, {"idx": "cosqa-train-4735", "doc": "python how to change an objects properties", "code": "def populate_obj(obj, attrs):\n    \"\"\"Populates an object's attributes using the provided dict\n    \"\"\"\n    for k, v in attrs.iteritems():\n        setattr(obj, k, v)", "code_tokens": "def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "docstring_tokens": "Populates an object s attributes using the provided dict", "label": 0}, {"idx": "cosqa-train-4736", "doc": "filter null values from a data frame python", "code": "def dropna(self, subset=None):\n        \"\"\"Remove missing values according to Baloo's convention.\n\n        Parameters\n        ----------\n        subset : list of str, optional\n            Which columns to check for missing values in.\n\n        Returns\n        -------\n        DataFrame\n            DataFrame with no null values in columns.\n\n        \"\"\"\n        subset = check_and_obtain_subset_columns(subset, self)\n        not_nas = [v.notna() for v in self[subset]._iter()]\n        and_filter = reduce(lambda x, y: x & y, not_nas)\n\n        return self[and_filter]", "code_tokens": "def dropna ( self , subset = None ) : subset = check_and_obtain_subset_columns ( subset , self ) not_nas = [ v . notna ( ) for v in self [ subset ] . _iter ( ) ] and_filter = reduce ( lambda x , y : x & y , not_nas ) return self [ and_filter ]", "docstring_tokens": "Remove missing values according to Baloo s convention .", "label": 0}, {"idx": "cosqa-train-4737", "doc": "python how to change color of text output", "code": "def underline(self, msg):\n        \"\"\"Underline the input\"\"\"\n        return click.style(msg, underline=True) if self.colorize else msg", "code_tokens": "def underline ( self , msg ) : return click . style ( msg , underline = True ) if self . colorize else msg", "docstring_tokens": "Underline the input", "label": 0}, {"idx": "cosqa-train-4738", "doc": "filter |safe jinja python", "code": "def registered_filters_list(self):\n        \"\"\"\n        Return the list of registered filters (as a list of strings).\n\n        The list **only** includes registered filters (**not** the predefined :program:`Jinja2` filters).\n\n        \"\"\"\n        return [filter_name for filter_name in self.__jinja2_environment.filters.keys() if filter_name not in self.__jinja2_predefined_filters ]", "code_tokens": "def registered_filters_list ( self ) : return [ filter_name for filter_name in self . __jinja2_environment . filters . keys ( ) if filter_name not in self . __jinja2_predefined_filters ]", "docstring_tokens": "Return the list of registered filters ( as a list of strings ) .", "label": 0}, {"idx": "cosqa-train-4739", "doc": "python how to change indentation", "code": "def indent(self):\n        \"\"\"\n        Begins an indented block. Must be used in a 'with' code block.\n        All calls to the logger inside of the block will be indented.\n        \"\"\"\n        blk = IndentBlock(self, self._indent)\n        self._indent += 1\n        return blk", "code_tokens": "def indent ( self ) : blk = IndentBlock ( self , self . _indent ) self . _indent += 1 return blk", "docstring_tokens": "Begins an indented block . Must be used in a with code block . All calls to the logger inside of the block will be indented .", "label": 0}, {"idx": "cosqa-train-4740", "doc": "finding average color value in python", "code": "def get_average_color(colors):\n    \"\"\"Calculate the average color from the list of colors, where each color\n    is a 3-tuple of (r, g, b) values.\n    \"\"\"\n    c = reduce(color_reducer, colors)\n    total = len(colors)\n    return tuple(v / total for v in c)", "code_tokens": "def get_average_color ( colors ) : c = reduce ( color_reducer , colors ) total = len ( colors ) return tuple ( v / total for v in c )", "docstring_tokens": "Calculate the average color from the list of colors where each color is a 3 - tuple of ( r g b ) values .", "label": 1}, {"idx": "cosqa-train-4741", "doc": "python how to check if a file does not exist", "code": "def is_valid_file(parser, arg):\n    \"\"\"Check if arg is a valid file that already exists on the file system.\"\"\"\n    arg = os.path.abspath(arg)\n    if not os.path.exists(arg):\n        parser.error(\"The file %s does not exist!\" % arg)\n    else:\n        return arg", "code_tokens": "def is_valid_file ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . exists ( arg ) : parser . error ( \"The file %s does not exist!\" % arg ) else : return arg", "docstring_tokens": "Check if arg is a valid file that already exists on the file system .", "label": 0}, {"idx": "cosqa-train-4742", "doc": "finding first 10 nearest values using shapely in python", "code": "def index_nearest(value, array):\n    \"\"\"\n    expects a _n.array\n    returns the global minimum of (value-array)^2\n    \"\"\"\n\n    a = (array-value)**2\n    return index(a.min(), a)", "code_tokens": "def index_nearest ( value , array ) : a = ( array - value ) ** 2 return index ( a . min ( ) , a )", "docstring_tokens": "expects a _n . array returns the global minimum of ( value - array ) ^2", "label": 0}, {"idx": "cosqa-train-4743", "doc": "python how to check if an account exists", "code": "def user_exists(username):\n    \"\"\"Check if a user exists\"\"\"\n    try:\n        pwd.getpwnam(username)\n        user_exists = True\n    except KeyError:\n        user_exists = False\n    return user_exists", "code_tokens": "def user_exists ( username ) : try : pwd . getpwnam ( username ) user_exists = True except KeyError : user_exists = False return user_exists", "docstring_tokens": "Check if a user exists", "label": 1}, {"idx": "cosqa-train-4744", "doc": "finding index of an element in a matrix using python", "code": "def bisect_index(a, x):\n    \"\"\" Find the leftmost index of an element in a list using binary search.\n\n    Parameters\n    ----------\n    a: list\n        A sorted list.\n    x: arbitrary\n        The element.\n\n    Returns\n    -------\n    int\n        The index.\n\n    \"\"\"\n    i = bisect.bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    raise ValueError", "code_tokens": "def bisect_index ( a , x ) : i = bisect . bisect_left ( a , x ) if i != len ( a ) and a [ i ] == x : return i raise ValueError", "docstring_tokens": "Find the leftmost index of an element in a list using binary search .", "label": 0}, {"idx": "cosqa-train-4745", "doc": "python how to check if date is not datetime", "code": "def is_date(thing):\n    \"\"\"Checks if the given thing represents a date\n\n    :param thing: The object to check if it is a date\n    :type thing: arbitrary object\n    :returns: True if we have a date object\n    :rtype: bool\n    \"\"\"\n    # known date types\n    date_types = (datetime.datetime,\n                  datetime.date,\n                  DateTime)\n    return isinstance(thing, date_types)", "code_tokens": "def is_date ( thing ) : # known date types date_types = ( datetime . datetime , datetime . date , DateTime ) return isinstance ( thing , date_types )", "docstring_tokens": "Checks if the given thing represents a date", "label": 0}, {"idx": "cosqa-train-4746", "doc": "finding max value in an array python", "code": "def findMax(arr):\n    \"\"\"\n    in comparison to argrelmax() more simple and  reliable peak finder\n    \"\"\"\n    out = np.zeros(shape=arr.shape, dtype=bool)\n    _calcMax(arr, out)\n    return out", "code_tokens": "def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out", "docstring_tokens": "in comparison to argrelmax () more simple and reliable peak finder", "label": 0}, {"idx": "cosqa-train-4747", "doc": "python how to check if path is a file", "code": "def is_file(path):\n    \"\"\"Determine if a Path or string is a file on the file system.\"\"\"\n    try:\n        return path.expanduser().absolute().is_file()\n    except AttributeError:\n        return os.path.isfile(os.path.abspath(os.path.expanduser(str(path))))", "code_tokens": "def is_file ( path ) : try : return path . expanduser ( ) . absolute ( ) . is_file ( ) except AttributeError : return os . path . isfile ( os . path . abspath ( os . path . expanduser ( str ( path ) ) ) )", "docstring_tokens": "Determine if a Path or string is a file on the file system .", "label": 1}, {"idx": "cosqa-train-4748", "doc": "finding the attribute of an object in python", "code": "def get_member(thing_obj, member_string):\n    \"\"\"Get a member from an object by (string) name\"\"\"\n    mems = {x[0]: x[1] for x in inspect.getmembers(thing_obj)}\n    if member_string in mems:\n        return mems[member_string]", "code_tokens": "def get_member ( thing_obj , member_string ) : mems = { x [ 0 ] : x [ 1 ] for x in inspect . getmembers ( thing_obj ) } if member_string in mems : return mems [ member_string ]", "docstring_tokens": "Get a member from an object by ( string ) name", "label": 0}, {"idx": "cosqa-train-4749", "doc": "python how to check internet connection", "code": "def _internet_on(address):\n    \"\"\"\n    Check to see if the internet is on by pinging a set address.\n    :param address: the IP or address to hit\n    :return: a boolean - true if can be reached, false if not.\n    \"\"\"\n    try:\n        urllib2.urlopen(address, timeout=1)\n        return True\n    except urllib2.URLError as err:\n        return False", "code_tokens": "def _internet_on ( address ) : try : urllib2 . urlopen ( address , timeout = 1 ) return True except urllib2 . URLError as err : return False", "docstring_tokens": "Check to see if the internet is on by pinging a set address . : param address : the IP or address to hit : return : a boolean - true if can be reached false if not .", "label": 1}, {"idx": "cosqa-train-4750", "doc": "finding the number of common characters in 2 string python", "code": "def count_string_diff(a,b):\n    \"\"\"Return the number of characters in two strings that don't exactly match\"\"\"\n    shortest = min(len(a), len(b))\n    return sum(a[i] != b[i] for i in range(shortest))", "code_tokens": "def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )", "docstring_tokens": "Return the number of characters in two strings that don t exactly match", "label": 0}, {"idx": "cosqa-train-4751", "doc": "finding the number of weeks between two datas in python", "code": "def get_months_apart(d1, d2):\n    \"\"\"\n    Get amount of months between dates\n    http://stackoverflow.com/a/4040338\n    \"\"\"\n\n    return (d1.year - d2.year)*12 + d1.month - d2.month", "code_tokens": "def get_months_apart ( d1 , d2 ) : return ( d1 . year - d2 . year ) * 12 + d1 . month - d2 . month", "docstring_tokens": "Get amount of months between dates http : // stackoverflow . com / a / 4040338", "label": 0}, {"idx": "cosqa-train-4752", "doc": "python how to compute the range of an array", "code": "def _interval_to_bound_points(array):\n    \"\"\"\n    Helper function which returns an array\n    with the Intervals' boundaries.\n    \"\"\"\n\n    array_boundaries = np.array([x.left for x in array])\n    array_boundaries = np.concatenate(\n        (array_boundaries, np.array([array[-1].right])))\n\n    return array_boundaries", "code_tokens": "def _interval_to_bound_points ( array ) : array_boundaries = np . array ( [ x . left for x in array ] ) array_boundaries = np . concatenate ( ( array_boundaries , np . array ( [ array [ - 1 ] . right ] ) ) ) return array_boundaries", "docstring_tokens": "Helper function which returns an array with the Intervals boundaries .", "label": 1}, {"idx": "cosqa-train-4753", "doc": "finding the type in python", "code": "def is_builtin_type(tp):\n    \"\"\"Checks if the given type is a builtin one.\n    \"\"\"\n    return hasattr(__builtins__, tp.__name__) and tp is getattr(__builtins__, tp.__name__)", "code_tokens": "def is_builtin_type ( tp ) : return hasattr ( __builtins__ , tp . __name__ ) and tp is getattr ( __builtins__ , tp . __name__ )", "docstring_tokens": "Checks if the given type is a builtin one .", "label": 0}, {"idx": "cosqa-train-4754", "doc": "python how to create a bmp from byte data", "code": "def from_bytes(cls, b):\n\t\t\"\"\"Create :class:`PNG` from raw bytes.\n\t\t\n\t\t:arg bytes b: The raw bytes of the PNG file.\n\t\t:rtype: :class:`PNG`\n\t\t\"\"\"\n\t\tim = cls()\n\t\tim.chunks = list(parse_chunks(b))\n\t\tim.init()\n\t\treturn im", "code_tokens": "def from_bytes ( cls , b ) : im = cls ( ) im . chunks = list ( parse_chunks ( b ) ) im . init ( ) return im", "docstring_tokens": "Create : class : PNG from raw bytes . : arg bytes b : The raw bytes of the PNG file . : rtype : : class : PNG", "label": 0}, {"idx": "cosqa-train-4755", "doc": "fish shell python encoding", "code": "def getdefaultencoding():\n    \"\"\"Return IPython's guess for the default encoding for bytes as text.\n\n    Asks for stdin.encoding first, to match the calling Terminal, but that\n    is often None for subprocesses.  Fall back on locale.getpreferredencoding()\n    which should be a sensible platform default (that respects LANG environment),\n    and finally to sys.getdefaultencoding() which is the most conservative option,\n    and usually ASCII.\n    \"\"\"\n    enc = get_stream_enc(sys.stdin)\n    if not enc or enc=='ascii':\n        try:\n            # There are reports of getpreferredencoding raising errors\n            # in some cases, which may well be fixed, but let's be conservative here.\n            enc = locale.getpreferredencoding()\n        except Exception:\n            pass\n    return enc or sys.getdefaultencoding()", "code_tokens": "def getdefaultencoding ( ) : enc = get_stream_enc ( sys . stdin ) if not enc or enc == 'ascii' : try : # There are reports of getpreferredencoding raising errors # in some cases, which may well be fixed, but let's be conservative here. enc = locale . getpreferredencoding ( ) except Exception : pass return enc or sys . getdefaultencoding ( )", "docstring_tokens": "Return IPython s guess for the default encoding for bytes as text .", "label": 1}, {"idx": "cosqa-train-4756", "doc": "python how to cut a float off to two decimal places", "code": "def _saferound(value, decimal_places):\n    \"\"\"\n    Rounds a float value off to the desired precision\n    \"\"\"\n    try:\n        f = float(value)\n    except ValueError:\n        return ''\n    format = '%%.%df' % decimal_places\n    return format % f", "code_tokens": "def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f", "docstring_tokens": "Rounds a float value off to the desired precision", "label": 0}, {"idx": "cosqa-train-4757", "doc": "fit a gaussian to a peak in python", "code": "def Gaussian(x, a, x0, sigma, y0):\n    \"\"\"Gaussian peak\n\n    Inputs:\n    -------\n        ``x``: independent variable\n        ``a``: scaling factor (extremal value)\n        ``x0``: center\n        ``sigma``: half width at half maximum\n        ``y0``: additive constant\n\n    Formula:\n    --------\n        ``a*exp(-(x-x0)^2)/(2*sigma^2)+y0``\n    \"\"\"\n    return a * np.exp(-(x - x0) ** 2 / (2 * sigma ** 2)) + y0", "code_tokens": "def Gaussian ( x , a , x0 , sigma , y0 ) : return a * np . exp ( - ( x - x0 ) ** 2 / ( 2 * sigma ** 2 ) ) + y0", "docstring_tokens": "Gaussian peak", "label": 0}, {"idx": "cosqa-train-4758", "doc": "python how to define static path", "code": "def glr_path_static():\n    \"\"\"Returns path to packaged static files\"\"\"\n    return os.path.abspath(os.path.join(os.path.dirname(__file__), '_static'))", "code_tokens": "def glr_path_static ( ) : return os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '_static' ) )", "docstring_tokens": "Returns path to packaged static files", "label": 1}, {"idx": "cosqa-train-4759", "doc": "fixed value in slider widget python", "code": "def _increment(self, *args):\n        \"\"\"Move the slider only by increment given by resolution.\"\"\"\n        value = self._var.get()\n        if self._resolution:\n            value = self._start + int(round((value - self._start) / self._resolution)) * self._resolution\n            self._var.set(value)\n        self.display_value(value)", "code_tokens": "def _increment ( self , * args ) : value = self . _var . get ( ) if self . _resolution : value = self . _start + int ( round ( ( value - self . _start ) / self . _resolution ) ) * self . _resolution self . _var . set ( value ) self . display_value ( value )", "docstring_tokens": "Move the slider only by increment given by resolution .", "label": 0}, {"idx": "cosqa-train-4760", "doc": "python how to delete canvas", "code": "def clear(self):\n        \"\"\"Clear the displayed image.\"\"\"\n        self._imgobj = None\n        try:\n            # See if there is an image on the canvas\n            self.canvas.delete_object_by_tag(self._canvas_img_tag)\n            self.redraw()\n        except KeyError:\n            pass", "code_tokens": "def clear ( self ) : self . _imgobj = None try : # See if there is an image on the canvas self . canvas . delete_object_by_tag ( self . _canvas_img_tag ) self . redraw ( ) except KeyError : pass", "docstring_tokens": "Clear the displayed image .", "label": 1}, {"idx": "cosqa-train-4761", "doc": "flask python jinja2 default variables", "code": "def render_template(env, filename, values=None):\n    \"\"\"\n    Render a jinja template\n    \"\"\"\n    if not values:\n        values = {}\n    tmpl = env.get_template(filename)\n    return tmpl.render(values)", "code_tokens": "def render_template ( env , filename , values = None ) : if not values : values = { } tmpl = env . get_template ( filename ) return tmpl . render ( values )", "docstring_tokens": "Render a jinja template", "label": 0}, {"idx": "cosqa-train-4762", "doc": "python how to detect change in slope", "code": "def click_estimate_slope():\n    \"\"\"\n    Takes two clicks and returns the slope.\n\n    Right-click aborts.\n    \"\"\"\n\n    c1 = _pylab.ginput()\n    if len(c1)==0:\n        return None\n\n    c2 = _pylab.ginput()\n    if len(c2)==0:\n        return None\n\n    return (c1[0][1]-c2[0][1])/(c1[0][0]-c2[0][0])", "code_tokens": "def click_estimate_slope ( ) : c1 = _pylab . ginput ( ) if len ( c1 ) == 0 : return None c2 = _pylab . ginput ( ) if len ( c2 ) == 0 : return None return ( c1 [ 0 ] [ 1 ] - c2 [ 0 ] [ 1 ] ) / ( c1 [ 0 ] [ 0 ] - c2 [ 0 ] [ 0 ] )", "docstring_tokens": "Takes two clicks and returns the slope .", "label": 0}, {"idx": "cosqa-train-4763", "doc": "flatten 3d array python", "code": "def make_2d(ary):\n    \"\"\"Convert any array into a 2d numpy array.\n\n    In case the array is already more than 2 dimensional, will ravel the\n    dimensions after the first.\n    \"\"\"\n    dim_0, *_ = np.atleast_1d(ary).shape\n    return ary.reshape(dim_0, -1, order=\"F\")", "code_tokens": "def make_2d ( ary ) : dim_0 ,  * _ = np . atleast_1d ( ary ) . shape return ary . reshape ( dim_0 , - 1 , order = \"F\" )", "docstring_tokens": "Convert any array into a 2d numpy array .", "label": 0}, {"idx": "cosqa-train-4764", "doc": "python how to determine if an iterable is iterable", "code": "def _is_iterable(item):\n    \"\"\" Checks if an item is iterable (list, tuple, generator), but not string \"\"\"\n    return isinstance(item, collections.Iterable) and not isinstance(item, six.string_types)", "code_tokens": "def _is_iterable ( item ) : return isinstance ( item , collections . Iterable ) and not isinstance ( item , six . string_types )", "docstring_tokens": "Checks if an item is iterable ( list tuple generator ) but not string", "label": 1}, {"idx": "cosqa-train-4765", "doc": "flatten a python list", "code": "def flatten(l):\n    \"\"\"Flatten a nested list.\"\"\"\n    return sum(map(flatten, l), []) \\\n        if isinstance(l, list) or isinstance(l, tuple) else [l]", "code_tokens": "def flatten ( l ) : return sum ( map ( flatten , l ) , [ ] ) if isinstance ( l , list ) or isinstance ( l , tuple ) else [ l ]", "docstring_tokens": "Flatten a nested list .", "label": 0}, {"idx": "cosqa-train-4766", "doc": "python how to determineif path is executable", "code": "def is_executable(path):\n  \"\"\"Returns whether a path names an existing executable file.\"\"\"\n  return os.path.isfile(path) and os.access(path, os.X_OK)", "code_tokens": "def is_executable ( path ) : return os . path . isfile ( path ) and os . access ( path , os . X_OK )", "docstring_tokens": "Returns whether a path names an existing executable file .", "label": 0}, {"idx": "cosqa-train-4767", "doc": "flip an array left to right python", "code": "def imflip(img, direction='horizontal'):\n    \"\"\"Flip an image horizontally or vertically.\n\n    Args:\n        img (ndarray): Image to be flipped.\n        direction (str): The flip direction, either \"horizontal\" or \"vertical\".\n\n    Returns:\n        ndarray: The flipped image.\n    \"\"\"\n    assert direction in ['horizontal', 'vertical']\n    if direction == 'horizontal':\n        return np.flip(img, axis=1)\n    else:\n        return np.flip(img, axis=0)", "code_tokens": "def imflip ( img , direction = 'horizontal' ) : assert direction in [ 'horizontal' , 'vertical' ] if direction == 'horizontal' : return np . flip ( img , axis = 1 ) else : return np . flip ( img , axis = 0 )", "docstring_tokens": "Flip an image horizontally or vertically .", "label": 1}, {"idx": "cosqa-train-4768", "doc": "python how to enter things into a dictionary", "code": "def conv_dict(self):\n        \"\"\"dictionary of conversion\"\"\"\n        return dict(integer=self.integer, real=self.real, no_type=self.no_type)", "code_tokens": "def conv_dict ( self ) : return dict ( integer = self . integer , real = self . real , no_type = self . no_type )", "docstring_tokens": "dictionary of conversion", "label": 1}, {"idx": "cosqa-train-4769", "doc": "flip an image horizontally python 3", "code": "def hflip(img):\n    \"\"\"Horizontally flip the given PIL Image.\n\n    Args:\n        img (PIL Image): Image to be flipped.\n\n    Returns:\n        PIL Image:  Horizontall flipped image.\n    \"\"\"\n    if not _is_pil_image(img):\n        raise TypeError('img should be PIL Image. Got {}'.format(type(img)))\n\n    return img.transpose(Image.FLIP_LEFT_RIGHT)", "code_tokens": "def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )", "docstring_tokens": "Horizontally flip the given PIL Image .", "label": 0}, {"idx": "cosqa-train-4770", "doc": "python how to except a keyboard interrupt", "code": "def run (self):\n        \"\"\"Handle keyboard interrupt and other errors.\"\"\"\n        try:\n            self.run_checked()\n        except KeyboardInterrupt:\n            thread.interrupt_main()\n        except Exception:\n            self.internal_error()", "code_tokens": "def run ( self ) : try : self . run_checked ( ) except KeyboardInterrupt : thread . interrupt_main ( ) except Exception : self . internal_error ( )", "docstring_tokens": "Handle keyboard interrupt and other errors .", "label": 0}, {"idx": "cosqa-train-4771", "doc": "flip an image python", "code": "def hflip(img):\n    \"\"\"Horizontally flip the given PIL Image.\n\n    Args:\n        img (PIL Image): Image to be flipped.\n\n    Returns:\n        PIL Image:  Horizontall flipped image.\n    \"\"\"\n    if not _is_pil_image(img):\n        raise TypeError('img should be PIL Image. Got {}'.format(type(img)))\n\n    return img.transpose(Image.FLIP_LEFT_RIGHT)", "code_tokens": "def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )", "docstring_tokens": "Horizontally flip the given PIL Image .", "label": 0}, {"idx": "cosqa-train-4772", "doc": "python how to execute ansible playbook by ansible api", "code": "def callPlaybook(self, playbook, ansibleArgs, wait=True, tags=[\"all\"]):\n        \"\"\"\n        Run a playbook.\n\n        :param playbook: An Ansible playbook to run.\n        :param ansibleArgs: Arguments to pass to the playbook.\n        :param wait: Wait for the play to finish if true.\n        :param tags: Control tags for the play.\n        \"\"\"\n        playbook = os.path.join(self.playbooks, playbook)  # Path to playbook being executed\n        verbosity = \"-vvvvv\" if logger.isEnabledFor(logging.DEBUG) else \"-v\"\n        command = [\"ansible-playbook\", verbosity, \"--tags\", \",\".join(tags), \"--extra-vars\"]\n        command.append(\" \".join([\"=\".join(i) for i in ansibleArgs.items()]))  # Arguments being passed to playbook\n        command.append(playbook)\n\n        logger.debug(\"Executing Ansible call `%s`\", \" \".join(command))\n        p = subprocess.Popen(command)\n        if wait:\n            p.communicate()\n            if p.returncode != 0:\n                # FIXME: parse error codes\n                raise RuntimeError(\"Ansible reported an error when executing playbook %s\" % playbook)", "code_tokens": "def callPlaybook ( self , playbook , ansibleArgs , wait = True , tags = [ \"all\" ] ) : playbook = os . path . join ( self . playbooks , playbook ) # Path to playbook being executed verbosity = \"-vvvvv\" if logger . isEnabledFor ( logging . DEBUG ) else \"-v\" command = [ \"ansible-playbook\" , verbosity , \"--tags\" , \",\" . join ( tags ) , \"--extra-vars\" ] command . append ( \" \" . join ( [ \"=\" . join ( i ) for i in ansibleArgs . items ( ) ] ) ) # Arguments being passed to playbook command . append ( playbook ) logger . debug ( \"Executing Ansible call `%s`\" , \" \" . join ( command ) ) p = subprocess . Popen ( command ) if wait : p . communicate ( ) if p . returncode != 0 : # FIXME: parse error codes raise RuntimeError ( \"Ansible reported an error when executing playbook %s\" % playbook )", "docstring_tokens": "Run a playbook .", "label": 1}, {"idx": "cosqa-train-4773", "doc": "python how to exit all threads", "code": "def wait_until_exit(self):\n        \"\"\" Wait until all the threads are finished.\n\n        \"\"\"\n        [t.join() for t in self.threads]\n\n        self.threads = list()", "code_tokens": "def wait_until_exit ( self ) : [ t . join ( ) for t in self . threads ] self . threads = list ( )", "docstring_tokens": "Wait until all the threads are finished .", "label": 0}, {"idx": "cosqa-train-4774", "doc": "flushing a file in python", "code": "def file_writelines_flush_sync(path, lines):\n    \"\"\"\n    Fill file at @path with @lines then flush all buffers\n    (Python and system buffers)\n    \"\"\"\n    fp = open(path, 'w')\n    try:\n        fp.writelines(lines)\n        flush_sync_file_object(fp)\n    finally:\n        fp.close()", "code_tokens": "def file_writelines_flush_sync ( path , lines ) : fp = open ( path , 'w' ) try : fp . writelines ( lines ) flush_sync_file_object ( fp ) finally : fp . close ( )", "docstring_tokens": "Fill file at", "label": 0}, {"idx": "cosqa-train-4775", "doc": "python how to ftp a file to another server", "code": "def _send_file(self, filename):\n        \"\"\"\n        Sends a file via FTP.\n        \"\"\"\n        # pylint: disable=E1101\n        ftp = ftplib.FTP(host=self.host)\n        ftp.login(user=self.user, passwd=self.password)\n        ftp.set_pasv(True)\n        ftp.storbinary(\"STOR %s\" % os.path.basename(filename),\n            file(filename, 'rb'))", "code_tokens": "def _send_file ( self , filename ) : # pylint: disable=E1101 ftp = ftplib . FTP ( host = self . host ) ftp . login ( user = self . user , passwd = self . password ) ftp . set_pasv ( True ) ftp . storbinary ( \"STOR %s\" % os . path . basename ( filename ) , file ( filename , 'rb' ) )", "docstring_tokens": "Sends a file via FTP .", "label": 0}, {"idx": "cosqa-train-4776", "doc": "forcing python garbage collector", "code": "def cleanup_storage(*args):\n    \"\"\"Clean up processes after SIGTERM or SIGINT is received.\"\"\"\n    ShardedClusters().cleanup()\n    ReplicaSets().cleanup()\n    Servers().cleanup()\n    sys.exit(0)", "code_tokens": "def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )", "docstring_tokens": "Clean up processes after SIGTERM or SIGINT is received .", "label": 0}, {"idx": "cosqa-train-4777", "doc": "python how to get a csrf token from a response object", "code": "def get_csrf_token(response):\n    \"\"\"\n    Extract the CSRF token out of the \"Set-Cookie\" header of a response.\n    \"\"\"\n    cookie_headers = [\n        h.decode('ascii') for h in response.headers.getlist(\"Set-Cookie\")\n    ]\n    if not cookie_headers:\n        return None\n    csrf_headers = [\n        h for h in cookie_headers if h.startswith(\"csrftoken=\")\n    ]\n    if not csrf_headers:\n        return None\n    match = re.match(\"csrftoken=([^ ;]+);\", csrf_headers[-1])\n    return match.group(1)", "code_tokens": "def get_csrf_token ( response ) : cookie_headers = [ h . decode ( 'ascii' ) for h in response . headers . getlist ( \"Set-Cookie\" ) ] if not cookie_headers : return None csrf_headers = [ h for h in cookie_headers if h . startswith ( \"csrftoken=\" ) ] if not csrf_headers : return None match = re . match ( \"csrftoken=([^ ;]+);\" , csrf_headers [ - 1 ] ) return match . group ( 1 )", "docstring_tokens": "Extract the CSRF token out of the Set - Cookie header of a response .", "label": 1}, {"idx": "cosqa-train-4778", "doc": "format function in python stackoverflow", "code": "def exception_format():\n    \"\"\"\n    Convert exception info into a string suitable for display.\n    \"\"\"\n    return \"\".join(traceback.format_exception(\n        sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]\n    ))", "code_tokens": "def exception_format ( ) : return \"\" . join ( traceback . format_exception ( sys . exc_info ( ) [ 0 ] , sys . exc_info ( ) [ 1 ] , sys . exc_info ( ) [ 2 ] ) )", "docstring_tokens": "Convert exception info into a string suitable for display .", "label": 0}, {"idx": "cosqa-train-4779", "doc": "python how to get the ttl", "code": "def ttl(self):\n        \"\"\"how long you should cache results for cacheable queries\"\"\"\n        ret = 3600\n        cn = self.get_process()\n        if \"ttl\" in cn:\n            ret = cn[\"ttl\"]\n        return ret", "code_tokens": "def ttl ( self ) : ret = 3600 cn = self . get_process ( ) if \"ttl\" in cn : ret = cn [ \"ttl\" ] return ret", "docstring_tokens": "how long you should cache results for cacheable queries", "label": 0}, {"idx": "cosqa-train-4780", "doc": "found int expecting tuple python", "code": "def version_triple(tag):\n    \"\"\"\n    returns: a triple of integers from a version tag\n    \"\"\"\n    groups = re.match(r'v?(\\d+)\\.(\\d+)\\.(\\d+)', tag).groups()\n    return tuple(int(n) for n in groups)", "code_tokens": "def version_triple ( tag ) : groups = re . match ( r'v?(\\d+)\\.(\\d+)\\.(\\d+)' , tag ) . groups ( ) return tuple ( int ( n ) for n in groups )", "docstring_tokens": "returns : a triple of integers from a version tag", "label": 0}, {"idx": "cosqa-train-4781", "doc": "python how to get the turtles to move at the same time", "code": "def move_back(self, dt):\n        \"\"\" If called after an update, the sprite can move back\n        \"\"\"\n        self._position = self._old_position\n        self.rect.topleft = self._position\n        self.feet.midbottom = self.rect.midbottom", "code_tokens": "def move_back ( self , dt ) : self . _position = self . _old_position self . rect . topleft = self . _position self . feet . midbottom = self . rect . midbottom", "docstring_tokens": "If called after an update the sprite can move back", "label": 0}, {"idx": "cosqa-train-4782", "doc": "frequency of words count in a sentence python", "code": "def count(lines):\n  \"\"\" Counts the word frequences in a list of sentences.\n\n  Note:\n    This is a helper function for parallel execution of `Vocabulary.from_text`\n    method.\n  \"\"\"\n  words = [w for l in lines for w in l.strip().split()]\n  return Counter(words)", "code_tokens": "def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )", "docstring_tokens": "Counts the word frequences in a list of sentences .", "label": 0}, {"idx": "cosqa-train-4783", "doc": "python how to handle an empty numpyarray", "code": "def is_empty(self):\n        \"\"\"Checks for an empty image.\n        \"\"\"\n        if(((self.channels == []) and (not self.shape == (0, 0))) or\n           ((not self.channels == []) and (self.shape == (0, 0)))):\n            raise RuntimeError(\"Channels-shape mismatch.\")\n        return self.channels == [] and self.shape == (0, 0)", "code_tokens": "def is_empty ( self ) : if ( ( ( self . channels == [ ] ) and ( not self . shape == ( 0 , 0 ) ) ) or ( ( not self . channels == [ ] ) and ( self . shape == ( 0 , 0 ) ) ) ) : raise RuntimeError ( \"Channels-shape mismatch.\" ) return self . channels == [ ] and self . shape == ( 0 , 0 )", "docstring_tokens": "Checks for an empty image .", "label": 1}, {"idx": "cosqa-train-4784", "doc": "function for random sixed rectangles in python", "code": "def from_rectangle(box):\n        \"\"\" Create a vector randomly within the given rectangle. \"\"\"\n        x = box.left + box.width * random.uniform(0, 1)\n        y = box.bottom + box.height * random.uniform(0, 1)\n        return Vector(x, y)", "code_tokens": "def from_rectangle ( box ) : x = box . left + box . width * random . uniform ( 0 , 1 ) y = box . bottom + box . height * random . uniform ( 0 , 1 ) return Vector ( x , y )", "docstring_tokens": "Create a vector randomly within the given rectangle .", "label": 0}, {"idx": "cosqa-train-4785", "doc": "function that returns key given a value in dictionary python", "code": "def get_key_by_value(dictionary, search_value):\n    \"\"\"\n    searchs a value in a dicionary and returns the key of the first occurrence\n\n    :param dictionary: dictionary to search in\n    :param search_value: value to search for\n    \"\"\"\n    for key, value in dictionary.iteritems():\n        if value == search_value:\n            return ugettext(key)", "code_tokens": "def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )", "docstring_tokens": "searchs a value in a dicionary and returns the key of the first occurrence", "label": 0}, {"idx": "cosqa-train-4786", "doc": "python how to load h5ad", "code": "def h5ToDict(h5, readH5pyDataset=True):\n    \"\"\" Read a hdf5 file into a dictionary \"\"\"\n    h = h5py.File(h5, \"r\")\n    ret = unwrapArray(h, recursive=True, readH5pyDataset=readH5pyDataset)\n    if readH5pyDataset: h.close()\n    return ret", "code_tokens": "def h5ToDict ( h5 , readH5pyDataset = True ) : h = h5py . File ( h5 , \"r\" ) ret = unwrapArray ( h , recursive = True , readH5pyDataset = readH5pyDataset ) if readH5pyDataset : h . close ( ) return ret", "docstring_tokens": "Read a hdf5 file into a dictionary", "label": 0}, {"idx": "cosqa-train-4787", "doc": "function to repeat string in python", "code": "def insert_slash(string, every=2):\n    \"\"\"insert_slash insert / every 2 char\"\"\"\n    return os.path.join(string[i:i+every] for i in xrange(0, len(string), every))", "code_tokens": "def insert_slash ( string , every = 2 ) : return os . path . join ( string [ i : i + every ] for i in xrange ( 0 , len ( string ) , every ) )", "docstring_tokens": "insert_slash insert / every 2 char", "label": 0}, {"idx": "cosqa-train-4788", "doc": "python how to make a conditional to check for string", "code": "def is_valid_variable_name(string_to_check):\n    \"\"\"\n    Returns whether the provided name is a valid variable name in Python\n\n    :param string_to_check: the string to be checked\n    :return: True or False\n    \"\"\"\n\n    try:\n\n        parse('{} = None'.format(string_to_check))\n        return True\n\n    except (SyntaxError, ValueError, TypeError):\n\n        return False", "code_tokens": "def is_valid_variable_name ( string_to_check ) : try : parse ( '{} = None' . format ( string_to_check ) ) return True except ( SyntaxError , ValueError , TypeError ) : return False", "docstring_tokens": "Returns whether the provided name is a valid variable name in Python", "label": 1}, {"idx": "cosqa-train-4789", "doc": "gaussian distribution with python", "code": "def gauss_pdf(x, mu, sigma):\n    \"\"\"Normalized Gaussian\"\"\"\n    return 1 / np.sqrt(2 * np.pi) / sigma * np.exp(-(x - mu) ** 2 / 2. / sigma ** 2)", "code_tokens": "def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )", "docstring_tokens": "Normalized Gaussian", "label": 0}, {"idx": "cosqa-train-4790", "doc": "python how to make copy of object", "code": "def __copy__(self):\n        \"\"\"A magic method to implement shallow copy behavior.\"\"\"\n        return self.__class__.load(self.dump(), context=self.context)", "code_tokens": "def __copy__ ( self ) : return self . __class__ . load ( self . dump ( ) , context = self . context )", "docstring_tokens": "A magic method to implement shallow copy behavior .", "label": 0}, {"idx": "cosqa-train-4791", "doc": "generate circle image in python", "code": "def circles_pycairo(width, height, color):\n    \"\"\" Implementation of circle border with PyCairo. \"\"\"\n\n    cairo_color = color / rgb(255, 255, 255)\n\n    surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, width, height)\n    ctx = cairo.Context(surface)\n\n    # draw a circle in the center\n    ctx.new_path()\n    ctx.set_source_rgb(cairo_color.red, cairo_color.green, cairo_color.blue)\n    ctx.arc(width / 2, height / 2, width / 2, 0, 2 * pi)\n    ctx.fill()\n\n    surface.write_to_png('circles.png')", "code_tokens": "def circles_pycairo ( width , height , color ) : cairo_color = color / rgb ( 255 , 255 , 255 ) surface = cairo . ImageSurface ( cairo . FORMAT_ARGB32 , width , height ) ctx = cairo . Context ( surface ) # draw a circle in the center ctx . new_path ( ) ctx . set_source_rgb ( cairo_color . red , cairo_color . green , cairo_color . blue ) ctx . arc ( width / 2 , height / 2 , width / 2 , 0 , 2 * pi ) ctx . fill ( ) surface . write_to_png ( 'circles.png' )", "docstring_tokens": "Implementation of circle border with PyCairo .", "label": 1}, {"idx": "cosqa-train-4792", "doc": "python how to make dot character", "code": "def _dotify(cls, data):\n    \"\"\"Add dots.\"\"\"\n    return ''.join(char if char in cls.PRINTABLE_DATA else '.' for char in data)", "code_tokens": "def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )", "docstring_tokens": "Add dots .", "label": 1}, {"idx": "cosqa-train-4793", "doc": "generate combinations of elements in a list python", "code": "def combinations(l):\n    \"\"\"Pure-Python implementation of itertools.combinations(l, 2).\"\"\"\n    result = []\n    for x in xrange(len(l) - 1):\n        ls = l[x + 1:]\n        for y in ls:\n            result.append((l[x], y))\n    return result", "code_tokens": "def combinations ( l ) : result = [ ] for x in xrange ( len ( l ) - 1 ) : ls = l [ x + 1 : ] for y in ls : result . append ( ( l [ x ] , y ) ) return result", "docstring_tokens": "Pure - Python implementation of itertools . combinations ( l 2 ) .", "label": 1}, {"idx": "cosqa-train-4794", "doc": "python how to memorize last input", "code": "def _get_history_next(self):\n        \"\"\" callback function for key down \"\"\"\n        if self._has_history:\n            ret = self._input_history.return_history(1)\n            self.string = ret\n            self._curs_pos = len(ret)", "code_tokens": "def _get_history_next ( self ) : if self . _has_history : ret = self . _input_history . return_history ( 1 ) self . string = ret self . _curs_pos = len ( ret )", "docstring_tokens": "callback function for key down", "label": 0}, {"idx": "cosqa-train-4795", "doc": "python how to normalize image", "code": "def normalize(im, invert=False, scale=None, dtype=np.float64):\n    \"\"\"\n    Normalize a field to a (min, max) exposure range, default is (0, 255).\n    (min, max) exposure values. Invert the image if requested.\n    \"\"\"\n    if dtype not in {np.float16, np.float32, np.float64}:\n        raise ValueError('dtype must be numpy.float16, float32, or float64.')\n    out = im.astype('float').copy()\n\n    scale = scale or (0.0, 255.0)\n    l, u = (float(i) for i in scale)\n    out = (out - l) / (u - l)\n    if invert:\n        out = -out + (out.max() + out.min())\n    return out.astype(dtype)", "code_tokens": "def normalize ( im , invert = False , scale = None , dtype = np . float64 ) : if dtype not in { np . float16 , np . float32 , np . float64 } : raise ValueError ( 'dtype must be numpy.float16, float32, or float64.' ) out = im . astype ( 'float' ) . copy ( ) scale = scale or ( 0.0 , 255.0 ) l , u = ( float ( i ) for i in scale ) out = ( out - l ) / ( u - l ) if invert : out = - out + ( out . max ( ) + out . min ( ) ) return out . astype ( dtype )", "docstring_tokens": "Normalize a field to a ( min max ) exposure range default is ( 0 255 ) . ( min max ) exposure values . Invert the image if requested .", "label": 0}, {"idx": "cosqa-train-4796", "doc": "generate standard normal random variablles python", "code": "def rlognormal(mu, tau, size=None):\n    \"\"\"\n    Return random lognormal variates.\n    \"\"\"\n\n    return np.random.lognormal(mu, np.sqrt(1. / tau), size)", "code_tokens": "def rlognormal ( mu , tau , size = None ) : return np . random . lognormal ( mu , np . sqrt ( 1. / tau ) , size )", "docstring_tokens": "Return random lognormal variates .", "label": 1}, {"idx": "cosqa-train-4797", "doc": "python how to pass kerberos user credentials", "code": "def set_user_password(environment, parameter, password):\n    \"\"\"\n    Sets a user's password in the keyring storage\n    \"\"\"\n    username = '%s:%s' % (environment, parameter)\n    return password_set(username, password)", "code_tokens": "def set_user_password ( environment , parameter , password ) : username = '%s:%s' % ( environment , parameter ) return password_set ( username , password )", "docstring_tokens": "Sets a user s password in the keyring storage", "label": 1}, {"idx": "cosqa-train-4798", "doc": "get 3d rotation matrix python", "code": "def R_rot_3d(th):\n    \"\"\"Return a 3-dimensional rotation matrix.\n\n    Parameters\n    ----------\n    th: array, shape (n, 3)\n        Angles about which to rotate along each axis.\n\n    Returns\n    -------\n    R: array, shape (n, 3, 3)\n    \"\"\"\n    sx, sy, sz = np.sin(th).T\n    cx, cy, cz = np.cos(th).T\n    R = np.empty((len(th), 3, 3), dtype=np.float)\n\n    R[:, 0, 0] = cy * cz\n    R[:, 0, 1] = -cy * sz\n    R[:, 0, 2] = sy\n\n    R[:, 1, 0] = sx * sy * cz + cx * sz\n    R[:, 1, 1] = -sx * sy * sz + cx * cz\n    R[:, 1, 2] = -sx * cy\n\n    R[:, 2, 0] = -cx * sy * cz + sx * sz\n    R[:, 2, 1] = cx * sy * sz + sx * cz\n    R[:, 2, 2] = cx * cy\n    return R", "code_tokens": "def R_rot_3d ( th ) : sx , sy , sz = np . sin ( th ) . T cx , cy , cz = np . cos ( th ) . T R = np . empty ( ( len ( th ) , 3 , 3 ) , dtype = np . float ) R [ : , 0 , 0 ] = cy * cz R [ : , 0 , 1 ] = - cy * sz R [ : , 0 , 2 ] = sy R [ : , 1 , 0 ] = sx * sy * cz + cx * sz R [ : , 1 , 1 ] = - sx * sy * sz + cx * cz R [ : , 1 , 2 ] = - sx * cy R [ : , 2 , 0 ] = - cx * sy * cz + sx * sz R [ : , 2 , 1 ] = cx * sy * sz + sx * cz R [ : , 2 , 2 ] = cx * cy return R", "docstring_tokens": "Return a 3 - dimensional rotation matrix .", "label": 0}, {"idx": "cosqa-train-4799", "doc": "python how to populate a column with null", "code": "def fill_nulls(self, col: str):\n        \"\"\"\n        Fill all null values with NaN values in a column.\n        Null values are ``None`` or en empty string\n\n        :param col: column name\n        :type col: str\n\n        :example: ``ds.fill_nulls(\"mycol\")``\n        \"\"\"\n        n = [None, \"\"]\n        try:\n            self.df[col] = self.df[col].replace(n, nan)\n        except Exception as e:\n            self.err(e)", "code_tokens": "def fill_nulls ( self , col : str ) : n = [ None , \"\" ] try : self . df [ col ] = self . df [ col ] . replace ( n , nan ) except Exception as e : self . err ( e )", "docstring_tokens": "Fill all null values with NaN values in a column . Null values are None or en empty string", "label": 0}, {"idx": "cosqa-train-4800", "doc": "get 99% percentile of a list python", "code": "def percentile(values, k):\n    \"\"\"Find the percentile of a list of values.\n\n    :param list values: The list of values to find the percentile of\n    :param int k: The percentile to find\n    :rtype: float or int\n\n    \"\"\"\n    if not values:\n        return None\n    values.sort()\n    index = (len(values) * (float(k) / 100)) - 1\n    return values[int(math.ceil(index))]", "code_tokens": "def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]", "docstring_tokens": "Find the percentile of a list of values .", "label": 0}, {"idx": "cosqa-train-4801", "doc": "python how to put in absolute path", "code": "def get_absolute_path(*args):\n    \"\"\"Transform relative pathnames into absolute pathnames.\"\"\"\n    directory = os.path.dirname(os.path.abspath(__file__))\n    return os.path.join(directory, *args)", "code_tokens": "def get_absolute_path ( * args ) : directory = os . path . dirname ( os . path . abspath ( __file__ ) ) return os . path . join ( directory , * args )", "docstring_tokens": "Transform relative pathnames into absolute pathnames .", "label": 0}, {"idx": "cosqa-train-4802", "doc": "get 99th percentile of a list python", "code": "def percentile(values, k):\n    \"\"\"Find the percentile of a list of values.\n\n    :param list values: The list of values to find the percentile of\n    :param int k: The percentile to find\n    :rtype: float or int\n\n    \"\"\"\n    if not values:\n        return None\n    values.sort()\n    index = (len(values) * (float(k) / 100)) - 1\n    return values[int(math.ceil(index))]", "code_tokens": "def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]", "docstring_tokens": "Find the percentile of a list of values .", "label": 0}, {"idx": "cosqa-train-4803", "doc": "python how to read a text file to dict", "code": "def read_dict_from_file(file_path):\n    \"\"\"\n    Read a dictionary of strings from a file\n    \"\"\"\n    with open(file_path) as file:\n        lines = file.read().splitlines()\n\n    obj = {}\n    for line in lines:\n        key, value = line.split(':', maxsplit=1)\n        obj[key] = eval(value)\n\n    return obj", "code_tokens": "def read_dict_from_file ( file_path ) : with open ( file_path ) as file : lines = file . read ( ) . splitlines ( ) obj = { } for line in lines : key , value = line . split ( ':' , maxsplit = 1 ) obj [ key ] = eval ( value ) return obj", "docstring_tokens": "Read a dictionary of strings from a file", "label": 1}, {"idx": "cosqa-train-4804", "doc": "get all methods in object in python", "code": "def get_methods(*objs):\n    \"\"\" Return the names of all callable attributes of an object\"\"\"\n    return set(\n        attr\n        for obj in objs\n        for attr in dir(obj)\n        if not attr.startswith('_') and callable(getattr(obj, attr))\n    )", "code_tokens": "def get_methods ( * objs ) : return set ( attr for obj in objs for attr in dir ( obj ) if not attr . startswith ( '_' ) and callable ( getattr ( obj , attr ) ) )", "docstring_tokens": "Return the names of all callable attributes of an object", "label": 0}, {"idx": "cosqa-train-4805", "doc": "python how to read from bufferedreader", "code": "def get_iter_string_reader(stdin):\n    \"\"\" return an iterator that returns a chunk of a string every time it is\n    called.  notice that even though bufsize_type might be line buffered, we're\n    not doing any line buffering here.  that's because our StreamBufferer\n    handles all buffering.  we just need to return a reasonable-sized chunk. \"\"\"\n    bufsize = 1024\n    iter_str = (stdin[i:i + bufsize] for i in range(0, len(stdin), bufsize))\n    return get_iter_chunk_reader(iter_str)", "code_tokens": "def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )", "docstring_tokens": "return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk .", "label": 1}, {"idx": "cosqa-train-4806", "doc": "get attributes o object in python", "code": "def dict_from_object(obj: object):\n    \"\"\"Convert a object into dictionary with all of its readable attributes.\"\"\"\n\n    # If object is a dict instance, no need to convert.\n    return (obj if isinstance(obj, dict)\n            else {attr: getattr(obj, attr)\n                  for attr in dir(obj) if not attr.startswith('_')})", "code_tokens": "def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )", "docstring_tokens": "Convert a object into dictionary with all of its readable attributes .", "label": 0}, {"idx": "cosqa-train-4807", "doc": "python how to read xml file", "code": "def xmltreefromfile(filename):\n    \"\"\"Internal function to read an XML file\"\"\"\n    try:\n        return ElementTree.parse(filename, ElementTree.XMLParser(collect_ids=False))\n    except TypeError:\n        return ElementTree.parse(filename, ElementTree.XMLParser())", "code_tokens": "def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )", "docstring_tokens": "Internal function to read an XML file", "label": 0}, {"idx": "cosqa-train-4808", "doc": "get average of numbers in list python", "code": "def calc_list_average(l):\n    \"\"\"\n    Calculates the average value of a list of numbers\n    Returns a float\n    \"\"\"\n    total = 0.0\n    for value in l:\n        total += value\n    return total / len(l)", "code_tokens": "def calc_list_average ( l ) : total = 0.0 for value in l : total += value return total / len ( l )", "docstring_tokens": "Calculates the average value of a list of numbers Returns a float", "label": 1}, {"idx": "cosqa-train-4809", "doc": "python how to redirect stdout to a file", "code": "def redirect_output(fileobj):\n    \"\"\"Redirect standard out to file.\"\"\"\n    old = sys.stdout\n    sys.stdout = fileobj\n    try:\n        yield fileobj\n    finally:\n        sys.stdout = old", "code_tokens": "def redirect_output ( fileobj ) : old = sys . stdout sys . stdout = fileobj try : yield fileobj finally : sys . stdout = old", "docstring_tokens": "Redirect standard out to file .", "label": 0}, {"idx": "cosqa-train-4810", "doc": "get chinese character from pinyin python", "code": "def get(s, delimiter='', format=\"diacritical\"):\n    \"\"\"Return pinyin of string, the string must be unicode\n    \"\"\"\n    return delimiter.join(_pinyin_generator(u(s), format=format))", "code_tokens": "def get ( s , delimiter = '' , format = \"diacritical\" ) : return delimiter . join ( _pinyin_generator ( u ( s ) , format = format ) )", "docstring_tokens": "Return pinyin of string the string must be unicode", "label": 0}, {"idx": "cosqa-train-4811", "doc": "python how to remove file extension", "code": "def remove_ext(fname):\n    \"\"\"Removes the extension from a filename\n    \"\"\"\n    bn = os.path.basename(fname)\n    return os.path.splitext(bn)[0]", "code_tokens": "def remove_ext ( fname ) : bn = os . path . basename ( fname ) return os . path . splitext ( bn ) [ 0 ]", "docstring_tokens": "Removes the extension from a filename", "label": 0}, {"idx": "cosqa-train-4812", "doc": "get complexity of function python", "code": "def estimate_complexity(self, x,y,z,n):\n        \"\"\" \n        calculates a rough guess of runtime based on product of parameters \n        \"\"\"\n        num_calculations = x * y * z * n\n        run_time = num_calculations / 100000  # a 2014 PC does about 100k calcs in a second (guess based on prior logs)\n        return self.show_time_as_short_string(run_time)", "code_tokens": "def estimate_complexity ( self , x , y , z , n ) : num_calculations = x * y * z * n run_time = num_calculations / 100000 # a 2014 PC does about 100k calcs in a second (guess based on prior logs) return self . show_time_as_short_string ( run_time )", "docstring_tokens": "calculates a rough guess of runtime based on product of parameters", "label": 0}, {"idx": "cosqa-train-4813", "doc": "python how to restart back to a line", "code": "def do_rewind(self, line):\n        \"\"\"\n        rewind\n        \"\"\"\n        self.print_response(\"Rewinding from frame %s to 0\" % self.bot._frame)\n        self.bot._frame = 0", "code_tokens": "def do_rewind ( self , line ) : self . print_response ( \"Rewinding from frame %s to 0\" % self . bot . _frame ) self . bot . _frame = 0", "docstring_tokens": "rewind", "label": 0}, {"idx": "cosqa-train-4814", "doc": "get continent based on country geopy python", "code": "def get_geoip(ip):\n    \"\"\"Lookup country for IP address.\"\"\"\n    reader = geolite2.reader()\n    ip_data = reader.get(ip) or {}\n    return ip_data.get('country', {}).get('iso_code')", "code_tokens": "def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )", "docstring_tokens": "Lookup country for IP address .", "label": 0}, {"idx": "cosqa-train-4815", "doc": "python how to see if a file exists", "code": "def _file_exists(path, filename):\n  \"\"\"Checks if the filename exists under the path.\"\"\"\n  return os.path.isfile(os.path.join(path, filename))", "code_tokens": "def _file_exists ( path , filename ) : return os . path . isfile ( os . path . join ( path , filename ) )", "docstring_tokens": "Checks if the filename exists under the path .", "label": 1}, {"idx": "cosqa-train-4816", "doc": "get coordinates with python", "code": "def unproject(self, xy):\n        \"\"\"\n        Returns the coordinates from position in meters\n        \"\"\"\n        (x, y) = xy\n        lng = x/EARTH_RADIUS * RAD_TO_DEG\n        lat = 2 * atan(exp(y/EARTH_RADIUS)) - pi/2 * RAD_TO_DEG\n        return (lng, lat)", "code_tokens": "def unproject ( self , xy ) : ( x , y ) = xy lng = x / EARTH_RADIUS * RAD_TO_DEG lat = 2 * atan ( exp ( y / EARTH_RADIUS ) ) - pi / 2 * RAD_TO_DEG return ( lng , lat )", "docstring_tokens": "Returns the coordinates from position in meters", "label": 0}, {"idx": "cosqa-train-4817", "doc": "python how to see if a word is a palindrone", "code": "def is_palindrome(string, strict=True):\n    \"\"\"\n    Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n    :param string: String to check.\n    :type string: str\n    :param strict: True if white spaces matter (default), false otherwise.\n    :type strict: bool\n    :return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),\n    False otherwise\n    \"\"\"\n    if is_full_string(string):\n        if strict:\n            return reverse(string) == string\n        return is_palindrome(SPACES_RE.sub('', string))\n    return False", "code_tokens": "def is_palindrome ( string , strict = True ) : if is_full_string ( string ) : if strict : return reverse ( string ) == string return is_palindrome ( SPACES_RE . sub ( '' , string ) ) return False", "docstring_tokens": "Checks if the string is a palindrome ( https : // en . wikipedia . org / wiki / Palindrome ) .", "label": 1}, {"idx": "cosqa-train-4818", "doc": "get cosine of two numbers, python", "code": "def _cosine(a, b):\n    \"\"\" Return the len(a & b) / len(a) \"\"\"\n    return 1. * len(a & b) / (math.sqrt(len(a)) * math.sqrt(len(b)))", "code_tokens": "def _cosine ( a , b ) : return 1. * len ( a & b ) / ( math . sqrt ( len ( a ) ) * math . sqrt ( len ( b ) ) )", "docstring_tokens": "Return the len ( a & b ) / len ( a )", "label": 0}, {"idx": "cosqa-train-4819", "doc": "python how to select the most relevant words of a sparse document term matrix", "code": "def count(self, X):\n        \"\"\"\n        Called from the fit method, this method gets all the\n        words from the corpus and their corresponding frequency\n        counts.\n\n        Parameters\n        ----------\n\n        X : ndarray or masked ndarray\n            Pass in the matrix of vectorized documents, can be masked in\n            order to sum the word frequencies for only a subset of documents.\n\n        Returns\n        -------\n\n        counts : array\n            A vector containing the counts of all words in X (columns)\n\n        \"\"\"\n        # Sum on axis 0 (by columns), each column is a word\n        # Convert the matrix to an array\n        # Squeeze to remove the 1 dimension objects (like ravel)\n        return np.squeeze(np.asarray(X.sum(axis=0)))", "code_tokens": "def count ( self , X ) : # Sum on axis 0 (by columns), each column is a word # Convert the matrix to an array # Squeeze to remove the 1 dimension objects (like ravel) return np . squeeze ( np . asarray ( X . sum ( axis = 0 ) ) )", "docstring_tokens": "Called from the fit method this method gets all the words from the corpus and their corresponding frequency counts .", "label": 0}, {"idx": "cosqa-train-4820", "doc": "get current threads python", "code": "def get_current_frames():\n    \"\"\"Return current threads prepared for \n    further processing.\n    \"\"\"\n    return dict(\n        (thread_id, {'frame': thread2list(frame), 'time': None})\n        for thread_id, frame in sys._current_frames().items()\n    )", "code_tokens": "def get_current_frames ( ) : return dict ( ( thread_id , { 'frame' : thread2list ( frame ) , 'time' : None } ) for thread_id , frame in sys . _current_frames ( ) . items ( ) )", "docstring_tokens": "Return current threads prepared for further processing .", "label": 0}, {"idx": "cosqa-train-4821", "doc": "python how to set the value is empty of a dictionary", "code": "def _replace_none(self, aDict):\n        \"\"\" Replace all None values in a dict with 'none' \"\"\"\n        for k, v in aDict.items():\n            if v is None:\n                aDict[k] = 'none'", "code_tokens": "def _replace_none ( self , aDict ) : for k , v in aDict . items ( ) : if v is None : aDict [ k ] = 'none'", "docstring_tokens": "Replace all None values in a dict with none", "label": 0}, {"idx": "cosqa-train-4822", "doc": "get datetime with utc timezone python", "code": "def timestamp_from_datetime(dt):\n    \"\"\"\n    Compute timestamp from a datetime object that could be timezone aware\n    or unaware.\n    \"\"\"\n    try:\n        utc_dt = dt.astimezone(pytz.utc)\n    except ValueError:\n        utc_dt = dt.replace(tzinfo=pytz.utc)\n    return timegm(utc_dt.timetuple())", "code_tokens": "def timestamp_from_datetime ( dt ) : try : utc_dt = dt . astimezone ( pytz . utc ) except ValueError : utc_dt = dt . replace ( tzinfo = pytz . utc ) return timegm ( utc_dt . timetuple ( ) )", "docstring_tokens": "Compute timestamp from a datetime object that could be timezone aware or unaware .", "label": 0}, {"idx": "cosqa-train-4823", "doc": "python how to strip space in list", "code": "def __normalize_list(self, msg):\n        \"\"\"Split message to list by commas and trim whitespace.\"\"\"\n        if isinstance(msg, list):\n            msg = \"\".join(msg)\n        return list(map(lambda x: x.strip(), msg.split(\",\")))", "code_tokens": "def __normalize_list ( self , msg ) : if isinstance ( msg , list ) : msg = \"\" . join ( msg ) return list ( map ( lambda x : x . strip ( ) , msg . split ( \",\" ) ) )", "docstring_tokens": "Split message to list by commas and trim whitespace .", "label": 1}, {"idx": "cosqa-train-4824", "doc": "get distinct list python", "code": "def get_uniques(l):\n    \"\"\" Returns a list with no repeated elements.\n    \"\"\"\n    result = []\n\n    for i in l:\n        if i not in result:\n            result.append(i)\n\n    return result", "code_tokens": "def get_uniques ( l ) : result = [ ] for i in l : if i not in result : result . append ( i ) return result", "docstring_tokens": "Returns a list with no repeated elements .", "label": 0}, {"idx": "cosqa-train-4825", "doc": "python how to swap rows of numpy mattrix", "code": "def _swap_rows(self, i, j):\n        \"\"\"Swap i and j rows\n\n        As the side effect, determinant flips.\n\n        \"\"\"\n\n        L = np.eye(3, dtype='intc')\n        L[i, i] = 0\n        L[j, j] = 0\n        L[i, j] = 1\n        L[j, i] = 1\n        self._L.append(L.copy())\n        self._A = np.dot(L, self._A)", "code_tokens": "def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )", "docstring_tokens": "Swap i and j rows", "label": 1}, {"idx": "cosqa-train-4826", "doc": "get distinct values in python", "code": "def distinct(xs):\n    \"\"\"Get the list of distinct values with preserving order.\"\"\"\n    # don't use collections.OrderedDict because we do support Python 2.6\n    seen = set()\n    return [x for x in xs if x not in seen and not seen.add(x)]", "code_tokens": "def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]", "docstring_tokens": "Get the list of distinct values with preserving order .", "label": 0}, {"idx": "cosqa-train-4827", "doc": "python how to tell if a folder is a symbolic link", "code": "def is_symlink(self):\n        \"\"\"\n        Whether this path is a symbolic link.\n        \"\"\"\n        try:\n            return S_ISLNK(self.lstat().st_mode)\n        except OSError as e:\n            if e.errno != ENOENT:\n                raise\n            # Path doesn't exist\n            return False", "code_tokens": "def is_symlink ( self ) : try : return S_ISLNK ( self . lstat ( ) . st_mode ) except OSError as e : if e . errno != ENOENT : raise # Path doesn't exist return False", "docstring_tokens": "Whether this path is a symbolic link .", "label": 0}, {"idx": "cosqa-train-4828", "doc": "get euclidean distance between two arrays python", "code": "def vector_distance(a, b):\n    \"\"\"The Euclidean distance between two vectors.\"\"\"\n    a = np.array(a)\n    b = np.array(b)\n    return np.linalg.norm(a - b)", "code_tokens": "def vector_distance ( a , b ) : a = np . array ( a ) b = np . array ( b ) return np . linalg . norm ( a - b )", "docstring_tokens": "The Euclidean distance between two vectors .", "label": 0}, {"idx": "cosqa-train-4829", "doc": "python how to use pdb set trace", "code": "def set_trace():\n    \"\"\"Start a Pdb instance at the calling frame, with stdout routed to sys.__stdout__.\"\"\"\n    # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py\n    pdb.Pdb(stdout=sys.__stdout__).set_trace(sys._getframe().f_back)", "code_tokens": "def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )", "docstring_tokens": "Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ .", "label": 1}, {"idx": "cosqa-train-4830", "doc": "get globals from function python", "code": "def extract_module_locals(depth=0):\n    \"\"\"Returns (module, locals) of the funciton `depth` frames away from the caller\"\"\"\n    f = sys._getframe(depth + 1)\n    global_ns = f.f_globals\n    module = sys.modules[global_ns['__name__']]\n    return (module, f.f_locals)", "code_tokens": "def extract_module_locals ( depth = 0 ) : f = sys . _getframe ( depth + 1 ) global_ns = f . f_globals module = sys . modules [ global_ns [ '__name__' ] ] return ( module , f . f_locals )", "docstring_tokens": "Returns ( module locals ) of the funciton depth frames away from the caller", "label": 0}, {"idx": "cosqa-train-4831", "doc": "python how to work with binary files", "code": "def is_binary(filename):\n    \"\"\" Returns True if the file is binary\n\n    \"\"\"\n    with open(filename, 'rb') as fp:\n        data = fp.read(1024)\n        if not data:\n            return False\n        if b'\\0' in data:\n            return True\n        return False", "code_tokens": "def is_binary ( filename ) : with open ( filename , 'rb' ) as fp : data = fp . read ( 1024 ) if not data : return False if b'\\0' in data : return True return False", "docstring_tokens": "Returns True if the file is binary", "label": 0}, {"idx": "cosqa-train-4832", "doc": "get image format type python", "code": "def _get_image_numpy_dtype(self):\n        \"\"\"\n        Get the numpy dtype for the image\n        \"\"\"\n        try:\n            ftype = self._info['img_equiv_type']\n            npy_type = _image_bitpix2npy[ftype]\n        except KeyError:\n            raise KeyError(\"unsupported fits data type: %d\" % ftype)\n\n        return npy_type", "code_tokens": "def _get_image_numpy_dtype ( self ) : try : ftype = self . _info [ 'img_equiv_type' ] npy_type = _image_bitpix2npy [ ftype ] except KeyError : raise KeyError ( \"unsupported fits data type: %d\" % ftype ) return npy_type", "docstring_tokens": "Get the numpy dtype for the image", "label": 1}, {"idx": "cosqa-train-4833", "doc": "python how to write one character to stdout", "code": "def printOut(value, end='\\n'):\n    \"\"\"\n    This function prints the given String immediately and flushes the output.\n    \"\"\"\n    sys.stdout.write(value)\n    sys.stdout.write(end)\n    sys.stdout.flush()", "code_tokens": "def printOut ( value , end = '\\n' ) : sys . stdout . write ( value ) sys . stdout . write ( end ) sys . stdout . flush ( )", "docstring_tokens": "This function prints the given String immediately and flushes the output .", "label": 0}, {"idx": "cosqa-train-4834", "doc": "get index from item python", "code": "def _get_item_position(self, idx):\n        \"\"\"Return a tuple of (start, end) indices of an item from its index.\"\"\"\n        start = 0 if idx == 0 else self._index[idx - 1] + 1\n        end = self._index[idx]\n        return start, end", "code_tokens": "def _get_item_position ( self , idx ) : start = 0 if idx == 0 else self . _index [ idx - 1 ] + 1 end = self . _index [ idx ] return start , end", "docstring_tokens": "Return a tuple of ( start end ) indices of an item from its index .", "label": 0}, {"idx": "cosqa-train-4835", "doc": "python how to write warn", "code": "def warn(self, text):\n\t\t\"\"\" Ajout d'un message de log de type WARN \"\"\"\n\t\tself.logger.warn(\"{}{}\".format(self.message_prefix, text))", "code_tokens": "def warn ( self , text ) : self . logger . warn ( \"{}{}\" . format ( self . message_prefix , text ) )", "docstring_tokens": "Ajout d un message de log de type WARN", "label": 0}, {"idx": "cosqa-train-4836", "doc": "get index keys mongodb python", "code": "def get_model_index_properties(instance, index):\n    \"\"\"Return the list of properties specified for a model in an index.\"\"\"\n    mapping = get_index_mapping(index)\n    doc_type = instance._meta.model_name.lower()\n    return list(mapping[\"mappings\"][doc_type][\"properties\"].keys())", "code_tokens": "def get_model_index_properties ( instance , index ) : mapping = get_index_mapping ( index ) doc_type = instance . _meta . model_name . lower ( ) return list ( mapping [ \"mappings\" ] [ doc_type ] [ \"properties\" ] . keys ( ) )", "docstring_tokens": "Return the list of properties specified for a model in an index .", "label": 0}, {"idx": "cosqa-train-4837", "doc": "python how tro create a copy of a series", "code": "def copy(self):\n        \"\"\"Return a copy of this list with each element copied to new memory\n        \"\"\"\n        out = type(self)()\n        for series in self:\n            out.append(series.copy())\n        return out", "code_tokens": "def copy ( self ) : out = type ( self ) ( ) for series in self : out . append ( series . copy ( ) ) return out", "docstring_tokens": "Return a copy of this list with each element copied to new memory", "label": 0}, {"idx": "cosqa-train-4838", "doc": "get json file with python", "code": "def open_json(file_name):\n    \"\"\"\n    returns json contents as string\n    \"\"\"\n    with open(file_name, \"r\") as json_data:\n        data = json.load(json_data)\n        return data", "code_tokens": "def open_json ( file_name ) : with open ( file_name , \"r\" ) as json_data : data = json . load ( json_data ) return data", "docstring_tokens": "returns json contents as string", "label": 0}, {"idx": "cosqa-train-4839", "doc": "python html markdown to text", "code": "def markdown_to_text(body):\n    \"\"\"Converts markdown to text.\n\n    Args:\n        body: markdown (or plaintext, or maybe HTML) input\n\n    Returns:\n        Plaintext with all tags and frills removed\n    \"\"\"\n    # Turn our input into HTML\n    md = markdown.markdown(body, extensions=[\n        'markdown.extensions.extra'\n    ])\n\n    # Safely parse HTML so that we don't have to parse it ourselves\n    soup = BeautifulSoup(md, 'html.parser')\n\n    # Return just the text of the parsed HTML\n    return soup.get_text()", "code_tokens": "def markdown_to_text ( body ) : # Turn our input into HTML md = markdown . markdown ( body , extensions = [ 'markdown.extensions.extra' ] ) # Safely parse HTML so that we don't have to parse it ourselves soup = BeautifulSoup ( md , 'html.parser' ) # Return just the text of the parsed HTML return soup . get_text ( )", "docstring_tokens": "Converts markdown to text .", "label": 0}, {"idx": "cosqa-train-4840", "doc": "get last modified date python", "code": "def last_modified_date(filename):\n    \"\"\"Last modified timestamp as a UTC datetime\"\"\"\n    mtime = os.path.getmtime(filename)\n    dt = datetime.datetime.utcfromtimestamp(mtime)\n    return dt.replace(tzinfo=pytz.utc)", "code_tokens": "def last_modified_date ( filename ) : mtime = os . path . getmtime ( filename ) dt = datetime . datetime . utcfromtimestamp ( mtime ) return dt . replace ( tzinfo = pytz . utc )", "docstring_tokens": "Last modified timestamp as a UTC datetime", "label": 0}, {"idx": "cosqa-train-4841", "doc": "python http status cde 401", "code": "def HttpResponse401(request, template=KEY_AUTH_401_TEMPLATE,\ncontent=KEY_AUTH_401_CONTENT, content_type=KEY_AUTH_401_CONTENT_TYPE):\n    \"\"\"\n    HTTP response for not-authorized access (status code 403)\n    \"\"\"\n    return AccessFailedResponse(request, template, content, content_type, status=401)", "code_tokens": "def HttpResponse401 ( request , template = KEY_AUTH_401_TEMPLATE , content = KEY_AUTH_401_CONTENT , content_type = KEY_AUTH_401_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 401 )", "docstring_tokens": "HTTP response for not - authorized access ( status code 403 )", "label": 0}, {"idx": "cosqa-train-4842", "doc": "get list of indexes from row python", "code": "def get_idx_rect(index_list):\n    \"\"\"Extract the boundaries from a list of indexes\"\"\"\n    rows, cols = list(zip(*[(i.row(), i.column()) for i in index_list]))\n    return ( min(rows), max(rows), min(cols), max(cols) )", "code_tokens": "def get_idx_rect ( index_list ) : rows , cols = list ( zip ( * [ ( i . row ( ) , i . column ( ) ) for i in index_list ] ) ) return ( min ( rows ) , max ( rows ) , min ( cols ) , max ( cols ) )", "docstring_tokens": "Extract the boundaries from a list of indexes", "label": 0}, {"idx": "cosqa-train-4843", "doc": "python identify column type", "code": "def _getTypename(self, defn):\n        \"\"\" Returns the SQL typename required to store the given FieldDefinition \"\"\"\n        return 'REAL' if defn.type.float or 'TIME' in defn.type.name or defn.dntoeu else 'INTEGER'", "code_tokens": "def _getTypename ( self , defn ) : return 'REAL' if defn . type . float or 'TIME' in defn . type . name or defn . dntoeu else 'INTEGER'", "docstring_tokens": "Returns the SQL typename required to store the given FieldDefinition", "label": 0}, {"idx": "cosqa-train-4844", "doc": "get memory address of python object", "code": "def objectproxy_realaddress(obj):\n    \"\"\"\n    Obtain a real address as an integer from an objectproxy.\n    \"\"\"\n    voidp = QROOT.TPython.ObjectProxy_AsVoidPtr(obj)\n    return C.addressof(C.c_char.from_buffer(voidp))", "code_tokens": "def objectproxy_realaddress ( obj ) : voidp = QROOT . TPython . ObjectProxy_AsVoidPtr ( obj ) return C . addressof ( C . c_char . from_buffer ( voidp ) )", "docstring_tokens": "Obtain a real address as an integer from an objectproxy .", "label": 0}, {"idx": "cosqa-train-4845", "doc": "python ie download how to know the file size", "code": "def server(self):\n        \"\"\"Returns the size of remote files\n        \"\"\"\n        try:\n            tar = urllib2.urlopen(self.registry)\n            meta = tar.info()\n            return int(meta.getheaders(\"Content-Length\")[0])\n        except (urllib2.URLError, IndexError):\n            return \" \"", "code_tokens": "def server ( self ) : try : tar = urllib2 . urlopen ( self . registry ) meta = tar . info ( ) return int ( meta . getheaders ( \"Content-Length\" ) [ 0 ] ) except ( urllib2 . URLError , IndexError ) : return \" \"", "docstring_tokens": "Returns the size of remote files", "label": 0}, {"idx": "cosqa-train-4846", "doc": "get mouse coords in python 3", "code": "def get_mouse_location(self):\n        \"\"\"\n        Get the current mouse location (coordinates and screen number).\n\n        :return: a namedtuple with ``x``, ``y`` and ``screen_num`` fields\n        \"\"\"\n        x = ctypes.c_int(0)\n        y = ctypes.c_int(0)\n        screen_num = ctypes.c_int(0)\n        _libxdo.xdo_get_mouse_location(\n            self._xdo, ctypes.byref(x), ctypes.byref(y),\n            ctypes.byref(screen_num))\n        return mouse_location(x.value, y.value, screen_num.value)", "code_tokens": "def get_mouse_location ( self ) : x = ctypes . c_int ( 0 ) y = ctypes . c_int ( 0 ) screen_num = ctypes . c_int ( 0 ) _libxdo . xdo_get_mouse_location ( self . _xdo , ctypes . byref ( x ) , ctypes . byref ( y ) , ctypes . byref ( screen_num ) ) return mouse_location ( x . value , y . value , screen_num . value )", "docstring_tokens": "Get the current mouse location ( coordinates and screen number ) .", "label": 0}, {"idx": "cosqa-train-4847", "doc": "python if a json attribute exists do", "code": "def task_property_present_predicate(service, task, prop):\n    \"\"\" True if the json_element passed is present for the task specified.\n    \"\"\"\n    try:\n        response = get_service_task(service, task)\n    except Exception as e:\n        pass\n\n    return (response is not None) and (prop in response)", "code_tokens": "def task_property_present_predicate ( service , task , prop ) : try : response = get_service_task ( service , task ) except Exception as e : pass return ( response is not None ) and ( prop in response )", "docstring_tokens": "True if the json_element passed is present for the task specified .", "label": 0}, {"idx": "cosqa-train-4848", "doc": "get names of all disk drive python", "code": "def GetMountpoints():\n  \"\"\"List all the filesystems mounted on the system.\"\"\"\n  devices = {}\n\n  for filesys in GetFileSystems():\n    devices[filesys.f_mntonname] = (filesys.f_mntfromname, filesys.f_fstypename)\n\n  return devices", "code_tokens": "def GetMountpoints ( ) : devices = { } for filesys in GetFileSystems ( ) : devices [ filesys . f_mntonname ] = ( filesys . f_mntfromname , filesys . f_fstypename ) return devices", "docstring_tokens": "List all the filesystems mounted on the system .", "label": 0}, {"idx": "cosqa-train-4849", "doc": "python if file has size", "code": "def is_readable(fp, size=1):\n    \"\"\"\n    Check if the file-like object is readable.\n\n    :param fp: file-like object\n    :param size: byte size\n    :return: bool\n    \"\"\"\n    read_size = len(fp.read(size))\n    fp.seek(-read_size, 1)\n    return read_size == size", "code_tokens": "def is_readable ( fp , size = 1 ) : read_size = len ( fp . read ( size ) ) fp . seek ( - read_size , 1 ) return read_size == size", "docstring_tokens": "Check if the file - like object is readable .", "label": 0}, {"idx": "cosqa-train-4850", "doc": "get number of cores python os", "code": "def _num_cpus_darwin():\n    \"\"\"Return the number of active CPUs on a Darwin system.\"\"\"\n    p = subprocess.Popen(['sysctl','-n','hw.ncpu'],stdout=subprocess.PIPE)\n    return p.stdout.read()", "code_tokens": "def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )", "docstring_tokens": "Return the number of active CPUs on a Darwin system .", "label": 0}, {"idx": "cosqa-train-4851", "doc": "python if folder exist and creat", "code": "def ensure_dir_exists(directory):\n    \"\"\"Se asegura de que un directorio exista.\"\"\"\n    if directory and not os.path.exists(directory):\n        os.makedirs(directory)", "code_tokens": "def ensure_dir_exists ( directory ) : if directory and not os . path . exists ( directory ) : os . makedirs ( directory )", "docstring_tokens": "Se asegura de que un directorio exista .", "label": 1}, {"idx": "cosqa-train-4852", "doc": "get object value with name string python", "code": "def _GetValue(self, name):\n    \"\"\"Returns the TextFSMValue object natching the requested name.\"\"\"\n    for value in self.values:\n      if value.name == name:\n        return value", "code_tokens": "def _GetValue ( self , name ) : for value in self . values : if value . name == name : return value", "docstring_tokens": "Returns the TextFSMValue object natching the requested name .", "label": 1}, {"idx": "cosqa-train-4853", "doc": "python if set is subset of other set", "code": "def issuperset(self, other):\n        \"\"\"Report whether this RangeSet contains another set.\"\"\"\n        self._binary_sanity_check(other)\n        return set.issuperset(self, other)", "code_tokens": "def issuperset ( self , other ) : self . _binary_sanity_check ( other ) return set . issuperset ( self , other )", "docstring_tokens": "Report whether this RangeSet contains another set .", "label": 1}, {"idx": "cosqa-train-4854", "doc": "get output from call in python", "code": "def check_output(args):\n    \"\"\"Runs command and returns the output as string.\"\"\"\n    log.debug('run: %s', args)\n    out = subprocess.check_output(args=args).decode('utf-8')\n    log.debug('out: %r', out)\n    return out", "code_tokens": "def check_output ( args ) : log . debug ( 'run: %s' , args ) out = subprocess . check_output ( args = args ) . decode ( 'utf-8' ) log . debug ( 'out: %r' , out ) return out", "docstring_tokens": "Runs command and returns the output as string .", "label": 0}, {"idx": "cosqa-train-4855", "doc": "python if socket is readable", "code": "def _stdin_ready_posix():\n    \"\"\"Return True if there's something to read on stdin (posix version).\"\"\"\n    infds, outfds, erfds = select.select([sys.stdin],[],[],0)\n    return bool(infds)", "code_tokens": "def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )", "docstring_tokens": "Return True if there s something to read on stdin ( posix version ) .", "label": 0}, {"idx": "cosqa-train-4856", "doc": "get owner of doc in python", "code": "def owner(self):\n        \"\"\"\n        Username of document creator\n        \"\"\"\n        if self._owner:\n            return self._owner\n        elif not self.abstract:\n            return self.read_meta()._owner\n\n        raise EmptyDocumentException()", "code_tokens": "def owner ( self ) : if self . _owner : return self . _owner elif not self . abstract : return self . read_meta ( ) . _owner raise EmptyDocumentException ( )", "docstring_tokens": "Username of document creator", "label": 0}, {"idx": "cosqa-train-4857", "doc": "get properties of an object python", "code": "def dict_from_object(obj: object):\n    \"\"\"Convert a object into dictionary with all of its readable attributes.\"\"\"\n\n    # If object is a dict instance, no need to convert.\n    return (obj if isinstance(obj, dict)\n            else {attr: getattr(obj, attr)\n                  for attr in dir(obj) if not attr.startswith('_')})", "code_tokens": "def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )", "docstring_tokens": "Convert a object into dictionary with all of its readable attributes .", "label": 0}, {"idx": "cosqa-train-4858", "doc": "python igraph get subgraph without other vertice", "code": "def leaf_nodes(self):\n        \"\"\"\n        Return an interable of nodes with no edges pointing at them. This is\n        helpful to find all nodes without dependencies.\n        \"\"\"\n        # Now contains all nodes that contain dependencies.\n        deps = {item for sublist in self.edges.values() for item in sublist}\n        # contains all nodes *without* any dependencies (leaf nodes)\n        return self.nodes - deps", "code_tokens": "def leaf_nodes ( self ) : # Now contains all nodes that contain dependencies. deps = { item for sublist in self . edges . values ( ) for item in sublist } # contains all nodes *without* any dependencies (leaf nodes) return self . nodes - deps", "docstring_tokens": "Return an interable of nodes with no edges pointing at them . This is helpful to find all nodes without dependencies .", "label": 1}, {"idx": "cosqa-train-4859", "doc": "get rid of duplicate items in list python", "code": "def unique(list):\n    \"\"\" Returns a copy of the list without duplicates.\n    \"\"\"\n    unique = []; [unique.append(x) for x in list if x not in unique]\n    return unique", "code_tokens": "def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique", "docstring_tokens": "Returns a copy of the list without duplicates .", "label": 0}, {"idx": "cosqa-train-4860", "doc": "python image test for bad transparency mask", "code": "def check_color(cls, raw_image):\n        \"\"\"\n        Just check if raw_image is completely white.\n        http://stackoverflow.com/questions/14041562/python-pil-detect-if-an-image-is-completely-black-or-white\n        \"\"\"\n        # sum(img.convert(\"L\").getextrema()) in (0, 2)\n        extrema = raw_image.convert(\"L\").getextrema()\n        if extrema == (255, 255): # all white\n            raise cls.MonoImageException", "code_tokens": "def check_color ( cls , raw_image ) : # sum(img.convert(\"L\").getextrema()) in (0, 2)\n extrema = raw_image . convert ( \"L\" ) . getextrema ( ) if extrema == ( 255 , 255 ) : # all white\n raise cls . MonoImageException", "docstring_tokens": "Just check if raw_image is completely white . http : // stackoverflow . com / questions / 14041562 / python - pil - detect - if - an - image - is - completely - black - or - white", "label": 0}, {"idx": "cosqa-train-4861", "doc": "get rid of y axis python", "code": "def axes_off(ax):\n    \"\"\"Get rid of all axis ticks, lines, etc.\n    \"\"\"\n    ax.set_frame_on(False)\n    ax.axes.get_yaxis().set_visible(False)\n    ax.axes.get_xaxis().set_visible(False)", "code_tokens": "def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )", "docstring_tokens": "Get rid of all axis ticks lines etc .", "label": 0}, {"idx": "cosqa-train-4862", "doc": "python improved peak finding", "code": "def findMin(arr):\n    \"\"\"\n    in comparison to argrelmax() more simple and  reliable peak finder\n    \"\"\"\n    out = np.zeros(shape=arr.shape, dtype=bool)\n    _calcMin(arr, out)\n    return out", "code_tokens": "def findMin ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMin ( arr , out ) return out", "docstring_tokens": "in comparison to argrelmax () more simple and reliable peak finder", "label": 0}, {"idx": "cosqa-train-4863", "doc": "get the date from a string python", "code": "def _read_date_from_string(str1):\n    \"\"\"\n    Reads the date from a string in the format YYYY/MM/DD and returns\n    :class: datetime.date\n    \"\"\"\n    full_date = [int(x) for x in str1.split('/')]\n    return datetime.date(full_date[0], full_date[1], full_date[2])", "code_tokens": "def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )", "docstring_tokens": "Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date", "label": 1}, {"idx": "cosqa-train-4864", "doc": "python include files in other directories", "code": "def setup_path():\n    \"\"\"Sets up the python include paths to include src\"\"\"\n    import os.path; import sys\n\n    if sys.argv[0]:\n        top_dir = os.path.dirname(os.path.abspath(sys.argv[0]))\n        sys.path = [os.path.join(top_dir, \"src\")] + sys.path\n        pass\n    return", "code_tokens": "def setup_path ( ) : import os . path import sys if sys . argv [ 0 ] : top_dir = os . path . dirname ( os . path . abspath ( sys . argv [ 0 ] ) ) sys . path = [ os . path . join ( top_dir , \"src\" ) ] + sys . path pass return", "docstring_tokens": "Sets up the python include paths to include src", "label": 0}, {"idx": "cosqa-train-4865", "doc": "get the date of last monday in python", "code": "def prevmonday(num):\n    \"\"\"\n    Return unix SECOND timestamp of \"num\" mondays ago\n    \"\"\"\n    today = get_today()\n    lastmonday = today - timedelta(days=today.weekday(), weeks=num)\n    return lastmonday", "code_tokens": "def prevmonday ( num ) : today = get_today ( ) lastmonday = today - timedelta ( days = today . weekday ( ) , weeks = num ) return lastmonday", "docstring_tokens": "Return unix SECOND timestamp of num mondays ago", "label": 0}, {"idx": "cosqa-train-4866", "doc": "python inner join result larger than originals", "code": "def merge(left, right, how='inner', key=None, left_key=None, right_key=None,\n          left_as='left', right_as='right'):\n    \"\"\" Performs a join using the union join function. \"\"\"\n    return join(left, right, how, key, left_key, right_key,\n                join_fn=make_union_join(left_as, right_as))", "code_tokens": "def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "docstring_tokens": "Performs a join using the union join function .", "label": 0}, {"idx": "cosqa-train-4867", "doc": "get the last item in an object iterator python", "code": "def end_index(self):\n        \"\"\"\n        Returns the 1-based index of the last object on this page,\n        relative to total objects found (hits).\n        \"\"\"\n        return ((self.number - 1) * self.paginator.per_page +\n            len(self.object_list))", "code_tokens": "def end_index ( self ) : return ( ( self . number - 1 ) * self . paginator . per_page + len ( self . object_list ) )", "docstring_tokens": "Returns the 1 - based index of the last object on this page relative to total objects found ( hits ) .", "label": 0}, {"idx": "cosqa-train-4868", "doc": "python input command blocking", "code": "async def async_input(prompt):\n    \"\"\"\n    Python's ``input()`` is blocking, which means the event loop we set\n    above can't be running while we're blocking there. This method will\n    let the loop run while we wait for input.\n    \"\"\"\n    print(prompt, end='', flush=True)\n    return (await loop.run_in_executor(None, sys.stdin.readline)).rstrip()", "code_tokens": "async def async_input ( prompt ) : print ( prompt , end = '' , flush = True ) return ( await loop . run_in_executor ( None , sys . stdin . readline ) ) . rstrip ( )", "docstring_tokens": "Python s input () is blocking which means the event loop we set above can t be running while we re blocking there . This method will let the loop run while we wait for input .", "label": 0}, {"idx": "cosqa-train-4869", "doc": "get the name of a property python", "code": "def get_property(self, property_name):\n        \"\"\"\n        Get a property's value.\n\n        property_name -- the property to get the value of\n\n        Returns the properties value, if found, else None.\n        \"\"\"\n        prop = self.find_property(property_name)\n        if prop:\n            return prop.get_value()\n\n        return None", "code_tokens": "def get_property ( self , property_name ) : prop = self . find_property ( property_name ) if prop : return prop . get_value ( ) return None", "docstring_tokens": "Get a property s value .", "label": 0}, {"idx": "cosqa-train-4870", "doc": "python input copy and move files", "code": "def copyFile(input, output, replace=None):\n    \"\"\"Copy a file whole from input to output.\"\"\"\n\n    _found = findFile(output)\n    if not _found or (_found and replace):\n        shutil.copy2(input, output)", "code_tokens": "def copyFile ( input , output , replace = None ) : _found = findFile ( output ) if not _found or ( _found and replace ) : shutil . copy2 ( input , output )", "docstring_tokens": "Copy a file whole from input to output .", "label": 0}, {"idx": "cosqa-train-4871", "doc": "get the ordinal value for letters in a string python", "code": "def byte2int(s, index=0):\n    \"\"\"Get the ASCII int value of a character in a string.\n\n    :param s: a string\n    :param index: the position of desired character\n\n    :return: ASCII int value\n    \"\"\"\n    if six.PY2:\n        return ord(s[index])\n    return s[index]", "code_tokens": "def byte2int ( s , index = 0 ) : if six . PY2 : return ord ( s [ index ] ) return s [ index ]", "docstring_tokens": "Get the ASCII int value of a character in a string .", "label": 0}, {"idx": "cosqa-train-4872", "doc": "python insert \\n after a certain number of white spaces", "code": "def indent(text, amount, ch=' '):\n    \"\"\"Indents a string by the given amount of characters.\"\"\"\n    padding = amount * ch\n    return ''.join(padding+line for line in text.splitlines(True))", "code_tokens": "def indent ( text , amount , ch = ' ' ) : padding = amount * ch return '' . join ( padding + line for line in text . splitlines ( True ) )", "docstring_tokens": "Indents a string by the given amount of characters .", "label": 0}, {"idx": "cosqa-train-4873", "doc": "get the present date week number in python after setting week start date to saturday", "code": "def weekly(date=datetime.date.today()):\n    \"\"\"\n    Weeks start are fixes at Monday for now.\n    \"\"\"\n    return date - datetime.timedelta(days=date.weekday())", "code_tokens": "def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )", "docstring_tokens": "Weeks start are fixes at Monday for now .", "label": 0}, {"idx": "cosqa-train-4874", "doc": "python int array to c pointer", "code": "def cint32_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes int pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_int32)):\n        return np.fromiter(cptr, dtype=np.int32, count=length)\n    else:\n        raise RuntimeError('Expected int pointer')", "code_tokens": "def cint32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int32 ) ) : return np . fromiter ( cptr , dtype = np . int32 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "docstring_tokens": "Convert a ctypes int pointer array to a numpy array .", "label": 1}, {"idx": "cosqa-train-4875", "doc": "get the user name in python", "code": "def get_user_name():\n    \"\"\"Get user name provide by operating system\n    \"\"\"\n\n    if sys.platform == 'win32':\n        #user = os.getenv('USERPROFILE')\n        user = os.getenv('USERNAME')\n    else:\n        user = os.getenv('LOGNAME')\n\n    return user", "code_tokens": "def get_user_name ( ) : if sys . platform == 'win32' : #user = os.getenv('USERPROFILE') user = os . getenv ( 'USERNAME' ) else : user = os . getenv ( 'LOGNAME' ) return user", "docstring_tokens": "Get user name provide by operating system", "label": 0}, {"idx": "cosqa-train-4876", "doc": "python int typecasting removing whitespace", "code": "def robust_int(v):\n    \"\"\"Parse an int robustly, ignoring commas and other cruft. \"\"\"\n\n    if isinstance(v, int):\n        return v\n\n    if isinstance(v, float):\n        return int(v)\n\n    v = str(v).replace(',', '')\n\n    if not v:\n        return None\n\n    return int(v)", "code_tokens": "def robust_int ( v ) : if isinstance ( v , int ) : return v if isinstance ( v , float ) : return int ( v ) v = str ( v ) . replace ( ',' , '' ) if not v : return None return int ( v )", "docstring_tokens": "Parse an int robustly ignoring commas and other cruft .", "label": 0}, {"idx": "cosqa-train-4877", "doc": "get the value of dom element xml python", "code": "def _get_minidom_tag_value(station, tag_name):\n    \"\"\"get a value from a tag (if it exists)\"\"\"\n    tag = station.getElementsByTagName(tag_name)[0].firstChild\n    if tag:\n        return tag.nodeValue\n\n    return None", "code_tokens": "def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None", "docstring_tokens": "get a value from a tag ( if it exists )", "label": 0}, {"idx": "cosqa-train-4878", "doc": "python interpolate array too big", "code": "def interpolate_slice(slice_rows, slice_cols, interpolator):\n    \"\"\"Interpolate the given slice of the larger array.\"\"\"\n    fine_rows = np.arange(slice_rows.start, slice_rows.stop, slice_rows.step)\n    fine_cols = np.arange(slice_cols.start, slice_cols.stop, slice_cols.step)\n    return interpolator(fine_cols, fine_rows)", "code_tokens": "def interpolate_slice ( slice_rows , slice_cols , interpolator ) : fine_rows = np . arange ( slice_rows . start , slice_rows . stop , slice_rows . step ) fine_cols = np . arange ( slice_cols . start , slice_cols . stop , slice_cols . step ) return interpolator ( fine_cols , fine_rows )", "docstring_tokens": "Interpolate the given slice of the larger array .", "label": 0}, {"idx": "cosqa-train-4879", "doc": "get viewing screen resolution in python", "code": "def _getVirtualScreenRect(self):\n        \"\"\" The virtual screen is the bounding box containing all monitors.\n\n        Not all regions in the virtual screen are actually visible. The (0,0) coordinate\n        is the top left corner of the primary screen rather than the whole bounding box, so\n        some regions of the virtual screen may have negative coordinates if another screen\n        is positioned in Windows as further to the left or above the primary screen.\n\n        Returns the rect as (x, y, w, h)\n        \"\"\"\n        SM_XVIRTUALSCREEN = 76  # Left of virtual screen\n        SM_YVIRTUALSCREEN = 77  # Top of virtual screen\n        SM_CXVIRTUALSCREEN = 78 # Width of virtual screen\n        SM_CYVIRTUALSCREEN = 79 # Height of virtual screen\n\n        return (self._user32.GetSystemMetrics(SM_XVIRTUALSCREEN), \\\n                self._user32.GetSystemMetrics(SM_YVIRTUALSCREEN), \\\n                self._user32.GetSystemMetrics(SM_CXVIRTUALSCREEN), \\\n                self._user32.GetSystemMetrics(SM_CYVIRTUALSCREEN))", "code_tokens": "def _getVirtualScreenRect ( self ) : SM_XVIRTUALSCREEN = 76 # Left of virtual screen SM_YVIRTUALSCREEN = 77 # Top of virtual screen SM_CXVIRTUALSCREEN = 78 # Width of virtual screen SM_CYVIRTUALSCREEN = 79 # Height of virtual screen return ( self . _user32 . GetSystemMetrics ( SM_XVIRTUALSCREEN ) , self . _user32 . GetSystemMetrics ( SM_YVIRTUALSCREEN ) , self . _user32 . GetSystemMetrics ( SM_CXVIRTUALSCREEN ) , self . _user32 . GetSystemMetrics ( SM_CYVIRTUALSCREEN ) )", "docstring_tokens": "The virtual screen is the bounding box containing all monitors .", "label": 1}, {"idx": "cosqa-train-4880", "doc": "python interpolate atmos grid data to station", "code": "def resample(grid, wl, flux):\n    \"\"\" Resample spectrum onto desired grid \"\"\"\n    flux_rs = (interpolate.interp1d(wl, flux))(grid)\n    return flux_rs", "code_tokens": "def resample ( grid , wl , flux ) : flux_rs = ( interpolate . interp1d ( wl , flux ) ) ( grid ) return flux_rs", "docstring_tokens": "Resample spectrum onto desired grid", "label": 0}, {"idx": "cosqa-train-4881", "doc": "python invalid charater in identifer", "code": "def pythonise(id, encoding='ascii'):\n    \"\"\"Return a Python-friendly id\"\"\"\n    replace = {'-': '_', ':': '_', '/': '_'}\n    func = lambda id, pair: id.replace(pair[0], pair[1])\n    id = reduce(func, replace.iteritems(), id)\n    id = '_%s' % id if id[0] in string.digits else id\n    return id.encode(encoding)", "code_tokens": "def pythonise ( id , encoding = 'ascii' ) : replace = { '-' : '_' , ':' : '_' , '/' : '_' } func = lambda id , pair : id . replace ( pair [ 0 ] , pair [ 1 ] ) id = reduce ( func , replace . iteritems ( ) , id ) id = '_%s' % id if id [ 0 ] in string . digits else id return id . encode ( encoding )", "docstring_tokens": "Return a Python - friendly id", "label": 0}, {"idx": "cosqa-train-4882", "doc": "gettting enum name python", "code": "def getEventTypeNameFromEnum(self, eType):\n        \"\"\"returns the name of an EVREvent enum value\"\"\"\n\n        fn = self.function_table.getEventTypeNameFromEnum\n        result = fn(eType)\n        return result", "code_tokens": "def getEventTypeNameFromEnum ( self , eType ) : fn = self . function_table . getEventTypeNameFromEnum result = fn ( eType ) return result", "docstring_tokens": "returns the name of an EVREvent enum value", "label": 0}, {"idx": "cosqa-train-4883", "doc": "python ip to geolocation", "code": "def get_geoip(ip):\n    \"\"\"Lookup country for IP address.\"\"\"\n    reader = geolite2.reader()\n    ip_data = reader.get(ip) or {}\n    return ip_data.get('country', {}).get('iso_code')", "code_tokens": "def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )", "docstring_tokens": "Lookup country for IP address .", "label": 0}, {"idx": "cosqa-train-4884", "doc": "git bash python hangs", "code": "def check_git():\n    \"\"\"Check if git command is available.\"\"\"\n    try:\n        with open(os.devnull, \"wb\") as devnull:\n            subprocess.check_call([\"git\", \"--version\"], stdout=devnull, stderr=devnull)\n    except:\n        raise RuntimeError(\"Please make sure git is installed and on your path.\")", "code_tokens": "def check_git ( ) : try : with open ( os . devnull , \"wb\" ) as devnull : subprocess . check_call ( [ \"git\" , \"--version\" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( \"Please make sure git is installed and on your path.\" )", "docstring_tokens": "Check if git command is available .", "label": 0}, {"idx": "cosqa-train-4885", "doc": "python is a valid word", "code": "def is_identifier(string):\n    \"\"\"Check if string could be a valid python identifier\n\n    :param string: string to be tested\n    :returns: True if string can be a python identifier, False otherwise\n    :rtype: bool\n    \"\"\"\n    matched = PYTHON_IDENTIFIER_RE.match(string)\n    return bool(matched) and not keyword.iskeyword(string)", "code_tokens": "def is_identifier ( string ) : matched = PYTHON_IDENTIFIER_RE . match ( string ) return bool ( matched ) and not keyword . iskeyword ( string )", "docstring_tokens": "Check if string could be a valid python identifier", "label": 1}, {"idx": "cosqa-train-4886", "doc": "given word is palindrom or not in python", "code": "def is_palindrome(string, strict=True):\n    \"\"\"\n    Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n    :param string: String to check.\n    :type string: str\n    :param strict: True if white spaces matter (default), false otherwise.\n    :type strict: bool\n    :return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),\n    False otherwise\n    \"\"\"\n    if is_full_string(string):\n        if strict:\n            return reverse(string) == string\n        return is_palindrome(SPACES_RE.sub('', string))\n    return False", "code_tokens": "def is_palindrome ( string , strict = True ) : if is_full_string ( string ) : if strict : return reverse ( string ) == string return is_palindrome ( SPACES_RE . sub ( '' , string ) ) return False", "docstring_tokens": "Checks if the string is a palindrome ( https : // en . wikipedia . org / wiki / Palindrome ) .", "label": 0}, {"idx": "cosqa-train-4887", "doc": "python is not string", "code": "def to_str(s):\n    \"\"\"\n    Convert bytes and non-string into Python 3 str\n    \"\"\"\n    if isinstance(s, bytes):\n        s = s.decode('utf-8')\n    elif not isinstance(s, str):\n        s = str(s)\n    return s", "code_tokens": "def to_str ( s ) : if isinstance ( s , bytes ) : s = s . decode ( 'utf-8' ) elif not isinstance ( s , str ) : s = str ( s ) return s", "docstring_tokens": "Convert bytes and non - string into Python 3 str", "label": 0}, {"idx": "cosqa-train-4888", "doc": "grabbing certain box pixels in image python", "code": "def bbox(img):\n    \"\"\"Find the bounding box around nonzero elements in the given array\n\n    Copied from https://stackoverflow.com/a/31402351/5703449 .\n\n    Returns:\n        rowmin, rowmax, colmin, colmax\n    \"\"\"\n    rows = np.any(img, axis=1)\n    cols = np.any(img, axis=0)\n    rmin, rmax = np.where(rows)[0][[0, -1]]\n    cmin, cmax = np.where(cols)[0][[0, -1]]\n\n    return rmin, rmax, cmin, cmax", "code_tokens": "def bbox ( img ) : rows = np . any ( img , axis = 1 ) cols = np . any ( img , axis = 0 ) rmin , rmax = np . where ( rows ) [ 0 ] [ [ 0 , - 1 ] ] cmin , cmax = np . where ( cols ) [ 0 ] [ [ 0 , - 1 ] ] return rmin , rmax , cmin , cmax", "docstring_tokens": "Find the bounding box around nonzero elements in the given array", "label": 0}, {"idx": "cosqa-train-4889", "doc": "python itarate array in chunks", "code": "def chunks(arr, size):\n    \"\"\"Splits a list into chunks\n\n    :param arr: list to split\n    :type arr: :class:`list`\n    :param size: number of elements in each chunk\n    :type size: :class:`int`\n    :return: generator object\n    :rtype: :class:`generator`\n    \"\"\"\n    for i in _range(0, len(arr), size):\n        yield arr[i:i+size]", "code_tokens": "def chunks ( arr , size ) : for i in _range ( 0 , len ( arr ) , size ) : yield arr [ i : i + size ]", "docstring_tokens": "Splits a list into chunks", "label": 0}, {"idx": "cosqa-train-4890", "doc": "handling python stored procedure result set", "code": "def query_proc_row(procname, args=(), factory=None):\n    \"\"\"\n    Execute a stored procedure. Returns the first row of the result set,\n    or `None`.\n    \"\"\"\n    for row in query_proc(procname, args, factory):\n        return row\n    return None", "code_tokens": "def query_proc_row ( procname , args = ( ) , factory = None ) : for row in query_proc ( procname , args , factory ) : return row return None", "docstring_tokens": "Execute a stored procedure . Returns the first row of the result set or None .", "label": 0}, {"idx": "cosqa-train-4891", "doc": "python item for item in iterable", "code": "def concat(cls, iterables):\n    \"\"\"\n    Similar to #itertools.chain.from_iterable().\n    \"\"\"\n\n    def generator():\n      for it in iterables:\n        for element in it:\n          yield element\n    return cls(generator())", "code_tokens": "def concat ( cls , iterables ) : def generator ( ) : for it in iterables : for element in it : yield element return cls ( generator ( ) )", "docstring_tokens": "Similar to #itertools . chain . from_iterable () .", "label": 0}, {"idx": "cosqa-train-4892", "doc": "haversine python with multiple", "code": "def lazy_reverse_binmap(f, xs):\n    \"\"\"\n    Same as lazy_binmap, except the parameters are flipped for the binary function\n    \"\"\"\n    return (f(y, x) for x, y in zip(xs, xs[1:]))", "code_tokens": "def lazy_reverse_binmap ( f , xs ) : return ( f ( y , x ) for x , y in zip ( xs , xs [ 1 : ] ) )", "docstring_tokens": "Same as lazy_binmap except the parameters are flipped for the binary function", "label": 0}, {"idx": "cosqa-train-4893", "doc": "python iter not next", "code": "def __next__(self):\n    \"\"\"Pop the head off the iterator and return it.\"\"\"\n    res = self._head\n    self._fill()\n    if res is None:\n      raise StopIteration()\n    return res", "code_tokens": "def __next__ ( self ) : res = self . _head self . _fill ( ) if res is None : raise StopIteration ( ) return res", "docstring_tokens": "Pop the head off the iterator and return it .", "label": 0}, {"idx": "cosqa-train-4894", "doc": "heap and stack in python", "code": "def _heappush_max(heap, item):\n    \"\"\" why is this not in heapq \"\"\"\n    heap.append(item)\n    heapq._siftdown_max(heap, 0, len(heap) - 1)", "code_tokens": "def _heappush_max ( heap , item ) : heap . append ( item ) heapq . _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "docstring_tokens": "why is this not in heapq", "label": 0}, {"idx": "cosqa-train-4895", "doc": "python iterable numpy tolist", "code": "def A(*a):\n    \"\"\"convert iterable object into numpy array\"\"\"\n    return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "code_tokens": "def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]", "docstring_tokens": "convert iterable object into numpy array", "label": 0}, {"idx": "cosqa-train-4896", "doc": "height of tree recursive python", "code": "def min_depth(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if root is None:\n        return 0\n    if root.left is not None or root.right is not None:\n        return max(self.minDepth(root.left), self.minDepth(root.right))+1\n    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1", "code_tokens": "def min_depth ( self , root ) : if root is None : return 0 if root . left is not None or root . right is not None : return max ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1 return min ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1", "docstring_tokens": ": type root : TreeNode : rtype : int", "label": 0}, {"idx": "cosqa-train-4897", "doc": "python iterate files in folder", "code": "def each_img(dir_path):\n    \"\"\"\n    Iterates through each image in the given directory. (not recursive)\n    :param dir_path: Directory path where images files are present\n    :return: Iterator to iterate through image files\n    \"\"\"\n    for fname in os.listdir(dir_path):\n        if fname.endswith('.jpg') or fname.endswith('.png') or fname.endswith('.bmp'):\n            yield fname", "code_tokens": "def each_img ( dir_path ) : for fname in os . listdir ( dir_path ) : if fname . endswith ( '.jpg' ) or fname . endswith ( '.png' ) or fname . endswith ( '.bmp' ) : yield fname", "docstring_tokens": "Iterates through each image in the given directory . ( not recursive ) : param dir_path : Directory path where images files are present : return : Iterator to iterate through image files", "label": 0}, {"idx": "cosqa-train-4898", "doc": "hex to charachter python", "code": "def hex_escape(bin_str):\n  \"\"\"\n  Hex encode a binary string\n  \"\"\"\n  printable = string.ascii_letters + string.digits + string.punctuation + ' '\n  return ''.join(ch if ch in printable else r'0x{0:02x}'.format(ord(ch)) for ch in bin_str)", "code_tokens": "def hex_escape ( bin_str ) : printable = string . ascii_letters + string . digits + string . punctuation + ' ' return '' . join ( ch if ch in printable else r'0x{0:02x}' . format ( ord ( ch ) ) for ch in bin_str )", "docstring_tokens": "Hex encode a binary string", "label": 0}, {"idx": "cosqa-train-4899", "doc": "python iterate folders and get paths", "code": "def get_files(dir_name):\n    \"\"\"Simple directory walker\"\"\"\n    return [(os.path.join('.', d), [os.path.join(d, f) for f in files]) for d, _, files in os.walk(dir_name)]", "code_tokens": "def get_files ( dir_name ) : return [ ( os . path . join ( '.' , d ) , [ os . path . join ( d , f ) for f in files ] ) for d , _ , files in os . walk ( dir_name ) ]", "docstring_tokens": "Simple directory walker", "label": 0}, {"idx": "cosqa-train-4900", "doc": "highlight text output python", "code": "def get_highlighted_code(name, code, type='terminal'):\n    \"\"\"\n    If pygments are available on the system\n    then returned output is colored. Otherwise\n    unchanged content is returned.\n    \"\"\"\n    import logging\n    try:\n        import pygments\n        pygments\n    except ImportError:\n        return code\n    from pygments import highlight\n    from pygments.lexers import guess_lexer_for_filename, ClassNotFound\n    from pygments.formatters import TerminalFormatter\n\n    try:\n        lexer = guess_lexer_for_filename(name, code)\n        formatter = TerminalFormatter()\n        content = highlight(code, lexer, formatter)\n    except ClassNotFound:\n        logging.debug(\"Couldn't guess Lexer, will not use pygments.\")\n        content = code\n    return content", "code_tokens": "def get_highlighted_code ( name , code , type = 'terminal' ) : import logging try : import pygments pygments except ImportError : return code from pygments import highlight from pygments . lexers import guess_lexer_for_filename , ClassNotFound from pygments . formatters import TerminalFormatter try : lexer = guess_lexer_for_filename ( name , code ) formatter = TerminalFormatter ( ) content = highlight ( code , lexer , formatter ) except ClassNotFound : logging . debug ( \"Couldn't guess Lexer, will not use pygments.\" ) content = code return content", "docstring_tokens": "If pygments are available on the system then returned output is colored . Otherwise unchanged content is returned .", "label": 0}, {"idx": "cosqa-train-4901", "doc": "python iterate keys in dict sorted", "code": "def _dict_values_sorted_by_key(dictionary):\n    # This should be a yield from instead.\n    \"\"\"Internal helper to return the values of a dictionary, sorted by key.\n    \"\"\"\n    for _, value in sorted(dictionary.iteritems(), key=operator.itemgetter(0)):\n        yield value", "code_tokens": "def _dict_values_sorted_by_key ( dictionary ) : # This should be a yield from instead. for _ , value in sorted ( dictionary . iteritems ( ) , key = operator . itemgetter ( 0 ) ) : yield value", "docstring_tokens": "Internal helper to return the values of a dictionary sorted by key .", "label": 0}, {"idx": "cosqa-train-4902", "doc": "ho to read a file and pass all comment lines python", "code": "def parse_comments_for_file(filename):\n    \"\"\"\n    Return a list of all parsed comments in a file.  Mostly for testing &\n    interactive use.\n    \"\"\"\n    return [parse_comment(strip_stars(comment), next_line)\n            for comment, next_line in get_doc_comments(read_file(filename))]", "code_tokens": "def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]", "docstring_tokens": "Return a list of all parsed comments in a file . Mostly for testing & interactive use .", "label": 0}, {"idx": "cosqa-train-4903", "doc": "python iterating over everything except last item", "code": "def __iter__(self):\n\t\t\"\"\"Iterate through all elements.\n\n\t\tMultiple copies will be returned if they exist.\n\t\t\"\"\"\n\t\tfor value, count in self.counts():\n\t\t\tfor _ in range(count):\n\t\t\t\tyield value", "code_tokens": "def __iter__ ( self ) : for value , count in self . counts ( ) : for _ in range ( count ) : yield value", "docstring_tokens": "Iterate through all elements .", "label": 0}, {"idx": "cosqa-train-4904", "doc": "hoe to check data type in python", "code": "def isnumber(*args):\n    \"\"\"Checks if value is an integer, long integer or float.\n\n    NOTE: Treats booleans as numbers, where True=1 and False=0.\n    \"\"\"\n    return all(map(lambda c: isinstance(c, int) or isinstance(c, float), args))", "code_tokens": "def isnumber ( * args ) : return all ( map ( lambda c : isinstance ( c , int ) or isinstance ( c , float ) , args ) )", "docstring_tokens": "Checks if value is an integer long integer or float .", "label": 1}, {"idx": "cosqa-train-4905", "doc": "python iterating over queryset values", "code": "def _unordered_iterator(self):\n        \"\"\"\n        Return the value of each QuerySet, but also add the '#' property to each\n        return item.\n        \"\"\"\n        for i, qs in zip(self._queryset_idxs, self._querysets):\n            for item in qs:\n                setattr(item, '#', i)\n                yield item", "code_tokens": "def _unordered_iterator ( self ) : for i , qs in zip ( self . _queryset_idxs , self . _querysets ) : for item in qs : setattr ( item , '#' , i ) yield item", "docstring_tokens": "Return the value of each QuerySet but also add the # property to each return item .", "label": 0}, {"idx": "cosqa-train-4906", "doc": "hot to format string into xml in python", "code": "def pretty_xml(data):\n    \"\"\"Return a pretty formated xml\n    \"\"\"\n    parsed_string = minidom.parseString(data.decode('utf-8'))\n    return parsed_string.toprettyxml(indent='\\t', encoding='utf-8')", "code_tokens": "def pretty_xml ( data ) : parsed_string = minidom . parseString ( data . decode ( 'utf-8' ) ) return parsed_string . toprettyxml ( indent = '\\t' , encoding = 'utf-8' )", "docstring_tokens": "Return a pretty formated xml", "label": 0}, {"idx": "cosqa-train-4907", "doc": "python iterator get chunk", "code": "def get_chunks(source, chunk_len):\n    \"\"\" Returns an iterator over 'chunk_len' chunks of 'source' \"\"\"\n    return (source[i: i + chunk_len] for i in range(0, len(source), chunk_len))", "code_tokens": "def get_chunks ( source , chunk_len ) : return ( source [ i : i + chunk_len ] for i in range ( 0 , len ( source ) , chunk_len ) )", "docstring_tokens": "Returns an iterator over chunk_len chunks of source", "label": 0}, {"idx": "cosqa-train-4908", "doc": "how 'save as' in python", "code": "def pickle_save(thing,fname):\n    \"\"\"save something to a pickle file\"\"\"\n    pickle.dump(thing, open(fname,\"wb\"),pickle.HIGHEST_PROTOCOL)\n    return thing", "code_tokens": "def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , \"wb\" ) , pickle . HIGHEST_PROTOCOL ) return thing", "docstring_tokens": "save something to a pickle file", "label": 1}, {"idx": "cosqa-train-4909", "doc": "python iterator get index", "code": "def index(self, elem):\n        \"\"\"Find the index of elem in the reversed iterator.\"\"\"\n        return _coconut.len(self._iter) - self._iter.index(elem) - 1", "code_tokens": "def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1", "docstring_tokens": "Find the index of elem in the reversed iterator .", "label": 0}, {"idx": "cosqa-train-4910", "doc": "how can i change path of python", "code": "def getpackagepath():\n    \"\"\"\n     *Get the root path for this python package - used in unit testing code*\n    \"\"\"\n    moduleDirectory = os.path.dirname(__file__)\n    packagePath = os.path.dirname(__file__) + \"/../\"\n\n    return packagePath", "code_tokens": "def getpackagepath ( ) : moduleDirectory = os . path . dirname ( __file__ ) packagePath = os . path . dirname ( __file__ ) + \"/../\" return packagePath", "docstring_tokens": "* Get the root path for this python package - used in unit testing code *", "label": 0}, {"idx": "cosqa-train-4911", "doc": "python iterrows get next row", "code": "def next(self):\n        \"\"\"Retrieve the next row.\"\"\"\n        # I'm pretty sure this is the completely wrong way to go about this, but\n        # oh well, this works.\n        if not hasattr(self, '_iter'):\n            self._iter = self.readrow_as_dict()\n        return self._iter.next()", "code_tokens": "def next ( self ) : # I'm pretty sure this is the completely wrong way to go about this, but # oh well, this works. if not hasattr ( self , '_iter' ) : self . _iter = self . readrow_as_dict ( ) return self . _iter . next ( )", "docstring_tokens": "Retrieve the next row .", "label": 1}, {"idx": "cosqa-train-4912", "doc": "how can i get all sunday in a month python", "code": "def first_sunday(self, year, month):\n        \"\"\"Get the first sunday of a month.\"\"\"\n        date = datetime(year, month, 1, 0)\n        days_until_sunday = 6 - date.weekday()\n\n        return date + timedelta(days=days_until_sunday)", "code_tokens": "def first_sunday ( self , year , month ) : date = datetime ( year , month , 1 , 0 ) days_until_sunday = 6 - date . weekday ( ) return date + timedelta ( days = days_until_sunday )", "docstring_tokens": "Get the first sunday of a month .", "label": 1}, {"idx": "cosqa-train-4913", "doc": "python itertools groupby usage", "code": "def group_by(iterable, key_func):\n    \"\"\"Wrap itertools.groupby to make life easier.\"\"\"\n    groups = (\n        list(sub) for key, sub in groupby(iterable, key_func)\n    )\n    return zip(groups, groups)", "code_tokens": "def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "docstring_tokens": "Wrap itertools . groupby to make life easier .", "label": 1}, {"idx": "cosqa-train-4914", "doc": "how can i read the last line of a file in python", "code": "def last(self):\n        \"\"\"Get the last object in file.\"\"\"\n        # End of file\n        self.__file.seek(0, 2)\n\n        # Get the last struct\n        data = self.get(self.length - 1)\n\n        return data", "code_tokens": "def last ( self ) : # End of file self . __file . seek ( 0 , 2 ) # Get the last struct data = self . get ( self . length - 1 ) return data", "docstring_tokens": "Get the last object in file .", "label": 0}, {"idx": "cosqa-train-4915", "doc": "python jinja render table", "code": "def html(header_rows):\n    \"\"\"\n    Convert a list of tuples describing a table into a HTML string\n    \"\"\"\n    name = 'table%d' % next(tablecounter)\n    return HtmlTable([map(str, row) for row in header_rows], name).render()", "code_tokens": "def html ( header_rows ) : name = 'table%d' % next ( tablecounter ) return HtmlTable ( [ map ( str , row ) for row in header_rows ] , name ) . render ( )", "docstring_tokens": "Convert a list of tuples describing a table into a HTML string", "label": 0}, {"idx": "cosqa-train-4916", "doc": "how can we invoke ws authentication in soap ws using python", "code": "def authenticate(self, transport, account_name, password=None):\n        \"\"\"\n        Authenticates account using soap method.\n        \"\"\"\n        Authenticator.authenticate(self, transport, account_name, password)\n\n        if password == None:\n            return self.pre_auth(transport, account_name)\n        else:\n            return self.auth(transport, account_name, password)", "code_tokens": "def authenticate ( self , transport , account_name , password = None ) : Authenticator . authenticate ( self , transport , account_name , password ) if password == None : return self . pre_auth ( transport , account_name ) else : return self . auth ( transport , account_name , password )", "docstring_tokens": "Authenticates account using soap method .", "label": 0}, {"idx": "cosqa-train-4917", "doc": "python jinja2 add express", "code": "def render_template(template_name, **context):\n    \"\"\"Render a template into a response.\"\"\"\n    tmpl = jinja_env.get_template(template_name)\n    context[\"url_for\"] = url_for\n    return Response(tmpl.render(context), mimetype=\"text/html\")", "code_tokens": "def render_template ( template_name , * * context ) : tmpl = jinja_env . get_template ( template_name ) context [ \"url_for\" ] = url_for return Response ( tmpl . render ( context ) , mimetype = \"text/html\" )", "docstring_tokens": "Render a template into a response .", "label": 0}, {"idx": "cosqa-train-4918", "doc": "how cast from string to float in python", "code": "def comma_converter(float_string):\n    \"\"\"Convert numbers to floats whether the decimal point is '.' or ','\"\"\"\n    trans_table = maketrans(b',', b'.')\n    return float(float_string.translate(trans_table))", "code_tokens": "def comma_converter ( float_string ) : trans_table = maketrans ( b',' , b'.' ) return float ( float_string . translate ( trans_table ) )", "docstring_tokens": "Convert numbers to floats whether the decimal point is . or", "label": 0}, {"idx": "cosqa-train-4919", "doc": "python jinja2 same directionary", "code": "def rstjinja(app, docname, source):\n    \"\"\"\n    Render our pages as a jinja template for fancy templating goodness.\n    \"\"\"\n    # Make sure we're outputting HTML\n    if app.builder.format != 'html':\n        return\n    src = source[0]\n    rendered = app.builder.templates.render_string(\n        src, app.config.html_context\n    )\n    source[0] = rendered", "code_tokens": "def rstjinja ( app , docname , source ) : # Make sure we're outputting HTML if app . builder . format != 'html' : return src = source [ 0 ] rendered = app . builder . templates . render_string ( src , app . config . html_context ) source [ 0 ] = rendered", "docstring_tokens": "Render our pages as a jinja template for fancy templating goodness .", "label": 0}, {"idx": "cosqa-train-4920", "doc": "how do i disable the security certificate check in python requests", "code": "def disable_insecure_request_warning():\n    \"\"\"Suppress warning about untrusted SSL certificate.\"\"\"\n    import requests\n    from requests.packages.urllib3.exceptions import InsecureRequestWarning\n    requests.packages.urllib3.disable_warnings(InsecureRequestWarning)", "code_tokens": "def disable_insecure_request_warning ( ) : import requests from requests . packages . urllib3 . exceptions import InsecureRequestWarning requests . packages . urllib3 . disable_warnings ( InsecureRequestWarning )", "docstring_tokens": "Suppress warning about untrusted SSL certificate .", "label": 1}, {"idx": "cosqa-train-4921", "doc": "python join expected string", "code": "def _py2_and_3_joiner(sep, joinable):\n    \"\"\"\n    Allow '\\n'.join(...) statements to work in Py2 and Py3.\n    :param sep:\n    :param joinable:\n    :return:\n    \"\"\"\n    if ISPY3:\n        sep = bytes(sep, DEFAULT_ENCODING)\n    joined = sep.join(joinable)\n    return joined.decode(DEFAULT_ENCODING) if ISPY3 else joined", "code_tokens": "def _py2_and_3_joiner ( sep , joinable ) : if ISPY3 : sep = bytes ( sep , DEFAULT_ENCODING ) joined = sep . join ( joinable ) return joined . decode ( DEFAULT_ENCODING ) if ISPY3 else joined", "docstring_tokens": "Allow \\ n . join ( ... ) statements to work in Py2 and Py3 . : param sep : : param joinable : : return :", "label": 0}, {"idx": "cosqa-train-4922", "doc": "how do i make my object iterable python", "code": "def __iter__(self):\n\t\t\"\"\"Iterate through all elements.\n\n\t\tMultiple copies will be returned if they exist.\n\t\t\"\"\"\n\t\tfor value, count in self.counts():\n\t\t\tfor _ in range(count):\n\t\t\t\tyield value", "code_tokens": "def __iter__ ( self ) : for value , count in self . counts ( ) : for _ in range ( count ) : yield value", "docstring_tokens": "Iterate through all elements .", "label": 0}, {"idx": "cosqa-train-4923", "doc": "python join path to everyname in list", "code": "def prepare_path(path):\n    \"\"\"\n    Path join helper method\n    Join paths if list passed\n\n    :type path: str|unicode|list\n    :rtype: str|unicode\n    \"\"\"\n    if type(path) == list:\n        return os.path.join(*path)\n    return path", "code_tokens": "def prepare_path ( path ) : if type ( path ) == list : return os . path . join ( * path ) return path", "docstring_tokens": "Path join helper method Join paths if list passed", "label": 0}, {"idx": "cosqa-train-4924", "doc": "how do i show a legend on a python plot", "code": "def finish_plot():\n    \"\"\"Helper for plotting.\"\"\"\n    plt.legend()\n    plt.grid(color='0.7')\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.show()", "code_tokens": "def finish_plot ( ) : plt . legend ( ) plt . grid ( color = '0.7' ) plt . xlabel ( 'x' ) plt . ylabel ( 'y' ) plt . show ( )", "docstring_tokens": "Helper for plotting .", "label": 1}, {"idx": "cosqa-train-4925", "doc": "python json check dumps", "code": "def is_valid_data(obj):\n    \"\"\"Check if data is JSON serializable.\n    \"\"\"\n    if obj:\n        try:\n            tmp = json.dumps(obj, default=datetime_encoder)\n            del tmp\n        except (TypeError, UnicodeDecodeError):\n            return False\n    return True", "code_tokens": "def is_valid_data ( obj ) : if obj : try : tmp = json . dumps ( obj , default = datetime_encoder ) del tmp except ( TypeError , UnicodeDecodeError ) : return False return True", "docstring_tokens": "Check if data is JSON serializable .", "label": 0}, {"idx": "cosqa-train-4926", "doc": "how do i stop git from running python", "code": "def check_git():\n    \"\"\"Check if git command is available.\"\"\"\n    try:\n        with open(os.devnull, \"wb\") as devnull:\n            subprocess.check_call([\"git\", \"--version\"], stdout=devnull, stderr=devnull)\n    except:\n        raise RuntimeError(\"Please make sure git is installed and on your path.\")", "code_tokens": "def check_git ( ) : try : with open ( os . devnull , \"wb\" ) as devnull : subprocess . check_call ( [ \"git\" , \"--version\" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( \"Please make sure git is installed and on your path.\" )", "docstring_tokens": "Check if git command is available .", "label": 1}, {"idx": "cosqa-train-4927", "doc": "python json deserialize datetime", "code": "def _deserialize_datetime(self, data):\n        \"\"\"Take any values coming in as a datetime and deserialize them\n\n        \"\"\"\n        for key in data:\n            if isinstance(data[key], dict):\n                if data[key].get('type') == 'datetime':\n                    data[key] = \\\n                        datetime.datetime.fromtimestamp(data[key]['value'])\n        return data", "code_tokens": "def _deserialize_datetime ( self , data ) : for key in data : if isinstance ( data [ key ] , dict ) : if data [ key ] . get ( 'type' ) == 'datetime' : data [ key ] = datetime . datetime . fromtimestamp ( data [ key ] [ 'value' ] ) return data", "docstring_tokens": "Take any values coming in as a datetime and deserialize them", "label": 1}, {"idx": "cosqa-train-4928", "doc": "how do i test for null values in float variables in python", "code": "def set_float(val):\n    \"\"\" utility to set a floating value,\n    useful for converting from strings \"\"\"\n    out = None\n    if not val in (None, ''):\n        try:\n            out = float(val)\n        except ValueError:\n            return None\n        if numpy.isnan(out):\n            out = default\n    return out", "code_tokens": "def set_float ( val ) : out = None if not val in ( None , '' ) : try : out = float ( val ) except ValueError : return None if numpy . isnan ( out ) : out = default return out", "docstring_tokens": "utility to set a floating value useful for converting from strings", "label": 0}, {"idx": "cosqa-train-4929", "doc": "python json list to object", "code": "def parse_list(cls, api, json_list):\n        \"\"\"\n            Parse a list of JSON objects into\n            a result set of model instances.\n        \"\"\"\n        results = []\n        for json_obj in json_list:\n            if json_obj:\n                obj = cls.parse(api, json_obj)\n                results.append(obj)\n\n        return results", "code_tokens": "def parse_list ( cls , api , json_list ) : results = [ ] for json_obj in json_list : if json_obj : obj = cls . parse ( api , json_obj ) results . append ( obj ) return results", "docstring_tokens": "Parse a list of JSON objects into a result set of model instances .", "label": 0}, {"idx": "cosqa-train-4930", "doc": "how do i use telnet with python", "code": "def test():\n    \"\"\"Test program for telnetlib.\n\n    Usage: python telnetlib.py [-d] ... [host [port]]\n\n    Default host is localhost; default port is 23.\n\n    \"\"\"\n    debuglevel = 0\n    while sys.argv[1:] and sys.argv[1] == '-d':\n        debuglevel = debuglevel + 1\n        del sys.argv[1]\n    host = 'localhost'\n    if sys.argv[1:]:\n        host = sys.argv[1]\n    port = 0\n    if sys.argv[2:]:\n        portstr = sys.argv[2]\n        try:\n            port = int(portstr)\n        except ValueError:\n            port = socket.getservbyname(portstr, 'tcp')\n    tn = Telnet()\n    tn.set_debuglevel(debuglevel)\n    tn.open(host, port)\n    tn.interact()\n    tn.close()", "code_tokens": "def test ( ) : debuglevel = 0 while sys . argv [ 1 : ] and sys . argv [ 1 ] == '-d' : debuglevel = debuglevel + 1 del sys . argv [ 1 ] host = 'localhost' if sys . argv [ 1 : ] : host = sys . argv [ 1 ] port = 0 if sys . argv [ 2 : ] : portstr = sys . argv [ 2 ] try : port = int ( portstr ) except ValueError : port = socket . getservbyname ( portstr , 'tcp' ) tn = Telnet ( ) tn . set_debuglevel ( debuglevel ) tn . open ( host , port ) tn . interact ( ) tn . close ( )", "docstring_tokens": "Test program for telnetlib .", "label": 0}, {"idx": "cosqa-train-4931", "doc": "python json return datetime as string", "code": "def _time_to_json(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\"\"\"\n    if isinstance(value, datetime.time):\n        value = value.isoformat()\n    return value", "code_tokens": "def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 1}, {"idx": "cosqa-train-4932", "doc": "how do we exit in python", "code": "def fast_exit(code):\n    \"\"\"Exit without garbage collection, this speeds up exit by about 10ms for\n    things like bash completion.\n    \"\"\"\n    sys.stdout.flush()\n    sys.stderr.flush()\n    os._exit(code)", "code_tokens": "def fast_exit ( code ) : sys . stdout . flush ( ) sys . stderr . flush ( ) os . _exit ( code )", "docstring_tokens": "Exit without garbage collection this speeds up exit by about 10ms for things like bash completion .", "label": 0}, {"idx": "cosqa-train-4933", "doc": "python json stringify an object", "code": "def to_json(obj):\n    \"\"\"Return a json string representing the python object obj.\"\"\"\n    i = StringIO.StringIO()\n    w = Writer(i, encoding='UTF-8')\n    w.write_value(obj)\n    return i.getvalue()", "code_tokens": "def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )", "docstring_tokens": "Return a json string representing the python object obj .", "label": 0}, {"idx": "cosqa-train-4934", "doc": "how do you add headers to a request python", "code": "def with_headers(self, headers):\n        \"\"\"Sets multiple headers on the request and returns the request itself.\n\n        Keyword arguments:\n        headers -- a dict-like object which contains the headers to set.\n        \"\"\"\n        for key, value in headers.items():\n            self.with_header(key, value)\n        return self", "code_tokens": "def with_headers ( self , headers ) : for key , value in headers . items ( ) : self . with_header ( key , value ) return self", "docstring_tokens": "Sets multiple headers on the request and returns the request itself .", "label": 0}, {"idx": "cosqa-train-4935", "doc": "python json view as a tree", "code": "def as_tree(context):\n    \"\"\"Return info about an object's members as JSON\"\"\"\n\n    tree = _build_tree(context, 2, 1)\n    if type(tree) == dict:\n        tree = [tree] \n    \n    return Response(content_type='application/json', body=json.dumps(tree))", "code_tokens": "def as_tree ( context ) : tree = _build_tree ( context , 2 , 1 ) if type ( tree ) == dict : tree = [ tree ] return Response ( content_type = 'application/json' , body = json . dumps ( tree ) )", "docstring_tokens": "Return info about an object s members as JSON", "label": 0}, {"idx": "cosqa-train-4936", "doc": "how do you calculate a matrix to the 100th in python", "code": "def normalize_matrix(matrix):\n  \"\"\"Fold all values of the matrix into [0, 1].\"\"\"\n  abs_matrix = np.abs(matrix.copy())\n  return abs_matrix / abs_matrix.max()", "code_tokens": "def normalize_matrix ( matrix ) : abs_matrix = np . abs ( matrix . copy ( ) ) return abs_matrix / abs_matrix . max ( )", "docstring_tokens": "Fold all values of the matrix into [ 0 1 ] .", "label": 0}, {"idx": "cosqa-train-4937", "doc": "python jsonify result set sql server", "code": "def process_result_value(self, value, dialect):\n        \"\"\"convert value from json to a python object\"\"\"\n        if value is not None:\n            value = simplejson.loads(value)\n        return value", "code_tokens": "def process_result_value ( self , value , dialect ) : if value is not None : value = simplejson . loads ( value ) return value", "docstring_tokens": "convert value from json to a python object", "label": 0}, {"idx": "cosqa-train-4938", "doc": "how do you compare a string to a number in python", "code": "def is_int(string):\n    \"\"\"\n    Checks if a string is an integer. If the string value is an integer\n    return True, otherwise return False. \n    \n    Args:\n        string: a string to test.\n\n    Returns: \n        boolean\n    \"\"\"\n    try:\n        a = float(string)\n        b = int(a)\n    except ValueError:\n        return False\n    else:\n        return a == b", "code_tokens": "def is_int ( string ) : try : a = float ( string ) b = int ( a ) except ValueError : return False else : return a == b", "docstring_tokens": "Checks if a string is an integer . If the string value is an integer return True otherwise return False . Args : string : a string to test .", "label": 1}, {"idx": "cosqa-train-4939", "doc": "python just change modified time not contents of file", "code": "def set_time(filename, mod_time):\n\t\"\"\"\n\tSet the modified time of a file\n\t\"\"\"\n\tlog.debug('Setting modified time to %s', mod_time)\n\tmtime = calendar.timegm(mod_time.utctimetuple())\n\t# utctimetuple discards microseconds, so restore it (for consistency)\n\tmtime += mod_time.microsecond / 1000000\n\tatime = os.stat(filename).st_atime\n\tos.utime(filename, (atime, mtime))", "code_tokens": "def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)\n mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )", "docstring_tokens": "Set the modified time of a file", "label": 1}, {"idx": "cosqa-train-4940", "doc": "how do you create percentage in python", "code": "def ratio_and_percentage(current, total, time_remaining):\n    \"\"\"Returns the progress ratio and percentage.\"\"\"\n    return \"{} / {} ({}% completed)\".format(current, total, int(current / total * 100))", "code_tokens": "def ratio_and_percentage ( current , total , time_remaining ) : return \"{} / {} ({}% completed)\" . format ( current , total , int ( current / total * 100 ) )", "docstring_tokens": "Returns the progress ratio and percentage .", "label": 1}, {"idx": "cosqa-train-4941", "doc": "python keras keep models in memory", "code": "def lmx_h1k_f64k():\n  \"\"\"HParams for training languagemodel_lm1b32k_packed.  880M Params.\"\"\"\n  hparams = lmx_base()\n  hparams.hidden_size = 1024\n  hparams.filter_size = 65536\n  hparams.batch_size = 2048\n  return hparams", "code_tokens": "def lmx_h1k_f64k ( ) : hparams = lmx_base ( ) hparams . hidden_size = 1024 hparams . filter_size = 65536 hparams . batch_size = 2048 return hparams", "docstring_tokens": "HParams for training languagemodel_lm1b32k_packed . 880M Params .", "label": 0}, {"idx": "cosqa-train-4942", "doc": "how do you expose all the function in a standard python namesace", "code": "def export(defn):\n    \"\"\"Decorator to explicitly mark functions that are exposed in a lib.\"\"\"\n    globals()[defn.__name__] = defn\n    __all__.append(defn.__name__)\n    return defn", "code_tokens": "def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "docstring_tokens": "Decorator to explicitly mark functions that are exposed in a lib .", "label": 0}, {"idx": "cosqa-train-4943", "doc": "python kill a process tree", "code": "def kill_process_children(pid):\n    \"\"\"Find and kill child processes of a process.\n\n    :param pid: PID of parent process (process ID)\n    :return: Nothing\n    \"\"\"\n    if sys.platform == \"darwin\":\n        kill_process_children_osx(pid)\n    elif sys.platform == \"linux\":\n        kill_process_children_unix(pid)\n    else:\n        pass", "code_tokens": "def kill_process_children ( pid ) : if sys . platform == \"darwin\" : kill_process_children_osx ( pid ) elif sys . platform == \"linux\" : kill_process_children_unix ( pid ) else : pass", "docstring_tokens": "Find and kill child processes of a process .", "label": 1}, {"idx": "cosqa-train-4944", "doc": "how do you extend a list in python", "code": "def extend(self, item):\n        \"\"\"Extend the list with another list. Each member of the list must be\n        a string.\"\"\"\n        if not isinstance(item, list):\n            raise TypeError(\n                'You can only extend lists with lists. '\n                'You supplied \\\"%s\\\"' % type(item))\n        for entry in item:\n            if not isinstance(entry, str):\n                raise TypeError(\n                    'Members of this object must be strings. '\n                    'You supplied \\\"%s\\\"' % type(entry))\n            list.append(self, entry)", "code_tokens": "def extend ( self , item ) : if not isinstance ( item , list ) : raise TypeError ( 'You can only extend lists with lists. ' 'You supplied \\\"%s\\\"' % type ( item ) ) for entry in item : if not isinstance ( entry , str ) : raise TypeError ( 'Members of this object must be strings. ' 'You supplied \\\"%s\\\"' % type ( entry ) ) list . append ( self , entry )", "docstring_tokens": "Extend the list with another list . Each member of the list must be a string .", "label": 1}, {"idx": "cosqa-train-4945", "doc": "python kill process with keyword", "code": "def process_kill(pid, sig=None):\n    \"\"\"Send signal to process.\n    \"\"\"\n    sig = sig or signal.SIGTERM\n    os.kill(pid, sig)", "code_tokens": "def process_kill ( pid , sig = None ) : sig = sig or signal . SIGTERM os . kill ( pid , sig )", "docstring_tokens": "Send signal to process .", "label": 0}, {"idx": "cosqa-train-4946", "doc": "how do you format sql in python", "code": "def prettifysql(sql):\n    \"\"\"Returns a prettified version of the SQL as a list of lines to help\n    in creating a useful diff between two SQL statements.\"\"\"\n    pretty = []\n    for line in sql.split('\\n'):\n        pretty.extend([\"%s,\\n\" % x for x in line.split(',')])\n    return pretty", "code_tokens": "def prettifysql ( sql ) : pretty = [ ] for line in sql . split ( '\\n' ) : pretty . extend ( [ \"%s,\\n\" % x for x in line . split ( ',' ) ] ) return pretty", "docstring_tokens": "Returns a prettified version of the SQL as a list of lines to help in creating a useful diff between two SQL statements .", "label": 1}, {"idx": "cosqa-train-4947", "doc": "python lamba filter with or", "code": "def BROADCAST_FILTER_NOT(func):\n        \"\"\"\n        Composes the passed filters into an and-joined filter.\n        \"\"\"\n        return lambda u, command, *args, **kwargs: not func(u, command, *args, **kwargs)", "code_tokens": "def BROADCAST_FILTER_NOT ( func ) : return lambda u , command , * args , * * kwargs : not func ( u , command , * args , * * kwargs )", "docstring_tokens": "Composes the passed filters into an and - joined filter .", "label": 1}, {"idx": "cosqa-train-4948", "doc": "how do you make a equals in python", "code": "def hard_equals(a, b):\n    \"\"\"Implements the '===' operator.\"\"\"\n    if type(a) != type(b):\n        return False\n    return a == b", "code_tokens": "def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b", "docstring_tokens": "Implements the === operator .", "label": 0}, {"idx": "cosqa-train-4949", "doc": "python lambda function as default arg", "code": "def make_lambda(call):\n    \"\"\"Wrap an AST Call node to lambda expression node.\n    call: ast.Call node\n    \"\"\"\n    empty_args = ast.arguments(args=[], vararg=None, kwarg=None, defaults=[])\n    return ast.Lambda(args=empty_args, body=call)", "code_tokens": "def make_lambda ( call ) : empty_args = ast . arguments ( args = [ ] , vararg = None , kwarg = None , defaults = [ ] ) return ast . Lambda ( args = empty_args , body = call )", "docstring_tokens": "Wrap an AST Call node to lambda expression node . call : ast . Call node", "label": 0}, {"idx": "cosqa-train-4950", "doc": "how do you print the date as a date data type in python", "code": "def print_datetime_object(dt):\n    \"\"\"prints a date-object\"\"\"\n    print(dt)\n    print('ctime  :', dt.ctime())\n    print('tuple  :', dt.timetuple())\n    print('ordinal:', dt.toordinal())\n    print('Year   :', dt.year)\n    print('Mon    :', dt.month)\n    print('Day    :', dt.day)", "code_tokens": "def print_datetime_object ( dt ) : print ( dt ) print ( 'ctime  :' , dt . ctime ( ) ) print ( 'tuple  :' , dt . timetuple ( ) ) print ( 'ordinal:' , dt . toordinal ( ) ) print ( 'Year   :' , dt . year ) print ( 'Mon    :' , dt . month ) print ( 'Day    :' , dt . day )", "docstring_tokens": "prints a date - object", "label": 0}, {"idx": "cosqa-train-4951", "doc": "python leaving a try block early", "code": "def retry_on_signal(function):\n    \"\"\"Retries function until it doesn't raise an EINTR error\"\"\"\n    while True:\n        try:\n            return function()\n        except EnvironmentError, e:\n            if e.errno != errno.EINTR:\n                raise", "code_tokens": "def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise", "docstring_tokens": "Retries function until it doesn t raise an EINTR error", "label": 0}, {"idx": "cosqa-train-4952", "doc": "how do you strip punctuation of string in python", "code": "def _clean_str(self, s):\n        \"\"\" Returns a lowercase string with punctuation and bad chars removed\n        :param s: string to clean\n        \"\"\"\n        return s.translate(str.maketrans('', '', punctuation)).replace('\\u200b', \" \").strip().lower()", "code_tokens": "def _clean_str ( self , s ) : return s . translate ( str . maketrans ( '' , '' , punctuation ) ) . replace ( '\\u200b' , \" \" ) . strip ( ) . lower ( )", "docstring_tokens": "Returns a lowercase string with punctuation and bad chars removed : param s : string to clean", "label": 0}, {"idx": "cosqa-train-4953", "doc": "python left padd with space", "code": "def _pad(self, text):\n        \"\"\"Pad the text.\"\"\"\n        top_bottom = (\"\\n\" * self._padding) + \" \"\n        right_left = \" \" * self._padding * self.PAD_WIDTH\n        return top_bottom + right_left + text + right_left + top_bottom", "code_tokens": "def _pad ( self , text ) : top_bottom = ( \"\\n\" * self . _padding ) + \" \" right_left = \" \" * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom", "docstring_tokens": "Pad the text .", "label": 0}, {"idx": "cosqa-train-4954", "doc": "how do you wrap text in python", "code": "def normalize_text(text, line_len=80, indent=\"\"):\n    \"\"\"Wrap the text on the given line length.\"\"\"\n    return \"\\n\".join(\n        textwrap.wrap(\n            text, width=line_len, initial_indent=indent, subsequent_indent=indent\n        )\n    )", "code_tokens": "def normalize_text ( text , line_len = 80 , indent = \"\" ) : return \"\\n\" . join ( textwrap . wrap ( text , width = line_len , initial_indent = indent , subsequent_indent = indent ) )", "docstring_tokens": "Wrap the text on the given line length .", "label": 0}, {"idx": "cosqa-train-4955", "doc": "python legend with many lines", "code": "def add_plot(x, y, xl, yl, fig, ax, LATEX=False, linestyle=None, **kwargs):\n    \"\"\"Add plots to an existing plot\"\"\"\n    if LATEX:\n        xl_data = xl[1]  # NOQA\n        yl_data = yl[1]\n    else:\n        xl_data = xl[0]  # NOQA\n        yl_data = yl[0]\n\n    for idx in range(len(y)):\n        ax.plot(x, y[idx], label=yl_data[idx], linestyle=linestyle)\n\n    ax.legend(loc='upper right')\n    ax.set_ylim(auto=True)", "code_tokens": "def add_plot ( x , y , xl , yl , fig , ax , LATEX = False , linestyle = None , * * kwargs ) : if LATEX : xl_data = xl [ 1 ] # NOQA yl_data = yl [ 1 ] else : xl_data = xl [ 0 ] # NOQA yl_data = yl [ 0 ] for idx in range ( len ( y ) ) : ax . plot ( x , y [ idx ] , label = yl_data [ idx ] , linestyle = linestyle ) ax . legend ( loc = 'upper right' ) ax . set_ylim ( auto = True )", "docstring_tokens": "Add plots to an existing plot", "label": 0}, {"idx": "cosqa-train-4956", "doc": "how o mak a list object a string python", "code": "def _make_cmd_list(cmd_list):\n    \"\"\"\n    Helper function to easily create the proper json formated string from a list of strs\n    :param cmd_list: list of strings\n    :return: str json formatted\n    \"\"\"\n    cmd = ''\n    for i in cmd_list:\n        cmd = cmd + '\"' + i + '\",'\n    cmd = cmd[:-1]\n    return cmd", "code_tokens": "def _make_cmd_list ( cmd_list ) : cmd = '' for i in cmd_list : cmd = cmd + '\"' + i + '\",' cmd = cmd [ : - 1 ] return cmd", "docstring_tokens": "Helper function to easily create the proper json formated string from a list of strs : param cmd_list : list of strings : return : str json formatted", "label": 0}, {"idx": "cosqa-train-4957", "doc": "python len multi dimenssion list", "code": "def get_dimension_array(array):\n    \"\"\"\n    Get dimension of an array getting the number of rows and the max num of\n    columns.\n    \"\"\"\n    if all(isinstance(el, list) for el in array):\n        result = [len(array), len(max([x for x in array], key=len,))]\n\n    # elif array and isinstance(array, list):\n    else:\n        result = [len(array), 1]\n\n    return result", "code_tokens": "def get_dimension_array ( array ) : if all ( isinstance ( el , list ) for el in array ) : result = [ len ( array ) , len ( max ( [ x for x in array ] , key = len , ) ) ] # elif array and isinstance(array, list): else : result = [ len ( array ) , 1 ] return result", "docstring_tokens": "Get dimension of an array getting the number of rows and the max num of columns .", "label": 1}, {"idx": "cosqa-train-4958", "doc": "how python calculates inverse of matrix", "code": "def inh(table):\n    \"\"\"\n    inverse hyperbolic sine transformation\n    \"\"\"\n    t = []\n    for i in table:\n        t.append(np.ndarray.tolist(np.arcsinh(i)))\n    return t", "code_tokens": "def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "docstring_tokens": "inverse hyperbolic sine transformation", "label": 0}, {"idx": "cosqa-train-4959", "doc": "python list all loggers", "code": "def _get_loggers():\n    \"\"\"Return list of Logger classes.\"\"\"\n    from .. import loader\n    modules = loader.get_package_modules('logger')\n    return list(loader.get_plugins(modules, [_Logger]))", "code_tokens": "def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )", "docstring_tokens": "Return list of Logger classes .", "label": 1}, {"idx": "cosqa-train-4960", "doc": "how quickly check whether a string is in the list python", "code": "def isin(elems, line):\n    \"\"\"Check if an element from a list is in a string.\n\n    :type elems: list\n    :type line: str\n\n    \"\"\"\n    found = False\n    for e in elems:\n        if e in line.lower():\n            found = True\n            break\n    return found", "code_tokens": "def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found", "docstring_tokens": "Check if an element from a list is in a string .", "label": 0}, {"idx": "cosqa-train-4961", "doc": "python list all methods in obj", "code": "def get_methods(*objs):\n    \"\"\" Return the names of all callable attributes of an object\"\"\"\n    return set(\n        attr\n        for obj in objs\n        for attr in dir(obj)\n        if not attr.startswith('_') and callable(getattr(obj, attr))\n    )", "code_tokens": "def get_methods ( * objs ) : return set ( attr for obj in objs for attr in dir ( obj ) if not attr . startswith ( '_' ) and callable ( getattr ( obj , attr ) ) )", "docstring_tokens": "Return the names of all callable attributes of an object", "label": 0}, {"idx": "cosqa-train-4962", "doc": "how read file content python using os", "code": "def read(fname):\n    \"\"\"Quick way to read a file content.\"\"\"\n    content = None\n    with open(os.path.join(here, fname)) as f:\n        content = f.read()\n    return content", "code_tokens": "def read ( fname ) : content = None with open ( os . path . join ( here , fname ) ) as f : content = f . read ( ) return content", "docstring_tokens": "Quick way to read a file content .", "label": 0}, {"idx": "cosqa-train-4963", "doc": "python list dimension check", "code": "def _rectangular(n):\n    \"\"\"Checks to see if a 2D list is a valid 2D matrix\"\"\"\n    for i in n:\n        if len(i) != len(n[0]):\n            return False\n    return True", "code_tokens": "def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True", "docstring_tokens": "Checks to see if a 2D list is a valid 2D matrix", "label": 0}, {"idx": "cosqa-train-4964", "doc": "how t o change seconds(input) to days (string) in python", "code": "def str_time_to_day_seconds(time):\n    \"\"\"\n    Converts time strings to integer seconds\n    :param time: %H:%M:%S string\n    :return: integer seconds\n    \"\"\"\n    t = str(time).split(':')\n    seconds = int(t[0]) * 3600 + int(t[1]) * 60 + int(t[2])\n    return seconds", "code_tokens": "def str_time_to_day_seconds ( time ) : t = str ( time ) . split ( ':' ) seconds = int ( t [ 0 ] ) * 3600 + int ( t [ 1 ] ) * 60 + int ( t [ 2 ] ) return seconds", "docstring_tokens": "Converts time strings to integer seconds : param time : %H : %M : %S string : return : integer seconds", "label": 1}, {"idx": "cosqa-train-4965", "doc": "python list duplicates set", "code": "def remove_dups(seq):\n    \"\"\"remove duplicates from a sequence, preserving order\"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "remove duplicates from a sequence preserving order", "label": 0}, {"idx": "cosqa-train-4966", "doc": "how to access a defined 2d array in python", "code": "def poke_array(self, store, name, elemtype, elements, container, visited, _stack):\n        \"\"\"abstract method\"\"\"\n        raise NotImplementedError", "code_tokens": "def poke_array ( self , store , name , elemtype , elements , container , visited , _stack ) : raise NotImplementedError", "docstring_tokens": "abstract method", "label": 0}, {"idx": "cosqa-train-4967", "doc": "python list get index value default", "code": "def list_get(l, idx, default=None):\n    \"\"\"\n    Get from a list with an optional default value.\n    \"\"\"\n    try:\n        if l[idx]:\n            return l[idx]\n        else:\n            return default\n    except IndexError:\n        return default", "code_tokens": "def list_get ( l , idx , default = None ) : try : if l [ idx ] : return l [ idx ] else : return default except IndexError : return default", "docstring_tokens": "Get from a list with an optional default value .", "label": 1}, {"idx": "cosqa-train-4968", "doc": "how to access a specific element of a sparse matrix python3", "code": "def _first_and_last_element(arr):\n    \"\"\"Returns first and last element of numpy array or sparse matrix.\"\"\"\n    if isinstance(arr, np.ndarray) or hasattr(arr, 'data'):\n        # numpy array or sparse matrix with .data attribute\n        data = arr.data if sparse.issparse(arr) else arr\n        return data.flat[0], data.flat[-1]\n    else:\n        # Sparse matrices without .data attribute. Only dok_matrix at\n        # the time of writing, in this case indexing is fast\n        return arr[0, 0], arr[-1, -1]", "code_tokens": "def _first_and_last_element ( arr ) : if isinstance ( arr , np . ndarray ) or hasattr ( arr , 'data' ) : # numpy array or sparse matrix with .data attribute data = arr . data if sparse . issparse ( arr ) else arr return data . flat [ 0 ] , data . flat [ - 1 ] else : # Sparse matrices without .data attribute. Only dok_matrix at # the time of writing, in this case indexing is fast return arr [ 0 , 0 ] , arr [ - 1 , - 1 ]", "docstring_tokens": "Returns first and last element of numpy array or sparse matrix .", "label": 0}, {"idx": "cosqa-train-4969", "doc": "python list to c double array", "code": "def cfloat64_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes double pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_double)):\n        return np.fromiter(cptr, dtype=np.float64, count=length)\n    else:\n        raise RuntimeError('Expected double pointer')", "code_tokens": "def cfloat64_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_double ) ) : return np . fromiter ( cptr , dtype = np . float64 , count = length ) else : raise RuntimeError ( 'Expected double pointer' )", "docstring_tokens": "Convert a ctypes double pointer array to a numpy array .", "label": 0}, {"idx": "cosqa-train-4970", "doc": "how to access each element in a array python", "code": "def A(*a):\n    \"\"\"convert iterable object into numpy array\"\"\"\n    return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "code_tokens": "def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]", "docstring_tokens": "convert iterable object into numpy array", "label": 0}, {"idx": "cosqa-train-4971", "doc": "python listbox scrollbar not tk", "code": "def __init__(self, master=None, compound=tk.RIGHT, autohidescrollbar=True, **kwargs):\n        \"\"\"\n        Create a Listbox with a vertical scrollbar.\n\n        :param master: master widget\n        :type master: widget\n        :param compound: side for the Scrollbar to be on (:obj:`tk.LEFT` or :obj:`tk.RIGHT`)\n        :type compound: str\n        :param autohidescrollbar: whether to use an :class:`~ttkwidgets.AutoHideScrollbar` or a :class:`ttk.Scrollbar`\n        :type autohidescrollbar: bool\n        :param kwargs: keyword arguments passed on to the :class:`tk.Listbox` initializer\n        \"\"\"\n        ttk.Frame.__init__(self, master)\n        self.columnconfigure(1, weight=1)\n        self.rowconfigure(0, weight=1)\n        self.listbox = tk.Listbox(self, **kwargs)\n        if autohidescrollbar:\n            self.scrollbar = AutoHideScrollbar(self, orient=tk.VERTICAL, command=self.listbox.yview)\n        else:\n            self.scrollbar = ttk.Scrollbar(self, orient=tk.VERTICAL, command=self.listbox.yview)\n        self.config_listbox(yscrollcommand=self.scrollbar.set)\n        if compound is not tk.LEFT and compound is not tk.RIGHT:\n            raise ValueError(\"Invalid compound value passed: {0}\".format(compound))\n        self.__compound = compound\n        self._grid_widgets()", "code_tokens": "def __init__ ( self , master = None , compound = tk . RIGHT , autohidescrollbar = True , * * kwargs ) : ttk . Frame . __init__ ( self , master ) self . columnconfigure ( 1 , weight = 1 ) self . rowconfigure ( 0 , weight = 1 ) self . listbox = tk . Listbox ( self , * * kwargs ) if autohidescrollbar : self . scrollbar = AutoHideScrollbar ( self , orient = tk . VERTICAL , command = self . listbox . yview ) else : self . scrollbar = ttk . Scrollbar ( self , orient = tk . VERTICAL , command = self . listbox . yview ) self . config_listbox ( yscrollcommand = self . scrollbar . set ) if compound is not tk . LEFT and compound is not tk . RIGHT : raise ValueError ( \"Invalid compound value passed: {0}\" . format ( compound ) ) self . __compound = compound self . _grid_widgets ( )", "docstring_tokens": "Create a Listbox with a vertical scrollbar .", "label": 1}, {"idx": "cosqa-train-4972", "doc": "how to access the last row in python in a dataset", "code": "def get_last_row(dbconn, tablename, n=1, uuid=None):\n    \"\"\"\n    Returns the last `n` rows in the table\n    \"\"\"\n    return fetch(dbconn, tablename, n, uuid, end=True)", "code_tokens": "def get_last_row ( dbconn , tablename , n = 1 , uuid = None ) : return fetch ( dbconn , tablename , n , uuid , end = True )", "docstring_tokens": "Returns the last n rows in the table", "label": 0}, {"idx": "cosqa-train-4973", "doc": "python lmdb get all keys", "code": "def keys(self, index=None):\n        \"\"\"Returns a list of keys in the database\n        \"\"\"\n        with self._lmdb.begin() as txn:\n            return [key.decode() for key, _ in txn.cursor()]", "code_tokens": "def keys ( self , index = None ) : with self . _lmdb . begin ( ) as txn : return [ key . decode ( ) for key , _ in txn . cursor ( ) ]", "docstring_tokens": "Returns a list of keys in the database", "label": 1}, {"idx": "cosqa-train-4974", "doc": "how to add a column with the median in python", "code": "def getMedian(numericValues):\n    \"\"\"\n    Gets the median of a list of values\n    Returns a float/int\n    \"\"\"\n    theValues = sorted(numericValues)\n\n    if len(theValues) % 2 == 1:\n        return theValues[(len(theValues) + 1) / 2 - 1]\n    else:\n        lower = theValues[len(theValues) / 2 - 1]\n        upper = theValues[len(theValues) / 2]\n\n        return (float(lower + upper)) / 2", "code_tokens": "def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2", "docstring_tokens": "Gets the median of a list of values Returns a float / int", "label": 0}, {"idx": "cosqa-train-4975", "doc": "python load a dictionary from a file", "code": "def load(cls, fname):\n        \"\"\" Loads the dictionary from json file\n        :param fname: file to load from\n        :return: loaded dictionary\n        \"\"\"\n        with open(fname) as f:\n            return Config(**json.load(f))", "code_tokens": "def load ( cls , fname ) : with open ( fname ) as f : return Config ( * * json . load ( f ) )", "docstring_tokens": "Loads the dictionary from json file : param fname : file to load from : return : loaded dictionary", "label": 0}, {"idx": "cosqa-train-4976", "doc": "how to add header to correlation matrix in python", "code": "def show_correlation_matrix(self, correlation_matrix):\n        \"\"\"Shows the given correlation matrix as image\n\n        :param correlation_matrix: Correlation matrix of features\n        \"\"\"\n        cr_plot.create_correlation_matrix_plot(\n            correlation_matrix, self.title, self.headers_to_test\n        )\n        pyplot.show()", "code_tokens": "def show_correlation_matrix ( self , correlation_matrix ) : cr_plot . create_correlation_matrix_plot ( correlation_matrix , self . title , self . headers_to_test ) pyplot . show ( )", "docstring_tokens": "Shows the given correlation matrix as image", "label": 0}, {"idx": "cosqa-train-4977", "doc": "python load a dll", "code": "def load(self, name):\n        \"\"\"Loads and returns foreign library.\"\"\"\n        name = ctypes.util.find_library(name)\n        return ctypes.cdll.LoadLibrary(name)", "code_tokens": "def load ( self , name ) : name = ctypes . util . find_library ( name ) return ctypes . cdll . LoadLibrary ( name )", "docstring_tokens": "Loads and returns foreign library .", "label": 0}, {"idx": "cosqa-train-4978", "doc": "how to add python to patch", "code": "def unpatch(obj, name):\n    \"\"\"\n    Undo the effects of patch(func, obj, name)\n    \"\"\"\n    setattr(obj, name, getattr(obj, name).original)", "code_tokens": "def unpatch ( obj , name ) : setattr ( obj , name , getattr ( obj , name ) . original )", "docstring_tokens": "Undo the effects of patch ( func obj name )", "label": 0}, {"idx": "cosqa-train-4979", "doc": "python load a properties file", "code": "def load(path):\n    \"\"\"Loads a pushdb maintained in a properties file at the given path.\"\"\"\n    with open(path, 'r') as props:\n      properties = Properties.load(props)\n      return PushDb(properties)", "code_tokens": "def load ( path ) : with open ( path , 'r' ) as props : properties = Properties . load ( props ) return PushDb ( properties )", "docstring_tokens": "Loads a pushdb maintained in a properties file at the given path .", "label": 1}, {"idx": "cosqa-train-4980", "doc": "how to add the width of line in python", "code": "def get_height_for_line(self, lineno):\n        \"\"\"\n        Return the height of the given line.\n        (The height that it would take, if this line became visible.)\n        \"\"\"\n        if self.wrap_lines:\n            return self.ui_content.get_height_for_line(lineno, self.window_width)\n        else:\n            return 1", "code_tokens": "def get_height_for_line ( self , lineno ) : if self . wrap_lines : return self . ui_content . get_height_for_line ( lineno , self . window_width ) else : return 1", "docstring_tokens": "Return the height of the given line . ( The height that it would take if this line became visible . )", "label": 0}, {"idx": "cosqa-train-4981", "doc": "python load an empty pickle", "code": "def load(filename):\n    \"\"\"Load a pickled obj from the filesystem.\n\n    You better know what you expect from the given pickle, because we don't check it.\n\n    Args:\n        filename (str): The filename we load the object from.\n\n    Returns:\n        The object we were able to unpickle, else None.\n    \"\"\"\n    if not os.path.exists(filename):\n        LOG.error(\"load object - File '%s' does not exist.\", filename)\n        return None\n\n    obj = None\n    with open(filename, 'rb') as obj_file:\n        obj = dill.load(obj_file)\n    return obj", "code_tokens": "def load ( filename ) : if not os . path . exists ( filename ) : LOG . error ( \"load object - File '%s' does not exist.\" , filename ) return None obj = None with open ( filename , 'rb' ) as obj_file : obj = dill . load ( obj_file ) return obj", "docstring_tokens": "Load a pickled obj from the filesystem .", "label": 0}, {"idx": "cosqa-train-4982", "doc": "how to add without using built in functions in python", "code": "def generic_add(a, b):\n    \"\"\"Simple function to add two numbers\"\"\"\n    logger.debug('Called generic_add({}, {})'.format(a, b))\n    return a + b", "code_tokens": "def generic_add ( a , b ) : logger . debug ( 'Called generic_add({}, {})' . format ( a , b ) ) return a + b", "docstring_tokens": "Simple function to add two numbers", "label": 0}, {"idx": "cosqa-train-4983", "doc": "python load dot file", "code": "def graph_from_dot_file(path):\n    \"\"\"Load graph as defined by a DOT file.\n    \n    The file is assumed to be in DOT format. It will\n    be loaded, parsed and a Dot class will be returned, \n    representing the graph.\n    \"\"\"\n    \n    fd = file(path, 'rb')\n    data = fd.read()\n    fd.close()\n    \n    return graph_from_dot_data(data)", "code_tokens": "def graph_from_dot_file ( path ) : fd = file ( path , 'rb' ) data = fd . read ( ) fd . close ( ) return graph_from_dot_data ( data )", "docstring_tokens": "Load graph as defined by a DOT file . The file is assumed to be in DOT format . It will be loaded parsed and a Dot class will be returned representing the graph .", "label": 0}, {"idx": "cosqa-train-4984", "doc": "how to add word wrap to python", "code": "def toggle_word_wrap(self):\n        \"\"\"\n        Toggles document word wrap.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        self.setWordWrapMode(not self.wordWrapMode() and QTextOption.WordWrap or QTextOption.NoWrap)\n        return True", "code_tokens": "def toggle_word_wrap ( self ) : self . setWordWrapMode ( not self . wordWrapMode ( ) and QTextOption . WordWrap or QTextOption . NoWrap ) return True", "docstring_tokens": "Toggles document word wrap .", "label": 0}, {"idx": "cosqa-train-4985", "doc": "python load file with utf8", "code": "async def load_unicode(reader):\n    \"\"\"\n    Loads UTF8 string\n    :param reader:\n    :return:\n    \"\"\"\n    ivalue = await load_uvarint(reader)\n    fvalue = bytearray(ivalue)\n    await reader.areadinto(fvalue)\n    return str(fvalue, 'utf8')", "code_tokens": "async def load_unicode ( reader ) : ivalue = await load_uvarint ( reader ) fvalue = bytearray ( ivalue ) await reader . areadinto ( fvalue ) return str ( fvalue , 'utf8' )", "docstring_tokens": "Loads UTF8 string : param reader : : return :", "label": 0}, {"idx": "cosqa-train-4986", "doc": "how to append data to a json file in python", "code": "def store_data(data):\n    \"\"\"Use this function to store data in a JSON file.\n\n    This function is used for loading up a JSON file and appending additional\n    data to the JSON file.\n\n    :param data: the data to add to the JSON file.\n    :type data: dict\n    \"\"\"\n    with open(url_json_path) as json_file:\n        try:\n            json_file_data = load(json_file)\n            json_file_data.update(data)\n        except (AttributeError, JSONDecodeError):\n            json_file_data = data\n    with open(url_json_path, 'w') as json_file:\n        dump(json_file_data, json_file, indent=4, sort_keys=True)", "code_tokens": "def store_data ( data ) : with open ( url_json_path ) as json_file : try : json_file_data = load ( json_file ) json_file_data . update ( data ) except ( AttributeError , JSONDecodeError ) : json_file_data = data with open ( url_json_path , 'w' ) as json_file : dump ( json_file_data , json_file , indent = 4 , sort_keys = True )", "docstring_tokens": "Use this function to store data in a JSON file .", "label": 0}, {"idx": "cosqa-train-4987", "doc": "python load numpy array", "code": "def _openResources(self):\n        \"\"\" Uses numpy.load to open the underlying file\n        \"\"\"\n        arr = np.load(self._fileName, allow_pickle=ALLOW_PICKLE)\n        check_is_an_array(arr)\n        self._array = arr", "code_tokens": "def _openResources ( self ) : arr = np . load ( self . _fileName , allow_pickle = ALLOW_PICKLE ) check_is_an_array ( arr ) self . _array = arr", "docstring_tokens": "Uses numpy . load to open the underlying file", "label": 0}, {"idx": "cosqa-train-4988", "doc": "how to apply function to every column python", "code": "def transform(self, df):\n        \"\"\"\n        Transforms a DataFrame in place. Computes all outputs of the DataFrame.\n\n        Args:\n            df (pandas.DataFrame): DataFrame to transform.\n        \"\"\"\n        for name, function in self.outputs:\n            df[name] = function(df)", "code_tokens": "def transform ( self , df ) : for name , function in self . outputs : df [ name ] = function ( df )", "docstring_tokens": "Transforms a DataFrame in place . Computes all outputs of the DataFrame .", "label": 1}, {"idx": "cosqa-train-4989", "doc": "python load pickle model", "code": "def load(self, path):\n        \"\"\"Load the pickled model weights.\"\"\"\n        with io.open(path, 'rb') as fin:\n            self.weights = pickle.load(fin)", "code_tokens": "def load ( self , path ) : with io . open ( path , 'rb' ) as fin : self . weights = pickle . load ( fin )", "docstring_tokens": "Load the pickled model weights .", "label": 0}, {"idx": "cosqa-train-4990", "doc": "how to ask if item is directory in python", "code": "def _IsDirectory(parent, item):\n  \"\"\"Helper that returns if parent/item is a directory.\"\"\"\n  return tf.io.gfile.isdir(os.path.join(parent, item))", "code_tokens": "def _IsDirectory ( parent , item ) : return tf . io . gfile . isdir ( os . path . join ( parent , item ) )", "docstring_tokens": "Helper that returns if parent / item is a directory .", "label": 1}, {"idx": "cosqa-train-4991", "doc": "python load text from a file", "code": "def Load(file):\n    \"\"\" Loads a model from specified file \"\"\"\n    with open(file, 'rb') as file:\n        model = dill.load(file)\n        return model", "code_tokens": "def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model", "docstring_tokens": "Loads a model from specified file", "label": 0}, {"idx": "cosqa-train-4992", "doc": "how to average colors in python grayscale", "code": "def get_average_color(colors):\n    \"\"\"Calculate the average color from the list of colors, where each color\n    is a 3-tuple of (r, g, b) values.\n    \"\"\"\n    c = reduce(color_reducer, colors)\n    total = len(colors)\n    return tuple(v / total for v in c)", "code_tokens": "def get_average_color ( colors ) : c = reduce ( color_reducer , colors ) total = len ( colors ) return tuple ( v / total for v in c )", "docstring_tokens": "Calculate the average color from the list of colors where each color is a 3 - tuple of ( r g b ) values .", "label": 1}, {"idx": "cosqa-train-4993", "doc": "python locate index for certain value", "code": "def elem_find(self, field, value):\n        \"\"\"\n        Return the indices of elements whose field first satisfies the given values\n\n        ``value`` should be unique in self.field.\n        This function does not check the uniqueness.\n\n        :param field: name of the supplied field\n        :param value: value of field of the elemtn to find\n        :return: idx of the elements\n        :rtype: list, int, float, str\n        \"\"\"\n        if isinstance(value, (int, float, str)):\n            value = [value]\n\n        f = list(self.__dict__[field])\n        uid = np.vectorize(f.index)(value)\n        return self.get_idx(uid)", "code_tokens": "def elem_find ( self , field , value ) : if isinstance ( value , ( int , float , str ) ) : value = [ value ] f = list ( self . __dict__ [ field ] ) uid = np . vectorize ( f . index ) ( value ) return self . get_idx ( uid )", "docstring_tokens": "Return the indices of elements whose field first satisfies the given values", "label": 0}, {"idx": "cosqa-train-4994", "doc": "how to bold titlein python pie char", "code": "def camel_case(self, snake_case):\n        \"\"\" Convert snake case to camel case \"\"\"\n        components = snake_case.split('_')\n        return components[0] + \"\".join(x.title() for x in components[1:])", "code_tokens": "def camel_case ( self , snake_case ) : components = snake_case . split ( '_' ) return components [ 0 ] + \"\" . join ( x . title ( ) for x in components [ 1 : ] )", "docstring_tokens": "Convert snake case to camel case", "label": 0}, {"idx": "cosqa-train-4995", "doc": "python lock access to the same variable", "code": "def lock(self, block=True):\n\t\t\"\"\"\n\t\tLock connection from being used else where\n\t\t\"\"\"\n\t\tself._locked = True\n\t\treturn self._lock.acquire(block)", "code_tokens": "def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )", "docstring_tokens": "Lock connection from being used else where", "label": 1}, {"idx": "cosqa-train-4996", "doc": "how to cache multiple functions python", "code": "def simple_memoize(callable_object):\n    \"\"\"Simple memoization for functions without keyword arguments.\n\n    This is useful for mapping code objects to module in this context.\n    inspect.getmodule() requires a number of system calls, which may slow down\n    the tracing considerably. Caching the mapping from code objects (there is\n    *one* code object for each function, regardless of how many simultaneous\n    activations records there are).\n\n    In this context we can ignore keyword arguments, but a generic memoizer\n    ought to take care of that as well.\n    \"\"\"\n\n    cache = dict()\n\n    def wrapper(*rest):\n        if rest not in cache:\n            cache[rest] = callable_object(*rest)\n        return cache[rest]\n\n    return wrapper", "code_tokens": "def simple_memoize ( callable_object ) : cache = dict ( ) def wrapper ( * rest ) : if rest not in cache : cache [ rest ] = callable_object ( * rest ) return cache [ rest ] return wrapper", "docstring_tokens": "Simple memoization for functions without keyword arguments .", "label": 0}, {"idx": "cosqa-train-4997", "doc": "python lock mouse and keyboard", "code": "def buttonUp(self, button=mouse.LEFT):\n        \"\"\" Releases the specified mouse button.\n\n        Use Mouse.LEFT, Mouse.MIDDLE, Mouse.RIGHT\n        \"\"\"\n        self._lock.acquire()\n        mouse.release(button)\n        self._lock.release()", "code_tokens": "def buttonUp ( self , button = mouse . LEFT ) : self . _lock . acquire ( ) mouse . release ( button ) self . _lock . release ( )", "docstring_tokens": "Releases the specified mouse button .", "label": 0}, {"idx": "cosqa-train-4998", "doc": "how to calculate moving average python", "code": "def moving_average(array, n=3):\n    \"\"\"\n    Calculates the moving average of an array.\n\n    Parameters\n    ----------\n    array : array\n        The array to have the moving average taken of\n    n : int\n        The number of points of moving average to take\n    \n    Returns\n    -------\n    MovingAverageArray : array\n        The n-point moving average of the input array\n    \"\"\"\n    ret = _np.cumsum(array, dtype=float)\n    ret[n:] = ret[n:] - ret[:-n]\n    return ret[n - 1:] / n", "code_tokens": "def moving_average ( array , n = 3 ) : ret = _np . cumsum ( array , dtype = float ) ret [ n : ] = ret [ n : ] - ret [ : - n ] return ret [ n - 1 : ] / n", "docstring_tokens": "Calculates the moving average of an array .", "label": 1}, {"idx": "cosqa-train-4999", "doc": "python lock object for use", "code": "def lock(self, block=True):\n\t\t\"\"\"\n\t\tLock connection from being used else where\n\t\t\"\"\"\n\t\tself._locked = True\n\t\treturn self._lock.acquire(block)", "code_tokens": "def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )", "docstring_tokens": "Lock connection from being used else where", "label": 1}, {"idx": "cosqa-train-5000", "doc": "how to capitalize only the first letter of a string in python", "code": "def to_capitalized_camel_case(snake_case_string):\n    \"\"\"\n    Convert a string from snake case to camel case with the first letter capitalized. For example, \"some_var\"\n    would become \"SomeVar\".\n\n    :param snake_case_string: Snake-cased string to convert to camel case.\n    :returns: Camel-cased version of snake_case_string.\n    \"\"\"\n    parts = snake_case_string.split('_')\n    return ''.join([i.title() for i in parts])", "code_tokens": "def to_capitalized_camel_case ( snake_case_string ) : parts = snake_case_string . split ( '_' ) return '' . join ( [ i . title ( ) for i in parts ] )", "docstring_tokens": "Convert a string from snake case to camel case with the first letter capitalized . For example some_var would become SomeVar .", "label": 1}, {"idx": "cosqa-train-5001", "doc": "python log and fft of complex number numpy", "code": "def log_magnitude_spectrum(frames):\n    \"\"\"Compute the log of the magnitude spectrum of frames\"\"\"\n    return N.log(N.abs(N.fft.rfft(frames)).clip(1e-5, N.inf))", "code_tokens": "def log_magnitude_spectrum ( frames ) : return N . log ( N . abs ( N . fft . rfft ( frames ) ) . clip ( 1e-5 , N . inf ) )", "docstring_tokens": "Compute the log of the magnitude spectrum of frames", "label": 0}, {"idx": "cosqa-train-5002", "doc": "how to change a byte object to str type in python", "code": "def to_str(obj):\n    \"\"\"Attempts to convert given object to a string object\n    \"\"\"\n    if not isinstance(obj, str) and PY3 and isinstance(obj, bytes):\n        obj = obj.decode('utf-8')\n    return obj if isinstance(obj, string_types) else str(obj)", "code_tokens": "def to_str ( obj ) : if not isinstance ( obj , str ) and PY3 and isinstance ( obj , bytes ) : obj = obj . decode ( 'utf-8' ) return obj if isinstance ( obj , string_types ) else str ( obj )", "docstring_tokens": "Attempts to convert given object to a string object", "label": 0}, {"idx": "cosqa-train-5003", "doc": "python log loss function", "code": "def log_loss(preds, labels):\n    \"\"\"Logarithmic loss with non-necessarily-binary labels.\"\"\"\n    log_likelihood = np.sum(labels * np.log(preds)) / len(preds)\n    return -log_likelihood", "code_tokens": "def log_loss ( preds , labels ) : log_likelihood = np . sum ( labels * np . log ( preds ) ) / len ( preds ) return - log_likelihood", "docstring_tokens": "Logarithmic loss with non - necessarily - binary labels .", "label": 0}, {"idx": "cosqa-train-5004", "doc": "how to change a datetime to the beginnig of a month python", "code": "def start_of_month(val):\n    \"\"\"\n    Return a new datetime.datetime object with values that represent\n    a start of a month.\n    :param val: Date to ...\n    :type val: datetime.datetime | datetime.date\n    :rtype: datetime.datetime\n    \"\"\"\n    if type(val) == date:\n        val = datetime.fromordinal(val.toordinal())\n    return start_of_day(val).replace(day=1)", "code_tokens": "def start_of_month ( val ) : if type ( val ) == date : val = datetime . fromordinal ( val . toordinal ( ) ) return start_of_day ( val ) . replace ( day = 1 )", "docstring_tokens": "Return a new datetime . datetime object with values that represent a start of a month . : param val : Date to ... : type val : datetime . datetime | datetime . date : rtype : datetime . datetime", "label": 1}, {"idx": "cosqa-train-5005", "doc": "python logging config file dict args", "code": "def load_config(filename=\"logging.ini\", *args, **kwargs):\n    \"\"\"\n    Load logger config from file\n    \n    Keyword arguments:\n    filename -- configuration filename (Default: \"logging.ini\")\n    *args -- options passed to fileConfig\n    **kwargs -- options passed to fileConfigg\n    \n    \"\"\"\n    logging.config.fileConfig(filename, *args, **kwargs)", "code_tokens": "def load_config ( filename = \"logging.ini\" , * args , * * kwargs ) : logging . config . fileConfig ( filename , * args , * * kwargs )", "docstring_tokens": "Load logger config from file Keyword arguments : filename -- configuration filename ( Default : logging . ini ) * args -- options passed to fileConfig ** kwargs -- options passed to fileConfigg", "label": 0}, {"idx": "cosqa-train-5006", "doc": "how to change a graph to have log in python", "code": "def make_stream_handler(graph, formatter):\n    \"\"\"\n    Create the stream handler. Used for console/debug output.\n\n    \"\"\"\n    return {\n        \"class\": graph.config.logging.stream_handler.class_,\n        \"formatter\": formatter,\n        \"level\": graph.config.logging.level,\n        \"stream\": graph.config.logging.stream_handler.stream,\n    }", "code_tokens": "def make_stream_handler ( graph , formatter ) : return { \"class\" : graph . config . logging . stream_handler . class_ , \"formatter\" : formatter , \"level\" : graph . config . logging . level , \"stream\" : graph . config . logging . stream_handler . stream , }", "docstring_tokens": "Create the stream handler . Used for console / debug output .", "label": 0}, {"idx": "cosqa-train-5007", "doc": "python logging define new logging name", "code": "def logger(message, level=10):\n    \"\"\"Handle logging.\"\"\"\n    logging.getLogger(__name__).log(level, str(message))", "code_tokens": "def logger ( message , level = 10 ) : logging . getLogger ( __name__ ) . log ( level , str ( message ) )", "docstring_tokens": "Handle logging .", "label": 0}, {"idx": "cosqa-train-5008", "doc": "how to change a list to string inpython", "code": "def list_i2str(ilist):\n    \"\"\"\n    Convert an integer list into a string list.\n    \"\"\"\n    slist = []\n    for el in ilist:\n        slist.append(str(el))\n    return slist", "code_tokens": "def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist", "docstring_tokens": "Convert an integer list into a string list .", "label": 0}, {"idx": "cosqa-train-5009", "doc": "python logging get file name of calling function", "code": "def GetLoggingLocation():\n  \"\"\"Search for and return the file and line number from the log collector.\n\n  Returns:\n    (pathname, lineno, func_name) The full path, line number, and function name\n    for the logpoint location.\n  \"\"\"\n  frame = inspect.currentframe()\n  this_file = frame.f_code.co_filename\n  frame = frame.f_back\n  while frame:\n    if this_file == frame.f_code.co_filename:\n      if 'cdbg_logging_location' in frame.f_locals:\n        ret = frame.f_locals['cdbg_logging_location']\n        if len(ret) != 3:\n          return (None, None, None)\n        return ret\n    frame = frame.f_back\n  return (None, None, None)", "code_tokens": "def GetLoggingLocation ( ) : frame = inspect . currentframe ( ) this_file = frame . f_code . co_filename frame = frame . f_back while frame : if this_file == frame . f_code . co_filename : if 'cdbg_logging_location' in frame . f_locals : ret = frame . f_locals [ 'cdbg_logging_location' ] if len ( ret ) != 3 : return ( None , None , None ) return ret frame = frame . f_back return ( None , None , None )", "docstring_tokens": "Search for and return the file and line number from the log collector .", "label": 0}, {"idx": "cosqa-train-5010", "doc": "how to change a number to binary python without b", "code": "def intToBin(i):\n    \"\"\" Integer to two bytes \"\"\"\n    # devide in two parts (bytes)\n    i1 = i % 256\n    i2 = int(i / 256)\n    # make string (little endian)\n    return chr(i1) + chr(i2)", "code_tokens": "def intToBin ( i ) : # devide in two parts (bytes) i1 = i % 256 i2 = int ( i / 256 ) # make string (little endian) return chr ( i1 ) + chr ( i2 )", "docstring_tokens": "Integer to two bytes", "label": 0}, {"idx": "cosqa-train-5011", "doc": "python logging message format strings", "code": "def debug(self, text):\n\t\t\"\"\" Ajout d'un message de log de type DEBUG \"\"\"\n\t\tself.logger.debug(\"{}{}\".format(self.message_prefix, text))", "code_tokens": "def debug ( self , text ) : self . logger . debug ( \"{}{}\" . format ( self . message_prefix , text ) )", "docstring_tokens": "Ajout d un message de log de type DEBUG", "label": 0}, {"idx": "cosqa-train-5012", "doc": "how to change accented characters into non accent ones in python", "code": "def unaccentuate(s):\n    \"\"\" Replace accentuated chars in string by their non accentuated equivalent. \"\"\"\n    return \"\".join(c for c in unicodedata.normalize(\"NFKD\", s) if not unicodedata.combining(c))", "code_tokens": "def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "docstring_tokens": "Replace accentuated chars in string by their non accentuated equivalent .", "label": 0}, {"idx": "cosqa-train-5013", "doc": "python logging not flush to file", "code": "def log_no_newline(self, msg):\n      \"\"\" print the message to the predefined log file without newline \"\"\"\n      self.print2file(self.logfile, False, False, msg)", "code_tokens": "def log_no_newline ( self , msg ) : self . print2file ( self . logfile , False , False , msg )", "docstring_tokens": "print the message to the predefined log file without newline", "label": 0}, {"idx": "cosqa-train-5014", "doc": "how to change an object to a date in python", "code": "def QA_util_datetime_to_strdate(dt):\n    \"\"\"\n    :param dt:  pythone datetime.datetime\n    :return:  1999-02-01 string type\n    \"\"\"\n    strdate = \"%04d-%02d-%02d\" % (dt.year, dt.month, dt.day)\n    return strdate", "code_tokens": "def QA_util_datetime_to_strdate ( dt ) : strdate = \"%04d-%02d-%02d\" % ( dt . year , dt . month , dt . day ) return strdate", "docstring_tokens": ": param dt : pythone datetime . datetime : return : 1999 - 02 - 01 string type", "label": 0}, {"idx": "cosqa-train-5015", "doc": "python logging rotatingfilehandler add to basic", "code": "def timed_rotating_file_handler(name, logname, filename, when='h',\n                                interval=1, backupCount=0,\n                                encoding=None, delay=False, utc=False):\n    \"\"\"\n    A Bark logging handler logging output to a named file.  At\n    intervals specified by the 'when', the file will be rotated, under\n    control of 'backupCount'.\n\n    Similar to logging.handlers.TimedRotatingFileHandler.\n    \"\"\"\n\n    return wrap_log_handler(logging.handlers.TimedRotatingFileHandler(\n        filename, when=when, interval=interval, backupCount=backupCount,\n        encoding=encoding, delay=delay, utc=utc))", "code_tokens": "def timed_rotating_file_handler ( name , logname , filename , when = 'h' , interval = 1 , backupCount = 0 , encoding = None , delay = False , utc = False ) : return wrap_log_handler ( logging . handlers . TimedRotatingFileHandler ( filename , when = when , interval = interval , backupCount = backupCount , encoding = encoding , delay = delay , utc = utc ) )", "docstring_tokens": "A Bark logging handler logging output to a named file . At intervals specified by the when the file will be rotated under control of backupCount .", "label": 0}, {"idx": "cosqa-train-5016", "doc": "how to change axis limits python", "code": "def _set_axis_limits(self, which, lims, d, scale, reverse=False):\n        \"\"\"Private method for setting axis limits.\n\n        Sets the axis limits on each axis for an individual plot.\n\n        Args:\n            which (str): The indicator of which part of the plots\n                to adjust. This currently handles `x` and `y`.\n            lims (len-2 list of floats): The limits for the axis.\n            d (float): Amount to increment by between the limits.\n            scale (str): Scale of the axis. Either `log` or `lin`.\n            reverse (bool, optional): If True, reverse the axis tick marks. Default is False.\n\n        \"\"\"\n        setattr(self.limits, which + 'lims', lims)\n        setattr(self.limits, 'd' + which, d)\n        setattr(self.limits, which + 'scale', scale)\n\n        if reverse:\n            setattr(self.limits, 'reverse_' + which + '_axis', True)\n        return", "code_tokens": "def _set_axis_limits ( self , which , lims , d , scale , reverse = False ) : setattr ( self . limits , which + 'lims' , lims ) setattr ( self . limits , 'd' + which , d ) setattr ( self . limits , which + 'scale' , scale ) if reverse : setattr ( self . limits , 'reverse_' + which + '_axis' , True ) return", "docstring_tokens": "Private method for setting axis limits .", "label": 0}, {"idx": "cosqa-train-5017", "doc": "python longest consecutive number in array", "code": "def longest_run(da, dim='time'):\n    \"\"\"Return the length of the longest consecutive run of True values.\n\n        Parameters\n        ----------\n        arr : N-dimensional array (boolean)\n          Input array\n        dim : Xarray dimension (default = 'time')\n          Dimension along which to calculate consecutive run\n\n        Returns\n        -------\n        N-dimensional array (int)\n          Length of longest run of True values along dimension\n        \"\"\"\n\n    d = rle(da, dim=dim)\n    rl_long = d.max(dim=dim)\n\n    return rl_long", "code_tokens": "def longest_run ( da , dim = 'time' ) : d = rle ( da , dim = dim ) rl_long = d . max ( dim = dim ) return rl_long", "docstring_tokens": "Return the length of the longest consecutive run of True values .", "label": 0}, {"idx": "cosqa-train-5018", "doc": "how to change color of print in python", "code": "def auto():\n\t\"\"\"set colouring on if STDOUT is a terminal device, off otherwise\"\"\"\n\ttry:\n\t\tStyle.enabled = False\n\t\tStyle.enabled = sys.stdout.isatty()\n\texcept (AttributeError, TypeError):\n\t\tpass", "code_tokens": "def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass", "docstring_tokens": "set colouring on if STDOUT is a terminal device off otherwise", "label": 1}, {"idx": "cosqa-train-5019", "doc": "python looking for function comments in python file", "code": "def parse_comments_for_file(filename):\n    \"\"\"\n    Return a list of all parsed comments in a file.  Mostly for testing &\n    interactive use.\n    \"\"\"\n    return [parse_comment(strip_stars(comment), next_line)\n            for comment, next_line in get_doc_comments(read_file(filename))]", "code_tokens": "def parse_comments_for_file ( filename ) : return [ parse_comment ( strip_stars ( comment ) , next_line ) for comment , next_line in get_doc_comments ( read_file ( filename ) ) ]", "docstring_tokens": "Return a list of all parsed comments in a file . Mostly for testing & interactive use .", "label": 0}, {"idx": "cosqa-train-5020", "doc": "how to change numpy array to list in python", "code": "def A(*a):\n    \"\"\"convert iterable object into numpy array\"\"\"\n    return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "code_tokens": "def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]", "docstring_tokens": "convert iterable object into numpy array", "label": 1}, {"idx": "cosqa-train-5021", "doc": "python loop next skip", "code": "def skip(self, n):\n        \"\"\"Skip the specified number of elements in the list.\n\n        If the number skipped is greater than the number of elements in\n        the list, hasNext() becomes false and available() returns zero\n        as there are no more elements to retrieve.\n\n        arg:    n (cardinal): the number of elements to skip\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        try:\n            self._iter_object.skip(n)\n        except AttributeError:\n            for i in range(0, n):\n                self.next()", "code_tokens": "def skip ( self , n ) : try : self . _iter_object . skip ( n ) except AttributeError : for i in range ( 0 , n ) : self . next ( )", "docstring_tokens": "Skip the specified number of elements in the list .", "label": 0}, {"idx": "cosqa-train-5022", "doc": "how to change python codec", "code": "def b(s):\n\t\"\"\" Encodes Unicode strings to byte strings, if necessary. \"\"\"\n\n\treturn s if isinstance(s, bytes) else s.encode(locale.getpreferredencoding())", "code_tokens": "def b ( s ) : return s if isinstance ( s , bytes ) else s . encode ( locale . getpreferredencoding ( ) )", "docstring_tokens": "Encodes Unicode strings to byte strings if necessary .", "label": 0}, {"idx": "cosqa-train-5023", "doc": "python mac get contents of clipboard", "code": "def osx_clipboard_get():\n    \"\"\" Get the clipboard's text on OS X.\n    \"\"\"\n    p = subprocess.Popen(['pbpaste', '-Prefer', 'ascii'],\n        stdout=subprocess.PIPE)\n    text, stderr = p.communicate()\n    # Text comes in with old Mac \\r line endings. Change them to \\n.\n    text = text.replace('\\r', '\\n')\n    return text", "code_tokens": "def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \\r line endings. Change them to \\n. text = text . replace ( '\\r' , '\\n' ) return text", "docstring_tokens": "Get the clipboard s text on OS X .", "label": 1}, {"idx": "cosqa-train-5024", "doc": "how to change python print precision", "code": "def pprint(obj, verbose=False, max_width=79, newline='\\n'):\n    \"\"\"\n    Like `pretty` but print to stdout.\n    \"\"\"\n    printer = RepresentationPrinter(sys.stdout, verbose, max_width, newline)\n    printer.pretty(obj)\n    printer.flush()\n    sys.stdout.write(newline)\n    sys.stdout.flush()", "code_tokens": "def pprint ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )", "docstring_tokens": "Like pretty but print to stdout .", "label": 0}, {"idx": "cosqa-train-5025", "doc": "python magickmock how to set valye to property", "code": "def mock_add_spec(self, spec, spec_set=False):\n        \"\"\"Add a spec to a mock. `spec` can either be an object or a\n        list of strings. Only attributes on the `spec` can be fetched as\n        attributes from the mock.\n\n        If `spec_set` is True then only attributes on the spec can be set.\"\"\"\n        self._mock_add_spec(spec, spec_set)\n        self._mock_set_magics()", "code_tokens": "def mock_add_spec ( self , spec , spec_set = False ) : self . _mock_add_spec ( spec , spec_set ) self . _mock_set_magics ( )", "docstring_tokens": "Add a spec to a mock . spec can either be an object or a list of strings . Only attributes on the spec can be fetched as attributes from the mock .", "label": 0}, {"idx": "cosqa-train-5026", "doc": "how to change text color in python", "code": "def ansi(color, text):\n    \"\"\"Wrap text in an ansi escape sequence\"\"\"\n    code = COLOR_CODES[color]\n    return '\\033[1;{0}m{1}{2}'.format(code, text, RESET_TERM)", "code_tokens": "def ansi ( color , text ) : code = COLOR_CODES [ color ] return '\\033[1;{0}m{1}{2}' . format ( code , text , RESET_TERM )", "docstring_tokens": "Wrap text in an ansi escape sequence", "label": 1}, {"idx": "cosqa-train-5027", "doc": "python make a dictionary from string", "code": "def list_string_to_dict(string):\n    \"\"\"Inputs ``['a', 'b', 'c']``, returns ``{'a': 0, 'b': 1, 'c': 2}``.\"\"\"\n    dictionary = {}\n    for idx, c in enumerate(string):\n        dictionary.update({c: idx})\n    return dictionary", "code_tokens": "def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary", "docstring_tokens": "Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } .", "label": 0}, {"idx": "cosqa-train-5028", "doc": "how to change the background to a image in python", "code": "def copy_image_on_background(image, color=WHITE):\n    \"\"\"\n    Create a new image by copying the image on a *color* background.\n\n    Args:\n        image (PIL.Image.Image): Image to copy\n        color (tuple): Background color usually WHITE or BLACK\n\n    Returns:\n        PIL.Image.Image\n\n    \"\"\"\n    background = Image.new(\"RGB\", image.size, color)\n    background.paste(image, mask=image.split()[3])\n    return background", "code_tokens": "def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( \"RGB\" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background", "docstring_tokens": "Create a new image by copying the image on a * color * background .", "label": 1}, {"idx": "cosqa-train-5029", "doc": "python make a file read only", "code": "def fopenat(base_fd, path):\n    \"\"\"\n    Does openat read-only, then does fdopen to get a file object\n    \"\"\"\n\n    return os.fdopen(openat(base_fd, path, os.O_RDONLY), 'rb')", "code_tokens": "def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )", "docstring_tokens": "Does openat read - only then does fdopen to get a file object", "label": 0}, {"idx": "cosqa-train-5030", "doc": "how to change the color of strings in python", "code": "def colorize(string, color, *args, **kwargs):\n    \"\"\"\n    Implements string formatting along with color specified in colorama.Fore\n    \"\"\"\n    string = string.format(*args, **kwargs)\n    return color + string + colorama.Fore.RESET", "code_tokens": "def colorize ( string , color , * args , * * kwargs ) : string = string . format ( * args , * * kwargs ) return color + string + colorama . Fore . RESET", "docstring_tokens": "Implements string formatting along with color specified in colorama . Fore", "label": 0}, {"idx": "cosqa-train-5031", "doc": "python make an object picklable", "code": "def unpickle_stats(stats):\n    \"\"\"Unpickle a pstats.Stats object\"\"\"\n    stats = cPickle.loads(stats)\n    stats.stream = True\n    return stats", "code_tokens": "def unpickle_stats ( stats ) : stats = cPickle . loads ( stats ) stats . stream = True return stats", "docstring_tokens": "Unpickle a pstats . Stats object", "label": 1}, {"idx": "cosqa-train-5032", "doc": "how to change the mod of a python file in windows", "code": "def set_executable(filename):\n    \"\"\"Set the exectuable bit on the given filename\"\"\"\n    st = os.stat(filename)\n    os.chmod(filename, st.st_mode | stat.S_IEXEC)", "code_tokens": "def set_executable ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "docstring_tokens": "Set the exectuable bit on the given filename", "label": 0}, {"idx": "cosqa-train-5033", "doc": "python make multiple string replacements at once", "code": "def multi_replace(instr, search_list=[], repl_list=None):\n    \"\"\"\n    Does a string replace with a list of search and replacements\n\n    TODO: rename\n    \"\"\"\n    repl_list = [''] * len(search_list) if repl_list is None else repl_list\n    for ser, repl in zip(search_list, repl_list):\n        instr = instr.replace(ser, repl)\n    return instr", "code_tokens": "def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr", "docstring_tokens": "Does a string replace with a list of search and replacements", "label": 0}, {"idx": "cosqa-train-5034", "doc": "how to change the name of a column in data frame python", "code": "def col_rename(df,col_name,new_col_name):\n    \"\"\" Changes a column name in a DataFrame\n    Parameters:\n    df - DataFrame\n        DataFrame to operate on\n    col_name - string\n        Name of column to change\n    new_col_name - string\n        New name of column\n    \"\"\"\n    col_list = list(df.columns)\n    for index,value in enumerate(col_list):\n        if value == col_name:\n            col_list[index] = new_col_name\n            break\n    df.columns = col_list", "code_tokens": "def col_rename ( df , col_name , new_col_name ) : col_list = list ( df . columns ) for index , value in enumerate ( col_list ) : if value == col_name : col_list [ index ] = new_col_name break df . columns = col_list", "docstring_tokens": "Changes a column name in a DataFrame Parameters : df - DataFrame DataFrame to operate on col_name - string Name of column to change new_col_name - string New name of column", "label": 0}, {"idx": "cosqa-train-5035", "doc": "python make strin array a column", "code": "def bitsToString(arr):\n  \"\"\"Returns a string representing a numpy array of 0's and 1's\"\"\"\n  s = array('c','.'*len(arr))\n  for i in xrange(len(arr)):\n    if arr[i] == 1:\n      s[i]='*'\n  return s", "code_tokens": "def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s", "docstring_tokens": "Returns a string representing a numpy array of 0 s and 1 s", "label": 0}, {"idx": "cosqa-train-5036", "doc": "how to change the title of a window python", "code": "def title(msg):\n    \"\"\"Sets the title of the console window.\"\"\"\n    if sys.platform.startswith(\"win\"):\n        ctypes.windll.kernel32.SetConsoleTitleW(tounicode(msg))", "code_tokens": "def title ( msg ) : if sys . platform . startswith ( \"win\" ) : ctypes . windll . kernel32 . SetConsoleTitleW ( tounicode ( msg ) )", "docstring_tokens": "Sets the title of the console window .", "label": 1}, {"idx": "cosqa-train-5037", "doc": "python make url query string", "code": "def create_search_url(self):\n        \"\"\" Generates (urlencoded) query string from stored key-values tuples\n\n        :returns: A string containing all arguments in a url-encoded format\n        \"\"\"\n\n        url = '?'\n        for key, value in self.arguments.items():\n            url += '%s=%s&' % (quote_plus(key), quote_plus(value))\n        self.url = url[:-1]\n        return self.url", "code_tokens": "def create_search_url ( self ) : url = '?' for key , value in self . arguments . items ( ) : url += '%s=%s&' % ( quote_plus ( key ) , quote_plus ( value ) ) self . url = url [ : - 1 ] return self . url", "docstring_tokens": "Generates ( urlencoded ) query string from stored key - values tuples", "label": 0}, {"idx": "cosqa-train-5038", "doc": "how to change user agent in python", "code": "def append_user_agent(self, user_agent):\n        \"\"\"Append text to the User-Agent header for the request.\n\n        Use this method to update the User-Agent header by appending the\n        given string to the session's User-Agent header separated by a space.\n\n        :param user_agent: A string to append to the User-Agent header\n        :type user_agent: str\n        \"\"\"\n        old_ua = self.session.headers.get('User-Agent', '')\n        ua = old_ua + ' ' + user_agent\n        self.session.headers['User-Agent'] = ua.strip()", "code_tokens": "def append_user_agent ( self , user_agent ) : old_ua = self . session . headers . get ( 'User-Agent' , '' ) ua = old_ua + ' ' + user_agent self . session . headers [ 'User-Agent' ] = ua . strip ( )", "docstring_tokens": "Append text to the User - Agent header for the request .", "label": 0}, {"idx": "cosqa-train-5039", "doc": "python makedirs if not exist", "code": "def makedirs(path):\n    \"\"\"\n    Create directories if they do not exist, otherwise do nothing.\n\n    Return path for convenience\n    \"\"\"\n    if not os.path.isdir(path):\n        os.makedirs(path)\n    return path", "code_tokens": "def makedirs ( path ) : if not os . path . isdir ( path ) : os . makedirs ( path ) return path", "docstring_tokens": "Create directories if they do not exist otherwise do nothing .", "label": 0}, {"idx": "cosqa-train-5040", "doc": "how to check a for an int in a string in python", "code": "def str2int(string_with_int):\n    \"\"\" Collect digits from a string \"\"\"\n    return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)", "code_tokens": "def str2int ( string_with_int ) : return int ( \"\" . join ( [ char for char in string_with_int if char in string . digits ] ) or 0 )", "docstring_tokens": "Collect digits from a string", "label": 1}, {"idx": "cosqa-train-5041", "doc": "python makes not iterable to iterable", "code": "def force_iterable(f):\n    \"\"\"Will make any functions return an iterable objects by wrapping its result in a list.\"\"\"\n    def wrapper(*args, **kwargs):\n        r = f(*args, **kwargs)\n        if hasattr(r, '__iter__'):\n            return r\n        else:\n            return [r]\n    return wrapper", "code_tokens": "def force_iterable ( f ) : def wrapper ( * args , * * kwargs ) : r = f ( * args , * * kwargs ) if hasattr ( r , '__iter__' ) : return r else : return [ r ] return wrapper", "docstring_tokens": "Will make any functions return an iterable objects by wrapping its result in a list .", "label": 0}, {"idx": "cosqa-train-5042", "doc": "how to check data type of elements of array python", "code": "def _valid_other_type(x, types):\n    \"\"\"\n    Do all elements of x have a type from types?\n    \"\"\"\n    return all(any(isinstance(el, t) for t in types) for el in np.ravel(x))", "code_tokens": "def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )", "docstring_tokens": "Do all elements of x have a type from types?", "label": 0}, {"idx": "cosqa-train-5043", "doc": "python making list into dictionary", "code": "def list_of_lists_to_dict(l):\n    \"\"\" Convert list of key,value lists to dict\n\n    [['id', 1], ['id', 2], ['id', 3], ['foo': 4]]\n    {'id': [1, 2, 3], 'foo': [4]}\n    \"\"\"\n    d = {}\n    for key, val in l:\n        d.setdefault(key, []).append(val)\n    return d", "code_tokens": "def list_of_lists_to_dict ( l ) : d = { } for key , val in l : d . setdefault ( key , [ ] ) . append ( val ) return d", "docstring_tokens": "Convert list of key value lists to dict", "label": 1}, {"idx": "cosqa-train-5044", "doc": "how to check datatype of columns of a data frame in python", "code": "def _validate_pos(df):\n    \"\"\"Validates the returned positional object\n    \"\"\"\n    assert isinstance(df, pd.DataFrame)\n    assert [\"seqname\", \"position\", \"strand\"] == df.columns.tolist()\n    assert df.position.dtype == np.dtype(\"int64\")\n    assert df.strand.dtype == np.dtype(\"O\")\n    assert df.seqname.dtype == np.dtype(\"O\")\n    return df", "code_tokens": "def _validate_pos ( df ) : assert isinstance ( df , pd . DataFrame ) assert [ \"seqname\" , \"position\" , \"strand\" ] == df . columns . tolist ( ) assert df . position . dtype == np . dtype ( \"int64\" ) assert df . strand . dtype == np . dtype ( \"O\" ) assert df . seqname . dtype == np . dtype ( \"O\" ) return df", "docstring_tokens": "Validates the returned positional object", "label": 0}, {"idx": "cosqa-train-5045", "doc": "python manage runserver not bind", "code": "def server(port):\n    \"\"\"Start the Django dev server.\"\"\"\n    args = ['python', 'manage.py', 'runserver']\n    if port:\n        args.append(port)\n    run.main(args)", "code_tokens": "def server ( port ) : args = [ 'python' , 'manage.py' , 'runserver' ] if port : args . append ( port ) run . main ( args )", "docstring_tokens": "Start the Django dev server .", "label": 0}, {"idx": "cosqa-train-5046", "doc": "how to check dependencies in python", "code": "def check(modname):\n    \"\"\"Check if required dependency is installed\"\"\"\n    for dependency in DEPENDENCIES:\n        if dependency.modname == modname:\n            return dependency.check()\n    else:\n        raise RuntimeError(\"Unkwown dependency %s\" % modname)", "code_tokens": "def check ( modname ) : for dependency in DEPENDENCIES : if dependency . modname == modname : return dependency . check ( ) else : raise RuntimeError ( \"Unkwown dependency %s\" % modname )", "docstring_tokens": "Check if required dependency is installed", "label": 1}, {"idx": "cosqa-train-5047", "doc": "python manage server django", "code": "def server(port):\n    \"\"\"Start the Django dev server.\"\"\"\n    args = ['python', 'manage.py', 'runserver']\n    if port:\n        args.append(port)\n    run.main(args)", "code_tokens": "def server ( port ) : args = [ 'python' , 'manage.py' , 'runserver' ] if port : args . append ( port ) run . main ( args )", "docstring_tokens": "Start the Django dev server .", "label": 1}, {"idx": "cosqa-train-5048", "doc": "how to check dependencies in python wheel", "code": "def check(modname):\n    \"\"\"Check if required dependency is installed\"\"\"\n    for dependency in DEPENDENCIES:\n        if dependency.modname == modname:\n            return dependency.check()\n    else:\n        raise RuntimeError(\"Unkwown dependency %s\" % modname)", "code_tokens": "def check ( modname ) : for dependency in DEPENDENCIES : if dependency . modname == modname : return dependency . check ( ) else : raise RuntimeError ( \"Unkwown dependency %s\" % modname )", "docstring_tokens": "Check if required dependency is installed", "label": 0}, {"idx": "cosqa-train-5049", "doc": "python map 'dict' object is not callable", "code": "def generate_dumper(self, mapfile, names):\n        \"\"\"\n        Build dumpdata commands\n        \"\"\"\n        return self.build_template(mapfile, names, self._dumpdata_template)", "code_tokens": "def generate_dumper ( self , mapfile , names ) : return self . build_template ( mapfile , names , self . _dumpdata_template )", "docstring_tokens": "Build dumpdata commands", "label": 0}, {"idx": "cosqa-train-5050", "doc": "how to check failed file in s3 using python", "code": "def health_check(self):\n        \"\"\"Uses head object to make sure the file exists in S3.\"\"\"\n        logger.debug('Health Check on S3 file for: {namespace}'.format(\n            namespace=self.namespace\n        ))\n\n        try:\n            self.client.head_object(Bucket=self.bucket_name, Key=self.data_file)\n            return True\n        except ClientError as e:\n            logger.debug('Error encountered with S3.  Assume unhealthy')", "code_tokens": "def health_check ( self ) : logger . debug ( 'Health Check on S3 file for: {namespace}' . format ( namespace = self . namespace ) ) try : self . client . head_object ( Bucket = self . bucket_name , Key = self . data_file ) return True except ClientError as e : logger . debug ( 'Error encountered with S3.  Assume unhealthy' )", "docstring_tokens": "Uses head object to make sure the file exists in S3 .", "label": 0}, {"idx": "cosqa-train-5051", "doc": "python match list of strings", "code": "def match(string, patterns):\n    \"\"\"Given a string return true if it matches the supplied list of\n    patterns.\n\n    Parameters\n    ----------\n    string : str\n        The string to be matched.\n    patterns : None or [pattern, ...]\n        The series of regular expressions to attempt to match.\n    \"\"\"\n    if patterns is None:\n        return True\n    else:\n        return any(re.match(pattern, string)\n                   for pattern in patterns)", "code_tokens": "def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )", "docstring_tokens": "Given a string return true if it matches the supplied list of patterns .", "label": 0}, {"idx": "cosqa-train-5052", "doc": "how to check for integers in a string in python", "code": "def str2int(string_with_int):\n    \"\"\" Collect digits from a string \"\"\"\n    return int(\"\".join([char for char in string_with_int if char in string.digits]) or 0)", "code_tokens": "def str2int ( string_with_int ) : return int ( \"\" . join ( [ char for char in string_with_int if char in string . digits ] ) or 0 )", "docstring_tokens": "Collect digits from a string", "label": 0}, {"idx": "cosqa-train-5053", "doc": "python matplotlib colorbar colarmap", "code": "def colorbar(height, length, colormap):\n    \"\"\"Return the channels of a colorbar.\n    \"\"\"\n    cbar = np.tile(np.arange(length) * 1.0 / (length - 1), (height, 1))\n    cbar = (cbar * (colormap.values.max() - colormap.values.min())\n            + colormap.values.min())\n\n    return colormap.colorize(cbar)", "code_tokens": "def colorbar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . colorize ( cbar )", "docstring_tokens": "Return the channels of a colorbar .", "label": 1}, {"idx": "cosqa-train-5054", "doc": "how to check for values in a array python", "code": "def isin(value, values):\n    \"\"\" Check that value is in values \"\"\"\n    for i, v in enumerate(value):\n        if v not in np.array(values)[:, i]:\n            return False\n    return True", "code_tokens": "def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True", "docstring_tokens": "Check that value is in values", "label": 0}, {"idx": "cosqa-train-5055", "doc": "how to check functions in python", "code": "def init_checks_registry():\n    \"\"\"Register all globally visible functions.\n\n    The first argument name is either 'physical_line' or 'logical_line'.\n    \"\"\"\n    mod = inspect.getmodule(register_check)\n    for (name, function) in inspect.getmembers(mod, inspect.isfunction):\n        register_check(function)", "code_tokens": "def init_checks_registry ( ) : mod = inspect . getmodule ( register_check ) for ( name , function ) in inspect . getmembers ( mod , inspect . isfunction ) : register_check ( function )", "docstring_tokens": "Register all globally visible functions .", "label": 0}, {"idx": "cosqa-train-5056", "doc": "python matplotlib save to svg", "code": "def fig2x(figure, format):\n    \"\"\"Returns svg from matplotlib chart\"\"\"\n\n    # Save svg to file like object svg_io\n    io = StringIO()\n    figure.savefig(io, format=format)\n\n    # Rewind the file like object\n    io.seek(0)\n\n    data = io.getvalue()\n    io.close()\n\n    return data", "code_tokens": "def fig2x ( figure , format ) : # Save svg to file like object svg_io io = StringIO ( ) figure . savefig ( io , format = format ) # Rewind the file like object io . seek ( 0 ) data = io . getvalue ( ) io . close ( ) return data", "docstring_tokens": "Returns svg from matplotlib chart", "label": 0}, {"idx": "cosqa-train-5057", "doc": "how to check git connection in python", "code": "def check_git():\n    \"\"\"Check if git command is available.\"\"\"\n    try:\n        with open(os.devnull, \"wb\") as devnull:\n            subprocess.check_call([\"git\", \"--version\"], stdout=devnull, stderr=devnull)\n    except:\n        raise RuntimeError(\"Please make sure git is installed and on your path.\")", "code_tokens": "def check_git ( ) : try : with open ( os . devnull , \"wb\" ) as devnull : subprocess . check_call ( [ \"git\" , \"--version\" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( \"Please make sure git is installed and on your path.\" )", "docstring_tokens": "Check if git command is available .", "label": 0}, {"idx": "cosqa-train-5058", "doc": "python matplotlib savefig empty", "code": "def plot_and_save(self, **kwargs):\n        \"\"\"Used when the plot method defined does not create a figure nor calls save_plot\n        Then the plot method has to use self.fig\"\"\"\n        self.fig = pyplot.figure()\n        self.plot()\n        self.axes = pyplot.gca()\n        self.save_plot(self.fig, self.axes, **kwargs)\n        pyplot.close(self.fig)", "code_tokens": "def plot_and_save ( self , * * kwargs ) : self . fig = pyplot . figure ( ) self . plot ( ) self . axes = pyplot . gca ( ) self . save_plot ( self . fig , self . axes , * * kwargs ) pyplot . close ( self . fig )", "docstring_tokens": "Used when the plot method defined does not create a figure nor calls save_plot Then the plot method has to use self . fig", "label": 0}, {"idx": "cosqa-train-5059", "doc": "how to check if a file exist in a folder in python", "code": "def contained_in(filename, directory):\n    \"\"\"Test if a file is located within the given directory.\"\"\"\n    filename = os.path.normcase(os.path.abspath(filename))\n    directory = os.path.normcase(os.path.abspath(directory))\n    return os.path.commonprefix([filename, directory]) == directory", "code_tokens": "def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory", "docstring_tokens": "Test if a file is located within the given directory .", "label": 0}, {"idx": "cosqa-train-5060", "doc": "python matplotlib set axis title for axes", "code": "def set_title(self, title, **kwargs):\n        \"\"\"Sets the title on the underlying matplotlib AxesSubplot.\"\"\"\n        ax = self.get_axes()\n        ax.set_title(title, **kwargs)", "code_tokens": "def set_title ( self , title , * * kwargs ) : ax = self . get_axes ( ) ax . set_title ( title , * * kwargs )", "docstring_tokens": "Sets the title on the underlying matplotlib AxesSubplot .", "label": 0}, {"idx": "cosqa-train-5061", "doc": "how to check if a file exists or not in python", "code": "def _file_exists(path, filename):\n  \"\"\"Checks if the filename exists under the path.\"\"\"\n  return os.path.isfile(os.path.join(path, filename))", "code_tokens": "def _file_exists ( path , filename ) : return os . path . isfile ( os . path . join ( path , filename ) )", "docstring_tokens": "Checks if the filename exists under the path .", "label": 0}, {"idx": "cosqa-train-5062", "doc": "python max nesting depth for lists", "code": "def maxlevel(lst):\n    \"\"\"Return maximum nesting depth\"\"\"\n    maxlev = 0\n    def f(lst, level):\n        nonlocal maxlev\n        if isinstance(lst, list):\n            level += 1\n            maxlev = max(level, maxlev)\n            for item in lst:\n                f(item, level)\n    f(lst, 0)\n    return maxlev", "code_tokens": "def maxlevel ( lst ) : maxlev = 0 def f ( lst , level ) : nonlocal maxlev if isinstance ( lst , list ) : level += 1 maxlev = max ( level , maxlev ) for item in lst : f ( item , level ) f ( lst , 0 ) return maxlev", "docstring_tokens": "Return maximum nesting depth", "label": 1}, {"idx": "cosqa-train-5063", "doc": "how to check if a list is equal python", "code": "def allsame(list_, strict=True):\n    \"\"\"\n    checks to see if list is equal everywhere\n\n    Args:\n        list_ (list):\n\n    Returns:\n        True if all items in the list are equal\n    \"\"\"\n    if len(list_) == 0:\n        return True\n    first_item = list_[0]\n    return list_all_eq_to(list_, first_item, strict)", "code_tokens": "def allsame ( list_ , strict = True ) : if len ( list_ ) == 0 : return True first_item = list_ [ 0 ] return list_all_eq_to ( list_ , first_item , strict )", "docstring_tokens": "checks to see if list is equal everywhere", "label": 0}, {"idx": "cosqa-train-5064", "doc": "python maximum memory usage", "code": "def peak_memory_usage():\n    \"\"\"Return peak memory usage in MB\"\"\"\n    if sys.platform.startswith('win'):\n        p = psutil.Process()\n        return p.memory_info().peak_wset / 1024 / 1024\n\n    mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss\n    factor_mb = 1 / 1024\n    if sys.platform == 'darwin':\n        factor_mb = 1 / (1024 * 1024)\n    return mem * factor_mb", "code_tokens": "def peak_memory_usage ( ) : if sys . platform . startswith ( 'win' ) : p = psutil . Process ( ) return p . memory_info ( ) . peak_wset / 1024 / 1024 mem = resource . getrusage ( resource . RUSAGE_SELF ) . ru_maxrss factor_mb = 1 / 1024 if sys . platform == 'darwin' : factor_mb = 1 / ( 1024 * 1024 ) return mem * factor_mb", "docstring_tokens": "Return peak memory usage in MB", "label": 0}, {"idx": "cosqa-train-5065", "doc": "python merge a list of lists into a single list", "code": "def listunion(ListOfLists):\n    \"\"\"\n    Take the union of a list of lists.\n\n    Take a Python list of Python lists::\n\n            [[l11,l12, ...], [l21,l22, ...], ... , [ln1, ln2, ...]]\n\n    and return the aggregated list::\n\n            [l11,l12, ..., l21, l22 , ...]\n\n    For a list of two lists, e.g. `[a, b]`, this is like::\n\n            a.extend(b)\n\n    **Parameters**\n\n            **ListOfLists** :  Python list\n\n                    Python list of Python lists.\n\n    **Returns**\n\n            **u** :  Python list\n\n                    Python list created by taking the union of the\n                    lists in `ListOfLists`.\n\n    \"\"\"\n    u = []\n    for s in ListOfLists:\n        if s != None:\n            u.extend(s)\n    return u", "code_tokens": "def listunion ( ListOfLists ) : u = [ ] for s in ListOfLists : if s != None : u . extend ( s ) return u", "docstring_tokens": "Take the union of a list of lists .", "label": 0}, {"idx": "cosqa-train-5066", "doc": "how to check if a string is a url or a local address python", "code": "def is_valid_url(url):\n    \"\"\"Checks if a given string is an url\"\"\"\n    pieces = urlparse(url)\n    return all([pieces.scheme, pieces.netloc])", "code_tokens": "def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )", "docstring_tokens": "Checks if a given string is an url", "label": 1}, {"idx": "cosqa-train-5067", "doc": "python merge two objects", "code": "def merge(self, other):\n        \"\"\" Merge another stats. \"\"\"\n        Stats.merge(self, other)\n        self.changes += other.changes", "code_tokens": "def merge ( self , other ) : Stats . merge ( self , other ) self . changes += other . changes", "docstring_tokens": "Merge another stats .", "label": 0}, {"idx": "cosqa-train-5068", "doc": "how to check if duplicate names exist python", "code": "def _check_for_duplicate_sequence_names(self, fasta_file_path):\n        \"\"\"Test if the given fasta file contains sequences with duplicate\n        sequence names.\n\n        Parameters\n        ----------\n        fasta_file_path: string\n            path to file that is to be checked\n\n        Returns\n        -------\n        The name of the first duplicate sequence found, else False.\n\n        \"\"\"\n        found_sequence_names = set()\n        for record in SeqIO.parse(fasta_file_path, 'fasta'):\n            name = record.name\n            if name in found_sequence_names:\n                return name\n            found_sequence_names.add(name)\n        return False", "code_tokens": "def _check_for_duplicate_sequence_names ( self , fasta_file_path ) : found_sequence_names = set ( ) for record in SeqIO . parse ( fasta_file_path , 'fasta' ) : name = record . name if name in found_sequence_names : return name found_sequence_names . add ( name ) return False", "docstring_tokens": "Test if the given fasta file contains sequences with duplicate sequence names .", "label": 1}, {"idx": "cosqa-train-5069", "doc": "python merge two set to dict", "code": "def dict_merge(set1, set2):\n    \"\"\"Joins two dictionaries.\"\"\"\n    return dict(list(set1.items()) + list(set2.items()))", "code_tokens": "def dict_merge ( set1 , set2 ) : return dict ( list ( set1 . items ( ) ) + list ( set2 . items ( ) ) )", "docstring_tokens": "Joins two dictionaries .", "label": 1}, {"idx": "cosqa-train-5070", "doc": "how to check if function is defined in python", "code": "def is_callable(*p):\n    \"\"\" True if all the args are functions and / or subroutines\n    \"\"\"\n    import symbols\n    return all(isinstance(x, symbols.FUNCTION) for x in p)", "code_tokens": "def is_callable ( * p ) : import symbols return all ( isinstance ( x , symbols . FUNCTION ) for x in p )", "docstring_tokens": "True if all the args are functions and / or subroutines", "label": 1}, {"idx": "cosqa-train-5071", "doc": "python minidom get attribute value", "code": "def _get_minidom_tag_value(station, tag_name):\n    \"\"\"get a value from a tag (if it exists)\"\"\"\n    tag = station.getElementsByTagName(tag_name)[0].firstChild\n    if tag:\n        return tag.nodeValue\n\n    return None", "code_tokens": "def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None", "docstring_tokens": "get a value from a tag ( if it exists )", "label": 0}, {"idx": "cosqa-train-5072", "doc": "how to check if it is a symlink in python", "code": "def is_symlink(self):\n        \"\"\"\n        Whether this path is a symbolic link.\n        \"\"\"\n        try:\n            return S_ISLNK(self.lstat().st_mode)\n        except OSError as e:\n            if e.errno != ENOENT:\n                raise\n            # Path doesn't exist\n            return False", "code_tokens": "def is_symlink ( self ) : try : return S_ISLNK ( self . lstat ( ) . st_mode ) except OSError as e : if e . errno != ENOENT : raise # Path doesn't exist return False", "docstring_tokens": "Whether this path is a symbolic link .", "label": 1}, {"idx": "cosqa-train-5073", "doc": "python mkdirs silent if exists", "code": "def makedirs(path, mode=0o777, exist_ok=False):\n    \"\"\"A wrapper of os.makedirs().\"\"\"\n    os.makedirs(path, mode, exist_ok)", "code_tokens": "def makedirs ( path , mode = 0o777 , exist_ok = False ) : os . makedirs ( path , mode , exist_ok )", "docstring_tokens": "A wrapper of os . makedirs () .", "label": 0}, {"idx": "cosqa-train-5074", "doc": "how to check if json file is valid python", "code": "def is_json_file(filename, show_warnings = False):\n    \"\"\"Check configuration file type is JSON\n    Return a boolean indicating wheather the file is JSON format or not\n    \"\"\"\n    try:\n        config_dict = load_config(filename, file_type = \"json\")\n        is_json = True\n    except:\n        is_json = False\n    return(is_json)", "code_tokens": "def is_json_file ( filename , show_warnings = False ) : try : config_dict = load_config ( filename , file_type = \"json\" ) is_json = True except : is_json = False return ( is_json )", "docstring_tokens": "Check configuration file type is JSON Return a boolean indicating wheather the file is JSON format or not", "label": 0}, {"idx": "cosqa-train-5075", "doc": "python modify asyncio code", "code": "async def _thread_coro(self, *args):\n        \"\"\" Coroutine called by MapAsync. It's wrapping the call of\n        run_in_executor to run the synchronous function as thread \"\"\"\n        return await self._loop.run_in_executor(\n            self._executor, self._function, *args)", "code_tokens": "async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "docstring_tokens": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread", "label": 0}, {"idx": "cosqa-train-5076", "doc": "how to check if key is in dict in python", "code": "def __contains__(self, key):\n        \"\"\"\n        Invoked when determining whether a specific key is in the dictionary\n        using `key in d`.\n\n        The key is looked up case-insensitively.\n        \"\"\"\n        k = self._real_key(key)\n        return k in self._data", "code_tokens": "def __contains__ ( self , key ) : k = self . _real_key ( key ) return k in self . _data", "docstring_tokens": "Invoked when determining whether a specific key is in the dictionary using key in d .", "label": 0}, {"idx": "cosqa-train-5077", "doc": "how to check if regex pattern matches the string in python", "code": "def match(string, patterns):\n    \"\"\"Given a string return true if it matches the supplied list of\n    patterns.\n\n    Parameters\n    ----------\n    string : str\n        The string to be matched.\n    patterns : None or [pattern, ...]\n        The series of regular expressions to attempt to match.\n    \"\"\"\n    if patterns is None:\n        return True\n    else:\n        return any(re.match(pattern, string)\n                   for pattern in patterns)", "code_tokens": "def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )", "docstring_tokens": "Given a string return true if it matches the supplied list of patterns .", "label": 1}, {"idx": "cosqa-train-5078", "doc": "python mongodb add field to another field", "code": "def update_loan_entry(database, entry):\n    \"\"\"Update a record of a loan report in the provided database.\n\n    @param db: The MongoDB database to operate on. The loans collection will be\n        used from this database.\n    @type db: pymongo.database.Database\n    @param entry: The entry to insert into the database, updating the entry with\n        the same recordID if one exists.\n    @type entry: dict\n    \"\"\"\n    entry = clean_entry(entry)\n    database.loans.update(\n        {'recordID': entry['recordID']},\n        {'$set': entry},\n        upsert=True\n    )", "code_tokens": "def update_loan_entry ( database , entry ) : entry = clean_entry ( entry ) database . loans . update ( { 'recordID' : entry [ 'recordID' ] } , { '$set' : entry } , upsert = True )", "docstring_tokens": "Update a record of a loan report in the provided database .", "label": 0}, {"idx": "cosqa-train-5079", "doc": "how to check image is loded in python", "code": "def ffmpeg_works():\n  \"\"\"Tries to encode images with ffmpeg to check if it works.\"\"\"\n  images = np.zeros((2, 32, 32, 3), dtype=np.uint8)\n  try:\n    _encode_gif(images, 2)\n    return True\n  except (IOError, OSError):\n    return False", "code_tokens": "def ffmpeg_works ( ) : images = np . zeros ( ( 2 , 32 , 32 , 3 ) , dtype = np . uint8 ) try : _encode_gif ( images , 2 ) return True except ( IOError , OSError ) : return False", "docstring_tokens": "Tries to encode images with ffmpeg to check if it works .", "label": 1}, {"idx": "cosqa-train-5080", "doc": "python mongodb string to objectid", "code": "def json_obj_to_cursor(self, json):\n        \"\"\"(Deprecated) Converts a JSON object to a mongo db cursor\n\n        :param str json: A json string\n        :returns: dictionary with ObjectId type\n        :rtype: dict\n        \"\"\"\n        cursor = json_util.loads(json)\n        if \"id\" in json:\n            cursor[\"_id\"] = ObjectId(cursor[\"id\"])\n            del cursor[\"id\"]\n\n        return cursor", "code_tokens": "def json_obj_to_cursor ( self , json ) : cursor = json_util . loads ( json ) if \"id\" in json : cursor [ \"_id\" ] = ObjectId ( cursor [ \"id\" ] ) del cursor [ \"id\" ] return cursor", "docstring_tokens": "( Deprecated ) Converts a JSON object to a mongo db cursor", "label": 0}, {"idx": "cosqa-train-5081", "doc": "how to check the value of the column exist in that column python", "code": "def column_exists(cr, table, column):\n    \"\"\" Check whether a certain column exists \"\"\"\n    cr.execute(\n        'SELECT count(attname) FROM pg_attribute '\n        'WHERE attrelid = '\n        '( SELECT oid FROM pg_class WHERE relname = %s ) '\n        'AND attname = %s',\n        (table, column))\n    return cr.fetchone()[0] == 1", "code_tokens": "def column_exists ( cr , table , column ) : cr . execute ( 'SELECT count(attname) FROM pg_attribute ' 'WHERE attrelid = ' '( SELECT oid FROM pg_class WHERE relname = %s ) ' 'AND attname = %s' , ( table , column ) ) return cr . fetchone ( ) [ 0 ] == 1", "docstring_tokens": "Check whether a certain column exists", "label": 1}, {"idx": "cosqa-train-5082", "doc": "python most common element of array", "code": "def _most_common(iterable):\n    \"\"\"Returns the most common element in `iterable`.\"\"\"\n    data = Counter(iterable)\n    return max(data, key=data.__getitem__)", "code_tokens": "def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )", "docstring_tokens": "Returns the most common element in iterable .", "label": 0}, {"idx": "cosqa-train-5083", "doc": "how to check users folder authorirty check python", "code": "def check_permission_safety(path):\n    \"\"\"Check if the file at the given path is safe to use as a state file.\n\n    This checks that group and others have no permissions on the file and that the current user is\n    the owner.\n    \"\"\"\n    f_stats = os.stat(path)\n    return (f_stats.st_mode & (stat.S_IRWXG | stat.S_IRWXO)) == 0 and f_stats.st_uid == os.getuid()", "code_tokens": "def check_permission_safety ( path ) : f_stats = os . stat ( path ) return ( f_stats . st_mode & ( stat . S_IRWXG | stat . S_IRWXO ) ) == 0 and f_stats . st_uid == os . getuid ( )", "docstring_tokens": "Check if the file at the given path is safe to use as a state file .", "label": 0}, {"idx": "cosqa-train-5084", "doc": "python move cursor to beginning of line", "code": "def _go_to_line(editor, line):\n    \"\"\"\n    Move cursor to this line in the current buffer.\n    \"\"\"\n    b = editor.application.current_buffer\n    b.cursor_position = b.document.translate_row_col_to_index(max(0, int(line) - 1), 0)", "code_tokens": "def _go_to_line ( editor , line ) : b = editor . application . current_buffer b . cursor_position = b . document . translate_row_col_to_index ( max ( 0 , int ( line ) - 1 ) , 0 )", "docstring_tokens": "Move cursor to this line in the current buffer .", "label": 0}, {"idx": "cosqa-train-5085", "doc": "how to check whether a code is running in python", "code": "def IPYTHON_MAIN():\n    \"\"\"Decide if the Ipython command line is running code.\"\"\"\n    import pkg_resources\n\n    runner_frame = inspect.getouterframes(inspect.currentframe())[-2]\n    return (\n        getattr(runner_frame, \"function\", None)\n        == pkg_resources.load_entry_point(\"ipython\", \"console_scripts\", \"ipython\").__name__\n    )", "code_tokens": "def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , \"function\" , None ) == pkg_resources . load_entry_point ( \"ipython\" , \"console_scripts\" , \"ipython\" ) . __name__ )", "docstring_tokens": "Decide if the Ipython command line is running code .", "label": 1}, {"idx": "cosqa-train-5086", "doc": "python move cursor up", "code": "def move_up(lines=1, file=sys.stdout):\n    \"\"\" Move the cursor up a number of lines.\n\n        Esc[ValueA:\n        Moves the cursor up by the specified number of lines without changing\n        columns. If the cursor is already on the top line, ANSI.SYS ignores\n        this sequence.\n    \"\"\"\n    move.up(lines).write(file=file)", "code_tokens": "def move_up ( lines = 1 , file = sys . stdout ) : move . up ( lines ) . write ( file = file )", "docstring_tokens": "Move the cursor up a number of lines .", "label": 0}, {"idx": "cosqa-train-5087", "doc": "how to clear previously printed lines in python", "code": "def erase(self):\n        \"\"\"White out the progress bar.\"\"\"\n        with self._at_last_line():\n            self.stream.write(self._term.clear_eol)\n        self.stream.flush()", "code_tokens": "def erase ( self ) : with self . _at_last_line ( ) : self . stream . write ( self . _term . clear_eol ) self . stream . flush ( )", "docstring_tokens": "White out the progress bar .", "label": 0}, {"idx": "cosqa-train-5088", "doc": "python move mouse cursor and click", "code": "def set_cursor(self, x, y):\n        \"\"\"\n        Sets the cursor to the desired position.\n\n        :param x: X position\n        :param y: Y position\n        \"\"\"\n        curses.curs_set(1)\n        self.screen.move(y, x)", "code_tokens": "def set_cursor ( self , x , y ) : curses . curs_set ( 1 ) self . screen . move ( y , x )", "docstring_tokens": "Sets the cursor to the desired position .", "label": 0}, {"idx": "cosqa-train-5089", "doc": "how to clear python buffer in macs", "code": "def __clear_buffers(self):\n        \"\"\"Clears the input and output buffers\"\"\"\n        try:\n            self._port.reset_input_buffer()\n            self._port.reset_output_buffer()\n        except AttributeError:\n            #pySerial 2.7\n            self._port.flushInput()\n            self._port.flushOutput()", "code_tokens": "def __clear_buffers ( self ) : try : self . _port . reset_input_buffer ( ) self . _port . reset_output_buffer ( ) except AttributeError : #pySerial 2.7 self . _port . flushInput ( ) self . _port . flushOutput ( )", "docstring_tokens": "Clears the input and output buffers", "label": 1}, {"idx": "cosqa-train-5090", "doc": "python moving average vector", "code": "def moving_average(array, n=3):\n    \"\"\"\n    Calculates the moving average of an array.\n\n    Parameters\n    ----------\n    array : array\n        The array to have the moving average taken of\n    n : int\n        The number of points of moving average to take\n    \n    Returns\n    -------\n    MovingAverageArray : array\n        The n-point moving average of the input array\n    \"\"\"\n    ret = _np.cumsum(array, dtype=float)\n    ret[n:] = ret[n:] - ret[:-n]\n    return ret[n - 1:] / n", "code_tokens": "def moving_average ( array , n = 3 ) : ret = _np . cumsum ( array , dtype = float ) ret [ n : ] = ret [ n : ] - ret [ : - n ] return ret [ n - 1 : ] / n", "docstring_tokens": "Calculates the moving average of an array .", "label": 0}, {"idx": "cosqa-train-5091", "doc": "how to clear serial buffer python", "code": "def __clear_buffers(self):\n        \"\"\"Clears the input and output buffers\"\"\"\n        try:\n            self._port.reset_input_buffer()\n            self._port.reset_output_buffer()\n        except AttributeError:\n            #pySerial 2.7\n            self._port.flushInput()\n            self._port.flushOutput()", "code_tokens": "def __clear_buffers ( self ) : try : self . _port . reset_input_buffer ( ) self . _port . reset_output_buffer ( ) except AttributeError : #pySerial 2.7 self . _port . flushInput ( ) self . _port . flushOutput ( )", "docstring_tokens": "Clears the input and output buffers", "label": 0}, {"idx": "cosqa-train-5092", "doc": "python mplot3d coordinate frame", "code": "def list(self):\n        \"\"\"position in 3d space\"\"\"\n        return [self._pos3d.x, self._pos3d.y, self._pos3d.z]", "code_tokens": "def list ( self ) : return [ self . _pos3d . x , self . _pos3d . y , self . _pos3d . z ]", "docstring_tokens": "position in 3d space", "label": 0}, {"idx": "cosqa-train-5093", "doc": "how to clear the canvas in python", "code": "def clear(self):\n        \"\"\"Clear the displayed image.\"\"\"\n        self._imgobj = None\n        try:\n            # See if there is an image on the canvas\n            self.canvas.delete_object_by_tag(self._canvas_img_tag)\n            self.redraw()\n        except KeyError:\n            pass", "code_tokens": "def clear ( self ) : self . _imgobj = None try : # See if there is an image on the canvas self . canvas . delete_object_by_tag ( self . _canvas_img_tag ) self . redraw ( ) except KeyError : pass", "docstring_tokens": "Clear the displayed image .", "label": 0}, {"idx": "cosqa-train-5094", "doc": "python multiply an iterable", "code": "def map(cls, iterable, func, *a, **kw):\n    \"\"\"\n    Iterable-first replacement of Python's built-in `map()` function.\n    \"\"\"\n\n    return cls(func(x, *a, **kw) for x in iterable)", "code_tokens": "def map ( cls , iterable , func , * a , * * kw ) : return cls ( func ( x , * a , * * kw ) for x in iterable )", "docstring_tokens": "Iterable - first replacement of Python s built - in map () function .", "label": 0}, {"idx": "cosqa-train-5095", "doc": "how to close an open tiff image file in python", "code": "def cio_close(cio):\n    \"\"\"Wraps openjpeg library function cio_close.\n    \"\"\"\n    OPENJPEG.opj_cio_close.argtypes = [ctypes.POINTER(CioType)]\n    OPENJPEG.opj_cio_close(cio)", "code_tokens": "def cio_close ( cio ) : OPENJPEG . opj_cio_close . argtypes = [ ctypes . POINTER ( CioType ) ] OPENJPEG . opj_cio_close ( cio )", "docstring_tokens": "Wraps openjpeg library function cio_close .", "label": 0}, {"idx": "cosqa-train-5096", "doc": "python multiprocessing apply async result", "code": "async def result_processor(tasks):\n    \"\"\"An async result aggregator that combines all the results\n       This gets executed in unsync.loop and unsync.thread\"\"\"\n    output = {}\n    for task in tasks:\n        num, res = await task\n        output[num] = res\n    return output", "code_tokens": "async def result_processor ( tasks ) : output = { } for task in tasks : num , res = await task output [ num ] = res return output", "docstring_tokens": "An async result aggregator that combines all the results This gets executed in unsync . loop and unsync . thread", "label": 0}, {"idx": "cosqa-train-5097", "doc": "how to close database session sqlite3 python", "code": "def close( self ):\n        \"\"\"\n        Close the db and release memory\n        \"\"\"\n        if self.db is not None:\n            self.db.commit()\n            self.db.close()\n            self.db = None\n\n        return", "code_tokens": "def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return", "docstring_tokens": "Close the db and release memory", "label": 0}, {"idx": "cosqa-train-5098", "doc": "python multiprocessing cant pickle objects", "code": "def _parallel_compare_helper(class_obj, pairs, x, x_link=None):\n    \"\"\"Internal function to overcome pickling problem in python2.\"\"\"\n    return class_obj._compute(pairs, x, x_link)", "code_tokens": "def _parallel_compare_helper ( class_obj , pairs , x , x_link = None ) : return class_obj . _compute ( pairs , x , x_link )", "docstring_tokens": "Internal function to overcome pickling problem in python2 .", "label": 0}, {"idx": "cosqa-train-5099", "doc": "how to collect all the pdf links from a web page using python", "code": "def resources(self):\n        \"\"\"Retrieve contents of each page of PDF\"\"\"\n        return [self.pdf.getPage(i) for i in range(self.pdf.getNumPages())]", "code_tokens": "def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "docstring_tokens": "Retrieve contents of each page of PDF", "label": 0}, {"idx": "cosqa-train-5100", "doc": "python multiprocessing how to decide the number of processors", "code": "def compute_partition_size(result, processes):\n    \"\"\"\n    Attempts to compute the partition size to evenly distribute work across processes. Defaults to\n    1 if the length of result cannot be determined.\n\n    :param result: Result to compute on\n    :param processes: Number of processes to use\n    :return: Best partition size\n    \"\"\"\n    try:\n        return max(math.ceil(len(result) / processes), 1)\n    except TypeError:\n        return 1", "code_tokens": "def compute_partition_size ( result , processes ) : try : return max ( math . ceil ( len ( result ) / processes ) , 1 ) except TypeError : return 1", "docstring_tokens": "Attempts to compute the partition size to evenly distribute work across processes . Defaults to 1 if the length of result cannot be determined .", "label": 0}, {"idx": "cosqa-train-5101", "doc": "how to combine two models in python", "code": "def __iadd__(self, other_model):\n        \"\"\"Incrementally add the content of another model to this model (+=).\n\n        Copies of all the reactions in the other model are added to this\n        model. The objective is the sum of the objective expressions for the\n        two models.\n        \"\"\"\n        warn('use model.merge instead', DeprecationWarning)\n        return self.merge(other_model, objective='sum', inplace=True)", "code_tokens": "def __iadd__ ( self , other_model ) : warn ( 'use model.merge instead' , DeprecationWarning ) return self . merge ( other_model , objective = 'sum' , inplace = True )", "docstring_tokens": "Incrementally add the content of another model to this model ( + = ) .", "label": 0}, {"idx": "cosqa-train-5102", "doc": "python multiprocessing pool not start", "code": "def parallel(processes, threads):\n    \"\"\"\n    execute jobs in processes using N threads\n    \"\"\"\n    pool = multithread(threads)\n    pool.map(run_process, processes)\n    pool.close()\n    pool.join()", "code_tokens": "def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )", "docstring_tokens": "execute jobs in processes using N threads", "label": 1}, {"idx": "cosqa-train-5103", "doc": "how to compare 2 arrays and give accurecy python", "code": "def compare(a, b):\n    \"\"\"\n     Compare items in 2 arrays. Returns sum(abs(a(i)-b(i)))\n    \"\"\"\n    s=0\n    for i in range(len(a)):\n        s=s+abs(a[i]-b[i])\n    return s", "code_tokens": "def compare ( a , b ) : s = 0 for i in range ( len ( a ) ) : s = s + abs ( a [ i ] - b [ i ] ) return s", "docstring_tokens": "Compare items in 2 arrays . Returns sum ( abs ( a ( i ) - b ( i )))", "label": 1}, {"idx": "cosqa-train-5104", "doc": "python multiprocessing show cpu count", "code": "def machine_info():\n    \"\"\"Retrieve core and memory information for the current machine.\n    \"\"\"\n    import psutil\n    BYTES_IN_GIG = 1073741824.0\n    free_bytes = psutil.virtual_memory().total\n    return [{\"memory\": float(\"%.1f\" % (free_bytes / BYTES_IN_GIG)), \"cores\": multiprocessing.cpu_count(),\n             \"name\": socket.gethostname()}]", "code_tokens": "def machine_info ( ) : import psutil BYTES_IN_GIG = 1073741824.0 free_bytes = psutil . virtual_memory ( ) . total return [ { \"memory\" : float ( \"%.1f\" % ( free_bytes / BYTES_IN_GIG ) ) , \"cores\" : multiprocessing . cpu_count ( ) , \"name\" : socket . gethostname ( ) } ]", "docstring_tokens": "Retrieve core and memory information for the current machine .", "label": 1}, {"idx": "cosqa-train-5105", "doc": "how to compare the variable to its data type python", "code": "def is_value_type_valid_for_exact_conditions(self, value):\n    \"\"\" Method to validate if the value is valid for exact match type evaluation.\n\n    Args:\n      value: Value to validate.\n\n    Returns:\n      Boolean: True if value is a string, boolean, or number. Otherwise False.\n    \"\"\"\n    # No need to check for bool since bool is a subclass of int\n    if isinstance(value, string_types) or isinstance(value, (numbers.Integral, float)):\n      return True\n\n    return False", "code_tokens": "def is_value_type_valid_for_exact_conditions ( self , value ) : # No need to check for bool since bool is a subclass of int if isinstance ( value , string_types ) or isinstance ( value , ( numbers . Integral , float ) ) : return True return False", "docstring_tokens": "Method to validate if the value is valid for exact match type evaluation .", "label": 0}, {"idx": "cosqa-train-5106", "doc": "python multiprocessing unable to pickle object", "code": "def _parallel_compare_helper(class_obj, pairs, x, x_link=None):\n    \"\"\"Internal function to overcome pickling problem in python2.\"\"\"\n    return class_obj._compute(pairs, x, x_link)", "code_tokens": "def _parallel_compare_helper ( class_obj , pairs , x , x_link = None ) : return class_obj . _compute ( pairs , x , x_link )", "docstring_tokens": "Internal function to overcome pickling problem in python2 .", "label": 0}, {"idx": "cosqa-train-5107", "doc": "how to compare two object equality python", "code": "def __eq__(self, other):\n        \"\"\"Determine if two objects are equal.\"\"\"\n        return isinstance(other, self.__class__) \\\n            and self._freeze() == other._freeze()", "code_tokens": "def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) and self . _freeze ( ) == other . _freeze ( )", "docstring_tokens": "Determine if two objects are equal .", "label": 0}, {"idx": "cosqa-train-5108", "doc": "python mya save root node as self varibale", "code": "def _root(self):\n        \"\"\"Attribute referencing the root node of the tree.\n\n        :returns: the root node of the tree containing this instance.\n        :rtype: Node\n        \"\"\"\n        _n = self\n        while _n.parent:\n            _n = _n.parent\n        return _n", "code_tokens": "def _root ( self ) : _n = self while _n . parent : _n = _n . parent return _n", "docstring_tokens": "Attribute referencing the root node of the tree .", "label": 1}, {"idx": "cosqa-train-5109", "doc": "how to concatenate an input number and string in a function in python 3", "code": "def pair_strings_sum_formatter(a, b):\n  \"\"\"\n  Formats the sum of a and b.\n\n  Note\n  ----\n  Both inputs are numbers already converted to strings.\n\n  \"\"\"\n  if b[:1] == \"-\":\n    return \"{0} - {1}\".format(a, b[1:])\n  return \"{0} + {1}\".format(a, b)", "code_tokens": "def pair_strings_sum_formatter ( a , b ) : if b [ : 1 ] == \"-\" : return \"{0} - {1}\" . format ( a , b [ 1 : ] ) return \"{0} + {1}\" . format ( a , b )", "docstring_tokens": "Formats the sum of a and b .", "label": 0}, {"idx": "cosqa-train-5110", "doc": "python mysql drop and recreate table", "code": "def drop_all_tables(self):\n        \"\"\"Drop all tables in the database\"\"\"\n        for table_name in self.table_names():\n            self.execute_sql(\"DROP TABLE %s\" % table_name)\n        self.connection.commit()", "code_tokens": "def drop_all_tables ( self ) : for table_name in self . table_names ( ) : self . execute_sql ( \"DROP TABLE %s\" % table_name ) self . connection . commit ( )", "docstring_tokens": "Drop all tables in the database", "label": 0}, {"idx": "cosqa-train-5111", "doc": "how to continously return to try if error in python", "code": "def retry_on_signal(function):\n    \"\"\"Retries function until it doesn't raise an EINTR error\"\"\"\n    while True:\n        try:\n            return function()\n        except EnvironmentError, e:\n            if e.errno != errno.EINTR:\n                raise", "code_tokens": "def retry_on_signal ( function ) : while True : try : return function ( ) except EnvironmentError , e : if e . errno != errno . EINTR : raise", "docstring_tokens": "Retries function until it doesn t raise an EINTR error", "label": 0}, {"idx": "cosqa-train-5112", "doc": "python namedtuple as dict", "code": "def dictify(a_named_tuple):\n    \"\"\"Transform a named tuple into a dictionary\"\"\"\n    return dict((s, getattr(a_named_tuple, s)) for s in a_named_tuple._fields)", "code_tokens": "def dictify ( a_named_tuple ) : return dict ( ( s , getattr ( a_named_tuple , s ) ) for s in a_named_tuple . _fields )", "docstring_tokens": "Transform a named tuple into a dictionary", "label": 0}, {"idx": "cosqa-train-5113", "doc": "how to conver dict str to dictionary in python", "code": "def str_dict(some_dict):\n    \"\"\"Convert dict of ascii str/unicode to dict of str, if necessary\"\"\"\n    return {str(k): str(v) for k, v in some_dict.items()}", "code_tokens": "def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }", "docstring_tokens": "Convert dict of ascii str / unicode to dict of str if necessary", "label": 1}, {"idx": "cosqa-train-5114", "doc": "python naming convention for functions", "code": "def export(defn):\n    \"\"\"Decorator to explicitly mark functions that are exposed in a lib.\"\"\"\n    globals()[defn.__name__] = defn\n    __all__.append(defn.__name__)\n    return defn", "code_tokens": "def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "docstring_tokens": "Decorator to explicitly mark functions that are exposed in a lib .", "label": 0}, {"idx": "cosqa-train-5115", "doc": "how to copy a string to clipboard python", "code": "def paste(xsel=False):\n    \"\"\"Returns system clipboard contents.\"\"\"\n    selection = \"primary\" if xsel else \"clipboard\"\n    try:\n        return subprocess.Popen([\"xclip\", \"-selection\", selection, \"-o\"], stdout=subprocess.PIPE).communicate()[0].decode(\"utf-8\")\n    except OSError as why:\n        raise XclipNotFound", "code_tokens": "def paste ( xsel = False ) : selection = \"primary\" if xsel else \"clipboard\" try : return subprocess . Popen ( [ \"xclip\" , \"-selection\" , selection , \"-o\" ] , stdout = subprocess . PIPE ) . communicate ( ) [ 0 ] . decode ( \"utf-8\" ) except OSError as why : raise XclipNotFound", "docstring_tokens": "Returns system clipboard contents .", "label": 0}, {"idx": "cosqa-train-5116", "doc": "python nan in covariance matrix", "code": "def Cinv(self):\n        \"\"\"Inverse of the noise covariance.\"\"\"\n        try:\n            return np.linalg.inv(self.c)\n        except np.linalg.linalg.LinAlgError:\n            print('Warning: non-invertible noise covariance matrix c.')\n            return np.eye(self.c.shape[0])", "code_tokens": "def Cinv ( self ) : try : return np . linalg . inv ( self . c ) except np . linalg . linalg . LinAlgError : print ( 'Warning: non-invertible noise covariance matrix c.' ) return np . eye ( self . c . shape [ 0 ] )", "docstring_tokens": "Inverse of the noise covariance .", "label": 0}, {"idx": "cosqa-train-5117", "doc": "how to copy and replace a file in python", "code": "def copyFile(input, output, replace=None):\n    \"\"\"Copy a file whole from input to output.\"\"\"\n\n    _found = findFile(output)\n    if not _found or (_found and replace):\n        shutil.copy2(input, output)", "code_tokens": "def copyFile ( input , output , replace = None ) : _found = findFile ( output ) if not _found or ( _found and replace ) : shutil . copy2 ( input , output )", "docstring_tokens": "Copy a file whole from input to output .", "label": 1}, {"idx": "cosqa-train-5118", "doc": "python nested function variable scope and how to handle global scope", "code": "def _method_scope(input_layer, name):\n  \"\"\"Creates a nested set of name and id scopes and avoids repeats.\"\"\"\n  global _in_method_scope\n  # pylint: disable=protected-access\n\n  with input_layer.g.as_default(), \\\n       scopes.var_and_name_scope(\n           None if _in_method_scope else input_layer._scope), \\\n       scopes.var_and_name_scope((name, None)) as (scope, var_scope):\n    was_in_method_scope = _in_method_scope\n    yield scope, var_scope\n    _in_method_scope = was_in_method_scope", "code_tokens": "def _method_scope ( input_layer , name ) : global _in_method_scope # pylint: disable=protected-access with input_layer . g . as_default ( ) , scopes . var_and_name_scope ( None if _in_method_scope else input_layer . _scope ) , scopes . var_and_name_scope ( ( name , None ) ) as ( scope , var_scope ) : was_in_method_scope = _in_method_scope yield scope , var_scope _in_method_scope = was_in_method_scope", "docstring_tokens": "Creates a nested set of name and id scopes and avoids repeats .", "label": 0}, {"idx": "cosqa-train-5119", "doc": "how to coreelate a multidimensional array python", "code": "def arr_to_vector(arr):\n    \"\"\"Reshape a multidimensional array to a vector.\n    \"\"\"\n    dim = array_dim(arr)\n    tmp_arr = []\n    for n in range(len(dim) - 1):\n        for inner in arr:\n            for i in inner:\n                tmp_arr.append(i)\n        arr = tmp_arr\n        tmp_arr = []\n    return arr", "code_tokens": "def arr_to_vector ( arr ) : dim = array_dim ( arr ) tmp_arr = [ ] for n in range ( len ( dim ) - 1 ) : for inner in arr : for i in inner : tmp_arr . append ( i ) arr = tmp_arr tmp_arr = [ ] return arr", "docstring_tokens": "Reshape a multidimensional array to a vector .", "label": 0}, {"idx": "cosqa-train-5120", "doc": "python nonetype' object has no attribute 'picklable'", "code": "def is_serializable(obj):\n    \"\"\"Return `True` if the given object conforms to the Serializable protocol.\n\n    :rtype: bool\n    \"\"\"\n    if inspect.isclass(obj):\n      return Serializable.is_serializable_type(obj)\n    return isinstance(obj, Serializable) or hasattr(obj, '_asdict')", "code_tokens": "def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )", "docstring_tokens": "Return True if the given object conforms to the Serializable protocol .", "label": 0}, {"idx": "cosqa-train-5121", "doc": "how to count number of lines in a file in python\\", "code": "def line_count(fn):\n    \"\"\" Get line count of file\n\n    Args:\n        fn (str): Path to file\n\n    Return:\n          Number of lines in file (int)\n    \"\"\"\n\n    with open(fn) as f:\n        for i, l in enumerate(f):\n            pass\n    return i + 1", "code_tokens": "def line_count ( fn ) : with open ( fn ) as f : for i , l in enumerate ( f ) : pass return i + 1", "docstring_tokens": "Get line count of file", "label": 1}, {"idx": "cosqa-train-5122", "doc": "python nonlinear fit result of function call is not a proper array", "code": "def apply_fit(xy,coeffs):\n    \"\"\" Apply the coefficients from a linear fit to\n        an array of x,y positions.\n\n        The coeffs come from the 'coeffs' member of the\n        'fit_arrays()' output.\n    \"\"\"\n    x_new = coeffs[0][2] + coeffs[0][0]*xy[:,0] + coeffs[0][1]*xy[:,1]\n    y_new = coeffs[1][2] + coeffs[1][0]*xy[:,0] + coeffs[1][1]*xy[:,1]\n\n    return x_new,y_new", "code_tokens": "def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "docstring_tokens": "Apply the coefficients from a linear fit to an array of x y positions .", "label": 0}, {"idx": "cosqa-train-5123", "doc": "how to count the heigh of a tree python", "code": "def num_leaves(tree):\n    \"\"\"Determine the number of leaves in a tree\"\"\"\n    if tree.is_leaf:\n        return 1\n    else:\n        return num_leaves(tree.left_child) + num_leaves(tree.right_child)", "code_tokens": "def num_leaves ( tree ) : if tree . is_leaf : return 1 else : return num_leaves ( tree . left_child ) + num_leaves ( tree . right_child )", "docstring_tokens": "Determine the number of leaves in a tree", "label": 0}, {"idx": "cosqa-train-5124", "doc": "python norm of array sympy", "code": "def mag(z):\n    \"\"\"Get the magnitude of a vector.\"\"\"\n    if isinstance(z[0], np.ndarray):\n        return np.array(list(map(np.linalg.norm, z)))\n    else:\n        return np.linalg.norm(z)", "code_tokens": "def mag ( z ) : if isinstance ( z [ 0 ] , np . ndarray ) : return np . array ( list ( map ( np . linalg . norm , z ) ) ) else : return np . linalg . norm ( z )", "docstring_tokens": "Get the magnitude of a vector .", "label": 0}, {"idx": "cosqa-train-5125", "doc": "how to count the num of values of a key in python", "code": "def objectcount(data, key):\n    \"\"\"return the count of objects of key\"\"\"\n    objkey = key.upper()\n    return len(data.dt[objkey])", "code_tokens": "def objectcount ( data , key ) : objkey = key . upper ( ) return len ( data . dt [ objkey ] )", "docstring_tokens": "return the count of objects of key", "label": 1}, {"idx": "cosqa-train-5126", "doc": "python normal distribution p value", "code": "def EvalGaussianPdf(x, mu, sigma):\n    \"\"\"Computes the unnormalized PDF of the normal distribution.\n\n    x: value\n    mu: mean\n    sigma: standard deviation\n    \n    returns: float probability density\n    \"\"\"\n    return scipy.stats.norm.pdf(x, mu, sigma)", "code_tokens": "def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )", "docstring_tokens": "Computes the unnormalized PDF of the normal distribution .", "label": 0}, {"idx": "cosqa-train-5127", "doc": "how to count the number of lines in a file python", "code": "def line_count(fn):\n    \"\"\" Get line count of file\n\n    Args:\n        fn (str): Path to file\n\n    Return:\n          Number of lines in file (int)\n    \"\"\"\n\n    with open(fn) as f:\n        for i, l in enumerate(f):\n            pass\n    return i + 1", "code_tokens": "def line_count ( fn ) : with open ( fn ) as f : for i , l in enumerate ( f ) : pass return i + 1", "docstring_tokens": "Get line count of file", "label": 0}, {"idx": "cosqa-train-5128", "doc": "python normal distribution with sigma values", "code": "def gauss_pdf(x, mu, sigma):\n    \"\"\"Normalized Gaussian\"\"\"\n    return 1 / np.sqrt(2 * np.pi) / sigma * np.exp(-(x - mu) ** 2 / 2. / sigma ** 2)", "code_tokens": "def gauss_pdf ( x , mu , sigma ) : return 1 / np . sqrt ( 2 * np . pi ) / sigma * np . exp ( - ( x - mu ) ** 2 / 2. / sigma ** 2 )", "docstring_tokens": "Normalized Gaussian", "label": 0}, {"idx": "cosqa-train-5129", "doc": "how to count unique values in a list in python", "code": "def count_list(the_list):\n    \"\"\"\n    Generates a count of the number of times each unique item appears in a list\n    \"\"\"\n    count = the_list.count\n    result = [(item, count(item)) for item in set(the_list)]\n    result.sort()\n    return result", "code_tokens": "def count_list ( the_list ) : count = the_list . count result = [ ( item , count ( item ) ) for item in set ( the_list ) ] result . sort ( ) return result", "docstring_tokens": "Generates a count of the number of times each unique item appears in a list", "label": 0}, {"idx": "cosqa-train-5130", "doc": "python normalize image 0 to 1", "code": "def _normalize(mat: np.ndarray):\n    \"\"\"rescales a numpy array, so that min is 0 and max is 255\"\"\"\n    return ((mat - mat.min()) * (255 / mat.max())).astype(np.uint8)", "code_tokens": "def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )", "docstring_tokens": "rescales a numpy array so that min is 0 and max is 255", "label": 0}, {"idx": "cosqa-train-5131", "doc": "how to create a pyramid in python without a def variable", "code": "def Pyramid(pos=(0, 0, 0), s=1, height=1, axis=(0, 0, 1), c=\"dg\", alpha=1):\n    \"\"\"\n    Build a pyramid of specified base size `s` and `height`, centered at `pos`.\n    \"\"\"\n    return Cone(pos, s, height, axis, c, alpha, 4)", "code_tokens": "def Pyramid ( pos = ( 0 , 0 , 0 ) , s = 1 , height = 1 , axis = ( 0 , 0 , 1 ) , c = \"dg\" , alpha = 1 ) : return Cone ( pos , s , height , axis , c , alpha , 4 )", "docstring_tokens": "Build a pyramid of specified base size s and height centered at pos .", "label": 0}, {"idx": "cosqa-train-5132", "doc": "python nose tests directory", "code": "def test(nose_argsuments):\n    \"\"\" Run application tests \"\"\"\n    from nose import run\n\n    params = ['__main__', '-c', 'nose.ini']\n    params.extend(nose_argsuments)\n    run(argv=params)", "code_tokens": "def test ( nose_argsuments ) : from nose import run params = [ '__main__' , '-c' , 'nose.ini' ] params . extend ( nose_argsuments ) run ( argv = params )", "docstring_tokens": "Run application tests", "label": 0}, {"idx": "cosqa-train-5133", "doc": "how to create a symlink in python", "code": "def symlink(source, destination):\n    \"\"\"Create a symbolic link\"\"\"\n    log(\"Symlinking {} as {}\".format(source, destination))\n    cmd = [\n        'ln',\n        '-sf',\n        source,\n        destination,\n    ]\n    subprocess.check_call(cmd)", "code_tokens": "def symlink ( source , destination ) : log ( \"Symlinking {} as {}\" . format ( source , destination ) ) cmd = [ 'ln' , '-sf' , source , destination , ] subprocess . check_call ( cmd )", "docstring_tokens": "Create a symbolic link", "label": 1}, {"idx": "cosqa-train-5134", "doc": "python nose2 coverage example", "code": "def run(self):\n        \"\"\"\n        Runs the unit test framework. Can be overridden to run anything.\n        Returns True on passing and False on failure.\n        \"\"\"\n        try:\n            import nose\n            arguments = [sys.argv[0]] + list(self.test_args)\n            return nose.run(argv=arguments)\n        except ImportError:\n            print()\n            print(\"*** Nose library missing. Please install it. ***\")\n            print()\n            raise", "code_tokens": "def run ( self ) : try : import nose arguments = [ sys . argv [ 0 ] ] + list ( self . test_args ) return nose . run ( argv = arguments ) except ImportError : print ( ) print ( \"*** Nose library missing. Please install it. ***\" ) print ( ) raise", "docstring_tokens": "Runs the unit test framework . Can be overridden to run anything . Returns True on passing and False on failure .", "label": 0}, {"idx": "cosqa-train-5135", "doc": "how to create acronyms and removed stopwords without nltk using python", "code": "def get_wordnet_syns(word):\n    \"\"\"\n    Utilize wordnet (installed with nltk) to get synonyms for words\n    word is the input word\n    returns a list of unique synonyms\n    \"\"\"\n    synonyms = []\n    regex = r\"_\"\n    pat = re.compile(regex)\n    synset = nltk.wordnet.wordnet.synsets(word)\n    for ss in synset:\n        for swords in ss.lemma_names:\n            synonyms.append(pat.sub(\" \", swords.lower()))\n    synonyms = f7(synonyms)\n    return synonyms", "code_tokens": "def get_wordnet_syns ( word ) : synonyms = [ ] regex = r\"_\" pat = re . compile ( regex ) synset = nltk . wordnet . wordnet . synsets ( word ) for ss in synset : for swords in ss . lemma_names : synonyms . append ( pat . sub ( \" \" , swords . lower ( ) ) ) synonyms = f7 ( synonyms ) return synonyms", "docstring_tokens": "Utilize wordnet ( installed with nltk ) to get synonyms for words word is the input word returns a list of unique synonyms", "label": 0}, {"idx": "cosqa-train-5136", "doc": "python not computing logarithms", "code": "def log_loss(preds, labels):\n    \"\"\"Logarithmic loss with non-necessarily-binary labels.\"\"\"\n    log_likelihood = np.sum(labels * np.log(preds)) / len(preds)\n    return -log_likelihood", "code_tokens": "def log_loss ( preds , labels ) : log_likelihood = np . sum ( labels * np . log ( preds ) ) / len ( preds ) return - log_likelihood", "docstring_tokens": "Logarithmic loss with non - necessarily - binary labels .", "label": 0}, {"idx": "cosqa-train-5137", "doc": "how to create an ordered dictionary in python", "code": "def format_result(input):\n        \"\"\"From: http://stackoverflow.com/questions/13062300/convert-a-dict-to-sorted-dict-in-python\n        \"\"\"\n        items = list(iteritems(input))\n        return OrderedDict(sorted(items, key=lambda x: x[0]))", "code_tokens": "def format_result ( input ) : items = list ( iteritems ( input ) ) return OrderedDict ( sorted ( items , key = lambda x : x [ 0 ] ) )", "docstring_tokens": "From : http : // stackoverflow . com / questions / 13062300 / convert - a - dict - to - sorted - dict - in - python", "label": 0}, {"idx": "cosqa-train-5138", "doc": "python number of days in year", "code": "def gday_of_year(self):\n        \"\"\"Return the number of days since January 1 of the given year.\"\"\"\n        return (self.date - dt.date(self.date.year, 1, 1)).days", "code_tokens": "def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days", "docstring_tokens": "Return the number of days since January 1 of the given year .", "label": 0}, {"idx": "cosqa-train-5139", "doc": "how to create bins for numerical values automatically in python", "code": "def vals2bins(vals,res=100):\n    \"\"\"Maps values to bins\n    Args:\n    values (list or list of lists) - list of values to map to colors\n    res (int) - resolution of the color map (default: 100)\n    Returns:\n    list of numbers representing bins\n    \"\"\"\n    # flatten if list of lists\n    if any(isinstance(el, list) for el in vals):\n        vals = list(itertools.chain(*vals))\n    return list(np.digitize(vals, np.linspace(np.min(vals), np.max(vals)+1, res+1)) - 1)", "code_tokens": "def vals2bins ( vals , res = 100 ) : # flatten if list of lists if any ( isinstance ( el , list ) for el in vals ) : vals = list ( itertools . chain ( * vals ) ) return list ( np . digitize ( vals , np . linspace ( np . min ( vals ) , np . max ( vals ) + 1 , res + 1 ) ) - 1 )", "docstring_tokens": "Maps values to bins Args : values ( list or list of lists ) - list of values to map to colors res ( int ) - resolution of the color map ( default : 100 ) Returns : list of numbers representing bins", "label": 1}, {"idx": "cosqa-train-5140", "doc": "python number of days in year datetime", "code": "def gday_of_year(self):\n        \"\"\"Return the number of days since January 1 of the given year.\"\"\"\n        return (self.date - dt.date(self.date.year, 1, 1)).days", "code_tokens": "def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days", "docstring_tokens": "Return the number of days since January 1 of the given year .", "label": 0}, {"idx": "cosqa-train-5141", "doc": "how to create new data frame from a query in python", "code": "def to_dataframe(products):\n        \"\"\"Return the products from a query response as a Pandas DataFrame\n        with the values in their appropriate Python types.\n        \"\"\"\n        try:\n            import pandas as pd\n        except ImportError:\n            raise ImportError(\"to_dataframe requires the optional dependency Pandas.\")\n\n        return pd.DataFrame.from_dict(products, orient='index')", "code_tokens": "def to_dataframe ( products ) : try : import pandas as pd except ImportError : raise ImportError ( \"to_dataframe requires the optional dependency Pandas.\" ) return pd . DataFrame . from_dict ( products , orient = 'index' )", "docstring_tokens": "Return the products from a query response as a Pandas DataFrame with the values in their appropriate Python types .", "label": 0}, {"idx": "cosqa-train-5142", "doc": "python number of nan in a column", "code": "def count_rows_with_nans(X):\n    \"\"\"Count the number of rows in 2D arrays that contain any nan values.\"\"\"\n    if X.ndim == 2:\n        return np.where(np.isnan(X).sum(axis=1) != 0, 1, 0).sum()", "code_tokens": "def count_rows_with_nans ( X ) : if X . ndim == 2 : return np . where ( np . isnan ( X ) . sum ( axis = 1 ) != 0 , 1 , 0 ) . sum ( )", "docstring_tokens": "Count the number of rows in 2D arrays that contain any nan values .", "label": 0}, {"idx": "cosqa-train-5143", "doc": "how to create objects from a dictionary in python", "code": "def from_dict(cls, d):\n        \"\"\"Create an instance from a dictionary.\"\"\"\n        return cls(**{k: v for k, v in d.items() if k in cls.ENTRIES})", "code_tokens": "def from_dict ( cls , d ) : return cls ( * * { k : v for k , v in d . items ( ) if k in cls . ENTRIES } )", "docstring_tokens": "Create an instance from a dictionary .", "label": 0}, {"idx": "cosqa-train-5144", "doc": "python number of nan in array", "code": "def count(data, axis=None):\n    \"\"\"Count the number of non-NA in this array along the given axis or axes\n    \"\"\"\n    return np.sum(np.logical_not(isnull(data)), axis=axis)", "code_tokens": "def count ( data , axis = None ) : return np . sum ( np . logical_not ( isnull ( data ) ) , axis = axis )", "docstring_tokens": "Count the number of non - NA in this array along the given axis or axes", "label": 0}, {"idx": "cosqa-train-5145", "doc": "how to decode requests python", "code": "def _decode_request(self, encoded_request):\n        \"\"\"Decode an request previously encoded\"\"\"\n        obj = self.serializer.loads(encoded_request)\n        return request_from_dict(obj, self.spider)", "code_tokens": "def _decode_request ( self , encoded_request ) : obj = self . serializer . loads ( encoded_request ) return request_from_dict ( obj , self . spider )", "docstring_tokens": "Decode an request previously encoded", "label": 0}, {"idx": "cosqa-train-5146", "doc": "how to decompile python pyc file", "code": "def disassemble_file(filename, outstream=None):\n    \"\"\"\n    disassemble Python byte-code file (.pyc)\n\n    If given a Python source file (\".py\") file, we'll\n    try to find the corresponding compiled object.\n    \"\"\"\n    filename = check_object_path(filename)\n    (version, timestamp, magic_int, co, is_pypy,\n     source_size) = load_module(filename)\n    if type(co) == list:\n        for con in co:\n            disco(version, con, outstream)\n    else:\n        disco(version, co, outstream, is_pypy=is_pypy)\n    co = None", "code_tokens": "def disassemble_file ( filename , outstream = None ) : filename = check_object_path ( filename ) ( version , timestamp , magic_int , co , is_pypy , source_size ) = load_module ( filename ) if type ( co ) == list : for con in co : disco ( version , con , outstream ) else : disco ( version , co , outstream , is_pypy = is_pypy ) co = None", "docstring_tokens": "disassemble Python byte - code file ( . pyc )", "label": 0}, {"idx": "cosqa-train-5147", "doc": "python numpy array image base64 encode for html img", "code": "def img_encode(arr, **kwargs):\n    \"\"\"Encode ndarray to base64 string image data\n    \n    Parameters\n    ----------\n    arr: ndarray (rows, cols, depth)\n    kwargs: passed directly to matplotlib.image.imsave\n    \"\"\"\n    sio = BytesIO()\n    imsave(sio, arr, **kwargs)\n    sio.seek(0)\n    img_format = kwargs['format'] if kwargs.get('format') else 'png'\n    img_str = base64.b64encode(sio.getvalue()).decode()\n\n    return 'data:image/{};base64,{}'.format(img_format, img_str)", "code_tokens": "def img_encode ( arr , * * kwargs ) : sio = BytesIO ( ) imsave ( sio , arr , * * kwargs ) sio . seek ( 0 ) img_format = kwargs [ 'format' ] if kwargs . get ( 'format' ) else 'png' img_str = base64 . b64encode ( sio . getvalue ( ) ) . decode ( ) return 'data:image/{};base64,{}' . format ( img_format , img_str )", "docstring_tokens": "Encode ndarray to base64 string image data Parameters ---------- arr : ndarray ( rows cols depth ) kwargs : passed directly to matplotlib . image . imsave", "label": 0}, {"idx": "cosqa-train-5148", "doc": "how to define a type in python", "code": "def register_type(cls, name):\n    \"\"\"Register `name` as a type to validate as an instance of class `cls`.\"\"\"\n    x = TypeDefinition(name, (cls,), ())\n    Validator.types_mapping[name] = x", "code_tokens": "def register_type ( cls , name ) : x = TypeDefinition ( name , ( cls , ) , ( ) ) Validator . types_mapping [ name ] = x", "docstring_tokens": "Register name as a type to validate as an instance of class cls .", "label": 1}, {"idx": "cosqa-train-5149", "doc": "python numpy array of tuples", "code": "def pairwise_indices(self):\n        \"\"\"ndarray containing tuples of pairwise indices.\"\"\"\n        return np.array([sig.pairwise_indices for sig in self.values]).T", "code_tokens": "def pairwise_indices ( self ) : return np . array ( [ sig . pairwise_indices for sig in self . values ] ) . T", "docstring_tokens": "ndarray containing tuples of pairwise indices .", "label": 0}, {"idx": "cosqa-train-5150", "doc": "how to delay print aprearing using print in python", "code": "def printmp(msg):\n    \"\"\"Print temporarily, until next print overrides it.\n    \"\"\"\n    filler = (80 - len(msg)) * ' '\n    print(msg + filler, end='\\r')\n    sys.stdout.flush()", "code_tokens": "def printmp ( msg ) : filler = ( 80 - len ( msg ) ) * ' ' print ( msg + filler , end = '\\r' ) sys . stdout . flush ( )", "docstring_tokens": "Print temporarily until next print overrides it .", "label": 0}, {"idx": "cosqa-train-5151", "doc": "python numpy array to char", "code": "def _numpy_bytes_to_char(arr):\n    \"\"\"Like netCDF4.stringtochar, but faster and more flexible.\n    \"\"\"\n    # ensure the array is contiguous\n    arr = np.array(arr, copy=False, order='C', dtype=np.string_)\n    return arr.reshape(arr.shape + (1,)).view('S1')", "code_tokens": "def _numpy_bytes_to_char ( arr ) : # ensure the array is contiguous arr = np . array ( arr , copy = False , order = 'C' , dtype = np . string_ ) return arr . reshape ( arr . shape + ( 1 , ) ) . view ( 'S1' )", "docstring_tokens": "Like netCDF4 . stringtochar but faster and more flexible .", "label": 0}, {"idx": "cosqa-train-5152", "doc": "how to delete a key in dictionary python", "code": "def delete(self, row):\n        \"\"\"Delete a track value\"\"\"\n        i = self._get_key_index(row)\n        del self.keys[i]", "code_tokens": "def delete ( self , row ) : i = self . _get_key_index ( row ) del self . keys [ i ]", "docstring_tokens": "Delete a track value", "label": 0}, {"idx": "cosqa-train-5153", "doc": "python numpy array to one hot", "code": "def one_hot(x, size, dtype=np.float32):\n  \"\"\"Make a n+1 dim one-hot array from n dim int-categorical array.\"\"\"\n  return np.array(x[..., np.newaxis] == np.arange(size), dtype)", "code_tokens": "def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )", "docstring_tokens": "Make a n + 1 dim one - hot array from n dim int - categorical array .", "label": 1}, {"idx": "cosqa-train-5154", "doc": "how to delete image in python cmd", "code": "def cli(env, identifier):\n    \"\"\"Delete an image.\"\"\"\n\n    image_mgr = SoftLayer.ImageManager(env.client)\n    image_id = helpers.resolve_id(image_mgr.resolve_ids, identifier, 'image')\n\n    image_mgr.delete_image(image_id)", "code_tokens": "def cli ( env , identifier ) : image_mgr = SoftLayer . ImageManager ( env . client ) image_id = helpers . resolve_id ( image_mgr . resolve_ids , identifier , 'image' ) image_mgr . delete_image ( image_id )", "docstring_tokens": "Delete an image .", "label": 0}, {"idx": "cosqa-train-5155", "doc": "python numpy assert a variable is a scaler", "code": "def contains_all(self, array):\n        \"\"\"Test if `array` is an array of real numbers.\"\"\"\n        dtype = getattr(array, 'dtype', None)\n        if dtype is None:\n            dtype = np.result_type(*array)\n        return is_real_dtype(dtype)", "code_tokens": "def contains_all ( self , array ) : dtype = getattr ( array , 'dtype' , None ) if dtype is None : dtype = np . result_type ( * array ) return is_real_dtype ( dtype )", "docstring_tokens": "Test if array is an array of real numbers .", "label": 0}, {"idx": "cosqa-train-5156", "doc": "how to delete some letters in a string in python", "code": "def _sanitize(text):\n    \"\"\"Return sanitized Eidos text field for human readability.\"\"\"\n    d = {'-LRB-': '(', '-RRB-': ')'}\n    return re.sub('|'.join(d.keys()), lambda m: d[m.group(0)], text)", "code_tokens": "def _sanitize ( text ) : d = { '-LRB-' : '(' , '-RRB-' : ')' } return re . sub ( '|' . join ( d . keys ( ) ) , lambda m : d [ m . group ( 0 ) ] , text )", "docstring_tokens": "Return sanitized Eidos text field for human readability .", "label": 1}, {"idx": "cosqa-train-5157", "doc": "python numpy average rolling window", "code": "def movingaverage(arr, window):\n    \"\"\"\n    Calculates the moving average (\"rolling mean\") of an array\n    of a certain window size.\n    \"\"\"\n    m = np.ones(int(window)) / int(window)\n    return scipy.ndimage.convolve1d(arr, m, axis=0, mode='reflect')", "code_tokens": "def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )", "docstring_tokens": "Calculates the moving average ( rolling mean ) of an array of a certain window size .", "label": 1}, {"idx": "cosqa-train-5158", "doc": "how to deprecate function in python", "code": "def deprecate(func):\n  \"\"\" A deprecation warning emmiter as a decorator. \"\"\"\n  @wraps(func)\n  def wrapper(*args, **kwargs):\n    warn(\"Deprecated, this will be removed in the future\", DeprecationWarning)\n    return func(*args, **kwargs)\n  wrapper.__doc__ = \"Deprecated.\\n\" + (wrapper.__doc__ or \"\")\n  return wrapper", "code_tokens": "def deprecate ( func ) : @ wraps ( func ) def wrapper ( * args , * * kwargs ) : warn ( \"Deprecated, this will be removed in the future\" , DeprecationWarning ) return func ( * args , * * kwargs ) wrapper . __doc__ = \"Deprecated.\\n\" + ( wrapper . __doc__ or \"\" ) return wrapper", "docstring_tokens": "A deprecation warning emmiter as a decorator .", "label": 0}, {"idx": "cosqa-train-5159", "doc": "python numpy check if is inf", "code": "def is_int_vector(l):\n    r\"\"\"Checks if l is a numpy array of integers\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 1 and (l.dtype.kind == 'i' or l.dtype.kind == 'u'):\n            return True\n    return False", "code_tokens": "def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False", "docstring_tokens": "r Checks if l is a numpy array of integers", "label": 0}, {"idx": "cosqa-train-5160", "doc": "how to determine a dtype is numeric or not python", "code": "def _isstring(dtype):\n    \"\"\"Given a numpy dtype, determines whether it is a string. Returns True\n    if the dtype is string or unicode.\n    \"\"\"\n    return dtype.type == numpy.unicode_ or dtype.type == numpy.string_", "code_tokens": "def _isstring ( dtype ) : return dtype . type == numpy . unicode_ or dtype . type == numpy . string_", "docstring_tokens": "Given a numpy dtype determines whether it is a string . Returns True if the dtype is string or unicode .", "label": 0}, {"idx": "cosqa-train-5161", "doc": "python numpy datetime64 remove miscroseconds", "code": "def datetime64_to_datetime(dt):\n    \"\"\" convert numpy's datetime64 to datetime \"\"\"\n    dt64 = np.datetime64(dt)\n    ts = (dt64 - np.datetime64('1970-01-01T00:00:00')) / np.timedelta64(1, 's')\n    return datetime.datetime.utcfromtimestamp(ts)", "code_tokens": "def datetime64_to_datetime ( dt ) : dt64 = np . datetime64 ( dt ) ts = ( dt64 - np . datetime64 ( '1970-01-01T00:00:00' ) ) / np . timedelta64 ( 1 , 's' ) return datetime . datetime . utcfromtimestamp ( ts )", "docstring_tokens": "convert numpy s datetime64 to datetime", "label": 0}, {"idx": "cosqa-train-5162", "doc": "how to detremine if a number if a float in python", "code": "def _convert_to_float_if_possible(s):\n    \"\"\"\n    A small helper function to convert a string to a numeric value\n    if appropriate\n\n    :param s: the string to be converted\n    :type s: str\n    \"\"\"\n    try:\n        ret = float(s)\n    except (ValueError, TypeError):\n        ret = s\n    return ret", "code_tokens": "def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret", "docstring_tokens": "A small helper function to convert a string to a numeric value if appropriate", "label": 0}, {"idx": "cosqa-train-5163", "doc": "python numpy l2 normalization", "code": "def normalize(v, axis=None, eps=1e-10):\n  \"\"\"L2 Normalize along specified axes.\"\"\"\n  return v / max(anorm(v, axis=axis, keepdims=True), eps)", "code_tokens": "def normalize ( v , axis = None , eps = 1e-10 ) : return v / max ( anorm ( v , axis = axis , keepdims = True ) , eps )", "docstring_tokens": "L2 Normalize along specified axes .", "label": 0}, {"idx": "cosqa-train-5164", "doc": "how to differentiate between an empty indice and a zero python", "code": "def find_start_point(self):\n        \"\"\"\n        Find the first location in our array that is not empty\n        \"\"\"\n        for i, row in enumerate(self.data):\n            for j, _ in enumerate(row):\n                if self.data[i, j] != 0:  # or not np.isfinite(self.data[i,j]):\n                    return i, j", "code_tokens": "def find_start_point ( self ) : for i , row in enumerate ( self . data ) : for j , _ in enumerate ( row ) : if self . data [ i , j ] != 0 : # or not np.isfinite(self.data[i,j]): return i , j", "docstring_tokens": "Find the first location in our array that is not empty", "label": 0}, {"idx": "cosqa-train-5165", "doc": "python numpy loadtxt header", "code": "def read_mm_header(fd, byte_order, dtype, count):\n    \"\"\"Read MM_HEADER tag from file and return as numpy.rec.array.\"\"\"\n    return numpy.rec.fromfile(fd, MM_HEADER, 1, byteorder=byte_order)[0]", "code_tokens": "def read_mm_header ( fd , byte_order , dtype , count ) : return numpy . rec . fromfile ( fd , MM_HEADER , 1 , byteorder = byte_order ) [ 0 ]", "docstring_tokens": "Read MM_HEADER tag from file and return as numpy . rec . array .", "label": 1}, {"idx": "cosqa-train-5166", "doc": "how to display folium map python3", "code": "def as_html(self):\n        \"\"\"Generate HTML to display map.\"\"\"\n        if not self._folium_map:\n            self.draw()\n        return self._inline_map(self._folium_map, self._width, self._height)", "code_tokens": "def as_html ( self ) : if not self . _folium_map : self . draw ( ) return self . _inline_map ( self . _folium_map , self . _width , self . _height )", "docstring_tokens": "Generate HTML to display map .", "label": 0}, {"idx": "cosqa-train-5167", "doc": "python numpy maximum along an axis", "code": "def Max(a, axis, keep_dims):\n    \"\"\"\n    Max reduction op.\n    \"\"\"\n    return np.amax(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis),\n                   keepdims=keep_dims),", "code_tokens": "def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "docstring_tokens": "Max reduction op .", "label": 1}, {"idx": "cosqa-train-5168", "doc": "how to distinguish between text and binary file in python", "code": "def IsBinary(self, filename):\n\t\t\"\"\"Returns true if the guessed mimetyped isnt't in text group.\"\"\"\n\t\tmimetype = mimetypes.guess_type(filename)[0]\n\t\tif not mimetype:\n\t\t\treturn False  # e.g. README, \"real\" binaries usually have an extension\n\t\t# special case for text files which don't start with text/\n\t\tif mimetype in TEXT_MIMETYPES:\n\t\t\treturn False\n\t\treturn not mimetype.startswith(\"text/\")", "code_tokens": "def IsBinary ( self , filename ) : mimetype = mimetypes . guess_type ( filename ) [ 0 ] if not mimetype : return False # e.g. README, \"real\" binaries usually have an extension # special case for text files which don't start with text/ if mimetype in TEXT_MIMETYPES : return False return not mimetype . startswith ( \"text/\" )", "docstring_tokens": "Returns true if the guessed mimetyped isnt t in text group .", "label": 0}, {"idx": "cosqa-train-5169", "doc": "python numpy read from file", "code": "def read_numpy(fd, byte_order, dtype, count):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    return numpy.fromfile(fd, byte_order+dtype[-1], count)", "code_tokens": "def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 0}, {"idx": "cosqa-train-5170", "doc": "how to do adjacency matrix in python and compute matrix", "code": "def get_adjacent_matrix(self):\n        \"\"\"Get adjacency matrix.\n\n        Returns:\n            :param adj: adjacency matrix\n            :type adj: np.ndarray\n        \"\"\"\n        edges = self.edges\n        num_edges = len(edges) + 1\n        adj = np.zeros([num_edges, num_edges])\n\n        for k in range(num_edges - 1):\n            adj[edges[k].L, edges[k].R] = 1\n            adj[edges[k].R, edges[k].L] = 1\n\n        return adj", "code_tokens": "def get_adjacent_matrix ( self ) : edges = self . edges num_edges = len ( edges ) + 1 adj = np . zeros ( [ num_edges , num_edges ] ) for k in range ( num_edges - 1 ) : adj [ edges [ k ] . L , edges [ k ] . R ] = 1 adj [ edges [ k ] . R , edges [ k ] . L ] = 1 return adj", "docstring_tokens": "Get adjacency matrix .", "label": 1}, {"idx": "cosqa-train-5171", "doc": "python numpy return minimum", "code": "def fn_min(self, a, axis=None):\n        \"\"\"\n        Return the minimum of an array, ignoring any NaNs.\n\n        :param a: The array.\n        :return: The minimum value of the array.\n        \"\"\"\n\n        return numpy.nanmin(self._to_ndarray(a), axis=axis)", "code_tokens": "def fn_min ( self , a , axis = None ) : return numpy . nanmin ( self . _to_ndarray ( a ) , axis = axis )", "docstring_tokens": "Return the minimum of an array ignoring any NaNs .", "label": 0}, {"idx": "cosqa-train-5172", "doc": "how to do float if in python", "code": "def clean_float(v):\n    \"\"\"Remove commas from a float\"\"\"\n\n    if v is None or not str(v).strip():\n        return None\n\n    return float(str(v).replace(',', ''))", "code_tokens": "def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )", "docstring_tokens": "Remove commas from a float", "label": 1}, {"idx": "cosqa-train-5173", "doc": "python numpy shuffle data", "code": "def _shuffle(data, idx):\n    \"\"\"Shuffle the data.\"\"\"\n    shuffle_data = []\n\n    for idx_k, idx_v in data:\n        shuffle_data.append((idx_k, mx.ndarray.array(idx_v.asnumpy()[idx], idx_v.context)))\n\n    return shuffle_data", "code_tokens": "def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data", "docstring_tokens": "Shuffle the data .", "label": 0}, {"idx": "cosqa-train-5174", "doc": "how to do logarithm in python numpy", "code": "def to_distribution_values(self, values):\n        \"\"\"\n        Returns numpy array of natural logarithms of ``values``.\n        \"\"\"\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            # avoid RuntimeWarning: divide by zero encountered in log\n            return numpy.log(values)", "code_tokens": "def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( \"ignore\" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )", "docstring_tokens": "Returns numpy array of natural logarithms of values .", "label": 0}, {"idx": "cosqa-train-5175", "doc": "python numpy top k indeces", "code": "def rank(self):\n        \"\"\"how high in sorted list each key is. inverse permutation of sorter, such that sorted[rank]==keys\"\"\"\n        r = np.empty(self.size, np.int)\n        r[self.sorter] = np.arange(self.size)\n        return r", "code_tokens": "def rank ( self ) : r = np . empty ( self . size , np . int ) r [ self . sorter ] = np . arange ( self . size ) return r", "docstring_tokens": "how high in sorted list each key is . inverse permutation of sorter such that sorted [ rank ] == keys", "label": 1}, {"idx": "cosqa-train-5176", "doc": "how to do tokenization in python", "code": "def tokenize(string):\n    \"\"\"Match and yield all the tokens of the input string.\"\"\"\n    for match in TOKENS_REGEX.finditer(string):\n        yield Token(match.lastgroup, match.group().strip(), match.span())", "code_tokens": "def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "docstring_tokens": "Match and yield all the tokens of the input string .", "label": 0}, {"idx": "cosqa-train-5177", "doc": "python object attribute 'lower'", "code": "def name(self):\n        \"\"\"A unique name for this scraper.\"\"\"\n        return ''.join('_%s' % c if c.isupper() else c for c in self.__class__.__name__).strip('_').lower()", "code_tokens": "def name ( self ) : return '' . join ( '_%s' % c if c . isupper ( ) else c for c in self . __class__ . __name__ ) . strip ( '_' ) . lower ( )", "docstring_tokens": "A unique name for this scraper .", "label": 0}, {"idx": "cosqa-train-5178", "doc": "how to downlond python tokenzier", "code": "def tokenize(string):\n    \"\"\"Match and yield all the tokens of the input string.\"\"\"\n    for match in TOKENS_REGEX.finditer(string):\n        yield Token(match.lastgroup, match.group().strip(), match.span())", "code_tokens": "def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "docstring_tokens": "Match and yield all the tokens of the input string .", "label": 0}, {"idx": "cosqa-train-5179", "doc": "python object instance is copy", "code": "def __copy__(self):\n        \"\"\"A magic method to implement shallow copy behavior.\"\"\"\n        return self.__class__.load(self.dump(), context=self.context)", "code_tokens": "def __copy__ ( self ) : return self . __class__ . load ( self . dump ( ) , context = self . context )", "docstring_tokens": "A magic method to implement shallow copy behavior .", "label": 0}, {"idx": "cosqa-train-5180", "doc": "how to drop single capital alphabets from a text in python", "code": "def _to_lower_alpha_only(s):\n    \"\"\"Return a lowercased string with non alphabetic chars removed.\n\n    White spaces are not to be removed.\"\"\"\n    s = re.sub(r'\\n', ' ',  s.lower())\n    return re.sub(r'[^a-z\\s]', '', s)", "code_tokens": "def _to_lower_alpha_only ( s ) : s = re . sub ( r'\\n' , ' ' , s . lower ( ) ) return re . sub ( r'[^a-z\\s]' , '' , s )", "docstring_tokens": "Return a lowercased string with non alphabetic chars removed .", "label": 0}, {"idx": "cosqa-train-5181", "doc": "python object of type method is not json serializable", "code": "def is_serializable(obj):\n    \"\"\"Return `True` if the given object conforms to the Serializable protocol.\n\n    :rtype: bool\n    \"\"\"\n    if inspect.isclass(obj):\n      return Serializable.is_serializable_type(obj)\n    return isinstance(obj, Serializable) or hasattr(obj, '_asdict')", "code_tokens": "def is_serializable ( obj ) : if inspect . isclass ( obj ) : return Serializable . is_serializable_type ( obj ) return isinstance ( obj , Serializable ) or hasattr ( obj , '_asdict' )", "docstring_tokens": "Return True if the given object conforms to the Serializable protocol .", "label": 1}, {"idx": "cosqa-train-5182", "doc": "how to eliminate periodic noise in sound python", "code": "def synthesize(self, duration):\n        \"\"\"\n        Synthesize white noise\n\n        Args:\n            duration (numpy.timedelta64): The duration of the synthesized sound\n        \"\"\"\n        sr = self.samplerate.samples_per_second\n        seconds = duration / Seconds(1)\n        samples = np.random.uniform(low=-1., high=1., size=int(sr * seconds))\n        return AudioSamples(samples, self.samplerate)", "code_tokens": "def synthesize ( self , duration ) : sr = self . samplerate . samples_per_second seconds = duration / Seconds ( 1 ) samples = np . random . uniform ( low = - 1. , high = 1. , size = int ( sr * seconds ) ) return AudioSamples ( samples , self . samplerate )", "docstring_tokens": "Synthesize white noise", "label": 0}, {"idx": "cosqa-train-5183", "doc": "python oif dat equals type", "code": "def _is_date_data(self, data_type):\n        \"\"\"Private method for determining if a data record is of type DATE.\"\"\"\n        dt = DATA_TYPES[data_type]\n        if isinstance(self.data, dt['type']):\n            self.type = data_type.upper()\n            self.len = None\n            return True", "code_tokens": "def _is_date_data ( self , data_type ) : dt = DATA_TYPES [ data_type ] if isinstance ( self . data , dt [ 'type' ] ) : self . type = data_type . upper ( ) self . len = None return True", "docstring_tokens": "Private method for determining if a data record is of type DATE .", "label": 0}, {"idx": "cosqa-train-5184", "doc": "how to enter new line python", "code": "def go_to_new_line(self):\n        \"\"\"Go to the end of the current line and create a new line\"\"\"\n        self.stdkey_end(False, False)\n        self.insert_text(self.get_line_separator())", "code_tokens": "def go_to_new_line ( self ) : self . stdkey_end ( False , False ) self . insert_text ( self . get_line_separator ( ) )", "docstring_tokens": "Go to the end of the current line and create a new line", "label": 0}, {"idx": "cosqa-train-5185", "doc": "python only return real solution complex number", "code": "def part(z, s):\n    r\"\"\"Get the real or imaginary part of a complex number.\"\"\"\n    if sage_included:\n        if s == 1: return np.real(z)\n        elif s == -1: return np.imag(z)\n        elif s == 0:\n            return z\n    else:\n        if s == 1: return z.real\n        elif s == -1: return z.imag\n        elif s == 0: return z", "code_tokens": "def part ( z , s ) : if sage_included : if s == 1 : return np . real ( z ) elif s == - 1 : return np . imag ( z ) elif s == 0 : return z else : if s == 1 : return z . real elif s == - 1 : return z . imag elif s == 0 : return z", "docstring_tokens": "r Get the real or imaginary part of a complex number .", "label": 0}, {"idx": "cosqa-train-5186", "doc": "how to exclude certain records matching a pattern using regex in python", "code": "def seq_include(records, filter_regex):\n    \"\"\"\n    Filter any sequences who's seq does not match the filter. Ignore case.\n    \"\"\"\n    regex = re.compile(filter_regex)\n    for record in records:\n        if regex.search(str(record.seq)):\n            yield record", "code_tokens": "def seq_include ( records , filter_regex ) : regex = re . compile ( filter_regex ) for record in records : if regex . search ( str ( record . seq ) ) : yield record", "docstring_tokens": "Filter any sequences who s seq does not match the filter . Ignore case .", "label": 0}, {"idx": "cosqa-train-5187", "doc": "python open a file writing that doesn't exist", "code": "def _replace_file(path, content):\n  \"\"\"Writes a file if it doesn't already exist with the same content.\n\n  This is useful because cargo uses timestamps to decide whether to compile things.\"\"\"\n  if os.path.exists(path):\n    with open(path, 'r') as f:\n      if content == f.read():\n        print(\"Not overwriting {} because it is unchanged\".format(path), file=sys.stderr)\n        return\n\n  with open(path, 'w') as f:\n    f.write(content)", "code_tokens": "def _replace_file ( path , content ) : if os . path . exists ( path ) : with open ( path , 'r' ) as f : if content == f . read ( ) : print ( \"Not overwriting {} because it is unchanged\" . format ( path ) , file = sys . stderr ) return with open ( path , 'w' ) as f : f . write ( content )", "docstring_tokens": "Writes a file if it doesn t already exist with the same content .", "label": 1}, {"idx": "cosqa-train-5188", "doc": "how to execute multiple functions serially python", "code": "def parallel(processes, threads):\n    \"\"\"\n    execute jobs in processes using N threads\n    \"\"\"\n    pool = multithread(threads)\n    pool.map(run_process, processes)\n    pool.close()\n    pool.join()", "code_tokens": "def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )", "docstring_tokens": "execute jobs in processes using N threads", "label": 0}, {"idx": "cosqa-train-5189", "doc": "python open dot file", "code": "def graph_from_dot_file(path):\n    \"\"\"Load graph as defined by a DOT file.\n    \n    The file is assumed to be in DOT format. It will\n    be loaded, parsed and a Dot class will be returned, \n    representing the graph.\n    \"\"\"\n    \n    fd = file(path, 'rb')\n    data = fd.read()\n    fd.close()\n    \n    return graph_from_dot_data(data)", "code_tokens": "def graph_from_dot_file ( path ) : fd = file ( path , 'rb' ) data = fd . read ( ) fd . close ( ) return graph_from_dot_data ( data )", "docstring_tokens": "Load graph as defined by a DOT file . The file is assumed to be in DOT format . It will be loaded parsed and a Dot class will be returned representing the graph .", "label": 0}, {"idx": "cosqa-train-5190", "doc": "python open file encoding default setting", "code": "def open_with_encoding(filename, encoding, mode='r'):\n    \"\"\"Return opened file with a specific encoding.\"\"\"\n    return io.open(filename, mode=mode, encoding=encoding,\n                   newline='')", "code_tokens": "def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )", "docstring_tokens": "Return opened file with a specific encoding .", "label": 0}, {"idx": "cosqa-train-5191", "doc": "how to export python graph to excel", "code": "def save_dot(self, fd):\n        \"\"\" Saves a representation of the case in the Graphviz DOT language.\n        \"\"\"\n        from pylon.io import DotWriter\n        DotWriter(self).write(fd)", "code_tokens": "def save_dot ( self , fd ) : from pylon . io import DotWriter DotWriter ( self ) . write ( fd )", "docstring_tokens": "Saves a representation of the case in the Graphviz DOT language .", "label": 0}, {"idx": "cosqa-train-5192", "doc": "python open file without permissions", "code": "def fopenat(base_fd, path):\n    \"\"\"\n    Does openat read-only, then does fdopen to get a file object\n    \"\"\"\n\n    return os.fdopen(openat(base_fd, path, os.O_RDONLY), 'rb')", "code_tokens": "def fopenat ( base_fd , path ) : return os . fdopen ( openat ( base_fd , path , os . O_RDONLY ) , 'rb' )", "docstring_tokens": "Does openat read - only then does fdopen to get a file object", "label": 0}, {"idx": "cosqa-train-5193", "doc": "how to exschange list to string python", "code": "def list_i2str(ilist):\n    \"\"\"\n    Convert an integer list into a string list.\n    \"\"\"\n    slist = []\n    for el in ilist:\n        slist.append(str(el))\n    return slist", "code_tokens": "def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist", "docstring_tokens": "Convert an integer list into a string list .", "label": 0}, {"idx": "cosqa-train-5194", "doc": "python open image file to object", "code": "def get_image(self, source):\n        \"\"\"\n        Given a file-like object, loads it up into a PIL.Image object\n        and returns it.\n\n        :param file source: A file-like object to load the image from.\n        :rtype: PIL.Image\n        :returns: The loaded image.\n        \"\"\"\n        buf = StringIO(source.read())\n        return Image.open(buf)", "code_tokens": "def get_image ( self , source ) : buf = StringIO ( source . read ( ) ) return Image . open ( buf )", "docstring_tokens": "Given a file - like object loads it up into a PIL . Image object and returns it .", "label": 0}, {"idx": "cosqa-train-5195", "doc": "how to filter out the punctuation from a string in python", "code": "def tokenize_words(self, text):\n        \"\"\"Tokenize an input string into a list of words (with punctuation removed).\"\"\"\n        return [\n            self.strip_punctuation(word) for word in text.split(' ')\n            if self.strip_punctuation(word)\n        ]", "code_tokens": "def tokenize_words ( self , text ) : return [ self . strip_punctuation ( word ) for word in text . split ( ' ' ) if self . strip_punctuation ( word ) ]", "docstring_tokens": "Tokenize an input string into a list of words ( with punctuation removed ) .", "label": 1}, {"idx": "cosqa-train-5196", "doc": "python open slice buffer", "code": "def getbyteslice(self, start, end):\n        \"\"\"Direct access to byte data.\"\"\"\n        c = self._rawarray[start:end]\n        return c", "code_tokens": "def getbyteslice ( self , start , end ) : c = self . _rawarray [ start : end ] return c", "docstring_tokens": "Direct access to byte data .", "label": 1}, {"idx": "cosqa-train-5197", "doc": "how to fit gaussian in python", "code": "def fit_gaussian(x, y, yerr, p0):\n    \"\"\" Fit a Gaussian to the data \"\"\"\n    try:\n        popt, pcov = curve_fit(gaussian, x, y, sigma=yerr, p0=p0, absolute_sigma=True)\n    except RuntimeError:\n        return [0],[0]\n    return popt, pcov", "code_tokens": "def fit_gaussian ( x , y , yerr , p0 ) : try : popt , pcov = curve_fit ( gaussian , x , y , sigma = yerr , p0 = p0 , absolute_sigma = True ) except RuntimeError : return [ 0 ] , [ 0 ] return popt , pcov", "docstring_tokens": "Fit a Gaussian to the data", "label": 0}, {"idx": "cosqa-train-5198", "doc": "python opencv gaussian blur", "code": "def GaussianBlur(X, ksize_width, ksize_height, sigma_x, sigma_y):\n    \"\"\"Apply Gaussian blur to the given data.\n\n    Args:\n        X: data to blur\n        kernel_size: Gaussian kernel size\n        stddev: Gaussian kernel standard deviation (in both X and Y directions)\n    \"\"\"\n    return image_transform(\n        X,\n        cv2.GaussianBlur,\n        ksize=(ksize_width, ksize_height),\n        sigmaX=sigma_x,\n        sigmaY=sigma_y\n    )", "code_tokens": "def GaussianBlur ( X , ksize_width , ksize_height , sigma_x , sigma_y ) : return image_transform ( X , cv2 . GaussianBlur , ksize = ( ksize_width , ksize_height ) , sigmaX = sigma_x , sigmaY = sigma_y )", "docstring_tokens": "Apply Gaussian blur to the given data .", "label": 1}, {"idx": "cosqa-train-5199", "doc": "how to flatten a python list", "code": "def flatten(l):\n    \"\"\"Flatten a nested list.\"\"\"\n    return sum(map(flatten, l), []) \\\n        if isinstance(l, list) or isinstance(l, tuple) else [l]", "code_tokens": "def flatten ( l ) : return sum ( map ( flatten , l ) , [ ] ) if isinstance ( l , list ) or isinstance ( l , tuple ) else [ l ]", "docstring_tokens": "Flatten a nested list .", "label": 0}, {"idx": "cosqa-train-5200", "doc": "python opencv rotate along z axis", "code": "def zoom_cv(x,z):\n    \"\"\" Zoom the center of image x by a factor of z+1 while retaining the original image size and proportion. \"\"\"\n    if z==0: return x\n    r,c,*_ = x.shape\n    M = cv2.getRotationMatrix2D((c/2,r/2),0,z+1.)\n    return cv2.warpAffine(x,M,(c,r))", "code_tokens": "def zoom_cv ( x , z ) : if z == 0 : return x r , c ,  * _ = x . shape M = cv2 . getRotationMatrix2D ( ( c / 2 , r / 2 ) , 0 , z + 1. ) return cv2 . warpAffine ( x , M , ( c , r ) )", "docstring_tokens": "Zoom the center of image x by a factor of z + 1 while retaining the original image size and proportion .", "label": 0}, {"idx": "cosqa-train-5201", "doc": "how to flip a matrix in python", "code": "def imflip(img, direction='horizontal'):\n    \"\"\"Flip an image horizontally or vertically.\n\n    Args:\n        img (ndarray): Image to be flipped.\n        direction (str): The flip direction, either \"horizontal\" or \"vertical\".\n\n    Returns:\n        ndarray: The flipped image.\n    \"\"\"\n    assert direction in ['horizontal', 'vertical']\n    if direction == 'horizontal':\n        return np.flip(img, axis=1)\n    else:\n        return np.flip(img, axis=0)", "code_tokens": "def imflip ( img , direction = 'horizontal' ) : assert direction in [ 'horizontal' , 'vertical' ] if direction == 'horizontal' : return np . flip ( img , axis = 1 ) else : return np . flip ( img , axis = 0 )", "docstring_tokens": "Flip an image horizontally or vertically .", "label": 1}, {"idx": "cosqa-train-5202", "doc": "python opencv2 warpaffine center", "code": "def warp(self, warp_matrix, img, iflag=cv2.INTER_NEAREST):\n        \"\"\" Function to warp input image given an estimated 2D linear transformation\n\n        :param warp_matrix: Linear 2x3 matrix to use to linearly warp the input images\n        :type warp_matrix: ndarray\n        :param img: Image to be warped with estimated transformation\n        :type img: ndarray\n        :param iflag: Interpolation flag, specified interpolation using during resampling of warped image\n        :type iflag: cv2.INTER_*\n        :return: Warped image using the linear matrix\n        \"\"\"\n\n        height, width = img.shape[:2]\n        warped_img = np.zeros_like(img, dtype=img.dtype)\n\n        # Check if image to warp is 2D or 3D. If 3D need to loop over channels\n        if (self.interpolation_type == InterpolationType.LINEAR) or img.ndim == 2:\n            warped_img = cv2.warpAffine(img.astype(np.float32), warp_matrix, (width, height),\n                                        flags=iflag).astype(img.dtype)\n\n        elif img.ndim == 3:\n            for idx in range(img.shape[-1]):\n                warped_img[..., idx] = cv2.warpAffine(img[..., idx].astype(np.float32), warp_matrix, (width, height),\n                                                      flags=iflag).astype(img.dtype)\n        else:\n            raise ValueError('Image has incorrect number of dimensions: {}'.format(img.ndim))\n\n        return warped_img", "code_tokens": "def warp ( self , warp_matrix , img , iflag = cv2 . INTER_NEAREST ) : height , width = img . shape [ : 2 ] warped_img = np . zeros_like ( img , dtype = img . dtype ) # Check if image to warp is 2D or 3D. If 3D need to loop over channels if ( self . interpolation_type == InterpolationType . LINEAR ) or img . ndim == 2 : warped_img = cv2 . warpAffine ( img . astype ( np . float32 ) , warp_matrix , ( width , height ) , flags = iflag ) . astype ( img . dtype ) elif img . ndim == 3 : for idx in range ( img . shape [ - 1 ] ) : warped_img [ ... , idx ] = cv2 . warpAffine ( img [ ... , idx ] . astype ( np . float32 ) , warp_matrix , ( width , height ) , flags = iflag ) . astype ( img . dtype ) else : raise ValueError ( 'Image has incorrect number of dimensions: {}' . format ( img . ndim ) ) return warped_img", "docstring_tokens": "Function to warp input image given an estimated 2D linear transformation", "label": 0}, {"idx": "cosqa-train-5203", "doc": "how to force exit python without raise", "code": "def __exit__(self, type, value, traceback):\n        \"\"\"When the `with` statement ends.\"\"\"\n\n        if not self.asarfile:\n            return\n\n        self.asarfile.close()\n        self.asarfile = None", "code_tokens": "def __exit__ ( self , type , value , traceback ) : if not self . asarfile : return self . asarfile . close ( ) self . asarfile = None", "docstring_tokens": "When the with statement ends .", "label": 1}, {"idx": "cosqa-train-5204", "doc": "python opens file and immdiately closes", "code": "def file_read(filename):\n    \"\"\"Read a file and close it.  Returns the file source.\"\"\"\n    fobj = open(filename,'r');\n    source = fobj.read();\n    fobj.close()\n    return source", "code_tokens": "def file_read ( filename ) : fobj = open ( filename , 'r' ) source = fobj . read ( ) fobj . close ( ) return source", "docstring_tokens": "Read a file and close it . Returns the file source .", "label": 1}, {"idx": "cosqa-train-5205", "doc": "how to force kill without prompt in python", "code": "def set_stop_handler(self):\n        \"\"\"\n        Initializes functions that are invoked when the user or OS wants to kill this process.\n        :return:\n        \"\"\"\n        signal.signal(signal.SIGTERM, self.graceful_stop)\n        signal.signal(signal.SIGABRT, self.graceful_stop)\n        signal.signal(signal.SIGINT, self.graceful_stop)", "code_tokens": "def set_stop_handler ( self ) : signal . signal ( signal . SIGTERM , self . graceful_stop ) signal . signal ( signal . SIGABRT , self . graceful_stop ) signal . signal ( signal . SIGINT , self . graceful_stop )", "docstring_tokens": "Initializes functions that are invoked when the user or OS wants to kill this process . : return :", "label": 1}, {"idx": "cosqa-train-5206", "doc": "python optional multiple return", "code": "def many_until1(these, term):\n    \"\"\"Like many_until but must consume at least one of these.\n    \"\"\"\n    first = [these()]\n    these_results, term_result = many_until(these, term)\n    return (first + these_results, term_result)", "code_tokens": "def many_until1 ( these , term ) : first = [ these ( ) ] these_results , term_result = many_until ( these , term ) return ( first + these_results , term_result )", "docstring_tokens": "Like many_until but must consume at least one of these .", "label": 0}, {"idx": "cosqa-train-5207", "doc": "how to format text to capitalize in python", "code": "def camel_case(self, snake_case):\n        \"\"\" Convert snake case to camel case \"\"\"\n        components = snake_case.split('_')\n        return components[0] + \"\".join(x.title() for x in components[1:])", "code_tokens": "def camel_case ( self , snake_case ) : components = snake_case . split ( '_' ) return components [ 0 ] + \"\" . join ( x . title ( ) for x in components [ 1 : ] )", "docstring_tokens": "Convert snake case to camel case", "label": 0}, {"idx": "cosqa-train-5208", "doc": "python optionparser show help in the same line", "code": "def help(self, level=0):\n        \"\"\"return the usage string for available options \"\"\"\n        self.cmdline_parser.formatter.output_level = level\n        with _patch_optparse():\n            return self.cmdline_parser.format_help()", "code_tokens": "def help ( self , level = 0 ) : self . cmdline_parser . formatter . output_level = level with _patch_optparse ( ) : return self . cmdline_parser . format_help ( )", "docstring_tokens": "return the usage string for available options", "label": 0}, {"idx": "cosqa-train-5209", "doc": "how to generate a key from the given string in python", "code": "def unit_key_from_name(name):\n  \"\"\"Return a legal python name for the given name for use as a unit key.\"\"\"\n  result = name\n\n  for old, new in six.iteritems(UNIT_KEY_REPLACEMENTS):\n    result = result.replace(old, new)\n\n  # Collapse redundant underscores and convert to uppercase.\n  result = re.sub(r'_+', '_', result.upper())\n\n  return result", "code_tokens": "def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result", "docstring_tokens": "Return a legal python name for the given name for use as a unit key .", "label": 0}, {"idx": "cosqa-train-5210", "doc": "python oracle accessing database column names", "code": "def column_names(self, table):\n      \"\"\"An iterable of column names, for a particular table or\n      view.\"\"\"\n\n      table_info = self.execute(\n        u'PRAGMA table_info(%s)' % quote(table))\n      return (column['name'] for column in table_info)", "code_tokens": "def column_names ( self , table ) : table_info = self . execute ( u'PRAGMA table_info(%s)' % quote ( table ) ) return ( column [ 'name' ] for column in table_info )", "docstring_tokens": "An iterable of column names for a particular table or view .", "label": 0}, {"idx": "cosqa-train-5211", "doc": "how to generate an 'aware' datetime object in python 3", "code": "def get_naive(dt):\n  \"\"\"Gets a naive datetime from a datetime.\n\n  datetime_tz objects can't just have tzinfo replaced with None, you need to\n  call asdatetime.\n\n  Args:\n    dt: datetime object.\n\n  Returns:\n    datetime object without any timezone information.\n  \"\"\"\n  if not dt.tzinfo:\n    return dt\n  if hasattr(dt, \"asdatetime\"):\n    return dt.asdatetime()\n  return dt.replace(tzinfo=None)", "code_tokens": "def get_naive ( dt ) : if not dt . tzinfo : return dt if hasattr ( dt , \"asdatetime\" ) : return dt . asdatetime ( ) return dt . replace ( tzinfo = None )", "docstring_tokens": "Gets a naive datetime from a datetime .", "label": 0}, {"idx": "cosqa-train-5212", "doc": "python oracle table metadata", "code": "def get_table_metadata(engine, table):\n    \"\"\" Extract all useful infos from the given table\n\n    Args:\n        engine: SQLAlchemy connection engine\n        table: table name\n\n    Returns:\n        Dictionary of infos\n    \"\"\"\n    metadata = MetaData()\n    metadata.reflect(bind=engine, only=[table])\n    table_metadata = Table(table, metadata, autoload=True)\n    return table_metadata", "code_tokens": "def get_table_metadata ( engine , table ) : metadata = MetaData ( ) metadata . reflect ( bind = engine , only = [ table ] ) table_metadata = Table ( table , metadata , autoload = True ) return table_metadata", "docstring_tokens": "Extract all useful infos from the given table", "label": 0}, {"idx": "cosqa-train-5213", "doc": "how to generate random floats in python with precision", "code": "def money(min=0, max=10):\n    \"\"\"Return a str of decimal with two digits after a decimal mark.\"\"\"\n    value = random.choice(range(min * 100, max * 100))\n    return \"%1.2f\" % (float(value) / 100)", "code_tokens": "def money ( min = 0 , max = 10 ) : value = random . choice ( range ( min * 100 , max * 100 ) ) return \"%1.2f\" % ( float ( value ) / 100 )", "docstring_tokens": "Return a str of decimal with two digits after a decimal mark .", "label": 0}, {"idx": "cosqa-train-5214", "doc": "python oracle truncate a table;", "code": "def truncate(self, table):\n        \"\"\"Empty a table by deleting all of its rows.\"\"\"\n        if isinstance(table, (list, set, tuple)):\n            for t in table:\n                self._truncate(t)\n        else:\n            self._truncate(table)", "code_tokens": "def truncate ( self , table ) : if isinstance ( table , ( list , set , tuple ) ) : for t in table : self . _truncate ( t ) else : self . _truncate ( table )", "docstring_tokens": "Empty a table by deleting all of its rows .", "label": 0}, {"idx": "cosqa-train-5215", "doc": "how to get a file from a website using python", "code": "def wget(url):\n    \"\"\"\n    Download the page into a string\n    \"\"\"\n    import urllib.parse\n    request = urllib.request.urlopen(url)\n    filestring = request.read()\n    return filestring", "code_tokens": "def wget ( url ) : import urllib . parse request = urllib . request . urlopen ( url ) filestring = request . read ( ) return filestring", "docstring_tokens": "Download the page into a string", "label": 1}, {"idx": "cosqa-train-5216", "doc": "python output image shape", "code": "def out_shape_from_array(arr):\n    \"\"\"Get the output shape from an array.\"\"\"\n    arr = np.asarray(arr)\n    if arr.ndim == 1:\n        return arr.shape\n    else:\n        return (arr.shape[1],)", "code_tokens": "def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "docstring_tokens": "Get the output shape from an array .", "label": 0}, {"idx": "cosqa-train-5217", "doc": "how to get a scanner in python", "code": "def _import(module, cls):\n    \"\"\"\n    A messy way to import library-specific classes.\n    TODO: I should really make a factory class or something, but I'm lazy.\n    Plus, factories remind me a lot of java...\n    \"\"\"\n    global Scanner\n\n    try:\n        cls = str(cls)\n        mod = __import__(str(module), globals(), locals(), [cls], 1)\n        Scanner = getattr(mod, cls)\n    except ImportError:\n        pass", "code_tokens": "def _import ( module , cls ) : global Scanner try : cls = str ( cls ) mod = __import__ ( str ( module ) , globals ( ) , locals ( ) , [ cls ] , 1 ) Scanner = getattr ( mod , cls ) except ImportError : pass", "docstring_tokens": "A messy way to import library - specific classes . TODO : I should really make a factory class or something but I m lazy . Plus factories remind me a lot of java ...", "label": 0}, {"idx": "cosqa-train-5218", "doc": "python output redirect to file windows", "code": "def redirect_output(fileobj):\n    \"\"\"Redirect standard out to file.\"\"\"\n    old = sys.stdout\n    sys.stdout = fileobj\n    try:\n        yield fileobj\n    finally:\n        sys.stdout = old", "code_tokens": "def redirect_output ( fileobj ) : old = sys . stdout sys . stdout = fileobj try : yield fileobj finally : sys . stdout = old", "docstring_tokens": "Redirect standard out to file .", "label": 0}, {"idx": "cosqa-train-5219", "doc": "how to get average of an array in python", "code": "def variance(arr):\n  \"\"\"variance of the values, must have 2 or more entries.\n\n  :param arr: list of numbers\n  :type arr: number[] a number array\n  :return: variance\n  :rtype: float\n\n  \"\"\"\n  avg = average(arr)\n  return sum([(float(x)-avg)**2 for x in arr])/float(len(arr)-1)", "code_tokens": "def variance ( arr ) : avg = average ( arr ) return sum ( [ ( float ( x ) - avg ) ** 2 for x in arr ] ) / float ( len ( arr ) - 1 )", "docstring_tokens": "variance of the values must have 2 or more entries .", "label": 0}, {"idx": "cosqa-train-5220", "doc": "python overload requests session", "code": "def requests_request(method, url, **kwargs):\n    \"\"\"Requests-mock requests.request wrapper.\"\"\"\n    session = local_sessions.session\n    response = session.request(method=method, url=url, **kwargs)\n    session.close()\n    return response", "code_tokens": "def requests_request ( method , url , * * kwargs ) : session = local_sessions . session response = session . request ( method = method , url = url , * * kwargs ) session . close ( ) return response", "docstring_tokens": "Requests - mock requests . request wrapper .", "label": 0}, {"idx": "cosqa-train-5221", "doc": "how to get column names from oracle table using select query in python code", "code": "def column_names(self, table):\n      \"\"\"An iterable of column names, for a particular table or\n      view.\"\"\"\n\n      table_info = self.execute(\n        u'PRAGMA table_info(%s)' % quote(table))\n      return (column['name'] for column in table_info)", "code_tokens": "def column_names ( self , table ) : table_info = self . execute ( u'PRAGMA table_info(%s)' % quote ( table ) ) return ( column [ 'name' ] for column in table_info )", "docstring_tokens": "An iterable of column names for a particular table or view .", "label": 1}, {"idx": "cosqa-train-5222", "doc": "python pager for stdout", "code": "def autopage(self):\n        \"\"\"Iterate through results from all pages.\n\n        :return: all results\n        :rtype: generator\n        \"\"\"\n        while self.items:\n            yield from self.items\n            self.items = self.fetch_next()", "code_tokens": "def autopage ( self ) : while self . items : yield from self . items self . items = self . fetch_next ( )", "docstring_tokens": "Iterate through results from all pages .", "label": 0}, {"idx": "cosqa-train-5223", "doc": "how to get correlation matrix in python", "code": "def sample_correlations(self):\n        \"\"\"Returns an `ExpMatrix` containing all pairwise sample correlations.\n\n        Returns\n        -------\n        `ExpMatrix`\n            The sample correlation matrix.\n\n        \"\"\"\n        C = np.corrcoef(self.X.T)\n        corr_matrix = ExpMatrix(genes=self.samples, samples=self.samples, X=C)\n        return corr_matrix", "code_tokens": "def sample_correlations ( self ) : C = np . corrcoef ( self . X . T ) corr_matrix = ExpMatrix ( genes = self . samples , samples = self . samples , X = C ) return corr_matrix", "docstring_tokens": "Returns an ExpMatrix containing all pairwise sample correlations .", "label": 0}, {"idx": "cosqa-train-5224", "doc": "python parse dynamic log file", "code": "def parse(self):\n        \"\"\"\n        Parse file specified by constructor.\n        \"\"\"\n        f = open(self.parse_log_path, \"r\")\n        self.parse2(f)\n        f.close()", "code_tokens": "def parse ( self ) : f = open ( self . parse_log_path , \"r\" ) self . parse2 ( f ) f . close ( )", "docstring_tokens": "Parse file specified by constructor .", "label": 1}, {"idx": "cosqa-train-5225", "doc": "how to get definition of function in python using command", "code": "def find(command, on):\n    \"\"\"Find the command usage.\"\"\"\n    output_lines = parse_man_page(command, on)\n    click.echo(''.join(output_lines))", "code_tokens": "def find ( command , on ) : output_lines = parse_man_page ( command , on ) click . echo ( '' . join ( output_lines ) )", "docstring_tokens": "Find the command usage .", "label": 0}, {"idx": "cosqa-train-5226", "doc": "python parse json stringify", "code": "def serialize_json_string(self, value):\n        \"\"\"\n        Tries to load an encoded json string back into an object\n        :param json_string:\n        :return:\n        \"\"\"\n\n        # Check if the value might be a json string\n        if not isinstance(value, six.string_types):\n            return value\n\n        # Make sure it starts with a brace\n        if not value.startswith('{') or value.startswith('['):\n            return value\n\n        # Try to load the string\n        try:\n            return json.loads(value)\n        except:\n            return value", "code_tokens": "def serialize_json_string ( self , value ) : # Check if the value might be a json string if not isinstance ( value , six . string_types ) : return value # Make sure it starts with a brace if not value . startswith ( '{' ) or value . startswith ( '[' ) : return value # Try to load the string try : return json . loads ( value ) except : return value", "docstring_tokens": "Tries to load an encoded json string back into an object : param json_string : : return :", "label": 1}, {"idx": "cosqa-train-5227", "doc": "how to get distinct values in python", "code": "def distinct(xs):\n    \"\"\"Get the list of distinct values with preserving order.\"\"\"\n    # don't use collections.OrderedDict because we do support Python 2.6\n    seen = set()\n    return [x for x in xs if x not in seen and not seen.add(x)]", "code_tokens": "def distinct ( xs ) : # don't use collections.OrderedDict because we do support Python 2.6 seen = set ( ) return [ x for x in xs if x not in seen and not seen . add ( x ) ]", "docstring_tokens": "Get the list of distinct values with preserving order .", "label": 1}, {"idx": "cosqa-train-5228", "doc": "python parse string as bool", "code": "def FromString(self, string):\n    \"\"\"Parse a bool from a string.\"\"\"\n    if string.lower() in (\"false\", \"no\", \"n\"):\n      return False\n\n    if string.lower() in (\"true\", \"yes\", \"y\"):\n      return True\n\n    raise TypeValueError(\"%s is not recognized as a boolean value.\" % string)", "code_tokens": "def FromString ( self , string ) : if string . lower ( ) in ( \"false\" , \"no\" , \"n\" ) : return False if string . lower ( ) in ( \"true\" , \"yes\" , \"y\" ) : return True raise TypeValueError ( \"%s is not recognized as a boolean value.\" % string )", "docstring_tokens": "Parse a bool from a string .", "label": 0}, {"idx": "cosqa-train-5229", "doc": "how to get file location to use in python", "code": "def getScriptLocation():\n\t\"\"\"Helper function to get the location of a Python file.\"\"\"\n\tlocation = os.path.abspath(\"./\")\n\tif __file__.rfind(\"/\") != -1:\n\t\tlocation = __file__[:__file__.rfind(\"/\")]\n\treturn location", "code_tokens": "def getScriptLocation ( ) : location = os . path . abspath ( \"./\" ) if __file__ . rfind ( \"/\" ) != - 1 : location = __file__ [ : __file__ . rfind ( \"/\" ) ] return location", "docstring_tokens": "Helper function to get the location of a Python file .", "label": 1}, {"idx": "cosqa-train-5230", "doc": "python parser must be a string or character stream, not timestamp", "code": "def to_datetime(value):\n    \"\"\"Converts a string to a datetime.\"\"\"\n    if value is None:\n        return None\n\n    if isinstance(value, six.integer_types):\n        return parser.parse(value)\n    return parser.isoparse(value)", "code_tokens": "def to_datetime ( value ) : if value is None : return None if isinstance ( value , six . integer_types ) : return parser . parse ( value ) return parser . isoparse ( value )", "docstring_tokens": "Converts a string to a datetime .", "label": 1}, {"idx": "cosqa-train-5231", "doc": "how to get full path of the file in python", "code": "def rel_path(filename):\n    \"\"\"\n    Function that gets relative path to the filename\n    \"\"\"\n    return os.path.join(os.getcwd(), os.path.dirname(__file__), filename)", "code_tokens": "def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )", "docstring_tokens": "Function that gets relative path to the filename", "label": 0}, {"idx": "cosqa-train-5232", "doc": "how to get identity of a word python", "code": "def word_to_id(self, word):\n        \"\"\"Returns the integer word id of a word string.\"\"\"\n        if word in self.vocab:\n            return self.vocab[word]\n        else:\n            return self.unk_id", "code_tokens": "def word_to_id ( self , word ) : if word in self . vocab : return self . vocab [ word ] else : return self . unk_id", "docstring_tokens": "Returns the integer word id of a word string .", "label": 0}, {"idx": "cosqa-train-5233", "doc": "python pass along kwargs", "code": "def updateFromKwargs(self, properties, kwargs, collector, **unused):\n        \"\"\"Primary entry point to turn 'kwargs' into 'properties'\"\"\"\n        properties[self.name] = self.getFromKwargs(kwargs)", "code_tokens": "def updateFromKwargs ( self , properties , kwargs , collector , * * unused ) : properties [ self . name ] = self . getFromKwargs ( kwargs )", "docstring_tokens": "Primary entry point to turn kwargs into properties", "label": 0}, {"idx": "cosqa-train-5234", "doc": "how to get indivisual string elements to each seprate list in python", "code": "def split(s):\n  \"\"\"Uses dynamic programming to infer the location of spaces in a string without spaces.\"\"\"\n  l = [_split(x) for x in _SPLIT_RE.split(s)]\n  return [item for sublist in l for item in sublist]", "code_tokens": "def split ( s ) : l = [ _split ( x ) for x in _SPLIT_RE . split ( s ) ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Uses dynamic programming to infer the location of spaces in a string without spaces .", "label": 0}, {"idx": "cosqa-train-5235", "doc": "python passing argv to a function", "code": "def run(args):\n    \"\"\"Process command line arguments and walk inputs.\"\"\"\n    raw_arguments = get_arguments(args[1:])\n    process_arguments(raw_arguments)\n    walk.run()\n    return True", "code_tokens": "def run ( args ) : raw_arguments = get_arguments ( args [ 1 : ] ) process_arguments ( raw_arguments ) walk . run ( ) return True", "docstring_tokens": "Process command line arguments and walk inputs .", "label": 1}, {"idx": "cosqa-train-5236", "doc": "how to get local timezone python", "code": "def reload_localzone():\n    \"\"\"Reload the cached localzone. You need to call this if the timezone has changed.\"\"\"\n    global _cache_tz\n    _cache_tz = pytz.timezone(get_localzone_name())\n    utils.assert_tz_offset(_cache_tz)\n    return _cache_tz", "code_tokens": "def reload_localzone ( ) : global _cache_tz _cache_tz = pytz . timezone ( get_localzone_name ( ) ) utils . assert_tz_offset ( _cache_tz ) return _cache_tz", "docstring_tokens": "Reload the cached localzone . You need to call this if the timezone has changed .", "label": 0}, {"idx": "cosqa-train-5237", "doc": "python pasting to windows clipboard", "code": "def OnPasteAs(self, event):\n        \"\"\"Clipboard paste as event handler\"\"\"\n\n        data = self.main_window.clipboard.get_clipboard()\n        key = self.main_window.grid.actions.cursor\n\n        with undo.group(_(\"Paste As...\")):\n            self.main_window.actions.paste_as(key, data)\n\n        self.main_window.grid.ForceRefresh()\n\n        event.Skip()", "code_tokens": "def OnPasteAs ( self , event ) : data = self . main_window . clipboard . get_clipboard ( ) key = self . main_window . grid . actions . cursor with undo . group ( _ ( \"Paste As...\" ) ) : self . main_window . actions . paste_as ( key , data ) self . main_window . grid . ForceRefresh ( ) event . Skip ( )", "docstring_tokens": "Clipboard paste as event handler", "label": 0}, {"idx": "cosqa-train-5238", "doc": "how to get method name in python", "code": "def get_method_name(method):\n    \"\"\"\n    Returns given method name.\n\n    :param method: Method to retrieve the name.\n    :type method: object\n    :return: Method name.\n    :rtype: unicode\n    \"\"\"\n\n    name = get_object_name(method)\n    if name.startswith(\"__\") and not name.endswith(\"__\"):\n        name = \"_{0}{1}\".format(get_object_name(method.im_class), name)\n    return name", "code_tokens": "def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( \"__\" ) and not name . endswith ( \"__\" ) : name = \"_{0}{1}\" . format ( get_object_name ( method . im_class ) , name ) return name", "docstring_tokens": "Returns given method name .", "label": 1}, {"idx": "cosqa-train-5239", "doc": "python path parent for a file", "code": "def get_parent_folder_name(file_path):\n    \"\"\"Finds parent folder of file\n\n    :param file_path: path\n    :return: Name of folder container\n    \"\"\"\n    return os.path.split(os.path.split(os.path.abspath(file_path))[0])[-1]", "code_tokens": "def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]", "docstring_tokens": "Finds parent folder of file", "label": 1}, {"idx": "cosqa-train-5240", "doc": "how to get millisecond in python", "code": "def datetime_to_ms(dt):\n    \"\"\"\n    Converts a datetime to a millisecond accuracy timestamp\n    \"\"\"\n    seconds = calendar.timegm(dt.utctimetuple())\n    return seconds * 1000 + int(dt.microsecond / 1000)", "code_tokens": "def datetime_to_ms ( dt ) : seconds = calendar . timegm ( dt . utctimetuple ( ) ) return seconds * 1000 + int ( dt . microsecond / 1000 )", "docstring_tokens": "Converts a datetime to a millisecond accuracy timestamp", "label": 0}, {"idx": "cosqa-train-5241", "doc": "python pausing music selectively", "code": "def pause(self):\n        \"\"\"Pause the music\"\"\"\n        mixer.music.pause()\n        self.pause_time = self.get_time()\n        self.paused = True", "code_tokens": "def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True", "docstring_tokens": "Pause the music", "label": 0}, {"idx": "cosqa-train-5242", "doc": "how to get moving window data in python", "code": "def OnMove(self, event):\n        \"\"\"Main window move event\"\"\"\n\n        # Store window position in config\n        position = self.main_window.GetScreenPositionTuple()\n\n        config[\"window_position\"] = repr(position)", "code_tokens": "def OnMove ( self , event ) : # Store window position in config position = self . main_window . GetScreenPositionTuple ( ) config [ \"window_position\" ] = repr ( position )", "docstring_tokens": "Main window move event", "label": 1}, {"idx": "cosqa-train-5243", "doc": "python pdb exit set trace", "code": "def set_trace():\n    \"\"\"Start a Pdb instance at the calling frame, with stdout routed to sys.__stdout__.\"\"\"\n    # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py\n    pdb.Pdb(stdout=sys.__stdout__).set_trace(sys._getframe().f_back)", "code_tokens": "def set_trace ( ) : # https://github.com/nose-devs/nose/blob/master/nose/tools/nontrivial.py pdb . Pdb ( stdout = sys . __stdout__ ) . set_trace ( sys . _getframe ( ) . f_back )", "docstring_tokens": "Start a Pdb instance at the calling frame with stdout routed to sys . __stdout__ .", "label": 0}, {"idx": "cosqa-train-5244", "doc": "how to get number of columns and rows column and row of 2d array in python", "code": "def shape(self):\n        \"\"\"Compute the shape of the dataset as (rows, cols).\"\"\"\n        if not self.data:\n            return (0, 0)\n        return (len(self.data), len(self.dimensions))", "code_tokens": "def shape ( self ) : if not self . data : return ( 0 , 0 ) return ( len ( self . data ) , len ( self . dimensions ) )", "docstring_tokens": "Compute the shape of the dataset as ( rows cols ) .", "label": 0}, {"idx": "cosqa-train-5245", "doc": "python pdf text from area on page", "code": "def dimensions(self):\n        \"\"\"Get width and height of a PDF\"\"\"\n        size = self.pdf.getPage(0).mediaBox\n        return {'w': float(size[2]), 'h': float(size[3])}", "code_tokens": "def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "docstring_tokens": "Get width and height of a PDF", "label": 0}, {"idx": "cosqa-train-5246", "doc": "how to get number of core on python", "code": "def _num_cpus_darwin():\n    \"\"\"Return the number of active CPUs on a Darwin system.\"\"\"\n    p = subprocess.Popen(['sysctl','-n','hw.ncpu'],stdout=subprocess.PIPE)\n    return p.stdout.read()", "code_tokens": "def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )", "docstring_tokens": "Return the number of active CPUs on a Darwin system .", "label": 0}, {"idx": "cosqa-train-5247", "doc": "python peewee remove by key", "code": "def delete_entry(self, key):\n        \"\"\"Delete an object from the redis table\"\"\"\n        pipe = self.client.pipeline()\n        pipe.srem(self.keys_container, key)\n        pipe.delete(key)\n        pipe.execute()", "code_tokens": "def delete_entry ( self , key ) : pipe = self . client . pipeline ( ) pipe . srem ( self . keys_container , key ) pipe . delete ( key ) pipe . execute ( )", "docstring_tokens": "Delete an object from the redis table", "label": 0}, {"idx": "cosqa-train-5248", "doc": "how to get number of rows in data frame python", "code": "def count_(self):\n        \"\"\"\n        Returns the number of rows of the main dataframe\n        \"\"\"\n        try:\n            num = len(self.df.index)\n        except Exception as e:\n            self.err(e, \"Can not count data\")\n            return\n        return num", "code_tokens": "def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , \"Can not count data\" ) return return num", "docstring_tokens": "Returns the number of rows of the main dataframe", "label": 0}, {"idx": "cosqa-train-5249", "doc": "python permutations order doesn't matter", "code": "def circ_permutation(items):\n    \"\"\"Calculate the circular permutation for a given list of items.\"\"\"\n    permutations = []\n    for i in range(len(items)):\n        permutations.append(items[i:] + items[:i])\n    return permutations", "code_tokens": "def circ_permutation ( items ) : permutations = [ ] for i in range ( len ( items ) ) : permutations . append ( items [ i : ] + items [ : i ] ) return permutations", "docstring_tokens": "Calculate the circular permutation for a given list of items .", "label": 0}, {"idx": "cosqa-train-5250", "doc": "how to get program to exit on exit 0 python", "code": "def call_and_exit(self, cmd, shell=True):\n        \"\"\"Run the *cmd* and exit with the proper exit code.\"\"\"\n        sys.exit(subprocess.call(cmd, shell=shell))", "code_tokens": "def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )", "docstring_tokens": "Run the * cmd * and exit with the proper exit code .", "label": 1}, {"idx": "cosqa-train-5251", "doc": "python pexpect cmd stdout", "code": "def getoutput_pexpect(self, cmd):\n        \"\"\"Run a command and return its stdout/stderr as a string.\n\n        Parameters\n        ----------\n        cmd : str\n          A command to be executed in the system shell.\n\n        Returns\n        -------\n        output : str\n          A string containing the combination of stdout and stderr from the\n        subprocess, in whatever order the subprocess originally wrote to its\n        file descriptors (so the order of the information in this string is the\n        correct order as would be seen if running the command in a terminal).\n        \"\"\"\n        try:\n            return pexpect.run(self.sh, args=['-c', cmd]).replace('\\r\\n', '\\n')\n        except KeyboardInterrupt:\n            print('^C', file=sys.stderr, end='')", "code_tokens": "def getoutput_pexpect ( self , cmd ) : try : return pexpect . run ( self . sh , args = [ '-c' , cmd ] ) . replace ( '\\r\\n' , '\\n' ) except KeyboardInterrupt : print ( '^C' , file = sys . stderr , end = '' )", "docstring_tokens": "Run a command and return its stdout / stderr as a string .", "label": 0}, {"idx": "cosqa-train-5252", "doc": "how to get rid of space of a line from a file python", "code": "def get_stripped_file_lines(filename):\n    \"\"\"\n    Return lines of a file with whitespace removed\n    \"\"\"\n    try:\n        lines = open(filename).readlines()\n    except FileNotFoundError:\n        fatal(\"Could not open file: {!r}\".format(filename))\n\n    return [line.strip() for line in lines]", "code_tokens": "def get_stripped_file_lines ( filename ) : try : lines = open ( filename ) . readlines ( ) except FileNotFoundError : fatal ( \"Could not open file: {!r}\" . format ( filename ) ) return [ line . strip ( ) for line in lines ]", "docstring_tokens": "Return lines of a file with whitespace removed", "label": 1}, {"idx": "cosqa-train-5253", "doc": "python pexpect get result", "code": "def getoutput_pexpect(self, cmd):\n        \"\"\"Run a command and return its stdout/stderr as a string.\n\n        Parameters\n        ----------\n        cmd : str\n          A command to be executed in the system shell.\n\n        Returns\n        -------\n        output : str\n          A string containing the combination of stdout and stderr from the\n        subprocess, in whatever order the subprocess originally wrote to its\n        file descriptors (so the order of the information in this string is the\n        correct order as would be seen if running the command in a terminal).\n        \"\"\"\n        try:\n            return pexpect.run(self.sh, args=['-c', cmd]).replace('\\r\\n', '\\n')\n        except KeyboardInterrupt:\n            print('^C', file=sys.stderr, end='')", "code_tokens": "def getoutput_pexpect ( self , cmd ) : try : return pexpect . run ( self . sh , args = [ '-c' , cmd ] ) . replace ( '\\r\\n' , '\\n' ) except KeyboardInterrupt : print ( '^C' , file = sys . stderr , end = '' )", "docstring_tokens": "Run a command and return its stdout / stderr as a string .", "label": 1}, {"idx": "cosqa-train-5254", "doc": "how to get string column names in python", "code": "def _get_str_columns(sf):\n    \"\"\"\n    Returns a list of names of columns that are string type.\n    \"\"\"\n    return [name for name in sf.column_names() if sf[name].dtype == str]", "code_tokens": "def _get_str_columns ( sf ) : return [ name for name in sf . column_names ( ) if sf [ name ] . dtype == str ]", "docstring_tokens": "Returns a list of names of columns that are string type .", "label": 0}, {"idx": "cosqa-train-5255", "doc": "python pickle load an empty file", "code": "def unpickle(pickle_file):\n    \"\"\"Unpickle a python object from the given path.\"\"\"\n    pickle = None\n    with open(pickle_file, \"rb\") as pickle_f:\n        pickle = dill.load(pickle_f)\n    if not pickle:\n        LOG.error(\"Could not load python object from file\")\n    return pickle", "code_tokens": "def unpickle ( pickle_file ) : pickle = None with open ( pickle_file , \"rb\" ) as pickle_f : pickle = dill . load ( pickle_f ) if not pickle : LOG . error ( \"Could not load python object from file\" ) return pickle", "docstring_tokens": "Unpickle a python object from the given path .", "label": 0}, {"idx": "cosqa-train-5256", "doc": "how to get the angle between two points python", "code": "def angle(x0, y0, x1, y1):\n    \"\"\" Returns the angle between two points.\n    \"\"\"\n    return degrees(atan2(y1-y0, x1-x0))", "code_tokens": "def angle ( x0 , y0 , x1 , y1 ) : return degrees ( atan2 ( y1 - y0 , x1 - x0 ) )", "docstring_tokens": "Returns the angle between two points .", "label": 0}, {"idx": "cosqa-train-5257", "doc": "python pickle load from filename", "code": "def load(self, filename='classifier.dump'):\n        \"\"\"\n        Unpickles the classifier used\n        \"\"\"\n        ifile = open(filename, 'r+')\n        self.classifier = pickle.load(ifile)\n        ifile.close()", "code_tokens": "def load ( self , filename = 'classifier.dump' ) : ifile = open ( filename , 'r+' ) self . classifier = pickle . load ( ifile ) ifile . close ( )", "docstring_tokens": "Unpickles the classifier used", "label": 1}, {"idx": "cosqa-train-5258", "doc": "python plot beginning and end color", "code": "def highlight_region(plt, start_x, end_x):\n  \"\"\"\n  Highlight a region on the chart between the specified start and end x-co-ordinates.\n  param pyplot plt: matplotlibk pyplot which contains the charts to be highlighted\n  param string start_x : epoch time millis\n  param string end_x : epoch time millis\n  \"\"\"\n  start_x = convert_to_mdate(start_x)\n  end_x = convert_to_mdate(end_x)\n  plt.axvspan(start_x, end_x, color=CONSTANTS.HIGHLIGHT_COLOR, alpha=CONSTANTS.HIGHLIGHT_ALPHA)", "code_tokens": "def highlight_region ( plt , start_x , end_x ) : start_x = convert_to_mdate ( start_x ) end_x = convert_to_mdate ( end_x ) plt . axvspan ( start_x , end_x , color = CONSTANTS . HIGHLIGHT_COLOR , alpha = CONSTANTS . HIGHLIGHT_ALPHA )", "docstring_tokens": "Highlight a region on the chart between the specified start and end x - co - ordinates . param pyplot plt : matplotlibk pyplot which contains the charts to be highlighted param string start_x : epoch time millis param string end_x : epoch time millis", "label": 0}, {"idx": "cosqa-train-5259", "doc": "how to get the count in json file using python", "code": "def load_search_freq(fp=SEARCH_FREQ_JSON):\n    \"\"\"\n    Load the search_freq from JSON file\n    \"\"\"\n    try:\n        with open(fp) as f:\n            return Counter(json.load(f))\n    except FileNotFoundError:\n        return Counter()", "code_tokens": "def load_search_freq ( fp = SEARCH_FREQ_JSON ) : try : with open ( fp ) as f : return Counter ( json . load ( f ) ) except FileNotFoundError : return Counter ( )", "docstring_tokens": "Load the search_freq from JSON file", "label": 1}, {"idx": "cosqa-train-5260", "doc": "python plot dictionary bar chart horizontal sort values", "code": "def barv(d, plt, title=None, rotation='vertical'):\n    \"\"\"A convenience function for plotting a vertical bar plot from a Counter\"\"\"\n    labels = sorted(d, key=d.get, reverse=True)\n    index = range(len(labels))\n    plt.xticks(index, labels, rotation=rotation)\n    plt.bar(index, [d[v] for v in labels])\n\n    if title is not None:\n        plt.title(title)", "code_tokens": "def barv ( d , plt , title = None , rotation = 'vertical' ) : labels = sorted ( d , key = d . get , reverse = True ) index = range ( len ( labels ) ) plt . xticks ( index , labels , rotation = rotation ) plt . bar ( index , [ d [ v ] for v in labels ] ) if title is not None : plt . title ( title )", "docstring_tokens": "A convenience function for plotting a vertical bar plot from a Counter", "label": 1}, {"idx": "cosqa-train-5261", "doc": "how to get the data type in python as a string", "code": "def datatype(dbtype, description, cursor):\n    \"\"\"Google AppEngine Helper to convert a data type into a string.\"\"\"\n    dt = cursor.db.introspection.get_field_type(dbtype, description)\n    if type(dt) is tuple:\n        return dt[0]\n    else:\n        return dt", "code_tokens": "def datatype ( dbtype , description , cursor ) : dt = cursor . db . introspection . get_field_type ( dbtype , description ) if type ( dt ) is tuple : return dt [ 0 ] else : return dt", "docstring_tokens": "Google AppEngine Helper to convert a data type into a string .", "label": 0}, {"idx": "cosqa-train-5262", "doc": "python plot same color as scatter", "code": "def plot_target(target, ax):\n    \"\"\"Ajoute la target au plot\"\"\"\n    ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)", "code_tokens": "def plot_target ( target , ax ) : ax . scatter ( target [ 0 ] , target [ 1 ] , target [ 2 ] , c = \"red\" , s = 80 )", "docstring_tokens": "Ajoute la target au plot", "label": 0}, {"idx": "cosqa-train-5263", "doc": "how to get the first digit in a list of number in python", "code": "def find_first_number(ll):\n    \"\"\" Returns nr of first entry parseable to float in ll, None otherwise\"\"\"\n    for nr, entry in enumerate(ll):\n        try:\n            float(entry)\n        except (ValueError, TypeError) as e:\n            pass\n        else:\n            return nr\n    return None", "code_tokens": "def find_first_number ( ll ) : for nr , entry in enumerate ( ll ) : try : float ( entry ) except ( ValueError , TypeError ) as e : pass else : return nr return None", "docstring_tokens": "Returns nr of first entry parseable to float in ll None otherwise", "label": 0}, {"idx": "cosqa-train-5264", "doc": "python pool apply async", "code": "def blocking(func, *args, **kwargs):\n    \"\"\"Run a function that uses blocking IO.\n\n    The function is run in the IO thread pool.\n    \"\"\"\n    pool = get_io_pool()\n    fut = pool.submit(func, *args, **kwargs)\n    return fut.result()", "code_tokens": "def blocking ( func , * args , * * kwargs ) : pool = get_io_pool ( ) fut = pool . submit ( func , * args , * * kwargs ) return fut . result ( )", "docstring_tokens": "Run a function that uses blocking IO .", "label": 0}, {"idx": "cosqa-train-5265", "doc": "how to get the longest string in a list python", "code": "def get_longest_orf(orfs):\n    \"\"\"Find longest ORF from the given list of ORFs.\"\"\"\n    sorted_orf = sorted(orfs, key=lambda x: len(x['sequence']), reverse=True)[0]\n    return sorted_orf", "code_tokens": "def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf", "docstring_tokens": "Find longest ORF from the given list of ORFs .", "label": 0}, {"idx": "cosqa-train-5266", "doc": "python popen hide and store output", "code": "def disown(cmd):\n    \"\"\"Call a system command in the background,\n       disown it and hide it's output.\"\"\"\n    subprocess.Popen(cmd,\n                     stdout=subprocess.DEVNULL,\n                     stderr=subprocess.DEVNULL)", "code_tokens": "def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "docstring_tokens": "Call a system command in the background disown it and hide it s output .", "label": 0}, {"idx": "cosqa-train-5267", "doc": "how to get the next token in python", "code": "def _next_token(self, skipws=True):\n        \"\"\"Increment _token to the next token and return it.\"\"\"\n        self._token = next(self._tokens).group(0)\n        return self._next_token() if skipws and self._token.isspace() else self._token", "code_tokens": "def _next_token ( self , skipws = True ) : self . _token = next ( self . _tokens ) . group ( 0 ) return self . _next_token ( ) if skipws and self . _token . isspace ( ) else self . _token", "docstring_tokens": "Increment _token to the next token and return it .", "label": 0}, {"idx": "cosqa-train-5268", "doc": "python popen subprocess block stdout devnull", "code": "def disown(cmd):\n    \"\"\"Call a system command in the background,\n       disown it and hide it's output.\"\"\"\n    subprocess.Popen(cmd,\n                     stdout=subprocess.DEVNULL,\n                     stderr=subprocess.DEVNULL)", "code_tokens": "def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "docstring_tokens": "Call a system command in the background disown it and hide it s output .", "label": 0}, {"idx": "cosqa-train-5269", "doc": "how to get the number of rows in data frame in python", "code": "def count_(self):\n        \"\"\"\n        Returns the number of rows of the main dataframe\n        \"\"\"\n        try:\n            num = len(self.df.index)\n        except Exception as e:\n            self.err(e, \"Can not count data\")\n            return\n        return num", "code_tokens": "def count_ ( self ) : try : num = len ( self . df . index ) except Exception as e : self . err ( e , \"Can not count data\" ) return return num", "docstring_tokens": "Returns the number of rows of the main dataframe", "label": 0}, {"idx": "cosqa-train-5270", "doc": "python postgresql sqlalchemy update schema", "code": "def init_db():\n    \"\"\"\n    Drops and re-creates the SQL schema\n    \"\"\"\n    db.drop_all()\n    db.configure_mappers()\n    db.create_all()\n    db.session.commit()", "code_tokens": "def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )", "docstring_tokens": "Drops and re - creates the SQL schema", "label": 0}, {"idx": "cosqa-train-5271", "doc": "how to get the tweets of one user with twitter api and python+2018", "code": "def twitter_timeline(screen_name, since_id=None):\n    \"\"\" Return relevant twitter timeline \"\"\"\n    consumer_key = twitter_credential('consumer_key')\n    consumer_secret = twitter_credential('consumer_secret')\n    access_token = twitter_credential('access_token')\n    access_token_secret = twitter_credential('access_secret')\n    auth = tweepy.OAuthHandler(consumer_key, consumer_secret)\n    auth.set_access_token(access_token, access_token_secret)\n    api = tweepy.API(auth)\n    return get_all_tweets(screen_name, api, since_id)", "code_tokens": "def twitter_timeline ( screen_name , since_id = None ) : consumer_key = twitter_credential ( 'consumer_key' ) consumer_secret = twitter_credential ( 'consumer_secret' ) access_token = twitter_credential ( 'access_token' ) access_token_secret = twitter_credential ( 'access_secret' ) auth = tweepy . OAuthHandler ( consumer_key , consumer_secret ) auth . set_access_token ( access_token , access_token_secret ) api = tweepy . API ( auth ) return get_all_tweets ( screen_name , api , since_id )", "docstring_tokens": "Return relevant twitter timeline", "label": 0}, {"idx": "cosqa-train-5272", "doc": "python print a filter object", "code": "def Print(self, output_writer):\n    \"\"\"Prints a human readable version of the filter.\n\n    Args:\n      output_writer (CLIOutputWriter): output writer.\n    \"\"\"\n    if self._filters:\n      output_writer.Write('Filters:\\n')\n      for file_entry_filter in self._filters:\n        file_entry_filter.Print(output_writer)", "code_tokens": "def Print ( self , output_writer ) : if self . _filters : output_writer . Write ( 'Filters:\\n' ) for file_entry_filter in self . _filters : file_entry_filter . Print ( output_writer )", "docstring_tokens": "Prints a human readable version of the filter .", "label": 1}, {"idx": "cosqa-train-5273", "doc": "how to get the value of a tag in xml in python", "code": "def _get_minidom_tag_value(station, tag_name):\n    \"\"\"get a value from a tag (if it exists)\"\"\"\n    tag = station.getElementsByTagName(tag_name)[0].firstChild\n    if tag:\n        return tag.nodeValue\n\n    return None", "code_tokens": "def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None", "docstring_tokens": "get a value from a tag ( if it exists )", "label": 0}, {"idx": "cosqa-train-5274", "doc": "python print all instance attributes", "code": "def print_param_values(self_):\n        \"\"\"Print the values of all this object's Parameters.\"\"\"\n        self = self_.self\n        for name,val in self.param.get_param_values():\n            print('%s.%s = %s' % (self.name,name,val))", "code_tokens": "def print_param_values ( self_ ) : self = self_ . self for name , val in self . param . get_param_values ( ) : print ( '%s.%s = %s' % ( self . name , name , val ) )", "docstring_tokens": "Print the values of all this object s Parameters .", "label": 0}, {"idx": "cosqa-train-5275", "doc": "how to get the window title in python", "code": "def title(self):\n        \"\"\" The title of this window \"\"\"\n        with switch_window(self._browser, self.name):\n            return self._browser.title", "code_tokens": "def title ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . title", "docstring_tokens": "The title of this window", "label": 1}, {"idx": "cosqa-train-5276", "doc": "python print all lines of code executed in function call", "code": "def runcode(code):\n\t\"\"\"Run the given code line by line with printing, as list of lines, and return variable 'ans'.\"\"\"\n\tfor line in code:\n\t\tprint('# '+line)\n\t\texec(line,globals())\n\tprint('# return ans')\n\treturn ans", "code_tokens": "def runcode ( code ) : for line in code : print ( '# ' + line ) exec ( line , globals ( ) ) print ( '# return ans' ) return ans", "docstring_tokens": "Run the given code line by line with printing as list of lines and return variable ans .", "label": 0}, {"idx": "cosqa-train-5277", "doc": "how to get today date no time python", "code": "def created_today(self):\n        \"\"\"Return True if created today.\"\"\"\n        if self.datetime.date() == datetime.today().date():\n            return True\n        return False", "code_tokens": "def created_today ( self ) : if self . datetime . date ( ) == datetime . today ( ) . date ( ) : return True return False", "docstring_tokens": "Return True if created today .", "label": 0}, {"idx": "cosqa-train-5278", "doc": "python print current iteration", "code": "def __call__(self, _):\n        \"\"\"Print the current iteration.\"\"\"\n        if self.iter % self.step == 0:\n            print(self.fmt.format(self.iter), **self.kwargs)\n\n        self.iter += 1", "code_tokens": "def __call__ ( self , _ ) : if self . iter % self . step == 0 : print ( self . fmt . format ( self . iter ) , * * self . kwargs ) self . iter += 1", "docstring_tokens": "Print the current iteration .", "label": 0}, {"idx": "cosqa-train-5279", "doc": "how to get uid of a user using python", "code": "def get_system_uid():\n    \"\"\"Get a (probably) unique ID to identify a system.\n    Used to differentiate votes.\n    \"\"\"\n    try:\n        if os.name == 'nt':\n            return get_nt_system_uid()\n        if sys.platform == 'darwin':\n            return get_osx_system_uid()\n    except Exception:\n        return get_mac_uid()\n    else:\n        return get_mac_uid()", "code_tokens": "def get_system_uid ( ) : try : if os . name == 'nt' : return get_nt_system_uid ( ) if sys . platform == 'darwin' : return get_osx_system_uid ( ) except Exception : return get_mac_uid ( ) else : return get_mac_uid ( )", "docstring_tokens": "Get a ( probably ) unique ID to identify a system . Used to differentiate votes .", "label": 0}, {"idx": "cosqa-train-5280", "doc": "python print dictionary values in order", "code": "def Print(self):\n        \"\"\"Prints the values and freqs/probs in ascending order.\"\"\"\n        for val, prob in sorted(self.d.iteritems()):\n            print(val, prob)", "code_tokens": "def Print ( self ) : for val , prob in sorted ( self . d . iteritems ( ) ) : print ( val , prob )", "docstring_tokens": "Prints the values and freqs / probs in ascending order .", "label": 0}, {"idx": "cosqa-train-5281", "doc": "how to get underscores after each letter in python", "code": "def camel_case_from_underscores(string):\n    \"\"\"generate a CamelCase string from an underscore_string.\"\"\"\n    components = string.split('_')\n    string = ''\n    for component in components:\n        string += component[0].upper() + component[1:]\n    return string", "code_tokens": "def camel_case_from_underscores ( string ) : components = string . split ( '_' ) string = '' for component in components : string += component [ 0 ] . upper ( ) + component [ 1 : ] return string", "docstring_tokens": "generate a CamelCase string from an underscore_string .", "label": 0}, {"idx": "cosqa-train-5282", "doc": "python print doesn't output immediately", "code": "def raw_print(*args, **kw):\n    \"\"\"Raw print to sys.__stdout__, otherwise identical interface to print().\"\"\"\n\n    print(*args, sep=kw.get('sep', ' '), end=kw.get('end', '\\n'),\n          file=sys.__stdout__)\n    sys.__stdout__.flush()", "code_tokens": "def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )", "docstring_tokens": "Raw print to sys . __stdout__ otherwise identical interface to print () .", "label": 0}, {"idx": "cosqa-train-5283", "doc": "how to get width in python", "code": "def text_width(string, font_name, font_size):\n    \"\"\"Determine with width in pixels of string.\"\"\"\n    return stringWidth(string, fontName=font_name, fontSize=font_size)", "code_tokens": "def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )", "docstring_tokens": "Determine with width in pixels of string .", "label": 0}, {"idx": "cosqa-train-5284", "doc": "python print fixed width spaces", "code": "def indented_show(text, howmany=1):\n        \"\"\"Print a formatted indented text.\n        \"\"\"\n        print(StrTemplate.pad_indent(text=text, howmany=howmany))", "code_tokens": "def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )", "docstring_tokens": "Print a formatted indented text .", "label": 0}, {"idx": "cosqa-train-5285", "doc": "how to give an object a new member variable python", "code": "def assign_to(self, obj):\n    \"\"\"Assign `x` and `y` to an object that has properties `x` and `y`.\"\"\"\n    obj.x = self.x\n    obj.y = self.y", "code_tokens": "def assign_to ( self , obj ) : obj . x = self . x obj . y = self . y", "docstring_tokens": "Assign x and y to an object that has properties x and y .", "label": 0}, {"idx": "cosqa-train-5286", "doc": "python print pretty binary tree", "code": "def print_bintree(tree, indent='  '):\n    \"\"\"print a binary tree\"\"\"\n    for n in sorted(tree.keys()):\n        print \"%s%s\" % (indent * depth(n,tree), n)", "code_tokens": "def print_bintree ( tree , indent = '  ' ) : for n in sorted ( tree . keys ( ) ) : print \"%s%s\" % ( indent * depth ( n , tree ) , n )", "docstring_tokens": "print a binary tree", "label": 0}, {"idx": "cosqa-train-5287", "doc": "how to give color in scatterplot python", "code": "def plot_target(target, ax):\n    \"\"\"Ajoute la target au plot\"\"\"\n    ax.scatter(target[0], target[1], target[2], c=\"red\", s=80)", "code_tokens": "def plot_target ( target , ax ) : ax . scatter ( target [ 0 ] , target [ 1 ] , target [ 2 ] , c = \"red\" , s = 80 )", "docstring_tokens": "Ajoute la target au plot", "label": 0}, {"idx": "cosqa-train-5288", "doc": "python printing chart to another file", "code": "def save_dot(self, fd):\n        \"\"\" Saves a representation of the case in the Graphviz DOT language.\n        \"\"\"\n        from pylon.io import DotWriter\n        DotWriter(self).write(fd)", "code_tokens": "def save_dot ( self , fd ) : from pylon . io import DotWriter DotWriter ( self ) . write ( fd )", "docstring_tokens": "Saves a representation of the case in the Graphviz DOT language .", "label": 0}, {"idx": "cosqa-train-5289", "doc": "how to give comments in python", "code": "def _comment(string):\n    \"\"\"return string as a comment\"\"\"\n    lines = [line.strip() for line in string.splitlines()]\n    return \"# \" + (\"%s# \" % linesep).join(lines)", "code_tokens": "def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return \"# \" + ( \"%s# \" % linesep ) . join ( lines )", "docstring_tokens": "return string as a comment", "label": 1}, {"idx": "cosqa-train-5290", "doc": "python printing text in design", "code": "def _display(self, layout):\n        \"\"\"launch layouts display\"\"\"\n        print(file=self.out)\n        TextWriter().format(layout, self.out)", "code_tokens": "def _display ( self , layout ) : print ( file = self . out ) TextWriter ( ) . format ( layout , self . out )", "docstring_tokens": "launch layouts display", "label": 0}, {"idx": "cosqa-train-5291", "doc": "how to give cookiejar cookies in get request using python", "code": "def parse_cookies(self, req, name, field):\n        \"\"\"Pull the value from the cookiejar.\"\"\"\n        return core.get_value(req.COOKIES, name, field)", "code_tokens": "def parse_cookies ( self , req , name , field ) : return core . get_value ( req . COOKIES , name , field )", "docstring_tokens": "Pull the value from the cookiejar .", "label": 0}, {"idx": "cosqa-train-5292", "doc": "python process multiple argumnent", "code": "def run(args):\n    \"\"\"Process command line arguments and walk inputs.\"\"\"\n    raw_arguments = get_arguments(args[1:])\n    process_arguments(raw_arguments)\n    walk.run()\n    return True", "code_tokens": "def run ( args ) : raw_arguments = get_arguments ( args [ 1 : ] ) process_arguments ( raw_arguments ) walk . run ( ) return True", "docstring_tokens": "Process command line arguments and walk inputs .", "label": 0}, {"idx": "cosqa-train-5293", "doc": "how to give is equals in python", "code": "def hard_equals(a, b):\n    \"\"\"Implements the '===' operator.\"\"\"\n    if type(a) != type(b):\n        return False\n    return a == b", "code_tokens": "def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b", "docstring_tokens": "Implements the === operator .", "label": 0}, {"idx": "cosqa-train-5294", "doc": "python process pool in func", "code": "def compute_capture(args):\n    x, y, w, h, params = args\n    \"\"\"Callable function for the multiprocessing pool.\"\"\"\n    return x, y, mandelbrot_capture(x, y, w, h, params)", "code_tokens": "def compute_capture ( args ) : x , y , w , h , params = args return x , y , mandelbrot_capture ( x , y , w , h , params )", "docstring_tokens": "Callable function for the multiprocessing pool .", "label": 1}, {"idx": "cosqa-train-5295", "doc": "how to give multiple comments in python", "code": "def _comment(string):\n    \"\"\"return string as a comment\"\"\"\n    lines = [line.strip() for line in string.splitlines()]\n    return \"# \" + (\"%s# \" % linesep).join(lines)", "code_tokens": "def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return \"# \" + ( \"%s# \" % linesep ) . join ( lines )", "docstring_tokens": "return string as a comment", "label": 0}, {"idx": "cosqa-train-5296", "doc": "python program to get all free memory address", "code": "def get_free_memory_win():\n    \"\"\"Return current free memory on the machine for windows.\n\n    Warning : this script is really not robust\n    Return in MB unit\n    \"\"\"\n    stat = MEMORYSTATUSEX()\n    ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(stat))\n    return int(stat.ullAvailPhys / 1024 / 1024)", "code_tokens": "def get_free_memory_win ( ) : stat = MEMORYSTATUSEX ( ) ctypes . windll . kernel32 . GlobalMemoryStatusEx ( ctypes . byref ( stat ) ) return int ( stat . ullAvailPhys / 1024 / 1024 )", "docstring_tokens": "Return current free memory on the machine for windows .", "label": 0}, {"idx": "cosqa-train-5297", "doc": "how to grab focus python", "code": "def cycle_focus(self):\n        \"\"\"\n        Cycle through all windows.\n        \"\"\"\n        windows = self.windows()\n        new_index = (windows.index(self.active_window) + 1) % len(windows)\n        self.active_window = windows[new_index]", "code_tokens": "def cycle_focus ( self ) : windows = self . windows ( ) new_index = ( windows . index ( self . active_window ) + 1 ) % len ( windows ) self . active_window = windows [ new_index ]", "docstring_tokens": "Cycle through all windows .", "label": 0}, {"idx": "cosqa-train-5298", "doc": "python progressbar uneven iterations", "code": "def __call__(self, _):\n        \"\"\"Update the progressbar.\"\"\"\n        if self.iter % self.step == 0:\n            self.pbar.update(self.step)\n\n        self.iter += 1", "code_tokens": "def __call__ ( self , _ ) : if self . iter % self . step == 0 : self . pbar . update ( self . step ) self . iter += 1", "docstring_tokens": "Update the progressbar .", "label": 0}, {"idx": "cosqa-train-5299", "doc": "how to handel deal with the int32 in python", "code": "def int32_to_negative(int32):\n    \"\"\"Checks if a suspicious number (e.g. ligand position) is in fact a negative number represented as a\n    32 bit integer and returns the actual number.\n    \"\"\"\n    dct = {}\n    if int32 == 4294967295:  # Special case in some structures (note, this is just a workaround)\n        return -1\n    for i in range(-1000, -1):\n        dct[np.uint32(i)] = i\n    if int32 in dct:\n        return dct[int32]\n    else:\n        return int32", "code_tokens": "def int32_to_negative ( int32 ) : dct = { } if int32 == 4294967295 : # Special case in some structures (note, this is just a workaround) return - 1 for i in range ( - 1000 , - 1 ) : dct [ np . uint32 ( i ) ] = i if int32 in dct : return dct [ int32 ] else : return int32", "docstring_tokens": "Checks if a suspicious number ( e . g . ligand position ) is in fact a negative number represented as a 32 bit integer and returns the actual number .", "label": 1}, {"idx": "cosqa-train-5300", "doc": "python property object at dynamic", "code": "def value(self):\n        \"\"\"Value of property.\"\"\"\n        if self._prop.fget is None:\n            raise AttributeError('Unable to read attribute')\n        return self._prop.fget(self._obj)", "code_tokens": "def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )", "docstring_tokens": "Value of property .", "label": 0}, {"idx": "cosqa-train-5301", "doc": "how to handle float values in a string in python", "code": "def _convert_to_float_if_possible(s):\n    \"\"\"\n    A small helper function to convert a string to a numeric value\n    if appropriate\n\n    :param s: the string to be converted\n    :type s: str\n    \"\"\"\n    try:\n        ret = float(s)\n    except (ValueError, TypeError):\n        ret = s\n    return ret", "code_tokens": "def _convert_to_float_if_possible ( s ) : try : ret = float ( s ) except ( ValueError , TypeError ) : ret = s return ret", "docstring_tokens": "A small helper function to convert a string to a numeric value if appropriate", "label": 0}, {"idx": "cosqa-train-5302", "doc": "python protobuf timestamp get datetime", "code": "def acknowledge_time(self):\n        \"\"\"\n        Processor time when the alarm was acknowledged.\n\n        :type: :class:`~datetime.datetime`\n        \"\"\"\n        if (self.is_acknowledged and\n                self._proto.acknowledgeInfo.HasField('acknowledgeTime')):\n            return parse_isostring(self._proto.acknowledgeInfo.acknowledgeTime)\n        return None", "code_tokens": "def acknowledge_time ( self ) : if ( self . is_acknowledged and self . _proto . acknowledgeInfo . HasField ( 'acknowledgeTime' ) ) : return parse_isostring ( self . _proto . acknowledgeInfo . acknowledgeTime ) return None", "docstring_tokens": "Processor time when the alarm was acknowledged .", "label": 0}, {"idx": "cosqa-train-5303", "doc": "how to have an ordered dictionary python", "code": "def get_order(self):\n        \"\"\"\n        Return a list of dicionaries. See `set_order`.\n        \"\"\"\n        return [dict(reverse=r[0], key=r[1]) for r in self.get_model()]", "code_tokens": "def get_order ( self ) : return [ dict ( reverse = r [ 0 ] , key = r [ 1 ] ) for r in self . get_model ( ) ]", "docstring_tokens": "Return a list of dicionaries . See set_order .", "label": 1}, {"idx": "cosqa-train-5304", "doc": "python proxy connection setup", "code": "def _prepare_proxy(self, conn):\n        \"\"\"\n        Establish tunnel connection early, because otherwise httplib\n        would improperly set Host: header to proxy's IP:port.\n        \"\"\"\n        conn.set_tunnel(self._proxy_host, self.port, self.proxy_headers)\n        conn.connect()", "code_tokens": "def _prepare_proxy ( self , conn ) : conn . set_tunnel ( self . _proxy_host , self . port , self . proxy_headers ) conn . connect ( )", "docstring_tokens": "Establish tunnel connection early because otherwise httplib would improperly set Host : header to proxy s IP : port .", "label": 0}, {"idx": "cosqa-train-5305", "doc": "how to have theme in python program", "code": "def use_theme(theme):\n    \"\"\"Make the given theme current.\n\n    There are two included themes: light_theme, dark_theme.\n    \"\"\"\n    global current\n    current = theme\n    import scene\n    if scene.current is not None:\n        scene.current.stylize()", "code_tokens": "def use_theme ( theme ) : global current current = theme import scene if scene . current is not None : scene . current . stylize ( )", "docstring_tokens": "Make the given theme current .", "label": 1}, {"idx": "cosqa-train-5306", "doc": "python pull first letter of full name", "code": "def packagenameify(s):\n  \"\"\"\n  Makes a package name\n  \"\"\"\n  return ''.join(w if w in ACRONYMS else w.title() for w in s.split('.')[-1:])", "code_tokens": "def packagenameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '.' ) [ - 1 : ] )", "docstring_tokens": "Makes a package name", "label": 0}, {"idx": "cosqa-train-5307", "doc": "how to hide a python input as though password", "code": "def getpass(self, prompt, default=None):\n        \"\"\"Provide a password prompt.\"\"\"\n        return click.prompt(prompt, hide_input=True, default=default)", "code_tokens": "def getpass ( self , prompt , default = None ) : return click . prompt ( prompt , hide_input = True , default = default )", "docstring_tokens": "Provide a password prompt .", "label": 1}, {"idx": "cosqa-train-5308", "doc": "python pyodbc cursor executemany", "code": "def store_many(self, sql, values):\n        \"\"\"Abstraction over executemany method\"\"\"\n        cursor = self.get_cursor()\n        cursor.executemany(sql, values)\n        self.conn.commit()", "code_tokens": "def store_many ( self , sql , values ) : cursor = self . get_cursor ( ) cursor . executemany ( sql , values ) self . conn . commit ( )", "docstring_tokens": "Abstraction over executemany method", "label": 1}, {"idx": "cosqa-train-5309", "doc": "how to hide output of a command in python", "code": "def disown(cmd):\n    \"\"\"Call a system command in the background,\n       disown it and hide it's output.\"\"\"\n    subprocess.Popen(cmd,\n                     stdout=subprocess.DEVNULL,\n                     stderr=subprocess.DEVNULL)", "code_tokens": "def disown ( cmd ) : subprocess . Popen ( cmd , stdout = subprocess . DEVNULL , stderr = subprocess . DEVNULL )", "docstring_tokens": "Call a system command in the background disown it and hide it s output .", "label": 0}, {"idx": "cosqa-train-5310", "doc": "python pypdf2 added pages are blank", "code": "def _single_page_pdf(page):\n    \"\"\"Construct a single page PDF from the provided page in memory\"\"\"\n    pdf = Pdf.new()\n    pdf.pages.append(page)\n    bio = BytesIO()\n    pdf.save(bio)\n    bio.seek(0)\n    return bio.read()", "code_tokens": "def _single_page_pdf ( page ) : pdf = Pdf . new ( ) pdf . pages . append ( page ) bio = BytesIO ( ) pdf . save ( bio ) bio . seek ( 0 ) return bio . read ( )", "docstring_tokens": "Construct a single page PDF from the provided page in memory", "label": 0}, {"idx": "cosqa-train-5311", "doc": "how to hide particular frame in python gui", "code": "def hide(self):\n        \"\"\"Hides the main window of the terminal and sets the visible\n        flag to False.\n        \"\"\"\n        if not HidePrevention(self.window).may_hide():\n            return\n        self.hidden = True\n        self.get_widget('window-root').unstick()\n        self.window.hide()", "code_tokens": "def hide ( self ) : if not HidePrevention ( self . window ) . may_hide ( ) : return self . hidden = True self . get_widget ( 'window-root' ) . unstick ( ) self . window . hide ( )", "docstring_tokens": "Hides the main window of the terminal and sets the visible flag to False .", "label": 0}, {"idx": "cosqa-train-5312", "doc": "python pyplot set y axis limit", "code": "def set_ylimits(self, row, column, min=None, max=None):\n        \"\"\"Set y-axis limits of a subplot.\n\n        :param row,column: specify the subplot.\n        :param min: minimal axis value\n        :param max: maximum axis value\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_ylimits(min, max)", "code_tokens": "def set_ylimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_ylimits ( min , max )", "docstring_tokens": "Set y - axis limits of a subplot .", "label": 0}, {"idx": "cosqa-train-5313", "doc": "how to highlight a line in python and turn it into a comment", "code": "def isBlockComment(self, line, column):\n        \"\"\"Check if text at given position is a block comment.\n\n        If language is not known, or text is not parsed yet, ``False`` is returned\n        \"\"\"\n        return self._highlighter is not None and \\\n               self._highlighter.isBlockComment(self.document().findBlockByNumber(line), column)", "code_tokens": "def isBlockComment ( self , line , column ) : return self . _highlighter is not None and self . _highlighter . isBlockComment ( self . document ( ) . findBlockByNumber ( line ) , column )", "docstring_tokens": "Check if text at given position is a block comment .", "label": 0}, {"idx": "cosqa-train-5314", "doc": "python qbytearray to str", "code": "def handle_qbytearray(obj, encoding):\n    \"\"\"Qt/Python2/3 compatibility helper.\"\"\"\n    if isinstance(obj, QByteArray):\n        obj = obj.data()\n\n    return to_text_string(obj, encoding=encoding)", "code_tokens": "def handle_qbytearray ( obj , encoding ) : if isinstance ( obj , QByteArray ) : obj = obj . data ( ) return to_text_string ( obj , encoding = encoding )", "docstring_tokens": "Qt / Python2 / 3 compatibility helper .", "label": 0}, {"idx": "cosqa-train-5315", "doc": "how to identify comment python", "code": "def _get_line_no_from_comments(py_line):\n    \"\"\"Return the line number parsed from the comment or 0.\"\"\"\n    matched = LINECOL_COMMENT_RE.match(py_line)\n    if matched:\n        return int(matched.group(1))\n    else:\n        return 0", "code_tokens": "def _get_line_no_from_comments ( py_line ) : matched = LINECOL_COMMENT_RE . match ( py_line ) if matched : return int ( matched . group ( 1 ) ) else : return 0", "docstring_tokens": "Return the line number parsed from the comment or 0 .", "label": 0}, {"idx": "cosqa-train-5316", "doc": "how to implement myown python context manager", "code": "def __enter__(self):\n        \"\"\" Implements the context manager protocol. Specially useful for asserting exceptions\n        \"\"\"\n        clone = self.clone()\n        self._contexts.append(clone)\n        self.reset()\n        return self", "code_tokens": "def __enter__ ( self ) : clone = self . clone ( ) self . _contexts . append ( clone ) self . reset ( ) return self", "docstring_tokens": "Implements the context manager protocol . Specially useful for asserting exceptions", "label": 1}, {"idx": "cosqa-train-5317", "doc": "python query string from dict", "code": "def dict_to_querystring(dictionary):\n    \"\"\"Converts a dict to a querystring suitable to be appended to a URL.\"\"\"\n    s = u\"\"\n    for d in dictionary.keys():\n        s = unicode.format(u\"{0}{1}={2}&\", s, d, dictionary[d])\n    return s[:-1]", "code_tokens": "def dict_to_querystring ( dictionary ) : s = u\"\" for d in dictionary . keys ( ) : s = unicode . format ( u\"{0}{1}={2}&\" , s , d , dictionary [ d ] ) return s [ : - 1 ]", "docstring_tokens": "Converts a dict to a querystring suitable to be appended to a URL .", "label": 0}, {"idx": "cosqa-train-5318", "doc": "how to incorporate progress tracker in for loops in python", "code": "def __call__(self, _):\n        \"\"\"Update the progressbar.\"\"\"\n        if self.iter % self.step == 0:\n            self.pbar.update(self.step)\n\n        self.iter += 1", "code_tokens": "def __call__ ( self , _ ) : if self . iter % self . step == 0 : self . pbar . update ( self . step ) self . iter += 1", "docstring_tokens": "Update the progressbar .", "label": 0}, {"idx": "cosqa-train-5319", "doc": "python quick test for list with null", "code": "def is_nullable_list(val, vtype):\n    \"\"\"Return True if list contains either values of type `vtype` or None.\"\"\"\n    return (isinstance(val, list) and\n            any(isinstance(v, vtype) for v in val) and\n            all((isinstance(v, vtype) or v is None) for v in val))", "code_tokens": "def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )", "docstring_tokens": "Return True if list contains either values of type vtype or None .", "label": 0}, {"idx": "cosqa-train-5320", "doc": "how to increase text size in python", "code": "def set_font_size(self, size):\n        \"\"\"Convenience method for just changing font size.\"\"\"\n        if self.font.font_size == size:\n            pass\n        else:\n            self.font._set_size(size)", "code_tokens": "def set_font_size ( self , size ) : if self . font . font_size == size : pass else : self . font . _set_size ( size )", "docstring_tokens": "Convenience method for just changing font size .", "label": 0}, {"idx": "cosqa-train-5321", "doc": "python quit exit all threads", "code": "def wait_until_exit(self):\n        \"\"\" Wait until all the threads are finished.\n\n        \"\"\"\n        [t.join() for t in self.threads]\n\n        self.threads = list()", "code_tokens": "def wait_until_exit ( self ) : [ t . join ( ) for t in self . threads ] self . threads = list ( )", "docstring_tokens": "Wait until all the threads are finished .", "label": 1}, {"idx": "cosqa-train-5322", "doc": "how to intersect two dictionaries python", "code": "def intersect(d1, d2):\n    \"\"\"Intersect dictionaries d1 and d2 by key *and* value.\"\"\"\n    return dict((k, d1[k]) for k in d1 if k in d2 and d1[k] == d2[k])", "code_tokens": "def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )", "docstring_tokens": "Intersect dictionaries d1 and d2 by key * and * value .", "label": 0}, {"idx": "cosqa-train-5323", "doc": "python range for time", "code": "def timespan(start_time):\n    \"\"\"Return time in milliseconds from start_time\"\"\"\n\n    timespan = datetime.datetime.now() - start_time\n    timespan_ms = timespan.total_seconds() * 1000\n    return timespan_ms", "code_tokens": "def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms", "docstring_tokens": "Return time in milliseconds from start_time", "label": 1}, {"idx": "cosqa-train-5324", "doc": "how to iterate to a folder to get filenames in it in python", "code": "def directory_files(path):\n    \"\"\"Yield directory file names.\"\"\"\n\n    for entry in os.scandir(path):\n        if not entry.name.startswith('.') and entry.is_file():\n            yield entry.name", "code_tokens": "def directory_files ( path ) : for entry in os . scandir ( path ) : if not entry . name . startswith ( '.' ) and entry . is_file ( ) : yield entry . name", "docstring_tokens": "Yield directory file names .", "label": 0}, {"idx": "cosqa-train-5325", "doc": "python range function including endpoints", "code": "def get_range(self, start=None, stop=None):\n\t\t\"\"\"Return a RangeMap for the range start to stop.\n\n\t\tReturns:\n\t\t\tA RangeMap\n\t\t\"\"\"\n\t\treturn self.from_iterable(self.ranges(start, stop))", "code_tokens": "def get_range ( self , start = None , stop = None ) : return self . from_iterable ( self . ranges ( start , stop ) )", "docstring_tokens": "Return a RangeMap for the range start to stop .", "label": 0}, {"idx": "cosqa-train-5326", "doc": "how to keep python output window close", "code": "def safe_exit(output):\n    \"\"\"exit without breaking pipes.\"\"\"\n    try:\n        sys.stdout.write(output)\n        sys.stdout.flush()\n    except IOError:\n        pass", "code_tokens": "def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass", "docstring_tokens": "exit without breaking pipes .", "label": 0}, {"idx": "cosqa-train-5327", "doc": "python range zero fill", "code": "def LinSpace(start, stop, num):\n    \"\"\"\n    Linspace op.\n    \"\"\"\n    return np.linspace(start, stop, num=num, dtype=np.float32),", "code_tokens": "def LinSpace ( start , stop , num ) : return np . linspace ( start , stop , num = num , dtype = np . float32 ) ,", "docstring_tokens": "Linspace op .", "label": 0}, {"idx": "cosqa-train-5328", "doc": "how to keep the cursor from being at the bottom of the screen in python spyder", "code": "def ensure_hbounds(self):\n        \"\"\"Ensure the cursor is within horizontal screen bounds.\"\"\"\n        self.cursor.x = min(max(0, self.cursor.x), self.columns - 1)", "code_tokens": "def ensure_hbounds ( self ) : self . cursor . x = min ( max ( 0 , self . cursor . x ) , self . columns - 1 )", "docstring_tokens": "Ensure the cursor is within horizontal screen bounds .", "label": 0}, {"idx": "cosqa-train-5329", "doc": "python rate limit requests external", "code": "def _ratelimited_get(self, *args, **kwargs):\n        \"\"\"Perform get request, handling rate limiting.\"\"\"\n        with self._ratelimiter:\n            resp = self.session.get(*args, **kwargs)\n\n        # It's possible that Space-Track will return HTTP status 500 with a\n        # query rate limit violation. This can happen if a script is cancelled\n        # before it has finished sleeping to satisfy the rate limit and it is\n        # started again.\n        #\n        # Let's catch this specific instance and retry once if it happens.\n        if resp.status_code == 500:\n            # Let's only retry if the error page tells us it's a rate limit\n            # violation.\n            if 'violated your query rate limit' in resp.text:\n                # Mimic the RateLimiter callback behaviour.\n                until = time.time() + self._ratelimiter.period\n                t = threading.Thread(target=self._ratelimit_callback, args=(until,))\n                t.daemon = True\n                t.start()\n                time.sleep(self._ratelimiter.period)\n\n                # Now retry\n                with self._ratelimiter:\n                    resp = self.session.get(*args, **kwargs)\n\n        return resp", "code_tokens": "def _ratelimited_get ( self , * args , * * kwargs ) : with self . _ratelimiter : resp = self . session . get ( * args , * * kwargs ) # It's possible that Space-Track will return HTTP status 500 with a # query rate limit violation. This can happen if a script is cancelled # before it has finished sleeping to satisfy the rate limit and it is # started again. # # Let's catch this specific instance and retry once if it happens. if resp . status_code == 500 : # Let's only retry if the error page tells us it's a rate limit # violation. if 'violated your query rate limit' in resp . text : # Mimic the RateLimiter callback behaviour. until = time . time ( ) + self . _ratelimiter . period t = threading . Thread ( target = self . _ratelimit_callback , args = ( until , ) ) t . daemon = True t . start ( ) time . sleep ( self . _ratelimiter . period ) # Now retry with self . _ratelimiter : resp = self . session . get ( * args , * * kwargs ) return resp", "docstring_tokens": "Perform get request handling rate limiting .", "label": 1}, {"idx": "cosqa-train-5330", "doc": "how to kill just child process in python", "code": "def close(self):\n        \"\"\"Close child subprocess\"\"\"\n        if self._subprocess is not None:\n            os.killpg(self._subprocess.pid, signal.SIGTERM)\n            self._subprocess = None", "code_tokens": "def close ( self ) : if self . _subprocess is not None : os . killpg ( self . _subprocess . pid , signal . SIGTERM ) self . _subprocess = None", "docstring_tokens": "Close child subprocess", "label": 1}, {"idx": "cosqa-train-5331", "doc": "how to load mnist data in python3", "code": "def get_mnist(data_type=\"train\", location=\"/tmp/mnist\"):\n    \"\"\"\n    Get mnist dataset with features and label as ndarray.\n    Data would be downloaded automatically if it doesn't present at the specific location.\n\n    :param data_type: \"train\" for training data and \"test\" for testing data.\n    :param location: Location to store mnist dataset.\n    :return: (features: ndarray, label: ndarray)\n    \"\"\"\n    X, Y = mnist.read_data_sets(location, data_type)\n    return X, Y + 1", "code_tokens": "def get_mnist ( data_type = \"train\" , location = \"/tmp/mnist\" ) : X , Y = mnist . read_data_sets ( location , data_type ) return X , Y + 1", "docstring_tokens": "Get mnist dataset with features and label as ndarray . Data would be downloaded automatically if it doesn t present at the specific location .", "label": 0}, {"idx": "cosqa-train-5332", "doc": "python read ascii and removing lines", "code": "def rAsciiLine(ifile):\n    \"\"\"Returns the next non-blank line in an ASCII file.\"\"\"\n\n    _line = ifile.readline().strip()\n    while len(_line) == 0:\n        _line = ifile.readline().strip()\n    return _line", "code_tokens": "def rAsciiLine ( ifile ) : _line = ifile . readline ( ) . strip ( ) while len ( _line ) == 0 : _line = ifile . readline ( ) . strip ( ) return _line", "docstring_tokens": "Returns the next non - blank line in an ASCII file .", "label": 0}, {"idx": "cosqa-train-5333", "doc": "how to load python using javascript", "code": "def import_js(path, lib_name, globals):\n    \"\"\"Imports from javascript source file.\n      globals is your globals()\"\"\"\n    with codecs.open(path_as_local(path), \"r\", \"utf-8\") as f:\n        js = f.read()\n    e = EvalJs()\n    e.execute(js)\n    var = e.context['var']\n    globals[lib_name] = var.to_python()", "code_tokens": "def import_js ( path , lib_name , globals ) : with codecs . open ( path_as_local ( path ) , \"r\" , \"utf-8\" ) as f : js = f . read ( ) e = EvalJs ( ) e . execute ( js ) var = e . context [ 'var' ] globals [ lib_name ] = var . to_python ( )", "docstring_tokens": "Imports from javascript source file . globals is your globals ()", "label": 1}, {"idx": "cosqa-train-5334", "doc": "python read binary large", "code": "def read_large_int(self, bits, signed=True):\n        \"\"\"Reads a n-bits long integer value.\"\"\"\n        return int.from_bytes(\n            self.read(bits // 8), byteorder='little', signed=signed)", "code_tokens": "def read_large_int ( self , bits , signed = True ) : return int . from_bytes ( self . read ( bits // 8 ) , byteorder = 'little' , signed = signed )", "docstring_tokens": "Reads a n - bits long integer value .", "label": 0}, {"idx": "cosqa-train-5335", "doc": "how to lower the size of an image in python", "code": "def scale_image(image, new_width):\n    \"\"\"Resizes an image preserving the aspect ratio.\n    \"\"\"\n    (original_width, original_height) = image.size\n    aspect_ratio = original_height/float(original_width)\n    new_height = int(aspect_ratio * new_width)\n\n    # This scales it wider than tall, since characters are biased\n    new_image = image.resize((new_width*2, new_height))\n    return new_image", "code_tokens": "def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image", "docstring_tokens": "Resizes an image preserving the aspect ratio .", "label": 0}, {"idx": "cosqa-train-5336", "doc": "python read doc and rtf", "code": "def readme():\n    \"\"\"Try converting the README to an RST document. Return it as is on failure.\"\"\"\n    try:\n        import pypandoc\n        readme_content = pypandoc.convert('README.md', 'rst')\n    except(IOError, ImportError):\n        print(\"Warning: no pypandoc module found.\")\n        try:\n            readme_content = open('README.md').read()\n        except IOError:\n            readme_content = ''\n    return readme_content", "code_tokens": "def readme ( ) : try : import pypandoc readme_content = pypandoc . convert ( 'README.md' , 'rst' ) except ( IOError , ImportError ) : print ( \"Warning: no pypandoc module found.\" ) try : readme_content = open ( 'README.md' ) . read ( ) except IOError : readme_content = '' return readme_content", "docstring_tokens": "Try converting the README to an RST document . Return it as is on failure .", "label": 0}, {"idx": "cosqa-train-5337", "doc": "how to maintain space padding in python", "code": "def _pad(self, text):\n        \"\"\"Pad the text.\"\"\"\n        top_bottom = (\"\\n\" * self._padding) + \" \"\n        right_left = \" \" * self._padding * self.PAD_WIDTH\n        return top_bottom + right_left + text + right_left + top_bottom", "code_tokens": "def _pad ( self , text ) : top_bottom = ( \"\\n\" * self . _padding ) + \" \" right_left = \" \" * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom", "docstring_tokens": "Pad the text .", "label": 0}, {"idx": "cosqa-train-5338", "doc": "python read file of short integers", "code": "def _fast_read(self, infile):\n        \"\"\"Function for fast reading from sensor files.\"\"\"\n        infile.seek(0)\n        return(int(infile.read().decode().strip()))", "code_tokens": "def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )", "docstring_tokens": "Function for fast reading from sensor files .", "label": 0}, {"idx": "cosqa-train-5339", "doc": "how to make 50 spaces in print statemnet python", "code": "def indented_show(text, howmany=1):\n        \"\"\"Print a formatted indented text.\n        \"\"\"\n        print(StrTemplate.pad_indent(text=text, howmany=howmany))", "code_tokens": "def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )", "docstring_tokens": "Print a formatted indented text .", "label": 0}, {"idx": "cosqa-train-5340", "doc": "python read file with multiple json objects", "code": "def _read_json_file(self, json_file):\n        \"\"\" Helper function to read JSON file as OrderedDict \"\"\"\n\n        self.log.debug(\"Reading '%s' JSON file...\" % json_file)\n\n        with open(json_file, 'r') as f:\n            return json.load(f, object_pairs_hook=OrderedDict)", "code_tokens": "def _read_json_file ( self , json_file ) : self . log . debug ( \"Reading '%s' JSON file...\" % json_file ) with open ( json_file , 'r' ) as f : return json . load ( f , object_pairs_hook = OrderedDict )", "docstring_tokens": "Helper function to read JSON file as OrderedDict", "label": 0}, {"idx": "cosqa-train-5341", "doc": "how to make a field python", "code": "def _basic_field_data(field, obj):\n    \"\"\"Returns ``obj.field`` data as a dict\"\"\"\n    value = field.value_from_object(obj)\n    return {Field.TYPE: FieldType.VAL, Field.VALUE: value}", "code_tokens": "def _basic_field_data ( field , obj ) : value = field . value_from_object ( obj ) return { Field . TYPE : FieldType . VAL , Field . VALUE : value }", "docstring_tokens": "Returns obj . field data as a dict", "label": 1}, {"idx": "cosqa-train-5342", "doc": "python read in list from file", "code": "def get_list_from_file(file_name):\n    \"\"\"read the lines from a file into a list\"\"\"\n    with open(file_name, mode='r', encoding='utf-8') as f1:\n        lst = f1.readlines()\n    return lst", "code_tokens": "def get_list_from_file ( file_name ) : with open ( file_name , mode = 'r' , encoding = 'utf-8' ) as f1 : lst = f1 . readlines ( ) return lst", "docstring_tokens": "read the lines from a file into a list", "label": 0}, {"idx": "cosqa-train-5343", "doc": "how to make a kick command with python discord", "code": "def kick(self, channel, nick, comment=\"\"):\n        \"\"\"Send a KICK command.\"\"\"\n        self.send_items('KICK', channel, nick, comment and ':' + comment)", "code_tokens": "def kick ( self , channel , nick , comment = \"\" ) : self . send_items ( 'KICK' , channel , nick , comment and ':' + comment )", "docstring_tokens": "Send a KICK command .", "label": 0}, {"idx": "cosqa-train-5344", "doc": "python read lines from stdin", "code": "def standard_input():\n    \"\"\"Generator that yields lines from standard input.\"\"\"\n    with click.get_text_stream(\"stdin\") as stdin:\n        while stdin.readable():\n            line = stdin.readline()\n            if line:\n                yield line.strip().encode(\"utf-8\")", "code_tokens": "def standard_input ( ) : with click . get_text_stream ( \"stdin\" ) as stdin : while stdin . readable ( ) : line = stdin . readline ( ) if line : yield line . strip ( ) . encode ( \"utf-8\" )", "docstring_tokens": "Generator that yields lines from standard input .", "label": 0}, {"idx": "cosqa-train-5345", "doc": "how to make a list in python that is a certain length", "code": "def chunk_list(l, n):\n    \"\"\"Return `n` size lists from a given list `l`\"\"\"\n    return [l[i:i + n] for i in range(0, len(l), n)]", "code_tokens": "def chunk_list ( l , n ) : return [ l [ i : i + n ] for i in range ( 0 , len ( l ) , n ) ]", "docstring_tokens": "Return n size lists from a given list l", "label": 0}, {"idx": "cosqa-train-5346", "doc": "python read text from url", "code": "def url_read_text(url, verbose=True):\n    r\"\"\"\n    Directly reads text data from url\n    \"\"\"\n    data = url_read(url, verbose)\n    text = data.decode('utf8')\n    return text", "code_tokens": "def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text", "docstring_tokens": "r Directly reads text data from url", "label": 0}, {"idx": "cosqa-train-5347", "doc": "how to make a list initialized from iterable's items python", "code": "def group_by(iterable, key_func):\n    \"\"\"Wrap itertools.groupby to make life easier.\"\"\"\n    groups = (\n        list(sub) for key, sub in groupby(iterable, key_func)\n    )\n    return zip(groups, groups)", "code_tokens": "def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "docstring_tokens": "Wrap itertools . groupby to make life easier .", "label": 0}, {"idx": "cosqa-train-5348", "doc": "python read until end of file binary", "code": "def _readuntil(f, end=_TYPE_END):\n\t\"\"\"Helper function to read bytes until a certain end byte is hit\"\"\"\n\tbuf = bytearray()\n\tbyte = f.read(1)\n\twhile byte != end:\n\t\tif byte == b'':\n\t\t\traise ValueError('File ended unexpectedly. Expected end byte {}.'.format(end))\n\t\tbuf += byte\n\t\tbyte = f.read(1)\n\treturn buf", "code_tokens": "def _readuntil ( f , end = _TYPE_END ) : buf = bytearray ( ) byte = f . read ( 1 ) while byte != end : if byte == b'' : raise ValueError ( 'File ended unexpectedly. Expected end byte {}.' . format ( end ) ) buf += byte byte = f . read ( 1 ) return buf", "docstring_tokens": "Helper function to read bytes until a certain end byte is hit", "label": 0}, {"idx": "cosqa-train-5349", "doc": "how to make a normal distribution on python", "code": "def rnormal(mu, tau, size=None):\n    \"\"\"\n    Random normal variates.\n    \"\"\"\n    return np.random.normal(mu, 1. / np.sqrt(tau), size)", "code_tokens": "def rnormal ( mu , tau , size = None ) : return np . random . normal ( mu , 1. / np . sqrt ( tau ) , size )", "docstring_tokens": "Random normal variates .", "label": 0}, {"idx": "cosqa-train-5350", "doc": "python reading bigendian data", "code": "def read_data(file, endian, num=1):\n    \"\"\"\n    Read a given number of 32-bits unsigned integers from the given file\n    with the given endianness.\n    \"\"\"\n    res = struct.unpack(endian + 'L' * num, file.read(num * 4))\n    if len(res) == 1:\n        return res[0]\n    return res", "code_tokens": "def read_data ( file , endian , num = 1 ) : res = struct . unpack ( endian + 'L' * num , file . read ( num * 4 ) ) if len ( res ) == 1 : return res [ 0 ] return res", "docstring_tokens": "Read a given number of 32 - bits unsigned integers from the given file with the given endianness .", "label": 1}, {"idx": "cosqa-train-5351", "doc": "how to make a python code for a word count with removing punctuations", "code": "def counter_from_str(self, string):\n        \"\"\"Build word frequency list from incoming string.\"\"\"\n        string_list = [chars for chars in string if chars not in self.punctuation]\n        string_joined = ''.join(string_list)\n        tokens = self.punkt.word_tokenize(string_joined)\n        return Counter(tokens)", "code_tokens": "def counter_from_str ( self , string ) : string_list = [ chars for chars in string if chars not in self . punctuation ] string_joined = '' . join ( string_list ) tokens = self . punkt . word_tokenize ( string_joined ) return Counter ( tokens )", "docstring_tokens": "Build word frequency list from incoming string .", "label": 0}, {"idx": "cosqa-train-5352", "doc": "how to make a python file exit", "code": "def safe_exit(output):\n    \"\"\"exit without breaking pipes.\"\"\"\n    try:\n        sys.stdout.write(output)\n        sys.stdout.flush()\n    except IOError:\n        pass", "code_tokens": "def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass", "docstring_tokens": "exit without breaking pipes .", "label": 0}, {"idx": "cosqa-train-5353", "doc": "python recommended line length", "code": "def _multiline_width(multiline_s, line_width_fn=len):\n    \"\"\"Visible width of a potentially multiline content.\"\"\"\n    return max(map(line_width_fn, re.split(\"[\\r\\n]\", multiline_s)))", "code_tokens": "def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( \"[\\r\\n]\" , multiline_s ) ) )", "docstring_tokens": "Visible width of a potentially multiline content .", "label": 0}, {"idx": "cosqa-train-5354", "doc": "how to make a restart button in python", "code": "def do_restart(self, line):\n        \"\"\"Request that the Outstation perform a cold restart. Command syntax is: restart\"\"\"\n        self.application.master.Restart(opendnp3.RestartType.COLD, restart_callback)", "code_tokens": "def do_restart ( self , line ) : self . application . master . Restart ( opendnp3 . RestartType . COLD , restart_callback )", "docstring_tokens": "Request that the Outstation perform a cold restart . Command syntax is : restart", "label": 0}, {"idx": "cosqa-train-5355", "doc": "python redis hashes set list value", "code": "def __setitem__(self, field, value):\n        \"\"\" :see::meth:RedisMap.__setitem__ \"\"\"\n        return self._client.hset(self.key_prefix, field, self._dumps(value))", "code_tokens": "def __setitem__ ( self , field , value ) : return self . _client . hset ( self . key_prefix , field , self . _dumps ( value ) )", "docstring_tokens": ": see :: meth : RedisMap . __setitem__", "label": 0}, {"idx": "cosqa-train-5356", "doc": "how to make all words a user types lowercase in python", "code": "def downcaseTokens(s,l,t):\n    \"\"\"Helper parse action to convert tokens to lower case.\"\"\"\n    return [ tt.lower() for tt in map(_ustr,t) ]", "code_tokens": "def downcaseTokens ( s , l , t ) : return [ tt . lower ( ) for tt in map ( _ustr , t ) ]", "docstring_tokens": "Helper parse action to convert tokens to lower case .", "label": 0}, {"idx": "cosqa-train-5357", "doc": "python redis hset multiple", "code": "def __setitem__(self, field, value):\n        \"\"\" :see::meth:RedisMap.__setitem__ \"\"\"\n        return self._client.hset(self.key_prefix, field, self._dumps(value))", "code_tokens": "def __setitem__ ( self , field , value ) : return self . _client . hset ( self . key_prefix , field , self . _dumps ( value ) )", "docstring_tokens": ": see :: meth : RedisMap . __setitem__", "label": 0}, {"idx": "cosqa-train-5358", "doc": "how to make an exponential in python", "code": "def algo_exp(x, m, t, b):\n    \"\"\"mono-exponential curve.\"\"\"\n    return m*np.exp(-t*x)+b", "code_tokens": "def algo_exp ( x , m , t , b ) : return m * np . exp ( - t * x ) + b", "docstring_tokens": "mono - exponential curve .", "label": 0}, {"idx": "cosqa-train-5359", "doc": "python redis key value size", "code": "def hstrlen(self, name, key):\n        \"\"\"\n        Return the number of bytes stored in the value of ``key``\n        within hash ``name``\n        \"\"\"\n        with self.pipe as pipe:\n            return pipe.hstrlen(self.redis_key(name), key)", "code_tokens": "def hstrlen ( self , name , key ) : with self . pipe as pipe : return pipe . hstrlen ( self . redis_key ( name ) , key )", "docstring_tokens": "Return the number of bytes stored in the value of key within hash name", "label": 0}, {"idx": "cosqa-train-5360", "doc": "how to make an owl in python", "code": "def get_default_preds():\n    \"\"\"dynamically build autocomplete options based on an external file\"\"\"\n    g = ontospy.Ontospy(rdfsschema, text=True, verbose=False, hide_base_schemas=False)\n    classes = [(x.qname, x.bestDescription()) for x in g.all_classes]\n    properties = [(x.qname, x.bestDescription()) for x in g.all_properties]\n    commands = [('exit', 'exits the terminal'), ('show', 'show current buffer')]\n    return rdfschema + owlschema + classes + properties + commands", "code_tokens": "def get_default_preds ( ) : g = ontospy . Ontospy ( rdfsschema , text = True , verbose = False , hide_base_schemas = False ) classes = [ ( x . qname , x . bestDescription ( ) ) for x in g . all_classes ] properties = [ ( x . qname , x . bestDescription ( ) ) for x in g . all_properties ] commands = [ ( 'exit' , 'exits the terminal' ) , ( 'show' , 'show current buffer' ) ] return rdfschema + owlschema + classes + properties + commands", "docstring_tokens": "dynamically build autocomplete options based on an external file", "label": 0}, {"idx": "cosqa-train-5361", "doc": "python redis pool disconnect", "code": "def exit(self):\n        \"\"\"\n        Closes the connection\n        \"\"\"\n        self.pubsub.unsubscribe()\n        self.client.connection_pool.disconnect()\n\n        logger.info(\"Connection to Redis closed\")", "code_tokens": "def exit ( self ) : self . pubsub . unsubscribe ( ) self . client . connection_pool . disconnect ( ) logger . info ( \"Connection to Redis closed\" )", "docstring_tokens": "Closes the connection", "label": 0}, {"idx": "cosqa-train-5362", "doc": "how to make changed in a dictionary without changing the original python", "code": "def changed(self):\n        \"\"\"Returns dict of fields that changed since save (with old values)\"\"\"\n        return dict(\n            (field, self.previous(field))\n            for field in self.fields\n            if self.has_changed(field)\n        )", "code_tokens": "def changed ( self ) : return dict ( ( field , self . previous ( field ) ) for field in self . fields if self . has_changed ( field ) )", "docstring_tokens": "Returns dict of fields that changed since save ( with old values )", "label": 0}, {"idx": "cosqa-train-5363", "doc": "python redisclient' object has no attribute 'exists'", "code": "def _get_info(self, host, port, unix_socket, auth):\n        \"\"\"Return info dict from specified Redis instance\n\n:param str host: redis host\n:param int port: redis port\n:rtype: dict\n\n        \"\"\"\n\n        client = self._client(host, port, unix_socket, auth)\n        if client is None:\n            return None\n\n        info = client.info()\n        del client\n        return info", "code_tokens": "def _get_info ( self , host , port , unix_socket , auth ) : client = self . _client ( host , port , unix_socket , auth ) if client is None : return None info = client . info ( ) del client return info", "docstring_tokens": "Return info dict from specified Redis instance", "label": 0}, {"idx": "cosqa-train-5364", "doc": "how to make combinations of a list python", "code": "def combinations(l):\n    \"\"\"Pure-Python implementation of itertools.combinations(l, 2).\"\"\"\n    result = []\n    for x in xrange(len(l) - 1):\n        ls = l[x + 1:]\n        for y in ls:\n            result.append((l[x], y))\n    return result", "code_tokens": "def combinations ( l ) : result = [ ] for x in xrange ( len ( l ) - 1 ) : ls = l [ x + 1 : ] for y in ls : result . append ( ( l [ x ] , y ) ) return result", "docstring_tokens": "Pure - Python implementation of itertools . combinations ( l 2 ) .", "label": 0}, {"idx": "cosqa-train-5365", "doc": "python reduce pdf file size", "code": "def append_pdf(input_pdf: bytes, output_writer: PdfFileWriter):\n    \"\"\"\n    Appends a PDF to a pyPDF writer. Legacy interface.\n    \"\"\"\n    append_memory_pdf_to_writer(input_pdf=input_pdf,\n                                writer=output_writer)", "code_tokens": "def append_pdf ( input_pdf : bytes , output_writer : PdfFileWriter ) : append_memory_pdf_to_writer ( input_pdf = input_pdf , writer = output_writer )", "docstring_tokens": "Appends a PDF to a pyPDF writer . Legacy interface .", "label": 0}, {"idx": "cosqa-train-5366", "doc": "how to make idx count from left to right python", "code": "def rank(idx, dim):\n    \"\"\"Calculate the index rank according to Bertran's notation.\"\"\"\n    idxm = multi_index(idx, dim)\n    out = 0\n    while idxm[-1:] == (0,):\n        out += 1\n        idxm = idxm[:-1]\n    return out", "code_tokens": "def rank ( idx , dim ) : idxm = multi_index ( idx , dim ) out = 0 while idxm [ - 1 : ] == ( 0 , ) : out += 1 idxm = idxm [ : - 1 ] return out", "docstring_tokens": "Calculate the index rank according to Bertran s notation .", "label": 0}, {"idx": "cosqa-train-5367", "doc": "python regular expression extract tables in sql", "code": "def extract_table_names(query):\n    \"\"\" Extract table names from an SQL query. \"\"\"\n    # a good old fashioned regex. turns out this worked better than actually parsing the code\n    tables_blocks = re.findall(r'(?:FROM|JOIN)\\s+(\\w+(?:\\s*,\\s*\\w+)*)', query, re.IGNORECASE)\n    tables = [tbl\n              for block in tables_blocks\n              for tbl in re.findall(r'\\w+', block)]\n    return set(tables)", "code_tokens": "def extract_table_names ( query ) : # a good old fashioned regex. turns out this worked better than actually parsing the code tables_blocks = re . findall ( r'(?:FROM|JOIN)\\s+(\\w+(?:\\s*,\\s*\\w+)*)' , query , re . IGNORECASE ) tables = [ tbl for block in tables_blocks for tbl in re . findall ( r'\\w+' , block ) ] return set ( tables )", "docstring_tokens": "Extract table names from an SQL query .", "label": 0}, {"idx": "cosqa-train-5368", "doc": "how to make numpy array iterable python", "code": "def _npiter(arr):\n    \"\"\"Wrapper for iterating numpy array\"\"\"\n    for a in np.nditer(arr, flags=[\"refs_ok\"]):\n        c = a.item()\n        if c is not None:\n            yield c", "code_tokens": "def _npiter ( arr ) : for a in np . nditer ( arr , flags = [ \"refs_ok\" ] ) : c = a . item ( ) if c is not None : yield c", "docstring_tokens": "Wrapper for iterating numpy array", "label": 0}, {"idx": "cosqa-train-5369", "doc": "python rel to abs path", "code": "def __absolute__(self, uri):\n        \"\"\" Get the absolute uri for a file\n\n        :param uri: URI of the resource to be retrieved\n        :return: Absolute Path\n        \"\"\"\n        return op.abspath(op.join(self.__path__, uri))", "code_tokens": "def __absolute__ ( self , uri ) : return op . abspath ( op . join ( self . __path__ , uri ) )", "docstring_tokens": "Get the absolute uri for a file", "label": 1}, {"idx": "cosqa-train-5370", "doc": "how to make print bold in python", "code": "def good(txt):\n    \"\"\"Print, emphasized 'good', the given 'txt' message\"\"\"\n\n    print(\"%s# %s%s%s\" % (PR_GOOD_CC, get_time_stamp(), txt, PR_NC))\n    sys.stdout.flush()", "code_tokens": "def good ( txt ) : print ( \"%s# %s%s%s\" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "docstring_tokens": "Print emphasized good the given txt message", "label": 1}, {"idx": "cosqa-train-5371", "doc": "python reload page withdelay", "code": "def pages(self):\n        \"\"\"Get pages, reloading the site if needed.\"\"\"\n        rev = self.db.get('site:rev')\n        if int(rev) != self.revision:\n            self.reload_site()\n\n        return self._pages", "code_tokens": "def pages ( self ) : rev = self . db . get ( 'site:rev' ) if int ( rev ) != self . revision : self . reload_site ( ) return self . _pages", "docstring_tokens": "Get pages reloading the site if needed .", "label": 0}, {"idx": "cosqa-train-5372", "doc": "how to make python run a linear equation", "code": "def logx_linear(x, a, b):\n    \"\"\"logx linear\n\n    Parameters\n    ----------\n    x: int\n    a: float\n    b: float\n\n    Returns\n    -------\n    float\n        a * np.log(x) + b\n    \"\"\"\n    x = np.log(x)\n    return a*x + b", "code_tokens": "def logx_linear ( x , a , b ) : x = np . log ( x ) return a * x + b", "docstring_tokens": "logx linear", "label": 0}, {"idx": "cosqa-train-5373", "doc": "how to make sure the date attribute has a date type in python", "code": "def is_date(thing):\n    \"\"\"Checks if the given thing represents a date\n\n    :param thing: The object to check if it is a date\n    :type thing: arbitrary object\n    :returns: True if we have a date object\n    :rtype: bool\n    \"\"\"\n    # known date types\n    date_types = (datetime.datetime,\n                  datetime.date,\n                  DateTime)\n    return isinstance(thing, date_types)", "code_tokens": "def is_date ( thing ) : # known date types date_types = ( datetime . datetime , datetime . date , DateTime ) return isinstance ( thing , date_types )", "docstring_tokens": "Checks if the given thing represents a date", "label": 0}, {"idx": "cosqa-train-5374", "doc": "python remove all chinese punctuation", "code": "def strip_accents(s):\n    \"\"\"\n    Strip accents to prepare for slugification.\n    \"\"\"\n    nfkd = unicodedata.normalize('NFKD', unicode(s))\n    return u''.join(ch for ch in nfkd if not unicodedata.combining(ch))", "code_tokens": "def strip_accents ( s ) : nfkd = unicodedata . normalize ( 'NFKD' , unicode ( s ) ) return u'' . join ( ch for ch in nfkd if not unicodedata . combining ( ch ) )", "docstring_tokens": "Strip accents to prepare for slugification .", "label": 0}, {"idx": "cosqa-train-5375", "doc": "how to make the range function go from minimum to maximum in python", "code": "def min_values(args):\n    \"\"\" Return possible range for min function. \"\"\"\n    return Interval(min(x.low for x in args), min(x.high for x in args))", "code_tokens": "def min_values ( args ) : return Interval ( min ( x . low for x in args ) , min ( x . high for x in args ) )", "docstring_tokens": "Return possible range for min function .", "label": 0}, {"idx": "cosqa-train-5376", "doc": "python remove all white space in string", "code": "def unpunctuate(s, *, char_blacklist=string.punctuation):\n    \"\"\" Remove punctuation from string s. \"\"\"\n    # remove punctuation\n    s = \"\".join(c for c in s if c not in char_blacklist)\n    # remove consecutive spaces\n    return \" \".join(filter(None, s.split(\" \")))", "code_tokens": "def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = \"\" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return \" \" . join ( filter ( None , s . split ( \" \" ) ) )", "docstring_tokens": "Remove punctuation from string s .", "label": 0}, {"idx": "cosqa-train-5377", "doc": "how to make the the cursor visimble in the canvas widget in python", "code": "def ensure_hbounds(self):\n        \"\"\"Ensure the cursor is within horizontal screen bounds.\"\"\"\n        self.cursor.x = min(max(0, self.cursor.x), self.columns - 1)", "code_tokens": "def ensure_hbounds ( self ) : self . cursor . x = min ( max ( 0 , self . cursor . x ) , self . columns - 1 )", "docstring_tokens": "Ensure the cursor is within horizontal screen bounds .", "label": 0}, {"idx": "cosqa-train-5378", "doc": "python remove axison legend", "code": "def remove_legend(ax=None):\n    \"\"\"Remove legend for axes or gca.\n\n    See http://osdir.com/ml/python.matplotlib.general/2005-07/msg00285.html\n    \"\"\"\n    from pylab import gca, draw\n    if ax is None:\n        ax = gca()\n    ax.legend_ = None\n    draw()", "code_tokens": "def remove_legend ( ax = None ) : from pylab import gca , draw if ax is None : ax = gca ( ) ax . legend_ = None draw ( )", "docstring_tokens": "Remove legend for axes or gca .", "label": 0}, {"idx": "cosqa-train-5379", "doc": "python remove brackets and commas from list", "code": "def strip_spaces(value, sep=None, join=True):\n    \"\"\"Cleans trailing whitespaces and replaces also multiple whitespaces with a single space.\"\"\"\n    value = value.strip()\n    value = [v.strip() for v in value.split(sep)]\n    join_sep = sep or ' '\n    return join_sep.join(value) if join else value", "code_tokens": "def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value", "docstring_tokens": "Cleans trailing whitespaces and replaces also multiple whitespaces with a single space .", "label": 1}, {"idx": "cosqa-train-5380", "doc": "how to make word without punction or capitalization python", "code": "def classnameify(s):\n  \"\"\"\n  Makes a classname\n  \"\"\"\n  return ''.join(w if w in ACRONYMS else w.title() for w in s.split('_'))", "code_tokens": "def classnameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '_' ) )", "docstring_tokens": "Makes a classname", "label": 0}, {"idx": "cosqa-train-5381", "doc": "python remove commas from a list", "code": "def __normalize_list(self, msg):\n        \"\"\"Split message to list by commas and trim whitespace.\"\"\"\n        if isinstance(msg, list):\n            msg = \"\".join(msg)\n        return list(map(lambda x: x.strip(), msg.split(\",\")))", "code_tokens": "def __normalize_list ( self , msg ) : if isinstance ( msg , list ) : msg = \"\" . join ( msg ) return list ( map ( lambda x : x . strip ( ) , msg . split ( \",\" ) ) )", "docstring_tokens": "Split message to list by commas and trim whitespace .", "label": 1}, {"idx": "cosqa-train-5382", "doc": "how to multiply a list by a factor in python", "code": "def multiply(self, number):\n        \"\"\"Return a Vector as the product of the vector and a real number.\"\"\"\n        return self.from_list([x * number for x in self.to_list()])", "code_tokens": "def multiply ( self , number ) : return self . from_list ( [ x * number for x in self . to_list ( ) ] )", "docstring_tokens": "Return a Vector as the product of the vector and a real number .", "label": 0}, {"idx": "cosqa-train-5383", "doc": "how to name a cube in python", "code": "def get_cube(name):\n    \"\"\" Load the named cube from the current registered ``CubeManager``. \"\"\"\n    manager = get_manager()\n    if not manager.has_cube(name):\n        raise NotFound('No such cube: %r' % name)\n    return manager.get_cube(name)", "code_tokens": "def get_cube ( name ) : manager = get_manager ( ) if not manager . has_cube ( name ) : raise NotFound ( 'No such cube: %r' % name ) return manager . get_cube ( name )", "docstring_tokens": "Load the named cube from the current registered CubeManager .", "label": 0}, {"idx": "cosqa-train-5384", "doc": "python remove duplicate elements in sequence from list", "code": "def remove_dups(seq):\n    \"\"\"remove duplicates from a sequence, preserving order\"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "remove duplicates from a sequence preserving order", "label": 0}, {"idx": "cosqa-train-5385", "doc": "how to number python source lines", "code": "def mark(self, lineno, count=1):\n        \"\"\"Mark a given source line as executed count times.\n\n        Multiple calls to mark for the same lineno add up.\n        \"\"\"\n        self.sourcelines[lineno] = self.sourcelines.get(lineno, 0) + count", "code_tokens": "def mark ( self , lineno , count = 1 ) : self . sourcelines [ lineno ] = self . sourcelines . get ( lineno , 0 ) + count", "docstring_tokens": "Mark a given source line as executed count times .", "label": 1}, {"idx": "cosqa-train-5386", "doc": "python remove duplicates fasta", "code": "def dedupFasta(reads):\n    \"\"\"\n    Remove sequence duplicates (based on sequence) from FASTA.\n\n    @param reads: a C{dark.reads.Reads} instance.\n    @return: a generator of C{dark.reads.Read} instances with no duplicates.\n    \"\"\"\n    seen = set()\n    add = seen.add\n    for read in reads:\n        hash_ = md5(read.sequence.encode('UTF-8')).digest()\n        if hash_ not in seen:\n            add(hash_)\n            yield read", "code_tokens": "def dedupFasta ( reads ) : seen = set ( ) add = seen . add for read in reads : hash_ = md5 ( read . sequence . encode ( 'UTF-8' ) ) . digest ( ) if hash_ not in seen : add ( hash_ ) yield read", "docstring_tokens": "Remove sequence duplicates ( based on sequence ) from FASTA .", "label": 1}, {"idx": "cosqa-train-5387", "doc": "how to only get value without dtype python array", "code": "def remove_na_arraylike(arr):\n    \"\"\"\n    Return array-like containing only true/non-NaN values, possibly empty.\n    \"\"\"\n    if is_extension_array_dtype(arr):\n        return arr[notna(arr)]\n    else:\n        return arr[notna(lib.values_from_object(arr))]", "code_tokens": "def remove_na_arraylike ( arr ) : if is_extension_array_dtype ( arr ) : return arr [ notna ( arr ) ] else : return arr [ notna ( lib . values_from_object ( arr ) ) ]", "docstring_tokens": "Return array - like containing only true / non - NaN values possibly empty .", "label": 0}, {"idx": "cosqa-train-5388", "doc": "python remove element in dict", "code": "def pop (self, key):\n        \"\"\"Remove key from dict and return value.\"\"\"\n        if key in self._keys:\n            self._keys.remove(key)\n        super(ListDict, self).pop(key)", "code_tokens": "def pop ( self , key ) : if key in self . _keys : self . _keys . remove ( key ) super ( ListDict , self ) . pop ( key )", "docstring_tokens": "Remove key from dict and return value .", "label": 0}, {"idx": "cosqa-train-5389", "doc": "how to open an image in python'", "code": "def load_image(fname):\n    \"\"\" read an image from file - PIL doesnt close nicely \"\"\"\n    with open(fname, \"rb\") as f:\n        i = Image.open(fname)\n        #i.load()\n        return i", "code_tokens": "def load_image ( fname ) : with open ( fname , \"rb\" ) as f : i = Image . open ( fname ) #i.load() return i", "docstring_tokens": "read an image from file - PIL doesnt close nicely", "label": 1}, {"idx": "cosqa-train-5390", "doc": "python remove element set", "code": "def isolate_element(self, x):\n        \"\"\"Isolates `x` from its equivalence class.\"\"\"\n        members = list(self.members(x))\n        self.delete_set(x)\n        self.union(*(v for v in members if v != x))", "code_tokens": "def isolate_element ( self , x ) : members = list ( self . members ( x ) ) self . delete_set ( x ) self . union ( * ( v for v in members if v != x ) )", "docstring_tokens": "Isolates x from its equivalence class .", "label": 1}, {"idx": "cosqa-train-5391", "doc": "how to open and close file python", "code": "def file_read(filename):\n    \"\"\"Read a file and close it.  Returns the file source.\"\"\"\n    fobj = open(filename,'r');\n    source = fobj.read();\n    fobj.close()\n    return source", "code_tokens": "def file_read ( filename ) : fobj = open ( filename , 'r' ) source = fobj . read ( ) fobj . close ( ) return source", "docstring_tokens": "Read a file and close it . Returns the file source .", "label": 1}, {"idx": "cosqa-train-5392", "doc": "python remove file in s3", "code": "def remove_file_from_s3(awsclient, bucket, key):\n    \"\"\"Remove a file from an AWS S3 bucket.\n\n    :param awsclient:\n    :param bucket:\n    :param key:\n    :return:\n    \"\"\"\n    client_s3 = awsclient.get_client('s3')\n    response = client_s3.delete_object(Bucket=bucket, Key=key)", "code_tokens": "def remove_file_from_s3 ( awsclient , bucket , key ) : client_s3 = awsclient . get_client ( 's3' ) response = client_s3 . delete_object ( Bucket = bucket , Key = key )", "docstring_tokens": "Remove a file from an AWS S3 bucket .", "label": 0}, {"idx": "cosqa-train-5393", "doc": "how to order by in enum in python", "code": "def get_order(self, codes):\n        \"\"\"Return evidence codes in order shown in code2name.\"\"\"\n        return sorted(codes, key=lambda e: [self.ev2idx.get(e)])", "code_tokens": "def get_order ( self , codes ) : return sorted ( codes , key = lambda e : [ self . ev2idx . get ( e ) ] )", "docstring_tokens": "Return evidence codes in order shown in code2name .", "label": 0}, {"idx": "cosqa-train-5394", "doc": "python remove file or folder", "code": "def remover(file_path):\n    \"\"\"Delete a file or directory path only if it exists.\"\"\"\n    if os.path.isfile(file_path):\n        os.remove(file_path)\n        return True\n    elif os.path.isdir(file_path):\n        shutil.rmtree(file_path)\n        return True\n    else:\n        return False", "code_tokens": "def remover ( file_path ) : if os . path . isfile ( file_path ) : os . remove ( file_path ) return True elif os . path . isdir ( file_path ) : shutil . rmtree ( file_path ) return True else : return False", "docstring_tokens": "Delete a file or directory path only if it exists .", "label": 0}, {"idx": "cosqa-train-5395", "doc": "how to output json in python with indent", "code": "def to_json(data):\n    \"\"\"Return data as a JSON string.\"\"\"\n    return json.dumps(data, default=lambda x: x.__dict__, sort_keys=True, indent=4)", "code_tokens": "def to_json ( data ) : return json . dumps ( data , default = lambda x : x . __dict__ , sort_keys = True , indent = 4 )", "docstring_tokens": "Return data as a JSON string .", "label": 0}, {"idx": "cosqa-train-5396", "doc": "python remove focus after click outside of widget", "code": "def focusInEvent(self, event):\n        \"\"\"Reimplement Qt method to send focus change notification\"\"\"\n        self.focus_changed.emit()\n        return super(ControlWidget, self).focusInEvent(event)", "code_tokens": "def focusInEvent ( self , event ) : self . focus_changed . emit ( ) return super ( ControlWidget , self ) . focusInEvent ( event )", "docstring_tokens": "Reimplement Qt method to send focus change notification", "label": 0}, {"idx": "cosqa-train-5397", "doc": "how to output symbols in python like theta", "code": "def jsonify(symbol):\n    \"\"\" returns json format for symbol \"\"\"\n    try:\n        # all symbols have a toJson method, try it\n        return json.dumps(symbol.toJson(), indent='  ')\n    except AttributeError:\n        pass\n    return json.dumps(symbol, indent='  ')", "code_tokens": "def jsonify ( symbol ) : try : # all symbols have a toJson method, try it return json . dumps ( symbol . toJson ( ) , indent = '  ' ) except AttributeError : pass return json . dumps ( symbol , indent = '  ' )", "docstring_tokens": "returns json format for symbol", "label": 0}, {"idx": "cosqa-train-5398", "doc": "python remove from a dictonary", "code": "def _remove_dict_keys_with_value(dict_, val):\n  \"\"\"Removes `dict` keys which have have `self` as value.\"\"\"\n  return {k: v for k, v in dict_.items() if v is not val}", "code_tokens": "def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }", "docstring_tokens": "Removes dict keys which have have self as value .", "label": 1}, {"idx": "cosqa-train-5399", "doc": "how to paginate through a pdf in python", "code": "def resources(self):\n        \"\"\"Retrieve contents of each page of PDF\"\"\"\n        return [self.pdf.getPage(i) for i in range(self.pdf.getNumPages())]", "code_tokens": "def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "docstring_tokens": "Retrieve contents of each page of PDF", "label": 0}, {"idx": "cosqa-train-5400", "doc": "how to parse a mongodb document in python", "code": "def _obj_cursor_to_dictionary(self, cursor):\n        \"\"\"Handle conversion of pymongo cursor into a JSON object formatted for UI consumption\n\n        :param dict cursor: a mongo document that should be converted to primitive types for the client code\n        :returns: a primitive dictionary\n        :rtype: dict\n        \"\"\"\n        if not cursor:\n            return cursor\n\n        cursor = json.loads(json.dumps(cursor, cls=BSONEncoder))\n\n        if cursor.get(\"_id\"):\n            cursor[\"id\"] = cursor.get(\"_id\")\n            del cursor[\"_id\"]\n\n        return cursor", "code_tokens": "def _obj_cursor_to_dictionary ( self , cursor ) : if not cursor : return cursor cursor = json . loads ( json . dumps ( cursor , cls = BSONEncoder ) ) if cursor . get ( \"_id\" ) : cursor [ \"id\" ] = cursor . get ( \"_id\" ) del cursor [ \"_id\" ] return cursor", "docstring_tokens": "Handle conversion of pymongo cursor into a JSON object formatted for UI consumption", "label": 0}, {"idx": "cosqa-train-5401", "doc": "python remove non letters from string", "code": "def clean(self, text):\n        \"\"\"Remove all unwanted characters from text.\"\"\"\n        return ''.join([c for c in text if c in self.alphabet])", "code_tokens": "def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )", "docstring_tokens": "Remove all unwanted characters from text .", "label": 0}, {"idx": "cosqa-train-5402", "doc": "how to parse blank value as float python", "code": "def clean_float(v):\n    \"\"\"Remove commas from a float\"\"\"\n\n    if v is None or not str(v).strip():\n        return None\n\n    return float(str(v).replace(',', ''))", "code_tokens": "def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )", "docstring_tokens": "Remove commas from a float", "label": 0}, {"idx": "cosqa-train-5403", "doc": "python remove return new line in line", "code": "def get_line_ending(line):\n    \"\"\"Return line ending.\"\"\"\n    non_whitespace_index = len(line.rstrip()) - len(line)\n    if not non_whitespace_index:\n        return ''\n    else:\n        return line[non_whitespace_index:]", "code_tokens": "def get_line_ending ( line ) : non_whitespace_index = len ( line . rstrip ( ) ) - len ( line ) if not non_whitespace_index : return '' else : return line [ non_whitespace_index : ]", "docstring_tokens": "Return line ending .", "label": 0}, {"idx": "cosqa-train-5404", "doc": "how to pass user defined objects into json file with python", "code": "def _serialize_json(obj, fp):\n    \"\"\" Serialize ``obj`` as a JSON formatted stream to ``fp`` \"\"\"\n    json.dump(obj, fp, indent=4, default=serialize)", "code_tokens": "def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )", "docstring_tokens": "Serialize obj as a JSON formatted stream to fp", "label": 0}, {"idx": "cosqa-train-5405", "doc": "python remove small objects", "code": "def _removeTags(tags, objects):\n    \"\"\" Removes tags from objects \"\"\"\n    for t in tags:\n        for o in objects:\n            o.tags.remove(t)\n\n    return True", "code_tokens": "def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True", "docstring_tokens": "Removes tags from objects", "label": 0}, {"idx": "cosqa-train-5406", "doc": "how to pick a random element from set python", "code": "def random_choice(sequence):\n    \"\"\" Same as :meth:`random.choice`, but also supports :class:`set` type to be passed as sequence. \"\"\"\n    return random.choice(tuple(sequence) if isinstance(sequence, set) else sequence)", "code_tokens": "def random_choice ( sequence ) : return random . choice ( tuple ( sequence ) if isinstance ( sequence , set ) else sequence )", "docstring_tokens": "Same as : meth : random . choice but also supports : class : set type to be passed as sequence .", "label": 1}, {"idx": "cosqa-train-5407", "doc": "python remove substring at the begining", "code": "def _clip(sid, prefix):\n    \"\"\"Clips a prefix from the beginning of a string if it exists.\"\"\"\n    return sid[len(prefix):] if sid.startswith(prefix) else sid", "code_tokens": "def _clip ( sid , prefix ) : return sid [ len ( prefix ) : ] if sid . startswith ( prefix ) else sid", "docstring_tokens": "Clips a prefix from the beginning of a string if it exists .", "label": 0}, {"idx": "cosqa-train-5408", "doc": "how to play limit time music in python", "code": "def pause(self):\n        \"\"\"Pause the music\"\"\"\n        mixer.music.pause()\n        self.pause_time = self.get_time()\n        self.paused = True", "code_tokens": "def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True", "docstring_tokens": "Pause the music", "label": 0}, {"idx": "cosqa-train-5409", "doc": "python remove the parathenses in print", "code": "def format_screen(strng):\n    \"\"\"Format a string for screen printing.\n\n    This removes some latex-type format codes.\"\"\"\n    # Paragraph continue\n    par_re = re.compile(r'\\\\$',re.MULTILINE)\n    strng = par_re.sub('',strng)\n    return strng", "code_tokens": "def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng", "docstring_tokens": "Format a string for screen printing .", "label": 0}, {"idx": "cosqa-train-5410", "doc": "how to pop stack in python", "code": "def __pop_top_frame(self):\n        \"\"\"Pops the top frame off the frame stack.\"\"\"\n        popped = self.__stack.pop()\n        if self.__stack:\n            self.__stack[-1].process_subframe(popped)", "code_tokens": "def __pop_top_frame ( self ) : popped = self . __stack . pop ( ) if self . __stack : self . __stack [ - 1 ] . process_subframe ( popped )", "docstring_tokens": "Pops the top frame off the frame stack .", "label": 1}, {"idx": "cosqa-train-5411", "doc": "python remove timezone awareness", "code": "def make_aware(dt):\n    \"\"\"Appends tzinfo and assumes UTC, if datetime object has no tzinfo already.\"\"\"\n    return dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)", "code_tokens": "def make_aware ( dt ) : return dt if dt . tzinfo else dt . replace ( tzinfo = timezone . utc )", "docstring_tokens": "Appends tzinfo and assumes UTC if datetime object has no tzinfo already .", "label": 0}, {"idx": "cosqa-train-5412", "doc": "how to predict the accuracy score in python code", "code": "def cat_acc(y_true, y_pred):\n    \"\"\"Categorical accuracy\n    \"\"\"\n    return np.mean(y_true.argmax(axis=1) == y_pred.argmax(axis=1))", "code_tokens": "def cat_acc ( y_true , y_pred ) : return np . mean ( y_true . argmax ( axis = 1 ) == y_pred . argmax ( axis = 1 ) )", "docstring_tokens": "Categorical accuracy", "label": 0}, {"idx": "cosqa-train-5413", "doc": "python remove while iterating the queue", "code": "def remove(self, key):\n        \"\"\"remove the value found at key from the queue\"\"\"\n        item = self.item_finder.pop(key)\n        item[-1] = None\n        self.removed_count += 1", "code_tokens": "def remove ( self , key ) : item = self . item_finder . pop ( key ) item [ - 1 ] = None self . removed_count += 1", "docstring_tokens": "remove the value found at key from the queue", "label": 0}, {"idx": "cosqa-train-5414", "doc": "how to prevent python from closing", "code": "def close_stream(self):\n\t\t\"\"\" Closes the stream. Performs cleanup. \"\"\"\n\t\tself.keep_listening = False\n\t\tself.stream.stop()\n\t\tself.stream.close()", "code_tokens": "def close_stream ( self ) : self . keep_listening = False self . stream . stop ( ) self . stream . close ( )", "docstring_tokens": "Closes the stream . Performs cleanup .", "label": 0}, {"idx": "cosqa-train-5415", "doc": "python removing html markup from string", "code": "def strip_html(string, keep_tag_content=False):\n    \"\"\"\n    Remove html code contained into the given string.\n\n    :param string: String to manipulate.\n    :type string: str\n    :param keep_tag_content: True to preserve tag content, False to remove tag and its content too (default).\n    :type keep_tag_content: bool\n    :return: String with html removed.\n    :rtype: str\n    \"\"\"\n    r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE\n    return r.sub('', string)", "code_tokens": "def strip_html ( string , keep_tag_content = False ) : r = HTML_TAG_ONLY_RE if keep_tag_content else HTML_RE return r . sub ( '' , string )", "docstring_tokens": "Remove html code contained into the given string .", "label": 1}, {"idx": "cosqa-train-5416", "doc": "how to print a variable in logging error in python", "code": "def print_log(text, *colors):\n    \"\"\"Print a log message to standard error.\"\"\"\n    sys.stderr.write(sprint(\"{}: {}\".format(script_name, text), *colors) + \"\\n\")", "code_tokens": "def print_log ( text , * colors ) : sys . stderr . write ( sprint ( \"{}: {}\" . format ( script_name , text ) , * colors ) + \"\\n\" )", "docstring_tokens": "Print a log message to standard error .", "label": 1}, {"idx": "cosqa-train-5417", "doc": "how to print errror messages python", "code": "def fail_print(error):\n    \"\"\"Print an error in red text.\n    Parameters\n        error (HTTPError)\n            Error object to print.\n    \"\"\"\n    print(COLORS.fail, error.message, COLORS.end)\n    print(COLORS.fail, error.errors, COLORS.end)", "code_tokens": "def fail_print ( error ) : print ( COLORS . fail , error . message , COLORS . end ) print ( COLORS . fail , error . errors , COLORS . end )", "docstring_tokens": "Print an error in red text . Parameters error ( HTTPError ) Error object to print .", "label": 0}, {"idx": "cosqa-train-5418", "doc": "python replace month number", "code": "def replace_month_abbr_with_num(date_str, lang=DEFAULT_DATE_LANG):\n    \"\"\"Replace month strings occurrences with month number.\"\"\"\n    num, abbr = get_month_from_date_str(date_str, lang)\n    return re.sub(abbr, str(num), date_str, flags=re.IGNORECASE)", "code_tokens": "def replace_month_abbr_with_num ( date_str , lang = DEFAULT_DATE_LANG ) : num , abbr = get_month_from_date_str ( date_str , lang ) return re . sub ( abbr , str ( num ) , date_str , flags = re . IGNORECASE )", "docstring_tokens": "Replace month strings occurrences with month number .", "label": 1}, {"idx": "cosqa-train-5419", "doc": "how to print in an overloaded function python like add", "code": "def generic_add(a, b):\n    print\n    \"\"\"Simple function to add two numbers\"\"\"\n    logger.info('Called generic_add({}, {})'.format(a, b))\n    return a + b", "code_tokens": "def generic_add ( a , b ) : print logger . info ( 'Called generic_add({}, {})' . format ( a , b ) ) return a + b", "docstring_tokens": "Simple function to add two numbers", "label": 0}, {"idx": "cosqa-train-5420", "doc": "python replace n occurrences of characters", "code": "def subn_filter(s, find, replace, count=0):\n    \"\"\"A non-optimal implementation of a regex filter\"\"\"\n    return re.gsub(find, replace, count, s)", "code_tokens": "def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )", "docstring_tokens": "A non - optimal implementation of a regex filter", "label": 0}, {"idx": "cosqa-train-5421", "doc": "how to print python output in csv file", "code": "def csvpretty(csvfile: csvfile=sys.stdin):\n    \"\"\" Pretty print a CSV file. \"\"\"\n    shellish.tabulate(csv.reader(csvfile))", "code_tokens": "def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )", "docstring_tokens": "Pretty print a CSV file .", "label": 0}, {"idx": "cosqa-train-5422", "doc": "python replace non letters", "code": "def dashrepl(value):\n    \"\"\"\n    Replace any non-word characters with a dash.\n    \"\"\"\n    patt = re.compile(r'\\W', re.UNICODE)\n    return re.sub(patt, '-', value)", "code_tokens": "def dashrepl ( value ) : patt = re . compile ( r'\\W' , re . UNICODE ) return re . sub ( patt , '-' , value )", "docstring_tokens": "Replace any non - word characters with a dash .", "label": 1}, {"idx": "cosqa-train-5423", "doc": "how to print the contents of a python url request", "code": "def pretty_print_post(req):\n    \"\"\"Helper to print a \"prepared\" query. Useful to debug a POST query.\n\n    However pay attention at the formatting used in\n    this function because it is programmed to be pretty\n    printed and may differ from the actual request.\n    \"\"\"\n    print(('{}\\n{}\\n{}\\n\\n{}'.format(\n        '-----------START-----------',\n        req.method + ' ' + req.url,\n        '\\n'.join('{}: {}'.format(k, v) for k, v in list(req.headers.items())),\n        req.body,\n    )))", "code_tokens": "def pretty_print_post ( req ) : print ( ( '{}\\n{}\\n{}\\n\\n{}' . format ( '-----------START-----------' , req . method + ' ' + req . url , '\\n' . join ( '{}: {}' . format ( k , v ) for k , v in list ( req . headers . items ( ) ) ) , req . body , ) ) )", "docstring_tokens": "Helper to print a prepared query . Useful to debug a POST query .", "label": 0}, {"idx": "cosqa-train-5424", "doc": "python replace space with underscore in string", "code": "def camelcase_underscore(name):\n    \"\"\" Convert camelcase names to underscore \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def camelcase_underscore ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert camelcase names to underscore", "label": 0}, {"idx": "cosqa-train-5425", "doc": "how to print the object type in python", "code": "def object_type_repr(obj):\n    \"\"\"Returns the name of the object's type.  For some recognized\n    singletons the name of the object is returned instead. (For\n    example for `None` and `Ellipsis`).\n    \"\"\"\n    if obj is None:\n        return 'None'\n    elif obj is Ellipsis:\n        return 'Ellipsis'\n    if obj.__class__.__module__ == '__builtin__':\n        name = obj.__class__.__name__\n    else:\n        name = obj.__class__.__module__ + '.' + obj.__class__.__name__\n    return '%s object' % name", "code_tokens": "def object_type_repr ( obj ) : if obj is None : return 'None' elif obj is Ellipsis : return 'Ellipsis' if obj . __class__ . __module__ == '__builtin__' : name = obj . __class__ . __name__ else : name = obj . __class__ . __module__ + '.' + obj . __class__ . __name__ return '%s object' % name", "docstring_tokens": "Returns the name of the object s type . For some recognized singletons the name of the object is returned instead . ( For example for None and Ellipsis ) .", "label": 1}, {"idx": "cosqa-train-5426", "doc": "python request get querystring", "code": "def parse_querystring(self, req, name, field):\n        \"\"\"Pull a querystring value from the request.\"\"\"\n        return core.get_value(req.args, name, field)", "code_tokens": "def parse_querystring ( self , req , name , field ) : return core . get_value ( req . args , name , field )", "docstring_tokens": "Pull a querystring value from the request .", "label": 0}, {"idx": "cosqa-train-5427", "doc": "how to print things out in a table python", "code": "def get_table(ports):\n    \"\"\"\n    This function returns a pretty table used to display the port results.\n\n    :param ports: list of found ports\n    :return: the table to display\n    \"\"\"\n    table = PrettyTable([\"Name\", \"Port\", \"Protocol\", \"Description\"])\n    table.align[\"Name\"] = \"l\"\n    table.align[\"Description\"] = \"l\"\n    table.padding_width = 1\n\n    for port in ports:\n        table.add_row(port)\n\n    return table", "code_tokens": "def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "docstring_tokens": "This function returns a pretty table used to display the port results .", "label": 0}, {"idx": "cosqa-train-5428", "doc": "python request header autorization", "code": "def __call__(self, r):\n        \"\"\"Update the request headers.\"\"\"\n        r.headers['Authorization'] = 'JWT {jwt}'.format(jwt=self.token)\n        return r", "code_tokens": "def __call__ ( self , r ) : r . headers [ 'Authorization' ] = 'JWT {jwt}' . format ( jwt = self . token ) return r", "docstring_tokens": "Update the request headers .", "label": 1}, {"idx": "cosqa-train-5429", "doc": "how to print type of string in python", "code": "def getTypeStr(_type):\n  r\"\"\"Gets the string representation of the given type.\n  \"\"\"\n  if isinstance(_type, CustomType):\n    return str(_type)\n\n  if hasattr(_type, '__name__'):\n    return _type.__name__\n\n  return ''", "code_tokens": "def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''", "docstring_tokens": "r Gets the string representation of the given type .", "label": 0}, {"idx": "cosqa-train-5430", "doc": "python requests head request", "code": "def head(self, path, query=None, data=None, redirects=True):\n        \"\"\"\n        HEAD request wrapper for :func:`request()`\n        \"\"\"\n        return self.request('HEAD', path, query, None, redirects)", "code_tokens": "def head ( self , path , query = None , data = None , redirects = True ) : return self . request ( 'HEAD' , path , query , None , redirects )", "docstring_tokens": "HEAD request wrapper for : func : request ()", "label": 0}, {"idx": "cosqa-train-5431", "doc": "how to pull the max value from a column on python", "code": "def get_max(qs, field):\n    \"\"\"\n    get max for queryset.\n\n    qs: queryset\n    field: The field name to max.\n    \"\"\"\n    max_field = '%s__max' % field\n    num = qs.aggregate(Max(field))[max_field]\n    return num if num else 0", "code_tokens": "def get_max ( qs , field ) : max_field = '%s__max' % field num = qs . aggregate ( Max ( field ) ) [ max_field ] return num if num else 0", "docstring_tokens": "get max for queryset .", "label": 0}, {"idx": "cosqa-train-5432", "doc": "python requests session pool", "code": "def session(self):\n        \"\"\"A context manager for this client's session.\n\n        This function closes the current session when this client goes out of\n        scope.\n        \"\"\"\n        self._session = requests.session()\n        yield\n        self._session.close()\n        self._session = None", "code_tokens": "def session ( self ) : self . _session = requests . session ( ) yield self . _session . close ( ) self . _session = None", "docstring_tokens": "A context manager for this client s session .", "label": 0}, {"idx": "cosqa-train-5433", "doc": "how to put an exponential function in alegion in python", "code": "def Exponential(x, a, tau, y0):\n    \"\"\"Exponential function\n\n    Inputs:\n    -------\n        ``x``: independent variable\n        ``a``: scaling factor\n        ``tau``: time constant\n        ``y0``: additive constant\n\n    Formula:\n    --------\n        ``a*exp(x/tau)+y0``\n    \"\"\"\n    return np.exp(x / tau) * a + y0", "code_tokens": "def Exponential ( x , a , tau , y0 ) : return np . exp ( x / tau ) * a + y0", "docstring_tokens": "Exponential function", "label": 0}, {"idx": "cosqa-train-5434", "doc": "python requests set header for post", "code": "def send_post(self, url, data, remove_header=None):\n        \"\"\" Send a POST request\n        \"\"\"\n        return self.send_request(method=\"post\", url=url, data=data, remove_header=remove_header)", "code_tokens": "def send_post ( self , url , data , remove_header = None ) : return self . send_request ( method = \"post\" , url = url , data = data , remove_header = remove_header )", "docstring_tokens": "Send a POST request", "label": 0}, {"idx": "cosqa-train-5435", "doc": "how to put in bins for histogram on python", "code": "def inverseHistogram(hist, bin_range):\n    \"\"\"sample data from given histogram and min, max values within range\n\n    Returns:\n        np.array: data that would create the same histogram as given\n    \"\"\"\n    data = hist.astype(float) / np.min(hist[np.nonzero(hist)])\n    new_data = np.empty(shape=np.sum(data, dtype=int))\n    i = 0\n    xvals = np.linspace(bin_range[0], bin_range[1], len(data))\n    for d, x in zip(data, xvals):\n        new_data[i:i + d] = x\n        i += int(d)\n    return new_data", "code_tokens": "def inverseHistogram ( hist , bin_range ) : data = hist . astype ( float ) / np . min ( hist [ np . nonzero ( hist ) ] ) new_data = np . empty ( shape = np . sum ( data , dtype = int ) ) i = 0 xvals = np . linspace ( bin_range [ 0 ] , bin_range [ 1 ] , len ( data ) ) for d , x in zip ( data , xvals ) : new_data [ i : i + d ] = x i += int ( d ) return new_data", "docstring_tokens": "sample data from given histogram and min max values within range", "label": 0}, {"idx": "cosqa-train-5436", "doc": "python requests set no proxies", "code": "async def set_http_proxy(cls, url: typing.Optional[str]):\n        \"\"\"See `get_http_proxy`.\"\"\"\n        await cls.set_config(\"http_proxy\", \"\" if url is None else url)", "code_tokens": "async def set_http_proxy ( cls , url : typing . Optional [ str ] ) : await cls . set_config ( \"http_proxy\" , \"\" if url is None else url )", "docstring_tokens": "See get_http_proxy .", "label": 0}, {"idx": "cosqa-train-5437", "doc": "how to put multiple strings in one print command python", "code": "def print_out(self, *lst):\n      \"\"\" Print list of strings to the predefined stdout. \"\"\"\n      self.print2file(self.stdout, True, True, *lst)", "code_tokens": "def print_out ( self , * lst ) : self . print2file ( self . stdout , True , True , * lst )", "docstring_tokens": "Print list of strings to the predefined stdout .", "label": 0}, {"idx": "cosqa-train-5438", "doc": "python requestscookiejar retrieve cookie", "code": "def parse_cookies(self, req, name, field):\n        \"\"\"Pull the value from the cookiejar.\"\"\"\n        return core.get_value(req.COOKIES, name, field)", "code_tokens": "def parse_cookies ( self , req , name , field ) : return core . get_value ( req . COOKIES , name , field )", "docstring_tokens": "Pull the value from the cookiejar .", "label": 0}, {"idx": "cosqa-train-5439", "doc": "how to query with session in sqlalchemy python", "code": "def get_db_version(session):\n    \"\"\"\n    :param session: actually it is a sqlalchemy session\n    :return: version number\n    \"\"\"\n    value = session.query(ProgramInformation.value).filter(ProgramInformation.name == \"db_version\").scalar()\n    return int(value)", "code_tokens": "def get_db_version ( session ) : value = session . query ( ProgramInformation . value ) . filter ( ProgramInformation . name == \"db_version\" ) . scalar ( ) return int ( value )", "docstring_tokens": ": param session : actually it is a sqlalchemy session : return : version number", "label": 0}, {"idx": "cosqa-train-5440", "doc": "python resize image and maintain aspect ratio", "code": "def resize_image_to_fit_width(image, dest_w):\n    \"\"\"\n    Resize and image to fit the passed in width, keeping the aspect ratio the same\n\n    :param image: PIL.Image\n    :param dest_w: The desired width\n    \"\"\"\n    scale_factor = dest_w / image.size[0]\n    dest_h = image.size[1] * scale_factor\n    \n    scaled_image = image.resize((int(dest_w), int(dest_h)), PIL.Image.ANTIALIAS)\n\n    return scaled_image", "code_tokens": "def resize_image_to_fit_width ( image , dest_w ) : scale_factor = dest_w / image . size [ 0 ] dest_h = image . size [ 1 ] * scale_factor scaled_image = image . resize ( ( int ( dest_w ) , int ( dest_h ) ) , PIL . Image . ANTIALIAS ) return scaled_image", "docstring_tokens": "Resize and image to fit the passed in width keeping the aspect ratio the same", "label": 0}, {"idx": "cosqa-train-5441", "doc": "how to randomize data in a list python", "code": "def get_randomized_guid_sample(self, item_count):\n        \"\"\" Fetch a subset of randomzied GUIDs from the whitelist \"\"\"\n        dataset = self.get_whitelist()\n        random.shuffle(dataset)\n        return dataset[:item_count]", "code_tokens": "def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]", "docstring_tokens": "Fetch a subset of randomzied GUIDs from the whitelist", "label": 0}, {"idx": "cosqa-train-5442", "doc": "python resolve dynamic attribute at runtime", "code": "def __getattr__(self, name):\n        \"\"\" For attributes not found in self, redirect\n        to the properties dictionary \"\"\"\n\n        try:\n            return self.__dict__[name]\n        except KeyError:\n            if hasattr(self._properties,name):\n                return getattr(self._properties, name)", "code_tokens": "def __getattr__ ( self , name ) : try : return self . __dict__ [ name ] except KeyError : if hasattr ( self . _properties , name ) : return getattr ( self . _properties , name )", "docstring_tokens": "For attributes not found in self redirect to the properties dictionary", "label": 0}, {"idx": "cosqa-train-5443", "doc": "how to read file in python and collect words from lines of words", "code": "def extract_words(lines):\n    \"\"\"\n    Extract from the given iterable of lines the list of words.\n\n    :param lines: an iterable of lines;\n    :return: a generator of words of lines.\n    \"\"\"\n    for line in lines:\n        for word in re.findall(r\"\\w+\", line):\n            yield word", "code_tokens": "def extract_words ( lines ) : for line in lines : for word in re . findall ( r\"\\w+\" , line ) : yield word", "docstring_tokens": "Extract from the given iterable of lines the list of words .", "label": 0}, {"idx": "cosqa-train-5444", "doc": "python rest api performance", "code": "def stats(self):\n        \"\"\"\n        Return a new raw REST interface to stats resources\n\n        :rtype: :py:class:`ns1.rest.stats.Stats`\n        \"\"\"\n        import ns1.rest.stats\n        return ns1.rest.stats.Stats(self.config)", "code_tokens": "def stats ( self ) : import ns1 . rest . stats return ns1 . rest . stats . Stats ( self . config )", "docstring_tokens": "Return a new raw REST interface to stats resources", "label": 0}, {"idx": "cosqa-train-5445", "doc": "how to read into a buffered reader python", "code": "def get_iter_string_reader(stdin):\n    \"\"\" return an iterator that returns a chunk of a string every time it is\n    called.  notice that even though bufsize_type might be line buffered, we're\n    not doing any line buffering here.  that's because our StreamBufferer\n    handles all buffering.  we just need to return a reasonable-sized chunk. \"\"\"\n    bufsize = 1024\n    iter_str = (stdin[i:i + bufsize] for i in range(0, len(stdin), bufsize))\n    return get_iter_chunk_reader(iter_str)", "code_tokens": "def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )", "docstring_tokens": "return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk .", "label": 0}, {"idx": "cosqa-train-5446", "doc": "python restoring default settings", "code": "def restore_default_settings():\n    \"\"\" Restore settings to default values. \n    \"\"\"\n    global __DEFAULTS\n    __DEFAULTS.CACHE_DIR = defaults.CACHE_DIR\n    __DEFAULTS.SET_SEED = defaults.SET_SEED\n    __DEFAULTS.SEED = defaults.SEED\n    logging.info('Settings reverted to their default values.')", "code_tokens": "def restore_default_settings ( ) : global __DEFAULTS __DEFAULTS . CACHE_DIR = defaults . CACHE_DIR __DEFAULTS . SET_SEED = defaults . SET_SEED __DEFAULTS . SEED = defaults . SEED logging . info ( 'Settings reverted to their default values.' )", "docstring_tokens": "Restore settings to default values .", "label": 0}, {"idx": "cosqa-train-5447", "doc": "how to read json from url python", "code": "def get_jsonparsed_data(url):\n    \"\"\"Receive the content of ``url``, parse it as JSON and return the\n       object.\n    \"\"\"\n    response = urlopen(url)\n    data = response.read().decode('utf-8')\n    return json.loads(data)", "code_tokens": "def get_jsonparsed_data ( url ) : response = urlopen ( url ) data = response . read ( ) . decode ( 'utf-8' ) return json . loads ( data )", "docstring_tokens": "Receive the content of url parse it as JSON and return the object .", "label": 0}, {"idx": "cosqa-train-5448", "doc": "python restrict memory usage cpu", "code": "def set_mem_per_proc(self, mem_mb):\n        \"\"\"Set the memory per process in megabytes\"\"\"\n        super().set_mem_per_proc(mem_mb)\n        self.qparams[\"mem_per_cpu\"] = self.mem_per_proc", "code_tokens": "def set_mem_per_proc ( self , mem_mb ) : super ( ) . set_mem_per_proc ( mem_mb ) self . qparams [ \"mem_per_cpu\" ] = self . mem_per_proc", "docstring_tokens": "Set the memory per process in megabytes", "label": 0}, {"idx": "cosqa-train-5449", "doc": "how to redirect to '/' python flask", "code": "def logout():\n    \"\"\" Log out the active user\n    \"\"\"\n    flogin.logout_user()\n    next = flask.request.args.get('next')\n    return flask.redirect(next or flask.url_for(\"user\"))", "code_tokens": "def logout ( ) : flogin . logout_user ( ) next = flask . request . args . get ( 'next' ) return flask . redirect ( next or flask . url_for ( \"user\" ) )", "docstring_tokens": "Log out the active user", "label": 0}, {"idx": "cosqa-train-5450", "doc": "python restrict values in a dict", "code": "def dict_pick(dictionary, allowed_keys):\n    \"\"\"\n    Return a dictionary only with keys found in `allowed_keys`\n    \"\"\"\n    return {key: value for key, value in viewitems(dictionary) if key in allowed_keys}", "code_tokens": "def dict_pick ( dictionary , allowed_keys ) : return { key : value for key , value in viewitems ( dictionary ) if key in allowed_keys }", "docstring_tokens": "Return a dictionary only with keys found in allowed_keys", "label": 0}, {"idx": "cosqa-train-5451", "doc": "how to reduce to lower matrix in python", "code": "def normalize_matrix(matrix):\n  \"\"\"Fold all values of the matrix into [0, 1].\"\"\"\n  abs_matrix = np.abs(matrix.copy())\n  return abs_matrix / abs_matrix.max()", "code_tokens": "def normalize_matrix ( matrix ) : abs_matrix = np . abs ( matrix . copy ( ) ) return abs_matrix / abs_matrix . max ( )", "docstring_tokens": "Fold all values of the matrix into [ 0 1 ] .", "label": 0}, {"idx": "cosqa-train-5452", "doc": "python retry on element would receive the click", "code": "def click(self):\n        \"\"\"Click the element\n\n        :returns: page element instance\n        \"\"\"\n        try:\n            self.wait_until_clickable().web_element.click()\n        except StaleElementReferenceException:\n            # Retry if element has changed\n            self.web_element.click()\n        return self", "code_tokens": "def click ( self ) : try : self . wait_until_clickable ( ) . web_element . click ( ) except StaleElementReferenceException : # Retry if element has changed self . web_element . click ( ) return self", "docstring_tokens": "Click the element", "label": 0}, {"idx": "cosqa-train-5453", "doc": "how to reformat column name in python", "code": "def standard_db_name(file_column_name):\n    \"\"\"return a standard name by following rules:\n    1. find all regular expression partners ((IDs)|(ID)|([A-Z][a-z]+)|([A-Z]{2,}))\n    2. lower very part and join again with _\n    This method is only used if values in table[model]['columns'] are str\n\n    :param str file_column_name: name of column in file\n    :return: standard name\n    :rtype: str\n    \"\"\"\n    found = id_re.findall(file_column_name)\n\n    if not found:\n        return file_column_name\n\n    return '_'.join(x[0].lower() for x in found)", "code_tokens": "def standard_db_name ( file_column_name ) : found = id_re . findall ( file_column_name ) if not found : return file_column_name return '_' . join ( x [ 0 ] . lower ( ) for x in found )", "docstring_tokens": "return a standard name by following rules : 1 . find all regular expression partners (( IDs ) | ( ID ) | ( [ A - Z ] [ a - z ] + ) | ( [ A - Z ] { 2 } )) 2 . lower very part and join again with _ This method is only used if values in table [ model ] [ columns ] are str", "label": 0}, {"idx": "cosqa-train-5454", "doc": "python return all indexes of a value", "code": "def index(m, val):\n    \"\"\"\n    Return the indices of all the ``val`` in ``m``\n    \"\"\"\n    mm = np.array(m)\n    idx_tuple = np.where(mm == val)\n    idx = idx_tuple[0].tolist()\n\n    return idx", "code_tokens": "def index ( m , val ) : mm = np . array ( m ) idx_tuple = np . where ( mm == val ) idx = idx_tuple [ 0 ] . tolist ( ) return idx", "docstring_tokens": "Return the indices of all the val in m", "label": 0}, {"idx": "cosqa-train-5455", "doc": "how to remove a dom element from an xml python", "code": "def cleanup_nodes(doc):\n    \"\"\"\n    Remove text nodes containing only whitespace\n    \"\"\"\n    for node in doc.documentElement.childNodes:\n        if node.nodeType == Node.TEXT_NODE and node.nodeValue.isspace():\n            doc.documentElement.removeChild(node)\n    return doc", "code_tokens": "def cleanup_nodes ( doc ) : for node in doc . documentElement . childNodes : if node . nodeType == Node . TEXT_NODE and node . nodeValue . isspace ( ) : doc . documentElement . removeChild ( node ) return doc", "docstring_tokens": "Remove text nodes containing only whitespace", "label": 0}, {"idx": "cosqa-train-5456", "doc": "python return dictionary with index and values", "code": "def edge_index(self):\n        \"\"\"A map to look up the index of a edge\"\"\"\n        return dict((edge, index) for index, edge in enumerate(self.edges))", "code_tokens": "def edge_index ( self ) : return dict ( ( edge , index ) for index , edge in enumerate ( self . edges ) )", "docstring_tokens": "A map to look up the index of a edge", "label": 1}, {"idx": "cosqa-train-5457", "doc": "how to remove a list in a list in python", "code": "def rm_empty_indices(*args):\n    \"\"\"\n    Remove unwanted list indices. First argument is the list\n    of indices to remove. Other elements are the lists\n    to trim.\n    \"\"\"\n    rm_inds = args[0]\n\n    if not rm_inds:\n        return args[1:]\n\n    keep_inds = [i for i in range(len(args[1])) if i not in rm_inds]\n\n    return [[a[i] for i in keep_inds] for a in args[1:]]", "code_tokens": "def rm_empty_indices ( * args ) : rm_inds = args [ 0 ] if not rm_inds : return args [ 1 : ] keep_inds = [ i for i in range ( len ( args [ 1 ] ) ) if i not in rm_inds ] return [ [ a [ i ] for i in keep_inds ] for a in args [ 1 : ] ]", "docstring_tokens": "Remove unwanted list indices . First argument is the list of indices to remove . Other elements are the lists to trim .", "label": 0}, {"idx": "cosqa-train-5458", "doc": "python return dynamic number of objects", "code": "def get_size(objects):\n    \"\"\"Compute the total size of all elements in objects.\"\"\"\n    res = 0\n    for o in objects:\n        try:\n            res += _getsizeof(o)\n        except AttributeError:\n            print(\"IGNORING: type=%s; o=%s\" % (str(type(o)), str(o)))\n    return res", "code_tokens": "def get_size ( objects ) : res = 0 for o in objects : try : res += _getsizeof ( o ) except AttributeError : print ( \"IGNORING: type=%s; o=%s\" % ( str ( type ( o ) ) , str ( o ) ) ) return res", "docstring_tokens": "Compute the total size of all elements in objects .", "label": 0}, {"idx": "cosqa-train-5459", "doc": "how to remove all keys in dictionary python", "code": "def _delete_keys(dct, keys):\n    \"\"\"Returns a copy of dct without `keys` keys\n    \"\"\"\n    c = deepcopy(dct)\n    assert isinstance(keys, list)\n    for k in keys:\n        c.pop(k)\n    return c", "code_tokens": "def _delete_keys ( dct , keys ) : c = deepcopy ( dct ) assert isinstance ( keys , list ) for k in keys : c . pop ( k ) return c", "docstring_tokens": "Returns a copy of dct without keys keys", "label": 0}, {"idx": "cosqa-train-5460", "doc": "python return index of list within list", "code": "def is_in(self, search_list, pair):\n        \"\"\"\n        If pair is in search_list, return the index. Otherwise return -1\n        \"\"\"\n        index = -1\n        for nr, i in enumerate(search_list):\n            if(np.all(i == pair)):\n                return nr\n        return index", "code_tokens": "def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index", "docstring_tokens": "If pair is in search_list return the index . Otherwise return - 1", "label": 0}, {"idx": "cosqa-train-5461", "doc": "how to remove object from a list python", "code": "def remove_instance(self, item):\n        \"\"\"Remove `instance` from model\"\"\"\n        self.instances.remove(item)\n        self.remove_item(item)", "code_tokens": "def remove_instance ( self , item ) : self . instances . remove ( item ) self . remove_item ( item )", "docstring_tokens": "Remove instance from model", "label": 1}, {"idx": "cosqa-train-5462", "doc": "python return response ajax", "code": "def success_response(**data):\n    \"\"\"Return a generic success response.\"\"\"\n    data_out = {}\n    data_out[\"status\"] = \"success\"\n    data_out.update(data)\n    js = dumps(data_out, default=date_handler)\n    return Response(js, status=200, mimetype=\"application/json\")", "code_tokens": "def success_response ( * * data ) : data_out = { } data_out [ \"status\" ] = \"success\" data_out . update ( data ) js = dumps ( data_out , default = date_handler ) return Response ( js , status = 200 , mimetype = \"application/json\" )", "docstring_tokens": "Return a generic success response .", "label": 0}, {"idx": "cosqa-train-5463", "doc": "how to remove punctuation in a text using python", "code": "def remove_punctuation(text, exceptions=[]):\n    \"\"\"\n    Return a string with punctuation removed.\n\n    Parameters:\n        text (str): The text to remove punctuation from.\n        exceptions (list): List of symbols to keep in the given text.\n\n    Return:\n        str: The input text without the punctuation.\n    \"\"\"\n\n    all_but = [\n        r'\\w',\n        r'\\s'\n    ]\n\n    all_but.extend(exceptions)\n\n    pattern = '[^{}]'.format(''.join(all_but))\n\n    return re.sub(pattern, '', text)", "code_tokens": "def remove_punctuation ( text , exceptions = [ ] ) : all_but = [ r'\\w' , r'\\s' ] all_but . extend ( exceptions ) pattern = '[^{}]' . format ( '' . join ( all_but ) ) return re . sub ( pattern , '' , text )", "docstring_tokens": "Return a string with punctuation removed .", "label": 0}, {"idx": "cosqa-train-5464", "doc": "python return the two closest items in an array", "code": "def closest(xarr, val):\n    \"\"\" Return the index of the closest in xarr to value val \"\"\"\n    idx_closest = np.argmin(np.abs(np.array(xarr) - val))\n    return idx_closest", "code_tokens": "def closest ( xarr , val ) : idx_closest = np . argmin ( np . abs ( np . array ( xarr ) - val ) ) return idx_closest", "docstring_tokens": "Return the index of the closest in xarr to value val", "label": 0}, {"idx": "cosqa-train-5465", "doc": "how to remove punctuation in python nltk", "code": "def wordify(text):\n    \"\"\"Generate a list of words given text, removing punctuation.\n\n    Parameters\n    ----------\n    text : unicode\n        A piece of english text.\n\n    Returns\n    -------\n    words : list\n        List of words.\n    \"\"\"\n    stopset = set(nltk.corpus.stopwords.words('english'))\n    tokens = nltk.WordPunctTokenizer().tokenize(text)\n    return [w for w in tokens if w not in stopset]", "code_tokens": "def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]", "docstring_tokens": "Generate a list of words given text removing punctuation .", "label": 0}, {"idx": "cosqa-train-5466", "doc": "python returning a tempfile without closing it", "code": "def copy_to_temp(object):\n    \"\"\"\n    Copy file-like object to temp file and return\n    path.\n    \"\"\"\n    temp_file = NamedTemporaryFile(delete=False)\n    _copy_and_close(object, temp_file)\n    return temp_file.name", "code_tokens": "def copy_to_temp ( object ) : temp_file = NamedTemporaryFile ( delete = False ) _copy_and_close ( object , temp_file ) return temp_file . name", "docstring_tokens": "Copy file - like object to temp file and return path .", "label": 0}, {"idx": "cosqa-train-5467", "doc": "how to remove the spaces from a string python", "code": "def sanitize_word(s):\n    \"\"\"Remove non-alphanumerical characters from metric word.\n    And trim excessive underscores.\n    \"\"\"\n    s = re.sub('[^\\w-]+', '_', s)\n    s = re.sub('__+', '_', s)\n    return s.strip('_')", "code_tokens": "def sanitize_word ( s ) : s = re . sub ( '[^\\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )", "docstring_tokens": "Remove non - alphanumerical characters from metric word . And trim excessive underscores .", "label": 0}, {"idx": "cosqa-train-5468", "doc": "python returns the url in the response issue", "code": "def home():\n    \"\"\"Temporary helper function to link to the API routes\"\"\"\n    return dict(links=dict(api='{}{}'.format(request.url, PREFIX[1:]))), \\\n        HTTPStatus.OK", "code_tokens": "def home ( ) : return dict ( links = dict ( api = '{}{}' . format ( request . url , PREFIX [ 1 : ] ) ) ) , HTTPStatus . OK", "docstring_tokens": "Temporary helper function to link to the API routes", "label": 0}, {"idx": "cosqa-train-5469", "doc": "how to remove values from objects python", "code": "def _removeTags(tags, objects):\n    \"\"\" Removes tags from objects \"\"\"\n    for t in tags:\n        for o in objects:\n            o.tags.remove(t)\n\n    return True", "code_tokens": "def _removeTags ( tags , objects ) : for t in tags : for o in objects : o . tags . remove ( t ) return True", "docstring_tokens": "Removes tags from objects", "label": 1}, {"idx": "cosqa-train-5470", "doc": "python reverse call django url from ajax sample", "code": "def get_short_url(self):\n        \"\"\" Returns short version of topic url (without page number) \"\"\"\n        return reverse('post_short_url', args=(self.forum.slug, self.slug, self.id))", "code_tokens": "def get_short_url ( self ) : return reverse ( 'post_short_url' , args = ( self . forum . slug , self . slug , self . id ) )", "docstring_tokens": "Returns short version of topic url ( without page number )", "label": 0}, {"idx": "cosqa-train-5471", "doc": "how to remove whitespace in python string", "code": "def text_cleanup(data, key, last_type):\n    \"\"\" I strip extra whitespace off multi-line strings if they are ready to be stripped!\"\"\"\n    if key in data and last_type == STRING_TYPE:\n        data[key] = data[key].strip()\n    return data", "code_tokens": "def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data", "docstring_tokens": "I strip extra whitespace off multi - line strings if they are ready to be stripped!", "label": 1}, {"idx": "cosqa-train-5472", "doc": "python rotate image angle", "code": "def rotateImage(img, angle):\n    \"\"\"\n\n    querries scipy.ndimage.rotate routine\n    :param img: image to be rotated\n    :param angle: angle to be rotated (radian)\n    :return: rotated image\n    \"\"\"\n    imgR = scipy.ndimage.rotate(img, angle, reshape=False)\n    return imgR", "code_tokens": "def rotateImage ( img , angle ) : imgR = scipy . ndimage . rotate ( img , angle , reshape = False ) return imgR", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-5473", "doc": "how to replace given string in python", "code": "def myreplace(astr, thefind, thereplace):\n    \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"\n    alist = astr.split(thefind)\n    new_s = alist.split(thereplace)\n    return new_s", "code_tokens": "def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "docstring_tokens": "in string astr replace all occurences of thefind with thereplace", "label": 0}, {"idx": "cosqa-train-5474", "doc": "python rotation matrix 3d", "code": "def R_rot_3d(th):\n    \"\"\"Return a 3-dimensional rotation matrix.\n\n    Parameters\n    ----------\n    th: array, shape (n, 3)\n        Angles about which to rotate along each axis.\n\n    Returns\n    -------\n    R: array, shape (n, 3, 3)\n    \"\"\"\n    sx, sy, sz = np.sin(th).T\n    cx, cy, cz = np.cos(th).T\n    R = np.empty((len(th), 3, 3), dtype=np.float)\n\n    R[:, 0, 0] = cy * cz\n    R[:, 0, 1] = -cy * sz\n    R[:, 0, 2] = sy\n\n    R[:, 1, 0] = sx * sy * cz + cx * sz\n    R[:, 1, 1] = -sx * sy * sz + cx * cz\n    R[:, 1, 2] = -sx * cy\n\n    R[:, 2, 0] = -cx * sy * cz + sx * sz\n    R[:, 2, 1] = cx * sy * sz + sx * cz\n    R[:, 2, 2] = cx * cy\n    return R", "code_tokens": "def R_rot_3d ( th ) : sx , sy , sz = np . sin ( th ) . T cx , cy , cz = np . cos ( th ) . T R = np . empty ( ( len ( th ) , 3 , 3 ) , dtype = np . float ) R [ : , 0 , 0 ] = cy * cz R [ : , 0 , 1 ] = - cy * sz R [ : , 0 , 2 ] = sy R [ : , 1 , 0 ] = sx * sy * cz + cx * sz R [ : , 1 , 1 ] = - sx * sy * sz + cx * cz R [ : , 1 , 2 ] = - sx * cy R [ : , 2 , 0 ] = - cx * sy * cz + sx * sz R [ : , 2 , 1 ] = cx * sy * sz + sx * cz R [ : , 2 , 2 ] = cx * cy return R", "docstring_tokens": "Return a 3 - dimensional rotation matrix .", "label": 0}, {"idx": "cosqa-train-5475", "doc": "how to replace multiple strings in one input python", "code": "def replace(s, replace):\n    \"\"\"Replace multiple values in a string\"\"\"\n    for r in replace:\n        s = s.replace(*r)\n    return s", "code_tokens": "def replace ( s , replace ) : for r in replace : s = s . replace ( * r ) return s", "docstring_tokens": "Replace multiple values in a string", "label": 0}, {"idx": "cosqa-train-5476", "doc": "python round 4 significant figures", "code": "def round_figures(x, n):\n    \"\"\"Returns x rounded to n significant figures.\"\"\"\n    return round(x, int(n - math.ceil(math.log10(abs(x)))))", "code_tokens": "def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )", "docstring_tokens": "Returns x rounded to n significant figures .", "label": 0}, {"idx": "cosqa-train-5477", "doc": "how to replace space with underscore for all the columnname in python", "code": "def convert(name):\n    \"\"\"Convert CamelCase to underscore\n\n    Parameters\n    ----------\n    name : str\n        Camelcase string\n\n    Returns\n    -------\n    name : str\n        Converted name\n    \"\"\" \n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def convert ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert CamelCase to underscore", "label": 0}, {"idx": "cosqa-train-5478", "doc": "python round down numpy", "code": "def round_array(array_in):\n    \"\"\"\n    arr_out = round_array(array_in)\n\n    Rounds an array and recasts it to int. Also works on scalars.\n    \"\"\"\n    if isinstance(array_in, ndarray):\n        return np.round(array_in).astype(int)\n    else:\n        return int(np.round(array_in))", "code_tokens": "def round_array ( array_in ) : if isinstance ( array_in , ndarray ) : return np . round ( array_in ) . astype ( int ) else : return int ( np . round ( array_in ) )", "docstring_tokens": "arr_out = round_array ( array_in )", "label": 1}, {"idx": "cosqa-train-5479", "doc": "how to represent a nonetype object python", "code": "def listlike(obj):\n    \"\"\"Is an object iterable like a list (and not a string)?\"\"\"\n    \n    return hasattr(obj, \"__iter__\") \\\n    and not issubclass(type(obj), str)\\\n    and not issubclass(type(obj), unicode)", "code_tokens": "def listlike ( obj ) : return hasattr ( obj , \"__iter__\" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )", "docstring_tokens": "Is an object iterable like a list ( and not a string ) ?", "label": 0}, {"idx": "cosqa-train-5480", "doc": "python rounding to the nearest tenth", "code": "def get_rounded(self, digits):\n        \"\"\" Return a vector with the elements rounded to the given number of digits. \"\"\"\n        result = self.copy()\n        result.round(digits)\n        return result", "code_tokens": "def get_rounded ( self , digits ) : result = self . copy ( ) result . round ( digits ) return result", "docstring_tokens": "Return a vector with the elements rounded to the given number of digits .", "label": 1}, {"idx": "cosqa-train-5481", "doc": "how to represent comments in python", "code": "def to_comment(value):\n  \"\"\"\n  Builds a comment.\n  \"\"\"\n  if value is None:\n    return\n  if len(value.split('\\n')) == 1:\n    return \"* \" + value\n  else:\n    return '\\n'.join([' * ' + l for l in value.split('\\n')[:-1]])", "code_tokens": "def to_comment ( value ) : if value is None : return if len ( value . split ( '\\n' ) ) == 1 : return \"* \" + value else : return '\\n' . join ( [ ' * ' + l for l in value . split ( '\\n' ) [ : - 1 ] ] )", "docstring_tokens": "Builds a comment .", "label": 1}, {"idx": "cosqa-train-5482", "doc": "python run django custom command", "code": "def managepy(cmd, extra=None):\n    \"\"\"Run manage.py using this component's specific Django settings\"\"\"\n\n    extra = extra.split() if extra else []\n    run_django_cli(['invoke', cmd] + extra)", "code_tokens": "def managepy ( cmd , extra = None ) : extra = extra . split ( ) if extra else [ ] run_django_cli ( [ 'invoke' , cmd ] + extra )", "docstring_tokens": "Run manage . py using this component s specific Django settings", "label": 0}, {"idx": "cosqa-train-5483", "doc": "how to retreve python object via id", "code": "def retrieve_by_id(self, id_):\n        \"\"\"Return a JSSObject for the element with ID id_\"\"\"\n        items_with_id = [item for item in self if item.id == int(id_)]\n        if len(items_with_id) == 1:\n            return items_with_id[0].retrieve()", "code_tokens": "def retrieve_by_id ( self , id_ ) : items_with_id = [ item for item in self if item . id == int ( id_ ) ] if len ( items_with_id ) == 1 : return items_with_id [ 0 ] . retrieve ( )", "docstring_tokens": "Return a JSSObject for the element with ID id_", "label": 1}, {"idx": "cosqa-train-5484", "doc": "python run external command and get output", "code": "def check_output(args, env=None, sp=subprocess):\n    \"\"\"Call an external binary and return its stdout.\"\"\"\n    log.debug('calling %s with env %s', args, env)\n    output = sp.check_output(args=args, env=env)\n    log.debug('output: %r', output)\n    return output", "code_tokens": "def check_output ( args , env = None , sp = subprocess ) : log . debug ( 'calling %s with env %s' , args , env ) output = sp . check_output ( args = args , env = env ) log . debug ( 'output: %r' , output ) return output", "docstring_tokens": "Call an external binary and return its stdout .", "label": 1}, {"idx": "cosqa-train-5485", "doc": "how to retriev the first number on python", "code": "def find_first_number(ll):\n    \"\"\" Returns nr of first entry parseable to float in ll, None otherwise\"\"\"\n    for nr, entry in enumerate(ll):\n        try:\n            float(entry)\n        except (ValueError, TypeError) as e:\n            pass\n        else:\n            return nr\n    return None", "code_tokens": "def find_first_number ( ll ) : for nr , entry in enumerate ( ll ) : try : float ( entry ) except ( ValueError , TypeError ) as e : pass else : return nr return None", "docstring_tokens": "Returns nr of first entry parseable to float in ll None otherwise", "label": 0}, {"idx": "cosqa-train-5486", "doc": "python run http server in background", "code": "def start(self):\n        \"\"\"Create a background thread for httpd and serve 'forever'\"\"\"\n        self._process = threading.Thread(target=self._background_runner)\n        self._process.start()", "code_tokens": "def start ( self ) : self . _process = threading . Thread ( target = self . _background_runner ) self . _process . start ( )", "docstring_tokens": "Create a background thread for httpd and serve forever", "label": 0}, {"idx": "cosqa-train-5487", "doc": "how to return contents of a file in python", "code": "def str_from_file(path):\n    \"\"\"\n    Return file contents as string.\n\n    \"\"\"\n    with open(path) as f:\n        s = f.read().strip()\n    return s", "code_tokens": "def str_from_file ( path ) : with open ( path ) as f : s = f . read ( ) . strip ( ) return s", "docstring_tokens": "Return file contents as string .", "label": 0}, {"idx": "cosqa-train-5488", "doc": "python run shell command on the background", "code": "def execute_in_background(self):\n        \"\"\"Executes a (shell) command in the background\n\n        :return: the process' pid\n        \"\"\"\n        # http://stackoverflow.com/questions/1605520\n        args = shlex.split(self.cmd)\n        p = Popen(args)\n        return p.pid", "code_tokens": "def execute_in_background ( self ) : # http://stackoverflow.com/questions/1605520 args = shlex . split ( self . cmd ) p = Popen ( args ) return p . pid", "docstring_tokens": "Executes a ( shell ) command in the background", "label": 1}, {"idx": "cosqa-train-5489", "doc": "how to return only unique items in python 3", "code": "def unique_items(seq):\n    \"\"\"Return the unique items from iterable *seq* (in order).\"\"\"\n    seen = set()\n    return [x for x in seq if not (x in seen or seen.add(x))]", "code_tokens": "def unique_items ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Return the unique items from iterable * seq * ( in order ) .", "label": 0}, {"idx": "cosqa-train-5490", "doc": "python run until complete server force stop close", "code": "def stop_server(self):\n        \"\"\"\n        Stop receiving connections, wait for all tasks to end, and then \n        terminate the server.\n        \"\"\"\n        self.stop = True\n        while self.task_count:\n            time.sleep(END_RESP)\n        self.terminate = True", "code_tokens": "def stop_server ( self ) : self . stop = True while self . task_count : time . sleep ( END_RESP ) self . terminate = True", "docstring_tokens": "Stop receiving connections wait for all tasks to end and then terminate the server .", "label": 0}, {"idx": "cosqa-train-5491", "doc": "how to reverse sort a list alphanetically in python", "code": "def sort_nicely(l):\n    \"\"\"Sort the given list in the way that humans expect.\"\"\"\n    convert = lambda text: int(text) if text.isdigit() else text\n    alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)]\n    l.sort(key=alphanum_key)", "code_tokens": "def sort_nicely ( l ) : convert = lambda text : int ( text ) if text . isdigit ( ) else text alphanum_key = lambda key : [ convert ( c ) for c in re . split ( '([0-9]+)' , key ) ] l . sort ( key = alphanum_key )", "docstring_tokens": "Sort the given list in the way that humans expect .", "label": 0}, {"idx": "cosqa-train-5492", "doc": "python sanic static forlder permission", "code": "def is_writable_by_others(filename):\n    \"\"\"Check if file or directory is world writable.\"\"\"\n    mode = os.stat(filename)[stat.ST_MODE]\n    return mode & stat.S_IWOTH", "code_tokens": "def is_writable_by_others ( filename ) : mode = os . stat ( filename ) [ stat . ST_MODE ] return mode & stat . S_IWOTH", "docstring_tokens": "Check if file or directory is world writable .", "label": 1}, {"idx": "cosqa-train-5493", "doc": "how to round sig figs in python", "code": "def round_to_n(x, n):\n    \"\"\"\n    Round to sig figs\n    \"\"\"\n    return round(x, -int(np.floor(np.log10(x))) + (n - 1))", "code_tokens": "def round_to_n ( x , n ) : return round ( x , - int ( np . floor ( np . log10 ( x ) ) ) + ( n - 1 ) )", "docstring_tokens": "Round to sig figs", "label": 0}, {"idx": "cosqa-train-5494", "doc": "how to say if float then do something in python", "code": "def clean_float(v):\n    \"\"\"Remove commas from a float\"\"\"\n\n    if v is None or not str(v).strip():\n        return None\n\n    return float(str(v).replace(',', ''))", "code_tokens": "def clean_float ( v ) : if v is None or not str ( v ) . strip ( ) : return None return float ( str ( v ) . replace ( ',' , '' ) )", "docstring_tokens": "Remove commas from a float", "label": 0}, {"idx": "cosqa-train-5495", "doc": "python save self to disk", "code": "def write(self):\n        \"\"\"Write content back to file.\"\"\"\n        with open(self.path, 'w') as file_:\n            file_.write(self.content)", "code_tokens": "def write ( self ) : with open ( self . path , 'w' ) as file_ : file_ . write ( self . content )", "docstring_tokens": "Write content back to file .", "label": 0}, {"idx": "cosqa-train-5496", "doc": "how to see call signature of a funciton in python", "code": "def get_func_posargs_name(f):\n    \"\"\"Returns the name of the function f's keyword argument parameter if it exists, otherwise None\"\"\"\n    sigparams = inspect.signature(f).parameters\n    for p in sigparams:\n        if sigparams[p].kind == inspect.Parameter.VAR_POSITIONAL:\n            return sigparams[p].name\n    return None", "code_tokens": "def get_func_posargs_name ( f ) : sigparams = inspect . signature ( f ) . parameters for p in sigparams : if sigparams [ p ] . kind == inspect . Parameter . VAR_POSITIONAL : return sigparams [ p ] . name return None", "docstring_tokens": "Returns the name of the function f s keyword argument parameter if it exists otherwise None", "label": 0}, {"idx": "cosqa-train-5497", "doc": "python scipy stats norm ppf", "code": "def norm(x, mu, sigma=1.0):\n    \"\"\" Scipy norm function \"\"\"\n    return stats.norm(loc=mu, scale=sigma).pdf(x)", "code_tokens": "def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )", "docstring_tokens": "Scipy norm function", "label": 1}, {"idx": "cosqa-train-5498", "doc": "how to see the model summary in python", "code": "def _summarize_object_type(model):\n    \"\"\"\n        This function returns the summary for a given model\n    \"\"\"\n    # the fields for the service's model\n    model_fields = {field.name: field for field in list(model.fields())}\n    # summarize the model\n    return {\n        'fields': [{\n            'name': key,\n            'type': type(convert_peewee_field(value)).__name__\n            } for key, value in model_fields.items()\n        ]\n    }", "code_tokens": "def _summarize_object_type ( model ) : # the fields for the service's model model_fields = { field . name : field for field in list ( model . fields ( ) ) } # summarize the model return { 'fields' : [ { 'name' : key , 'type' : type ( convert_peewee_field ( value ) ) . __name__ } for key , value in model_fields . items ( ) ] }", "docstring_tokens": "This function returns the summary for a given model", "label": 1}, {"idx": "cosqa-train-5499", "doc": "python script to generate unique id 10 caracters", "code": "def _get_random_id():\n    \"\"\" Get a random (i.e., unique) string identifier\"\"\"\n    symbols = string.ascii_uppercase + string.ascii_lowercase + string.digits\n    return ''.join(random.choice(symbols) for _ in range(15))", "code_tokens": "def _get_random_id ( ) : symbols = string . ascii_uppercase + string . ascii_lowercase + string . digits return '' . join ( random . choice ( symbols ) for _ in range ( 15 ) )", "docstring_tokens": "Get a random ( i . e . unique ) string identifier", "label": 0}, {"idx": "cosqa-train-5500", "doc": "python script to test gcm push", "code": "def fetch_hg_push_log(repo_name, repo_url):\n    \"\"\"\n    Run a HgPushlog etl process\n    \"\"\"\n    newrelic.agent.add_custom_parameter(\"repo_name\", repo_name)\n    process = HgPushlogProcess()\n    process.run(repo_url + '/json-pushes/?full=1&version=2', repo_name)", "code_tokens": "def fetch_hg_push_log ( repo_name , repo_url ) : newrelic . agent . add_custom_parameter ( \"repo_name\" , repo_name ) process = HgPushlogProcess ( ) process . run ( repo_url + '/json-pushes/?full=1&version=2' , repo_name )", "docstring_tokens": "Run a HgPushlog etl process", "label": 0}, {"idx": "cosqa-train-5501", "doc": "how to select model argparse on python shell", "code": "def main():\n    \"\"\"\n    Commandline interface to average parameters.\n    \"\"\"\n    setup_main_logger(console=True, file_logging=False)\n    params = argparse.ArgumentParser(description=\"Averages parameters from multiple models.\")\n    arguments.add_average_args(params)\n    args = params.parse_args()\n    average_parameters(args)", "code_tokens": "def main ( ) : setup_main_logger ( console = True , file_logging = False ) params = argparse . ArgumentParser ( description = \"Averages parameters from multiple models.\" ) arguments . add_average_args ( params ) args = params . parse_args ( ) average_parameters ( args )", "docstring_tokens": "Commandline interface to average parameters .", "label": 0}, {"idx": "cosqa-train-5502", "doc": "how to set cursonrposition in python", "code": "def update_cursor_position(self, line, index):\n        \"\"\"Update cursor position.\"\"\"\n        value = 'Line {}, Col {}'.format(line + 1, index + 1)\n        self.set_value(value)", "code_tokens": "def update_cursor_position ( self , line , index ) : value = 'Line {}, Col {}' . format ( line + 1 , index + 1 ) self . set_value ( value )", "docstring_tokens": "Update cursor position .", "label": 0}, {"idx": "cosqa-train-5503", "doc": "python scripts for stess testing ram", "code": "def demo(quiet, shell, speed, prompt, commentecho):\n    \"\"\"Run a demo doitlive session.\"\"\"\n    run(\n        DEMO,\n        shell=shell,\n        speed=speed,\n        test_mode=TESTING,\n        prompt_template=prompt,\n        quiet=quiet,\n        commentecho=commentecho,\n    )", "code_tokens": "def demo ( quiet , shell , speed , prompt , commentecho ) : run ( DEMO , shell = shell , speed = speed , test_mode = TESTING , prompt_template = prompt , quiet = quiet , commentecho = commentecho , )", "docstring_tokens": "Run a demo doitlive session .", "label": 1}, {"idx": "cosqa-train-5504", "doc": "how to set different attributes for a number of objects python", "code": "def populate_obj(obj, attrs):\n    \"\"\"Populates an object's attributes using the provided dict\n    \"\"\"\n    for k, v in attrs.iteritems():\n        setattr(obj, k, v)", "code_tokens": "def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "docstring_tokens": "Populates an object s attributes using the provided dict", "label": 0}, {"idx": "cosqa-train-5505", "doc": "python scroll into view", "code": "def scroll_element_into_view(self):\n        \"\"\"Scroll element into view\n\n        :returns: page element instance\n        \"\"\"\n        x = self.web_element.location['x']\n        y = self.web_element.location['y']\n        self.driver.execute_script('window.scrollTo({0}, {1})'.format(x, y))\n        return self", "code_tokens": "def scroll_element_into_view ( self ) : x = self . web_element . location [ 'x' ] y = self . web_element . location [ 'y' ] self . driver . execute_script ( 'window.scrollTo({0}, {1})' . format ( x , y ) ) return self", "docstring_tokens": "Scroll element into view", "label": 0}, {"idx": "cosqa-train-5506", "doc": "how to set text size in python", "code": "def set_font_size(self, size):\n        \"\"\"Convenience method for just changing font size.\"\"\"\n        if self.font.font_size == size:\n            pass\n        else:\n            self.font._set_size(size)", "code_tokens": "def set_font_size ( self , size ) : if self . font . font_size == size : pass else : self . font . _set_size ( size )", "docstring_tokens": "Convenience method for just changing font size .", "label": 1}, {"idx": "cosqa-train-5507", "doc": "python select distinct of column", "code": "def fast_distinct(self):\n        \"\"\"\n        Because standard distinct used on the all fields are very slow and works only with PostgreSQL database\n        this method provides alternative to the standard distinct method.\n        :return: qs with unique objects\n        \"\"\"\n        return self.model.objects.filter(pk__in=self.values_list('pk', flat=True))", "code_tokens": "def fast_distinct ( self ) : return self . model . objects . filter ( pk__in = self . values_list ( 'pk' , flat = True ) )", "docstring_tokens": "Because standard distinct used on the all fields are very slow and works only with PostgreSQL database this method provides alternative to the standard distinct method . : return : qs with unique objects", "label": 0}, {"idx": "cosqa-train-5508", "doc": "how to set x axis limit in python", "code": "def set_xlimits_widgets(self, set_min=True, set_max=True):\n        \"\"\"Populate axis limits GUI with current plot values.\"\"\"\n        xmin, xmax = self.tab_plot.ax.get_xlim()\n        if set_min:\n            self.w.x_lo.set_text('{0}'.format(xmin))\n        if set_max:\n            self.w.x_hi.set_text('{0}'.format(xmax))", "code_tokens": "def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )", "docstring_tokens": "Populate axis limits GUI with current plot values .", "label": 0}, {"idx": "cosqa-train-5509", "doc": "python send response but don't close", "code": "def send(r, stream=False):\n    \"\"\"Just sends the request using its send method and returns its response.  \"\"\"\n    r.send(stream=stream)\n    return r.response", "code_tokens": "def send ( r , stream = False ) : r . send ( stream = stream ) return r . response", "docstring_tokens": "Just sends the request using its send method and returns its response .", "label": 1}, {"idx": "cosqa-train-5510", "doc": "how to show a pixel coordinate at the cursor location in python", "code": "def _position():\n    \"\"\"Returns the current xy coordinates of the mouse cursor as a two-integer\n    tuple by calling the GetCursorPos() win32 function.\n\n    Returns:\n      (x, y) tuple of the current xy coordinates of the mouse cursor.\n    \"\"\"\n\n    cursor = POINT()\n    ctypes.windll.user32.GetCursorPos(ctypes.byref(cursor))\n    return (cursor.x, cursor.y)", "code_tokens": "def _position ( ) : cursor = POINT ( ) ctypes . windll . user32 . GetCursorPos ( ctypes . byref ( cursor ) ) return ( cursor . x , cursor . y )", "docstring_tokens": "Returns the current xy coordinates of the mouse cursor as a two - integer tuple by calling the GetCursorPos () win32 function .", "label": 0}, {"idx": "cosqa-train-5511", "doc": "python seperating a sentence into a list", "code": "def split_into_sentences(s):\n  \"\"\"Split text into list of sentences.\"\"\"\n  s = re.sub(r\"\\s+\", \" \", s)\n  s = re.sub(r\"[\\\\.\\\\?\\\\!]\", \"\\n\", s)\n  return s.split(\"\\n\")", "code_tokens": "def split_into_sentences ( s ) : s = re . sub ( r\"\\s+\" , \" \" , s ) s = re . sub ( r\"[\\\\.\\\\?\\\\!]\" , \"\\n\" , s ) return s . split ( \"\\n\" )", "docstring_tokens": "Split text into list of sentences .", "label": 1}, {"idx": "cosqa-train-5512", "doc": "how to show a progress on ui,wxpython", "code": "def finished(self):\n        \"\"\"\n        Must be called to print final progress label.\n        \"\"\"\n        self.progress_bar.set_state(ProgressBar.STATE_DONE)\n        self.progress_bar.show()", "code_tokens": "def finished ( self ) : self . progress_bar . set_state ( ProgressBar . STATE_DONE ) self . progress_bar . show ( )", "docstring_tokens": "Must be called to print final progress label .", "label": 0}, {"idx": "cosqa-train-5513", "doc": "python serialize datetime json", "code": "def _time_to_json(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\"\"\"\n    if isinstance(value, datetime.time):\n        value = value.isoformat()\n    return value", "code_tokens": "def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 1}, {"idx": "cosqa-train-5514", "doc": "how to show help in python", "code": "def _help():\n    \"\"\" Display both SQLAlchemy and Python help statements \"\"\"\n\n    statement = '%s%s' % (shelp, phelp % ', '.join(cntx_.keys()))\n    print statement.strip()", "code_tokens": "def _help ( ) : statement = '%s%s' % ( shelp , phelp % ', ' . join ( cntx_ . keys ( ) ) ) print statement . strip ( )", "docstring_tokens": "Display both SQLAlchemy and Python help statements", "label": 0}, {"idx": "cosqa-train-5515", "doc": "python series only keep if value isnull", "code": "def na_if(series, *values):\n    \"\"\"\n    If values in a series match a specified value, change them to `np.nan`.\n\n    Args:\n        series: Series or vector, often symbolic.\n        *values: Value(s) to convert to `np.nan` in the series.\n    \"\"\"\n\n    series = pd.Series(series)\n    series[series.isin(values)] = np.nan\n    return series", "code_tokens": "def na_if ( series , * values ) : series = pd . Series ( series ) series [ series . isin ( values ) ] = np . nan return series", "docstring_tokens": "If values in a series match a specified value change them to np . nan .", "label": 0}, {"idx": "cosqa-train-5516", "doc": "how to shuffle rows in python array", "code": "def _shuffle(data, idx):\n    \"\"\"Shuffle the data.\"\"\"\n    shuffle_data = []\n\n    for idx_k, idx_v in data:\n        shuffle_data.append((idx_k, mx.ndarray.array(idx_v.asnumpy()[idx], idx_v.context)))\n\n    return shuffle_data", "code_tokens": "def _shuffle ( data , idx ) : shuffle_data = [ ] for idx_k , idx_v in data : shuffle_data . append ( ( idx_k , mx . ndarray . array ( idx_v . asnumpy ( ) [ idx ] , idx_v . context ) ) ) return shuffle_data", "docstring_tokens": "Shuffle the data .", "label": 0}, {"idx": "cosqa-train-5517", "doc": "python server configure mime type", "code": "def python_mime(fn):\n    \"\"\"\n    Decorator, which adds correct MIME type for python source to the decorated\n    bottle API function.\n    \"\"\"\n    @wraps(fn)\n    def python_mime_decorator(*args, **kwargs):\n        response.content_type = \"text/x-python\"\n\n        return fn(*args, **kwargs)\n\n    return python_mime_decorator", "code_tokens": "def python_mime ( fn ) : @ wraps ( fn ) def python_mime_decorator ( * args , * * kwargs ) : response . content_type = \"text/x-python\" return fn ( * args , * * kwargs ) return python_mime_decorator", "docstring_tokens": "Decorator which adds correct MIME type for python source to the decorated bottle API function .", "label": 1}, {"idx": "cosqa-train-5518", "doc": "how to skip an element in a for loop python", "code": "def skip(self, n):\n        \"\"\"Skip the specified number of elements in the list.\n\n        If the number skipped is greater than the number of elements in\n        the list, hasNext() becomes false and available() returns zero\n        as there are no more elements to retrieve.\n\n        arg:    n (cardinal): the number of elements to skip\n        *compliance: mandatory -- This method must be implemented.*\n\n        \"\"\"\n        try:\n            self._iter_object.skip(n)\n        except AttributeError:\n            for i in range(0, n):\n                self.next()", "code_tokens": "def skip ( self , n ) : try : self . _iter_object . skip ( n ) except AttributeError : for i in range ( 0 , n ) : self . next ( )", "docstring_tokens": "Skip the specified number of elements in the list .", "label": 0}, {"idx": "cosqa-train-5519", "doc": "python session save object", "code": "def save_session_to_file(self, sessionfile):\n        \"\"\"Not meant to be used directly, use :meth:`Instaloader.save_session_to_file`.\"\"\"\n        pickle.dump(requests.utils.dict_from_cookiejar(self._session.cookies), sessionfile)", "code_tokens": "def save_session_to_file ( self , sessionfile ) : pickle . dump ( requests . utils . dict_from_cookiejar ( self . _session . cookies ) , sessionfile )", "docstring_tokens": "Not meant to be used directly use : meth : Instaloader . save_session_to_file .", "label": 0}, {"idx": "cosqa-train-5520", "doc": "how to slice a 2d table in python", "code": "def getcolslice(self, blc, trc, inc=[], startrow=0, nrow=-1, rowincr=1):\n        \"\"\"Get a slice from a table column holding arrays.\n        (see :func:`table.getcolslice`)\"\"\"\n        return self._table.getcolslice(self._column, blc, trc, inc, startrow, nrow, rowincr)", "code_tokens": "def getcolslice ( self , blc , trc , inc = [ ] , startrow = 0 , nrow = - 1 , rowincr = 1 ) : return self . _table . getcolslice ( self . _column , blc , trc , inc , startrow , nrow , rowincr )", "docstring_tokens": "Get a slice from a table column holding arrays . ( see : func : table . getcolslice )", "label": 0}, {"idx": "cosqa-train-5521", "doc": "python set axes range", "code": "def ylim(self, low, high, index=1):\n        \"\"\"Set yaxis limits.\n\n        Parameters\n        ----------\n        low : number\n        high : number\n        index : int, optional\n\n        Returns\n        -------\n        Chart\n\n        \"\"\"\n        self.layout['yaxis' + str(index)]['range'] = [low, high]\n        return self", "code_tokens": "def ylim ( self , low , high , index = 1 ) : self . layout [ 'yaxis' + str ( index ) ] [ 'range' ] = [ low , high ] return self", "docstring_tokens": "Set yaxis limits .", "label": 0}, {"idx": "cosqa-train-5522", "doc": "how to slice a list backwards in python", "code": "def grow_slice(slc, size):\n    \"\"\"\n    Grow a slice object by 1 in each direction without overreaching the list.\n\n    Parameters\n    ----------\n    slc: slice\n        slice object to grow\n    size: int\n        list length\n\n    Returns\n    -------\n    slc: slice\n       extended slice \n\n    \"\"\"\n\n    return slice(max(0, slc.start-1), min(size, slc.stop+1))", "code_tokens": "def grow_slice ( slc , size ) : return slice ( max ( 0 , slc . start - 1 ) , min ( size , slc . stop + 1 ) )", "docstring_tokens": "Grow a slice object by 1 in each direction without overreaching the list .", "label": 0}, {"idx": "cosqa-train-5523", "doc": "python set clear to empty stackoverflow", "code": "def reset(self):\n        \"\"\"Reset analyzer state\n        \"\"\"\n        self.prevframe = None\n        self.wasmoving = False\n        self.t0 = 0\n        self.ismoving = False", "code_tokens": "def reset ( self ) : self . prevframe = None self . wasmoving = False self . t0 = 0 self . ismoving = False", "docstring_tokens": "Reset analyzer state", "label": 1}, {"idx": "cosqa-train-5524", "doc": "how to sort a array in python", "code": "def arglexsort(arrays):\n    \"\"\"\n    Returns the indices of the lexicographical sorting\n    order of the supplied arrays.\n    \"\"\"\n    dtypes = ','.join(array.dtype.str for array in arrays)\n    recarray = np.empty(len(arrays[0]), dtype=dtypes)\n    for i, array in enumerate(arrays):\n        recarray['f%s' % i] = array\n    return recarray.argsort()", "code_tokens": "def arglexsort ( arrays ) : dtypes = ',' . join ( array . dtype . str for array in arrays ) recarray = np . empty ( len ( arrays [ 0 ] ) , dtype = dtypes ) for i , array in enumerate ( arrays ) : recarray [ 'f%s' % i ] = array return recarray . argsort ( )", "docstring_tokens": "Returns the indices of the lexicographical sorting order of the supplied arrays .", "label": 1}, {"idx": "cosqa-train-5525", "doc": "python set command as variabls", "code": "def aug_sysargv(cmdstr):\n    \"\"\" DEBUG FUNC modify argv to look like you ran a command \"\"\"\n    import shlex\n    argv = shlex.split(cmdstr)\n    sys.argv.extend(argv)", "code_tokens": "def aug_sysargv ( cmdstr ) : import shlex argv = shlex . split ( cmdstr ) sys . argv . extend ( argv )", "docstring_tokens": "DEBUG FUNC modify argv to look like you ran a command", "label": 0}, {"idx": "cosqa-train-5526", "doc": "how to sort a list of string in alphabetical order in python", "code": "def sort_nicely(l):\n    \"\"\"Sort the given list in the way that humans expect.\"\"\"\n    convert = lambda text: int(text) if text.isdigit() else text\n    alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)]\n    l.sort(key=alphanum_key)", "code_tokens": "def sort_nicely ( l ) : convert = lambda text : int ( text ) if text . isdigit ( ) else text alphanum_key = lambda key : [ convert ( c ) for c in re . split ( '([0-9]+)' , key ) ] l . sort ( key = alphanum_key )", "docstring_tokens": "Sort the given list in the way that humans expect .", "label": 0}, {"idx": "cosqa-train-5527", "doc": "python set development testing flags", "code": "def test(ctx, all=False, verbose=False):\n    \"\"\"Run the tests.\"\"\"\n    cmd = 'tox' if all else 'py.test'\n    if verbose:\n        cmd += ' -v'\n    return ctx.run(cmd, pty=True).return_code", "code_tokens": "def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code", "docstring_tokens": "Run the tests .", "label": 0}, {"idx": "cosqa-train-5528", "doc": "how to sort the data in python", "code": "def sort_data(x, y):\n    \"\"\"Sort the data.\"\"\"\n    xy = sorted(zip(x, y))\n    x, y = zip(*xy)\n    return x, y", "code_tokens": "def sort_data ( x , y ) : xy = sorted ( zip ( x , y ) ) x , y = zip ( * xy ) return x , y", "docstring_tokens": "Sort the data .", "label": 0}, {"idx": "cosqa-train-5529", "doc": "python set existing matrix entries to zero", "code": "def _zerosamestates(self, A):\n        \"\"\"\n        zeros out states that should be identical\n\n        REQUIRED ARGUMENTS\n\n        A: the matrix whose entries are to be zeroed.\n\n        \"\"\"\n\n        for pair in self.samestates:\n            A[pair[0], pair[1]] = 0\n            A[pair[1], pair[0]] = 0", "code_tokens": "def _zerosamestates ( self , A ) : for pair in self . samestates : A [ pair [ 0 ] , pair [ 1 ] ] = 0 A [ pair [ 1 ] , pair [ 0 ] ] = 0", "docstring_tokens": "zeros out states that should be identical", "label": 0}, {"idx": "cosqa-train-5530", "doc": "how to sort using python the column multiple data values", "code": "def sort_data(data, cols):\n    \"\"\"Sort `data` rows and order columns\"\"\"\n    return data.sort_values(cols)[cols + ['value']].reset_index(drop=True)", "code_tokens": "def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )", "docstring_tokens": "Sort data rows and order columns", "label": 0}, {"idx": "cosqa-train-5531", "doc": "python set global variable in function definition", "code": "def set_global(node: Node, key: str, value: Any):\n    \"\"\"Adds passed value to node's globals\"\"\"\n    node.node_globals[key] = value", "code_tokens": "def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "docstring_tokens": "Adds passed value to node s globals", "label": 0}, {"idx": "cosqa-train-5532", "doc": "how to specify range in histogram python", "code": "def _histplot_op(ax, data, **kwargs):\n    \"\"\"Add a histogram for the data to the axes.\"\"\"\n    bins = get_bins(data)\n    ax.hist(data, bins=bins, align=\"left\", density=True, **kwargs)\n    return ax", "code_tokens": "def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "docstring_tokens": "Add a histogram for the data to the axes .", "label": 0}, {"idx": "cosqa-train-5533", "doc": "python set local variable using frame and trace", "code": "def __run(self):\n    \"\"\"Hacked run function, which installs the trace.\"\"\"\n    sys.settrace(self.globaltrace)\n    self.__run_backup()\n    self.run = self.__run_backup", "code_tokens": "def __run ( self ) : sys . settrace ( self . globaltrace ) self . __run_backup ( ) self . run = self . __run_backup", "docstring_tokens": "Hacked run function which installs the trace .", "label": 0}, {"idx": "cosqa-train-5534", "doc": "how to split a table into a matrix in python", "code": "def transpose(table):\n    \"\"\"\n    transpose matrix\n    \"\"\"\n    t = []\n    for i in range(0, len(table[0])):\n        t.append([row[i] for row in table])\n    return t", "code_tokens": "def transpose ( table ) : t = [ ] for i in range ( 0 , len ( table [ 0 ] ) ) : t . append ( [ row [ i ] for row in table ] ) return t", "docstring_tokens": "transpose matrix", "label": 0}, {"idx": "cosqa-train-5535", "doc": "python set log y axis ticks", "code": "def log_y_cb(self, w, val):\n        \"\"\"Toggle linear/log scale for Y-axis.\"\"\"\n        self.tab_plot.logy = val\n        self.plot_two_columns()", "code_tokens": "def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )", "docstring_tokens": "Toggle linear / log scale for Y - axis .", "label": 0}, {"idx": "cosqa-train-5536", "doc": "how to split an array in 2 by index python", "code": "def _split_arrs(array_2d, slices):\n    \"\"\"\n    Equivalent to numpy.split(array_2d, slices),\n    but avoids fancy indexing\n    \"\"\"\n    if len(array_2d) == 0:\n        return np.empty(0, dtype=np.object)\n\n    rtn = np.empty(len(slices) + 1, dtype=np.object)\n    start = 0\n    for i, s in enumerate(slices):\n        rtn[i] = array_2d[start:s]\n        start = s\n    rtn[-1] = array_2d[start:]\n    return rtn", "code_tokens": "def _split_arrs ( array_2d , slices ) : if len ( array_2d ) == 0 : return np . empty ( 0 , dtype = np . object ) rtn = np . empty ( len ( slices ) + 1 , dtype = np . object ) start = 0 for i , s in enumerate ( slices ) : rtn [ i ] = array_2d [ start : s ] start = s rtn [ - 1 ] = array_2d [ start : ] return rtn", "docstring_tokens": "Equivalent to numpy . split ( array_2d slices ) but avoids fancy indexing", "label": 0}, {"idx": "cosqa-train-5537", "doc": "python set number of x ticks", "code": "def ynticks(self, nticks, index=1):\n        \"\"\"Set the number of ticks.\"\"\"\n        self.layout['yaxis' + str(index)]['nticks'] = nticks\n        return self", "code_tokens": "def ynticks ( self , nticks , index = 1 ) : self . layout [ 'yaxis' + str ( index ) ] [ 'nticks' ] = nticks return self", "docstring_tokens": "Set the number of ticks .", "label": 1}, {"idx": "cosqa-train-5538", "doc": "how to standardize matrix in python", "code": "def normalize_matrix(matrix):\n  \"\"\"Fold all values of the matrix into [0, 1].\"\"\"\n  abs_matrix = np.abs(matrix.copy())\n  return abs_matrix / abs_matrix.max()", "code_tokens": "def normalize_matrix ( matrix ) : abs_matrix = np . abs ( matrix . copy ( ) ) return abs_matrix / abs_matrix . max ( )", "docstring_tokens": "Fold all values of the matrix into [ 0 1 ] .", "label": 0}, {"idx": "cosqa-train-5539", "doc": "python set range equal to a variable", "code": "def empty(self, start=None, stop=None):\n\t\t\"\"\"Empty the range from start to stop.\n\n\t\tLike delete, but no Error is raised if the entire range isn't mapped.\n\t\t\"\"\"\n\t\tself.set(NOT_SET, start=start, stop=stop)", "code_tokens": "def empty ( self , start = None , stop = None ) : self . set ( NOT_SET , start = start , stop = stop )", "docstring_tokens": "Empty the range from start to stop .", "label": 0}, {"idx": "cosqa-train-5540", "doc": "how to stop a process linux python", "code": "def stop(pid):\n    \"\"\"Shut down a specific process.\n\n    Args:\n      pid: the pid of the process to shutdown.\n    \"\"\"\n    if psutil.pid_exists(pid):\n      try:\n        p = psutil.Process(pid)\n        p.kill()\n      except Exception:\n        pass", "code_tokens": "def stop ( pid ) : if psutil . pid_exists ( pid ) : try : p = psutil . Process ( pid ) p . kill ( ) except Exception : pass", "docstring_tokens": "Shut down a specific process .", "label": 0}, {"idx": "cosqa-train-5541", "doc": "python set standard output to line buffered", "code": "def linebuffered_stdout():\n    \"\"\" Always line buffer stdout so pipes and redirects are CLI friendly. \"\"\"\n    if sys.stdout.line_buffering:\n        return sys.stdout\n    orig = sys.stdout\n    new = type(orig)(orig.buffer, encoding=orig.encoding, errors=orig.errors,\n                     line_buffering=True)\n    new.mode = orig.mode\n    return new", "code_tokens": "def linebuffered_stdout ( ) : if sys . stdout . line_buffering : return sys . stdout orig = sys . stdout new = type ( orig ) ( orig . buffer , encoding = orig . encoding , errors = orig . errors , line_buffering = True ) new . mode = orig . mode return new", "docstring_tokens": "Always line buffer stdout so pipes and redirects are CLI friendly .", "label": 1}, {"idx": "cosqa-train-5542", "doc": "how to store sessions using a python server", "code": "def save_session(self, sid, session, namespace=None):\n        \"\"\"Store the user session for a client.\n\n        The only difference with the :func:`socketio.Server.save_session`\n        method is that when the ``namespace`` argument is not given the\n        namespace associated with the class is used.\n        \"\"\"\n        return self.server.save_session(\n            sid, session, namespace=namespace or self.namespace)", "code_tokens": "def save_session ( self , sid , session , namespace = None ) : return self . server . save_session ( sid , session , namespace = namespace or self . namespace )", "docstring_tokens": "Store the user session for a client .", "label": 0}, {"idx": "cosqa-train-5543", "doc": "python set unhashable type list", "code": "def dedupe_list(l):\n    \"\"\"Remove duplicates from a list preserving the order.\n\n    We might be tempted to use the list(set(l)) idiom, but it doesn't preserve\n    the order, which hinders testability and does not work for lists with\n    unhashable elements.\n    \"\"\"\n    result = []\n\n    for el in l:\n        if el not in result:\n            result.append(el)\n\n    return result", "code_tokens": "def dedupe_list ( l ) : result = [ ] for el in l : if el not in result : result . append ( el ) return result", "docstring_tokens": "Remove duplicates from a list preserving the order .", "label": 0}, {"idx": "cosqa-train-5544", "doc": "how to store true boolean as a variable in python", "code": "def strToBool(val):\n    \"\"\"\n    Helper function to turn a string representation of \"true\" into\n    boolean True.\n    \"\"\"\n    if isinstance(val, str):\n        val = val.lower()\n\n    return val in ['true', 'on', 'yes', True]", "code_tokens": "def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]", "docstring_tokens": "Helper function to turn a string representation of true into boolean True .", "label": 0}, {"idx": "cosqa-train-5545", "doc": "python set with not unique", "code": "def unique(iterable):\n    \"\"\" Returns a list copy in which each item occurs only once (in-order).\n    \"\"\"\n    seen = set()\n    return [x for x in iterable if x not in seen and not seen.add(x)]", "code_tokens": "def unique ( iterable ) : seen = set ( ) return [ x for x in iterable if x not in seen and not seen . add ( x ) ]", "docstring_tokens": "Returns a list copy in which each item occurs only once ( in - order ) .", "label": 0}, {"idx": "cosqa-train-5546", "doc": "how to string two numbers in python", "code": "def pair_strings_sum_formatter(a, b):\n  \"\"\"\n  Formats the sum of a and b.\n\n  Note\n  ----\n  Both inputs are numbers already converted to strings.\n\n  \"\"\"\n  if b[:1] == \"-\":\n    return \"{0} - {1}\".format(a, b[1:])\n  return \"{0} + {1}\".format(a, b)", "code_tokens": "def pair_strings_sum_formatter ( a , b ) : if b [ : 1 ] == \"-\" : return \"{0} - {1}\" . format ( a , b [ 1 : ] ) return \"{0} + {1}\" . format ( a , b )", "docstring_tokens": "Formats the sum of a and b .", "label": 0}, {"idx": "cosqa-train-5547", "doc": "python setdefault nested dict", "code": "def setdefaults(dct, defaults):\n    \"\"\"Given a target dct and a dict of {key:default value} pairs,\n    calls setdefault for all of those pairs.\"\"\"\n    for key in defaults:\n        dct.setdefault(key, defaults[key])\n\n    return dct", "code_tokens": "def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct", "docstring_tokens": "Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs .", "label": 0}, {"idx": "cosqa-train-5548", "doc": "how to stringify json object in python", "code": "def to_json(obj):\n    \"\"\"Return a json string representing the python object obj.\"\"\"\n    i = StringIO.StringIO()\n    w = Writer(i, encoding='UTF-8')\n    w.write_value(obj)\n    return i.getvalue()", "code_tokens": "def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )", "docstring_tokens": "Return a json string representing the python object obj .", "label": 0}, {"idx": "cosqa-train-5549", "doc": "python setuptools entry points", "code": "def main(argv, version=DEFAULT_VERSION):\n    \"\"\"Install or upgrade setuptools and EasyInstall\"\"\"\n    tarball = download_setuptools()\n    _install(tarball, _build_install_args(argv))", "code_tokens": "def main ( argv , version = DEFAULT_VERSION ) : tarball = download_setuptools ( ) _install ( tarball , _build_install_args ( argv ) )", "docstring_tokens": "Install or upgrade setuptools and EasyInstall", "label": 0}, {"idx": "cosqa-train-5550", "doc": "how to strip comma within parenthesis python", "code": "def split_comma_argument(comma_sep_str):\n    \"\"\"Split a comma separated option into a list.\"\"\"\n    terms = []\n    for term in comma_sep_str.split(','):\n        if term:\n            terms.append(term)\n    return terms", "code_tokens": "def split_comma_argument ( comma_sep_str ) : terms = [ ] for term in comma_sep_str . split ( ',' ) : if term : terms . append ( term ) return terms", "docstring_tokens": "Split a comma separated option into a list .", "label": 0}, {"idx": "cosqa-train-5551", "doc": "how to swap rows matrix in python", "code": "def _swap_rows(self, i, j):\n        \"\"\"Swap i and j rows\n\n        As the side effect, determinant flips.\n\n        \"\"\"\n\n        L = np.eye(3, dtype='intc')\n        L[i, i] = 0\n        L[j, j] = 0\n        L[i, j] = 1\n        L[j, i] = 1\n        self._L.append(L.copy())\n        self._A = np.dot(L, self._A)", "code_tokens": "def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )", "docstring_tokens": "Swap i and j rows", "label": 0}, {"idx": "cosqa-train-5552", "doc": "python sha1 hash of a file", "code": "def _sha1_for_file(filename):\n    \"\"\"Return sha1 for contents of filename.\"\"\"\n    with open(filename, \"rb\") as fileobj:\n        contents = fileobj.read()\n        return hashlib.sha1(contents).hexdigest()", "code_tokens": "def _sha1_for_file ( filename ) : with open ( filename , \"rb\" ) as fileobj : contents = fileobj . read ( ) return hashlib . sha1 ( contents ) . hexdigest ( )", "docstring_tokens": "Return sha1 for contents of filename .", "label": 0}, {"idx": "cosqa-train-5553", "doc": "how to switch capital letters and lower on python", "code": "def convert_camel_case_to_snake_case(name):\n    \"\"\"Convert CamelCase to snake_case.\"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def convert_camel_case_to_snake_case ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert CamelCase to snake_case .", "label": 1}, {"idx": "cosqa-train-5554", "doc": "python sha1 hashed string", "code": "def sha1(s):\n    \"\"\" Returns a sha1 of the given string\n    \"\"\"\n    h = hashlib.new('sha1')\n    h.update(s)\n    return h.hexdigest()", "code_tokens": "def sha1 ( s ) : h = hashlib . new ( 'sha1' ) h . update ( s ) return h . hexdigest ( )", "docstring_tokens": "Returns a sha1 of the given string", "label": 0}, {"idx": "cosqa-train-5555", "doc": "how to take date range as input in python 3", "code": "def from_years_range(start_year, end_year):\n        \"\"\"Transform a range of years (two ints) to a DateRange object.\"\"\"\n        start = datetime.date(start_year, 1 , 1)\n        end = datetime.date(end_year, 12 , 31)\n        return DateRange(start, end)", "code_tokens": "def from_years_range ( start_year , end_year ) : start = datetime . date ( start_year , 1 , 1 ) end = datetime . date ( end_year , 12 , 31 ) return DateRange ( start , end )", "docstring_tokens": "Transform a range of years ( two ints ) to a DateRange object .", "label": 0}, {"idx": "cosqa-train-5556", "doc": "python shell check virtual env", "code": "def has_virtualenv(self):\n        \"\"\"\n        Returns true if the virtualenv tool is installed.\n        \"\"\"\n        with self.settings(warn_only=True):\n            ret = self.run_or_local('which virtualenv').strip()\n            return bool(ret)", "code_tokens": "def has_virtualenv ( self ) : with self . settings ( warn_only = True ) : ret = self . run_or_local ( 'which virtualenv' ) . strip ( ) return bool ( ret )", "docstring_tokens": "Returns true if the virtualenv tool is installed .", "label": 0}, {"idx": "cosqa-train-5557", "doc": "how to take natural logarithm ln in python", "code": "def glog(x,l = 2):\n    \"\"\"\n    Generalised logarithm\n\n    :param x: number\n    :param p: number added befor logarithm \n\n    \"\"\"\n    return np.log((x+np.sqrt(x**2+l**2))/2)/np.log(l)", "code_tokens": "def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )", "docstring_tokens": "Generalised logarithm", "label": 0}, {"idx": "cosqa-train-5558", "doc": "python short time fft", "code": "def stft(func=None, **kwparams):\n  \"\"\"\n  Short Time Fourier Transform for real data keeping the full FFT block.\n\n  Same to the default STFT strategy, but with new defaults. This is the same\n  to:\n\n  .. code-block:: python\n\n    stft.base(transform=numpy.fft.fft,\n              inverse_transform=lambda *args: numpy.fft.ifft(*args).real)\n\n  See ``stft.base`` docs for more.\n  \"\"\"\n  from numpy.fft import fft, ifft\n  ifft_r = lambda *args: ifft(*args).real\n  return stft.base(transform=fft, inverse_transform=ifft_r)(func, **kwparams)", "code_tokens": "def stft ( func = None , * * kwparams ) : from numpy . fft import fft , ifft ifft_r = lambda * args : ifft ( * args ) . real return stft . base ( transform = fft , inverse_transform = ifft_r ) ( func , * * kwparams )", "docstring_tokens": "Short Time Fourier Transform for real data keeping the full FFT block .", "label": 1}, {"idx": "cosqa-train-5559", "doc": "how to tell if a python script has admin privileges", "code": "def is_managed():\n    \"\"\"\n    Check if a Django project is being managed with ``manage.py`` or\n    ``django-admin`` scripts\n\n    :return: Check result\n    :rtype: bool\n    \"\"\"\n    for item in sys.argv:\n        if re.search(r'manage.py|django-admin|django', item) is not None:\n            return True\n    return False", "code_tokens": "def is_managed ( ) : for item in sys . argv : if re . search ( r'manage.py|django-admin|django' , item ) is not None : return True return False", "docstring_tokens": "Check if a Django project is being managed with manage . py or django - admin scripts", "label": 0}, {"idx": "cosqa-train-5560", "doc": "how to time a function call in python", "code": "def timed_call(func, *args, log_level='DEBUG', **kwargs):\n    \"\"\"Logs a function's run time\n\n    :param func: The function to run\n    :param args: The args to pass to the function\n    :param kwargs: The keyword args to pass to the function\n    :param log_level: The log level at which to print the run time\n    :return: The function's return value\n    \"\"\"\n    start = time()\n    r = func(*args, **kwargs)\n    t = time() - start\n    log(log_level, \"Call to '{}' took {:0.6f}s\".format(func.__name__, t))\n    return r", "code_tokens": "def timed_call ( func , * args , log_level = 'DEBUG' , * * kwargs ) : start = time ( ) r = func ( * args , * * kwargs ) t = time ( ) - start log ( log_level , \"Call to '{}' took {:0.6f}s\" . format ( func . __name__ , t ) ) return r", "docstring_tokens": "Logs a function s run time", "label": 0}, {"idx": "cosqa-train-5561", "doc": "how to turn of traceback in python", "code": "def format_exception(e):\n    \"\"\"Returns a string containing the type and text of the exception.\n\n    \"\"\"\n    from .utils.printing import fill\n    return '\\n'.join(fill(line) for line in traceback.format_exception_only(type(e), e))", "code_tokens": "def format_exception ( e ) : from . utils . printing import fill return '\\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )", "docstring_tokens": "Returns a string containing the type and text of the exception .", "label": 0}, {"idx": "cosqa-train-5562", "doc": "python sigint handler exits windows", "code": "def signal_handler(signal_name, frame):\n    \"\"\"Quit signal handler.\"\"\"\n    sys.stdout.flush()\n    print(\"\\nSIGINT in frame signal received. Quitting...\")\n    sys.stdout.flush()\n    sys.exit(0)", "code_tokens": "def signal_handler ( signal_name , frame ) : sys . stdout . flush ( ) print ( \"\\nSIGINT in frame signal received. Quitting...\" ) sys . stdout . flush ( ) sys . exit ( 0 )", "docstring_tokens": "Quit signal handler .", "label": 1}, {"idx": "cosqa-train-5563", "doc": "how to type infinity in code python", "code": "def get_neg_infinity(dtype):\n    \"\"\"Return an appropriate positive infinity for this dtype.\n\n    Parameters\n    ----------\n    dtype : np.dtype\n\n    Returns\n    -------\n    fill_value : positive infinity value corresponding to this dtype.\n    \"\"\"\n    if issubclass(dtype.type, (np.floating, np.integer)):\n        return -np.inf\n\n    if issubclass(dtype.type, np.complexfloating):\n        return -np.inf - 1j * np.inf\n\n    return NINF", "code_tokens": "def get_neg_infinity ( dtype ) : if issubclass ( dtype . type , ( np . floating , np . integer ) ) : return - np . inf if issubclass ( dtype . type , np . complexfloating ) : return - np . inf - 1j * np . inf return NINF", "docstring_tokens": "Return an appropriate positive infinity for this dtype .", "label": 0}, {"idx": "cosqa-train-5564", "doc": "python signal handler how to die", "code": "def signal_handler(signal_name, frame):\n    \"\"\"Quit signal handler.\"\"\"\n    sys.stdout.flush()\n    print(\"\\nSIGINT in frame signal received. Quitting...\")\n    sys.stdout.flush()\n    sys.exit(0)", "code_tokens": "def signal_handler ( signal_name , frame ) : sys . stdout . flush ( ) print ( \"\\nSIGINT in frame signal received. Quitting...\" ) sys . stdout . flush ( ) sys . exit ( 0 )", "docstring_tokens": "Quit signal handler .", "label": 0}, {"idx": "cosqa-train-5565", "doc": "how to update multiple mongodb python", "code": "def update_one(self, query, doc):\n        \"\"\"\n        Updates one element of the collection\n\n        :param query: dictionary representing the mongo query\n        :param doc: dictionary representing the item to be updated\n        :return: UpdateResult\n        \"\"\"\n        if self.table is None:\n            self.build_table()\n\n        if u\"$set\" in doc:\n            doc = doc[u\"$set\"]\n\n        allcond = self.parse_query(query)\n\n        try:\n            result = self.table.update(doc, allcond)\n        except:\n            # TODO: check table.update result\n            # check what pymongo does in that case\n            result = None\n\n        return UpdateResult(raw_result=result)", "code_tokens": "def update_one ( self , query , doc ) : if self . table is None : self . build_table ( ) if u\"$set\" in doc : doc = doc [ u\"$set\" ] allcond = self . parse_query ( query ) try : result = self . table . update ( doc , allcond ) except : # TODO: check table.update result # check what pymongo does in that case result = None return UpdateResult ( raw_result = result )", "docstring_tokens": "Updates one element of the collection", "label": 0}, {"idx": "cosqa-train-5566", "doc": "python simple html entity replacer", "code": "def unescape_all(string):\n    \"\"\"Resolve all html entities to their corresponding unicode character\"\"\"\n    def escape_single(matchobj):\n        return _unicode_for_entity_with_name(matchobj.group(1))\n    return entities.sub(escape_single, string)", "code_tokens": "def unescape_all ( string ) : def escape_single ( matchobj ) : return _unicode_for_entity_with_name ( matchobj . group ( 1 ) ) return entities . sub ( escape_single , string )", "docstring_tokens": "Resolve all html entities to their corresponding unicode character", "label": 0}, {"idx": "cosqa-train-5567", "doc": "how to update value in json python", "code": "def update(self, params):\n        \"\"\"Update the dev_info data from a dictionary.\n\n        Only updates if it already exists in the device.\n        \"\"\"\n        dev_info = self.json_state.get('deviceInfo')\n        dev_info.update({k: params[k] for k in params if dev_info.get(k)})", "code_tokens": "def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )", "docstring_tokens": "Update the dev_info data from a dictionary .", "label": 0}, {"idx": "cosqa-train-5568", "doc": "python simplehttpserver log requests", "code": "def log_request(self, code='-', size='-'):\n        \"\"\"Selectively log an accepted request.\"\"\"\n\n        if self.server.logRequests:\n            BaseHTTPServer.BaseHTTPRequestHandler.log_request(self, code, size)", "code_tokens": "def log_request ( self , code = '-' , size = '-' ) : if self . server . logRequests : BaseHTTPServer . BaseHTTPRequestHandler . log_request ( self , code , size )", "docstring_tokens": "Selectively log an accepted request .", "label": 0}, {"idx": "cosqa-train-5569", "doc": "how to update value in python dictionary", "code": "def update(self, params):\n        \"\"\"Update the dev_info data from a dictionary.\n\n        Only updates if it already exists in the device.\n        \"\"\"\n        dev_info = self.json_state.get('deviceInfo')\n        dev_info.update({k: params[k] for k in params if dev_info.get(k)})", "code_tokens": "def update ( self , params ) : dev_info = self . json_state . get ( 'deviceInfo' ) dev_info . update ( { k : params [ k ] for k in params if dev_info . get ( k ) } )", "docstring_tokens": "Update the dev_info data from a dictionary .", "label": 0}, {"idx": "cosqa-train-5570", "doc": "python size of a variable command'", "code": "def calculate_size(name, timeout):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += LONG_SIZE_IN_BYTES\n    return data_size", "code_tokens": "def calculate_size ( name , timeout ) : data_size = 0 data_size += calculate_size_str ( name ) data_size += LONG_SIZE_IN_BYTES return data_size", "docstring_tokens": "Calculates the request payload size", "label": 0}, {"idx": "cosqa-train-5571", "doc": "how to url ssl to wrap a python socket for an https request", "code": "def enable_ssl(self, *args, **kwargs):\n        \"\"\"\n        Transforms the regular socket.socket to an ssl.SSLSocket for secure\n        connections. Any arguments are passed to ssl.wrap_socket:\n        http://docs.python.org/dev/library/ssl.html#ssl.wrap_socket\n        \"\"\"\n        if self.handshake_sent:\n            raise SSLError('can only enable SSL before handshake')\n\n        self.secure = True\n        self.sock = ssl.wrap_socket(self.sock, *args, **kwargs)", "code_tokens": "def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )", "docstring_tokens": "Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket", "label": 0}, {"idx": "cosqa-train-5572", "doc": "python skip file pointer to a specific line", "code": "def _skip_frame(self):\n        \"\"\"Skip a single frame from the trajectory\"\"\"\n        size = self.read_size()\n        for i in range(size+1):\n            line = self._f.readline()\n            if len(line) == 0:\n                raise StopIteration", "code_tokens": "def _skip_frame ( self ) : size = self . read_size ( ) for i in range ( size + 1 ) : line = self . _f . readline ( ) if len ( line ) == 0 : raise StopIteration", "docstring_tokens": "Skip a single frame from the trajectory", "label": 1}, {"idx": "cosqa-train-5573", "doc": "how to use a for loop to make a table python", "code": "def get_table(ports):\n    \"\"\"\n    This function returns a pretty table used to display the port results.\n\n    :param ports: list of found ports\n    :return: the table to display\n    \"\"\"\n    table = PrettyTable([\"Name\", \"Port\", \"Protocol\", \"Description\"])\n    table.align[\"Name\"] = \"l\"\n    table.align[\"Description\"] = \"l\"\n    table.padding_width = 1\n\n    for port in ports:\n        table.add_row(port)\n\n    return table", "code_tokens": "def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "docstring_tokens": "This function returns a pretty table used to display the port results .", "label": 0}, {"idx": "cosqa-train-5574", "doc": "python skip to end of parentheses", "code": "def _skip_newlines(self):\n        \"\"\"Increment over newlines.\"\"\"\n        while self._cur_token['type'] is TT.lbreak and not self._finished:\n            self._increment()", "code_tokens": "def _skip_newlines ( self ) : while self . _cur_token [ 'type' ] is TT . lbreak and not self . _finished : self . _increment ( )", "docstring_tokens": "Increment over newlines .", "label": 0}, {"idx": "cosqa-train-5575", "doc": "how to use a python filter object", "code": "def filter(self, obj, *args, **kwargs):\n        \"\"\"\n        Filter the given object through the filter chain.\n\n        :param obj: The object to filter\n        :param args: Additional arguments to pass to each filter function.\n        :param kwargs: Additional keyword arguments to pass to each filter\n                       function.\n        :return: The filtered object or :data:`None`\n\n        See the documentation of :class:`Filter` on how filtering operates.\n\n        Returns the object returned by the last function in the filter chain or\n        :data:`None` if any function returned :data:`None`.\n        \"\"\"\n        for _, _, func in self._filter_order:\n            obj = func(obj, *args, **kwargs)\n            if obj is None:\n                return None\n        return obj", "code_tokens": "def filter ( self , obj , * args , * * kwargs ) : for _ , _ , func in self . _filter_order : obj = func ( obj , * args , * * kwargs ) if obj is None : return None return obj", "docstring_tokens": "Filter the given object through the filter chain .", "label": 0}, {"idx": "cosqa-train-5576", "doc": "python skip to next line", "code": "def _skip_frame(self):\n        \"\"\"Skip a single frame from the trajectory\"\"\"\n        size = self.read_size()\n        for i in range(size+1):\n            line = self._f.readline()\n            if len(line) == 0:\n                raise StopIteration", "code_tokens": "def _skip_frame ( self ) : size = self . read_size ( ) for i in range ( size + 1 ) : line = self . _f . readline ( ) if len ( line ) == 0 : raise StopIteration", "docstring_tokens": "Skip a single frame from the trajectory", "label": 0}, {"idx": "cosqa-train-5577", "doc": "how to use a variable for spacing in python", "code": "def indent(txt, spacing=4):\n    \"\"\"\n    Indent given text using custom spacing, default is set to 4.\n    \"\"\"\n    return prefix(str(txt), ''.join([' ' for _ in range(spacing)]))", "code_tokens": "def indent ( txt , spacing = 4 ) : return prefix ( str ( txt ) , '' . join ( [ ' ' for _ in range ( spacing ) ] ) )", "docstring_tokens": "Indent given text using custom spacing default is set to 4 .", "label": 0}, {"idx": "cosqa-train-5578", "doc": "python sklearn roc auc", "code": "def roc_auc(y_true, y_score):\n    \"\"\"\n    Returns are under the ROC curve\n    \"\"\"\n    notnull = ~np.isnan(y_true)\n    fpr, tpr, thresholds = sklearn.metrics.roc_curve(y_true[notnull], y_score[notnull])\n    return sklearn.metrics.auc(fpr, tpr)", "code_tokens": "def roc_auc ( y_true , y_score ) : notnull = ~ np . isnan ( y_true ) fpr , tpr , thresholds = sklearn . metrics . roc_curve ( y_true [ notnull ] , y_score [ notnull ] ) return sklearn . metrics . auc ( fpr , tpr )", "docstring_tokens": "Returns are under the ROC curve", "label": 0}, {"idx": "cosqa-train-5579", "doc": "how to use differemt colour un write command in python", "code": "def write_color(string, name, style='normal', when='auto'):\n    \"\"\" Write the given colored string to standard out. \"\"\"\n    write(color(string, name, style, when))", "code_tokens": "def write_color ( string , name , style = 'normal' , when = 'auto' ) : write ( color ( string , name , style , when ) )", "docstring_tokens": "Write the given colored string to standard out .", "label": 1}, {"idx": "cosqa-train-5580", "doc": "python sklearn should be equal the number of features at training time", "code": "def NeuralNetLearner(dataset, sizes):\n   \"\"\"Layered feed-forward network.\"\"\"\n\n   activations = map(lambda n: [0.0 for i in range(n)], sizes)\n   weights = []\n\n   def predict(example):\n      unimplemented()\n\n   return predict", "code_tokens": "def NeuralNetLearner ( dataset , sizes ) : activations = map ( lambda n : [ 0.0 for i in range ( n ) ] , sizes ) weights = [ ] def predict ( example ) : unimplemented ( ) return predict", "docstring_tokens": "Layered feed - forward network .", "label": 0}, {"idx": "cosqa-train-5581", "doc": "how to use exponential constant in [python", "code": "def Exponential(x, a, tau, y0):\n    \"\"\"Exponential function\n\n    Inputs:\n    -------\n        ``x``: independent variable\n        ``a``: scaling factor\n        ``tau``: time constant\n        ``y0``: additive constant\n\n    Formula:\n    --------\n        ``a*exp(x/tau)+y0``\n    \"\"\"\n    return np.exp(x / tau) * a + y0", "code_tokens": "def Exponential ( x , a , tau , y0 ) : return np . exp ( x / tau ) * a + y0", "docstring_tokens": "Exponential function", "label": 0}, {"idx": "cosqa-train-5582", "doc": "how to use most left index in python", "code": "def find_le(a, x):\n    \"\"\"Find rightmost value less than or equal to x.\"\"\"\n    i = bs.bisect_right(a, x)\n    if i: return i - 1\n    raise ValueError", "code_tokens": "def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError", "docstring_tokens": "Find rightmost value less than or equal to x .", "label": 0}, {"idx": "cosqa-train-5583", "doc": "python sleep in for loop", "code": "def seconds(num):\n    \"\"\"\n    Pause for this many seconds\n    \"\"\"\n    now = pytime.time()\n    end = now + num\n    until(end)", "code_tokens": "def seconds ( num ) : now = pytime . time ( ) end = now + num until ( end )", "docstring_tokens": "Pause for this many seconds", "label": 0}, {"idx": "cosqa-train-5584", "doc": "how to use python to turn an html page into a plaintext file", "code": "def html_to_text(content):\n    \"\"\" Converts html content to plain text \"\"\"\n    text = None\n    h2t = html2text.HTML2Text()\n    h2t.ignore_links = False\n    text = h2t.handle(content)\n    return text", "code_tokens": "def html_to_text ( content ) : text = None h2t = html2text . HTML2Text ( ) h2t . ignore_links = False text = h2t . handle ( content ) return text", "docstring_tokens": "Converts html content to plain text", "label": 0}, {"idx": "cosqa-train-5585", "doc": "python slice half way", "code": "def is_full_slice(obj, l):\n    \"\"\"\n    We have a full length slice.\n    \"\"\"\n    return (isinstance(obj, slice) and obj.start == 0 and obj.stop == l and\n            obj.step is None)", "code_tokens": "def is_full_slice ( obj , l ) : return ( isinstance ( obj , slice ) and obj . start == 0 and obj . stop == l and obj . step is None )", "docstring_tokens": "We have a full length slice .", "label": 0}, {"idx": "cosqa-train-5586", "doc": "how to use raise without the extra in python", "code": "def _re_raise_as(NewExc, *args, **kw):\n    \"\"\"Raise a new exception using the preserved traceback of the last one.\"\"\"\n    etype, val, tb = sys.exc_info()\n    raise NewExc(*args, **kw), None, tb", "code_tokens": "def _re_raise_as ( NewExc , * args , * * kw ) : etype , val , tb = sys . exc_info ( ) raise NewExc ( * args , * * kw ) , None , tb", "docstring_tokens": "Raise a new exception using the preserved traceback of the last one .", "label": 1}, {"idx": "cosqa-train-5587", "doc": "python slice list into equal items", "code": "def partition(a, sz): \n    \"\"\"splits iterables a in equal parts of size sz\"\"\"\n    return [a[i:i+sz] for i in range(0, len(a), sz)]", "code_tokens": "def partition ( a , sz ) : return [ a [ i : i + sz ] for i in range ( 0 , len ( a ) , sz ) ]", "docstring_tokens": "splits iterables a in equal parts of size sz", "label": 0}, {"idx": "cosqa-train-5588", "doc": "how to use tkinter messagebox in python 2", "code": "def alert(text='', title='', button=OK_TEXT, root=None, timeout=None):\n    \"\"\"Displays a simple message box with text and a single OK button. Returns the text of the button clicked on.\"\"\"\n    assert TKINTER_IMPORT_SUCCEEDED, 'Tkinter is required for pymsgbox'\n    return _buttonbox(msg=text, title=title, choices=[str(button)], root=root, timeout=timeout)", "code_tokens": "def alert ( text = '' , title = '' , button = OK_TEXT , root = None , timeout = None ) : assert TKINTER_IMPORT_SUCCEEDED , 'Tkinter is required for pymsgbox' return _buttonbox ( msg = text , title = title , choices = [ str ( button ) ] , root = root , timeout = timeout )", "docstring_tokens": "Displays a simple message box with text and a single OK button . Returns the text of the button clicked on .", "label": 1}, {"idx": "cosqa-train-5589", "doc": "python softmax result to label", "code": "def output_scores(self, name=None):\n        \"\"\" Returns: N x #class scores, summed to one for each box.\"\"\"\n        return tf.nn.softmax(self.label_logits, name=name)", "code_tokens": "def output_scores ( self , name = None ) : return tf . nn . softmax ( self . label_logits , name = name )", "docstring_tokens": "Returns : N x #class scores summed to one for each box .", "label": 0}, {"idx": "cosqa-train-5590", "doc": "how to validate date python", "code": "def _validate_date_str(str_):\n    \"\"\"Validate str as a date and return string version of date\"\"\"\n\n    if not str_:\n        return None\n\n    # Convert to datetime so we can validate it's a real date that exists then\n    # convert it back to the string.\n    try:\n        date = datetime.strptime(str_, DATE_FMT)\n    except ValueError:\n        msg = 'Invalid date format, should be YYYY-MM-DD'\n        raise argparse.ArgumentTypeError(msg)\n\n    return date.strftime(DATE_FMT)", "code_tokens": "def _validate_date_str ( str_ ) : if not str_ : return None # Convert to datetime so we can validate it's a real date that exists then # convert it back to the string. try : date = datetime . strptime ( str_ , DATE_FMT ) except ValueError : msg = 'Invalid date format, should be YYYY-MM-DD' raise argparse . ArgumentTypeError ( msg ) return date . strftime ( DATE_FMT )", "docstring_tokens": "Validate str as a date and return string version of date", "label": 1}, {"idx": "cosqa-train-5591", "doc": "python sort a list by last name", "code": "def sort_by_name(self):\n        \"\"\"Sort list elements by name.\"\"\"\n        super(JSSObjectList, self).sort(key=lambda k: k.name)", "code_tokens": "def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )", "docstring_tokens": "Sort list elements by name .", "label": 0}, {"idx": "cosqa-train-5592", "doc": "how to wrap an infinite iterator python", "code": "def _fill(self):\n    \"\"\"Advance the iterator without returning the old head.\"\"\"\n    try:\n      self._head = self._iterable.next()\n    except StopIteration:\n      self._head = None", "code_tokens": "def _fill ( self ) : try : self . _head = self . _iterable . next ( ) except StopIteration : self . _head = None", "docstring_tokens": "Advance the iterator without returning the old head .", "label": 0}, {"idx": "cosqa-train-5593", "doc": "python sort dictionary by key iteritems", "code": "def _dict_values_sorted_by_key(dictionary):\n    # This should be a yield from instead.\n    \"\"\"Internal helper to return the values of a dictionary, sorted by key.\n    \"\"\"\n    for _, value in sorted(dictionary.iteritems(), key=operator.itemgetter(0)):\n        yield value", "code_tokens": "def _dict_values_sorted_by_key ( dictionary ) : # This should be a yield from instead. for _ , value in sorted ( dictionary . iteritems ( ) , key = operator . itemgetter ( 0 ) ) : yield value", "docstring_tokens": "Internal helper to return the values of a dictionary sorted by key .", "label": 1}, {"idx": "cosqa-train-5594", "doc": "how to wrap around text in python", "code": "def normalize_text(text, line_len=80, indent=\"\"):\n    \"\"\"Wrap the text on the given line length.\"\"\"\n    return \"\\n\".join(\n        textwrap.wrap(\n            text, width=line_len, initial_indent=indent, subsequent_indent=indent\n        )\n    )", "code_tokens": "def normalize_text ( text , line_len = 80 , indent = \"\" ) : return \"\\n\" . join ( textwrap . wrap ( text , width = line_len , initial_indent = indent , subsequent_indent = indent ) )", "docstring_tokens": "Wrap the text on the given line length .", "label": 1}, {"idx": "cosqa-train-5595", "doc": "python sort list endswith", "code": "def sort_by_name(self):\n        \"\"\"Sort list elements by name.\"\"\"\n        super(JSSObjectList, self).sort(key=lambda k: k.name)", "code_tokens": "def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )", "docstring_tokens": "Sort list elements by name .", "label": 1}, {"idx": "cosqa-train-5596", "doc": "how to write a code that rounds a number to the input of digits python", "code": "def get_rounded(self, digits):\n        \"\"\" Return a vector with the elements rounded to the given number of digits. \"\"\"\n        result = self.copy()\n        result.round(digits)\n        return result", "code_tokens": "def get_rounded ( self , digits ) : result = self . copy ( ) result . round ( digits ) return result", "docstring_tokens": "Return a vector with the elements rounded to the given number of digits .", "label": 0}, {"idx": "cosqa-train-5597", "doc": "python sort list of dictionaries by multiple keys", "code": "def unique_list_dicts(dlist, key):\n    \"\"\"Return a list of dictionaries which are sorted for only unique entries.\n\n    :param dlist:\n    :param key:\n    :return list:\n    \"\"\"\n\n    return list(dict((val[key], val) for val in dlist).values())", "code_tokens": "def unique_list_dicts ( dlist , key ) : return list ( dict ( ( val [ key ] , val ) for val in dlist ) . values ( ) )", "docstring_tokens": "Return a list of dictionaries which are sorted for only unique entries .", "label": 0}, {"idx": "cosqa-train-5598", "doc": "how to write a comment header in python", "code": "def comment (self, s, **args):\n        \"\"\"Write GML comment.\"\"\"\n        self.writeln(s=u'comment \"%s\"' % s, **args)", "code_tokens": "def comment ( self , s , * * args ) : self . writeln ( s = u'comment \"%s\"' % s , * * args )", "docstring_tokens": "Write GML comment .", "label": 0}, {"idx": "cosqa-train-5599", "doc": "python spherical bessel functions", "code": "def sbessely(x, N):\n    \"\"\"Returns a vector of spherical bessel functions yn:\n\n        x:   The argument.\n        N:   values of n will run from 0 to N-1.\n\n    \"\"\"\n\n    out = np.zeros(N, dtype=np.float64)\n\n    out[0] = -np.cos(x) / x\n    out[1] = -np.cos(x) / (x ** 2) - np.sin(x) / x\n\n    for n in xrange(2, N):\n        out[n] = ((2.0 * n - 1.0) / x) * out[n - 1] - out[n - 2]\n\n    return out", "code_tokens": "def sbessely ( x , N ) : out = np . zeros ( N , dtype = np . float64 ) out [ 0 ] = - np . cos ( x ) / x out [ 1 ] = - np . cos ( x ) / ( x ** 2 ) - np . sin ( x ) / x for n in xrange ( 2 , N ) : out [ n ] = ( ( 2.0 * n - 1.0 ) / x ) * out [ n - 1 ] - out [ n - 2 ] return out", "docstring_tokens": "Returns a vector of spherical bessel functions yn : x : The argument . N : values of n will run from 0 to N - 1 .", "label": 1}, {"idx": "cosqa-train-5600", "doc": "python split list into sublists based on size", "code": "def batch(items, size):\n    \"\"\"Batches a list into a list of lists, with sub-lists sized by a specified\n    batch size.\"\"\"\n    return [items[x:x + size] for x in xrange(0, len(items), size)]", "code_tokens": "def batch ( items , size ) : return [ items [ x : x + size ] for x in xrange ( 0 , len ( items ) , size ) ]", "docstring_tokens": "Batches a list into a list of lists with sub - lists sized by a specified batch size .", "label": 0}, {"idx": "cosqa-train-5601", "doc": "how to write a left join function in python for sql query", "code": "def get_join_cols(by_entry):\n  \"\"\" helper function used for joins\n  builds left and right join list for join function\n  \"\"\"\n  left_cols = []\n  right_cols = []\n  for col in by_entry:\n    if isinstance(col, str):\n      left_cols.append(col)\n      right_cols.append(col)\n    else:\n      left_cols.append(col[0])\n      right_cols.append(col[1])\n  return left_cols, right_cols", "code_tokens": "def get_join_cols ( by_entry ) : left_cols = [ ] right_cols = [ ] for col in by_entry : if isinstance ( col , str ) : left_cols . append ( col ) right_cols . append ( col ) else : left_cols . append ( col [ 0 ] ) right_cols . append ( col [ 1 ] ) return left_cols , right_cols", "docstring_tokens": "helper function used for joins builds left and right join list for join function", "label": 0}, {"idx": "cosqa-train-5602", "doc": "python split string delimter word", "code": "def split_on(s, sep=\" \"):\n    \"\"\"Split s by sep, unless it's inside a quote.\"\"\"\n    pattern = '''((?:[^%s\"']|\"[^\"]*\"|'[^']*')+)''' % sep\n\n    return [_strip_speechmarks(t) for t in re.split(pattern, s)[1::2]]", "code_tokens": "def split_on ( s , sep = \" \" ) : pattern = '''((?:[^%s\"']|\"[^\"]*\"|'[^']*')+)''' % sep return [ _strip_speechmarks ( t ) for t in re . split ( pattern , s ) [ 1 : : 2 ] ]", "docstring_tokens": "Split s by sep unless it s inside a quote .", "label": 0}, {"idx": "cosqa-train-5603", "doc": "how to write a list as tab delimit into a file, line by line, python", "code": "def write_tsv_line_from_list(linelist, outfp):\n    \"\"\"Utility method to convert list to tsv line with carriage return\"\"\"\n    line = '\\t'.join(linelist)\n    outfp.write(line)\n    outfp.write('\\n')", "code_tokens": "def write_tsv_line_from_list ( linelist , outfp ) : line = '\\t' . join ( linelist ) outfp . write ( line ) outfp . write ( '\\n' )", "docstring_tokens": "Utility method to convert list to tsv line with carriage return", "label": 1}, {"idx": "cosqa-train-5604", "doc": "python split string to integer tuple", "code": "def ver_to_tuple(value):\n    \"\"\"\n    Convert version like string to a tuple of integers.\n    \"\"\"\n    return tuple(int(_f) for _f in re.split(r'\\D+', value) if _f)", "code_tokens": "def ver_to_tuple ( value ) : return tuple ( int ( _f ) for _f in re . split ( r'\\D+' , value ) if _f )", "docstring_tokens": "Convert version like string to a tuple of integers .", "label": 0}, {"idx": "cosqa-train-5605", "doc": "how to write a nested dictionary to a string in python", "code": "def pretty_dict_string(d, indent=0):\n    \"\"\"Pretty output of nested dictionaries.\n    \"\"\"\n    s = ''\n    for key, value in sorted(d.items()):\n        s += '    ' * indent + str(key)\n        if isinstance(value, dict):\n             s += '\\n' + pretty_dict_string(value, indent+1)\n        else:\n             s += '=' + str(value) + '\\n'\n    return s", "code_tokens": "def pretty_dict_string ( d , indent = 0 ) : s = '' for key , value in sorted ( d . items ( ) ) : s += '    ' * indent + str ( key ) if isinstance ( value , dict ) : s += '\\n' + pretty_dict_string ( value , indent + 1 ) else : s += '=' + str ( value ) + '\\n' return s", "docstring_tokens": "Pretty output of nested dictionaries .", "label": 0}, {"idx": "cosqa-train-5606", "doc": "python split string to subatring f differernt lenght", "code": "def split_len(s, length):\n    \"\"\"split string *s* into list of strings no longer than *length*\"\"\"\n    return [s[i:i+length] for i in range(0, len(s), length)]", "code_tokens": "def split_len ( s , length ) : return [ s [ i : i + length ] for i in range ( 0 , len ( s ) , length ) ]", "docstring_tokens": "split string * s * into list of strings no longer than * length *", "label": 0}, {"idx": "cosqa-train-5607", "doc": "how to write a parser on python", "code": "def __init__(self):\n        \"\"\"__init__: Performs basic initialisations\"\"\"\n        # Root parser\n        self.parser = argparse.ArgumentParser()\n        # Subparsers\n        self.subparsers = self.parser.add_subparsers()\n        # Parser dictionary, to avoir overwriting existing parsers\n        self.parsers = {}", "code_tokens": "def __init__ ( self ) : # Root parser self . parser = argparse . ArgumentParser ( ) # Subparsers self . subparsers = self . parser . add_subparsers ( ) # Parser dictionary, to avoir overwriting existing parsers self . parsers = { }", "docstring_tokens": "__init__ : Performs basic initialisations", "label": 1}, {"idx": "cosqa-train-5608", "doc": "how to write a python expression that evaluates and stores a function", "code": "def upoint2exprpoint(upoint):\n    \"\"\"Convert an untyped point into an Expression point.\n\n    .. seealso::\n       For definitions of points and untyped points,\n       see the :mod:`pyeda.boolalg.boolfunc` module.\n    \"\"\"\n    point = dict()\n    for uniqid in upoint[0]:\n        point[_LITS[uniqid]] = 0\n    for uniqid in upoint[1]:\n        point[_LITS[uniqid]] = 1\n    return point", "code_tokens": "def upoint2exprpoint ( upoint ) : point = dict ( ) for uniqid in upoint [ 0 ] : point [ _LITS [ uniqid ] ] = 0 for uniqid in upoint [ 1 ] : point [ _LITS [ uniqid ] ] = 1 return point", "docstring_tokens": "Convert an untyped point into an Expression point .", "label": 0}, {"idx": "cosqa-train-5609", "doc": "python spyder apply lowercase transformation to code", "code": "def to_snake_case(s):\n    \"\"\"Converts camel-case identifiers to snake-case.\"\"\"\n    return re.sub('([^_A-Z])([A-Z])', lambda m: m.group(1) + '_' + m.group(2).lower(), s)", "code_tokens": "def to_snake_case ( s ) : return re . sub ( '([^_A-Z])([A-Z])' , lambda m : m . group ( 1 ) + '_' + m . group ( 2 ) . lower ( ) , s )", "docstring_tokens": "Converts camel - case identifiers to snake - case .", "label": 0}, {"idx": "cosqa-train-5610", "doc": "how to write python exclusive or", "code": "def logical_or(self, other):\n        \"\"\"logical_or(t) = self(t) or other(t).\"\"\"\n        return self.operation(other, lambda x, y: int(x or y))", "code_tokens": "def logical_or ( self , other ) : return self . operation ( other , lambda x , y : int ( x or y ) )", "docstring_tokens": "logical_or ( t ) = self ( t ) or other ( t ) .", "label": 0}, {"idx": "cosqa-train-5611", "doc": "python sql server paramerterized query", "code": "def parse_query_string(query):\n    \"\"\"\n    parse_query_string:\n    very simplistic. won't do the right thing with list values\n    \"\"\"\n    result = {}\n    qparts = query.split('&')\n    for item in qparts:\n        key, value = item.split('=')\n        key = key.strip()\n        value = value.strip()\n        result[key] = unquote_plus(value)\n    return result", "code_tokens": "def parse_query_string ( query ) : result = { } qparts = query . split ( '&' ) for item in qparts : key , value = item . split ( '=' ) key = key . strip ( ) value = value . strip ( ) result [ key ] = unquote_plus ( value ) return result", "docstring_tokens": "parse_query_string : very simplistic . won t do the right thing with list values", "label": 0}, {"idx": "cosqa-train-5612", "doc": "howto generate same rand sequence in python", "code": "def get_random_id(length):\n    \"\"\"Generate a random, alpha-numerical id.\"\"\"\n    alphabet = string.ascii_uppercase + string.ascii_lowercase + string.digits\n    return ''.join(random.choice(alphabet) for _ in range(length))", "code_tokens": "def get_random_id ( length ) : alphabet = string . ascii_uppercase + string . ascii_lowercase + string . digits return '' . join ( random . choice ( alphabet ) for _ in range ( length ) )", "docstring_tokens": "Generate a random alpha - numerical id .", "label": 0}, {"idx": "cosqa-train-5613", "doc": "python sql server query date to datetime object", "code": "def from_pydatetime(cls, pydatetime):\n        \"\"\"\n        Creates sql datetime2 object from Python datetime object\n        ignoring timezone\n        @param pydatetime: Python datetime object\n        @return: sql datetime2 object\n        \"\"\"\n        return cls(date=Date.from_pydate(pydatetime.date),\n                   time=Time.from_pytime(pydatetime.time))", "code_tokens": "def from_pydatetime ( cls , pydatetime ) : return cls ( date = Date . from_pydate ( pydatetime . date ) , time = Time . from_pytime ( pydatetime . time ) )", "docstring_tokens": "Creates sql datetime2 object from Python datetime object ignoring timezone", "label": 1}, {"idx": "cosqa-train-5614", "doc": "html entity (named) in python", "code": "def unescape_all(string):\n    \"\"\"Resolve all html entities to their corresponding unicode character\"\"\"\n    def escape_single(matchobj):\n        return _unicode_for_entity_with_name(matchobj.group(1))\n    return entities.sub(escape_single, string)", "code_tokens": "def unescape_all ( string ) : def escape_single ( matchobj ) : return _unicode_for_entity_with_name ( matchobj . group ( 1 ) ) return entities . sub ( escape_single , string )", "docstring_tokens": "Resolve all html entities to their corresponding unicode character", "label": 0}, {"idx": "cosqa-train-5615", "doc": "python sqlalchemy model table update method", "code": "def save(self):\n        \"\"\"Saves the updated model to the current entity db.\n        \"\"\"\n        self.session.add(self)\n        self.session.flush()\n        return self", "code_tokens": "def save ( self ) : self . session . add ( self ) self . session . flush ( ) return self", "docstring_tokens": "Saves the updated model to the current entity db .", "label": 1}, {"idx": "cosqa-train-5616", "doc": "html render text as markdown python", "code": "def md_to_text(content):\n    \"\"\" Converts markdown content to text \"\"\"\n    text = None\n    html = markdown.markdown(content)\n    if html:\n        text = html_to_text(content)\n    return text", "code_tokens": "def md_to_text ( content ) : text = None html = markdown . markdown ( content ) if html : text = html_to_text ( content ) return text", "docstring_tokens": "Converts markdown content to text", "label": 0}, {"idx": "cosqa-train-5617", "doc": "python sqlalchemy not create table", "code": "def createdb():\n    \"\"\"Create database tables from sqlalchemy models\"\"\"\n    manager.db.engine.echo = True\n    manager.db.create_all()\n    set_alembic_revision()", "code_tokens": "def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )", "docstring_tokens": "Create database tables from sqlalchemy models", "label": 1}, {"idx": "cosqa-train-5618", "doc": "hwo to put a function in loop with sleep time python", "code": "def main(idle):\n    \"\"\"Any normal python logic which runs a loop. Can take arguments.\"\"\"\n    while True:\n\n        LOG.debug(\"Sleeping for {0} seconds.\".format(idle))\n        time.sleep(idle)", "code_tokens": "def main ( idle ) : while True : LOG . debug ( \"Sleeping for {0} seconds.\" . format ( idle ) ) time . sleep ( idle )", "docstring_tokens": "Any normal python logic which runs a loop . Can take arguments .", "label": 1}, {"idx": "cosqa-train-5619", "doc": "python sqlite table name in a variable", "code": "def get_tablenames(cur):\n    \"\"\" Conveinience: \"\"\"\n    cur.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n    tablename_list_ = cur.fetchall()\n    tablename_list = [str(tablename[0]) for tablename in tablename_list_ ]\n    return tablename_list", "code_tokens": "def get_tablenames ( cur ) : cur . execute ( \"SELECT name FROM sqlite_master WHERE type='table'\" ) tablename_list_ = cur . fetchall ( ) tablename_list = [ str ( tablename [ 0 ] ) for tablename in tablename_list_ ] return tablename_list", "docstring_tokens": "Conveinience :", "label": 0}, {"idx": "cosqa-train-5620", "doc": "identify datatype and print the name in python", "code": "def _getTypename(self, defn):\n        \"\"\" Returns the SQL typename required to store the given FieldDefinition \"\"\"\n        return 'REAL' if defn.type.float or 'TIME' in defn.type.name or defn.dntoeu else 'INTEGER'", "code_tokens": "def _getTypename ( self , defn ) : return 'REAL' if defn . type . float or 'TIME' in defn . type . name or defn . dntoeu else 'INTEGER'", "docstring_tokens": "Returns the SQL typename required to store the given FieldDefinition", "label": 0}, {"idx": "cosqa-train-5621", "doc": "python sqlite3 last row", "code": "def get_last_id(self, cur, table='reaction'):\n        \"\"\"\n        Get the id of the last written row in table\n\n        Parameters\n        ----------\n        cur: database connection().cursor() object\n        table: str\n            'reaction', 'publication', 'publication_system', 'reaction_system'\n\n        Returns: id\n        \"\"\"\n        cur.execute(\"SELECT seq FROM sqlite_sequence WHERE name='{0}'\"\n                    .format(table))\n        result = cur.fetchone()\n        if result is not None:\n            id = result[0]\n        else:\n            id = 0\n        return id", "code_tokens": "def get_last_id ( self , cur , table = 'reaction' ) : cur . execute ( \"SELECT seq FROM sqlite_sequence WHERE name='{0}'\" . format ( table ) ) result = cur . fetchone ( ) if result is not None : id = result [ 0 ] else : id = 0 return id", "docstring_tokens": "Get the id of the last written row in table", "label": 0}, {"idx": "cosqa-train-5622", "doc": "identifying string types in python", "code": "def visit_Str(self, node):\n        \"\"\" Set the pythonic string type. \"\"\"\n        self.result[node] = self.builder.NamedType(pytype_to_ctype(str))", "code_tokens": "def visit_Str ( self , node ) : self . result [ node ] = self . builder . NamedType ( pytype_to_ctype ( str ) )", "docstring_tokens": "Set the pythonic string type .", "label": 0}, {"idx": "cosqa-train-5623", "doc": "python stacked plot from series", "code": "def _plot(self):\n        \"\"\"Plot stacked serie lines and stacked secondary lines\"\"\"\n        for serie in self.series[::-1 if self.stack_from_top else 1]:\n            self.line(serie)\n        for serie in self.secondary_series[::-1 if self.stack_from_top else 1]:\n            self.line(serie, True)", "code_tokens": "def _plot ( self ) : for serie in self . series [ : : - 1 if self . stack_from_top else 1 ] : self . line ( serie ) for serie in self . secondary_series [ : : - 1 if self . stack_from_top else 1 ] : self . line ( serie , True )", "docstring_tokens": "Plot stacked serie lines and stacked secondary lines", "label": 0}, {"idx": "cosqa-train-5624", "doc": "if there are no inputs, print the result in python code", "code": "def print(*a):\n    \"\"\" print just one that returns what you give it instead of None \"\"\"\n    try:\n        _print(*a)\n        return a[0] if len(a) == 1 else a\n    except:\n        _print(*a)", "code_tokens": "def print ( * a ) : try : _print ( * a ) return a [ 0 ] if len ( a ) == 1 else a except : _print ( * a )", "docstring_tokens": "print just one that returns what you give it instead of None", "label": 0}, {"idx": "cosqa-train-5625", "doc": "python stdout clear line", "code": "def _stdout_raw(self, s):\n        \"\"\"Writes the string to stdout\"\"\"\n        print(s, end='', file=sys.stdout)\n        sys.stdout.flush()", "code_tokens": "def _stdout_raw ( self , s ) : print ( s , end = '' , file = sys . stdout ) sys . stdout . flush ( )", "docstring_tokens": "Writes the string to stdout", "label": 0}, {"idx": "cosqa-train-5626", "doc": "if value key in python not provided, defaulted to none python", "code": "def validate_args(**args):\n\t\"\"\"\n\tfunction to check if input query is not None \n\tand set missing arguments to default value\n\t\"\"\"\n\tif not args['query']:\n\t\tprint(\"\\nMissing required query argument.\")\n\t\tsys.exit()\n\n\tfor key in DEFAULTS:\n\t\tif key not in args:\n\t\t\targs[key] = DEFAULTS[key]\n\n\treturn args", "code_tokens": "def validate_args ( * * args ) : if not args [ 'query' ] : print ( \"\\nMissing required query argument.\" ) sys . exit ( ) for key in DEFAULTS : if key not in args : args [ key ] = DEFAULTS [ key ] return args", "docstring_tokens": "function to check if input query is not None and set missing arguments to default value", "label": 0}, {"idx": "cosqa-train-5627", "doc": "python stop a window service", "code": "def stop(self, reason=None):\n        \"\"\"Shutdown the service with a reason.\"\"\"\n        self.logger.info('stopping')\n        self.loop.stop(pyev.EVBREAK_ALL)", "code_tokens": "def stop ( self , reason = None ) : self . logger . info ( 'stopping' ) self . loop . stop ( pyev . EVBREAK_ALL )", "docstring_tokens": "Shutdown the service with a reason .", "label": 0}, {"idx": "cosqa-train-5628", "doc": "image jaccard similarity in python", "code": "def jaccard(c_1, c_2):\n    \"\"\"\n    Calculates the Jaccard similarity between two sets of nodes. Called by mroc.\n\n    Inputs:  - c_1: Community (set of nodes) 1.\n             - c_2: Community (set of nodes) 2.\n\n    Outputs: - jaccard_similarity: The Jaccard similarity of these two communities.\n    \"\"\"\n    nom = np.intersect1d(c_1, c_2).size\n    denom = np.union1d(c_1, c_2).size\n    return nom/denom", "code_tokens": "def jaccard ( c_1 , c_2 ) : nom = np . intersect1d ( c_1 , c_2 ) . size denom = np . union1d ( c_1 , c_2 ) . size return nom / denom", "docstring_tokens": "Calculates the Jaccard similarity between two sets of nodes . Called by mroc .", "label": 0}, {"idx": "cosqa-train-5629", "doc": "python store the index of the max 3 values in an array", "code": "def MultiArgMax(x):\n  \"\"\"\n  Get tuple (actually a generator) of indices where the max value of\n  array x occurs. Requires that x have a max() method, as x.max()\n  (in the case of NumPy) is much faster than max(x).\n  For a simpler, faster argmax when there is only a single maximum entry,\n  or when knowing only the first index where the maximum occurs,\n  call argmax() on a NumPy array.\n\n  :param x: Any sequence that has a max() method.\n  :returns: Generator with the indices where the max value occurs.\n  \"\"\"\n  m = x.max()\n  return (i for i, v in enumerate(x) if v == m)", "code_tokens": "def MultiArgMax ( x ) : m = x . max ( ) return ( i for i , v in enumerate ( x ) if v == m )", "docstring_tokens": "Get tuple ( actually a generator ) of indices where the max value of array x occurs . Requires that x have a max () method as x . max () ( in the case of NumPy ) is much faster than max ( x ) . For a simpler faster argmax when there is only a single maximum entry or when knowing only the first index where the maximum occurs call argmax () on a NumPy array .", "label": 0}, {"idx": "cosqa-train-5630", "doc": "images to animated gif python", "code": "def _encode_gif(images, fps):\n  \"\"\"Encodes numpy images into gif string.\n\n  Args:\n    images: A 4-D `uint8` `np.array` (or a list of 3-D images) of shape\n      `[time, height, width, channels]` where `channels` is 1 or 3.\n    fps: frames per second of the animation\n\n  Returns:\n    The encoded gif string.\n\n  Raises:\n    IOError: If the ffmpeg command returns an error.\n  \"\"\"\n  writer = WholeVideoWriter(fps)\n  writer.write_multi(images)\n  return writer.finish()", "code_tokens": "def _encode_gif ( images , fps ) : writer = WholeVideoWriter ( fps ) writer . write_multi ( images ) return writer . finish ( )", "docstring_tokens": "Encodes numpy images into gif string .", "label": 0}, {"idx": "cosqa-train-5631", "doc": "python store userid in session", "code": "def load_logged_in_user():\n    \"\"\"If a user id is stored in the session, load the user object from\n    the database into ``g.user``.\"\"\"\n    user_id = session.get(\"user_id\")\n    g.user = User.query.get(user_id) if user_id is not None else None", "code_tokens": "def load_logged_in_user ( ) : user_id = session . get ( \"user_id\" ) g . user = User . query . get ( user_id ) if user_id is not None else None", "docstring_tokens": "If a user id is stored in the session load the user object from the database into g . user .", "label": 0}, {"idx": "cosqa-train-5632", "doc": "immediately retrieve the last key in the mysql table using python 3", "code": "def get_last_id(self, cur, table='reaction'):\n        \"\"\"\n        Get the id of the last written row in table\n\n        Parameters\n        ----------\n        cur: database connection().cursor() object\n        table: str\n            'reaction', 'publication', 'publication_system', 'reaction_system'\n\n        Returns: id\n        \"\"\"\n        cur.execute(\"SELECT seq FROM sqlite_sequence WHERE name='{0}'\"\n                    .format(table))\n        result = cur.fetchone()\n        if result is not None:\n            id = result[0]\n        else:\n            id = 0\n        return id", "code_tokens": "def get_last_id ( self , cur , table = 'reaction' ) : cur . execute ( \"SELECT seq FROM sqlite_sequence WHERE name='{0}'\" . format ( table ) ) result = cur . fetchone ( ) if result is not None : id = result [ 0 ] else : id = 0 return id", "docstring_tokens": "Get the id of the last written row in table", "label": 1}, {"idx": "cosqa-train-5633", "doc": "python str to bytes python2", "code": "def u2b(string):\n    \"\"\" unicode to bytes\"\"\"\n    if ((PY2 and isinstance(string, unicode)) or\n        ((not PY2) and isinstance(string, str))):\n        return string.encode('utf-8')\n    return string", "code_tokens": "def u2b ( string ) : if ( ( PY2 and isinstance ( string , unicode ) ) or ( ( not PY2 ) and isinstance ( string , str ) ) ) : return string . encode ( 'utf-8' ) return string", "docstring_tokens": "unicode to bytes", "label": 1}, {"idx": "cosqa-train-5634", "doc": "implement clustered edges in python networkx", "code": "def _create_complete_graph(node_ids):\n    \"\"\"Create a complete graph from the list of node ids.\n\n    Args:\n        node_ids: a list of node ids\n\n    Returns:\n        An undirected graph (as a networkx.Graph)\n    \"\"\"\n    g = nx.Graph()\n    g.add_nodes_from(node_ids)\n    for (i, j) in combinations(node_ids, 2):\n        g.add_edge(i, j)\n    return g", "code_tokens": "def _create_complete_graph ( node_ids ) : g = nx . Graph ( ) g . add_nodes_from ( node_ids ) for ( i , j ) in combinations ( node_ids , 2 ) : g . add_edge ( i , j ) return g", "docstring_tokens": "Create a complete graph from the list of node ids .", "label": 0}, {"idx": "cosqa-train-5635", "doc": "python string ithout spaces", "code": "def strip_spaces(x):\n    \"\"\"\n    Strips spaces\n    :param x:\n    :return:\n    \"\"\"\n    x = x.replace(b' ', b'')\n    x = x.replace(b'\\t', b'')\n    return x", "code_tokens": "def strip_spaces ( x ) : x = x . replace ( b' ' , b'' ) x = x . replace ( b'\\t' , b'' ) return x", "docstring_tokens": "Strips spaces : param x : : return :", "label": 1}, {"idx": "cosqa-train-5636", "doc": "in a dictionary in python 3 is pop and del the same thing", "code": "def pop (self, key):\n        \"\"\"Remove key from dict and return value.\"\"\"\n        if key in self._keys:\n            self._keys.remove(key)\n        super(ListDict, self).pop(key)", "code_tokens": "def pop ( self , key ) : if key in self . _keys : self . _keys . remove ( key ) super ( ListDict , self ) . pop ( key )", "docstring_tokens": "Remove key from dict and return value .", "label": 0}, {"idx": "cosqa-train-5637", "doc": "python string remove non alphabet", "code": "def clean(self, text):\n        \"\"\"Remove all unwanted characters from text.\"\"\"\n        return ''.join([c for c in text if c in self.alphabet])", "code_tokens": "def clean ( self , text ) : return '' . join ( [ c for c in text if c in self . alphabet ] )", "docstring_tokens": "Remove all unwanted characters from text .", "label": 1}, {"idx": "cosqa-train-5638", "doc": "in python ctype for pointer", "code": "def POINTER(obj):\n    \"\"\"\n    Create ctypes pointer to object.\n\n    Notes\n    -----\n    This function converts None to a real NULL pointer because of bug\n    in how ctypes handles None on 64-bit platforms.\n\n    \"\"\"\n\n    p = ctypes.POINTER(obj)\n    if not isinstance(p.from_param, classmethod):\n        def from_param(cls, x):\n            if x is None:\n                return cls()\n            else:\n                return x\n        p.from_param = classmethod(from_param)\n\n    return p", "code_tokens": "def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p", "docstring_tokens": "Create ctypes pointer to object .", "label": 0}, {"idx": "cosqa-train-5639", "doc": "python string replace multiple", "code": "def myreplace(astr, thefind, thereplace):\n    \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"\n    alist = astr.split(thefind)\n    new_s = alist.split(thereplace)\n    return new_s", "code_tokens": "def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "docstring_tokens": "in string astr replace all occurences of thefind with thereplace", "label": 0}, {"idx": "cosqa-train-5640", "doc": "in python takes in a picture and scales it by doubling the width and cutting the height in half", "code": "def scale_image(image, new_width):\n    \"\"\"Resizes an image preserving the aspect ratio.\n    \"\"\"\n    (original_width, original_height) = image.size\n    aspect_ratio = original_height/float(original_width)\n    new_height = int(aspect_ratio * new_width)\n\n    # This scales it wider than tall, since characters are biased\n    new_image = image.resize((new_width*2, new_height))\n    return new_image", "code_tokens": "def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image", "docstring_tokens": "Resizes an image preserving the aspect ratio .", "label": 1}, {"idx": "cosqa-train-5641", "doc": "python string replace multiple things", "code": "def myreplace(astr, thefind, thereplace):\n    \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"\n    alist = astr.split(thefind)\n    new_s = alist.split(thereplace)\n    return new_s", "code_tokens": "def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "docstring_tokens": "in string astr replace all occurences of thefind with thereplace", "label": 0}, {"idx": "cosqa-train-5642", "doc": "in python, can we open a file for both write and read", "code": "def open_file(file, mode):\n\t\"\"\"Open a file.\n\n\t:arg file: file-like or path-like object.\n\t:arg str mode: ``mode`` argument for :func:`open`.\n\t\"\"\"\n\tif hasattr(file, \"read\"):\n\t\treturn file\n\tif hasattr(file, \"open\"):\n\t\treturn file.open(mode)\n\treturn open(file, mode)", "code_tokens": "def open_file ( file , mode ) : if hasattr ( file , \"read\" ) : return file if hasattr ( file , \"open\" ) : return file . open ( mode ) return open ( file , mode )", "docstring_tokens": "Open a file .", "label": 0}, {"idx": "cosqa-train-5643", "doc": "python string replace space with underscore", "code": "def us2mc(string):\n    \"\"\"Transform an underscore_case string to a mixedCase string\"\"\"\n    return re.sub(r'_([a-z])', lambda m: (m.group(1).upper()), string)", "code_tokens": "def us2mc ( string ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , string )", "docstring_tokens": "Transform an underscore_case string to a mixedCase string", "label": 0}, {"idx": "cosqa-train-5644", "doc": "in python, how to print strings in different colours", "code": "def cprint(string, fg=None, bg=None, end='\\n', target=sys.stdout):\n    \"\"\"Print a colored string to the target handle.\n\n    fg and bg specify foreground- and background colors, respectively. The\n    remaining keyword arguments are the same as for Python's built-in print\n    function. Colors are returned to their defaults before the function\n    returns.\n\n    \"\"\"\n    _color_manager.set_color(fg, bg)\n    target.write(string + end)\n    target.flush()  # Needed for Python 3.x\n    _color_manager.set_defaults()", "code_tokens": "def cprint ( string , fg = None , bg = None , end = '\\n' , target = sys . stdout ) : _color_manager . set_color ( fg , bg ) target . write ( string + end ) target . flush ( ) # Needed for Python 3.x _color_manager . set_defaults ( )", "docstring_tokens": "Print a colored string to the target handle .", "label": 1}, {"idx": "cosqa-train-5645", "doc": "python string to dictonary", "code": "def list_string_to_dict(string):\n    \"\"\"Inputs ``['a', 'b', 'c']``, returns ``{'a': 0, 'b': 1, 'c': 2}``.\"\"\"\n    dictionary = {}\n    for idx, c in enumerate(string):\n        dictionary.update({c: idx})\n    return dictionary", "code_tokens": "def list_string_to_dict ( string ) : dictionary = { } for idx , c in enumerate ( string ) : dictionary . update ( { c : idx } ) return dictionary", "docstring_tokens": "Inputs [ a b c ] returns { a : 0 b : 1 c : 2 } .", "label": 0}, {"idx": "cosqa-train-5646", "doc": "increase the pyxl column width using python", "code": "def _xls2col_widths(self, worksheet, tab):\n        \"\"\"Updates col_widths in code_array\"\"\"\n\n        for col in xrange(worksheet.ncols):\n            try:\n                xls_width = worksheet.colinfo_map[col].width\n                pys_width = self.xls_width2pys_width(xls_width)\n                self.code_array.col_widths[col, tab] = pys_width\n\n            except KeyError:\n                pass", "code_tokens": "def _xls2col_widths ( self , worksheet , tab ) : for col in xrange ( worksheet . ncols ) : try : xls_width = worksheet . colinfo_map [ col ] . width pys_width = self . xls_width2pys_width ( xls_width ) self . code_array . col_widths [ col , tab ] = pys_width except KeyError : pass", "docstring_tokens": "Updates col_widths in code_array", "label": 0}, {"idx": "cosqa-train-5647", "doc": "python string to enum name", "code": "def getEventTypeNameFromEnum(self, eType):\n        \"\"\"returns the name of an EVREvent enum value\"\"\"\n\n        fn = self.function_table.getEventTypeNameFromEnum\n        result = fn(eType)\n        return result", "code_tokens": "def getEventTypeNameFromEnum ( self , eType ) : fn = self . function_table . getEventTypeNameFromEnum result = fn ( eType ) return result", "docstring_tokens": "returns the name of an EVREvent enum value", "label": 1}, {"idx": "cosqa-train-5648", "doc": "indenting multiline docstrings python", "code": "def process_docstring(app, what, name, obj, options, lines):\n    \"\"\"React to a docstring event and append contracts to it.\"\"\"\n    # pylint: disable=unused-argument\n    # pylint: disable=too-many-arguments\n    lines.extend(_format_contracts(what=what, obj=obj))", "code_tokens": "def process_docstring ( app , what , name , obj , options , lines ) : # pylint: disable=unused-argument # pylint: disable=too-many-arguments lines . extend ( _format_contracts ( what = what , obj = obj ) )", "docstring_tokens": "React to a docstring event and append contracts to it .", "label": 1}, {"idx": "cosqa-train-5649", "doc": "python string to microseconds", "code": "def timestamp_to_microseconds(timestamp):\n    \"\"\"Convert a timestamp string into a microseconds value\n    :param timestamp\n    :return time in microseconds\n    \"\"\"\n    timestamp_str = datetime.datetime.strptime(timestamp, ISO_DATETIME_REGEX)\n    epoch_time_secs = calendar.timegm(timestamp_str.timetuple())\n    epoch_time_mus = epoch_time_secs * 1e6 + timestamp_str.microsecond\n    return epoch_time_mus", "code_tokens": "def timestamp_to_microseconds ( timestamp ) : timestamp_str = datetime . datetime . strptime ( timestamp , ISO_DATETIME_REGEX ) epoch_time_secs = calendar . timegm ( timestamp_str . timetuple ( ) ) epoch_time_mus = epoch_time_secs * 1e6 + timestamp_str . microsecond return epoch_time_mus", "docstring_tokens": "Convert a timestamp string into a microseconds value : param timestamp : return time in microseconds", "label": 1}, {"idx": "cosqa-train-5650", "doc": "index of a number in a list python", "code": "def is_in(self, search_list, pair):\n        \"\"\"\n        If pair is in search_list, return the index. Otherwise return -1\n        \"\"\"\n        index = -1\n        for nr, i in enumerate(search_list):\n            if(np.all(i == pair)):\n                return nr\n        return index", "code_tokens": "def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index", "docstring_tokens": "If pair is in search_list return the index . Otherwise return - 1", "label": 1}, {"idx": "cosqa-train-5651", "doc": "python stringio faster than file", "code": "def FromString(s, **kwargs):\n    \"\"\"Like FromFile, but takes a string.\"\"\"\n    \n    f = StringIO.StringIO(s)\n    return FromFile(f, **kwargs)", "code_tokens": "def FromString ( s , * * kwargs ) : f = StringIO . StringIO ( s ) return FromFile ( f , * * kwargs )", "docstring_tokens": "Like FromFile but takes a string .", "label": 0}, {"idx": "cosqa-train-5652", "doc": "index of last match regex python", "code": "def findLastCharIndexMatching(text, func):\n    \"\"\" Return index of last character in string for which func(char) evaluates to True. \"\"\"\n    for i in range(len(text) - 1, -1, -1):\n      if func(text[i]):\n        return i", "code_tokens": "def findLastCharIndexMatching ( text , func ) : for i in range ( len ( text ) - 1 , - 1 , - 1 ) : if func ( text [ i ] ) : return i", "docstring_tokens": "Return index of last character in string for which func ( char ) evaluates to True .", "label": 1}, {"idx": "cosqa-train-5653", "doc": "python stringio to file path", "code": "def FromString(s, **kwargs):\n    \"\"\"Like FromFile, but takes a string.\"\"\"\n    \n    f = StringIO.StringIO(s)\n    return FromFile(f, **kwargs)", "code_tokens": "def FromString ( s , * * kwargs ) : f = StringIO . StringIO ( s ) return FromFile ( f , * * kwargs )", "docstring_tokens": "Like FromFile but takes a string .", "label": 0}, {"idx": "cosqa-train-5654", "doc": "index of the maximum number in the array python", "code": "def MultiArgMax(x):\n  \"\"\"\n  Get tuple (actually a generator) of indices where the max value of\n  array x occurs. Requires that x have a max() method, as x.max()\n  (in the case of NumPy) is much faster than max(x).\n  For a simpler, faster argmax when there is only a single maximum entry,\n  or when knowing only the first index where the maximum occurs,\n  call argmax() on a NumPy array.\n\n  :param x: Any sequence that has a max() method.\n  :returns: Generator with the indices where the max value occurs.\n  \"\"\"\n  m = x.max()\n  return (i for i, v in enumerate(x) if v == m)", "code_tokens": "def MultiArgMax ( x ) : m = x . max ( ) return ( i for i , v in enumerate ( x ) if v == m )", "docstring_tokens": "Get tuple ( actually a generator ) of indices where the max value of array x occurs . Requires that x have a max () method as x . max () ( in the case of NumPy ) is much faster than max ( x ) . For a simpler faster argmax when there is only a single maximum entry or when knowing only the first index where the maximum occurs call argmax () on a NumPy array .", "label": 0}, {"idx": "cosqa-train-5655", "doc": "python strip invisible characters from string", "code": "def drop_bad_characters(text):\n    \"\"\"Takes a text and drops all non-printable and non-ascii characters and\n    also any whitespace characters that aren't space.\n\n    :arg str text: the text to fix\n\n    :returns: text with all bad characters dropped\n\n    \"\"\"\n    # Strip all non-ascii and non-printable characters\n    text = ''.join([c for c in text if c in ALLOWED_CHARS])\n    return text", "code_tokens": "def drop_bad_characters ( text ) : # Strip all non-ascii and non-printable characters text = '' . join ( [ c for c in text if c in ALLOWED_CHARS ] ) return text", "docstring_tokens": "Takes a text and drops all non - printable and non - ascii characters and also any whitespace characters that aren t space .", "label": 0}, {"idx": "cosqa-train-5656", "doc": "indexing a line after reading file python", "code": "def get_lines(handle, line):\n    \"\"\"\n    Get zero-indexed line from an open file-like.\n    \"\"\"\n    for i, l in enumerate(handle):\n        if i == line:\n            return l", "code_tokens": "def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l", "docstring_tokens": "Get zero - indexed line from an open file - like .", "label": 0}, {"idx": "cosqa-train-5657", "doc": "python strip off time million seconds", "code": "def RoundToSeconds(cls, timestamp):\n    \"\"\"Takes a timestamp value and rounds it to a second precision.\"\"\"\n    leftovers = timestamp % definitions.MICROSECONDS_PER_SECOND\n    scrubbed = timestamp - leftovers\n    rounded = round(float(leftovers) / definitions.MICROSECONDS_PER_SECOND)\n\n    return int(scrubbed + rounded * definitions.MICROSECONDS_PER_SECOND)", "code_tokens": "def RoundToSeconds ( cls , timestamp ) : leftovers = timestamp % definitions . MICROSECONDS_PER_SECOND scrubbed = timestamp - leftovers rounded = round ( float ( leftovers ) / definitions . MICROSECONDS_PER_SECOND ) return int ( scrubbed + rounded * definitions . MICROSECONDS_PER_SECOND )", "docstring_tokens": "Takes a timestamp value and rounds it to a second precision .", "label": 0}, {"idx": "cosqa-train-5658", "doc": "initializing a list to an unknown number of elements in python", "code": "def __init__(self, capacity=10):\n        \"\"\"\n        Initialize python List with capacity of 10 or user given input.\n        Python List type is a dynamic array, so we have to restrict its\n        dynamic nature to make it work like a static array.\n        \"\"\"\n        super().__init__()\n        self._array = [None] * capacity\n        self._front = 0\n        self._rear = 0", "code_tokens": "def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0", "docstring_tokens": "Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array .", "label": 0}, {"idx": "cosqa-train-5659", "doc": "python strip spaces from strings", "code": "def unpunctuate(s, *, char_blacklist=string.punctuation):\n    \"\"\" Remove punctuation from string s. \"\"\"\n    # remove punctuation\n    s = \"\".join(c for c in s if c not in char_blacklist)\n    # remove consecutive spaces\n    return \" \".join(filter(None, s.split(\" \")))", "code_tokens": "def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = \"\" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return \" \" . join ( filter ( None , s . split ( \" \" ) ) )", "docstring_tokens": "Remove punctuation from string s .", "label": 0}, {"idx": "cosqa-train-5660", "doc": "initiate with an empty set in python", "code": "def _init_unique_sets(self):\n        \"\"\"Initialise sets used for uniqueness checking.\"\"\"\n\n        ks = dict()\n        for t in self._unique_checks:\n            key = t[0]\n            ks[key] = set() # empty set\n        return ks", "code_tokens": "def _init_unique_sets ( self ) : ks = dict ( ) for t in self . _unique_checks : key = t [ 0 ] ks [ key ] = set ( ) # empty set return ks", "docstring_tokens": "Initialise sets used for uniqueness checking .", "label": 0}, {"idx": "cosqa-train-5661", "doc": "python strip string of prefix", "code": "def _clip(sid, prefix):\n    \"\"\"Clips a prefix from the beginning of a string if it exists.\"\"\"\n    return sid[len(prefix):] if sid.startswith(prefix) else sid", "code_tokens": "def _clip ( sid , prefix ) : return sid [ len ( prefix ) : ] if sid . startswith ( prefix ) else sid", "docstring_tokens": "Clips a prefix from the beginning of a string if it exists .", "label": 1}, {"idx": "cosqa-train-5662", "doc": "inner join python means", "code": "def merge(left, right, how='inner', key=None, left_key=None, right_key=None,\n          left_as='left', right_as='right'):\n    \"\"\" Performs a join using the union join function. \"\"\"\n    return join(left, right, how, key, left_key, right_key,\n                join_fn=make_union_join(left_as, right_as))", "code_tokens": "def merge ( left , right , how = 'inner' , key = None , left_key = None , right_key = None , left_as = 'left' , right_as = 'right' ) : return join ( left , right , how , key , left_key , right_key , join_fn = make_union_join ( left_as , right_as ) )", "docstring_tokens": "Performs a join using the union join function .", "label": 0}, {"idx": "cosqa-train-5663", "doc": "python strip string prefix", "code": "def _clip(sid, prefix):\n    \"\"\"Clips a prefix from the beginning of a string if it exists.\"\"\"\n    return sid[len(prefix):] if sid.startswith(prefix) else sid", "code_tokens": "def _clip ( sid , prefix ) : return sid [ len ( prefix ) : ] if sid . startswith ( prefix ) else sid", "docstring_tokens": "Clips a prefix from the beginning of a string if it exists .", "label": 0}, {"idx": "cosqa-train-5664", "doc": "input a non string into function python", "code": "def get_input(input_func, input_str):\n    \"\"\"\n    Get input from the user given an input function and an input string\n    \"\"\"\n    val = input_func(\"Please enter your {0}: \".format(input_str))\n    while not val or not len(val.strip()):\n        val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))\n    return val", "code_tokens": "def get_input ( input_func , input_str ) : val = input_func ( \"Please enter your {0}: \" . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( \"You didn't enter a valid {0}, please try again: \" . format ( input_str ) ) return val", "docstring_tokens": "Get input from the user given an input function and an input string", "label": 0}, {"idx": "cosqa-train-5665", "doc": "python subtract 2 weeks from a date", "code": "def weekly(date=datetime.date.today()):\n    \"\"\"\n    Weeks start are fixes at Monday for now.\n    \"\"\"\n    return date - datetime.timedelta(days=date.weekday())", "code_tokens": "def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )", "docstring_tokens": "Weeks start are fixes at Monday for now .", "label": 0}, {"idx": "cosqa-train-5666", "doc": "input capital letters into number in alphabet in python", "code": "def camelcase(string):\n    \"\"\" Convert string into camel case.\n\n    Args:\n        string: String to convert.\n\n    Returns:\n        string: Camel case string.\n\n    \"\"\"\n\n    string = re.sub(r\"^[\\-_\\.]\", '', str(string))\n    if not string:\n        return string\n    return lowercase(string[0]) + re.sub(r\"[\\-_\\.\\s]([a-z])\", lambda matched: uppercase(matched.group(1)), string[1:])", "code_tokens": "def camelcase ( string ) : string = re . sub ( r\"^[\\-_\\.]\" , '' , str ( string ) ) if not string : return string return lowercase ( string [ 0 ] ) + re . sub ( r\"[\\-_\\.\\s]([a-z])\" , lambda matched : uppercase ( matched . group ( 1 ) ) , string [ 1 : ] )", "docstring_tokens": "Convert string into camel case .", "label": 0}, {"idx": "cosqa-train-5667", "doc": "python symbolic sin inverse", "code": "def asin(x):\n    \"\"\"\n    Inverse sine\n    \"\"\"\n    if isinstance(x, UncertainFunction):\n        mcpts = np.arcsin(x._mcpts)\n        return UncertainFunction(mcpts)\n    else:\n        return np.arcsin(x)", "code_tokens": "def asin ( x ) : if isinstance ( x , UncertainFunction ) : mcpts = np . arcsin ( x . _mcpts ) return UncertainFunction ( mcpts ) else : return np . arcsin ( x )", "docstring_tokens": "Inverse sine", "label": 0}, {"idx": "cosqa-train-5668", "doc": "insert and before the last item in list in python", "code": "def list_move_to_front(l,value='other'):\n    \"\"\"if the value is in the list, move it to the front and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n        l.insert(0,value)\n    return l", "code_tokens": "def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l", "docstring_tokens": "if the value is in the list move it to the front and return it .", "label": 1}, {"idx": "cosqa-train-5669", "doc": "python synchronized objects should only be", "code": "def synchronized(obj):\n  \"\"\"\n  This function has two purposes:\n\n  1. Decorate a function that automatically synchronizes access to the object\n     passed as the first argument (usually `self`, for member methods)\n  2. Synchronize access to the object, used in a `with`-statement.\n\n  Note that you can use #wait(), #notify() and #notify_all() only on\n  synchronized objects.\n\n  # Example\n  ```python\n  class Box(Synchronizable):\n    def __init__(self):\n      self.value = None\n    @synchronized\n    def get(self):\n      return self.value\n    @synchronized\n    def set(self, value):\n      self.value = value\n\n  box = Box()\n  box.set('foobar')\n  with synchronized(box):\n    box.value = 'taz\\'dingo'\n  print(box.get())\n  ```\n\n  # Arguments\n  obj (Synchronizable, function): The object to synchronize access to, or a\n    function to decorate.\n\n  # Returns\n  1. The decorated function.\n  2. The value of `obj.synchronizable_condition`, which should implement the\n     context-manager interface (to be used in a `with`-statement).\n  \"\"\"\n\n  if hasattr(obj, 'synchronizable_condition'):\n    return obj.synchronizable_condition\n  elif callable(obj):\n    @functools.wraps(obj)\n    def wrapper(self, *args, **kwargs):\n      with self.synchronizable_condition:\n        return obj(self, *args, **kwargs)\n    return wrapper\n  else:\n    raise TypeError('expected Synchronizable instance or callable to decorate')", "code_tokens": "def synchronized ( obj ) : if hasattr ( obj , 'synchronizable_condition' ) : return obj . synchronizable_condition elif callable ( obj ) : @ functools . wraps ( obj ) def wrapper ( self , * args , * * kwargs ) : with self . synchronizable_condition : return obj ( self , * args , * * kwargs ) return wrapper else : raise TypeError ( 'expected Synchronizable instance or callable to decorate' )", "docstring_tokens": "This function has two purposes :", "label": 0}, {"idx": "cosqa-train-5670", "doc": "insert image into pdf python", "code": "def main(filename):\n    \"\"\"\n    Creates a PDF by embedding the first page from the given image and\n    writes some text to it.\n\n    @param[in] filename\n        The source filename of the image to embed.\n    \"\"\"\n\n    # Prepare font.\n    font_family = 'arial'\n    font = Font(font_family, bold=True)\n    if not font:\n        raise RuntimeError('No font found for %r' % font_family)\n\n    # Initialize PDF document on a stream.\n    with Document('output.pdf') as document:\n\n        # Initialize a new page and begin its context.\n        with document.Page() as ctx:\n\n            # Open the image to embed.\n            with Image(filename) as embed:\n\n                # Set the media box for the page to the same as the\n                # image to embed.\n                ctx.box = embed.box\n\n                # Embed the image.\n                ctx.embed(embed)\n\n            # Write some text.\n            ctx.add(Text('Hello World', font, size=14, x=100, y=60))", "code_tokens": "def main ( filename ) : # Prepare font. font_family = 'arial' font = Font ( font_family , bold = True ) if not font : raise RuntimeError ( 'No font found for %r' % font_family ) # Initialize PDF document on a stream. with Document ( 'output.pdf' ) as document : # Initialize a new page and begin its context. with document . Page ( ) as ctx : # Open the image to embed. with Image ( filename ) as embed : # Set the media box for the page to the same as the # image to embed. ctx . box = embed . box # Embed the image. ctx . embed ( embed ) # Write some text. ctx . add ( Text ( 'Hello World' , font , size = 14 , x = 100 , y = 60 ) )", "docstring_tokens": "Creates a PDF by embedding the first page from the given image and writes some text to it .", "label": 1}, {"idx": "cosqa-train-5671", "doc": "python synchronous function call an async coroutine", "code": "def runcoro(async_function):\n    \"\"\"\n    Runs an asynchronous function without needing to use await - useful for lambda\n\n    Args:\n        async_function (Coroutine): The asynchronous function to run\n    \"\"\"\n\n    future = _asyncio.run_coroutine_threadsafe(async_function, client.loop)\n    result = future.result()\n    return result", "code_tokens": "def runcoro ( async_function ) : future = _asyncio . run_coroutine_threadsafe ( async_function , client . loop ) result = future . result ( ) return result", "docstring_tokens": "Runs an asynchronous function without needing to use await - useful for lambda", "label": 0}, {"idx": "cosqa-train-5672", "doc": "int to bool in python", "code": "def is_int(value):\n    \"\"\"Return `True` if ``value`` is an integer.\"\"\"\n    if isinstance(value, bool):\n        return False\n    try:\n        int(value)\n        return True\n    except (ValueError, TypeError):\n        return False", "code_tokens": "def is_int ( value ) : if isinstance ( value , bool ) : return False try : int ( value ) return True except ( ValueError , TypeError ) : return False", "docstring_tokens": "Return True if value is an integer .", "label": 1}, {"idx": "cosqa-train-5673", "doc": "python sys setdefaultencoding utf", "code": "def setencoding():\n    \"\"\"Set the string encoding used by the Unicode implementation.  The\n    default is 'ascii', but if you're willing to experiment, you can\n    change this.\"\"\"\n    encoding = \"ascii\" # Default value set by _PyUnicode_Init()\n    if 0:\n        # Enable to support locale aware default string encodings.\n        import locale\n        loc = locale.getdefaultlocale()\n        if loc[1]:\n            encoding = loc[1]\n    if 0:\n        # Enable to switch off string to Unicode coercion and implicit\n        # Unicode to string conversion.\n        encoding = \"undefined\"\n    if encoding != \"ascii\":\n        # On Non-Unicode builds this will raise an AttributeError...\n        sys.setdefaultencoding(encoding)", "code_tokens": "def setencoding ( ) : encoding = \"ascii\" # Default value set by _PyUnicode_Init() if 0 : # Enable to support locale aware default string encodings. import locale loc = locale . getdefaultlocale ( ) if loc [ 1 ] : encoding = loc [ 1 ] if 0 : # Enable to switch off string to Unicode coercion and implicit # Unicode to string conversion. encoding = \"undefined\" if encoding != \"ascii\" : # On Non-Unicode builds this will raise an AttributeError... sys . setdefaultencoding ( encoding )", "docstring_tokens": "Set the string encoding used by the Unicode implementation . The default is ascii but if you re willing to experiment you can change this .", "label": 0}, {"idx": "cosqa-train-5674", "doc": "interpolate x in list using python", "code": "def lin_interp(x, rangeX, rangeY):\n    \"\"\"\n    Interpolate linearly variable x in rangeX onto rangeY.\n    \"\"\"\n    s = (x - rangeX[0]) / mag(rangeX[1] - rangeX[0])\n    y = rangeY[0] * (1 - s) + rangeY[1] * s\n    return y", "code_tokens": "def lin_interp ( x , rangeX , rangeY ) : s = ( x - rangeX [ 0 ] ) / mag ( rangeX [ 1 ] - rangeX [ 0 ] ) y = rangeY [ 0 ] * ( 1 - s ) + rangeY [ 1 ] * s return y", "docstring_tokens": "Interpolate linearly variable x in rangeX onto rangeY .", "label": 0}, {"idx": "cosqa-train-5675", "doc": "python sys stdin remove new line", "code": "def pass_from_pipe(cls):\n        \"\"\"Return password from pipe if not on TTY, else False.\n        \"\"\"\n        is_pipe = not sys.stdin.isatty()\n        return is_pipe and cls.strip_last_newline(sys.stdin.read())", "code_tokens": "def pass_from_pipe ( cls ) : is_pipe = not sys . stdin . isatty ( ) return is_pipe and cls . strip_last_newline ( sys . stdin . read ( ) )", "docstring_tokens": "Return password from pipe if not on TTY else False .", "label": 0}, {"idx": "cosqa-train-5676", "doc": "interpolation in python using two column values at the same time", "code": "def lin_interp(x, rangeX, rangeY):\n    \"\"\"\n    Interpolate linearly variable x in rangeX onto rangeY.\n    \"\"\"\n    s = (x - rangeX[0]) / mag(rangeX[1] - rangeX[0])\n    y = rangeY[0] * (1 - s) + rangeY[1] * s\n    return y", "code_tokens": "def lin_interp ( x , rangeX , rangeY ) : s = ( x - rangeX [ 0 ] ) / mag ( rangeX [ 1 ] - rangeX [ 0 ] ) y = rangeY [ 0 ] * ( 1 - s ) + rangeY [ 1 ] * s return y", "docstring_tokens": "Interpolate linearly variable x in rangeX onto rangeY .", "label": 0}, {"idx": "cosqa-train-5677", "doc": "python systemd crash core dump gunicorn", "code": "def post_worker_init(worker):\n    \"\"\"Hook into Gunicorn to display message after launching.\n\n    This mimics the behaviour of Django's stock runserver command.\n    \"\"\"\n    quit_command = 'CTRL-BREAK' if sys.platform == 'win32' else 'CONTROL-C'\n    sys.stdout.write(\n        \"Django version {djangover}, Gunicorn version {gunicornver}, \"\n        \"using settings {settings!r}\\n\"\n        \"Starting development server at {urls}\\n\"\n        \"Quit the server with {quit_command}.\\n\".format(\n            djangover=django.get_version(),\n            gunicornver=gunicorn.__version__,\n            settings=os.environ.get('DJANGO_SETTINGS_MODULE'),\n            urls=', '.join('http://{0}/'.format(b) for b in worker.cfg.bind),\n            quit_command=quit_command,\n        ),\n    )", "code_tokens": "def post_worker_init ( worker ) : quit_command = 'CTRL-BREAK' if sys . platform == 'win32' else 'CONTROL-C' sys . stdout . write ( \"Django version {djangover}, Gunicorn version {gunicornver}, \" \"using settings {settings!r}\\n\" \"Starting development server at {urls}\\n\" \"Quit the server with {quit_command}.\\n\" . format ( djangover = django . get_version ( ) , gunicornver = gunicorn . __version__ , settings = os . environ . get ( 'DJANGO_SETTINGS_MODULE' ) , urls = ', ' . join ( 'http://{0}/' . format ( b ) for b in worker . cfg . bind ) , quit_command = quit_command , ) , )", "docstring_tokens": "Hook into Gunicorn to display message after launching .", "label": 1}, {"idx": "cosqa-train-5678", "doc": "is a set iterable python", "code": "def unique_everseen(iterable, filterfalse_=itertools.filterfalse):\n    \"\"\"Unique elements, preserving order.\"\"\"\n    # Itertools recipes:\n    # https://docs.python.org/3/library/itertools.html#itertools-recipes\n    seen = set()\n    seen_add = seen.add\n    for element in filterfalse_(seen.__contains__, iterable):\n        seen_add(element)\n        yield element", "code_tokens": "def unique_everseen ( iterable , filterfalse_ = itertools . filterfalse ) : # Itertools recipes:\n # https://docs.python.org/3/library/itertools.html#itertools-recipes\n seen = set ( ) seen_add = seen . add for element in filterfalse_ ( seen . __contains__ , iterable ) : seen_add ( element ) yield element", "docstring_tokens": "Unique elements preserving order .", "label": 0}, {"idx": "cosqa-train-5679", "doc": "python take max across arrays", "code": "def findMax(arr):\n    \"\"\"\n    in comparison to argrelmax() more simple and  reliable peak finder\n    \"\"\"\n    out = np.zeros(shape=arr.shape, dtype=bool)\n    _calcMax(arr, out)\n    return out", "code_tokens": "def findMax ( arr ) : out = np . zeros ( shape = arr . shape , dtype = bool ) _calcMax ( arr , out ) return out", "docstring_tokens": "in comparison to argrelmax () more simple and reliable peak finder", "label": 0}, {"idx": "cosqa-train-5680", "doc": "is python able use a printer", "code": "def raw_print(*args, **kw):\n    \"\"\"Raw print to sys.__stdout__, otherwise identical interface to print().\"\"\"\n\n    print(*args, sep=kw.get('sep', ' '), end=kw.get('end', '\\n'),\n          file=sys.__stdout__)\n    sys.__stdout__.flush()", "code_tokens": "def raw_print ( * args , * * kw ) : print ( * args , sep = kw . get ( 'sep' , ' ' ) , end = kw . get ( 'end' , '\\n' ) , file = sys . __stdout__ ) sys . __stdout__ . flush ( )", "docstring_tokens": "Raw print to sys . __stdout__ otherwise identical interface to print () .", "label": 0}, {"idx": "cosqa-train-5681", "doc": "python tell if a file is not there", "code": "def file_found(filename,force):\n    \"\"\"Check if a file exists\"\"\"\n    if os.path.exists(filename) and not force:\n        logger.info(\"Found %s; skipping...\"%filename)\n        return True\n    else:\n        return False", "code_tokens": "def file_found ( filename , force ) : if os . path . exists ( filename ) and not force : logger . info ( \"Found %s; skipping...\" % filename ) return True else : return False", "docstring_tokens": "Check if a file exists", "label": 0}, {"idx": "cosqa-train-5682", "doc": "is there a python function that rounds off integers", "code": "def specialRound(number, rounding):\n    \"\"\"A method used to round a number in the way that UsefulUtils rounds.\"\"\"\n    temp = 0\n    if rounding == 0:\n        temp = number\n    else:\n        temp =  round(number, rounding)\n    if temp % 1 == 0:\n        return int(temp)\n    else:\n        return float(temp)", "code_tokens": "def specialRound ( number , rounding ) : temp = 0 if rounding == 0 : temp = number else : temp = round ( number , rounding ) if temp % 1 == 0 : return int ( temp ) else : return float ( temp )", "docstring_tokens": "A method used to round a number in the way that UsefulUtils rounds .", "label": 0}, {"idx": "cosqa-train-5683", "doc": "python tell if request has timed out", "code": "def _request_limit_reached(exception):\n    \"\"\" Checks if exception was raised because of too many executed requests. (This is a temporal solution and\n    will be changed in later package versions.)\n\n    :param exception: Exception raised during download\n    :type exception: Exception\n    :return: True if exception is caused because too many requests were executed at once and False otherwise\n    :rtype: bool\n    \"\"\"\n    return isinstance(exception, requests.HTTPError) and \\\n        exception.response.status_code == requests.status_codes.codes.TOO_MANY_REQUESTS", "code_tokens": "def _request_limit_reached ( exception ) : return isinstance ( exception , requests . HTTPError ) and exception . response . status_code == requests . status_codes . codes . TOO_MANY_REQUESTS", "docstring_tokens": "Checks if exception was raised because of too many executed requests . ( This is a temporal solution and will be changed in later package versions . )", "label": 0}, {"idx": "cosqa-train-5684", "doc": "is there a way to run a bash script in python", "code": "def bash(filename):\n    \"\"\"Runs a bash script in the local directory\"\"\"\n    sys.stdout.flush()\n    subprocess.call(\"bash {}\".format(filename), shell=True)", "code_tokens": "def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( \"bash {}\" . format ( filename ) , shell = True )", "docstring_tokens": "Runs a bash script in the local directory", "label": 0}, {"idx": "cosqa-train-5685", "doc": "python tell if windows or linux", "code": "def _platform_is_windows(platform=sys.platform):\n        \"\"\"Is the current OS a Windows?\"\"\"\n        matched = platform in ('cygwin', 'win32', 'win64')\n        if matched:\n            error_msg = \"Windows isn't supported yet\"\n            raise OSError(error_msg)\n        return matched", "code_tokens": "def _platform_is_windows ( platform = sys . platform ) : matched = platform in ( 'cygwin' , 'win32' , 'win64' ) if matched : error_msg = \"Windows isn't supported yet\" raise OSError ( error_msg ) return matched", "docstring_tokens": "Is the current OS a Windows?", "label": 1}, {"idx": "cosqa-train-5686", "doc": "is there any function in python to count the most common value in a list", "code": "def _most_common(iterable):\n    \"\"\"Returns the most common element in `iterable`.\"\"\"\n    data = Counter(iterable)\n    return max(data, key=data.__getitem__)", "code_tokens": "def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )", "docstring_tokens": "Returns the most common element in iterable .", "label": 0}, {"idx": "cosqa-train-5687", "doc": "python tensorflow node names", "code": "def get_tensor_device(self, tensor_name):\n    \"\"\"The device of a tensor.\n\n    Note that only tf tensors have device assignments.\n\n    Args:\n      tensor_name: a string, name of a tensor in the graph.\n\n    Returns:\n      a string or None, representing the device name.\n    \"\"\"\n    tensor = self._name_to_tensor(tensor_name)\n    if isinstance(tensor, tf.Tensor):\n      return tensor.device\n    else:  # mtf.Tensor\n      return None", "code_tokens": "def get_tensor_device ( self , tensor_name ) : tensor = self . _name_to_tensor ( tensor_name ) if isinstance ( tensor , tf . Tensor ) : return tensor . device else : # mtf.Tensor return None", "docstring_tokens": "The device of a tensor .", "label": 0}, {"idx": "cosqa-train-5688", "doc": "isnull values removal in python", "code": "def mask_nonfinite(self):\n        \"\"\"Extend the mask with the image elements where the intensity is NaN.\"\"\"\n        self.mask = np.logical_and(self.mask, (np.isfinite(self.intensity)))", "code_tokens": "def mask_nonfinite ( self ) : self . mask = np . logical_and ( self . mask , ( np . isfinite ( self . intensity ) ) )", "docstring_tokens": "Extend the mask with the image elements where the intensity is NaN .", "label": 0}, {"idx": "cosqa-train-5689", "doc": "python tensorflow tf global variables initializer", "code": "def sg_init(sess):\n    r\"\"\" Initializes session variables.\n    \n    Args:\n      sess: Session to initialize. \n    \"\"\"\n    # initialize variables\n    sess.run(tf.group(tf.global_variables_initializer(),\n                      tf.local_variables_initializer()))", "code_tokens": "def sg_init ( sess ) : # initialize variables sess . run ( tf . group ( tf . global_variables_initializer ( ) , tf . local_variables_initializer ( ) ) )", "docstring_tokens": "r Initializes session variables . Args : sess : Session to initialize .", "label": 0}, {"idx": "cosqa-train-5690", "doc": "iso format to datetime python", "code": "async def iso(self, source):\n        \"\"\"Convert to timestamp.\"\"\"\n        from datetime import datetime\n        unix_timestamp = int(source)\n        return datetime.fromtimestamp(unix_timestamp).isoformat()", "code_tokens": "async def iso ( self , source ) : from datetime import datetime unix_timestamp = int ( source ) return datetime . fromtimestamp ( unix_timestamp ) . isoformat ( )", "docstring_tokens": "Convert to timestamp .", "label": 0}, {"idx": "cosqa-train-5691", "doc": "python terminate function after time", "code": "def main(args):\n    \"\"\"\n    invoke wptools and exit safely\n    \"\"\"\n    start = time.time()\n    output = get(args)\n    _safe_exit(start, output)", "code_tokens": "def main ( args ) : start = time . time ( ) output = get ( args ) _safe_exit ( start , output )", "docstring_tokens": "invoke wptools and exit safely", "label": 0}, {"idx": "cosqa-train-5692", "doc": "iterate over chunksize in range python", "code": "def chunks(iterable, n):\n    \"\"\"Yield successive n-sized chunks from iterable object. https://stackoverflow.com/a/312464 \"\"\"\n    for i in range(0, len(iterable), n):\n        yield iterable[i:i + n]", "code_tokens": "def chunks ( iterable , n ) : for i in range ( 0 , len ( iterable ) , n ) : yield iterable [ i : i + n ]", "docstring_tokens": "Yield successive n - sized chunks from iterable object . https : // stackoverflow . com / a / 312464", "label": 0}, {"idx": "cosqa-train-5693", "doc": "python test if array or list", "code": "def is_listish(obj):\n    \"\"\"Check if something quacks like a list.\"\"\"\n    if isinstance(obj, (list, tuple, set)):\n        return True\n    return is_sequence(obj)", "code_tokens": "def is_listish ( obj ) : if isinstance ( obj , ( list , tuple , set ) ) : return True return is_sequence ( obj )", "docstring_tokens": "Check if something quacks like a list .", "label": 0}, {"idx": "cosqa-train-5694", "doc": "iterator from dict keys python", "code": "def itervalues(d, **kw):\n    \"\"\"Return an iterator over the values of a dictionary.\"\"\"\n    if not PY2:\n        return iter(d.values(**kw))\n    return d.itervalues(**kw)", "code_tokens": "def itervalues ( d , * * kw ) : if not PY2 : return iter ( d . values ( * * kw ) ) return d . itervalues ( * * kw )", "docstring_tokens": "Return an iterator over the values of a dictionary .", "label": 0}, {"idx": "cosqa-train-5695", "doc": "python test if binary file", "code": "def is_binary(filename):\n    \"\"\" Returns True if the file is binary\n\n    \"\"\"\n    with open(filename, 'rb') as fp:\n        data = fp.read(1024)\n        if not data:\n            return False\n        if b'\\0' in data:\n            return True\n        return False", "code_tokens": "def is_binary ( filename ) : with open ( filename , 'rb' ) as fp : data = fp . read ( 1024 ) if not data : return False if b'\\0' in data : return True return False", "docstring_tokens": "Returns True if the file is binary", "label": 1}, {"idx": "cosqa-train-5696", "doc": "itertools python group by multiple keys", "code": "def group_by(iterable, key_func):\n    \"\"\"Wrap itertools.groupby to make life easier.\"\"\"\n    groups = (\n        list(sub) for key, sub in groupby(iterable, key_func)\n    )\n    return zip(groups, groups)", "code_tokens": "def group_by ( iterable , key_func ) : groups = ( list ( sub ) for key , sub in groupby ( iterable , key_func ) ) return zip ( groups , groups )", "docstring_tokens": "Wrap itertools . groupby to make life easier .", "label": 0}, {"idx": "cosqa-train-5697", "doc": "python test matrix singualrity", "code": "def is_square_matrix(mat):\n    \"\"\"Test if an array is a square matrix.\"\"\"\n    mat = np.array(mat)\n    if mat.ndim != 2:\n        return False\n    shape = mat.shape\n    return shape[0] == shape[1]", "code_tokens": "def is_square_matrix ( mat ) : mat = np . array ( mat ) if mat . ndim != 2 : return False shape = mat . shape return shape [ 0 ] == shape [ 1 ]", "docstring_tokens": "Test if an array is a square matrix .", "label": 0}, {"idx": "cosqa-train-5698", "doc": "java 2 dimensional array return python", "code": "def string_list_to_array(l):\n    \"\"\"\n    Turns a Python unicode string list into a Java String array.\n\n    :param l: the string list\n    :type: list\n    :rtype: java string array\n    :return: JB_Object\n    \"\"\"\n    result = javabridge.get_env().make_object_array(len(l), javabridge.get_env().find_class(\"java/lang/String\"))\n    for i in range(len(l)):\n        javabridge.get_env().set_object_array_element(result, i, javabridge.get_env().new_string_utf(l[i]))\n    return result", "code_tokens": "def string_list_to_array ( l ) : result = javabridge . get_env ( ) . make_object_array ( len ( l ) , javabridge . get_env ( ) . find_class ( \"java/lang/String\" ) ) for i in range ( len ( l ) ) : javabridge . get_env ( ) . set_object_array_element ( result , i , javabridge . get_env ( ) . new_string_utf ( l [ i ] ) ) return result", "docstring_tokens": "Turns a Python unicode string list into a Java String array .", "label": 1}, {"idx": "cosqa-train-5699", "doc": "python test whether variable is a collection of atomic type", "code": "def contains_geometric_info(var):\n    \"\"\" Check whether the passed variable is a tuple with two floats or integers \"\"\"\n    return isinstance(var, tuple) and len(var) == 2 and all(isinstance(val, (int, float)) for val in var)", "code_tokens": "def contains_geometric_info ( var ) : return isinstance ( var , tuple ) and len ( var ) == 2 and all ( isinstance ( val , ( int , float ) ) for val in var )", "docstring_tokens": "Check whether the passed variable is a tuple with two floats or integers", "label": 0}, {"idx": "cosqa-train-5700", "doc": "java con't run python with runtime in windows", "code": "def test_python_java_rt():\n    \"\"\" Run Python test cases against Java runtime classes. \"\"\"\n    sub_env = {'PYTHONPATH': _build_dir()}\n\n    log.info('Executing Python unit tests (against Java runtime classes)...')\n    return jpyutil._execute_python_scripts(python_java_rt_tests,\n                                           env=sub_env)", "code_tokens": "def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )", "docstring_tokens": "Run Python test cases against Java runtime classes .", "label": 0}, {"idx": "cosqa-train-5701", "doc": "python test, how to make sure data format is correct", "code": "def _check_format(file_path, content):\n    \"\"\" check testcase format if valid\n    \"\"\"\n    # TODO: replace with JSON schema validation\n    if not content:\n        # testcase file content is empty\n        err_msg = u\"Testcase file content is empty: {}\".format(file_path)\n        logger.log_error(err_msg)\n        raise exceptions.FileFormatError(err_msg)\n\n    elif not isinstance(content, (list, dict)):\n        # testcase file content does not match testcase format\n        err_msg = u\"Testcase file content format invalid: {}\".format(file_path)\n        logger.log_error(err_msg)\n        raise exceptions.FileFormatError(err_msg)", "code_tokens": "def _check_format ( file_path , content ) : # TODO: replace with JSON schema validation if not content : # testcase file content is empty err_msg = u\"Testcase file content is empty: {}\" . format ( file_path ) logger . log_error ( err_msg ) raise exceptions . FileFormatError ( err_msg ) elif not isinstance ( content , ( list , dict ) ) : # testcase file content does not match testcase format err_msg = u\"Testcase file content format invalid: {}\" . format ( file_path ) logger . log_error ( err_msg ) raise exceptions . FileFormatError ( err_msg )", "docstring_tokens": "check testcase format if valid", "label": 0}, {"idx": "cosqa-train-5702", "doc": "js object to python json without quota", "code": "def dump_json(obj):\n    \"\"\"Dump Python object as JSON string.\"\"\"\n    return simplejson.dumps(obj, ignore_nan=True, default=json_util.default)", "code_tokens": "def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )", "docstring_tokens": "Dump Python object as JSON string .", "label": 0}, {"idx": "cosqa-train-5703", "doc": "python textwrap without cutting up words", "code": "def do_wordwrap(s, width=79, break_long_words=True):\n    \"\"\"\n    Return a copy of the string passed to the filter wrapped after\n    ``79`` characters.  You can override this default using the first\n    parameter.  If you set the second parameter to `false` Jinja will not\n    split words apart if they are longer than `width`.\n    \"\"\"\n    import textwrap\n    return u'\\n'.join(textwrap.wrap(s, width=width, expand_tabs=False,\n                                   replace_whitespace=False,\n                                   break_long_words=break_long_words))", "code_tokens": "def do_wordwrap ( s , width = 79 , break_long_words = True ) : import textwrap return u'\\n' . join ( textwrap . wrap ( s , width = width , expand_tabs = False , replace_whitespace = False , break_long_words = break_long_words ) )", "docstring_tokens": "Return a copy of the string passed to the filter wrapped after 79 characters . You can override this default using the first parameter . If you set the second parameter to false Jinja will not split words apart if they are longer than width .", "label": 0}, {"idx": "cosqa-train-5704", "doc": "json boolean to python", "code": "def from_json(value, **kwargs):\n        \"\"\"Coerces JSON string to boolean\"\"\"\n        if isinstance(value, string_types):\n            value = value.upper()\n            if value in ('TRUE', 'Y', 'YES', 'ON'):\n                return True\n            if value in ('FALSE', 'N', 'NO', 'OFF'):\n                return False\n        if isinstance(value, int):\n            return value\n        raise ValueError('Could not load boolean from JSON: {}'.format(value))", "code_tokens": "def from_json ( value , * * kwargs ) : if isinstance ( value , string_types ) : value = value . upper ( ) if value in ( 'TRUE' , 'Y' , 'YES' , 'ON' ) : return True if value in ( 'FALSE' , 'N' , 'NO' , 'OFF' ) : return False if isinstance ( value , int ) : return value raise ValueError ( 'Could not load boolean from JSON: {}' . format ( value ) )", "docstring_tokens": "Coerces JSON string to boolean", "label": 0}, {"idx": "cosqa-train-5705", "doc": "python the best way to detect adege of image", "code": "def is_progressive(image):\n    \"\"\"\n    Check to see if an image is progressive.\n    \"\"\"\n    if not isinstance(image, Image.Image):\n        # Can only check PIL images for progressive encoding.\n        return False\n    return ('progressive' in image.info) or ('progression' in image.info)", "code_tokens": "def is_progressive ( image ) : if not isinstance ( image , Image . Image ) : # Can only check PIL images for progressive encoding. return False return ( 'progressive' in image . info ) or ( 'progression' in image . info )", "docstring_tokens": "Check to see if an image is progressive .", "label": 0}, {"idx": "cosqa-train-5706", "doc": "json dump is not serializable python 2 to python 3", "code": "def json_dumps(self, obj):\n        \"\"\"Serializer for consistency\"\"\"\n        return json.dumps(obj, sort_keys=True, indent=4, separators=(',', ': '))", "code_tokens": "def json_dumps ( self , obj ) : return json . dumps ( obj , sort_keys = True , indent = 4 , separators = ( ',' , ': ' ) )", "docstring_tokens": "Serializer for consistency", "label": 0}, {"idx": "cosqa-train-5707", "doc": "python threading condition lock", "code": "def set(self):\n        \"\"\"Set the internal flag to true.\n\n        All threads waiting for the flag to become true are awakened. Threads\n        that call wait() once the flag is true will not block at all.\n\n        \"\"\"\n        with self.__cond:\n            self.__flag = True\n            self.__cond.notify_all()", "code_tokens": "def set ( self ) : with self . __cond : self . __flag = True self . __cond . notify_all ( )", "docstring_tokens": "Set the internal flag to true .", "label": 0}, {"idx": "cosqa-train-5708", "doc": "json encoder python custom object", "code": "def dumps(obj):\n    \"\"\"Outputs json with formatting edits + object handling.\"\"\"\n    return json.dumps(obj, indent=4, sort_keys=True, cls=CustomEncoder)", "code_tokens": "def dumps ( obj ) : return json . dumps ( obj , indent = 4 , sort_keys = True , cls = CustomEncoder )", "docstring_tokens": "Outputs json with formatting edits + object handling .", "label": 0}, {"idx": "cosqa-train-5709", "doc": "python time complexity measure", "code": "def estimate_complexity(self, x,y,z,n):\n        \"\"\" \n        calculates a rough guess of runtime based on product of parameters \n        \"\"\"\n        num_calculations = x * y * z * n\n        run_time = num_calculations / 100000  # a 2014 PC does about 100k calcs in a second (guess based on prior logs)\n        return self.show_time_as_short_string(run_time)", "code_tokens": "def estimate_complexity ( self , x , y , z , n ) : num_calculations = x * y * z * n run_time = num_calculations / 100000 # a 2014 PC does about 100k calcs in a second (guess based on prior logs) return self . show_time_as_short_string ( run_time )", "docstring_tokens": "calculates a rough guess of runtime based on product of parameters", "label": 0}, {"idx": "cosqa-train-5710", "doc": "json load get u strings python", "code": "def read_json(location):\n    \"\"\"Open and load JSON from file.\n\n    location (Path): Path to JSON file.\n    RETURNS (dict): Loaded JSON content.\n    \"\"\"\n    location = ensure_path(location)\n    with location.open('r', encoding='utf8') as f:\n        return ujson.load(f)", "code_tokens": "def read_json ( location ) : location = ensure_path ( location ) with location . open ( 'r' , encoding = 'utf8' ) as f : return ujson . load ( f )", "docstring_tokens": "Open and load JSON from file .", "label": 0}, {"idx": "cosqa-train-5711", "doc": "kali linux python webdriver chrome", "code": "def is_webdriver_ios(webdriver):\n        \"\"\"\n        Check if a web driver if mobile.\n\n        Args:\n            webdriver (WebDriver): Selenium webdriver.\n\n        \"\"\"\n        browser = webdriver.capabilities['browserName']\n\n        if (browser == u('iPhone') or \n            browser == u('iPad')):\n            return True\n        else:\n            return False", "code_tokens": "def is_webdriver_ios ( webdriver ) : browser = webdriver . capabilities [ 'browserName' ] if ( browser == u ( 'iPhone' ) or browser == u ( 'iPad' ) ) : return True else : return False", "docstring_tokens": "Check if a web driver if mobile .", "label": 0}, {"idx": "cosqa-train-5712", "doc": "python time from string to minute", "code": "def hms_to_seconds(time_string):\n    \"\"\"\n    Converts string 'hh:mm:ss.ssssss' as a float\n    \"\"\"\n    s = time_string.split(':')\n    hours = int(s[0])\n    minutes = int(s[1])\n    secs = float(s[2])\n    return hours * 3600 + minutes * 60 + secs", "code_tokens": "def hms_to_seconds ( time_string ) : s = time_string . split ( ':' ) hours = int ( s [ 0 ] ) minutes = int ( s [ 1 ] ) secs = float ( s [ 2 ] ) return hours * 3600 + minutes * 60 + secs", "docstring_tokens": "Converts string hh : mm : ss . ssssss as a float", "label": 0}, {"idx": "cosqa-train-5713", "doc": "key function to sort by filter in sorted python3", "code": "def sort_func(self, key):\n        \"\"\"Sorting logic for `Quantity` objects.\"\"\"\n        if key == self._KEYS.VALUE:\n            return 'aaa'\n        if key == self._KEYS.SOURCE:\n            return 'zzz'\n        return key", "code_tokens": "def sort_func ( self , key ) : if key == self . _KEYS . VALUE : return 'aaa' if key == self . _KEYS . SOURCE : return 'zzz' return key", "docstring_tokens": "Sorting logic for Quantity objects .", "label": 1}, {"idx": "cosqa-train-5714", "doc": "python timezone pytz fromutc", "code": "def fromtimestamp(cls, timestamp):\n    \"\"\"Returns a datetime object of a given timestamp (in local tz).\"\"\"\n    d = cls.utcfromtimestamp(timestamp)\n    return d.astimezone(localtz())", "code_tokens": "def fromtimestamp ( cls , timestamp ) : d = cls . utcfromtimestamp ( timestamp ) return d . astimezone ( localtz ( ) )", "docstring_tokens": "Returns a datetime object of a given timestamp ( in local tz ) .", "label": 0}, {"idx": "cosqa-train-5715", "doc": "key in sorted function python", "code": "def sort_func(self, key):\n        \"\"\"Sorting logic for `Quantity` objects.\"\"\"\n        if key == self._KEYS.VALUE:\n            return 'aaa'\n        if key == self._KEYS.SOURCE:\n            return 'zzz'\n        return key", "code_tokens": "def sort_func ( self , key ) : if key == self . _KEYS . VALUE : return 'aaa' if key == self . _KEYS . SOURCE : return 'zzz' return key", "docstring_tokens": "Sorting logic for Quantity objects .", "label": 1}, {"idx": "cosqa-train-5716", "doc": "python tkinter bind unchecking checkbutton", "code": "def checkbox_uncheck(self, force_check=False):\n        \"\"\"\n        Wrapper to uncheck a checkbox\n        \"\"\"\n        if self.get_attribute('checked'):\n            self.click(force_click=force_check)", "code_tokens": "def checkbox_uncheck ( self , force_check = False ) : if self . get_attribute ( 'checked' ) : self . click ( force_click = force_check )", "docstring_tokens": "Wrapper to uncheck a checkbox", "label": 0}, {"idx": "cosqa-train-5717", "doc": "keyboard shortcut to stop python code", "code": "def stop_button_click_handler(self):\n        \"\"\"Method to handle what to do when the stop button is pressed\"\"\"\n        self.stop_button.setDisabled(True)\n        # Interrupt computations or stop debugging\n        if not self.shellwidget._reading:\n            self.interrupt_kernel()\n        else:\n            self.shellwidget.write_to_stdin('exit')", "code_tokens": "def stop_button_click_handler ( self ) : self . stop_button . setDisabled ( True ) # Interrupt computations or stop debugging\n if not self . shellwidget . _reading : self . interrupt_kernel ( ) else : self . shellwidget . write_to_stdin ( 'exit' )", "docstring_tokens": "Method to handle what to do when the stop button is pressed", "label": 1}, {"idx": "cosqa-train-5718", "doc": "python tkinter calling an event to close gui window", "code": "def closeEvent(self, e):\n        \"\"\"Qt slot when the window is closed.\"\"\"\n        self.emit('close_widget')\n        super(DockWidget, self).closeEvent(e)", "code_tokens": "def closeEvent ( self , e ) : self . emit ( 'close_widget' ) super ( DockWidget , self ) . closeEvent ( e )", "docstring_tokens": "Qt slot when the window is closed .", "label": 0}, {"idx": "cosqa-train-5719", "doc": "keypress event python in a window", "code": "def on_key_press(self, symbol, modifiers):\n        \"\"\"\n        Pyglet specific key press callback.\n        Forwards and translates the events to :py:func:`keyboard_event`\n        \"\"\"\n        self.keyboard_event(symbol, self.keys.ACTION_PRESS, modifiers)", "code_tokens": "def on_key_press ( self , symbol , modifiers ) : self . keyboard_event ( symbol , self . keys . ACTION_PRESS , modifiers )", "docstring_tokens": "Pyglet specific key press callback . Forwards and translates the events to : py : func : keyboard_event", "label": 0}, {"idx": "cosqa-train-5720", "doc": "python tkinter delete text last line", "code": "def _end_del(self):\n        \"\"\" Deletes the line content after the cursor  \"\"\"\n        text = self.edit_text[:self.edit_pos]\n        self.set_edit_text(text)", "code_tokens": "def _end_del ( self ) : text = self . edit_text [ : self . edit_pos ] self . set_edit_text ( text )", "docstring_tokens": "Deletes the line content after the cursor", "label": 0}, {"idx": "cosqa-train-5721", "doc": "killing server python sigint", "code": "def sigterm(self, signum, frame):\n        \"\"\"\n        These actions will be done after SIGTERM.\n        \"\"\"\n        self.logger.warning(\"Caught signal %s. Stopping daemon.\" % signum)\n        sys.exit(0)", "code_tokens": "def sigterm ( self , signum , frame ) : self . logger . warning ( \"Caught signal %s. Stopping daemon.\" % signum ) sys . exit ( 0 )", "docstring_tokens": "These actions will be done after SIGTERM .", "label": 0}, {"idx": "cosqa-train-5722", "doc": "python tkinter get the position of a widget", "code": "def _get(self, pos):\n        \"\"\"loads widget at given position; handling invalid arguments\"\"\"\n        res = None, None\n        if pos is not None:\n            try:\n                res = self[pos], pos\n            except (IndexError, KeyError):\n                pass\n        return res", "code_tokens": "def _get ( self , pos ) : res = None , None if pos is not None : try : res = self [ pos ] , pos except ( IndexError , KeyError ) : pass return res", "docstring_tokens": "loads widget at given position ; handling invalid arguments", "label": 0}, {"idx": "cosqa-train-5723", "doc": "last accessed time file python", "code": "def get_access_datetime(filepath):\n    \"\"\"\n    Get the last time filepath was accessed.\n\n    Parameters\n    ----------\n    filepath : str\n\n    Returns\n    -------\n    access_datetime : datetime.datetime\n    \"\"\"\n    import tzlocal\n    tz = tzlocal.get_localzone()\n    mtime = datetime.fromtimestamp(os.path.getatime(filepath))\n    return mtime.replace(tzinfo=tz)", "code_tokens": "def get_access_datetime ( filepath ) : import tzlocal tz = tzlocal . get_localzone ( ) mtime = datetime . fromtimestamp ( os . path . getatime ( filepath ) ) return mtime . replace ( tzinfo = tz )", "docstring_tokens": "Get the last time filepath was accessed .", "label": 0}, {"idx": "cosqa-train-5724", "doc": "python tkinter hide window", "code": "def hide(self):\n        \"\"\"Hide the window.\"\"\"\n        self.tk.withdraw()\n        self._visible = False\n        if self._modal:\n            self.tk.grab_release()", "code_tokens": "def hide ( self ) : self . tk . withdraw ( ) self . _visible = False if self . _modal : self . tk . grab_release ( )", "docstring_tokens": "Hide the window .", "label": 0}, {"idx": "cosqa-train-5725", "doc": "last n lines of a command in python", "code": "def clear_last_lines(self, n):\n        \"\"\"Clear last N lines of terminal output.\n        \"\"\"\n        self.term.stream.write(\n            self.term.move_up * n + self.term.clear_eos)\n        self.term.stream.flush()", "code_tokens": "def clear_last_lines ( self , n ) : self . term . stream . write ( self . term . move_up * n + self . term . clear_eos ) self . term . stream . flush ( )", "docstring_tokens": "Clear last N lines of terminal output .", "label": 0}, {"idx": "cosqa-train-5726", "doc": "python tkinter scale if value changed", "code": "def _on_scale(self, event):\n        \"\"\"\n        Callback for the Scale widget, inserts an int value into the Entry.\n\n        :param event: Tkinter event\n        \"\"\"\n        self._entry.delete(0, tk.END)\n        self._entry.insert(0, str(self._variable.get()))", "code_tokens": "def _on_scale ( self , event ) : self . _entry . delete ( 0 , tk . END ) self . _entry . insert ( 0 , str ( self . _variable . get ( ) ) )", "docstring_tokens": "Callback for the Scale widget inserts an int value into the Entry .", "label": 0}, {"idx": "cosqa-train-5727", "doc": "latex notation python spyder", "code": "def print_latex(o):\n    \"\"\"A function to generate the latex representation of sympy\n    expressions.\"\"\"\n    if can_print_latex(o):\n        s = latex(o, mode='plain')\n        s = s.replace('\\\\dag','\\\\dagger')\n        s = s.strip('$')\n        return '$$%s$$' % s\n    # Fallback to the string printer\n    return None", "code_tokens": "def print_latex ( o ) : if can_print_latex ( o ) : s = latex ( o , mode = 'plain' ) s = s . replace ( '\\\\dag' , '\\\\dagger' ) s = s . strip ( '$' ) return '$$%s$$' % s # Fallback to the string printer return None", "docstring_tokens": "A function to generate the latex representation of sympy expressions .", "label": 0}, {"idx": "cosqa-train-5728", "doc": "python to capitalize letter", "code": "def to_pascal_case(s):\n    \"\"\"Transform underscore separated string to pascal case\n\n    \"\"\"\n    return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())", "code_tokens": "def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )", "docstring_tokens": "Transform underscore separated string to pascal case", "label": 0}, {"idx": "cosqa-train-5729", "doc": "latitude and longitude map python", "code": "def Distance(lat1, lon1, lat2, lon2):\n    \"\"\"Get distance between pairs of lat-lon points\"\"\"\n\n    az12, az21, dist = wgs84_geod.inv(lon1, lat1, lon2, lat2)\n    return az21, dist", "code_tokens": "def Distance ( lat1 , lon1 , lat2 , lon2 ) : az12 , az21 , dist = wgs84_geod . inv ( lon1 , lat1 , lon2 , lat2 ) return az21 , dist", "docstring_tokens": "Get distance between pairs of lat - lon points", "label": 0}, {"idx": "cosqa-train-5730", "doc": "python to concatinate multiple pdf files", "code": "def merge_pdfs(pdf_filepaths, out_filepath):\n    \"\"\" Merge all the PDF files in `pdf_filepaths` in a new PDF file `out_filepath`.\n\n    Parameters\n    ----------\n    pdf_filepaths: list of str\n        Paths to PDF files.\n\n    out_filepath: str\n        Path to the result PDF file.\n\n    Returns\n    -------\n    path: str\n        The output file path.\n    \"\"\"\n    merger = PdfFileMerger()\n    for pdf in pdf_filepaths:\n        merger.append(PdfFileReader(open(pdf, 'rb')))\n\n    merger.write(out_filepath)\n\n    return out_filepath", "code_tokens": "def merge_pdfs ( pdf_filepaths , out_filepath ) : merger = PdfFileMerger ( ) for pdf in pdf_filepaths : merger . append ( PdfFileReader ( open ( pdf , 'rb' ) ) ) merger . write ( out_filepath ) return out_filepath", "docstring_tokens": "Merge all the PDF files in pdf_filepaths in a new PDF file out_filepath .", "label": 0}, {"idx": "cosqa-train-5731", "doc": "lazy with file write yield python", "code": "def write_to(f, mode):\n    \"\"\"Flexible writing, where f can be a filename or f object, if filename, closed after writing\"\"\"\n    if hasattr(f, 'write'):\n        yield f\n    else:\n        f = open(f, mode)\n        yield f\n        f.close()", "code_tokens": "def write_to ( f , mode ) : if hasattr ( f , 'write' ) : yield f else : f = open ( f , mode ) yield f f . close ( )", "docstring_tokens": "Flexible writing where f can be a filename or f object if filename closed after writing", "label": 0}, {"idx": "cosqa-train-5732", "doc": "python to get all ec2 instances with tags", "code": "def _aws_get_instance_by_tag(region, name, tag, raw):\n    \"\"\"Get all instances matching a tag.\"\"\"\n    client = boto3.session.Session().client('ec2', region)\n    matching_reservations = client.describe_instances(Filters=[{'Name': tag, 'Values': [name]}]).get('Reservations', [])\n    instances = []\n    [[instances.append(_aws_instance_from_dict(region, instance, raw))  # pylint: disable=expression-not-assigned\n      for instance in reservation.get('Instances')] for reservation in matching_reservations if reservation]\n    return instances", "code_tokens": "def _aws_get_instance_by_tag ( region , name , tag , raw ) : client = boto3 . session . Session ( ) . client ( 'ec2' , region ) matching_reservations = client . describe_instances ( Filters = [ { 'Name' : tag , 'Values' : [ name ] } ] ) . get ( 'Reservations' , [ ] ) instances = [ ] [ [ instances . append ( _aws_instance_from_dict ( region , instance , raw ) ) # pylint: disable=expression-not-assigned for instance in reservation . get ( 'Instances' ) ] for reservation in matching_reservations if reservation ] return instances", "docstring_tokens": "Get all instances matching a tag .", "label": 0}, {"idx": "cosqa-train-5733", "doc": "lemmitiser in python for list of words", "code": "def lemmatize(self, text, best_guess=True, return_frequencies=False):\n\t\t\"\"\"Lemmatize all tokens in a string or a list.  A string is first tokenized using punkt.\n\t\tThrow a type error if the input is neither a string nor a list.\n\t\t\"\"\"\n\t\tif isinstance(text, str):\n\t\t\ttokens = wordpunct_tokenize(text)\n\t\telif isinstance(text, list):\n\t\t\ttokens= text\n\t\telse:\n\t\t\traise TypeError(\"lemmatize only works with strings or lists of string tokens.\")\n\n\t\treturn [self._lemmatize_token(token, best_guess, return_frequencies) for token in tokens]", "code_tokens": "def lemmatize ( self , text , best_guess = True , return_frequencies = False ) : if isinstance ( text , str ) : tokens = wordpunct_tokenize ( text ) elif isinstance ( text , list ) : tokens = text else : raise TypeError ( \"lemmatize only works with strings or lists of string tokens.\" ) return [ self . _lemmatize_token ( token , best_guess , return_frequencies ) for token in tokens ]", "docstring_tokens": "Lemmatize all tokens in a string or a list . A string is first tokenized using punkt . Throw a type error if the input is neither a string nor a list .", "label": 0}, {"idx": "cosqa-train-5734", "doc": "python top k largest elements", "code": "def _sort_tensor(tensor):\n  \"\"\"Use `top_k` to sort a `Tensor` along the last dimension.\"\"\"\n  sorted_, _ = tf.nn.top_k(tensor, k=tf.shape(input=tensor)[-1])\n  sorted_.set_shape(tensor.shape)\n  return sorted_", "code_tokens": "def _sort_tensor ( tensor ) : sorted_ , _ = tf . nn . top_k ( tensor , k = tf . shape ( input = tensor ) [ - 1 ] ) sorted_ . set_shape ( tensor . shape ) return sorted_", "docstring_tokens": "Use top_k to sort a Tensor along the last dimension .", "label": 1}, {"idx": "cosqa-train-5735", "doc": "lenght of a vector python", "code": "def norm_vec(vector):\n    \"\"\"Normalize the length of a vector to one\"\"\"\n    assert len(vector) == 3\n    v = np.array(vector)\n    return v/np.sqrt(np.sum(v**2))", "code_tokens": "def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )", "docstring_tokens": "Normalize the length of a vector to one", "label": 0}, {"idx": "cosqa-train-5736", "doc": "python tornado flow control", "code": "def start(args):\n    \"\"\"Run server with provided command line arguments.\n    \"\"\"\n    application = tornado.web.Application([(r\"/run\", run.get_handler(args)),\n                                           (r\"/status\", run.StatusHandler)])\n    application.runmonitor = RunMonitor()\n    application.listen(args.port)\n    tornado.ioloop.IOLoop.instance().start()", "code_tokens": "def start ( args ) : application = tornado . web . Application ( [ ( r\"/run\" , run . get_handler ( args ) ) , ( r\"/status\" , run . StatusHandler ) ] ) application . runmonitor = RunMonitor ( ) application . listen ( args . port ) tornado . ioloop . IOLoop . instance ( ) . start ( )", "docstring_tokens": "Run server with provided command line arguments .", "label": 0}, {"idx": "cosqa-train-5737", "doc": "length of array python for loop", "code": "def array_dim(arr):\n    \"\"\"Return the size of a multidimansional array.\n    \"\"\"\n    dim = []\n    while True:\n        try:\n            dim.append(len(arr))\n            arr = arr[0]\n        except TypeError:\n            return dim", "code_tokens": "def array_dim ( arr ) : dim = [ ] while True : try : dim . append ( len ( arr ) ) arr = arr [ 0 ] except TypeError : return dim", "docstring_tokens": "Return the size of a multidimansional array .", "label": 1}, {"idx": "cosqa-train-5738", "doc": "python tornado return chunk json", "code": "async def json_or_text(response):\n    \"\"\"Turns response into a properly formatted json or text object\"\"\"\n    text = await response.text()\n    if response.headers['Content-Type'] == 'application/json; charset=utf-8':\n        return json.loads(text)\n    return text", "code_tokens": "async def json_or_text ( response ) : text = await response . text ( ) if response . headers [ 'Content-Type' ] == 'application/json; charset=utf-8' : return json . loads ( text ) return text", "docstring_tokens": "Turns response into a properly formatted json or text object", "label": 0}, {"idx": "cosqa-train-5739", "doc": "limit precision while print python", "code": "def pprint(obj, verbose=False, max_width=79, newline='\\n'):\n    \"\"\"\n    Like `pretty` but print to stdout.\n    \"\"\"\n    printer = RepresentationPrinter(sys.stdout, verbose, max_width, newline)\n    printer.pretty(obj)\n    printer.flush()\n    sys.stdout.write(newline)\n    sys.stdout.flush()", "code_tokens": "def pprint ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )", "docstring_tokens": "Like pretty but print to stdout .", "label": 0}, {"idx": "cosqa-train-5740", "doc": "python traceback remove raise code", "code": "def re_raise(self):\n        \"\"\" Raise this exception with the original traceback \"\"\"\n        if self.exc_info is not None:\n            six.reraise(type(self), self, self.exc_info[2])\n        else:\n            raise self", "code_tokens": "def re_raise ( self ) : if self . exc_info is not None : six . reraise ( type ( self ) , self , self . exc_info [ 2 ] ) else : raise self", "docstring_tokens": "Raise this exception with the original traceback", "label": 0}, {"idx": "cosqa-train-5741", "doc": "linear regression on logrithmic data, python", "code": "def glog(x,l = 2):\n    \"\"\"\n    Generalised logarithm\n\n    :param x: number\n    :param p: number added befor logarithm \n\n    \"\"\"\n    return np.log((x+np.sqrt(x**2+l**2))/2)/np.log(l)", "code_tokens": "def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )", "docstring_tokens": "Generalised logarithm", "label": 0}, {"idx": "cosqa-train-5742", "doc": "python tree preorder traversal", "code": "def walk_tree(root):\n    \"\"\"Pre-order depth-first\"\"\"\n    yield root\n\n    for child in root.children:\n        for el in walk_tree(child):\n            yield el", "code_tokens": "def walk_tree ( root ) : yield root for child in root . children : for el in walk_tree ( child ) : yield el", "docstring_tokens": "Pre - order depth - first", "label": 0}, {"idx": "cosqa-train-5743", "doc": "linear regression plot the graph in python", "code": "def _linear_seaborn_(self, label=None, style=None, opts=None):\n        \"\"\"\n        Returns a Seaborn linear regression plot\n        \"\"\"\n        xticks, yticks = self._get_ticks(opts)\n        try:\n            fig = sns.lmplot(self.x, self.y, data=self.df)\n            fig = self._set_with_height(fig, opts)\n            return fig\n        except Exception as e:\n            self.err(e, self.linear_,\n                     \"Can not draw linear regression chart\")", "code_tokens": "def _linear_seaborn_ ( self , label = None , style = None , opts = None ) : xticks , yticks = self . _get_ticks ( opts ) try : fig = sns . lmplot ( self . x , self . y , data = self . df ) fig = self . _set_with_height ( fig , opts ) return fig except Exception as e : self . err ( e , self . linear_ , \"Can not draw linear regression chart\" )", "docstring_tokens": "Returns a Seaborn linear regression plot", "label": 0}, {"idx": "cosqa-train-5744", "doc": "python trim remove whitespace", "code": "def text_remove_empty_lines(text):\n    \"\"\"\n    Whitespace normalization:\n\n      - Strip empty lines\n      - Strip trailing whitespace\n    \"\"\"\n    lines = [ line.rstrip()  for line in text.splitlines()  if line.strip() ]\n    return \"\\n\".join(lines)", "code_tokens": "def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return \"\\n\" . join ( lines )", "docstring_tokens": "Whitespace normalization :", "label": 0}, {"idx": "cosqa-train-5745", "doc": "python trim trailing char", "code": "def remove_trailing_string(content, trailing):\n    \"\"\"\n    Strip trailing component `trailing` from `content` if it exists.\n    Used when generating names from view classes.\n    \"\"\"\n    if content.endswith(trailing) and content != trailing:\n        return content[:-len(trailing)]\n    return content", "code_tokens": "def remove_trailing_string ( content , trailing ) : if content . endswith ( trailing ) and content != trailing : return content [ : - len ( trailing ) ] return content", "docstring_tokens": "Strip trailing component trailing from content if it exists . Used when generating names from view classes .", "label": 1}, {"idx": "cosqa-train-5746", "doc": "list of list matrix form in python", "code": "def to_list(self):\n        \"\"\"Convert this confusion matrix into a 2x2 plain list of values.\"\"\"\n        return [[int(self.table.cell_values[0][1]), int(self.table.cell_values[0][2])],\n                [int(self.table.cell_values[1][1]), int(self.table.cell_values[1][2])]]", "code_tokens": "def to_list ( self ) : return [ [ int ( self . table . cell_values [ 0 ] [ 1 ] ) , int ( self . table . cell_values [ 0 ] [ 2 ] ) ] , [ int ( self . table . cell_values [ 1 ] [ 1 ] ) , int ( self . table . cell_values [ 1 ] [ 2 ] ) ] ]", "docstring_tokens": "Convert this confusion matrix into a 2x2 plain list of values .", "label": 0}, {"idx": "cosqa-train-5747", "doc": "python true false to 0 1 image", "code": "def abs_img(img):\n    \"\"\" Return an image with the binarised version of the data of `img`.\"\"\"\n    bool_img = np.abs(read_img(img).get_data())\n    return bool_img.astype(int)", "code_tokens": "def abs_img ( img ) : bool_img = np . abs ( read_img ( img ) . get_data ( ) ) return bool_img . astype ( int )", "docstring_tokens": "Return an image with the binarised version of the data of img .", "label": 0}, {"idx": "cosqa-train-5748", "doc": "list of ordered dictionariess python", "code": "def get_order(self):\n        \"\"\"\n        Return a list of dicionaries. See `set_order`.\n        \"\"\"\n        return [dict(reverse=r[0], key=r[1]) for r in self.get_model()]", "code_tokens": "def get_order ( self ) : return [ dict ( reverse = r [ 0 ] , key = r [ 1 ] ) for r in self . get_model ( ) ]", "docstring_tokens": "Return a list of dicionaries . See set_order .", "label": 0}, {"idx": "cosqa-train-5749", "doc": "python try catch for unzip", "code": "def _unzip_handle(handle):\n    \"\"\"Transparently unzip the file handle\"\"\"\n    if isinstance(handle, basestring):\n        handle = _gzip_open_filename(handle)\n    else:\n        handle = _gzip_open_handle(handle)\n    return handle", "code_tokens": "def _unzip_handle ( handle ) : if isinstance ( handle , basestring ) : handle = _gzip_open_filename ( handle ) else : handle = _gzip_open_handle ( handle ) return handle", "docstring_tokens": "Transparently unzip the file handle", "label": 0}, {"idx": "cosqa-train-5750", "doc": "list of python booleans syntax", "code": "def isbinary(*args):\n    \"\"\"Checks if value can be part of binary/bitwise operations.\"\"\"\n    return all(map(lambda c: isnumber(c) or isbool(c), args))", "code_tokens": "def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )", "docstring_tokens": "Checks if value can be part of binary / bitwise operations .", "label": 0}, {"idx": "cosqa-train-5751", "doc": "python turn a string to a list", "code": "def comma_delimited_to_list(list_param):\n    \"\"\"Convert comma-delimited list / string into a list of strings\n\n    :param list_param: Comma-delimited string\n    :type list_param: str | unicode\n    :return: A list of strings\n    :rtype: list\n    \"\"\"\n    if isinstance(list_param, list):\n        return list_param\n    if isinstance(list_param, str):\n        return list_param.split(',')\n    else:\n        return []", "code_tokens": "def comma_delimited_to_list ( list_param ) : if isinstance ( list_param , list ) : return list_param if isinstance ( list_param , str ) : return list_param . split ( ',' ) else : return [ ]", "docstring_tokens": "Convert comma - delimited list / string into a list of strings", "label": 1}, {"idx": "cosqa-train-5752", "doc": "list of tables in database sql in python", "code": "def get_table_names(connection):\n\t\"\"\"\n\tReturn a list of the table names in the database.\n\t\"\"\"\n\tcursor = connection.cursor()\n\tcursor.execute(\"SELECT name FROM sqlite_master WHERE type == 'table'\")\n\treturn [name for (name,) in cursor]", "code_tokens": "def get_table_names ( connection ) : cursor = connection . cursor ( ) cursor . execute ( \"SELECT name FROM sqlite_master WHERE type == 'table'\" ) return [ name for ( name , ) in cursor ]", "docstring_tokens": "Return a list of the table names in the database .", "label": 1}, {"idx": "cosqa-train-5753", "doc": "python turn every element in list into tuple", "code": "def compose_all(tups):\n  \"\"\"Compose all given tuples together.\"\"\"\n  from . import ast  # I weep for humanity\n  return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))", "code_tokens": "def compose_all ( tups ) : from . import ast # I weep for humanity return functools . reduce ( lambda x , y : x . compose ( y ) , map ( ast . make_tuple , tups ) , ast . make_tuple ( { } ) )", "docstring_tokens": "Compose all given tuples together .", "label": 0}, {"idx": "cosqa-train-5754", "doc": "list pages in pdf python not using pypdf", "code": "def resources(self):\n        \"\"\"Retrieve contents of each page of PDF\"\"\"\n        return [self.pdf.getPage(i) for i in range(self.pdf.getNumPages())]", "code_tokens": "def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "docstring_tokens": "Retrieve contents of each page of PDF", "label": 0}, {"idx": "cosqa-train-5755", "doc": "python turn first char to lowercase", "code": "def camel_to_(s):\n    \"\"\"\n    Convert CamelCase to camel_case\n    \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', s)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def camel_to_ ( s ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , s ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert CamelCase to camel_case", "label": 1}, {"idx": "cosqa-train-5756", "doc": "list remove all item function python", "code": "def unique(transactions):\n    \"\"\" Remove any duplicate entries. \"\"\"\n    seen = set()\n    # TODO: Handle comments\n    return [x for x in transactions if not (x in seen or seen.add(x))]", "code_tokens": "def unique ( transactions ) : seen = set ( ) # TODO: Handle comments return [ x for x in transactions if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Remove any duplicate entries .", "label": 1}, {"idx": "cosqa-train-5757", "doc": "list remove brackets in python", "code": "def readCommaList(fileList):\n    \"\"\" Return a list of the files with the commas removed. \"\"\"\n    names=fileList.split(',')\n    fileList=[]\n    for item in names:\n        fileList.append(item)\n    return fileList", "code_tokens": "def readCommaList ( fileList ) : names = fileList . split ( ',' ) fileList = [ ] for item in names : fileList . append ( item ) return fileList", "docstring_tokens": "Return a list of the files with the commas removed .", "label": 1}, {"idx": "cosqa-train-5758", "doc": "python turning an array into 2d array", "code": "def _convert_to_array(array_like, dtype):\n        \"\"\"\n        Convert Matrix attributes which are array-like or buffer to array.\n        \"\"\"\n        if isinstance(array_like, bytes):\n            return np.frombuffer(array_like, dtype=dtype)\n        return np.asarray(array_like, dtype=dtype)", "code_tokens": "def _convert_to_array ( array_like , dtype ) : if isinstance ( array_like , bytes ) : return np . frombuffer ( array_like , dtype = dtype ) return np . asarray ( array_like , dtype = dtype )", "docstring_tokens": "Convert Matrix attributes which are array - like or buffer to array .", "label": 0}, {"idx": "cosqa-train-5759", "doc": "list to rdf triple python", "code": "def _get_triplet_value_list(self, graph, identity, rdf_type):\n        \"\"\"\n        Get a list of values from RDF triples when more than one may be present\n        \"\"\"\n        values = []\n        for elem in graph.objects(identity, rdf_type):\n            values.append(elem.toPython())\n        return values", "code_tokens": "def _get_triplet_value_list ( self , graph , identity , rdf_type ) : values = [ ] for elem in graph . objects ( identity , rdf_type ) : values . append ( elem . toPython ( ) ) return values", "docstring_tokens": "Get a list of values from RDF triples when more than one may be present", "label": 0}, {"idx": "cosqa-train-5760", "doc": "python turtle how to set new position", "code": "def forward(self, step):\n        \"\"\"Move the turtle forward.\n\n        :param step: Integer. Distance to move forward.\n        \"\"\"\n        x = self.pos_x + math.cos(math.radians(self.rotation)) * step\n        y = self.pos_y + math.sin(math.radians(self.rotation)) * step\n        prev_brush_state = self.brush_on\n        self.brush_on = True\n        self.move(x, y)\n        self.brush_on = prev_brush_state", "code_tokens": "def forward ( self , step ) : x = self . pos_x + math . cos ( math . radians ( self . rotation ) ) * step y = self . pos_y + math . sin ( math . radians ( self . rotation ) ) * step prev_brush_state = self . brush_on self . brush_on = True self . move ( x , y ) self . brush_on = prev_brush_state", "docstring_tokens": "Move the turtle forward .", "label": 0}, {"idx": "cosqa-train-5761", "doc": "load npy files into features python", "code": "def load_feature(fname, language):\n    \"\"\" Load and parse a feature file. \"\"\"\n\n    fname = os.path.abspath(fname)\n    feat = parse_file(fname, language)\n    return feat", "code_tokens": "def load_feature ( fname , language ) : fname = os . path . abspath ( fname ) feat = parse_file ( fname , language ) return feat", "docstring_tokens": "Load and parse a feature file .", "label": 1}, {"idx": "cosqa-train-5762", "doc": "python typing on instance methods", "code": "def __get__(self, obj, objtype):\n        if not self.is_method:\n            self.is_method = True\n        \"\"\"Support instance methods.\"\"\"\n        return functools.partial(self.__call__, obj)", "code_tokens": "def __get__ ( self , obj , objtype ) : if not self . is_method : self . is_method = True return functools . partial ( self . __call__ , obj )", "docstring_tokens": "Support instance methods .", "label": 0}, {"idx": "cosqa-train-5763", "doc": "load uint8 file in python", "code": "async def load_unicode(reader):\n    \"\"\"\n    Loads UTF8 string\n    :param reader:\n    :return:\n    \"\"\"\n    ivalue = await load_uvarint(reader)\n    fvalue = bytearray(ivalue)\n    await reader.areadinto(fvalue)\n    return str(fvalue, 'utf8')", "code_tokens": "async def load_unicode ( reader ) : ivalue = await load_uvarint ( reader ) fvalue = bytearray ( ivalue ) await reader . areadinto ( fvalue ) return str ( fvalue , 'utf8' )", "docstring_tokens": "Loads UTF8 string : param reader : : return :", "label": 1}, {"idx": "cosqa-train-5764", "doc": "python unable to create argparse in function", "code": "def parsed_args():\n    parser = argparse.ArgumentParser(description=\"\"\"python runtime functions\"\"\", epilog=\"\")\n    parser.add_argument('command',nargs='*',\n        help=\"Name of the function to run with arguments\")\n    args = parser.parse_args()\n    return (args, parser)", "code_tokens": "def parsed_args ( ) : parser = argparse . ArgumentParser ( description = \"\"\"python runtime functions\"\"\" , epilog = \"\" ) parser . add_argument ( 'command' , nargs = '*' , help = \"Name of the function to run with arguments\" ) args = parser . parse_args ( ) return ( args , parser )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-5765", "doc": "loading a fucntion in python", "code": "def load_feature(fname, language):\n    \"\"\" Load and parse a feature file. \"\"\"\n\n    fname = os.path.abspath(fname)\n    feat = parse_file(fname, language)\n    return feat", "code_tokens": "def load_feature ( fname , language ) : fname = os . path . abspath ( fname ) feat = parse_file ( fname , language ) return feat", "docstring_tokens": "Load and parse a feature file .", "label": 0}, {"idx": "cosqa-train-5766", "doc": "python undefined variable assertfalse", "code": "def assert_is_not(expected, actual, message=None, extra=None):\n    \"\"\"Raises an AssertionError if expected is actual.\"\"\"\n    assert expected is not actual, _assert_fail_message(\n        message, expected, actual, \"is\", extra\n    )", "code_tokens": "def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , \"is\" , extra )", "docstring_tokens": "Raises an AssertionError if expected is actual .", "label": 0}, {"idx": "cosqa-train-5767", "doc": "locating items in tuple in python", "code": "def tuple_search(t, i, v):\n    \"\"\"\n    Search tuple array by index and value\n    :param t: tuple array\n    :param i: index of the value in each tuple\n    :param v: value\n    :return: the first tuple in the array with the specific index / value\n    \"\"\"\n    for e in t:\n        if e[i] == v:\n            return e\n    return None", "code_tokens": "def tuple_search ( t , i , v ) : for e in t : if e [ i ] == v : return e return None", "docstring_tokens": "Search tuple array by index and value : param t : tuple array : param i : index of the value in each tuple : param v : value : return : the first tuple in the array with the specific index / value", "label": 0}, {"idx": "cosqa-train-5768", "doc": "python unittest assert text equal", "code": "def page_title(step, title):\n    \"\"\"\n    Check that the page title matches the given one.\n    \"\"\"\n\n    with AssertContextManager(step):\n        assert_equals(world.browser.title, title)", "code_tokens": "def page_title ( step , title ) : with AssertContextManager ( step ) : assert_equals ( world . browser . title , title )", "docstring_tokens": "Check that the page title matches the given one .", "label": 0}, {"idx": "cosqa-train-5769", "doc": "logger python print function name", "code": "def pylog(self, *args, **kwargs):\n        \"\"\"Display all available logging information.\"\"\"\n        printerr(self.name, args, kwargs, traceback.format_exc())", "code_tokens": "def pylog ( self , * args , * * kwargs ) : printerr ( self . name , args , kwargs , traceback . format_exc ( ) )", "docstring_tokens": "Display all available logging information .", "label": 0}, {"idx": "cosqa-train-5770", "doc": "python unpack dictionary to function args", "code": "def _correct_args(func, kwargs):\n    \"\"\"\n        Convert a dictionary of arguments including __argv into a list\n        for passing to the function.\n    \"\"\"\n    args = inspect.getargspec(func)[0]\n    return [kwargs[arg] for arg in args] + kwargs['__args']", "code_tokens": "def _correct_args ( func , kwargs ) : args = inspect . getargspec ( func ) [ 0 ] return [ kwargs [ arg ] for arg in args ] + kwargs [ '__args' ]", "docstring_tokens": "Convert a dictionary of arguments including __argv into a list for passing to the function .", "label": 1}, {"idx": "cosqa-train-5771", "doc": "longest sequence of adjacent values in python", "code": "def longest_run_1d(arr):\n    \"\"\"Return the length of the longest consecutive run of identical values.\n\n    Parameters\n    ----------\n    arr : bool array\n      Input array\n\n    Returns\n    -------\n    int\n      Length of longest run.\n    \"\"\"\n    v, rl = rle_1d(arr)[:2]\n    return np.where(v, rl, 0).max()", "code_tokens": "def longest_run_1d ( arr ) : v , rl = rle_1d ( arr ) [ : 2 ] return np . where ( v , rl , 0 ) . max ( )", "docstring_tokens": "Return the length of the longest consecutive run of identical values .", "label": 0}, {"idx": "cosqa-train-5772", "doc": "python unpack various lenght struct", "code": "def unpack(self, s):\n        \"\"\"Parse bytes and return a namedtuple.\"\"\"\n        return self._create(super(NamedStruct, self).unpack(s))", "code_tokens": "def unpack ( self , s ) : return self . _create ( super ( NamedStruct , self ) . unpack ( s ) )", "docstring_tokens": "Parse bytes and return a namedtuple .", "label": 1}, {"idx": "cosqa-train-5773", "doc": "looking for some specific key value in python tuples", "code": "def tuple_search(t, i, v):\n    \"\"\"\n    Search tuple array by index and value\n    :param t: tuple array\n    :param i: index of the value in each tuple\n    :param v: value\n    :return: the first tuple in the array with the specific index / value\n    \"\"\"\n    for e in t:\n        if e[i] == v:\n            return e\n    return None", "code_tokens": "def tuple_search ( t , i , v ) : for e in t : if e [ i ] == v : return e return None", "docstring_tokens": "Search tuple array by index and value : param t : tuple array : param i : index of the value in each tuple : param v : value : return : the first tuple in the array with the specific index / value", "label": 0}, {"idx": "cosqa-train-5774", "doc": "python unstacked area chart", "code": "def sarea_(self, col, x=None, y=None, rsum=None, rmean=None):\n\t\t\"\"\"\n\t\tGet an stacked area chart\n\t\t\"\"\"\n\t\ttry:\n\t\t\tcharts = self._multiseries(col, x, y, \"area\", rsum, rmean)\n\t\t\treturn hv.Area.stack(charts)\n\t\texcept Exception as e:\n\t\t\tself.err(e, self.sarea_, \"Can not draw stacked area chart\")", "code_tokens": "def sarea_ ( self , col , x = None , y = None , rsum = None , rmean = None ) : try : charts = self . _multiseries ( col , x , y , \"area\" , rsum , rmean ) return hv . Area . stack ( charts ) except Exception as e : self . err ( e , self . sarea_ , \"Can not draw stacked area chart\" )", "docstring_tokens": "Get an stacked area chart", "label": 0}, {"idx": "cosqa-train-5775", "doc": "lookup a value of a key dictionary python", "code": "def get_key_by_value(dictionary, search_value):\n    \"\"\"\n    searchs a value in a dicionary and returns the key of the first occurrence\n\n    :param dictionary: dictionary to search in\n    :param search_value: value to search for\n    \"\"\"\n    for key, value in dictionary.iteritems():\n        if value == search_value:\n            return ugettext(key)", "code_tokens": "def get_key_by_value ( dictionary , search_value ) : for key , value in dictionary . iteritems ( ) : if value == search_value : return ugettext ( key )", "docstring_tokens": "searchs a value in a dicionary and returns the key of the first occurrence", "label": 1}, {"idx": "cosqa-train-5776", "doc": "python update file mtime without modification", "code": "def set_time(filename, mod_time):\n\t\"\"\"\n\tSet the modified time of a file\n\t\"\"\"\n\tlog.debug('Setting modified time to %s', mod_time)\n\tmtime = calendar.timegm(mod_time.utctimetuple())\n\t# utctimetuple discards microseconds, so restore it (for consistency)\n\tmtime += mod_time.microsecond / 1000000\n\tatime = os.stat(filename).st_atime\n\tos.utime(filename, (atime, mtime))", "code_tokens": "def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)\n mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )", "docstring_tokens": "Set the modified time of a file", "label": 0}, {"idx": "cosqa-train-5777", "doc": "mac get python details", "code": "async def sysinfo(dev: Device):\n    \"\"\"Print out system information (version, MAC addrs).\"\"\"\n    click.echo(await dev.get_system_info())\n    click.echo(await dev.get_interface_information())", "code_tokens": "async def sysinfo ( dev : Device ) : click . echo ( await dev . get_system_info ( ) ) click . echo ( await dev . get_interface_information ( ) )", "docstring_tokens": "Print out system information ( version MAC addrs ) .", "label": 0}, {"idx": "cosqa-train-5778", "doc": "python url for static files", "code": "def glr_path_static():\n    \"\"\"Returns path to packaged static files\"\"\"\n    return os.path.abspath(os.path.join(os.path.dirname(__file__), '_static'))", "code_tokens": "def glr_path_static ( ) : return os . path . abspath ( os . path . join ( os . path . dirname ( __file__ ) , '_static' ) )", "docstring_tokens": "Returns path to packaged static files", "label": 0}, {"idx": "cosqa-train-5779", "doc": "macro for discord to change presence python", "code": "def subscribe_to_quorum_channel(self):\n        \"\"\"In case the experiment enforces a quorum, listen for notifications\n        before creating Partipant objects.\n        \"\"\"\n        from dallinger.experiment_server.sockets import chat_backend\n\n        self.log(\"Bot subscribing to quorum channel.\")\n        chat_backend.subscribe(self, \"quorum\")", "code_tokens": "def subscribe_to_quorum_channel ( self ) : from dallinger . experiment_server . sockets import chat_backend self . log ( \"Bot subscribing to quorum channel.\" ) chat_backend . subscribe ( self , \"quorum\" )", "docstring_tokens": "In case the experiment enforces a quorum listen for notifications before creating Partipant objects .", "label": 0}, {"idx": "cosqa-train-5780", "doc": "python url get the file name", "code": "def get_url_file_name(url):\n    \"\"\"Get the file name from an url\n    \n    Parameters\n    ----------\n    url : str\n\n    Returns\n    -------\n    str\n        The file name \n    \"\"\"\n\n    assert isinstance(url, (str, _oldstr))\n    return urlparse.urlparse(url).path.split('/')[-1]", "code_tokens": "def get_url_file_name ( url ) : assert isinstance ( url , ( str , _oldstr ) ) return urlparse . urlparse ( url ) . path . split ( '/' ) [ - 1 ]", "docstring_tokens": "Get the file name from an url Parameters ---------- url : str", "label": 0}, {"idx": "cosqa-train-5781", "doc": "make a listy copy without pointer to original python", "code": "def copy(self):\n        \"\"\"Return a copy of this list with each element copied to new memory\n        \"\"\"\n        out = type(self)()\n        for series in self:\n            out.append(series.copy())\n        return out", "code_tokens": "def copy ( self ) : out = type ( self ) ( ) for series in self : out . append ( series . copy ( ) ) return out", "docstring_tokens": "Return a copy of this list with each element copied to new memory", "label": 1}, {"idx": "cosqa-train-5782", "doc": "python user libraries path", "code": "def GetPythonLibraryDirectoryPath():\n  \"\"\"Retrieves the Python library directory path.\"\"\"\n  path = sysconfig.get_python_lib(True)\n  _, _, path = path.rpartition(sysconfig.PREFIX)\n\n  if path.startswith(os.sep):\n    path = path[1:]\n\n  return path", "code_tokens": "def GetPythonLibraryDirectoryPath ( ) : path = sysconfig . get_python_lib ( True ) _ , _ , path = path . rpartition ( sysconfig . PREFIX ) if path . startswith ( os . sep ) : path = path [ 1 : ] return path", "docstring_tokens": "Retrieves the Python library directory path .", "label": 0}, {"idx": "cosqa-train-5783", "doc": "make dictionary elements as array python", "code": "def C_dict2array(C):\n    \"\"\"Convert an OrderedDict containing C values to a 1D array.\"\"\"\n    return np.hstack([np.asarray(C[k]).ravel() for k in C_keys])", "code_tokens": "def C_dict2array ( C ) : return np . hstack ( [ np . asarray ( C [ k ] ) . ravel ( ) for k in C_keys ] )", "docstring_tokens": "Convert an OrderedDict containing C values to a 1D array .", "label": 0}, {"idx": "cosqa-train-5784", "doc": "python uuid database no hydashhen", "code": "def generate_id():\n    \"\"\"Generate new UUID\"\"\"\n    # TODO: Use six.string_type to Py3 compat\n    try:\n        return unicode(uuid1()).replace(u\"-\", u\"\")\n    except NameError:\n        return str(uuid1()).replace(u\"-\", u\"\")", "code_tokens": "def generate_id ( ) : # TODO: Use six.string_type to Py3 compat try : return unicode ( uuid1 ( ) ) . replace ( u\"-\" , u\"\" ) except NameError : return str ( uuid1 ( ) ) . replace ( u\"-\" , u\"\" )", "docstring_tokens": "Generate new UUID", "label": 1}, {"idx": "cosqa-train-5785", "doc": "make irc bot to join channel python", "code": "def on_welcome(self, connection, event):\n        \"\"\"\n        Join the channel once connected to the IRC server.\n        \"\"\"\n        connection.join(self.channel, key=settings.IRC_CHANNEL_KEY or \"\")", "code_tokens": "def on_welcome ( self , connection , event ) : connection . join ( self . channel , key = settings . IRC_CHANNEL_KEY or \"\" )", "docstring_tokens": "Join the channel once connected to the IRC server .", "label": 0}, {"idx": "cosqa-train-5786", "doc": "python validate enum value is from enum", "code": "def check(self, var):\n        \"\"\"Check whether the provided value is a valid enum constant.\"\"\"\n        if not isinstance(var, _str_type): return False\n        return _enum_mangle(var) in self._consts", "code_tokens": "def check ( self , var ) : if not isinstance ( var , _str_type ) : return False return _enum_mangle ( var ) in self . _consts", "docstring_tokens": "Check whether the provided value is a valid enum constant .", "label": 0}, {"idx": "cosqa-train-5787", "doc": "make nested dict a str python", "code": "def pretty_dict_string(d, indent=0):\n    \"\"\"Pretty output of nested dictionaries.\n    \"\"\"\n    s = ''\n    for key, value in sorted(d.items()):\n        s += '    ' * indent + str(key)\n        if isinstance(value, dict):\n             s += '\\n' + pretty_dict_string(value, indent+1)\n        else:\n             s += '=' + str(value) + '\\n'\n    return s", "code_tokens": "def pretty_dict_string ( d , indent = 0 ) : s = '' for key , value in sorted ( d . items ( ) ) : s += '    ' * indent + str ( key ) if isinstance ( value , dict ) : s += '\\n' + pretty_dict_string ( value , indent + 1 ) else : s += '=' + str ( value ) + '\\n' return s", "docstring_tokens": "Pretty output of nested dictionaries .", "label": 1}, {"idx": "cosqa-train-5788", "doc": "python venv without active", "code": "def venv():\n    \"\"\"Install venv + deps.\"\"\"\n    try:\n        import virtualenv  # NOQA\n    except ImportError:\n        sh(\"%s -m pip install virtualenv\" % PYTHON)\n    if not os.path.isdir(\"venv\"):\n        sh(\"%s -m virtualenv venv\" % PYTHON)\n    sh(\"venv\\\\Scripts\\\\pip install -r %s\" % (REQUIREMENTS_TXT))", "code_tokens": "def venv ( ) : try : import virtualenv # NOQA except ImportError : sh ( \"%s -m pip install virtualenv\" % PYTHON ) if not os . path . isdir ( \"venv\" ) : sh ( \"%s -m virtualenv venv\" % PYTHON ) sh ( \"venv\\\\Scripts\\\\pip install -r %s\" % ( REQUIREMENTS_TXT ) )", "docstring_tokens": "Install venv + deps .", "label": 0}, {"idx": "cosqa-train-5789", "doc": "make string url safe python", "code": "def url_encode(url):\n    \"\"\"\n    Convert special characters using %xx escape.\n\n    :param url: str\n    :return: str - encoded url\n    \"\"\"\n    if isinstance(url, text_type):\n        url = url.encode('utf8')\n    return quote(url, ':/%?&=')", "code_tokens": "def url_encode ( url ) : if isinstance ( url , text_type ) : url = url . encode ( 'utf8' ) return quote ( url , ':/%?&=' )", "docstring_tokens": "Convert special characters using %xx escape .", "label": 0}, {"idx": "cosqa-train-5790", "doc": "python verify if column exists", "code": "def _raise_error_if_column_exists(dataset, column_name = 'dataset',\n                            dataset_variable_name = 'dataset',\n                            column_name_error_message_name = 'column_name'):\n    \"\"\"\n    Check if a column exists in an SFrame with error message.\n    \"\"\"\n    err_msg = 'The SFrame {0} must contain the column {1}.'.format(\n                                                dataset_variable_name,\n                                             column_name_error_message_name)\n    if column_name not in dataset.column_names():\n      raise ToolkitError(str(err_msg))", "code_tokens": "def _raise_error_if_column_exists ( dataset , column_name = 'dataset' , dataset_variable_name = 'dataset' , column_name_error_message_name = 'column_name' ) : err_msg = 'The SFrame {0} must contain the column {1}.' . format ( dataset_variable_name , column_name_error_message_name ) if column_name not in dataset . column_names ( ) : raise ToolkitError ( str ( err_msg ) )", "docstring_tokens": "Check if a column exists in an SFrame with error message .", "label": 0}, {"idx": "cosqa-train-5791", "doc": "make string utf8 python", "code": "def safe_unicode(string):\n    \"\"\"If Python 2, replace non-ascii characters and return encoded string.\"\"\"\n    if not PY3:\n        uni = string.replace(u'\\u2019', \"'\")\n        return uni.encode('utf-8')\n        \n    return string", "code_tokens": "def safe_unicode ( string ) : if not PY3 : uni = string . replace ( u'\\u2019' , \"'\" ) return uni . encode ( 'utf-8' ) return string", "docstring_tokens": "If Python 2 replace non - ascii characters and return encoded string .", "label": 1}, {"idx": "cosqa-train-5792", "doc": "python view as series column format string", "code": "def format(x, format):\n    \"\"\"Uses http://www.cplusplus.com/reference/string/to_string/ for formatting\"\"\"\n    # don't change the dtype, otherwise for each block the dtype may be different (string length)\n    sl = vaex.strings.format(x, format)\n    return column.ColumnStringArrow(sl.bytes, sl.indices, sl.length, sl.offset, string_sequence=sl)", "code_tokens": "def format ( x , format ) : # don't change the dtype, otherwise for each block the dtype may be different (string length) sl = vaex . strings . format ( x , format ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "docstring_tokens": "Uses http : // www . cplusplus . com / reference / string / to_string / for formatting", "label": 1}, {"idx": "cosqa-train-5793", "doc": "make tabel in python left justify", "code": "def print_table(*args, **kwargs):\n    \"\"\"\n    if csv:\n        import csv\n        t = csv.writer(sys.stdout, delimiter=\";\")\n        t.writerow(header)\n    else:\n        t = PrettyTable(header)\n        t.align = \"r\"\n        t.align[\"details\"] = \"l\"\n    \"\"\"\n    t = format_table(*args, **kwargs)\n    click.echo(t)", "code_tokens": "def print_table ( * args , * * kwargs ) : t = format_table ( * args , * * kwargs ) click . echo ( t )", "docstring_tokens": "if csv : import csv t = csv . writer ( sys . stdout delimiter = ; ) t . writerow ( header ) else : t = PrettyTable ( header ) t . align = r t . align [ details ] = l", "label": 0}, {"idx": "cosqa-train-5794", "doc": "python view vector to asimuth elevation", "code": "def world_to_view(v):\n    \"\"\"world coords to view coords; v an eu.Vector2, returns (float, float)\"\"\"\n    return v.x * config.scale_x, v.y * config.scale_y", "code_tokens": "def world_to_view ( v ) : return v . x * config . scale_x , v . y * config . scale_y", "docstring_tokens": "world coords to view coords ; v an eu . Vector2 returns ( float float )", "label": 1}, {"idx": "cosqa-train-5795", "doc": "making a bezier curve around points python", "code": "def quadratic_bezier(start, end, c0=(0, 0), c1=(0, 0), steps=50):\n    \"\"\"\n    Compute quadratic bezier spline given start and end coordinate and\n    two control points.\n    \"\"\"\n    steps = np.linspace(0, 1, steps)\n    sx, sy = start\n    ex, ey = end\n    cx0, cy0 = c0\n    cx1, cy1 = c1\n    xs = ((1-steps)**3*sx + 3*((1-steps)**2)*steps*cx0 +\n          3*(1-steps)*steps**2*cx1 + steps**3*ex)\n    ys = ((1-steps)**3*sy + 3*((1-steps)**2)*steps*cy0 +\n          3*(1-steps)*steps**2*cy1 + steps**3*ey)\n    return np.column_stack([xs, ys])", "code_tokens": "def quadratic_bezier ( start , end , c0 = ( 0 , 0 ) , c1 = ( 0 , 0 ) , steps = 50 ) : steps = np . linspace ( 0 , 1 , steps ) sx , sy = start ex , ey = end cx0 , cy0 = c0 cx1 , cy1 = c1 xs = ( ( 1 - steps ) ** 3 * sx + 3 * ( ( 1 - steps ) ** 2 ) * steps * cx0 + 3 * ( 1 - steps ) * steps ** 2 * cx1 + steps ** 3 * ex ) ys = ( ( 1 - steps ) ** 3 * sy + 3 * ( ( 1 - steps ) ** 2 ) * steps * cy0 + 3 * ( 1 - steps ) * steps ** 2 * cy1 + steps ** 3 * ey ) return np . column_stack ( [ xs , ys ] )", "docstring_tokens": "Compute quadratic bezier spline given start and end coordinate and two control points .", "label": 0}, {"idx": "cosqa-train-5796", "doc": "python volume of grid surface", "code": "def volume(self):\n        \"\"\"\n        The volume of the primitive extrusion.\n\n        Calculated from polygon and height to avoid mesh creation.\n\n        Returns\n        ----------\n        volume: float, volume of 3D extrusion\n        \"\"\"\n        volume = abs(self.primitive.polygon.area *\n                     self.primitive.height)\n        return volume", "code_tokens": "def volume ( self ) : volume = abs ( self . primitive . polygon . area * self . primitive . height ) return volume", "docstring_tokens": "The volume of the primitive extrusion .", "label": 0}, {"idx": "cosqa-train-5797", "doc": "making a call to a server python script in javascript", "code": "def eval_script(self, expr):\n    \"\"\" Evaluates a piece of Javascript in the context of the current page and\n    returns its value. \"\"\"\n    ret = self.conn.issue_command(\"Evaluate\", expr)\n    return json.loads(\"[%s]\" % ret)[0]", "code_tokens": "def eval_script ( self , expr ) : ret = self . conn . issue_command ( \"Evaluate\" , expr ) return json . loads ( \"[%s]\" % ret ) [ 0 ]", "docstring_tokens": "Evaluates a piece of Javascript in the context of the current page and returns its value .", "label": 0}, {"idx": "cosqa-train-5798", "doc": "python vribles strt with underscore", "code": "def classnameify(s):\n  \"\"\"\n  Makes a classname\n  \"\"\"\n  return ''.join(w if w in ACRONYMS else w.title() for w in s.split('_'))", "code_tokens": "def classnameify ( s ) : return '' . join ( w if w in ACRONYMS else w . title ( ) for w in s . split ( '_' ) )", "docstring_tokens": "Makes a classname", "label": 0}, {"idx": "cosqa-train-5799", "doc": "making a sine wave on python", "code": "def sine_wave(frequency):\n  \"\"\"Emit a sine wave at the given frequency.\"\"\"\n  xs = tf.reshape(tf.range(_samples(), dtype=tf.float32), [1, _samples(), 1])\n  ts = xs / FLAGS.sample_rate\n  return tf.sin(2 * math.pi * frequency * ts)", "code_tokens": "def sine_wave ( frequency ) : xs = tf . reshape ( tf . range ( _samples ( ) , dtype = tf . float32 ) , [ 1 , _samples ( ) , 1 ] ) ts = xs / FLAGS . sample_rate return tf . sin ( 2 * math . pi * frequency * ts )", "docstring_tokens": "Emit a sine wave at the given frequency .", "label": 0}, {"idx": "cosqa-train-5800", "doc": "python wav spectrogram to wav", "code": "def readwav(filename):\n    \"\"\"Read a WAV file and returns the data and sample rate\n\n    ::\n\n        from spectrum.io import readwav\n        readwav()\n\n    \"\"\"\n    from scipy.io.wavfile import read as readwav\n    samplerate, signal = readwav(filename)\n    return signal, samplerate", "code_tokens": "def readwav ( filename ) : from scipy . io . wavfile import read as readwav samplerate , signal = readwav ( filename ) return signal , samplerate", "docstring_tokens": "Read a WAV file and returns the data and sample rate", "label": 0}, {"idx": "cosqa-train-5801", "doc": "making a username and password on python", "code": "def get_auth():\n    \"\"\"Get authentication.\"\"\"\n    import getpass\n    user = input(\"User Name: \")  # noqa\n    pswd = getpass.getpass('Password: ')\n    return Github(user, pswd)", "code_tokens": "def get_auth ( ) : import getpass user = input ( \"User Name: \" ) # noqa pswd = getpass . getpass ( 'Password: ' ) return Github ( user , pswd )", "docstring_tokens": "Get authentication .", "label": 0}, {"idx": "cosqa-train-5802", "doc": "python web scraping cookies and referrer", "code": "def get_page_and_url(session, url):\n    \"\"\"\n    Download an HTML page using the requests session and return\n    the final URL after following redirects.\n    \"\"\"\n    reply = get_reply(session, url)\n    return reply.text, reply.url", "code_tokens": "def get_page_and_url ( session , url ) : reply = get_reply ( session , url ) return reply . text , reply . url", "docstring_tokens": "Download an HTML page using the requests session and return the final URL after following redirects .", "label": 0}, {"idx": "cosqa-train-5803", "doc": "manhattan distance python numpy", "code": "def manhattan_distance_numpy(object1, object2):\n    \"\"\"!\n    @brief Calculate Manhattan distance between two objects using numpy.\n\n    @param[in] object1 (array_like): The first array_like object.\n    @param[in] object2 (array_like): The second array_like object.\n\n    @return (double) Manhattan distance between two objects.\n\n    \"\"\"\n    return numpy.sum(numpy.absolute(object1 - object2), axis=1).T", "code_tokens": "def manhattan_distance_numpy ( object1 , object2 ) : return numpy . sum ( numpy . absolute ( object1 - object2 ) , axis = 1 ) . T", "docstring_tokens": "!", "label": 0}, {"idx": "cosqa-train-5804", "doc": "python webdriver check box", "code": "def check_by_selector(self, selector):\n    \"\"\"Check the checkbox matching the CSS selector.\"\"\"\n    elem = find_element_by_jquery(world.browser, selector)\n    if not elem.is_selected():\n        elem.click()", "code_tokens": "def check_by_selector ( self , selector ) : elem = find_element_by_jquery ( world . browser , selector ) if not elem . is_selected ( ) : elem . click ( )", "docstring_tokens": "Check the checkbox matching the CSS selector .", "label": 0}, {"idx": "cosqa-train-5805", "doc": "manually calling unit test setup python", "code": "def autobuild_python_test(path):\n    \"\"\"Add pytest unit tests to be built as part of build/test/output.\"\"\"\n\n    env = Environment(tools=[])\n    target = env.Command(['build/test/output/pytest.log'], [path],\n                         action=env.Action(run_pytest, \"Running python unit tests\"))\n    env.AlwaysBuild(target)", "code_tokens": "def autobuild_python_test ( path ) : env = Environment ( tools = [ ] ) target = env . Command ( [ 'build/test/output/pytest.log' ] , [ path ] , action = env . Action ( run_pytest , \"Running python unit tests\" ) ) env . AlwaysBuild ( target )", "docstring_tokens": "Add pytest unit tests to be built as part of build / test / output .", "label": 0}, {"idx": "cosqa-train-5806", "doc": "python webdriver get content by id", "code": "def find_elements_by_id(self, id_):\n        \"\"\"\n        Finds multiple elements by id.\n\n        :Args:\n         - id\\\\_ - The id of the elements to be found.\n\n        :Returns:\n         - list of WebElement - a list with elements if any was found.  An\n           empty list if not\n\n        :Usage:\n            ::\n\n                elements = driver.find_elements_by_id('foo')\n        \"\"\"\n        return self.find_elements(by=By.ID, value=id_)", "code_tokens": "def find_elements_by_id ( self , id_ ) : return self . find_elements ( by = By . ID , value = id_ )", "docstring_tokens": "Finds multiple elements by id .", "label": 0}, {"idx": "cosqa-train-5807", "doc": "matching keys and values for 2 python dictionary", "code": "def intersect(d1, d2):\n    \"\"\"Intersect dictionaries d1 and d2 by key *and* value.\"\"\"\n    return dict((k, d1[k]) for k in d1 if k in d2 and d1[k] == d2[k])", "code_tokens": "def intersect ( d1 , d2 ) : return dict ( ( k , d1 [ k ] ) for k in d1 if k in d2 and d1 [ k ] == d2 [ k ] )", "docstring_tokens": "Intersect dictionaries d1 and d2 by key * and * value .", "label": 0}, {"idx": "cosqa-train-5808", "doc": "python what index is the item at", "code": "def _get_item_position(self, idx):\n        \"\"\"Return a tuple of (start, end) indices of an item from its index.\"\"\"\n        start = 0 if idx == 0 else self._index[idx - 1] + 1\n        end = self._index[idx]\n        return start, end", "code_tokens": "def _get_item_position ( self , idx ) : start = 0 if idx == 0 else self . _index [ idx - 1 ] + 1 end = self . _index [ idx ] return start , end", "docstring_tokens": "Return a tuple of ( start end ) indices of an item from its index .", "label": 0}, {"idx": "cosqa-train-5809", "doc": "matlibplot python draw arrow", "code": "def add_arrow(self, x1, y1, x2, y2, **kws):\n        \"\"\"add arrow to plot\"\"\"\n        self.panel.add_arrow(x1, y1, x2, y2, **kws)", "code_tokens": "def add_arrow ( self , x1 , y1 , x2 , y2 , * * kws ) : self . panel . add_arrow ( x1 , y1 , x2 , y2 , * * kws )", "docstring_tokens": "add arrow to plot", "label": 0}, {"idx": "cosqa-train-5810", "doc": "python wrap function starmap", "code": "def map_wrap(f):\n    \"\"\"Wrap standard function to easily pass into 'map' processing.\n    \"\"\"\n    @functools.wraps(f)\n    def wrapper(*args, **kwargs):\n        return f(*args, **kwargs)\n    return wrapper", "code_tokens": "def map_wrap ( f ) : @ functools . wraps ( f ) def wrapper ( * args , * * kwargs ) : return f ( * args , * * kwargs ) return wrapper", "docstring_tokens": "Wrap standard function to easily pass into map processing .", "label": 0}, {"idx": "cosqa-train-5811", "doc": "matrix to get identity matrix python", "code": "def ident():\n    \"\"\"\n    This routine returns the 3x3 identity matrix.\n\n    http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/ident_c.html\n\n    :return: The 3x3 identity matrix.\n    :rtype: 3x3-Element Array of floats\n    \"\"\"\n    matrix = stypes.emptyDoubleMatrix()\n    libspice.ident_c(matrix)\n    return stypes.cMatrixToNumpy(matrix)", "code_tokens": "def ident ( ) : matrix = stypes . emptyDoubleMatrix ( ) libspice . ident_c ( matrix ) return stypes . cMatrixToNumpy ( matrix )", "docstring_tokens": "This routine returns the 3x3 identity matrix .", "label": 0}, {"idx": "cosqa-train-5812", "doc": "python write a program that calculates the average word length in a sentence entered by the user", "code": "def get_average_length_of_string(strings):\n    \"\"\"Computes average length of words\n\n    :param strings: list of words\n    :return: Average length of word on list\n    \"\"\"\n    if not strings:\n        return 0\n\n    return sum(len(word) for word in strings) / len(strings)", "code_tokens": "def get_average_length_of_string ( strings ) : if not strings : return 0 return sum ( len ( word ) for word in strings ) / len ( strings )", "docstring_tokens": "Computes average length of words", "label": 0}, {"idx": "cosqa-train-5813", "doc": "max heap priority queue python", "code": "def heappush_max(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown_max(heap, 0, len(heap) - 1)", "code_tokens": "def heappush_max ( heap , item ) : heap . append ( item ) _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "docstring_tokens": "Push item onto heap maintaining the heap invariant .", "label": 0}, {"idx": "cosqa-train-5814", "doc": "python write all items", "code": "def flush(self):\n        \"\"\"Ensure contents are written to file.\"\"\"\n        for name in self.item_names:\n            item = self[name]\n            item.flush()\n        self.file.flush()", "code_tokens": "def flush ( self ) : for name in self . item_names : item = self [ name ] item . flush ( ) self . file . flush ( )", "docstring_tokens": "Ensure contents are written to file .", "label": 0}, {"idx": "cosqa-train-5815", "doc": "maximum line length in python", "code": "def _multiline_width(multiline_s, line_width_fn=len):\n    \"\"\"Visible width of a potentially multiline content.\"\"\"\n    return max(map(line_width_fn, re.split(\"[\\r\\n]\", multiline_s)))", "code_tokens": "def _multiline_width ( multiline_s , line_width_fn = len ) : return max ( map ( line_width_fn , re . split ( \"[\\r\\n]\" , multiline_s ) ) )", "docstring_tokens": "Visible width of a potentially multiline content .", "label": 0}, {"idx": "cosqa-train-5816", "doc": "python write base64 string to image file", "code": "def base64ToImage(imgData, out_path, out_file):\n        \"\"\" converts a base64 string to a file \"\"\"\n        fh = open(os.path.join(out_path, out_file), \"wb\")\n        fh.write(imgData.decode('base64'))\n        fh.close()\n        del fh\n        return os.path.join(out_path, out_file)", "code_tokens": "def base64ToImage ( imgData , out_path , out_file ) : fh = open ( os . path . join ( out_path , out_file ) , \"wb\" ) fh . write ( imgData . decode ( 'base64' ) ) fh . close ( ) del fh return os . path . join ( out_path , out_file )", "docstring_tokens": "converts a base64 string to a file", "label": 0}, {"idx": "cosqa-train-5817", "doc": "maximum precision of floar in python", "code": "def get_decimal_quantum(precision):\n    \"\"\"Return minimal quantum of a number, as defined by precision.\"\"\"\n    assert isinstance(precision, (int, decimal.Decimal))\n    return decimal.Decimal(10) ** (-precision)", "code_tokens": "def get_decimal_quantum ( precision ) : assert isinstance ( precision , ( int , decimal . Decimal ) ) return decimal . Decimal ( 10 ) ** ( - precision )", "docstring_tokens": "Return minimal quantum of a number as defined by precision .", "label": 1}, {"idx": "cosqa-train-5818", "doc": "python write json to file wrap", "code": "def _serialize_json(obj, fp):\n    \"\"\" Serialize ``obj`` as a JSON formatted stream to ``fp`` \"\"\"\n    json.dump(obj, fp, indent=4, default=serialize)", "code_tokens": "def _serialize_json ( obj , fp ) : json . dump ( obj , fp , indent = 4 , default = serialize )", "docstring_tokens": "Serialize obj as a JSON formatted stream to fp", "label": 0}, {"idx": "cosqa-train-5819", "doc": "measure string drawing size python", "code": "def text_width(string, font_name, font_size):\n    \"\"\"Determine with width in pixels of string.\"\"\"\n    return stringWidth(string, fontName=font_name, fontSize=font_size)", "code_tokens": "def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )", "docstring_tokens": "Determine with width in pixels of string .", "label": 0}, {"idx": "cosqa-train-5820", "doc": "python write out json file from yelp", "code": "def serialize_yaml_tofile(filename, resource):\n    \"\"\"\n    Serializes a K8S resource to YAML-formatted file.\n    \"\"\"\n    stream = file(filename, \"w\")\n    yaml.dump(resource, stream, default_flow_style=False)", "code_tokens": "def serialize_yaml_tofile ( filename , resource ) : stream = file ( filename , \"w\" ) yaml . dump ( resource , stream , default_flow_style = False )", "docstring_tokens": "Serializes a K8S resource to YAML - formatted file .", "label": 0}, {"idx": "cosqa-train-5821", "doc": "median for collection of numbers python", "code": "def median_high(data):\n    \"\"\"Return the high median of data.\n\n    When the number of data points is odd, the middle value is returned.\n    When it is even, the larger of the two middle values is returned.\n\n    \"\"\"\n    data = sorted(data)\n    n = len(data)\n    if n == 0:\n        raise StatisticsError(\"no median for empty data\")\n    return data[n // 2]", "code_tokens": "def median_high ( data ) : data = sorted ( data ) n = len ( data ) if n == 0 : raise StatisticsError ( \"no median for empty data\" ) return data [ n // 2 ]", "docstring_tokens": "Return the high median of data .", "label": 0}, {"idx": "cosqa-train-5822", "doc": "python write string to file\\", "code": "def write_str2file(pathname, astr):\n    \"\"\"writes a string to file\"\"\"\n    fname = pathname\n    fhandle = open(fname, 'wb')\n    fhandle.write(astr)\n    fhandle.close()", "code_tokens": "def write_str2file ( pathname , astr ) : fname = pathname fhandle = open ( fname , 'wb' ) fhandle . write ( astr ) fhandle . close ( )", "docstring_tokens": "writes a string to file", "label": 1}, {"idx": "cosqa-train-5823", "doc": "memory address of python object", "code": "def objectproxy_realaddress(obj):\n    \"\"\"\n    Obtain a real address as an integer from an objectproxy.\n    \"\"\"\n    voidp = QROOT.TPython.ObjectProxy_AsVoidPtr(obj)\n    return C.addressof(C.c_char.from_buffer(voidp))", "code_tokens": "def objectproxy_realaddress ( obj ) : voidp = QROOT . TPython . ObjectProxy_AsVoidPtr ( obj ) return C . addressof ( C . c_char . from_buffer ( voidp ) )", "docstring_tokens": "Obtain a real address as an integer from an objectproxy .", "label": 0}, {"idx": "cosqa-train-5824", "doc": "python write to yaml file for ansible", "code": "def write_config(self, outfile):\n        \"\"\"Write the configuration dictionary to an output file.\"\"\"\n        utils.write_yaml(self.config, outfile, default_flow_style=False)", "code_tokens": "def write_config ( self , outfile ) : utils . write_yaml ( self . config , outfile , default_flow_style = False )", "docstring_tokens": "Write the configuration dictionary to an output file .", "label": 1}, {"idx": "cosqa-train-5825", "doc": "mention relative path in python", "code": "def _rel(self, path):\n        \"\"\"\n        Get the relative path for the given path from the current\n        file by working around https://bugs.python.org/issue20012.\n        \"\"\"\n        return os.path.relpath(\n            str(path), self._parent).replace(os.path.sep, '/')", "code_tokens": "def _rel ( self , path ) : return os . path . relpath ( str ( path ) , self . _parent ) . replace ( os . path . sep , '/' )", "docstring_tokens": "Get the relative path for the given path from the current file by working around https : // bugs . python . org / issue20012 .", "label": 0}, {"idx": "cosqa-train-5826", "doc": "python wrong continued indentation before block", "code": "def end_block(self):\n        \"\"\"Ends an indentation block, leaving an empty line afterwards\"\"\"\n        self.current_indent -= 1\n\n        # If we did not add a new line automatically yet, now it's the time!\n        if not self.auto_added_line:\n            self.writeln()\n            self.auto_added_line = True", "code_tokens": "def end_block ( self ) : self . current_indent -= 1 # If we did not add a new line automatically yet, now it's the time! if not self . auto_added_line : self . writeln ( ) self . auto_added_line = True", "docstring_tokens": "Ends an indentation block leaving an empty line afterwards", "label": 0}, {"idx": "cosqa-train-5827", "doc": "merge 2 ranges python", "code": "def merge(self, other):\n        \"\"\"\n        Merge this range object with another (ranges need not overlap or abut).\n\n        :returns: a new Range object representing the interval containing both\n                  ranges.\n        \"\"\"\n        newstart = min(self._start, other.start)\n        newend = max(self._end, other.end)\n        return Range(newstart, newend)", "code_tokens": "def merge ( self , other ) : newstart = min ( self . _start , other . start ) newend = max ( self . _end , other . end ) return Range ( newstart , newend )", "docstring_tokens": "Merge this range object with another ( ranges need not overlap or abut ) .", "label": 0}, {"idx": "cosqa-train-5828", "doc": "python wx change the panel color", "code": "def _update_bordercolor(self, bordercolor):\n        \"\"\"Updates background color\"\"\"\n\n        border_color = wx.SystemSettings_GetColour(wx.SYS_COLOUR_ACTIVEBORDER)\n        border_color.SetRGB(bordercolor)\n\n        self.linecolor_choice.SetColour(border_color)", "code_tokens": "def _update_bordercolor ( self , bordercolor ) : border_color = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_ACTIVEBORDER ) border_color . SetRGB ( bordercolor ) self . linecolor_choice . SetColour ( border_color )", "docstring_tokens": "Updates background color", "label": 0}, {"idx": "cosqa-train-5829", "doc": "merge two range python", "code": "def merge(self, other):\n        \"\"\"\n        Merge this range object with another (ranges need not overlap or abut).\n\n        :returns: a new Range object representing the interval containing both\n                  ranges.\n        \"\"\"\n        newstart = min(self._start, other.start)\n        newend = max(self._end, other.end)\n        return Range(newstart, newend)", "code_tokens": "def merge ( self , other ) : newstart = min ( self . _start , other . start ) newend = max ( self . _end , other . end ) return Range ( newstart , newend )", "docstring_tokens": "Merge this range object with another ( ranges need not overlap or abut ) .", "label": 0}, {"idx": "cosqa-train-5830", "doc": "python xlib get mouse coordinates", "code": "def get_mouse_location(self):\n        \"\"\"\n        Get the current mouse location (coordinates and screen number).\n\n        :return: a namedtuple with ``x``, ``y`` and ``screen_num`` fields\n        \"\"\"\n        x = ctypes.c_int(0)\n        y = ctypes.c_int(0)\n        screen_num = ctypes.c_int(0)\n        _libxdo.xdo_get_mouse_location(\n            self._xdo, ctypes.byref(x), ctypes.byref(y),\n            ctypes.byref(screen_num))\n        return mouse_location(x.value, y.value, screen_num.value)", "code_tokens": "def get_mouse_location ( self ) : x = ctypes . c_int ( 0 ) y = ctypes . c_int ( 0 ) screen_num = ctypes . c_int ( 0 ) _libxdo . xdo_get_mouse_location ( self . _xdo , ctypes . byref ( x ) , ctypes . byref ( y ) , ctypes . byref ( screen_num ) ) return mouse_location ( x . value , y . value , screen_num . value )", "docstring_tokens": "Get the current mouse location ( coordinates and screen number ) .", "label": 0}, {"idx": "cosqa-train-5831", "doc": "merging multiple list in a single list in python", "code": "def listunion(ListOfLists):\n    \"\"\"\n    Take the union of a list of lists.\n\n    Take a Python list of Python lists::\n\n            [[l11,l12, ...], [l21,l22, ...], ... , [ln1, ln2, ...]]\n\n    and return the aggregated list::\n\n            [l11,l12, ..., l21, l22 , ...]\n\n    For a list of two lists, e.g. `[a, b]`, this is like::\n\n            a.extend(b)\n\n    **Parameters**\n\n            **ListOfLists** :  Python list\n\n                    Python list of Python lists.\n\n    **Returns**\n\n            **u** :  Python list\n\n                    Python list created by taking the union of the\n                    lists in `ListOfLists`.\n\n    \"\"\"\n    u = []\n    for s in ListOfLists:\n        if s != None:\n            u.extend(s)\n    return u", "code_tokens": "def listunion ( ListOfLists ) : u = [ ] for s in ListOfLists : if s != None : u . extend ( s ) return u", "docstring_tokens": "Take the union of a list of lists .", "label": 0}, {"idx": "cosqa-train-5832", "doc": "python xml sax parser into dictionary", "code": "def xml_str_to_dict(s):\n    \"\"\" Transforms an XML string it to python-zimbra dict format\n\n    For format, see:\n      https://github.com/Zimbra-Community/python-zimbra/blob/master/README.md\n\n    :param: a string, containing XML\n    :returns: a dict, with python-zimbra format\n    \"\"\"\n    xml = minidom.parseString(s)\n    return pythonzimbra.tools.xmlserializer.dom_to_dict(xml.firstChild)", "code_tokens": "def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )", "docstring_tokens": "Transforms an XML string it to python - zimbra dict format", "label": 1}, {"idx": "cosqa-train-5833", "doc": "message channel python bot", "code": "def send_notice(self, text):\n        \"\"\"Send a notice (from bot) message to the room.\"\"\"\n        return self.client.api.send_notice(self.room_id, text)", "code_tokens": "def send_notice ( self , text ) : return self . client . api . send_notice ( self . room_id , text )", "docstring_tokens": "Send a notice ( from bot ) message to the room .", "label": 0}, {"idx": "cosqa-train-5834", "doc": "python xml schema validation using", "code": "def validate(self, xml_input):\n        \"\"\"\n        This method validate the parsing and schema, return a boolean\n        \"\"\"\n        parsed_xml = etree.parse(self._handle_xml(xml_input))\n        try:\n            return self.xmlschema.validate(parsed_xml)\n        except AttributeError:\n            raise CannotValidate('Set XSD to validate the XML')", "code_tokens": "def validate ( self , xml_input ) : parsed_xml = etree . parse ( self . _handle_xml ( xml_input ) ) try : return self . xmlschema . validate ( parsed_xml ) except AttributeError : raise CannotValidate ( 'Set XSD to validate the XML' )", "docstring_tokens": "This method validate the parsing and schema return a boolean", "label": 1}, {"idx": "cosqa-train-5835", "doc": "method used for deleting last element in python list", "code": "def pop(self, index=-1):\n\t\t\"\"\"Remove and return the item at index.\"\"\"\n\t\tvalue = self._list.pop(index)\n\t\tdel self._dict[value]\n\t\treturn value", "code_tokens": "def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value", "docstring_tokens": "Remove and return the item at index .", "label": 1}, {"idx": "cosqa-train-5836", "doc": "modified geographic coordinates on spherical coordinates python", "code": "def get_lons_from_cartesian(x__, y__):\n    \"\"\"Get longitudes from cartesian coordinates.\n    \"\"\"\n    return rad2deg(arccos(x__ / sqrt(x__ ** 2 + y__ ** 2))) * sign(y__)", "code_tokens": "def get_lons_from_cartesian ( x__ , y__ ) : return rad2deg ( arccos ( x__ / sqrt ( x__ ** 2 + y__ ** 2 ) ) ) * sign ( y__ )", "docstring_tokens": "Get longitudes from cartesian coordinates .", "label": 0}, {"idx": "cosqa-train-5837", "doc": "python xpath get node all content", "code": "def _extract_node_text(node):\n    \"\"\"Extract text from a given lxml node.\"\"\"\n\n    texts = map(\n        six.text_type.strip, map(six.text_type, map(unescape, node.xpath(\".//text()\")))\n    )\n    return \" \".join(text for text in texts if text)", "code_tokens": "def _extract_node_text ( node ) : texts = map ( six . text_type . strip , map ( six . text_type , map ( unescape , node . xpath ( \".//text()\" ) ) ) ) return \" \" . join ( text for text in texts if text )", "docstring_tokens": "Extract text from a given lxml node .", "label": 1}, {"idx": "cosqa-train-5838", "doc": "modify the dice roll program to call a function for the die roll s python", "code": "def roll_dice():\n    \"\"\"\n    Roll a die.\n\n    :return: None\n    \"\"\"\n    sums = 0  # will return the sum of the roll calls.\n    while True:\n        roll = random.randint(1, 6)\n        sums += roll\n        if(input(\"Enter y or n to continue: \").upper()) == 'N':\n            print(sums)  # prints the sum of the roll calls\n            break", "code_tokens": "def roll_dice ( ) : sums = 0 # will return the sum of the roll calls. while True : roll = random . randint ( 1 , 6 ) sums += roll if ( input ( \"Enter y or n to continue: \" ) . upper ( ) ) == 'N' : print ( sums ) # prints the sum of the roll calls break", "docstring_tokens": "Roll a die .", "label": 1}, {"idx": "cosqa-train-5839", "doc": "python yaml dump compact format", "code": "def print_yaml(o):\n    \"\"\"Pretty print an object as YAML.\"\"\"\n    print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))", "code_tokens": "def print_yaml ( o ) : print ( yaml . dump ( o , default_flow_style = False , indent = 4 , encoding = 'utf-8' ) )", "docstring_tokens": "Pretty print an object as YAML .", "label": 0}, {"idx": "cosqa-train-5840", "doc": "mongodb python create index every time", "code": "def ensure_index(self, key, unique=False):\n        \"\"\"Wrapper for pymongo.Collection.ensure_index\n        \"\"\"\n        return self.collection.ensure_index(key, unique=unique)", "code_tokens": "def ensure_index ( self , key , unique = False ) : return self . collection . ensure_index ( key , unique = unique )", "docstring_tokens": "Wrapper for pymongo . Collection . ensure_index", "label": 0}, {"idx": "cosqa-train-5841", "doc": "python zipfile for folder", "code": "def extract_zip(zip_path, target_folder):\n    \"\"\"\n    Extract the content of the zip-file at `zip_path` into `target_folder`.\n    \"\"\"\n    with zipfile.ZipFile(zip_path) as archive:\n        archive.extractall(target_folder)", "code_tokens": "def extract_zip ( zip_path , target_folder ) : with zipfile . ZipFile ( zip_path ) as archive : archive . extractall ( target_folder )", "docstring_tokens": "Extract the content of the zip - file at zip_path into target_folder .", "label": 0}, {"idx": "cosqa-train-5842", "doc": "mongodb python sort multiple field", "code": "def order_by(self, *fields):\n        \"\"\"An alternate to ``sort`` which allows you to specify a list\n        of fields and use a leading - (minus) to specify DESCENDING.\"\"\"\n        doc = []\n        for field in fields:\n            if field.startswith('-'):\n                doc.append((field.strip('-'), pymongo.DESCENDING))\n            else:\n                doc.append((field, pymongo.ASCENDING))\n        return self.sort(doc)", "code_tokens": "def order_by ( self , * fields ) : doc = [ ] for field in fields : if field . startswith ( '-' ) : doc . append ( ( field . strip ( '-' ) , pymongo . DESCENDING ) ) else : doc . append ( ( field , pymongo . ASCENDING ) ) return self . sort ( doc )", "docstring_tokens": "An alternate to sort which allows you to specify a list of fields and use a leading - ( minus ) to specify DESCENDING .", "label": 0}, {"idx": "cosqa-train-5843", "doc": "python zlib java gzip", "code": "def compressBuffer(buffer):\n    \"\"\"\n    Note that this code compresses into a buffer held in memory, rather\n    than a disk file. This is done through the use of cStringIO.StringIO().\n    \"\"\"\n    # http://jython.xhaus.com/http-compression-in-python-and-jython/\n    zbuf = cStringIO.StringIO()\n    zfile = gzip.GzipFile(mode='wb', fileobj=zbuf, compresslevel=9)\n    zfile.write(buffer)\n    zfile.close()\n    return zbuf.getvalue()", "code_tokens": "def compressBuffer ( buffer ) : # http://jython.xhaus.com/http-compression-in-python-and-jython/ zbuf = cStringIO . StringIO ( ) zfile = gzip . GzipFile ( mode = 'wb' , fileobj = zbuf , compresslevel = 9 ) zfile . write ( buffer ) zfile . close ( ) return zbuf . getvalue ( )", "docstring_tokens": "Note that this code compresses into a buffer held in memory rather than a disk file . This is done through the use of cStringIO . StringIO () .", "label": 1}, {"idx": "cosqa-train-5844", "doc": "most common element in array python", "code": "def _most_common(iterable):\n    \"\"\"Returns the most common element in `iterable`.\"\"\"\n    data = Counter(iterable)\n    return max(data, key=data.__getitem__)", "code_tokens": "def _most_common ( iterable ) : data = Counter ( iterable ) return max ( data , key = data . __getitem__ )", "docstring_tokens": "Returns the most common element in iterable .", "label": 1}, {"idx": "cosqa-train-5845", "doc": "python, iterating through a string in chunks", "code": "def pieces(array, chunk_size):\n        \"\"\"Yield successive chunks from array/list/string.\n        Final chunk may be truncated if array is not evenly divisible by chunk_size.\"\"\"\n        for i in range(0, len(array), chunk_size): yield array[i:i+chunk_size]", "code_tokens": "def pieces ( array , chunk_size ) : for i in range ( 0 , len ( array ) , chunk_size ) : yield array [ i : i + chunk_size ]", "docstring_tokens": "Yield successive chunks from array / list / string . Final chunk may be truncated if array is not evenly divisible by chunk_size .", "label": 1}, {"idx": "cosqa-train-5846", "doc": "multiple hash comments out python", "code": "def _add_hash(source):\n    \"\"\"Add a leading hash '#' at the beginning of every line in the source.\"\"\"\n    source = '\\n'.join('# ' + line.rstrip()\n                       for line in source.splitlines())\n    return source", "code_tokens": "def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "docstring_tokens": "Add a leading hash # at the beginning of every line in the source .", "label": 0}, {"idx": "cosqa-train-5847", "doc": "python, locate the minimum value in a list", "code": "def find_lt(a, x):\n    \"\"\"Find rightmost value less than x.\"\"\"\n    i = bs.bisect_left(a, x)\n    if i: return i - 1\n    raise ValueError", "code_tokens": "def find_lt ( a , x ) : i = bs . bisect_left ( a , x ) if i : return i - 1 raise ValueError", "docstring_tokens": "Find rightmost value less than x .", "label": 0}, {"idx": "cosqa-train-5848", "doc": "multiple static methods python", "code": "def static_method(cls, f):\n        \"\"\"Decorator which dynamically binds static methods to the model for later use.\"\"\"\n        setattr(cls, f.__name__, staticmethod(f))\n        return f", "code_tokens": "def static_method ( cls , f ) : setattr ( cls , f . __name__ , staticmethod ( f ) ) return f", "docstring_tokens": "Decorator which dynamically binds static methods to the model for later use .", "label": 0}, {"idx": "cosqa-train-5849", "doc": "python, sql table column details", "code": "def column_names(self, table):\n      \"\"\"An iterable of column names, for a particular table or\n      view.\"\"\"\n\n      table_info = self.execute(\n        u'PRAGMA table_info(%s)' % quote(table))\n      return (column['name'] for column in table_info)", "code_tokens": "def column_names ( self , table ) : table_info = self . execute ( u'PRAGMA table_info(%s)' % quote ( table ) ) return ( column [ 'name' ] for column in table_info )", "docstring_tokens": "An iterable of column names for a particular table or view .", "label": 1}, {"idx": "cosqa-train-5850", "doc": "ndarray to series with index python", "code": "def from_series(cls, series):\n        \"\"\"Convert a pandas.Series into an xarray.DataArray.\n\n        If the series's index is a MultiIndex, it will be expanded into a\n        tensor product of one-dimensional coordinates (filling in missing\n        values with NaN). Thus this operation should be the inverse of the\n        `to_series` method.\n        \"\"\"\n        # TODO: add a 'name' parameter\n        name = series.name\n        df = pd.DataFrame({name: series})\n        ds = Dataset.from_dataframe(df)\n        return ds[name]", "code_tokens": "def from_series ( cls , series ) : # TODO: add a 'name' parameter name = series . name df = pd . DataFrame ( { name : series } ) ds = Dataset . from_dataframe ( df ) return ds [ name ]", "docstring_tokens": "Convert a pandas . Series into an xarray . DataArray .", "label": 0}, {"idx": "cosqa-train-5851", "doc": "python3 async only allow one at a time", "code": "def access(self, accessor, timeout=None):\n        \"\"\"Return a result from an asyncio future.\"\"\"\n        if self.loop.is_running():\n            raise RuntimeError(\"Loop is already running\")\n        coro = asyncio.wait_for(accessor, timeout, loop=self.loop)\n        return self.loop.run_until_complete(coro)", "code_tokens": "def access ( self , accessor , timeout = None ) : if self . loop . is_running ( ) : raise RuntimeError ( \"Loop is already running\" ) coro = asyncio . wait_for ( accessor , timeout , loop = self . loop ) return self . loop . run_until_complete ( coro )", "docstring_tokens": "Return a result from an asyncio future .", "label": 0}, {"idx": "cosqa-train-5852", "doc": "nearest neighbor interpolation code in python", "code": "def interpolate_nearest(self, xi, yi, zdata):\n        \"\"\"\n        Nearest-neighbour interpolation.\n        Calls nearnd to find the index of the closest neighbours to xi,yi\n\n        Parameters\n        ----------\n         xi : float / array of floats, shape (l,)\n            x coordinates on the Cartesian plane\n         yi : float / array of floats, shape (l,)\n            y coordinates on the Cartesian plane\n\n        Returns\n        -------\n         zi : float / array of floats, shape (l,)\n            nearest-neighbour interpolated value(s) of (xi,yi)\n        \"\"\"\n        if zdata.size != self.npoints:\n            raise ValueError('zdata should be same size as mesh')\n\n        zdata = self._shuffle_field(zdata)\n\n        ist = np.ones_like(xi, dtype=np.int32)\n        ist, dist = _tripack.nearnds(xi, yi, ist, self._x, self._y,\n                                     self.lst, self.lptr, self.lend)\n        return zdata[ist - 1]", "code_tokens": "def interpolate_nearest ( self , xi , yi , zdata ) : if zdata . size != self . npoints : raise ValueError ( 'zdata should be same size as mesh' ) zdata = self . _shuffle_field ( zdata ) ist = np . ones_like ( xi , dtype = np . int32 ) ist , dist = _tripack . nearnds ( xi , yi , ist , self . _x , self . _y , self . lst , self . lptr , self . lend ) return zdata [ ist - 1 ]", "docstring_tokens": "Nearest - neighbour interpolation . Calls nearnd to find the index of the closest neighbours to xi yi", "label": 0}, {"idx": "cosqa-train-5853", "doc": "python3 byte to string]", "code": "def ub_to_str(string):\n    \"\"\"\n    converts py2 unicode / py3 bytestring into str\n    Args:\n        string (unicode, byte_string): string to be converted\n        \n    Returns:\n        (str)\n    \"\"\"\n    if not isinstance(string, str):\n        if six.PY2:\n            return str(string)\n        else:\n            return string.decode()\n    return string", "code_tokens": "def ub_to_str ( string ) : if not isinstance ( string , str ) : if six . PY2 : return str ( string ) else : return string . decode ( ) return string", "docstring_tokens": "converts py2 unicode / py3 bytestring into str Args : string ( unicode byte_string ) : string to be converted Returns : ( str )", "label": 1}, {"idx": "cosqa-train-5854", "doc": "python3 can not connect to http ssl", "code": "def inject_into_urllib3():\n    \"\"\"\n    Monkey-patch urllib3 with SecureTransport-backed SSL-support.\n    \"\"\"\n    util.ssl_.SSLContext = SecureTransportContext\n    util.HAS_SNI = HAS_SNI\n    util.ssl_.HAS_SNI = HAS_SNI\n    util.IS_SECURETRANSPORT = True\n    util.ssl_.IS_SECURETRANSPORT = True", "code_tokens": "def inject_into_urllib3 ( ) : util . ssl_ . SSLContext = SecureTransportContext util . HAS_SNI = HAS_SNI util . ssl_ . HAS_SNI = HAS_SNI util . IS_SECURETRANSPORT = True util . ssl_ . IS_SECURETRANSPORT = True", "docstring_tokens": "Monkey - patch urllib3 with SecureTransport - backed SSL - support .", "label": 0}, {"idx": "cosqa-train-5855", "doc": "norm of an array python", "code": "def mag(z):\n    \"\"\"Get the magnitude of a vector.\"\"\"\n    if isinstance(z[0], np.ndarray):\n        return np.array(list(map(np.linalg.norm, z)))\n    else:\n        return np.linalg.norm(z)", "code_tokens": "def mag ( z ) : if isinstance ( z [ 0 ] , np . ndarray ) : return np . array ( list ( map ( np . linalg . norm , z ) ) ) else : return np . linalg . norm ( z )", "docstring_tokens": "Get the magnitude of a vector .", "label": 0}, {"idx": "cosqa-train-5856", "doc": "python3 check empty file", "code": "def isemptyfile(filepath):\n    \"\"\"Determine if the file both exists and isempty\n\n    Args:\n        filepath (str, path): file path\n\n    Returns:\n        bool\n    \"\"\"\n    exists = os.path.exists(safepath(filepath))\n    if exists:\n        filesize = os.path.getsize(safepath(filepath))\n        return filesize == 0\n    else:\n        return False", "code_tokens": "def isemptyfile ( filepath ) : exists = os . path . exists ( safepath ( filepath ) ) if exists : filesize = os . path . getsize ( safepath ( filepath ) ) return filesize == 0 else : return False", "docstring_tokens": "Determine if the file both exists and isempty", "label": 0}, {"idx": "cosqa-train-5857", "doc": "normal distribution with excess kurtosis in python", "code": "def norm(x, mu, sigma=1.0):\n    \"\"\" Scipy norm function \"\"\"\n    return stats.norm(loc=mu, scale=sigma).pdf(x)", "code_tokens": "def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )", "docstring_tokens": "Scipy norm function", "label": 0}, {"idx": "cosqa-train-5858", "doc": "python3 check type is byte", "code": "def isstring(value):\n    \"\"\"Report whether the given value is a byte or unicode string.\"\"\"\n    classes = (str, bytes) if pyutils.PY3 else basestring  # noqa: F821\n    return isinstance(value, classes)", "code_tokens": "def isstring ( value ) : classes = ( str , bytes ) if pyutils . PY3 else basestring # noqa: F821 return isinstance ( value , classes )", "docstring_tokens": "Report whether the given value is a byte or unicode string .", "label": 1}, {"idx": "cosqa-train-5859", "doc": "normal gzip file python not a gzipped file", "code": "def get_gzipped_contents(input_file):\n    \"\"\"\n    Returns a gzipped version of a previously opened file's buffer.\n    \"\"\"\n    zbuf = StringIO()\n    zfile = GzipFile(mode=\"wb\", compresslevel=6, fileobj=zbuf)\n    zfile.write(input_file.read())\n    zfile.close()\n    return ContentFile(zbuf.getvalue())", "code_tokens": "def get_gzipped_contents ( input_file ) : zbuf = StringIO ( ) zfile = GzipFile ( mode = \"wb\" , compresslevel = 6 , fileobj = zbuf ) zfile . write ( input_file . read ( ) ) zfile . close ( ) return ContentFile ( zbuf . getvalue ( ) )", "docstring_tokens": "Returns a gzipped version of a previously opened file s buffer .", "label": 0}, {"idx": "cosqa-train-5860", "doc": "python3 check value in enum", "code": "def is_enum_type(type_):\n    \"\"\" Checks if the given type is an enum type.\n\n    :param type_: The type to check\n    :return: True if the type is a enum type, otherwise False\n    :rtype: bool\n    \"\"\"\n\n    return isinstance(type_, type) and issubclass(type_, tuple(_get_types(Types.ENUM)))", "code_tokens": "def is_enum_type ( type_ ) : return isinstance ( type_ , type ) and issubclass ( type_ , tuple ( _get_types ( Types . ENUM ) ) )", "docstring_tokens": "Checks if the given type is an enum type .", "label": 0}, {"idx": "cosqa-train-5861", "doc": "normal probability distribution function python", "code": "def EvalGaussianPdf(x, mu, sigma):\n    \"\"\"Computes the unnormalized PDF of the normal distribution.\n\n    x: value\n    mu: mean\n    sigma: standard deviation\n    \n    returns: float probability density\n    \"\"\"\n    return scipy.stats.norm.pdf(x, mu, sigma)", "code_tokens": "def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )", "docstring_tokens": "Computes the unnormalized PDF of the normal distribution .", "label": 0}, {"idx": "cosqa-train-5862", "doc": "normalize column vector python", "code": "def v_normalize(v):\n    \"\"\"\n    Normalizes the given vector.\n    \n    The vector given may have any number of dimensions.\n    \"\"\"\n    vmag = v_magnitude(v)\n    return [ v[i]/vmag  for i in range(len(v)) ]", "code_tokens": "def v_normalize ( v ) : vmag = v_magnitude ( v ) return [ v [ i ] / vmag for i in range ( len ( v ) ) ]", "docstring_tokens": "Normalizes the given vector . The vector given may have any number of dimensions .", "label": 0}, {"idx": "cosqa-train-5863", "doc": "python3 hashlib md5 to string", "code": "def md5_string(s):\n    \"\"\"\n    Shortcut to create md5 hash\n    :param s:\n    :return:\n    \"\"\"\n    m = hashlib.md5()\n    m.update(s)\n    return str(m.hexdigest())", "code_tokens": "def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )", "docstring_tokens": "Shortcut to create md5 hash : param s : : return :", "label": 0}, {"idx": "cosqa-train-5864", "doc": "normalize image in python 0 to 1", "code": "def _normalize(mat: np.ndarray):\n    \"\"\"rescales a numpy array, so that min is 0 and max is 255\"\"\"\n    return ((mat - mat.min()) * (255 / mat.max())).astype(np.uint8)", "code_tokens": "def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )", "docstring_tokens": "rescales a numpy array so that min is 0 and max is 255", "label": 0}, {"idx": "cosqa-train-5865", "doc": "python3 how to check if something is iterable", "code": "def is_seq(obj):\n    \"\"\" Returns True if object is not a string but is iterable \"\"\"\n    if not hasattr(obj, '__iter__'):\n        return False\n    if isinstance(obj, basestring):\n        return False\n    return True", "code_tokens": "def is_seq ( obj ) : if not hasattr ( obj , '__iter__' ) : return False if isinstance ( obj , basestring ) : return False return True", "docstring_tokens": "Returns True if object is not a string but is iterable", "label": 0}, {"idx": "cosqa-train-5866", "doc": "normalizing an rgb image python", "code": "def normalize(im, invert=False, scale=None, dtype=np.float64):\n    \"\"\"\n    Normalize a field to a (min, max) exposure range, default is (0, 255).\n    (min, max) exposure values. Invert the image if requested.\n    \"\"\"\n    if dtype not in {np.float16, np.float32, np.float64}:\n        raise ValueError('dtype must be numpy.float16, float32, or float64.')\n    out = im.astype('float').copy()\n\n    scale = scale or (0.0, 255.0)\n    l, u = (float(i) for i in scale)\n    out = (out - l) / (u - l)\n    if invert:\n        out = -out + (out.max() + out.min())\n    return out.astype(dtype)", "code_tokens": "def normalize ( im , invert = False , scale = None , dtype = np . float64 ) : if dtype not in { np . float16 , np . float32 , np . float64 } : raise ValueError ( 'dtype must be numpy.float16, float32, or float64.' ) out = im . astype ( 'float' ) . copy ( ) scale = scale or ( 0.0 , 255.0 ) l , u = ( float ( i ) for i in scale ) out = ( out - l ) / ( u - l ) if invert : out = - out + ( out . max ( ) + out . min ( ) ) return out . astype ( dtype )", "docstring_tokens": "Normalize a field to a ( min max ) exposure range default is ( 0 255 ) . ( min max ) exposure values . Invert the image if requested .", "label": 0}, {"idx": "cosqa-train-5867", "doc": "not a gzipped file python gunzip", "code": "def get_gzipped_contents(input_file):\n    \"\"\"\n    Returns a gzipped version of a previously opened file's buffer.\n    \"\"\"\n    zbuf = StringIO()\n    zfile = GzipFile(mode=\"wb\", compresslevel=6, fileobj=zbuf)\n    zfile.write(input_file.read())\n    zfile.close()\n    return ContentFile(zbuf.getvalue())", "code_tokens": "def get_gzipped_contents ( input_file ) : zbuf = StringIO ( ) zfile = GzipFile ( mode = \"wb\" , compresslevel = 6 , fileobj = zbuf ) zfile . write ( input_file . read ( ) ) zfile . close ( ) return ContentFile ( zbuf . getvalue ( ) )", "docstring_tokens": "Returns a gzipped version of a previously opened file s buffer .", "label": 0}, {"idx": "cosqa-train-5868", "doc": "python3 how to test if a directory is valid", "code": "def is_valid_folder(parser, arg):\n    \"\"\"Check if arg is a valid file that already exists on the file system.\"\"\"\n    arg = os.path.abspath(arg)\n    if not os.path.isdir(arg):\n        parser.error(\"The folder %s does not exist!\" % arg)\n    else:\n        return arg", "code_tokens": "def is_valid_folder ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . isdir ( arg ) : parser . error ( \"The folder %s does not exist!\" % arg ) else : return arg", "docstring_tokens": "Check if arg is a valid file that already exists on the file system .", "label": 0}, {"idx": "cosqa-train-5869", "doc": "number of common characters in python strings", "code": "def count_string_diff(a,b):\n    \"\"\"Return the number of characters in two strings that don't exactly match\"\"\"\n    shortest = min(len(a), len(b))\n    return sum(a[i] != b[i] for i in range(shortest))", "code_tokens": "def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )", "docstring_tokens": "Return the number of characters in two strings that don t exactly match", "label": 0}, {"idx": "cosqa-train-5870", "doc": "python3 how to upper case a string", "code": "def clean(some_string, uppercase=False):\n    \"\"\"\n    helper to clean up an input string\n    \"\"\"\n    if uppercase:\n        return some_string.strip().upper()\n    else:\n        return some_string.strip().lower()", "code_tokens": "def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )", "docstring_tokens": "helper to clean up an input string", "label": 0}, {"idx": "cosqa-train-5871", "doc": "numpy array and python list", "code": "def dump_nparray(self, obj, class_name=numpy_ndarray_class_name):\n        \"\"\"\n        ``numpy.ndarray`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: self._json_convert(obj.tolist())}", "code_tokens": "def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { \"$\" + class_name : self . _json_convert ( obj . tolist ( ) ) }", "docstring_tokens": "numpy . ndarray dumper .", "label": 1}, {"idx": "cosqa-train-5872", "doc": "python3 jinja object render", "code": "def render(template, context):\n        \"\"\"Wrapper to the jinja2 render method from a template file\n\n        Parameters\n        ----------\n        template : str\n            Path to template file.\n        context : dict\n            Dictionary with kwargs context to populate the template\n        \"\"\"\n\n        path, filename = os.path.split(template)\n\n        return jinja2.Environment(\n            loader=jinja2.FileSystemLoader(path or './')\n        ).get_template(filename).render(context)", "code_tokens": "def render ( template , context ) : path , filename = os . path . split ( template ) return jinja2 . Environment ( loader = jinja2 . FileSystemLoader ( path or './' ) ) . get_template ( filename ) . render ( context )", "docstring_tokens": "Wrapper to the jinja2 render method from a template file", "label": 0}, {"idx": "cosqa-train-5873", "doc": "numpy array with different size of arrays python", "code": "def _unique_rows_numpy(a):\n    \"\"\"return unique rows\"\"\"\n    a = np.ascontiguousarray(a)\n    unique_a = np.unique(a.view([('', a.dtype)] * a.shape[1]))\n    return unique_a.view(a.dtype).reshape((unique_a.shape[0], a.shape[1]))", "code_tokens": "def _unique_rows_numpy ( a ) : a = np . ascontiguousarray ( a ) unique_a = np . unique ( a . view ( [ ( '' , a . dtype ) ] * a . shape [ 1 ] ) ) return unique_a . view ( a . dtype ) . reshape ( ( unique_a . shape [ 0 ] , a . shape [ 1 ] ) )", "docstring_tokens": "return unique rows", "label": 0}, {"idx": "cosqa-train-5874", "doc": "python3 make image height equal width", "code": "def scale_image(image, new_width):\n    \"\"\"Resizes an image preserving the aspect ratio.\n    \"\"\"\n    (original_width, original_height) = image.size\n    aspect_ratio = original_height/float(original_width)\n    new_height = int(aspect_ratio * new_width)\n\n    # This scales it wider than tall, since characters are biased\n    new_image = image.resize((new_width*2, new_height))\n    return new_image", "code_tokens": "def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image", "docstring_tokens": "Resizes an image preserving the aspect ratio .", "label": 1}, {"idx": "cosqa-train-5875", "doc": "numpy datetime64 to python datetime", "code": "def ensure_us_time_resolution(val):\n    \"\"\"Convert val out of numpy time, for use in to_dict.\n    Needed because of numpy bug GH#7619\"\"\"\n    if np.issubdtype(val.dtype, np.datetime64):\n        val = val.astype('datetime64[us]')\n    elif np.issubdtype(val.dtype, np.timedelta64):\n        val = val.astype('timedelta64[us]')\n    return val", "code_tokens": "def ensure_us_time_resolution ( val ) : if np . issubdtype ( val . dtype , np . datetime64 ) : val = val . astype ( 'datetime64[us]' ) elif np . issubdtype ( val . dtype , np . timedelta64 ) : val = val . astype ( 'timedelta64[us]' ) return val", "docstring_tokens": "Convert val out of numpy time for use in to_dict . Needed because of numpy bug GH#7619", "label": 0}, {"idx": "cosqa-train-5876", "doc": "python3 separate requests in same session", "code": "def setup_request_sessions(self):\n        \"\"\" Sets up a requests.Session object for sharing headers across API requests.\n        \"\"\"\n        self.req_session = requests.Session()\n        self.req_session.headers.update(self.headers)", "code_tokens": "def setup_request_sessions ( self ) : self . req_session = requests . Session ( ) self . req_session . headers . update ( self . headers )", "docstring_tokens": "Sets up a requests . Session object for sharing headers across API requests .", "label": 0}, {"idx": "cosqa-train-5877", "doc": "numpy python normal cdf", "code": "def lognormcdf(x, mu, tau):\n    \"\"\"Log-normal cumulative density function\"\"\"\n    x = np.atleast_1d(x)\n    return np.array(\n        [0.5 * (1 - flib.derf(-(np.sqrt(tau / 2)) * (np.log(y) - mu))) for y in x])", "code_tokens": "def lognormcdf ( x , mu , tau ) : x = np . atleast_1d ( x ) return np . array ( [ 0.5 * ( 1 - flib . derf ( - ( np . sqrt ( tau / 2 ) ) * ( np . log ( y ) - mu ) ) ) for y in x ] )", "docstring_tokens": "Log - normal cumulative density function", "label": 0}, {"idx": "cosqa-train-5878", "doc": "python3 xml string to dict", "code": "def xml_str_to_dict(s):\n    \"\"\" Transforms an XML string it to python-zimbra dict format\n\n    For format, see:\n      https://github.com/Zimbra-Community/python-zimbra/blob/master/README.md\n\n    :param: a string, containing XML\n    :returns: a dict, with python-zimbra format\n    \"\"\"\n    xml = minidom.parseString(s)\n    return pythonzimbra.tools.xmlserializer.dom_to_dict(xml.firstChild)", "code_tokens": "def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )", "docstring_tokens": "Transforms an XML string it to python - zimbra dict format", "label": 0}, {"idx": "cosqa-train-5879", "doc": "object oriented to stack push method python", "code": "def push(h, x):\n    \"\"\"Push a new value into heap.\"\"\"\n    h.push(x)\n    up(h, h.size()-1)", "code_tokens": "def push ( h , x ) : h . push ( x ) up ( h , h . size ( ) - 1 )", "docstring_tokens": "Push a new value into heap .", "label": 0}, {"idx": "cosqa-train-5880", "doc": "pythonreturn json file from a function", "code": "def information(filename):\n    \"\"\"Returns the file exif\"\"\"\n    check_if_this_file_exist(filename)\n    filename = os.path.abspath(filename)\n    result = get_json(filename)\n    result = result[0]\n    return result", "code_tokens": "def information ( filename ) : check_if_this_file_exist ( filename ) filename = os . path . abspath ( filename ) result = get_json ( filename ) result = result [ 0 ] return result", "docstring_tokens": "Returns the file exif", "label": 1}, {"idx": "cosqa-train-5881", "doc": "off sparse array in python", "code": "def _first_and_last_element(arr):\n    \"\"\"Returns first and last element of numpy array or sparse matrix.\"\"\"\n    if isinstance(arr, np.ndarray) or hasattr(arr, 'data'):\n        # numpy array or sparse matrix with .data attribute\n        data = arr.data if sparse.issparse(arr) else arr\n        return data.flat[0], data.flat[-1]\n    else:\n        # Sparse matrices without .data attribute. Only dok_matrix at\n        # the time of writing, in this case indexing is fast\n        return arr[0, 0], arr[-1, -1]", "code_tokens": "def _first_and_last_element ( arr ) : if isinstance ( arr , np . ndarray ) or hasattr ( arr , 'data' ) : # numpy array or sparse matrix with .data attribute data = arr . data if sparse . issparse ( arr ) else arr return data . flat [ 0 ] , data . flat [ - 1 ] else : # Sparse matrices without .data attribute. Only dok_matrix at # the time of writing, in this case indexing is fast return arr [ 0 , 0 ] , arr [ - 1 , - 1 ]", "docstring_tokens": "Returns first and last element of numpy array or sparse matrix .", "label": 0}, {"idx": "cosqa-train-5882", "doc": "rabbitmq python not ack", "code": "def run(self):\n        \"\"\"\n        consume message from channel on the consuming thread.\n        \"\"\"\n        LOGGER.debug(\"rabbitmq.Service.run\")\n        try:\n            self.channel.start_consuming()\n        except Exception as e:\n            LOGGER.warn(\"rabbitmq.Service.run - Exception raised while consuming\")", "code_tokens": "def run ( self ) : LOGGER . debug ( \"rabbitmq.Service.run\" ) try : self . channel . start_consuming ( ) except Exception as e : LOGGER . warn ( \"rabbitmq.Service.run - Exception raised while consuming\" )", "docstring_tokens": "consume message from channel on the consuming thread .", "label": 0}, {"idx": "cosqa-train-5883", "doc": "on duplicate key python", "code": "def filter_duplicate_key(line, message, line_number, marked_line_numbers,\n                         source, previous_line=''):\n    \"\"\"Return '' if first occurrence of the key otherwise return `line`.\"\"\"\n    if marked_line_numbers and line_number == sorted(marked_line_numbers)[0]:\n        return ''\n\n    return line", "code_tokens": "def filter_duplicate_key ( line , message , line_number , marked_line_numbers , source , previous_line = '' ) : if marked_line_numbers and line_number == sorted ( marked_line_numbers ) [ 0 ] : return '' return line", "docstring_tokens": "Return if first occurrence of the key otherwise return line .", "label": 0}, {"idx": "cosqa-train-5884", "doc": "random state in python definition", "code": "def reseed_random(seed):\n    \"\"\"Reseed factory.fuzzy's random generator.\"\"\"\n    r = random.Random(seed)\n    random_internal_state = r.getstate()\n    set_random_state(random_internal_state)", "code_tokens": "def reseed_random ( seed ) : r = random . Random ( seed ) random_internal_state = r . getstate ( ) set_random_state ( random_internal_state )", "docstring_tokens": "Reseed factory . fuzzy s random generator .", "label": 0}, {"idx": "cosqa-train-5885", "doc": "one to many relationship python", "code": "def handle_m2m(self, sender, instance, **kwargs):\n    \"\"\" Handle many to many relationships \"\"\"\n    self.handle_save(instance.__class__, instance)", "code_tokens": "def handle_m2m ( self , sender , instance , * * kwargs ) : self . handle_save ( instance . __class__ , instance )", "docstring_tokens": "Handle many to many relationships", "label": 0}, {"idx": "cosqa-train-5886", "doc": "read csv file as dictionary python stack overflow", "code": "def csv_to_dicts(file, header=None):\n    \"\"\"Reads a csv and returns a List of Dicts with keys given by header row.\"\"\"\n    with open(file) as csvfile:\n        return [row for row in csv.DictReader(csvfile, fieldnames=header)]", "code_tokens": "def csv_to_dicts ( file , header = None ) : with open ( file ) as csvfile : return [ row for row in csv . DictReader ( csvfile , fieldnames = header ) ]", "docstring_tokens": "Reads a csv and returns a List of Dicts with keys given by header row .", "label": 0}, {"idx": "cosqa-train-5887", "doc": "open yaml file python", "code": "def getYamlDocument(filePath):\n    \"\"\"\n    Return a yaml file's contents as a dictionary\n    \"\"\"\n    with open(filePath) as stream:\n        doc = yaml.load(stream)\n        return doc", "code_tokens": "def getYamlDocument ( filePath ) : with open ( filePath ) as stream : doc = yaml . load ( stream ) return doc", "docstring_tokens": "Return a yaml file s contents as a dictionary", "label": 0}, {"idx": "cosqa-train-5888", "doc": "read entire pdf into a list python", "code": "def resources(self):\n        \"\"\"Retrieve contents of each page of PDF\"\"\"\n        return [self.pdf.getPage(i) for i in range(self.pdf.getNumPages())]", "code_tokens": "def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "docstring_tokens": "Retrieve contents of each page of PDF", "label": 1}, {"idx": "cosqa-train-5889", "doc": "opening images from a file in python", "code": "def load_image(fname):\n    \"\"\" read an image from file - PIL doesnt close nicely \"\"\"\n    with open(fname, \"rb\") as f:\n        i = Image.open(fname)\n        #i.load()\n        return i", "code_tokens": "def load_image ( fname ) : with open ( fname , \"rb\" ) as f : i = Image . open ( fname ) #i.load() return i", "docstring_tokens": "read an image from file - PIL doesnt close nicely", "label": 1}, {"idx": "cosqa-train-5890", "doc": "read group from hdf4 file python", "code": "def _read_group_h5(filename, groupname):\n    \"\"\"Return group content.\n\n    Args:\n        filename (:class:`pathlib.Path`): path of hdf5 file.\n        groupname (str): name of group to read.\n    Returns:\n        :class:`numpy.array`: content of group.\n    \"\"\"\n    with h5py.File(filename, 'r') as h5f:\n        data = h5f[groupname][()]\n    return data", "code_tokens": "def _read_group_h5 ( filename , groupname ) : with h5py . File ( filename , 'r' ) as h5f : data = h5f [ groupname ] [ ( ) ] return data", "docstring_tokens": "Return group content .", "label": 0}, {"idx": "cosqa-train-5891", "doc": "read lines from stdin python", "code": "def standard_input():\n    \"\"\"Generator that yields lines from standard input.\"\"\"\n    with click.get_text_stream(\"stdin\") as stdin:\n        while stdin.readable():\n            line = stdin.readline()\n            if line:\n                yield line.strip().encode(\"utf-8\")", "code_tokens": "def standard_input ( ) : with click . get_text_stream ( \"stdin\" ) as stdin : while stdin . readable ( ) : line = stdin . readline ( ) if line : yield line . strip ( ) . encode ( \"utf-8\" )", "docstring_tokens": "Generator that yields lines from standard input .", "label": 0}, {"idx": "cosqa-train-5892", "doc": "overlay density plot on histogram in python", "code": "def _histplot_op(ax, data, **kwargs):\n    \"\"\"Add a histogram for the data to the axes.\"\"\"\n    bins = get_bins(data)\n    ax.hist(data, bins=bins, align=\"left\", density=True, **kwargs)\n    return ax", "code_tokens": "def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "docstring_tokens": "Add a histogram for the data to the axes .", "label": 0}, {"idx": "cosqa-train-5893", "doc": "read python not showing file content", "code": "def read(fname):\n    \"\"\"Quick way to read a file content.\"\"\"\n    content = None\n    with open(os.path.join(here, fname)) as f:\n        content = f.read()\n    return content", "code_tokens": "def read ( fname ) : content = None with open ( os . path . join ( here , fname ) ) as f : content = f . read ( ) return content", "docstring_tokens": "Quick way to read a file content .", "label": 0}, {"idx": "cosqa-train-5894", "doc": "ow to hash a file python", "code": "def generate_hash(filepath):\n    \"\"\"Public function that reads a local file and generates a SHA256 hash digest for it\"\"\"\n    fr = FileReader(filepath)\n    data = fr.read_bin()\n    return _calculate_sha256(data)", "code_tokens": "def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )", "docstring_tokens": "Public function that reads a local file and generates a SHA256 hash digest for it", "label": 0}, {"idx": "cosqa-train-5895", "doc": "read rest api response json in python", "code": "def versions_request(self):\n        \"\"\"List Available REST API Versions\"\"\"\n        ret = self.handle_api_exceptions('GET', '', api_ver='')\n        return [str_dict(x) for x in ret.json()]", "code_tokens": "def versions_request ( self ) : ret = self . handle_api_exceptions ( 'GET' , '' , api_ver = '' ) return [ str_dict ( x ) for x in ret . json ( ) ]", "docstring_tokens": "List Available REST API Versions", "label": 0}, {"idx": "cosqa-train-5896", "doc": "parse a string into a dictionary in python", "code": "def string_to_identity(identity_str):\n    \"\"\"Parse string into Identity dictionary.\"\"\"\n    m = _identity_regexp.match(identity_str)\n    result = m.groupdict()\n    log.debug('parsed identity: %s', result)\n    return {k: v for k, v in result.items() if v}", "code_tokens": "def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }", "docstring_tokens": "Parse string into Identity dictionary .", "label": 0}, {"idx": "cosqa-train-5897", "doc": "read text from a url python", "code": "def url_read_text(url, verbose=True):\n    r\"\"\"\n    Directly reads text data from url\n    \"\"\"\n    data = url_read(url, verbose)\n    text = data.decode('utf8')\n    return text", "code_tokens": "def url_read_text ( url , verbose = True ) : data = url_read ( url , verbose ) text = data . decode ( 'utf8' ) return text", "docstring_tokens": "r Directly reads text data from url", "label": 0}, {"idx": "cosqa-train-5898", "doc": "parse an http response python", "code": "def _parse_response(self, response):\n        \"\"\"\n        Parse http raw respone into python\n        dictionary object.\n        \n        :param str response: http response\n        :returns: response dict\n        :rtype: dict\n        \"\"\"\n\n        response_dict = {}\n        for line in response.splitlines():\n            key, value = response.split(\"=\", 1)\n            response_dict[key] = value\n        return response_dict", "code_tokens": "def _parse_response ( self , response ) : response_dict = { } for line in response . splitlines ( ) : key , value = response . split ( \"=\" , 1 ) response_dict [ key ] = value return response_dict", "docstring_tokens": "Parse http raw respone into python dictionary object . : param str response : http response : returns : response dict : rtype : dict", "label": 0}, {"idx": "cosqa-train-5899", "doc": "reading json from file in order python", "code": "def _read_json_file(self, json_file):\n        \"\"\" Helper function to read JSON file as OrderedDict \"\"\"\n\n        self.log.debug(\"Reading '%s' JSON file...\" % json_file)\n\n        with open(json_file, 'r') as f:\n            return json.load(f, object_pairs_hook=OrderedDict)", "code_tokens": "def _read_json_file ( self , json_file ) : self . log . debug ( \"Reading '%s' JSON file...\" % json_file ) with open ( json_file , 'r' ) as f : return json . load ( f , object_pairs_hook = OrderedDict )", "docstring_tokens": "Helper function to read JSON file as OrderedDict", "label": 0}, {"idx": "cosqa-train-5900", "doc": "parse json from string python", "code": "def serialize_json_string(self, value):\n        \"\"\"\n        Tries to load an encoded json string back into an object\n        :param json_string:\n        :return:\n        \"\"\"\n\n        # Check if the value might be a json string\n        if not isinstance(value, six.string_types):\n            return value\n\n        # Make sure it starts with a brace\n        if not value.startswith('{') or value.startswith('['):\n            return value\n\n        # Try to load the string\n        try:\n            return json.loads(value)\n        except:\n            return value", "code_tokens": "def serialize_json_string ( self , value ) : # Check if the value might be a json string if not isinstance ( value , six . string_types ) : return value # Make sure it starts with a brace if not value . startswith ( '{' ) or value . startswith ( '[' ) : return value # Try to load the string try : return json . loads ( value ) except : return value", "docstring_tokens": "Tries to load an encoded json string back into an object : param json_string : : return :", "label": 1}, {"idx": "cosqa-train-5901", "doc": "realtime copy of python print window", "code": "def print(cls, *args, **kwargs):\n        \"\"\"Print synchronized.\"\"\"\n        # pylint: disable=protected-access\n        with _shared._PRINT_LOCK:\n            print(*args, **kwargs)\n            _sys.stdout.flush()", "code_tokens": "def print ( cls , * args , * * kwargs ) : # pylint: disable=protected-access with _shared . _PRINT_LOCK : print ( * args , * * kwargs ) _sys . stdout . flush ( )", "docstring_tokens": "Print synchronized .", "label": 1}, {"idx": "cosqa-train-5902", "doc": "parse string to bool python", "code": "def FromString(self, string):\n    \"\"\"Parse a bool from a string.\"\"\"\n    if string.lower() in (\"false\", \"no\", \"n\"):\n      return False\n\n    if string.lower() in (\"true\", \"yes\", \"y\"):\n      return True\n\n    raise TypeValueError(\"%s is not recognized as a boolean value.\" % string)", "code_tokens": "def FromString ( self , string ) : if string . lower ( ) in ( \"false\" , \"no\" , \"n\" ) : return False if string . lower ( ) in ( \"true\" , \"yes\" , \"y\" ) : return True raise TypeValueError ( \"%s is not recognized as a boolean value.\" % string )", "docstring_tokens": "Parse a bool from a string .", "label": 1}, {"idx": "cosqa-train-5903", "doc": "reaplace strings with dictionary values python", "code": "def replace_all(text, dic):\n    \"\"\"Takes a string and dictionary. replaces all occurrences of i with j\"\"\"\n\n    for i, j in dic.iteritems():\n        text = text.replace(i, j)\n    return text", "code_tokens": "def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text", "docstring_tokens": "Takes a string and dictionary . replaces all occurrences of i with j", "label": 0}, {"idx": "cosqa-train-5904", "doc": "pass function into jinja2 python", "code": "def rstjinja(app, docname, source):\n    \"\"\"\n    Render our pages as a jinja template for fancy templating goodness.\n    \"\"\"\n    # Make sure we're outputting HTML\n    if app.builder.format != 'html':\n        return\n    src = source[0]\n    rendered = app.builder.templates.render_string(\n        src, app.config.html_context\n    )\n    source[0] = rendered", "code_tokens": "def rstjinja ( app , docname , source ) : # Make sure we're outputting HTML if app . builder . format != 'html' : return src = source [ 0 ] rendered = app . builder . templates . render_string ( src , app . config . html_context ) source [ 0 ] = rendered", "docstring_tokens": "Render our pages as a jinja template for fancy templating goodness .", "label": 0}, {"idx": "cosqa-train-5905", "doc": "recursively read all files from folder in python", "code": "def recursively_get_files_from_directory(directory):\n    \"\"\"\n    Return all filenames under recursively found in a directory\n    \"\"\"\n    return [\n        os.path.join(root, filename)\n        for root, directories, filenames in os.walk(directory)\n        for filename in filenames\n    ]", "code_tokens": "def recursively_get_files_from_directory ( directory ) : return [ os . path . join ( root , filename ) for root , directories , filenames in os . walk ( directory ) for filename in filenames ]", "docstring_tokens": "Return all filenames under recursively found in a directory", "label": 0}, {"idx": "cosqa-train-5906", "doc": "passing **params to a function python", "code": "def trigger(self, target: str, trigger: str, parameters: Dict[str, Any]={}):\n\t\t\"\"\"Calls the specified Trigger of another Area with the optionally given parameters.\n\n\t\tArgs:\n\t\t\ttarget: The name of the target Area.\n\t\t\ttrigger: The name of the Trigger.\n\t\t\tparameters: The parameters of the function call.\n\t\t\"\"\"\n\t\tpass", "code_tokens": "def trigger ( self , target : str , trigger : str , parameters : Dict [ str , Any ] = { } ) : pass", "docstring_tokens": "Calls the specified Trigger of another Area with the optionally given parameters .", "label": 0}, {"idx": "cosqa-train-5907", "doc": "recursivly list files in directory python", "code": "def recursively_get_files_from_directory(directory):\n    \"\"\"\n    Return all filenames under recursively found in a directory\n    \"\"\"\n    return [\n        os.path.join(root, filename)\n        for root, directories, filenames in os.walk(directory)\n        for filename in filenames\n    ]", "code_tokens": "def recursively_get_files_from_directory ( directory ) : return [ os . path . join ( root , filename ) for root , directories , filenames in os . walk ( directory ) for filename in filenames ]", "docstring_tokens": "Return all filenames under recursively found in a directory", "label": 0}, {"idx": "cosqa-train-5908", "doc": "redis get all keys python", "code": "def values(self):\n        \"\"\" :see::meth:RedisMap.keys \"\"\"\n        for val in self._client.hvals(self.key_prefix):\n            yield self._loads(val)", "code_tokens": "def values ( self ) : for val in self . _client . hvals ( self . key_prefix ) : yield self . _loads ( val )", "docstring_tokens": ": see :: meth : RedisMap . keys", "label": 0}, {"idx": "cosqa-train-5909", "doc": "passing functions as argumetns python", "code": "def def_linear(fun):\n    \"\"\"Flags that a function is linear wrt all args\"\"\"\n    defjvp_argnum(fun, lambda argnum, g, ans, args, kwargs:\n                  fun(*subval(args, argnum, g), **kwargs))", "code_tokens": "def def_linear ( fun ) : defjvp_argnum ( fun , lambda argnum , g , ans , args , kwargs : fun ( * subval ( args , argnum , g ) , * * kwargs ) )", "docstring_tokens": "Flags that a function is linear wrt all args", "label": 1}, {"idx": "cosqa-train-5910", "doc": "regex in python for domain url", "code": "def parse_domain(url):\n    \"\"\" parse the domain from the url \"\"\"\n    domain_match = lib.DOMAIN_REGEX.match(url)\n    if domain_match:\n        return domain_match.group()", "code_tokens": "def parse_domain ( url ) : domain_match = lib . DOMAIN_REGEX . match ( url ) if domain_match : return domain_match . group ( )", "docstring_tokens": "parse the domain from the url", "label": 0}, {"idx": "cosqa-train-5911", "doc": "passing python variables to html", "code": "def dict_to_html_attrs(dict_):\n    \"\"\"\n    Banana banana\n    \"\"\"\n    res = ' '.join('%s=\"%s\"' % (k, v) for k, v in dict_.items())\n    return res", "code_tokens": "def dict_to_html_attrs ( dict_ ) : res = ' ' . join ( '%s=\"%s\"' % ( k , v ) for k , v in dict_ . items ( ) ) return res", "docstring_tokens": "Banana banana", "label": 0}, {"idx": "cosqa-train-5912", "doc": "regex to get all numbers from a string python", "code": "def get_numbers(s):\n    \"\"\"Extracts all integers from a string an return them in a list\"\"\"\n\n    result = map(int, re.findall(r'[0-9]+', unicode(s)))\n    return result + [1] * (2 - len(result))", "code_tokens": "def get_numbers ( s ) : result = map ( int , re . findall ( r'[0-9]+' , unicode ( s ) ) ) return result + [ 1 ] * ( 2 - len ( result ) )", "docstring_tokens": "Extracts all integers from a string an return them in a list", "label": 0}, {"idx": "cosqa-train-5913", "doc": "pearson correlation nan python", "code": "def cor(y_true, y_pred):\n    \"\"\"Compute Pearson correlation coefficient.\n    \"\"\"\n    y_true, y_pred = _mask_nan(y_true, y_pred)\n    return np.corrcoef(y_true, y_pred)[0, 1]", "code_tokens": "def cor ( y_true , y_pred ) : y_true , y_pred = _mask_nan ( y_true , y_pred ) return np . corrcoef ( y_true , y_pred ) [ 0 , 1 ]", "docstring_tokens": "Compute Pearson correlation coefficient .", "label": 0}, {"idx": "cosqa-train-5914", "doc": "regex upper to lower python", "code": "def camel_to_(s):\n    \"\"\"\n    Convert CamelCase to camel_case\n    \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', s)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def camel_to_ ( s ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , s ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert CamelCase to camel_case", "label": 0}, {"idx": "cosqa-train-5915", "doc": "performing a ttest with python", "code": "def test(ctx, all=False, verbose=False):\n    \"\"\"Run the tests.\"\"\"\n    cmd = 'tox' if all else 'py.test'\n    if verbose:\n        cmd += ' -v'\n    return ctx.run(cmd, pty=True).return_code", "code_tokens": "def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code", "docstring_tokens": "Run the tests .", "label": 0}, {"idx": "cosqa-train-5916", "doc": "regular expression for valid email address in python", "code": "def is_valid_email(email):\n    \"\"\"\n    Check if email is valid\n    \"\"\"\n    pattern = re.compile(r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+')\n    return bool(pattern.match(email))", "code_tokens": "def is_valid_email ( email ) : pattern = re . compile ( r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+' ) return bool ( pattern . match ( email ) )", "docstring_tokens": "Check if email is valid", "label": 1}, {"idx": "cosqa-train-5917", "doc": "piecewise linear interpolation in python", "code": "def _linear_interpolation(x, X, Y):\n    \"\"\"Given two data points [X,Y], linearly interpolate those at x.\n    \"\"\"\n    return (Y[1] * (x - X[0]) + Y[0] * (X[1] - x)) / (X[1] - X[0])", "code_tokens": "def _linear_interpolation ( x , X , Y ) : return ( Y [ 1 ] * ( x - X [ 0 ] ) + Y [ 0 ] * ( X [ 1 ] - x ) ) / ( X [ 1 ] - X [ 0 ] )", "docstring_tokens": "Given two data points [ X Y ] linearly interpolate those at x .", "label": 1}, {"idx": "cosqa-train-5918", "doc": "regular expression remove python comments", "code": "def lines(input):\n    \"\"\"Remove comments and empty lines\"\"\"\n    for raw_line in input:\n        line = raw_line.strip()\n        if line and not line.startswith('#'):\n            yield strip_comments(line)", "code_tokens": "def lines ( input ) : for raw_line in input : line = raw_line . strip ( ) if line and not line . startswith ( '#' ) : yield strip_comments ( line )", "docstring_tokens": "Remove comments and empty lines", "label": 0}, {"idx": "cosqa-train-5919", "doc": "plot a confusion matrix in python", "code": "def confusion_matrix(self):\n        \"\"\"Confusion matrix plot\n        \"\"\"\n        return plot.confusion_matrix(self.y_true, self.y_pred,\n                                     self.target_names, ax=_gen_ax())", "code_tokens": "def confusion_matrix ( self ) : return plot . confusion_matrix ( self . y_true , self . y_pred , self . target_names , ax = _gen_ax ( ) )", "docstring_tokens": "Confusion matrix plot", "label": 1}, {"idx": "cosqa-train-5920", "doc": "remkove duplicats from python list", "code": "def remove_list_duplicates(lista, unique=False):\n    \"\"\"\n    Remove duplicated elements in a list.\n    Args:\n        lista: List with elements to clean duplicates.\n    \"\"\"\n    result = []\n    allready = []\n\n    for elem in lista:\n        if elem not in result:\n            result.append(elem)\n        else:\n            allready.append(elem)\n\n    if unique:\n        for elem in allready:\n            result = list(filter((elem).__ne__, result))\n\n    return result", "code_tokens": "def remove_list_duplicates ( lista , unique = False ) : result = [ ] allready = [ ] for elem in lista : if elem not in result : result . append ( elem ) else : allready . append ( elem ) if unique : for elem in allready : result = list ( filter ( ( elem ) . __ne__ , result ) ) return result", "docstring_tokens": "Remove duplicated elements in a list . Args : lista : List with elements to clean duplicates .", "label": 0}, {"idx": "cosqa-train-5921", "doc": "plot confusion matrix as heatmap python", "code": "def confusion_matrix(self):\n        \"\"\"Confusion matrix plot\n        \"\"\"\n        return plot.confusion_matrix(self.y_true, self.y_pred,\n                                     self.target_names, ax=_gen_ax())", "code_tokens": "def confusion_matrix ( self ) : return plot . confusion_matrix ( self . y_true , self . y_pred , self . target_names , ax = _gen_ax ( ) )", "docstring_tokens": "Confusion matrix plot", "label": 0}, {"idx": "cosqa-train-5922", "doc": "remove [ from a variable in python", "code": "def de_blank(val):\n    \"\"\"Remove blank elements in `val` and return `ret`\"\"\"\n    ret = list(val)\n    if type(val) == list:\n        for idx, item in enumerate(val):\n            if item.strip() == '':\n                ret.remove(item)\n            else:\n                ret[idx] = item.strip()\n    return ret", "code_tokens": "def de_blank ( val ) : ret = list ( val ) if type ( val ) == list : for idx , item in enumerate ( val ) : if item . strip ( ) == '' : ret . remove ( item ) else : ret [ idx ] = item . strip ( ) return ret", "docstring_tokens": "Remove blank elements in val and return ret", "label": 0}, {"idx": "cosqa-train-5923", "doc": "plot sinusoidal wave python", "code": "def sine_wave(i, frequency=FREQUENCY, framerate=FRAMERATE, amplitude=AMPLITUDE):\n    \"\"\"\n    Returns value of a sine wave at a given frequency and framerate\n    for a given sample i\n    \"\"\"\n    omega = 2.0 * pi * float(frequency)\n    sine = sin(omega * (float(i) / float(framerate)))\n    return float(amplitude) * sine", "code_tokens": "def sine_wave ( i , frequency = FREQUENCY , framerate = FRAMERATE , amplitude = AMPLITUDE ) : omega = 2.0 * pi * float ( frequency ) sine = sin ( omega * ( float ( i ) / float ( framerate ) ) ) return float ( amplitude ) * sine", "docstring_tokens": "Returns value of a sine wave at a given frequency and framerate for a given sample i", "label": 0}, {"idx": "cosqa-train-5924", "doc": "remove a comma from a string in python", "code": "def slugify(string):\n    \"\"\"\n    Removes non-alpha characters, and converts spaces to hyphens. Useful for making file names.\n\n\n    Source: http://stackoverflow.com/questions/5574042/string-slugification-in-python\n    \"\"\"\n    string = re.sub('[^\\w .-]', '', string)\n    string = string.replace(\" \", \"-\")\n    return string", "code_tokens": "def slugify ( string ) : string = re . sub ( '[^\\w .-]' , '' , string ) string = string . replace ( \" \" , \"-\" ) return string", "docstring_tokens": "Removes non - alpha characters and converts spaces to hyphens . Useful for making file names . Source : http : // stackoverflow . com / questions / 5574042 / string - slugification - in - python", "label": 0}, {"idx": "cosqa-train-5925", "doc": "plotting a noise in python", "code": "def normal_noise(points):\n    \"\"\"Init a noise variable.\"\"\"\n    return np.random.rand(1) * np.random.randn(points, 1) \\\n        + random.sample([2, -2], 1)", "code_tokens": "def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "docstring_tokens": "Init a noise variable .", "label": 0}, {"idx": "cosqa-train-5926", "doc": "remove a duplicate in a list python", "code": "def dedup_list(l):\n    \"\"\"Given a list (l) will removing duplicates from the list,\n       preserving the original order of the list. Assumes that\n       the list entrie are hashable.\"\"\"\n    dedup = set()\n    return [ x for x in l if not (x in dedup or dedup.add(x))]", "code_tokens": "def dedup_list ( l ) : dedup = set ( ) return [ x for x in l if not ( x in dedup or dedup . add ( x ) ) ]", "docstring_tokens": "Given a list ( l ) will removing duplicates from the list preserving the original order of the list . Assumes that the list entrie are hashable .", "label": 0}, {"idx": "cosqa-train-5927", "doc": "plotting with colormap python", "code": "def add_matplotlib_cmap(cm, name=None):\n    \"\"\"Add a matplotlib colormap.\"\"\"\n    global cmaps\n    cmap = matplotlib_to_ginga_cmap(cm, name=name)\n    cmaps[cmap.name] = cmap", "code_tokens": "def add_matplotlib_cmap ( cm , name = None ) : global cmaps cmap = matplotlib_to_ginga_cmap ( cm , name = name ) cmaps [ cmap . name ] = cmap", "docstring_tokens": "Add a matplotlib colormap .", "label": 0}, {"idx": "cosqa-train-5928", "doc": "remove a list of indices python", "code": "def rm_empty_indices(*args):\n    \"\"\"\n    Remove unwanted list indices. First argument is the list\n    of indices to remove. Other elements are the lists\n    to trim.\n    \"\"\"\n    rm_inds = args[0]\n\n    if not rm_inds:\n        return args[1:]\n\n    keep_inds = [i for i in range(len(args[1])) if i not in rm_inds]\n\n    return [[a[i] for i in keep_inds] for a in args[1:]]", "code_tokens": "def rm_empty_indices ( * args ) : rm_inds = args [ 0 ] if not rm_inds : return args [ 1 : ] keep_inds = [ i for i in range ( len ( args [ 1 ] ) ) if i not in rm_inds ] return [ [ a [ i ] for i in keep_inds ] for a in args [ 1 : ] ]", "docstring_tokens": "Remove unwanted list indices . First argument is the list of indices to remove . Other elements are the lists to trim .", "label": 0}, {"idx": "cosqa-train-5929", "doc": "post method, what data is encoded in the request python", "code": "def _request(self, data):\n        \"\"\"Moved out to make testing easier.\"\"\"\n        return requests.post(self.endpoint, data=data.encode(\"ascii\")).content", "code_tokens": "def _request ( self , data ) : return requests . post ( self . endpoint , data = data . encode ( \"ascii\" ) ) . content", "docstring_tokens": "Moved out to make testing easier .", "label": 1}, {"idx": "cosqa-train-5930", "doc": "remove all letters and numbers in python", "code": "def remove_bad(string):\n    \"\"\"\n    remove problem characters from string\n    \"\"\"\n    remove = [':', ',', '(', ')', ' ', '|', ';', '\\'']\n    for c in remove:\n        string = string.replace(c, '_')\n    return string", "code_tokens": "def remove_bad ( string ) : remove = [ ':' , ',' , '(' , ')' , ' ' , '|' , ';' , '\\'' ] for c in remove : string = string . replace ( c , '_' ) return string", "docstring_tokens": "remove problem characters from string", "label": 0}, {"idx": "cosqa-train-5931", "doc": "predefined function for checking equality in python", "code": "def hard_equals(a, b):\n    \"\"\"Implements the '===' operator.\"\"\"\n    if type(a) != type(b):\n        return False\n    return a == b", "code_tokens": "def hard_equals ( a , b ) : if type ( a ) != type ( b ) : return False return a == b", "docstring_tokens": "Implements the === operator .", "label": 0}, {"idx": "cosqa-train-5932", "doc": "remove all non matches python set", "code": "def distinct(l):\n    \"\"\"\n    Return a list where the duplicates have been removed.\n\n    Args:\n        l (list): the list to filter.\n\n    Returns:\n        list: the same list without duplicates.\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return (_ for _ in l if not (_ in seen or seen_add(_)))", "code_tokens": "def distinct ( l ) : seen = set ( ) seen_add = seen . add return ( _ for _ in l if not ( _ in seen or seen_add ( _ ) ) )", "docstring_tokens": "Return a list where the duplicates have been removed .", "label": 0}, {"idx": "cosqa-train-5933", "doc": "prettty print json dict python", "code": "def prettyprint(d):\n        \"\"\"Print dicttree in Json-like format. keys are sorted\n        \"\"\"\n        print(json.dumps(d, sort_keys=True, \n                         indent=4, separators=(\",\" , \": \")))", "code_tokens": "def prettyprint ( d ) : print ( json . dumps ( d , sort_keys = True , indent = 4 , separators = ( \",\" , \": \" ) ) )", "docstring_tokens": "Print dicttree in Json - like format . keys are sorted", "label": 1}, {"idx": "cosqa-train-5934", "doc": "remove all space after and before a character python", "code": "def normalize_value(text):\n    \"\"\"\n    This removes newlines and multiple spaces from a string.\n    \"\"\"\n    result = text.replace('\\n', ' ')\n    result = re.subn('[ ]{2,}', ' ', result)[0]\n    return result", "code_tokens": "def normalize_value ( text ) : result = text . replace ( '\\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result", "docstring_tokens": "This removes newlines and multiple spaces from a string .", "label": 1}, {"idx": "cosqa-train-5935", "doc": "pretty print matrix python", "code": "def print_matrix(X, decimals=1):\n    \"\"\"Pretty printing for numpy matrix X\"\"\"\n    for row in np.round(X, decimals=decimals):\n        print(row)", "code_tokens": "def print_matrix ( X , decimals = 1 ) : for row in np . round ( X , decimals = decimals ) : print ( row )", "docstring_tokens": "Pretty printing for numpy matrix X", "label": 1}, {"idx": "cosqa-train-5936", "doc": "remove all spaces in string python", "code": "def strip_spaces(s):\n    \"\"\" Strip excess spaces from a string \"\"\"\n    return u\" \".join([c for c in s.split(u' ') if c])", "code_tokens": "def strip_spaces ( s ) : return u\" \" . join ( [ c for c in s . split ( u' ' ) if c ] )", "docstring_tokens": "Strip excess spaces from a string", "label": 0}, {"idx": "cosqa-train-5937", "doc": "pretty print python dictionary", "code": "def pprint_for_ordereddict():\n    \"\"\"\n    Context manager that causes pprint() to print OrderedDict objects as nicely\n    as standard Python dictionary objects.\n    \"\"\"\n    od_saved = OrderedDict.__repr__\n    try:\n        OrderedDict.__repr__ = dict.__repr__\n        yield\n    finally:\n        OrderedDict.__repr__ = od_saved", "code_tokens": "def pprint_for_ordereddict ( ) : od_saved = OrderedDict . __repr__ try : OrderedDict . __repr__ = dict . __repr__ yield finally : OrderedDict . __repr__ = od_saved", "docstring_tokens": "Context manager that causes pprint () to print OrderedDict objects as nicely as standard Python dictionary objects .", "label": 1}, {"idx": "cosqa-train-5938", "doc": "remove alpha characters in str python", "code": "def strip_accents(string):\n    \"\"\"\n    Strip all the accents from the string\n    \"\"\"\n    return u''.join(\n        (character for character in unicodedata.normalize('NFD', string)\n         if unicodedata.category(character) != 'Mn'))", "code_tokens": "def strip_accents ( string ) : return u'' . join ( ( character for character in unicodedata . normalize ( 'NFD' , string ) if unicodedata . category ( character ) != 'Mn' ) )", "docstring_tokens": "Strip all the accents from the string", "label": 0}, {"idx": "cosqa-train-5939", "doc": "pretty print xml element python", "code": "def pp_xml(body):\n    \"\"\"Pretty print format some XML so it's readable.\"\"\"\n    pretty = xml.dom.minidom.parseString(body)\n    return pretty.toprettyxml(indent=\"  \")", "code_tokens": "def pp_xml ( body ) : pretty = xml . dom . minidom . parseString ( body ) return pretty . toprettyxml ( indent = \"  \" )", "docstring_tokens": "Pretty print format some XML so it s readable .", "label": 0}, {"idx": "cosqa-train-5940", "doc": "remove duplicates from an array python", "code": "def delete_duplicates(seq):\n    \"\"\"\n    Remove duplicates from an iterable, preserving the order.\n\n    Args:\n        seq: Iterable of various type.\n\n    Returns:\n        list: List of unique objects.\n\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "Remove duplicates from an iterable preserving the order .", "label": 0}, {"idx": "cosqa-train-5941", "doc": "prevent a list from being sorted python", "code": "def insort_no_dup(lst, item):\n    \"\"\"\n    If item is not in lst, add item to list at its sorted position\n    \"\"\"\n    import bisect\n    ix = bisect.bisect_left(lst, item)\n    if lst[ix] != item: \n        lst[ix:ix] = [item]", "code_tokens": "def insort_no_dup ( lst , item ) : import bisect ix = bisect . bisect_left ( lst , item ) if lst [ ix ] != item : lst [ ix : ix ] = [ item ]", "docstring_tokens": "If item is not in lst add item to list at its sorted position", "label": 0}, {"idx": "cosqa-train-5942", "doc": "remove duplicates list python without changing order", "code": "def remove_duplicates(lst):\n    \"\"\"\n    Emulate what a Python ``set()`` does, but keeping the element's order.\n    \"\"\"\n    dset = set()\n    return [l for l in lst if l not in dset and not dset.add(l)]", "code_tokens": "def remove_duplicates ( lst ) : dset = set ( ) return [ l for l in lst if l not in dset and not dset . add ( l ) ]", "docstring_tokens": "Emulate what a Python set () does but keeping the element s order .", "label": 1}, {"idx": "cosqa-train-5943", "doc": "prevent color of white or black during python colorsys", "code": "def auto():\n\t\"\"\"set colouring on if STDOUT is a terminal device, off otherwise\"\"\"\n\ttry:\n\t\tStyle.enabled = False\n\t\tStyle.enabled = sys.stdout.isatty()\n\texcept (AttributeError, TypeError):\n\t\tpass", "code_tokens": "def auto ( ) : try : Style . enabled = False Style . enabled = sys . stdout . isatty ( ) except ( AttributeError , TypeError ) : pass", "docstring_tokens": "set colouring on if STDOUT is a terminal device off otherwise", "label": 0}, {"idx": "cosqa-train-5944", "doc": "remove extraneous whitespace in python", "code": "def clean(s):\n  \"\"\"Removes trailing whitespace on each line.\"\"\"\n  lines = [l.rstrip() for l in s.split('\\n')]\n  return '\\n'.join(lines)", "code_tokens": "def clean ( s ) : lines = [ l . rstrip ( ) for l in s . split ( '\\n' ) ] return '\\n' . join ( lines )", "docstring_tokens": "Removes trailing whitespace on each line .", "label": 0}, {"idx": "cosqa-train-5945", "doc": "prevent text wrapping in python", "code": "def toggle_word_wrap(self):\n        \"\"\"\n        Toggles document word wrap.\n\n        :return: Method success.\n        :rtype: bool\n        \"\"\"\n\n        self.setWordWrapMode(not self.wordWrapMode() and QTextOption.WordWrap or QTextOption.NoWrap)\n        return True", "code_tokens": "def toggle_word_wrap ( self ) : self . setWordWrapMode ( not self . wordWrapMode ( ) and QTextOption . WordWrap or QTextOption . NoWrap ) return True", "docstring_tokens": "Toggles document word wrap .", "label": 0}, {"idx": "cosqa-train-5946", "doc": "remove head of a list python", "code": "def strip_head(sequence, values):\n    \"\"\"Strips elements of `values` from the beginning of `sequence`.\"\"\"\n    values = set(values)\n    return list(itertools.dropwhile(lambda x: x in values, sequence))", "code_tokens": "def strip_head ( sequence , values ) : values = set ( values ) return list ( itertools . dropwhile ( lambda x : x in values , sequence ) )", "docstring_tokens": "Strips elements of values from the beginning of sequence .", "label": 0}, {"idx": "cosqa-train-5947", "doc": "print all nodes of binary tree in python", "code": "def print_bintree(tree, indent='  '):\n    \"\"\"print a binary tree\"\"\"\n    for n in sorted(tree.keys()):\n        print \"%s%s\" % (indent * depth(n,tree), n)", "code_tokens": "def print_bintree ( tree , indent = '  ' ) : for n in sorted ( tree . keys ( ) ) : print \"%s%s\" % ( indent * depth ( n , tree ) , n )", "docstring_tokens": "print a binary tree", "label": 0}, {"idx": "cosqa-train-5948", "doc": "remove item from python series", "code": "def remove_series(self, series):\n        \"\"\"Removes a :py:class:`.Series` from the chart.\n\n        :param Series series: The :py:class:`.Series` to remove.\n        :raises ValueError: if you try to remove the last\\\n        :py:class:`.Series`.\"\"\"\n\n        if len(self.all_series()) == 1:\n            raise ValueError(\"Cannot remove last series from %s\" % str(self))\n        self._all_series.remove(series)\n        series._chart = None", "code_tokens": "def remove_series ( self , series ) : if len ( self . all_series ( ) ) == 1 : raise ValueError ( \"Cannot remove last series from %s\" % str ( self ) ) self . _all_series . remove ( series ) series . _chart = None", "docstring_tokens": "Removes a : py : class : . Series from the chart .", "label": 0}, {"idx": "cosqa-train-5949", "doc": "print time it takes to complete python step", "code": "def log_finished(self):\n\t\t\"\"\"Log that this task is done.\"\"\"\n\t\tdelta = time.perf_counter() - self.start_time\n\t\tlogger.log(\"Finished '\", logger.cyan(self.name),\n\t\t\t\"' after \", logger.magenta(time_to_text(delta)))", "code_tokens": "def log_finished ( self ) : delta = time . perf_counter ( ) - self . start_time logger . log ( \"Finished '\" , logger . cyan ( self . name ) , \"' after \" , logger . magenta ( time_to_text ( delta ) ) )", "docstring_tokens": "Log that this task is done .", "label": 0}, {"idx": "cosqa-train-5950", "doc": "remove last element from the list python", "code": "def remove_last_entry(self):\n        \"\"\"Remove the last NoteContainer in the Bar.\"\"\"\n        self.current_beat -= 1.0 / self.bar[-1][1]\n        self.bar = self.bar[:-1]\n        return self.current_beat", "code_tokens": "def remove_last_entry ( self ) : self . current_beat -= 1.0 / self . bar [ - 1 ] [ 1 ] self . bar = self . bar [ : - 1 ] return self . current_beat", "docstring_tokens": "Remove the last NoteContainer in the Bar .", "label": 0}, {"idx": "cosqa-train-5951", "doc": "print with consistent spacing python", "code": "def indented_show(text, howmany=1):\n        \"\"\"Print a formatted indented text.\n        \"\"\"\n        print(StrTemplate.pad_indent(text=text, howmany=howmany))", "code_tokens": "def indented_show ( text , howmany = 1 ) : print ( StrTemplate . pad_indent ( text = text , howmany = howmany ) )", "docstring_tokens": "Print a formatted indented text .", "label": 0}, {"idx": "cosqa-train-5952", "doc": "remove multiple variables using del in python", "code": "def __delitem__(self, key):\n        \"\"\"Remove a variable from this dataset.\n        \"\"\"\n        del self._variables[key]\n        self._coord_names.discard(key)", "code_tokens": "def __delitem__ ( self , key ) : del self . _variables [ key ] self . _coord_names . discard ( key )", "docstring_tokens": "Remove a variable from this dataset .", "label": 0}, {"idx": "cosqa-train-5953", "doc": "printing objects as strings python", "code": "def _get_pretty_string(obj):\n    \"\"\"Return a prettier version of obj\n\n    Parameters\n    ----------\n    obj : object\n        Object to pretty print\n\n    Returns\n    -------\n    s : str\n        Pretty print object repr\n    \"\"\"\n    sio = StringIO()\n    pprint.pprint(obj, stream=sio)\n    return sio.getvalue()", "code_tokens": "def _get_pretty_string ( obj ) : sio = StringIO ( ) pprint . pprint ( obj , stream = sio ) return sio . getvalue ( )", "docstring_tokens": "Return a prettier version of obj", "label": 0}, {"idx": "cosqa-train-5954", "doc": "remove na values from df in python", "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True):\n    \"\"\"Clean a pandas dataframe by:\n        1. Filling empty values with Nan\n        2. Dropping columns with all empty values\n\n    Args:\n        df: Pandas DataFrame\n        fill_nan (bool): If any empty values (strings, None, etc) should be replaced with NaN\n        drop_empty_columns (bool): If columns whose values are all empty should be dropped\n\n    Returns:\n        DataFrame: cleaned DataFrame\n\n    \"\"\"\n    if fill_nan:\n        df = df.fillna(value=np.nan)\n    if drop_empty_columns:\n        df = df.dropna(axis=1, how='all')\n    return df.sort_index()", "code_tokens": "def clean_df ( df , fill_nan = True , drop_empty_columns = True ) : if fill_nan : df = df . fillna ( value = np . nan ) if drop_empty_columns : df = df . dropna ( axis = 1 , how = 'all' ) return df . sort_index ( )", "docstring_tokens": "Clean a pandas dataframe by : 1 . Filling empty values with Nan 2 . Dropping columns with all empty values", "label": 0}, {"idx": "cosqa-train-5955", "doc": "proper way to quit python", "code": "def _quit(self, *args):\n        \"\"\" quit crash \"\"\"\n        self.logger.warn('Bye!')\n        sys.exit(self.exit())", "code_tokens": "def _quit ( self , * args ) : self . logger . warn ( 'Bye!' ) sys . exit ( self . exit ( ) )", "docstring_tokens": "quit crash", "label": 0}, {"idx": "cosqa-train-5956", "doc": "remove none values from a list in python", "code": "def filter_none(list_of_points):\n    \"\"\"\n    \n    :param list_of_points: \n    :return: list_of_points with None's removed\n    \"\"\"\n    remove_elementnone = filter(lambda p: p is not None, list_of_points)\n    remove_sublistnone = filter(lambda p: not contains_none(p), remove_elementnone)\n    return list(remove_sublistnone)", "code_tokens": "def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "docstring_tokens": ": param list_of_points : : return : list_of_points with None s removed", "label": 0}, {"idx": "cosqa-train-5957", "doc": "remove observations with 0 value in python", "code": "def __convert_none_to_zero(self, ts):\n        \"\"\"\n        Convert None values to 0 so the data works with Matplotlib\n        :param ts:\n        :return: a list with 0s where Nones existed\n        \"\"\"\n\n        if not ts:\n            return ts\n\n        ts_clean = [val if val else 0 for val in ts]\n\n        return ts_clean", "code_tokens": "def __convert_none_to_zero ( self , ts ) : if not ts : return ts ts_clean = [ val if val else 0 for val in ts ] return ts_clean", "docstring_tokens": "Convert None values to 0 so the data works with Matplotlib : param ts : : return : a list with 0s where Nones existed", "label": 0}, {"idx": "cosqa-train-5958", "doc": "put all quantifiable variables in a list in python", "code": "def qubits(self):\n        \"\"\"Return a list of qubits as (QuantumRegister, index) pairs.\"\"\"\n        return [(v, i) for k, v in self.qregs.items() for i in range(v.size)]", "code_tokens": "def qubits ( self ) : return [ ( v , i ) for k , v in self . qregs . items ( ) for i in range ( v . size ) ]", "docstring_tokens": "Return a list of qubits as ( QuantumRegister index ) pairs .", "label": 0}, {"idx": "cosqa-train-5959", "doc": "remove prefix from object name in python", "code": "def _clean_name(self, prefix, obj):\n        \"\"\"Create a C variable name with the given prefix based on the name of obj.\"\"\"\n        return '{}{}_{}'.format(prefix, self._uid(), ''.join(c for c in obj.name if c.isalnum()))", "code_tokens": "def _clean_name ( self , prefix , obj ) : return '{}{}_{}' . format ( prefix , self . _uid ( ) , '' . join ( c for c in obj . name if c . isalnum ( ) ) )", "docstring_tokens": "Create a C variable name with the given prefix based on the name of obj .", "label": 0}, {"idx": "cosqa-train-5960", "doc": "pytest included in python 3", "code": "def test():  # pragma: no cover\n    \"\"\"Execute the unit tests on an installed copy of unyt.\n\n    Note that this function requires pytest to run. If pytest is not\n    installed this function will raise ImportError.\n    \"\"\"\n    import pytest\n    import os\n\n    pytest.main([os.path.dirname(os.path.abspath(__file__))])", "code_tokens": "def test ( ) : # pragma: no cover import pytest import os pytest . main ( [ os . path . dirname ( os . path . abspath ( __file__ ) ) ] )", "docstring_tokens": "Execute the unit tests on an installed copy of unyt .", "label": 1}, {"idx": "cosqa-train-5961", "doc": "remove punctuation and stop words python nltk", "code": "def wordify(text):\n    \"\"\"Generate a list of words given text, removing punctuation.\n\n    Parameters\n    ----------\n    text : unicode\n        A piece of english text.\n\n    Returns\n    -------\n    words : list\n        List of words.\n    \"\"\"\n    stopset = set(nltk.corpus.stopwords.words('english'))\n    tokens = nltk.WordPunctTokenizer().tokenize(text)\n    return [w for w in tokens if w not in stopset]", "code_tokens": "def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]", "docstring_tokens": "Generate a list of words given text removing punctuation .", "label": 1}, {"idx": "cosqa-train-5962", "doc": "python 'connection' object has no attribute 'delete'", "code": "def close_connection (self):\n        \"\"\"\n        Close an opened url connection.\n        \"\"\"\n        if self.url_connection is None:\n            # no connection is open\n            return\n        try:\n            self.url_connection.close()\n        except Exception:\n            # ignore close errors\n            pass\n        self.url_connection = None", "code_tokens": "def close_connection ( self ) : if self . url_connection is None : # no connection is open return try : self . url_connection . close ( ) except Exception : # ignore close errors pass self . url_connection = None", "docstring_tokens": "Close an opened url connection .", "label": 0}, {"idx": "cosqa-train-5963", "doc": "remove spaces in a file python code", "code": "def lint_file(in_file, out_file=None):\n    \"\"\"Helps remove extraneous whitespace from the lines of a file\n\n    :param file in_file: A readable file or file-like\n    :param file out_file: A writable file or file-like\n    \"\"\"\n    for line in in_file:\n        print(line.strip(), file=out_file)", "code_tokens": "def lint_file ( in_file , out_file = None ) : for line in in_file : print ( line . strip ( ) , file = out_file )", "docstring_tokens": "Helps remove extraneous whitespace from the lines of a file", "label": 1}, {"idx": "cosqa-train-5964", "doc": "python 2 join path", "code": "def prepare_path(path):\n    \"\"\"\n    Path join helper method\n    Join paths if list passed\n\n    :type path: str|unicode|list\n    :rtype: str|unicode\n    \"\"\"\n    if type(path) == list:\n        return os.path.join(*path)\n    return path", "code_tokens": "def prepare_path ( path ) : if type ( path ) == list : return os . path . join ( * path ) return path", "docstring_tokens": "Path join helper method Join paths if list passed", "label": 1}, {"idx": "cosqa-train-5965", "doc": "remove the last object from list in python", "code": "def pop(self, index=-1):\n\t\t\"\"\"Remove and return the item at index.\"\"\"\n\t\tvalue = self._list.pop(index)\n\t\tdel self._dict[value]\n\t\treturn value", "code_tokens": "def pop ( self , index = - 1 ) : value = self . _list . pop ( index ) del self . _dict [ value ] return value", "docstring_tokens": "Remove and return the item at index .", "label": 0}, {"idx": "cosqa-train-5966", "doc": "python 2 os makedirs exits", "code": "def makedirs(path, mode=0o777, exist_ok=False):\n    \"\"\"A wrapper of os.makedirs().\"\"\"\n    os.makedirs(path, mode, exist_ok)", "code_tokens": "def makedirs ( path , mode = 0o777 , exist_ok = False ) : os . makedirs ( path , mode , exist_ok )", "docstring_tokens": "A wrapper of os . makedirs () .", "label": 0}, {"idx": "cosqa-train-5967", "doc": "remove white space from strings in python", "code": "def text_cleanup(data, key, last_type):\n    \"\"\" I strip extra whitespace off multi-line strings if they are ready to be stripped!\"\"\"\n    if key in data and last_type == STRING_TYPE:\n        data[key] = data[key].strip()\n    return data", "code_tokens": "def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data", "docstring_tokens": "I strip extra whitespace off multi - line strings if they are ready to be stripped!", "label": 0}, {"idx": "cosqa-train-5968", "doc": "python 2 parse query string", "code": "def parse_query_string(query):\n    \"\"\"\n    parse_query_string:\n    very simplistic. won't do the right thing with list values\n    \"\"\"\n    result = {}\n    qparts = query.split('&')\n    for item in qparts:\n        key, value = item.split('=')\n        key = key.strip()\n        value = value.strip()\n        result[key] = unquote_plus(value)\n    return result", "code_tokens": "def parse_query_string ( query ) : result = { } qparts = query . split ( '&' ) for item in qparts : key , value = item . split ( '=' ) key = key . strip ( ) value = value . strip ( ) result [ key ] = unquote_plus ( value ) return result", "docstring_tokens": "parse_query_string : very simplistic . won t do the right thing with list values", "label": 1}, {"idx": "cosqa-train-5969", "doc": "remove white space in string python", "code": "def text_cleanup(data, key, last_type):\n    \"\"\" I strip extra whitespace off multi-line strings if they are ready to be stripped!\"\"\"\n    if key in data and last_type == STRING_TYPE:\n        data[key] = data[key].strip()\n    return data", "code_tokens": "def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data", "docstring_tokens": "I strip extra whitespace off multi - line strings if they are ready to be stripped!", "label": 0}, {"idx": "cosqa-train-5970", "doc": "python 2 using if and user input", "code": "def _stdin_(p):\n    \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"\n    _v = sys.version[0]\n    return input(p) if _v is '3' else raw_input(p)", "code_tokens": "def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "docstring_tokens": "Takes input from user . Works for Python 2 and 3 .", "label": 0}, {"idx": "cosqa-train-5971", "doc": "remove whitespace at end of line in python", "code": "def clean(s):\n  \"\"\"Removes trailing whitespace on each line.\"\"\"\n  lines = [l.rstrip() for l in s.split('\\n')]\n  return '\\n'.join(lines)", "code_tokens": "def clean ( s ) : lines = [ l . rstrip ( ) for l in s . split ( '\\n' ) ] return '\\n' . join ( lines )", "docstring_tokens": "Removes trailing whitespace on each line .", "label": 1}, {"idx": "cosqa-train-5972", "doc": "python 3 check if object is number", "code": "def is_number(obj):\n    \"\"\"Check if obj is number.\"\"\"\n    return isinstance(obj, (int, float, np.int_, np.float_))", "code_tokens": "def is_number ( obj ) : return isinstance ( obj , ( int , float , np . int_ , np . float_ ) )", "docstring_tokens": "Check if obj is number .", "label": 1}, {"idx": "cosqa-train-5973", "doc": "remove xaxis ticks labels python", "code": "def clean_axis(axis):\n    \"\"\"Remove ticks, tick labels, and frame from axis\"\"\"\n    axis.get_xaxis().set_ticks([])\n    axis.get_yaxis().set_ticks([])\n    for spine in list(axis.spines.values()):\n        spine.set_visible(False)", "code_tokens": "def clean_axis ( axis ) : axis . get_xaxis ( ) . set_ticks ( [ ] ) axis . get_yaxis ( ) . set_ticks ( [ ] ) for spine in list ( axis . spines . values ( ) ) : spine . set_visible ( False )", "docstring_tokens": "Remove ticks tick labels and frame from axis", "label": 1}, {"idx": "cosqa-train-5974", "doc": "python 3 check if string is not empty", "code": "def is_non_empty_string(input_string):\n    \"\"\"\n    Validate if non empty string\n\n    :param input_string: Input is a *str*.\n    :return: True if input is string and non empty.\n       Raise :exc:`Exception` otherwise.\n    \"\"\"\n    try:\n        if not input_string.strip():\n            raise ValueError()\n    except AttributeError as error:\n        raise TypeError(error)\n\n    return True", "code_tokens": "def is_non_empty_string ( input_string ) : try : if not input_string . strip ( ) : raise ValueError ( ) except AttributeError as error : raise TypeError ( error ) return True", "docstring_tokens": "Validate if non empty string", "label": 0}, {"idx": "cosqa-train-5975", "doc": "remove xml nodes with python", "code": "def cleanup_nodes(doc):\n    \"\"\"\n    Remove text nodes containing only whitespace\n    \"\"\"\n    for node in doc.documentElement.childNodes:\n        if node.nodeType == Node.TEXT_NODE and node.nodeValue.isspace():\n            doc.documentElement.removeChild(node)\n    return doc", "code_tokens": "def cleanup_nodes ( doc ) : for node in doc . documentElement . childNodes : if node . nodeType == Node . TEXT_NODE and node . nodeValue . isspace ( ) : doc . documentElement . removeChild ( node ) return doc", "docstring_tokens": "Remove text nodes containing only whitespace", "label": 1}, {"idx": "cosqa-train-5976", "doc": "removing elements from set python", "code": "def unique(_list):\n    \"\"\"\n    Makes the list have unique items only and maintains the order\n\n    list(set()) won't provide that\n\n    :type _list list\n    :rtype: list\n    \"\"\"\n    ret = []\n\n    for item in _list:\n        if item not in ret:\n            ret.append(item)\n\n    return ret", "code_tokens": "def unique ( _list ) : ret = [ ] for item in _list : if item not in ret : ret . append ( item ) return ret", "docstring_tokens": "Makes the list have unique items only and maintains the order", "label": 0}, {"idx": "cosqa-train-5977", "doc": "python 3 combobox update values", "code": "def _updateItemComboBoxIndex(self, item, column, num):\n        \"\"\"Callback for comboboxes: notifies us that a combobox for the given item and column has changed\"\"\"\n        item._combobox_current_index[column] = num\n        item._combobox_current_value[column] = item._combobox_option_list[column][num][0]", "code_tokens": "def _updateItemComboBoxIndex ( self , item , column , num ) : item . _combobox_current_index [ column ] = num item . _combobox_current_value [ column ] = item . _combobox_option_list [ column ] [ num ] [ 0 ]", "docstring_tokens": "Callback for comboboxes : notifies us that a combobox for the given item and column has changed", "label": 0}, {"idx": "cosqa-train-5978", "doc": "removing items seperated by comma from a list python", "code": "def string_to_list(string, sep=\",\", filter_empty=False):\n    \"\"\"Transforma una string con elementos separados por `sep` en una lista.\"\"\"\n    return [value.strip() for value in string.split(sep)\n            if (not filter_empty or value)]", "code_tokens": "def string_to_list ( string , sep = \",\" , filter_empty = False ) : return [ value . strip ( ) for value in string . split ( sep ) if ( not filter_empty or value ) ]", "docstring_tokens": "Transforma una string con elementos separados por sep en una lista .", "label": 0}, {"idx": "cosqa-train-5979", "doc": "python 3 create a dictionary from a list of tuples", "code": "def _convert(tup, dictlist):\n    \"\"\"\n    :param tup: a list of tuples\n    :param di: a dictionary converted from tup\n    :return: dictionary\n    \"\"\"\n    di = {}\n    for a, b in tup:\n        di.setdefault(a, []).append(b)\n    for key, val in di.items():\n        dictlist.append((key, val))\n    return dictlist", "code_tokens": "def _convert ( tup , dictlist ) : di = { } for a , b in tup : di . setdefault ( a , [ ] ) . append ( b ) for key , val in di . items ( ) : dictlist . append ( ( key , val ) ) return dictlist", "docstring_tokens": ": param tup : a list of tuples : param di : a dictionary converted from tup : return : dictionary", "label": 1}, {"idx": "cosqa-train-5980", "doc": "replace any singular letters in python", "code": "def dashrepl(value):\n    \"\"\"\n    Replace any non-word characters with a dash.\n    \"\"\"\n    patt = re.compile(r'\\W', re.UNICODE)\n    return re.sub(patt, '-', value)", "code_tokens": "def dashrepl ( value ) : patt = re . compile ( r'\\W' , re . UNICODE ) return re . sub ( patt , '-' , value )", "docstring_tokens": "Replace any non - word characters with a dash .", "label": 0}, {"idx": "cosqa-train-5981", "doc": "python 3 not runnning in git bash", "code": "def check_git():\n    \"\"\"Check if git command is available.\"\"\"\n    try:\n        with open(os.devnull, \"wb\") as devnull:\n            subprocess.check_call([\"git\", \"--version\"], stdout=devnull, stderr=devnull)\n    except:\n        raise RuntimeError(\"Please make sure git is installed and on your path.\")", "code_tokens": "def check_git ( ) : try : with open ( os . devnull , \"wb\" ) as devnull : subprocess . check_call ( [ \"git\" , \"--version\" ] , stdout = devnull , stderr = devnull ) except : raise RuntimeError ( \"Please make sure git is installed and on your path.\" )", "docstring_tokens": "Check if git command is available .", "label": 1}, {"idx": "cosqa-train-5982", "doc": "replace boolean values with 1s and 0s python", "code": "def _cast_boolean(value):\n    \"\"\"\n    Helper to convert config values to boolean as ConfigParser do.\n    \"\"\"\n    _BOOLEANS = {'1': True, 'yes': True, 'true': True, 'on': True,\n                 '0': False, 'no': False, 'false': False, 'off': False, '': False}\n    value = str(value)\n    if value.lower() not in _BOOLEANS:\n        raise ValueError('Not a boolean: %s' % value)\n\n    return _BOOLEANS[value.lower()]", "code_tokens": "def _cast_boolean ( value ) : _BOOLEANS = { '1' : True , 'yes' : True , 'true' : True , 'on' : True , '0' : False , 'no' : False , 'false' : False , 'off' : False , '' : False } value = str ( value ) if value . lower ( ) not in _BOOLEANS : raise ValueError ( 'Not a boolean: %s' % value ) return _BOOLEANS [ value . lower ( ) ]", "docstring_tokens": "Helper to convert config values to boolean as ConfigParser do .", "label": 0}, {"idx": "cosqa-train-5983", "doc": "python 3 unpack tuple lambda", "code": "def lambda_tuple_converter(func):\n    \"\"\"\n    Converts a Python 2 function as\n      lambda (x,y): x + y\n    In the Python 3 format:\n      lambda x,y : x + y\n    \"\"\"\n    if func is not None and func.__code__.co_argcount == 1:\n        return lambda *args: func(args[0] if len(args) == 1 else args)\n    else:\n        return func", "code_tokens": "def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func", "docstring_tokens": "Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y", "label": 0}, {"idx": "cosqa-train-5984", "doc": "replace dash in string python", "code": "def dashrepl(value):\n    \"\"\"\n    Replace any non-word characters with a dash.\n    \"\"\"\n    patt = re.compile(r'\\W', re.UNICODE)\n    return re.sub(patt, '-', value)", "code_tokens": "def dashrepl ( value ) : patt = re . compile ( r'\\W' , re . UNICODE ) return re . sub ( patt , '-' , value )", "docstring_tokens": "Replace any non - word characters with a dash .", "label": 0}, {"idx": "cosqa-train-5985", "doc": "python 3 user input if else", "code": "def _stdin_(p):\n    \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"\n    _v = sys.version[0]\n    return input(p) if _v is '3' else raw_input(p)", "code_tokens": "def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "docstring_tokens": "Takes input from user . Works for Python 2 and 3 .", "label": 1}, {"idx": "cosqa-train-5986", "doc": "replace items of a list with another python", "code": "def replace_list(items, match, replacement):\n    \"\"\"Replaces occurrences of a match string in a given list of strings and returns\n    a list of new strings. The match string can be a regex expression.\n\n    Args:\n        items (list):       the list of strings to modify.\n        match (str):        the search expression.\n        replacement (str):  the string to replace with.\n    \"\"\"\n    return [replace(item, match, replacement) for item in items]", "code_tokens": "def replace_list ( items , match , replacement ) : return [ replace ( item , match , replacement ) for item in items ]", "docstring_tokens": "Replaces occurrences of a match string in a given list of strings and returns a list of new strings . The match string can be a regex expression .", "label": 0}, {"idx": "cosqa-train-5987", "doc": "python 3, generate numpy array with zeros", "code": "def zeros(self, name, **kwargs):\n        \"\"\"Create an array. Keyword arguments as per\n        :func:`zarr.creation.zeros`.\"\"\"\n        return self._write_op(self._zeros_nosync, name, **kwargs)", "code_tokens": "def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )", "docstring_tokens": "Create an array . Keyword arguments as per : func : zarr . creation . zeros .", "label": 0}, {"idx": "cosqa-train-5988", "doc": "replace month number values with name python", "code": "def replace_month_abbr_with_num(date_str, lang=DEFAULT_DATE_LANG):\n    \"\"\"Replace month strings occurrences with month number.\"\"\"\n    num, abbr = get_month_from_date_str(date_str, lang)\n    return re.sub(abbr, str(num), date_str, flags=re.IGNORECASE)", "code_tokens": "def replace_month_abbr_with_num ( date_str , lang = DEFAULT_DATE_LANG ) : num , abbr = get_month_from_date_str ( date_str , lang ) return re . sub ( abbr , str ( num ) , date_str , flags = re . IGNORECASE )", "docstring_tokens": "Replace month strings occurrences with month number .", "label": 0}, {"idx": "cosqa-train-5989", "doc": "python 3, round number", "code": "def specialRound(number, rounding):\n    \"\"\"A method used to round a number in the way that UsefulUtils rounds.\"\"\"\n    temp = 0\n    if rounding == 0:\n        temp = number\n    else:\n        temp =  round(number, rounding)\n    if temp % 1 == 0:\n        return int(temp)\n    else:\n        return float(temp)", "code_tokens": "def specialRound ( number , rounding ) : temp = 0 if rounding == 0 : temp = number else : temp = round ( number , rounding ) if temp % 1 == 0 : return int ( temp ) else : return float ( temp )", "docstring_tokens": "A method used to round a number in the way that UsefulUtils rounds .", "label": 1}, {"idx": "cosqa-train-5990", "doc": "replace nan values in numpy array with zero numpy python", "code": "def clean_with_zeros(self,x):\n        \"\"\" set nan and inf rows from x to zero\"\"\"\n        x[~np.any(np.isnan(x) | np.isinf(x),axis=1)] = 0\n        return x", "code_tokens": "def clean_with_zeros ( self , x ) : x [ ~ np . any ( np . isnan ( x ) | np . isinf ( x ) , axis = 1 ) ] = 0 return x", "docstring_tokens": "set nan and inf rows from x to zero", "label": 0}, {"idx": "cosqa-train-5991", "doc": "python 95% percentile values of a list", "code": "def percentile(values, k):\n    \"\"\"Find the percentile of a list of values.\n\n    :param list values: The list of values to find the percentile of\n    :param int k: The percentile to find\n    :rtype: float or int\n\n    \"\"\"\n    if not values:\n        return None\n    values.sort()\n    index = (len(values) * (float(k) / 100)) - 1\n    return values[int(math.ceil(index))]", "code_tokens": "def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]", "docstring_tokens": "Find the percentile of a list of values .", "label": 0}, {"idx": "cosqa-train-5992", "doc": "replace text in dictionary python", "code": "def replace_all(text, dic):\n    \"\"\"Takes a string and dictionary. replaces all occurrences of i with j\"\"\"\n\n    for i, j in dic.iteritems():\n        text = text.replace(i, j)\n    return text", "code_tokens": "def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text", "docstring_tokens": "Takes a string and dictionary . replaces all occurrences of i with j", "label": 0}, {"idx": "cosqa-train-5993", "doc": "python add 0x to string", "code": "def add_0x(string):\n    \"\"\"Add 0x to string at start.\n    \"\"\"\n    if isinstance(string, bytes):\n        string = string.decode('utf-8')\n    return '0x' + str(string)", "code_tokens": "def add_0x ( string ) : if isinstance ( string , bytes ) : string = string . decode ( 'utf-8' ) return '0x' + str ( string )", "docstring_tokens": "Add 0x to string at start .", "label": 0}, {"idx": "cosqa-train-5994", "doc": "replace unary character with ascii in python", "code": "def safe_unicode(string):\n    \"\"\"If Python 2, replace non-ascii characters and return encoded string.\"\"\"\n    if not PY3:\n        uni = string.replace(u'\\u2019', \"'\")\n        return uni.encode('utf-8')\n        \n    return string", "code_tokens": "def safe_unicode ( string ) : if not PY3 : uni = string . replace ( u'\\u2019' , \"'\" ) return uni . encode ( 'utf-8' ) return string", "docstring_tokens": "If Python 2 replace non - ascii characters and return encoded string .", "label": 1}, {"idx": "cosqa-train-5995", "doc": "python add coroutine to async function", "code": "def submit(self, fn, *args, **kwargs):\n        \"\"\"Submit an operation\"\"\"\n        corofn = asyncio.coroutine(lambda: fn(*args, **kwargs))\n        return run_coroutine_threadsafe(corofn(), self.loop)", "code_tokens": "def submit ( self , fn , * args , * * kwargs ) : corofn = asyncio . coroutine ( lambda : fn ( * args , * * kwargs ) ) return run_coroutine_threadsafe ( corofn ( ) , self . loop )", "docstring_tokens": "Submit an operation", "label": 0}, {"idx": "cosqa-train-5996", "doc": "replacing na with missing in python", "code": "def _replace_nan(a, val):\n    \"\"\"\n    replace nan in a by val, and returns the replaced array and the nan\n    position\n    \"\"\"\n    mask = isnull(a)\n    return where_method(val, mask, a), mask", "code_tokens": "def _replace_nan ( a , val ) : mask = isnull ( a ) return where_method ( val , mask , a ) , mask", "docstring_tokens": "replace nan in a by val and returns the replaced array and the nan position", "label": 0}, {"idx": "cosqa-train-5997", "doc": "python add geolocation information", "code": "def get_geoip(ip):\n    \"\"\"Lookup country for IP address.\"\"\"\n    reader = geolite2.reader()\n    ip_data = reader.get(ip) or {}\n    return ip_data.get('country', {}).get('iso_code')", "code_tokens": "def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )", "docstring_tokens": "Lookup country for IP address .", "label": 0}, {"idx": "cosqa-train-5998", "doc": "request user agent header python", "code": "def _get_user_agent(self):\n        \"\"\"Retrieve the request's User-Agent, if available.\n\n        Taken from Flask Login utils.py.\n        \"\"\"\n        user_agent = request.headers.get('User-Agent')\n        if user_agent:\n            user_agent = user_agent.encode('utf-8')\n        return user_agent or ''", "code_tokens": "def _get_user_agent ( self ) : user_agent = request . headers . get ( 'User-Agent' ) if user_agent : user_agent = user_agent . encode ( 'utf-8' ) return user_agent or ''", "docstring_tokens": "Retrieve the request s User - Agent if available .", "label": 0}, {"idx": "cosqa-train-5999", "doc": "python add noise into sound", "code": "def synthesize(self, duration):\n        \"\"\"\n        Synthesize white noise\n\n        Args:\n            duration (numpy.timedelta64): The duration of the synthesized sound\n        \"\"\"\n        sr = self.samplerate.samples_per_second\n        seconds = duration / Seconds(1)\n        samples = np.random.uniform(low=-1., high=1., size=int(sr * seconds))\n        return AudioSamples(samples, self.samplerate)", "code_tokens": "def synthesize ( self , duration ) : sr = self . samplerate . samples_per_second seconds = duration / Seconds ( 1 ) samples = np . random . uniform ( low = - 1. , high = 1. , size = int ( sr * seconds ) ) return AudioSamples ( samples , self . samplerate )", "docstring_tokens": "Synthesize white noise", "label": 1}, {"idx": "cosqa-train-6000", "doc": "reshape a series in python", "code": "def sf01(arr):\n    \"\"\"\n    swap and then flatten axes 0 and 1\n    \"\"\"\n    s = arr.shape\n    return arr.swapaxes(0, 1).reshape(s[0] * s[1], *s[2:])", "code_tokens": "def sf01 ( arr ) : s = arr . shape return arr . swapaxes ( 0 , 1 ) . reshape ( s [ 0 ] * s [ 1 ] , * s [ 2 : ] )", "docstring_tokens": "swap and then flatten axes 0 and 1", "label": 0}, {"idx": "cosqa-train-6001", "doc": "python add noise to audio", "code": "def synthesize(self, duration):\n        \"\"\"\n        Synthesize white noise\n\n        Args:\n            duration (numpy.timedelta64): The duration of the synthesized sound\n        \"\"\"\n        sr = self.samplerate.samples_per_second\n        seconds = duration / Seconds(1)\n        samples = np.random.uniform(low=-1., high=1., size=int(sr * seconds))\n        return AudioSamples(samples, self.samplerate)", "code_tokens": "def synthesize ( self , duration ) : sr = self . samplerate . samples_per_second seconds = duration / Seconds ( 1 ) samples = np . random . uniform ( low = - 1. , high = 1. , size = int ( sr * seconds ) ) return AudioSamples ( samples , self . samplerate )", "docstring_tokens": "Synthesize white noise", "label": 0}, {"idx": "cosqa-train-6002", "doc": "resolve pickling error parallel processing python copyreg stack overflow", "code": "def _parallel_compare_helper(class_obj, pairs, x, x_link=None):\n    \"\"\"Internal function to overcome pickling problem in python2.\"\"\"\n    return class_obj._compute(pairs, x, x_link)", "code_tokens": "def _parallel_compare_helper ( class_obj , pairs , x , x_link = None ) : return class_obj . _compute ( pairs , x , x_link )", "docstring_tokens": "Internal function to overcome pickling problem in python2 .", "label": 0}, {"idx": "cosqa-train-6003", "doc": "python adding a keyword to the callback", "code": "def add_device_callback(self, callback):\n        \"\"\"Register a callback to be invoked when a new device appears.\"\"\"\n        _LOGGER.debug('Added new callback %s ', callback)\n        self._cb_new_device.append(callback)", "code_tokens": "def add_device_callback ( self , callback ) : _LOGGER . debug ( 'Added new callback %s ' , callback ) self . _cb_new_device . append ( callback )", "docstring_tokens": "Register a callback to be invoked when a new device appears .", "label": 0}, {"idx": "cosqa-train-6004", "doc": "rest api get works on browser not in python", "code": "def _list_available_rest_versions(self):\n        \"\"\"Return a list of the REST API versions supported by the array\"\"\"\n        url = \"https://{0}/api/api_version\".format(self._target)\n\n        data = self._request(\"GET\", url, reestablish_session=False)\n        return data[\"version\"]", "code_tokens": "def _list_available_rest_versions ( self ) : url = \"https://{0}/api/api_version\" . format ( self . _target ) data = self . _request ( \"GET\" , url , reestablish_session = False ) return data [ \"version\" ]", "docstring_tokens": "Return a list of the REST API versions supported by the array", "label": 1}, {"idx": "cosqa-train-6005", "doc": "python agraph edge property", "code": "def has_edge(self, p_from, p_to):\n        \"\"\" Returns True when the graph has the given edge. \"\"\"\n        return p_from in self._edges and p_to in self._edges[p_from]", "code_tokens": "def has_edge ( self , p_from , p_to ) : return p_from in self . _edges and p_to in self . _edges [ p_from ]", "docstring_tokens": "Returns True when the graph has the given edge .", "label": 1}, {"idx": "cosqa-train-6006", "doc": "retrieve object type python", "code": "def type(self):\n        \"\"\"Returns type of the data for the given FeatureType.\"\"\"\n        if self is FeatureType.TIMESTAMP:\n            return list\n        if self is FeatureType.BBOX:\n            return BBox\n        return dict", "code_tokens": "def type ( self ) : if self is FeatureType . TIMESTAMP : return list if self is FeatureType . BBOX : return BBox return dict", "docstring_tokens": "Returns type of the data for the given FeatureType .", "label": 0}, {"idx": "cosqa-train-6007", "doc": "python aiohttp send emaijl", "code": "async def send_message():\n    \"\"\"Example of sending a message.\"\"\"\n    jar = aiohttp.CookieJar(unsafe=True)\n    websession = aiohttp.ClientSession(cookie_jar=jar)\n\n    modem = eternalegypt.Modem(hostname=sys.argv[1], websession=websession)\n    await modem.login(password=sys.argv[2])\n\n    await modem.sms(phone=sys.argv[3], message=sys.argv[4])\n\n    await modem.logout()\n    await websession.close()", "code_tokens": "async def send_message ( ) : jar = aiohttp . CookieJar ( unsafe = True ) websession = aiohttp . ClientSession ( cookie_jar = jar ) modem = eternalegypt . Modem ( hostname = sys . argv [ 1 ] , websession = websession ) await modem . login ( password = sys . argv [ 2 ] ) await modem . sms ( phone = sys . argv [ 3 ] , message = sys . argv [ 4 ] ) await modem . logout ( ) await websession . close ( )", "docstring_tokens": "Example of sending a message .", "label": 0}, {"idx": "cosqa-train-6008", "doc": "retrieving file property with python", "code": "def get_property(self, filename):\n        \"\"\"Opens the file and reads the value\"\"\"\n\n        with open(self.filepath(filename)) as f:\n            return f.read().strip()", "code_tokens": "def get_property ( self , filename ) : with open ( self . filepath ( filename ) ) as f : return f . read ( ) . strip ( )", "docstring_tokens": "Opens the file and reads the value", "label": 0}, {"idx": "cosqa-train-6009", "doc": "python all partitions of list", "code": "def partition_all(n, iterable):\n    \"\"\"Partition a list into equally sized pieces, including last smaller parts\n    http://stackoverflow.com/questions/5129102/python-equivalent-to-clojures-partition-all\n    \"\"\"\n    it = iter(iterable)\n    while True:\n        chunk = list(itertools.islice(it, n))\n        if not chunk:\n            break\n        yield chunk", "code_tokens": "def partition_all ( n , iterable ) : it = iter ( iterable ) while True : chunk = list ( itertools . islice ( it , n ) ) if not chunk : break yield chunk", "docstring_tokens": "Partition a list into equally sized pieces including last smaller parts http : // stackoverflow . com / questions / 5129102 / python - equivalent - to - clojures - partition - all", "label": 1}, {"idx": "cosqa-train-6010", "doc": "return a column from a datatable python", "code": "def get_date_field(datetimes, field):\n    \"\"\"Adapted from pandas.tslib.get_date_field\"\"\"\n    return np.array([getattr(date, field) for date in datetimes])", "code_tokens": "def get_date_field ( datetimes , field ) : return np . array ( [ getattr ( date , field ) for date in datetimes ] )", "docstring_tokens": "Adapted from pandas . tslib . get_date_field", "label": 0}, {"idx": "cosqa-train-6011", "doc": "python analyze bounding box of image", "code": "def bbox(img):\n    \"\"\"Find the bounding box around nonzero elements in the given array\n\n    Copied from https://stackoverflow.com/a/31402351/5703449 .\n\n    Returns:\n        rowmin, rowmax, colmin, colmax\n    \"\"\"\n    rows = np.any(img, axis=1)\n    cols = np.any(img, axis=0)\n    rmin, rmax = np.where(rows)[0][[0, -1]]\n    cmin, cmax = np.where(cols)[0][[0, -1]]\n\n    return rmin, rmax, cmin, cmax", "code_tokens": "def bbox ( img ) : rows = np . any ( img , axis = 1 ) cols = np . any ( img , axis = 0 ) rmin , rmax = np . where ( rows ) [ 0 ] [ [ 0 , - 1 ] ] cmin , cmax = np . where ( cols ) [ 0 ] [ [ 0 , - 1 ] ] return rmin , rmax , cmin , cmax", "docstring_tokens": "Find the bounding box around nonzero elements in the given array", "label": 0}, {"idx": "cosqa-train-6012", "doc": "python and geneteate hash random number", "code": "def generate_hash(self, length=30):\n        \"\"\" Generate random string of given length \"\"\"\n        import random, string\n        chars = string.ascii_letters + string.digits\n        ran = random.SystemRandom().choice\n        hash = ''.join(ran(chars) for i in range(length))\n        return hash", "code_tokens": "def generate_hash ( self , length = 30 ) : import random , string chars = string . ascii_letters + string . digits ran = random . SystemRandom ( ) . choice hash = '' . join ( ran ( chars ) for i in range ( length ) ) return hash", "docstring_tokens": "Generate random string of given length", "label": 0}, {"idx": "cosqa-train-6013", "doc": "return keys of most common in python counter object", "code": "def most_common(items):\n    \"\"\"\n    Wanted functionality from Counters (new in Python 2.7).\n    \"\"\"\n    counts = {}\n    for i in items:\n        counts.setdefault(i, 0)\n        counts[i] += 1\n    return max(six.iteritems(counts), key=operator.itemgetter(1))", "code_tokens": "def most_common ( items ) : counts = { } for i in items : counts . setdefault ( i , 0 ) counts [ i ] += 1 return max ( six . iteritems ( counts ) , key = operator . itemgetter ( 1 ) )", "docstring_tokens": "Wanted functionality from Counters ( new in Python 2 . 7 ) .", "label": 0}, {"idx": "cosqa-train-6014", "doc": "python and get os user name", "code": "def get_user_name():\n    \"\"\"Get user name provide by operating system\n    \"\"\"\n\n    if sys.platform == 'win32':\n        #user = os.getenv('USERPROFILE')\n        user = os.getenv('USERNAME')\n    else:\n        user = os.getenv('LOGNAME')\n\n    return user", "code_tokens": "def get_user_name ( ) : if sys . platform == 'win32' : #user = os.getenv('USERPROFILE') user = os . getenv ( 'USERNAME' ) else : user = os . getenv ( 'LOGNAME' ) return user", "docstring_tokens": "Get user name provide by operating system", "label": 1}, {"idx": "cosqa-train-6015", "doc": "return min value in a list python", "code": "def find_lt(a, x):\n    \"\"\"Find rightmost value less than x\"\"\"\n    i = bisect.bisect_left(a, x)\n    if i:\n        return a[i-1]\n    raise ValueError", "code_tokens": "def find_lt ( a , x ) : i = bisect . bisect_left ( a , x ) if i : return a [ i - 1 ] raise ValueError", "docstring_tokens": "Find rightmost value less than x", "label": 0}, {"idx": "cosqa-train-6016", "doc": "python animation to gif", "code": "def _encode_gif(images, fps):\n  \"\"\"Encodes numpy images into gif string.\n\n  Args:\n    images: A 4-D `uint8` `np.array` (or a list of 3-D images) of shape\n      `[time, height, width, channels]` where `channels` is 1 or 3.\n    fps: frames per second of the animation\n\n  Returns:\n    The encoded gif string.\n\n  Raises:\n    IOError: If the ffmpeg command returns an error.\n  \"\"\"\n  writer = WholeVideoWriter(fps)\n  writer.write_multi(images)\n  return writer.finish()", "code_tokens": "def _encode_gif ( images , fps ) : writer = WholeVideoWriter ( fps ) writer . write_multi ( images ) return writer . finish ( )", "docstring_tokens": "Encodes numpy images into gif string .", "label": 1}, {"idx": "cosqa-train-6017", "doc": "return python jumps to next line", "code": "def do_next(self, args):\n        \"\"\"Step over the next statement\n        \"\"\"\n        self._do_print_from_last_cmd = True\n        self._interp.step_over()\n        return True", "code_tokens": "def do_next ( self , args ) : self . _do_print_from_last_cmd = True self . _interp . step_over ( ) return True", "docstring_tokens": "Step over the next statement", "label": 0}, {"idx": "cosqa-train-6018", "doc": "python any element of a set logic", "code": "def convert_args_to_sets(f):\n    \"\"\"\n    Converts all args to 'set' type via self.setify function.\n    \"\"\"\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        args = (setify(x) for x in args)\n        return f(*args, **kwargs)\n    return wrapper", "code_tokens": "def convert_args_to_sets ( f ) : @ wraps ( f ) def wrapper ( * args , * * kwargs ) : args = ( setify ( x ) for x in args ) return f ( * args , * * kwargs ) return wrapper", "docstring_tokens": "Converts all args to set type via self . setify function .", "label": 0}, {"idx": "cosqa-train-6019", "doc": "return the size of an image stored as a numpy array in python", "code": "def bytesize(arr):\n    \"\"\"\n    Returns the memory byte size of a Numpy array as an integer.\n    \"\"\"\n    byte_size = np.prod(arr.shape) * np.dtype(arr.dtype).itemsize\n    return byte_size", "code_tokens": "def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size", "docstring_tokens": "Returns the memory byte size of a Numpy array as an integer .", "label": 0}, {"idx": "cosqa-train-6020", "doc": "python append kwargs to existing dictionary", "code": "def _merge_args_with_kwargs(args_dict, kwargs_dict):\n    \"\"\"Merge args with kwargs.\"\"\"\n    ret = args_dict.copy()\n    ret.update(kwargs_dict)\n    return ret", "code_tokens": "def _merge_args_with_kwargs ( args_dict , kwargs_dict ) : ret = args_dict . copy ( ) ret . update ( kwargs_dict ) return ret", "docstring_tokens": "Merge args with kwargs .", "label": 0}, {"idx": "cosqa-train-6021", "doc": "return union between two sets in python", "code": "def __or__(self, other):\n        \"\"\"Return the union of two RangeSets as a new RangeSet.\n\n        (I.e. all elements that are in either set.)\n        \"\"\"\n        if not isinstance(other, set):\n            return NotImplemented\n        return self.union(other)", "code_tokens": "def __or__ ( self , other ) : if not isinstance ( other , set ) : return NotImplemented return self . union ( other )", "docstring_tokens": "Return the union of two RangeSets as a new RangeSet .", "label": 0}, {"idx": "cosqa-train-6022", "doc": "python apply a function to a vector", "code": "def apply(f, obj, *args, **kwargs):\n    \"\"\"Apply a function in parallel to each element of the input\"\"\"\n    return vectorize(f)(obj, *args, **kwargs)", "code_tokens": "def apply ( f , obj , * args , * * kwargs ) : return vectorize ( f ) ( obj , * args , * * kwargs )", "docstring_tokens": "Apply a function in parallel to each element of the input", "label": 0}, {"idx": "cosqa-train-6023", "doc": "revealing the type in python", "code": "def getTypeStr(_type):\n  r\"\"\"Gets the string representation of the given type.\n  \"\"\"\n  if isinstance(_type, CustomType):\n    return str(_type)\n\n  if hasattr(_type, '__name__'):\n    return _type.__name__\n\n  return ''", "code_tokens": "def getTypeStr ( _type ) : if isinstance ( _type , CustomType ) : return str ( _type ) if hasattr ( _type , '__name__' ) : return _type . __name__ return ''", "docstring_tokens": "r Gets the string representation of the given type .", "label": 0}, {"idx": "cosqa-train-6024", "doc": "python apply function dict", "code": "def map_with_obj(f, dct):\n    \"\"\"\n        Implementation of Ramda's mapObjIndexed without the final argument.\n        This returns the original key with the mapped value. Use map_key_values to modify the keys too\n    :param f: Called with a key and value\n    :param dct:\n    :return {dict}: Keyed by the original key, valued by the mapped value\n    \"\"\"\n    f_dict = {}\n    for k, v in dct.items():\n        f_dict[k] = f(k, v)\n    return f_dict", "code_tokens": "def map_with_obj ( f , dct ) : f_dict = { } for k , v in dct . items ( ) : f_dict [ k ] = f ( k , v ) return f_dict", "docstring_tokens": "Implementation of Ramda s mapObjIndexed without the final argument . This returns the original key with the mapped value . Use map_key_values to modify the keys too : param f : Called with a key and value : param dct : : return { dict } : Keyed by the original key valued by the mapped value", "label": 0}, {"idx": "cosqa-train-6025", "doc": "rgb value for the color green python green", "code": "def rgba_bytes_tuple(self, x):\n        \"\"\"Provides the color corresponding to value `x` in the\n        form of a tuple (R,G,B,A) with int values between 0 and 255.\n        \"\"\"\n        return tuple(int(u*255.9999) for u in self.rgba_floats_tuple(x))", "code_tokens": "def rgba_bytes_tuple ( self , x ) : return tuple ( int ( u * 255.9999 ) for u in self . rgba_floats_tuple ( x ) )", "docstring_tokens": "Provides the color corresponding to value x in the form of a tuple ( R G B A ) with int values between 0 and 255 .", "label": 1}, {"idx": "cosqa-train-6026", "doc": "python apply function to all columns in df", "code": "def transform(self, df):\n        \"\"\"\n        Transforms a DataFrame in place. Computes all outputs of the DataFrame.\n\n        Args:\n            df (pandas.DataFrame): DataFrame to transform.\n        \"\"\"\n        for name, function in self.outputs:\n            df[name] = function(df)", "code_tokens": "def transform ( self , df ) : for name , function in self . outputs : df [ name ] = function ( df )", "docstring_tokens": "Transforms a DataFrame in place . Computes all outputs of the DataFrame .", "label": 0}, {"idx": "cosqa-train-6027", "doc": "rmarkdown 'python' is not recognized as an internal or external command", "code": "def parse_markdown(markdown_content, site_settings):\n    \"\"\"Parse markdown text to html.\n\n    :param markdown_content: Markdown text lists #TODO#\n    \"\"\"\n    markdown_extensions = set_markdown_extensions(site_settings)\n\n    html_content = markdown.markdown(\n        markdown_content,\n        extensions=markdown_extensions,\n    )\n\n    return html_content", "code_tokens": "def parse_markdown ( markdown_content , site_settings ) : markdown_extensions = set_markdown_extensions ( site_settings ) html_content = markdown . markdown ( markdown_content , extensions = markdown_extensions , ) return html_content", "docstring_tokens": "Parse markdown text to html .", "label": 0}, {"idx": "cosqa-train-6028", "doc": "python apply mask on image", "code": "def _rgbtomask(self, obj):\n        \"\"\"Convert RGB arrays from mask canvas object back to boolean mask.\"\"\"\n        dat = obj.get_image().get_data()  # RGB arrays\n        return dat.sum(axis=2).astype(np.bool)", "code_tokens": "def _rgbtomask ( self , obj ) : dat = obj . get_image ( ) . get_data ( ) # RGB arrays return dat . sum ( axis = 2 ) . astype ( np . bool )", "docstring_tokens": "Convert RGB arrays from mask canvas object back to boolean mask .", "label": 0}, {"idx": "cosqa-train-6029", "doc": "rotating a matrix in python", "code": "def similarity_transformation(rot, mat):\n    \"\"\" R x M x R^-1 \"\"\"\n    return np.dot(rot, np.dot(mat, np.linalg.inv(rot)))", "code_tokens": "def similarity_transformation ( rot , mat ) : return np . dot ( rot , np . dot ( mat , np . linalg . inv ( rot ) ) )", "docstring_tokens": "R x M x R^ - 1", "label": 1}, {"idx": "cosqa-train-6030", "doc": "python argparse bool without value", "code": "def process_bool_arg(arg):\n    \"\"\" Determine True/False from argument \"\"\"\n    if isinstance(arg, bool):\n        return arg\n    elif isinstance(arg, basestring):\n        if arg.lower() in [\"true\", \"1\"]:\n            return True\n        elif arg.lower() in [\"false\", \"0\"]:\n            return False", "code_tokens": "def process_bool_arg ( arg ) : if isinstance ( arg , bool ) : return arg elif isinstance ( arg , basestring ) : if arg . lower ( ) in [ \"true\" , \"1\" ] : return True elif arg . lower ( ) in [ \"false\" , \"0\" ] : return False", "docstring_tokens": "Determine True / False from argument", "label": 0}, {"idx": "cosqa-train-6031", "doc": "rotation matrix given angle python", "code": "def create_rot2d(angle):\n    \"\"\"Create 2D rotation matrix\"\"\"\n    ca = math.cos(angle)\n    sa = math.sin(angle)\n    return np.array([[ca, -sa], [sa, ca]])", "code_tokens": "def create_rot2d ( angle ) : ca = math . cos ( angle ) sa = math . sin ( angle ) return np . array ( [ [ ca , - sa ] , [ sa , ca ] ] )", "docstring_tokens": "Create 2D rotation matrix", "label": 0}, {"idx": "cosqa-train-6032", "doc": "python argparse check value", "code": "def email_type(arg):\n\t\"\"\"An argparse type representing an email address.\"\"\"\n\tif not is_valid_email_address(arg):\n\t\traise argparse.ArgumentTypeError(\"{0} is not a valid email address\".format(repr(arg)))\n\treturn arg", "code_tokens": "def email_type ( arg ) : if not is_valid_email_address ( arg ) : raise argparse . ArgumentTypeError ( \"{0} is not a valid email address\" . format ( repr ( arg ) ) ) return arg", "docstring_tokens": "An argparse type representing an email address .", "label": 0}, {"idx": "cosqa-train-6033", "doc": "round python int object is not callable", "code": "def floor(self):\n    \"\"\"Round `x` and `y` down to integers.\"\"\"\n    return Point(int(math.floor(self.x)), int(math.floor(self.y)))", "code_tokens": "def floor ( self ) : return Point ( int ( math . floor ( self . x ) ) , int ( math . floor ( self . y ) ) )", "docstring_tokens": "Round x and y down to integers .", "label": 0}, {"idx": "cosqa-train-6034", "doc": "python argparse set usage", "code": "def main(args=sys.argv):\n    \"\"\"\n    main entry point for the jardiff CLI\n    \"\"\"\n\n    parser = create_optparser(args[0])\n    return cli(parser.parse_args(args[1:]))", "code_tokens": "def main ( args = sys . argv ) : parser = create_optparser ( args [ 0 ] ) return cli ( parser . parse_args ( args [ 1 : ] ) )", "docstring_tokens": "main entry point for the jardiff CLI", "label": 0}, {"idx": "cosqa-train-6035", "doc": "round significant figures python", "code": "def round_figures(x, n):\n    \"\"\"Returns x rounded to n significant figures.\"\"\"\n    return round(x, int(n - math.ceil(math.log10(abs(x)))))", "code_tokens": "def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )", "docstring_tokens": "Returns x rounded to n significant figures .", "label": 0}, {"idx": "cosqa-train-6036", "doc": "python argparse subparser handler", "code": "def set_subparsers_args(self, *args, **kwargs):\n        \"\"\"\n        Sets args and kwargs that are passed when creating a subparsers group\n        in an argparse.ArgumentParser i.e. when calling\n        argparser.ArgumentParser.add_subparsers\n        \"\"\"\n        self.subparsers_args = args\n        self.subparsers_kwargs = kwargs", "code_tokens": "def set_subparsers_args ( self , * args , * * kwargs ) : self . subparsers_args = args self . subparsers_kwargs = kwargs", "docstring_tokens": "Sets args and kwargs that are passed when creating a subparsers group in an argparse . ArgumentParser i . e . when calling argparser . ArgumentParser . add_subparsers", "label": 0}, {"idx": "cosqa-train-6037", "doc": "round to two significant figures python", "code": "def round_figures(x, n):\n    \"\"\"Returns x rounded to n significant figures.\"\"\"\n    return round(x, int(n - math.ceil(math.log10(abs(x)))))", "code_tokens": "def round_figures ( x , n ) : return round ( x , int ( n - math . ceil ( math . log10 ( abs ( x ) ) ) ) )", "docstring_tokens": "Returns x rounded to n significant figures .", "label": 0}, {"idx": "cosqa-train-6038", "doc": "python array of all zeros", "code": "def zeros(self, name, **kwargs):\n        \"\"\"Create an array. Keyword arguments as per\n        :func:`zarr.creation.zeros`.\"\"\"\n        return self._write_op(self._zeros_nosync, name, **kwargs)", "code_tokens": "def zeros ( self , name , * * kwargs ) : return self . _write_op ( self . _zeros_nosync , name , * * kwargs )", "docstring_tokens": "Create an array . Keyword arguments as per : func : zarr . creation . zeros .", "label": 0}, {"idx": "cosqa-train-6039", "doc": "run and stop asynchronous function in python", "code": "async def wait_and_quit(loop):\n\t\"\"\"Wait until all task are executed.\"\"\"\n\tfrom pylp.lib.tasks import running\n\tif running:\n\t\tawait asyncio.wait(map(lambda runner: runner.future, running))", "code_tokens": "async def wait_and_quit ( loop ) : from pylp . lib . tasks import running if running : await asyncio . wait ( map ( lambda runner : runner . future , running ) )", "docstring_tokens": "Wait until all task are executed .", "label": 0}, {"idx": "cosqa-train-6040", "doc": "run code line by line in python", "code": "def runcode(code):\n\t\"\"\"Run the given code line by line with printing, as list of lines, and return variable 'ans'.\"\"\"\n\tfor line in code:\n\t\tprint('# '+line)\n\t\texec(line,globals())\n\tprint('# return ans')\n\treturn ans", "code_tokens": "def runcode ( code ) : for line in code : print ( '# ' + line ) exec ( line , globals ( ) ) print ( '# return ans' ) return ans", "docstring_tokens": "Run the given code line by line with printing as list of lines and return variable ans .", "label": 0}, {"idx": "cosqa-train-6041", "doc": "python array to c pointer", "code": "def cint32_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes int pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_int32)):\n        return np.fromiter(cptr, dtype=np.int32, count=length)\n    else:\n        raise RuntimeError('Expected int pointer')", "code_tokens": "def cint32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int32 ) ) : return np . fromiter ( cptr , dtype = np . int32 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "docstring_tokens": "Convert a ctypes int pointer array to a numpy array .", "label": 1}, {"idx": "cosqa-train-6042", "doc": "run pylint for python3", "code": "def lint(ctx: click.Context, amend: bool = False, stage: bool = False):\n    \"\"\"\n    Runs all linters\n\n    Args:\n        ctx: click context\n        amend: whether or not to commit results\n        stage: whether or not to stage changes\n    \"\"\"\n    _lint(ctx, amend, stage)", "code_tokens": "def lint ( ctx : click . Context , amend : bool = False , stage : bool = False ) : _lint ( ctx , amend , stage )", "docstring_tokens": "Runs all linters", "label": 0}, {"idx": "cosqa-train-6043", "doc": "python array to ctype buffer", "code": "def c_array(ctype, values):\n    \"\"\"Convert a python string to c array.\"\"\"\n    if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype):\n        return (ctype * len(values)).from_buffer_copy(values)\n    return (ctype * len(values))(*values)", "code_tokens": "def c_array ( ctype , values ) : if isinstance ( values , np . ndarray ) and values . dtype . itemsize == ctypes . sizeof ( ctype ) : return ( ctype * len ( values ) ) . from_buffer_copy ( values ) return ( ctype * len ( values ) ) ( * values )", "docstring_tokens": "Convert a python string to c array .", "label": 0}, {"idx": "cosqa-train-6044", "doc": "run pylint on cmd python 3", "code": "def lint(ctx: click.Context, amend: bool = False, stage: bool = False):\n    \"\"\"\n    Runs all linters\n\n    Args:\n        ctx: click context\n        amend: whether or not to commit results\n        stage: whether or not to stage changes\n    \"\"\"\n    _lint(ctx, amend, stage)", "code_tokens": "def lint ( ctx : click . Context , amend : bool = False , stage : bool = False ) : _lint ( ctx , amend , stage )", "docstring_tokens": "Runs all linters", "label": 0}, {"idx": "cosqa-train-6045", "doc": "python array triple from to", "code": "def _transform_triple_numpy(x):\n    \"\"\"Transform triple index into a 1-D numpy array.\"\"\"\n    return np.array([x.head, x.relation, x.tail], dtype=np.int64)", "code_tokens": "def _transform_triple_numpy ( x ) : return np . array ( [ x . head , x . relation , x . tail ] , dtype = np . int64 )", "docstring_tokens": "Transform triple index into a 1 - D numpy array .", "label": 0}, {"idx": "cosqa-train-6046", "doc": "saving cookies with python", "code": "def _save_cookies(requests_cookiejar, filename):\n    \"\"\"Save cookies to a file.\"\"\"\n    with open(filename, 'wb') as handle:\n        pickle.dump(requests_cookiejar, handle)", "code_tokens": "def _save_cookies ( requests_cookiejar , filename ) : with open ( filename , 'wb' ) as handle : pickle . dump ( requests_cookiejar , handle )", "docstring_tokens": "Save cookies to a file .", "label": 0}, {"idx": "cosqa-train-6047", "doc": "seconds to minute hours python", "code": "def seconds_to_hms(input_seconds):\n    \"\"\"Convert seconds to human-readable time.\"\"\"\n    minutes, seconds = divmod(input_seconds, 60)\n    hours, minutes = divmod(minutes, 60)\n\n    hours = int(hours)\n    minutes = int(minutes)\n    seconds = str(int(seconds)).zfill(2)\n\n    return hours, minutes, seconds", "code_tokens": "def seconds_to_hms ( input_seconds ) : minutes , seconds = divmod ( input_seconds , 60 ) hours , minutes = divmod ( minutes , 60 ) hours = int ( hours ) minutes = int ( minutes ) seconds = str ( int ( seconds ) ) . zfill ( 2 ) return hours , minutes , seconds", "docstring_tokens": "Convert seconds to human - readable time .", "label": 1}, {"idx": "cosqa-train-6048", "doc": "python assert content of list all identical", "code": "def expect_all(a, b):\n    \"\"\"\\\n    Asserts that two iterables contain the same values.\n    \"\"\"\n    assert all(_a == _b for _a, _b in zip_longest(a, b))", "code_tokens": "def expect_all ( a , b ) : assert all ( _a == _b for _a , _b in zip_longest ( a , b ) )", "docstring_tokens": "\\ Asserts that two iterables contain the same values .", "label": 0}, {"idx": "cosqa-train-6049", "doc": "see point3d obj in python", "code": "def list(self):\n        \"\"\"position in 3d space\"\"\"\n        return [self._pos3d.x, self._pos3d.y, self._pos3d.z]", "code_tokens": "def list ( self ) : return [ self . _pos3d . x , self . _pos3d . y , self . _pos3d . z ]", "docstring_tokens": "position in 3d space", "label": 0}, {"idx": "cosqa-train-6050", "doc": "python ast parse if else", "code": "def p_if_statement_2(self, p):\n        \"\"\"if_statement : IF LPAREN expr RPAREN statement ELSE statement\"\"\"\n        p[0] = ast.If(predicate=p[3], consequent=p[5], alternative=p[7])", "code_tokens": "def p_if_statement_2 ( self , p ) : p [ 0 ] = ast . If ( predicate = p [ 3 ] , consequent = p [ 5 ] , alternative = p [ 7 ] )", "docstring_tokens": "if_statement : IF LPAREN expr RPAREN statement ELSE statement", "label": 0}, {"idx": "cosqa-train-6051", "doc": "select nearest value in list python", "code": "def get_closest_index(myList, myNumber):\n    \"\"\"\n    Assumes myList is sorted. Returns closest value to myNumber.\n    If two numbers are equally close, return the smallest number.\n\n    Parameters\n    ----------\n    myList : array\n        The list in which to find the closest value to myNumber\n    myNumber : float\n        The number to find the closest to in MyList\n\n    Returns\n    -------\n    closest_values_index : int\n        The index in the array of the number closest to myNumber in myList\n    \"\"\"\n    closest_values_index = _np.where(self.time == take_closest(myList, myNumber))[0][0]\n    return closest_values_index", "code_tokens": "def get_closest_index ( myList , myNumber ) : closest_values_index = _np . where ( self . time == take_closest ( myList , myNumber ) ) [ 0 ] [ 0 ] return closest_values_index", "docstring_tokens": "Assumes myList is sorted . Returns closest value to myNumber . If two numbers are equally close return the smallest number .", "label": 1}, {"idx": "cosqa-train-6052", "doc": "python astropy table adding values", "code": "def update_table_row(self, table, row_idx):\n        \"\"\"Add this instance as a row on a `astropy.table.Table` \"\"\"\n        try:\n            table[row_idx]['timestamp'] = self.timestamp\n            table[row_idx]['status'] = self.status\n        except IndexError:\n            print(\"Index error\", len(table), row_idx)", "code_tokens": "def update_table_row ( self , table , row_idx ) : try : table [ row_idx ] [ 'timestamp' ] = self . timestamp table [ row_idx ] [ 'status' ] = self . status except IndexError : print ( \"Index error\" , len ( table ) , row_idx )", "docstring_tokens": "Add this instance as a row on a astropy . table . Table", "label": 0}, {"idx": "cosqa-train-6053", "doc": "select rows of data frame with null values python", "code": "def dropna(self, subset=None):\n        \"\"\"Remove missing values according to Baloo's convention.\n\n        Parameters\n        ----------\n        subset : list of str, optional\n            Which columns to check for missing values in.\n\n        Returns\n        -------\n        DataFrame\n            DataFrame with no null values in columns.\n\n        \"\"\"\n        subset = check_and_obtain_subset_columns(subset, self)\n        not_nas = [v.notna() for v in self[subset]._iter()]\n        and_filter = reduce(lambda x, y: x & y, not_nas)\n\n        return self[and_filter]", "code_tokens": "def dropna ( self , subset = None ) : subset = check_and_obtain_subset_columns ( subset , self ) not_nas = [ v . notna ( ) for v in self [ subset ] . _iter ( ) ] and_filter = reduce ( lambda x , y : x & y , not_nas ) return self [ and_filter ]", "docstring_tokens": "Remove missing values according to Baloo s convention .", "label": 0}, {"idx": "cosqa-train-6054", "doc": "python async object method call", "code": "async def _thread_coro(self, *args):\n        \"\"\" Coroutine called by MapAsync. It's wrapping the call of\n        run_in_executor to run the synchronous function as thread \"\"\"\n        return await self._loop.run_in_executor(\n            self._executor, self._function, *args)", "code_tokens": "async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "docstring_tokens": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread", "label": 0}, {"idx": "cosqa-train-6055", "doc": "selecting specific columns from a fits file in python", "code": "def create_table_from_fits(fitsfile, hduname, colnames=None):\n    \"\"\"Memory efficient function for loading a table from a FITS\n    file.\"\"\"\n\n    if colnames is None:\n        return Table.read(fitsfile, hduname)\n\n    cols = []\n    with fits.open(fitsfile, memmap=True) as h:\n        for k in colnames:\n            data = h[hduname].data.field(k)\n            cols += [Column(name=k, data=data)]\n    return Table(cols)", "code_tokens": "def create_table_from_fits ( fitsfile , hduname , colnames = None ) : if colnames is None : return Table . read ( fitsfile , hduname ) cols = [ ] with fits . open ( fitsfile , memmap = True ) as h : for k in colnames : data = h [ hduname ] . data . field ( k ) cols += [ Column ( name = k , data = data ) ] return Table ( cols )", "docstring_tokens": "Memory efficient function for loading a table from a FITS file .", "label": 0}, {"idx": "cosqa-train-6056", "doc": "python asynchronous function call return", "code": "def asynchronous(function, event):\n    \"\"\"\n    Runs the function asynchronously taking care of exceptions.\n    \"\"\"\n    thread = Thread(target=synchronous, args=(function, event))\n    thread.daemon = True\n    thread.start()", "code_tokens": "def asynchronous ( function , event ) : thread = Thread ( target = synchronous , args = ( function , event ) ) thread . daemon = True thread . start ( )", "docstring_tokens": "Runs the function asynchronously taking care of exceptions .", "label": 1}, {"idx": "cosqa-train-6057", "doc": "selenim python assert element exists", "code": "def check_no_element_by_selector(self, selector):\n    \"\"\"Assert an element does not exist matching the given selector.\"\"\"\n    elems = find_elements_by_jquery(world.browser, selector)\n    if elems:\n        raise AssertionError(\"Expected no matching elements, found {}.\".format(\n            len(elems)))", "code_tokens": "def check_no_element_by_selector ( self , selector ) : elems = find_elements_by_jquery ( world . browser , selector ) if elems : raise AssertionError ( \"Expected no matching elements, found {}.\" . format ( len ( elems ) ) )", "docstring_tokens": "Assert an element does not exist matching the given selector .", "label": 0}, {"idx": "cosqa-train-6058", "doc": "python asyncio async processpool async map", "code": "async def _thread_coro(self, *args):\n        \"\"\" Coroutine called by MapAsync. It's wrapping the call of\n        run_in_executor to run the synchronous function as thread \"\"\"\n        return await self._loop.run_in_executor(\n            self._executor, self._function, *args)", "code_tokens": "async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "docstring_tokens": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread", "label": 0}, {"idx": "cosqa-train-6059", "doc": "sending url in post for api in python", "code": "def POST(self, *args, **kwargs):\n        \"\"\" POST request \"\"\"\n        return self._handle_api(self.API_POST, args, kwargs)", "code_tokens": "def POST ( self , * args , * * kwargs ) : return self . _handle_api ( self . API_POST , args , kwargs )", "docstring_tokens": "POST request", "label": 0}, {"idx": "cosqa-train-6060", "doc": "python asyncio dynamically add tasks to event loop", "code": "def run(*tasks: Awaitable, loop: asyncio.AbstractEventLoop=asyncio.get_event_loop()):\n    \"\"\"Helper to run tasks in the event loop\n\n    :param tasks: Tasks to run in the event loop.\n    :param loop: The event loop.\n    \"\"\"\n    futures = [asyncio.ensure_future(task, loop=loop) for task in tasks]\n    return loop.run_until_complete(asyncio.gather(*futures))", "code_tokens": "def run ( * tasks : Awaitable , loop : asyncio . AbstractEventLoop = asyncio . get_event_loop ( ) ) : futures = [ asyncio . ensure_future ( task , loop = loop ) for task in tasks ] return loop . run_until_complete ( asyncio . gather ( * futures ) )", "docstring_tokens": "Helper to run tasks in the event loop", "label": 1}, {"idx": "cosqa-train-6061", "doc": "sent urlencoded payload in python", "code": "def urlencoded(body, charset='ascii', **kwargs):\n    \"\"\"Converts query strings into native Python objects\"\"\"\n    return parse_query_string(text(body, charset=charset), False)", "code_tokens": "def urlencoded ( body , charset = 'ascii' , * * kwargs ) : return parse_query_string ( text ( body , charset = charset ) , False )", "docstring_tokens": "Converts query strings into native Python objects", "label": 1}, {"idx": "cosqa-train-6062", "doc": "python asyncio signal exit", "code": "def shutdown():\n    \"\"\"Manually shutdown the async API.\n\n    Cancels all related tasks and all the socket transportation.\n    \"\"\"\n    global handler, transport, protocol\n    if handler is not None:\n        handler.close()\n        transport.close()\n        handler = None\n        transport = None\n        protocol = None", "code_tokens": "def shutdown ( ) : global handler , transport , protocol if handler is not None : handler . close ( ) transport . close ( ) handler = None transport = None protocol = None", "docstring_tokens": "Manually shutdown the async API .", "label": 0}, {"idx": "cosqa-train-6063", "doc": "set attribute on an object python", "code": "def setobjattr(obj, key, value):\n    \"\"\"Sets an object attribute with the correct data type.\"\"\"\n    try:\n        setattr(obj, key, int(value))\n    except ValueError:\n        try:\n            setattr(obj, key, float(value))\n        except ValueError:\n            # string if not number\n            try:\n                setattr(obj, key, str(value))\n            except UnicodeEncodeError:\n                setattr(obj, key, value)", "code_tokens": "def setobjattr ( obj , key , value ) : try : setattr ( obj , key , int ( value ) ) except ValueError : try : setattr ( obj , key , float ( value ) ) except ValueError : # string if not number try : setattr ( obj , key , str ( value ) ) except UnicodeEncodeError : setattr ( obj , key , value )", "docstring_tokens": "Sets an object attribute with the correct data type .", "label": 0}, {"idx": "cosqa-train-6064", "doc": "python auto exit thread on exit", "code": "def exit(exit_code=0):\n  r\"\"\"A function to support exiting from exit hooks.\n\n  Could also be used to exit from the calling scripts in a thread safe manner.\n  \"\"\"\n  core.processExitHooks()\n\n  if state.isExitHooked and not hasattr(sys, 'exitfunc'): # The function is called from the exit hook\n    sys.stderr.flush()\n    sys.stdout.flush()\n    os._exit(exit_code) #pylint: disable=W0212\n\n  sys.exit(exit_code)", "code_tokens": "def exit ( exit_code = 0 ) : core . processExitHooks ( ) if state . isExitHooked and not hasattr ( sys , 'exitfunc' ) : # The function is called from the exit hook sys . stderr . flush ( ) sys . stdout . flush ( ) os . _exit ( exit_code ) #pylint: disable=W0212 sys . exit ( exit_code )", "docstring_tokens": "r A function to support exiting from exit hooks .", "label": 0}, {"idx": "cosqa-train-6065", "doc": "set color message wxpython", "code": "def _update_fontcolor(self, fontcolor):\n        \"\"\"Updates text font color button\n\n        Parameters\n        ----------\n\n        fontcolor: Integer\n        \\tText color in integer RGB format\n\n        \"\"\"\n\n        textcolor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)\n        textcolor.SetRGB(fontcolor)\n\n        self.textcolor_choice.SetColour(textcolor)", "code_tokens": "def _update_fontcolor ( self , fontcolor ) : textcolor = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_WINDOWTEXT ) textcolor . SetRGB ( fontcolor ) self . textcolor_choice . SetColour ( textcolor )", "docstring_tokens": "Updates text font color button", "label": 1}, {"idx": "cosqa-train-6066", "doc": "python auto populating a pdf", "code": "def _single_page_pdf(page):\n    \"\"\"Construct a single page PDF from the provided page in memory\"\"\"\n    pdf = Pdf.new()\n    pdf.pages.append(page)\n    bio = BytesIO()\n    pdf.save(bio)\n    bio.seek(0)\n    return bio.read()", "code_tokens": "def _single_page_pdf ( page ) : pdf = Pdf . new ( ) pdf . pages . append ( page ) bio = BytesIO ( ) pdf . save ( bio ) bio . seek ( 0 ) return bio . read ( )", "docstring_tokens": "Construct a single page PDF from the provided page in memory", "label": 0}, {"idx": "cosqa-train-6067", "doc": "set every cell in matrix to 0 if that row or column contains a 0 python", "code": "def check_precomputed_distance_matrix(X):\n    \"\"\"Perform check_array(X) after removing infinite values (numpy.inf) from the given distance matrix.\n    \"\"\"\n    tmp = X.copy()\n    tmp[np.isinf(tmp)] = 1\n    check_array(tmp)", "code_tokens": "def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "docstring_tokens": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix .", "label": 1}, {"idx": "cosqa-train-6068", "doc": "python autoformat axis labels", "code": "def dim_axis_label(dimensions, separator=', '):\n    \"\"\"\n    Returns an axis label for one or more dimensions.\n    \"\"\"\n    if not isinstance(dimensions, list): dimensions = [dimensions]\n    return separator.join([d.pprint_label for d in dimensions])", "code_tokens": "def dim_axis_label ( dimensions , separator = ', ' ) : if not isinstance ( dimensions , list ) : dimensions = [ dimensions ] return separator . join ( [ d . pprint_label for d in dimensions ] )", "docstring_tokens": "Returns an axis label for one or more dimensions .", "label": 0}, {"idx": "cosqa-train-6069", "doc": "set pixel color python", "code": "def setPixel(self, x, y, color):\n        \"\"\"Set the pixel at (x,y) to the integers in sequence 'color'.\"\"\"\n        return _fitz.Pixmap_setPixel(self, x, y, color)", "code_tokens": "def setPixel ( self , x , y , color ) : return _fitz . Pixmap_setPixel ( self , x , y , color )", "docstring_tokens": "Set the pixel at ( x y ) to the integers in sequence color .", "label": 1}, {"idx": "cosqa-train-6070", "doc": "python automatic figure out encoding", "code": "def get_best_encoding(stream):\n    \"\"\"Returns the default stream encoding if not found.\"\"\"\n    rv = getattr(stream, 'encoding', None) or sys.getdefaultencoding()\n    if is_ascii_encoding(rv):\n        return 'utf-8'\n    return rv", "code_tokens": "def get_best_encoding ( stream ) : rv = getattr ( stream , 'encoding' , None ) or sys . getdefaultencoding ( ) if is_ascii_encoding ( rv ) : return 'utf-8' return rv", "docstring_tokens": "Returns the default stream encoding if not found .", "label": 0}, {"idx": "cosqa-train-6071", "doc": "set python colorbar length to half", "code": "def palettebar(height, length, colormap):\n    \"\"\"Return the channels of a palettebar.\n    \"\"\"\n    cbar = np.tile(np.arange(length) * 1.0 / (length - 1), (height, 1))\n    cbar = (cbar * (colormap.values.max() + 1 - colormap.values.min())\n            + colormap.values.min())\n\n    return colormap.palettize(cbar)", "code_tokens": "def palettebar ( height , length , colormap ) : cbar = np . tile ( np . arange ( length ) * 1.0 / ( length - 1 ) , ( height , 1 ) ) cbar = ( cbar * ( colormap . values . max ( ) + 1 - colormap . values . min ( ) ) + colormap . values . min ( ) ) return colormap . palettize ( cbar )", "docstring_tokens": "Return the channels of a palettebar .", "label": 0}, {"idx": "cosqa-train-6072", "doc": "python avoid file permission denied", "code": "def make_file_read_only(file_path):\n    \"\"\"\n    Removes the write permissions for the given file for owner, groups and others.\n\n    :param file_path: The file whose privileges are revoked.\n    :raise FileNotFoundError: If the given file does not exist.\n    \"\"\"\n    old_permissions = os.stat(file_path).st_mode\n    os.chmod(file_path, old_permissions & ~WRITE_PERMISSIONS)", "code_tokens": "def make_file_read_only ( file_path ) : old_permissions = os . stat ( file_path ) . st_mode os . chmod ( file_path , old_permissions & ~ WRITE_PERMISSIONS )", "docstring_tokens": "Removes the write permissions for the given file for owner groups and others .", "label": 0}, {"idx": "cosqa-train-6073", "doc": "set window position in python", "code": "def OnMove(self, event):\n        \"\"\"Main window move event\"\"\"\n\n        # Store window position in config\n        position = self.main_window.GetScreenPositionTuple()\n\n        config[\"window_position\"] = repr(position)", "code_tokens": "def OnMove ( self , event ) : # Store window position in config position = self . main_window . GetScreenPositionTuple ( ) config [ \"window_position\" ] = repr ( position )", "docstring_tokens": "Main window move event", "label": 0}, {"idx": "cosqa-train-6074", "doc": "python bad pixel replacement", "code": "def inpaint(self):\n        \"\"\" Replace masked-out elements in an array using an iterative image inpainting algorithm. \"\"\"\n\n        import inpaint\n        filled = inpaint.replace_nans(np.ma.filled(self.raster_data, np.NAN).astype(np.float32), 3, 0.01, 2)\n        self.raster_data = np.ma.masked_invalid(filled)", "code_tokens": "def inpaint ( self ) : import inpaint filled = inpaint . replace_nans ( np . ma . filled ( self . raster_data , np . NAN ) . astype ( np . float32 ) , 3 , 0.01 , 2 ) self . raster_data = np . ma . masked_invalid ( filled )", "docstring_tokens": "Replace masked - out elements in an array using an iterative image inpainting algorithm .", "label": 0}, {"idx": "cosqa-train-6075", "doc": "setting a pointer at end of file in python", "code": "def writefile(openedfile, newcontents):\n    \"\"\"Set the contents of a file.\"\"\"\n    openedfile.seek(0)\n    openedfile.truncate()\n    openedfile.write(newcontents)", "code_tokens": "def writefile ( openedfile , newcontents ) : openedfile . seek ( 0 ) openedfile . truncate ( ) openedfile . write ( newcontents )", "docstring_tokens": "Set the contents of a file .", "label": 0}, {"idx": "cosqa-train-6076", "doc": "python base64 image string to image write to file", "code": "def base64ToImage(imgData, out_path, out_file):\n        \"\"\" converts a base64 string to a file \"\"\"\n        fh = open(os.path.join(out_path, out_file), \"wb\")\n        fh.write(imgData.decode('base64'))\n        fh.close()\n        del fh\n        return os.path.join(out_path, out_file)", "code_tokens": "def base64ToImage ( imgData , out_path , out_file ) : fh = open ( os . path . join ( out_path , out_file ) , \"wb\" ) fh . write ( imgData . decode ( 'base64' ) ) fh . close ( ) del fh return os . path . join ( out_path , out_file )", "docstring_tokens": "converts a base64 string to a file", "label": 0}, {"idx": "cosqa-train-6077", "doc": "setting proxy code in python", "code": "def enable_proxy(self, host, port):\n        \"\"\"Enable a default web proxy\"\"\"\n\n        self.proxy = [host, _number(port)]\n        self.proxy_enabled = True", "code_tokens": "def enable_proxy ( self , host , port ) : self . proxy = [ host , _number ( port ) ] self . proxy_enabled = True", "docstring_tokens": "Enable a default web proxy", "label": 0}, {"idx": "cosqa-train-6078", "doc": "setting up sympy in python", "code": "def make_qs(n, m=None):\n    \"\"\"Make sympy symbols q0, q1, ...\n    \n    Args:\n        n(int), m(int, optional):\n            If specified both n and m, returns [qn, q(n+1), ..., qm],\n            Only n is specified, returns[q0, q1, ..., qn].\n\n    Return:\n        tuple(Symbol): Tuple of sympy symbols.\n    \"\"\"\n    try:\n        import sympy\n    except ImportError:\n        raise ImportError(\"This function requires sympy. Please install it.\")\n    if m is None:\n        syms = sympy.symbols(\" \".join(f\"q{i}\" for i in range(n)))\n        if isinstance(syms, tuple):\n            return syms\n        else:\n            return (syms,)\n    syms = sympy.symbols(\" \".join(f\"q{i}\" for i in range(n, m)))\n    if isinstance(syms, tuple):\n        return syms\n    else:\n        return (syms,)", "code_tokens": "def make_qs ( n , m = None ) : try : import sympy except ImportError : raise ImportError ( \"This function requires sympy. Please install it.\" ) if m is None : syms = sympy . symbols ( \" \" . join ( f\"q{i}\" for i in range ( n ) ) ) if isinstance ( syms , tuple ) : return syms else : return ( syms , ) syms = sympy . symbols ( \" \" . join ( f\"q{i}\" for i in range ( n , m ) ) ) if isinstance ( syms , tuple ) : return syms else : return ( syms , )", "docstring_tokens": "Make sympy symbols q0 q1 ... Args : n ( int ) m ( int optional ) : If specified both n and m returns [ qn q ( n + 1 ) ... qm ] Only n is specified returns [ q0 q1 ... qn ] .", "label": 0}, {"idx": "cosqa-train-6079", "doc": "python base64 without special symbol", "code": "def toBase64(s):\n    \"\"\"Represent string / bytes s as base64, omitting newlines\"\"\"\n    if isinstance(s, str):\n        s = s.encode(\"utf-8\")\n    return binascii.b2a_base64(s)[:-1]", "code_tokens": "def toBase64 ( s ) : if isinstance ( s , str ) : s = s . encode ( \"utf-8\" ) return binascii . b2a_base64 ( s ) [ : - 1 ]", "docstring_tokens": "Represent string / bytes s as base64 omitting newlines", "label": 0}, {"idx": "cosqa-train-6080", "doc": "setting variable in jinja python flask", "code": "def render_template(env, filename, values=None):\n    \"\"\"\n    Render a jinja template\n    \"\"\"\n    if not values:\n        values = {}\n    tmpl = env.get_template(filename)\n    return tmpl.render(values)", "code_tokens": "def render_template ( env , filename , values = None ) : if not values : values = { } tmpl = env . get_template ( filename ) return tmpl . render ( values )", "docstring_tokens": "Render a jinja template", "label": 1}, {"idx": "cosqa-train-6081", "doc": "python best way to scroll a canvas in tkinter", "code": "def _set_scroll_v(self, *args):\n        \"\"\"Scroll both categories Canvas and scrolling container\"\"\"\n        self._canvas_categories.yview(*args)\n        self._canvas_scroll.yview(*args)", "code_tokens": "def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "docstring_tokens": "Scroll both categories Canvas and scrolling container", "label": 0}, {"idx": "cosqa-train-6082", "doc": "setting x axis to time python imshow", "code": "def update(self):\n        \"\"\"Updates image to be displayed with new time frame.\"\"\"\n        if self.single_channel:\n            self.im.set_data(self.data[self.ind, :, :])\n        else:\n            self.im.set_data(self.data[self.ind, :, :, :])\n        self.ax.set_ylabel('time frame %s' % self.ind)\n        self.im.axes.figure.canvas.draw()", "code_tokens": "def update ( self ) : if self . single_channel : self . im . set_data ( self . data [ self . ind , : , : ] ) else : self . im . set_data ( self . data [ self . ind , : , : , : ] ) self . ax . set_ylabel ( 'time frame %s' % self . ind ) self . im . axes . figure . canvas . draw ( )", "docstring_tokens": "Updates image to be displayed with new time frame .", "label": 0}, {"idx": "cosqa-train-6083", "doc": "python bianry tree get parent node", "code": "def root_parent(self, category=None):\n        \"\"\" Returns the topmost parent of the current category. \"\"\"\n        return next(filter(lambda c: c.is_root, self.hierarchy()))", "code_tokens": "def root_parent ( self , category = None ) : return next ( filter ( lambda c : c . is_root , self . hierarchy ( ) ) )", "docstring_tokens": "Returns the topmost parent of the current category .", "label": 0}, {"idx": "cosqa-train-6084", "doc": "shortcut for multiple comments in python", "code": "def comments(tag, limit=0, flags=0, **kwargs):\n    \"\"\"Get comments only.\"\"\"\n\n    return [comment for comment in cm.CommentsMatch(tag).get_comments(limit)]", "code_tokens": "def comments ( tag , limit = 0 , flags = 0 , * * kwargs ) : return [ comment for comment in cm . CommentsMatch ( tag ) . get_comments ( limit ) ]", "docstring_tokens": "Get comments only .", "label": 0}, {"idx": "cosqa-train-6085", "doc": "python binary true false as image", "code": "def abs_img(img):\n    \"\"\" Return an image with the binarised version of the data of `img`.\"\"\"\n    bool_img = np.abs(read_img(img).get_data())\n    return bool_img.astype(int)", "code_tokens": "def abs_img ( img ) : bool_img = np . abs ( read_img ( img ) . get_data ( ) ) return bool_img . astype ( int )", "docstring_tokens": "Return an image with the binarised version of the data of img .", "label": 0}, {"idx": "cosqa-train-6086", "doc": "shortcuts to check for attribute eroor python", "code": "def safe_setattr(obj, name, value):\n    \"\"\"Attempt to setattr but catch AttributeErrors.\"\"\"\n    try:\n        setattr(obj, name, value)\n        return True\n    except AttributeError:\n        return False", "code_tokens": "def safe_setattr ( obj , name , value ) : try : setattr ( obj , name , value ) return True except AttributeError : return False", "docstring_tokens": "Attempt to setattr but catch AttributeErrors .", "label": 0}, {"idx": "cosqa-train-6087", "doc": "python bind to processor", "code": "def main(ctx, connection):\n    \"\"\"Command line interface for PyBEL.\"\"\"\n    ctx.obj = Manager(connection=connection)\n    ctx.obj.bind()", "code_tokens": "def main ( ctx , connection ) : ctx . obj = Manager ( connection = connection ) ctx . obj . bind ( )", "docstring_tokens": "Command line interface for PyBEL .", "label": 0}, {"idx": "cosqa-train-6088", "doc": "show head of table python", "code": "def top(n, width=WIDTH, style=STYLE):\n    \"\"\"Prints the top row of a table\"\"\"\n    return hrule(n, width, linestyle=STYLES[style].top)", "code_tokens": "def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )", "docstring_tokens": "Prints the top row of a table", "label": 0}, {"idx": "cosqa-train-6089", "doc": "python bool parse from string", "code": "def FromString(self, string):\n    \"\"\"Parse a bool from a string.\"\"\"\n    if string.lower() in (\"false\", \"no\", \"n\"):\n      return False\n\n    if string.lower() in (\"true\", \"yes\", \"y\"):\n      return True\n\n    raise TypeValueError(\"%s is not recognized as a boolean value.\" % string)", "code_tokens": "def FromString ( self , string ) : if string . lower ( ) in ( \"false\" , \"no\" , \"n\" ) : return False if string . lower ( ) in ( \"true\" , \"yes\" , \"y\" ) : return True raise TypeValueError ( \"%s is not recognized as a boolean value.\" % string )", "docstring_tokens": "Parse a bool from a string .", "label": 0}, {"idx": "cosqa-train-6090", "doc": "signed angle between two vectors python", "code": "def smallest_signed_angle(source, target):\n    \"\"\"Find the smallest angle going from angle `source` to angle `target`.\"\"\"\n    dth = target - source\n    dth = (dth + np.pi) % (2.0 * np.pi) - np.pi\n    return dth", "code_tokens": "def smallest_signed_angle ( source , target ) : dth = target - source dth = ( dth + np . pi ) % ( 2.0 * np . pi ) - np . pi return dth", "docstring_tokens": "Find the smallest angle going from angle source to angle target .", "label": 0}, {"idx": "cosqa-train-6091", "doc": "python boolean condition for numpy matrix", "code": "def is_bool_matrix(l):\n    r\"\"\"Checks if l is a 2D numpy array of bools\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 2 and (l.dtype == bool):\n            return True\n    return False", "code_tokens": "def is_bool_matrix ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 2 and ( l . dtype == bool ) : return True return False", "docstring_tokens": "r Checks if l is a 2D numpy array of bools", "label": 1}, {"idx": "cosqa-train-6092", "doc": "simple dialog box to reshow after incorrect value python", "code": "def close_error_dlg(self):\n        \"\"\"Close error dialog.\"\"\"\n        if self.error_dlg.dismiss_box.isChecked():\n            self.dismiss_error = True\n        self.error_dlg.reject()", "code_tokens": "def close_error_dlg ( self ) : if self . error_dlg . dismiss_box . isChecked ( ) : self . dismiss_error = True self . error_dlg . reject ( )", "docstring_tokens": "Close error dialog .", "label": 0}, {"idx": "cosqa-train-6093", "doc": "python boolean function definition", "code": "def isbinary(*args):\n    \"\"\"Checks if value can be part of binary/bitwise operations.\"\"\"\n    return all(map(lambda c: isnumber(c) or isbool(c), args))", "code_tokens": "def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )", "docstring_tokens": "Checks if value can be part of binary / bitwise operations .", "label": 0}, {"idx": "cosqa-train-6094", "doc": "simplehttpserver python log raw request", "code": "def log_request(self, code='-', size='-'):\n        \"\"\"Selectively log an accepted request.\"\"\"\n\n        if self.server.logRequests:\n            BaseHTTPServer.BaseHTTPRequestHandler.log_request(self, code, size)", "code_tokens": "def log_request ( self , code = '-' , size = '-' ) : if self . server . logRequests : BaseHTTPServer . BaseHTTPRequestHandler . log_request ( self , code , size )", "docstring_tokens": "Selectively log an accepted request .", "label": 1}, {"idx": "cosqa-train-6095", "doc": "python boto3 ec2 security groups filter", "code": "def list_autoscaling_group(region, filter_by_kwargs):\n    \"\"\"List all Auto Scaling Groups.\"\"\"\n    conn = boto.ec2.autoscale.connect_to_region(region)\n    groups = conn.get_all_groups()\n    return lookup(groups, filter_by=filter_by_kwargs)", "code_tokens": "def list_autoscaling_group ( region , filter_by_kwargs ) : conn = boto . ec2 . autoscale . connect_to_region ( region ) groups = conn . get_all_groups ( ) return lookup ( groups , filter_by = filter_by_kwargs )", "docstring_tokens": "List all Auto Scaling Groups .", "label": 0}, {"idx": "cosqa-train-6096", "doc": "simulating log normal distribution python", "code": "def glog(x,l = 2):\n    \"\"\"\n    Generalised logarithm\n\n    :param x: number\n    :param p: number added befor logarithm \n\n    \"\"\"\n    return np.log((x+np.sqrt(x**2+l**2))/2)/np.log(l)", "code_tokens": "def glog ( x , l = 2 ) : return np . log ( ( x + np . sqrt ( x ** 2 + l ** 2 ) ) / 2 ) / np . log ( l )", "docstring_tokens": "Generalised logarithm", "label": 0}, {"idx": "cosqa-train-6097", "doc": "size of axis numpy python", "code": "def array_size(x, axis):\n  \"\"\"Calculate the size of `x` along `axis` dimensions only.\"\"\"\n  axis_shape = x.shape if axis is None else tuple(x.shape[a] for a in axis)\n  return max(numpy.prod(axis_shape), 1)", "code_tokens": "def array_size ( x , axis ) : axis_shape = x . shape if axis is None else tuple ( x . shape [ a ] for a in axis ) return max ( numpy . prod ( axis_shape ) , 1 )", "docstring_tokens": "Calculate the size of x along axis dimensions only .", "label": 1}, {"idx": "cosqa-train-6098", "doc": "python break a list into smaller batches", "code": "def batch(items, size):\n    \"\"\"Batches a list into a list of lists, with sub-lists sized by a specified\n    batch size.\"\"\"\n    return [items[x:x + size] for x in xrange(0, len(items), size)]", "code_tokens": "def batch ( items , size ) : return [ items [ x : x + size ] for x in xrange ( 0 , len ( items ) , size ) ]", "docstring_tokens": "Batches a list into a list of lists with sub - lists sized by a specified batch size .", "label": 0}, {"idx": "cosqa-train-6099", "doc": "size of list object in python", "code": "def __len__(self):\n        \"\"\"Return total data length of the list and its headers.\"\"\"\n        return self.chunk_length() + len(self.type) + len(self.header) + 4", "code_tokens": "def __len__ ( self ) : return self . chunk_length ( ) + len ( self . type ) + len ( self . header ) + 4", "docstring_tokens": "Return total data length of the list and its headers .", "label": 0}, {"idx": "cosqa-train-6100", "doc": "python break up a string into dictionaries", "code": "def string_to_identity(identity_str):\n    \"\"\"Parse string into Identity dictionary.\"\"\"\n    m = _identity_regexp.match(identity_str)\n    result = m.groupdict()\n    log.debug('parsed identity: %s', result)\n    return {k: v for k, v in result.items() if v}", "code_tokens": "def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }", "docstring_tokens": "Parse string into Identity dictionary .", "label": 0}, {"idx": "cosqa-train-6101", "doc": "size of the list in python", "code": "def __len__(self):\n        \"\"\"Return total data length of the list and its headers.\"\"\"\n        return self.chunk_length() + len(self.type) + len(self.header) + 4", "code_tokens": "def __len__ ( self ) : return self . chunk_length ( ) + len ( self . type ) + len ( self . header ) + 4", "docstring_tokens": "Return total data length of the list and its headers .", "label": 0}, {"idx": "cosqa-train-6102", "doc": "python btypes to string", "code": "def _to_bstr(l):\n    \"\"\"Convert to byte string.\"\"\"\n\n    if isinstance(l, str):\n        l = l.encode('ascii', 'backslashreplace')\n    elif not isinstance(l, bytes):\n        l = str(l).encode('ascii', 'backslashreplace')\n    return l", "code_tokens": "def _to_bstr ( l ) : if isinstance ( l , str ) : l = l . encode ( 'ascii' , 'backslashreplace' ) elif not isinstance ( l , bytes ) : l = str ( l ) . encode ( 'ascii' , 'backslashreplace' ) return l", "docstring_tokens": "Convert to byte string .", "label": 0}, {"idx": "cosqa-train-6103", "doc": "slice every 5 items python", "code": "def batch(input_iter, batch_size=32):\n  \"\"\"Batches data from an iterator that returns single items at a time.\"\"\"\n  input_iter = iter(input_iter)\n  next_ = list(itertools.islice(input_iter, batch_size))\n  while next_:\n    yield next_\n    next_ = list(itertools.islice(input_iter, batch_size))", "code_tokens": "def batch ( input_iter , batch_size = 32 ) : input_iter = iter ( input_iter ) next_ = list ( itertools . islice ( input_iter , batch_size ) ) while next_ : yield next_ next_ = list ( itertools . islice ( input_iter , batch_size ) )", "docstring_tokens": "Batches data from an iterator that returns single items at a time .", "label": 0}, {"idx": "cosqa-train-6104", "doc": "python byte array memory size", "code": "def array_bytes(array):\n    \"\"\" Estimates the memory of the supplied array in bytes \"\"\"\n    return np.product(array.shape)*np.dtype(array.dtype).itemsize", "code_tokens": "def array_bytes ( array ) : return np . product ( array . shape ) * np . dtype ( array . dtype ) . itemsize", "docstring_tokens": "Estimates the memory of the supplied array in bytes", "label": 1}, {"idx": "cosqa-train-6105", "doc": "smallest number repeating k times in python", "code": "def n_choose_k(n, k):\n    \"\"\" get the number of quartets as n-choose-k. This is used\n    in equal splits to decide whether a split should be exhaustively sampled\n    or randomly sampled. Edges near tips can be exhaustive while highly nested\n    edges probably have too many quartets\n    \"\"\"\n    return int(reduce(MUL, (Fraction(n-i, i+1) for i in range(k)), 1))", "code_tokens": "def n_choose_k ( n , k ) : return int ( reduce ( MUL , ( Fraction ( n - i , i + 1 ) for i in range ( k ) ) , 1 ) )", "docstring_tokens": "get the number of quartets as n - choose - k . This is used in equal splits to decide whether a split should be exhaustively sampled or randomly sampled . Edges near tips can be exhaustive while highly nested edges probably have too many quartets", "label": 0}, {"idx": "cosqa-train-6106", "doc": "python byte to string b", "code": "def _to_bstr(l):\n    \"\"\"Convert to byte string.\"\"\"\n\n    if isinstance(l, str):\n        l = l.encode('ascii', 'backslashreplace')\n    elif not isinstance(l, bytes):\n        l = str(l).encode('ascii', 'backslashreplace')\n    return l", "code_tokens": "def _to_bstr ( l ) : if isinstance ( l , str ) : l = l . encode ( 'ascii' , 'backslashreplace' ) elif not isinstance ( l , bytes ) : l = str ( l ) . encode ( 'ascii' , 'backslashreplace' ) return l", "docstring_tokens": "Convert to byte string .", "label": 1}, {"idx": "cosqa-train-6107", "doc": "smart way to do percentage python", "code": "def ratio_and_percentage(current, total, time_remaining):\n    \"\"\"Returns the progress ratio and percentage.\"\"\"\n    return \"{} / {} ({}% completed)\".format(current, total, int(current / total * 100))", "code_tokens": "def ratio_and_percentage ( current , total , time_remaining ) : return \"{} / {} ({}% completed)\" . format ( current , total , int ( current / total * 100 ) )", "docstring_tokens": "Returns the progress ratio and percentage .", "label": 1}, {"idx": "cosqa-train-6108", "doc": "python c extern char array", "code": "def bytes_to_c_array(data):\n    \"\"\"\n    Make a C array using the given string.\n    \"\"\"\n    chars = [\n        \"'{}'\".format(encode_escape(i))\n        for i in decode_escape(data)\n    ]\n    return ', '.join(chars) + ', 0'", "code_tokens": "def bytes_to_c_array ( data ) : chars = [ \"'{}'\" . format ( encode_escape ( i ) ) for i in decode_escape ( data ) ] return ', ' . join ( chars ) + ', 0'", "docstring_tokens": "Make a C array using the given string .", "label": 0}, {"idx": "cosqa-train-6109", "doc": "solve a matrix python", "code": "def MatrixSolve(a, rhs, adj):\n    \"\"\"\n    Matrix solve op.\n    \"\"\"\n    return np.linalg.solve(a if not adj else _adjoint(a), rhs),", "code_tokens": "def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,", "docstring_tokens": "Matrix solve op .", "label": 0}, {"idx": "cosqa-train-6110", "doc": "python c++ dependency visualization", "code": "def cpp_prog_builder(build_context, target):\n    \"\"\"Build a C++ binary executable\"\"\"\n    yprint(build_context.conf, 'Build CppProg', target)\n    workspace_dir = build_context.get_workspace('CppProg', target.name)\n    build_cpp(build_context, target, target.compiler_config, workspace_dir)", "code_tokens": "def cpp_prog_builder ( build_context , target ) : yprint ( build_context . conf , 'Build CppProg' , target ) workspace_dir = build_context . get_workspace ( 'CppProg' , target . name ) build_cpp ( build_context , target , target . compiler_config , workspace_dir )", "docstring_tokens": "Build a C ++ binary executable", "label": 0}, {"idx": "cosqa-train-6111", "doc": "solving matrix equations python", "code": "def MatrixSolve(a, rhs, adj):\n    \"\"\"\n    Matrix solve op.\n    \"\"\"\n    return np.linalg.solve(a if not adj else _adjoint(a), rhs),", "code_tokens": "def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,", "docstring_tokens": "Matrix solve op .", "label": 0}, {"idx": "cosqa-train-6112", "doc": "python calculate average contrast of an image", "code": "def lighting(im, b, c):\n    \"\"\" Adjust image balance and contrast \"\"\"\n    if b==0 and c==1: return im\n    mu = np.average(im)\n    return np.clip((im-mu)*c+mu+b,0.,1.).astype(np.float32)", "code_tokens": "def lighting ( im , b , c ) : if b == 0 and c == 1 : return im mu = np . average ( im ) return np . clip ( ( im - mu ) * c + mu + b , 0. , 1. ) . astype ( np . float32 )", "docstring_tokens": "Adjust image balance and contrast", "label": 0}, {"idx": "cosqa-train-6113", "doc": "sort an array in descending order in python", "code": "def arglexsort(arrays):\n    \"\"\"\n    Returns the indices of the lexicographical sorting\n    order of the supplied arrays.\n    \"\"\"\n    dtypes = ','.join(array.dtype.str for array in arrays)\n    recarray = np.empty(len(arrays[0]), dtype=dtypes)\n    for i, array in enumerate(arrays):\n        recarray['f%s' % i] = array\n    return recarray.argsort()", "code_tokens": "def arglexsort ( arrays ) : dtypes = ',' . join ( array . dtype . str for array in arrays ) recarray = np . empty ( len ( arrays [ 0 ] ) , dtype = dtypes ) for i , array in enumerate ( arrays ) : recarray [ 'f%s' % i ] = array return recarray . argsort ( )", "docstring_tokens": "Returns the indices of the lexicographical sorting order of the supplied arrays .", "label": 0}, {"idx": "cosqa-train-6114", "doc": "python calculate distance between 2 coordinates", "code": "def _calculate_distance(latlon1, latlon2):\n    \"\"\"Calculates the distance between two points on earth.\n    \"\"\"\n    lat1, lon1 = latlon1\n    lat2, lon2 = latlon2\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    R = 6371  # radius of the earth in kilometers\n    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * (np.sin(dlon / 2))**2\n    c = 2 * np.pi * R * np.arctan2(np.sqrt(a), np.sqrt(1 - a)) / 180\n    return c", "code_tokens": "def _calculate_distance ( latlon1 , latlon2 ) : lat1 , lon1 = latlon1 lat2 , lon2 = latlon2 dlon = lon2 - lon1 dlat = lat2 - lat1 R = 6371 # radius of the earth in kilometers a = np . sin ( dlat / 2 ) ** 2 + np . cos ( lat1 ) * np . cos ( lat2 ) * ( np . sin ( dlon / 2 ) ) ** 2 c = 2 * np . pi * R * np . arctan2 ( np . sqrt ( a ) , np . sqrt ( 1 - a ) ) / 180 return c", "docstring_tokens": "Calculates the distance between two points on earth .", "label": 0}, {"idx": "cosqa-train-6115", "doc": "sort and uniq a list in python", "code": "def unique_list(lst):\n    \"\"\"Make a list unique, retaining order of initial appearance.\"\"\"\n    uniq = []\n    for item in lst:\n        if item not in uniq:\n            uniq.append(item)\n    return uniq", "code_tokens": "def unique_list ( lst ) : uniq = [ ] for item in lst : if item not in uniq : uniq . append ( item ) return uniq", "docstring_tokens": "Make a list unique retaining order of initial appearance .", "label": 0}, {"idx": "cosqa-train-6116", "doc": "python calculate jaccard similarity between two vectors", "code": "def jaccard(c_1, c_2):\n    \"\"\"\n    Calculates the Jaccard similarity between two sets of nodes. Called by mroc.\n\n    Inputs:  - c_1: Community (set of nodes) 1.\n             - c_2: Community (set of nodes) 2.\n\n    Outputs: - jaccard_similarity: The Jaccard similarity of these two communities.\n    \"\"\"\n    nom = np.intersect1d(c_1, c_2).size\n    denom = np.union1d(c_1, c_2).size\n    return nom/denom", "code_tokens": "def jaccard ( c_1 , c_2 ) : nom = np . intersect1d ( c_1 , c_2 ) . size denom = np . union1d ( c_1 , c_2 ) . size return nom / denom", "docstring_tokens": "Calculates the Jaccard similarity between two sets of nodes . Called by mroc .", "label": 0}, {"idx": "cosqa-train-6117", "doc": "sort and uniq list python", "code": "def unique_list(lst):\n    \"\"\"Make a list unique, retaining order of initial appearance.\"\"\"\n    uniq = []\n    for item in lst:\n        if item not in uniq:\n            uniq.append(item)\n    return uniq", "code_tokens": "def unique_list ( lst ) : uniq = [ ] for item in lst : if item not in uniq : uniq . append ( item ) return uniq", "docstring_tokens": "Make a list unique retaining order of initial appearance .", "label": 0}, {"idx": "cosqa-train-6118", "doc": "python calculate offset coordinates star", "code": "def getOffset(self, loc):\n        \"\"\" Returns the offset between the given point and this point \"\"\"\n        return Location(loc.x - self.x, loc.y - self.y)", "code_tokens": "def getOffset ( self , loc ) : return Location ( loc . x - self . x , loc . y - self . y )", "docstring_tokens": "Returns the offset between the given point and this point", "label": 0}, {"idx": "cosqa-train-6119", "doc": "sort data to column in python", "code": "def sort_data(data, cols):\n    \"\"\"Sort `data` rows and order columns\"\"\"\n    return data.sort_values(cols)[cols + ['value']].reset_index(drop=True)", "code_tokens": "def sort_data ( data , cols ) : return data . sort_values ( cols ) [ cols + [ 'value' ] ] . reset_index ( drop = True )", "docstring_tokens": "Sort data rows and order columns", "label": 0}, {"idx": "cosqa-train-6120", "doc": "sorting a list of python objects by an element of the object", "code": "def csort(objs, key):\n    \"\"\"Order-preserving sorting function.\"\"\"\n    idxs = dict((obj, i) for (i, obj) in enumerate(objs))\n    return sorted(objs, key=lambda obj: (key(obj), idxs[obj]))", "code_tokens": "def csort ( objs , key ) : idxs = dict ( ( obj , i ) for ( i , obj ) in enumerate ( objs ) ) return sorted ( objs , key = lambda obj : ( key ( obj ) , idxs [ obj ] ) )", "docstring_tokens": "Order - preserving sorting function .", "label": 0}, {"idx": "cosqa-train-6121", "doc": "python calculate struct offset", "code": "def get_element_offset(self, ty, position):\n        \"\"\"\n        Get byte offset of type's ty element at the given position\n        \"\"\"\n\n        offset = ffi.lib.LLVMPY_OffsetOfElement(self, ty, position)\n        if offset == -1:\n            raise ValueError(\"Could not determined offset of {}th \"\n                    \"element of the type '{}'. Is it a struct type?\".format(\n                    position, str(ty)))\n        return offset", "code_tokens": "def get_element_offset ( self , ty , position ) : offset = ffi . lib . LLVMPY_OffsetOfElement ( self , ty , position ) if offset == - 1 : raise ValueError ( \"Could not determined offset of {}th \" \"element of the type '{}'. Is it a struct type?\" . format ( position , str ( ty ) ) ) return offset", "docstring_tokens": "Get byte offset of type s ty element at the given position", "label": 0}, {"idx": "cosqa-train-6122", "doc": "sorting values key should also change in python", "code": "def sort_func(self, key):\n        \"\"\"Sorting logic for `Quantity` objects.\"\"\"\n        if key == self._KEYS.VALUE:\n            return 'aaa'\n        if key == self._KEYS.SOURCE:\n            return 'zzz'\n        return key", "code_tokens": "def sort_func ( self , key ) : if key == self . _KEYS . VALUE : return 'aaa' if key == self . _KEYS . SOURCE : return 'zzz' return key", "docstring_tokens": "Sorting logic for Quantity objects .", "label": 1}, {"idx": "cosqa-train-6123", "doc": "python can use cascade inequality", "code": "def logical_or(self, other):\n        \"\"\"logical_or(t) = self(t) or other(t).\"\"\"\n        return self.operation(other, lambda x, y: int(x or y))", "code_tokens": "def logical_or ( self , other ) : return self . operation ( other , lambda x , y : int ( x or y ) )", "docstring_tokens": "logical_or ( t ) = self ( t ) or other ( t ) .", "label": 0}, {"idx": "cosqa-train-6124", "doc": "sphinx skip python files", "code": "def shall_skip(app, module, private):\n    \"\"\"Check if we want to skip this module.\n\n    :param app: the sphinx app\n    :type app: :class:`sphinx.application.Sphinx`\n    :param module: the module name\n    :type module: :class:`str`\n    :param private: True, if privates are allowed\n    :type private: :class:`bool`\n    \"\"\"\n    logger.debug('Testing if %s should be skipped.', module)\n    # skip if it has a \"private\" name and this is selected\n    if module != '__init__.py' and module.startswith('_') and \\\n       not private:\n        logger.debug('Skip %s because its either private or __init__.', module)\n        return True\n    logger.debug('Do not skip %s', module)\n    return False", "code_tokens": "def shall_skip ( app , module , private ) : logger . debug ( 'Testing if %s should be skipped.' , module ) # skip if it has a \"private\" name and this is selected if module != '__init__.py' and module . startswith ( '_' ) and not private : logger . debug ( 'Skip %s because its either private or __init__.' , module ) return True logger . debug ( 'Do not skip %s' , module ) return False", "docstring_tokens": "Check if we want to skip this module .", "label": 0}, {"idx": "cosqa-train-6125", "doc": "python canvas auto scrolling text", "code": "def set_scrollregion(self, event=None):\n        \"\"\" Set the scroll region on the canvas\"\"\"\n        self.canvas.configure(scrollregion=self.canvas.bbox('all'))", "code_tokens": "def set_scrollregion ( self , event = None ) : self . canvas . configure ( scrollregion = self . canvas . bbox ( 'all' ) )", "docstring_tokens": "Set the scroll region on the canvas", "label": 1}, {"idx": "cosqa-train-6126", "doc": "split tsv file python", "code": "def generate_split_tsv_lines(fn, header):\n    \"\"\"Returns dicts with header-keys and psm statistic values\"\"\"\n    for line in generate_tsv_psms_line(fn):\n        yield {x: y for (x, y) in zip(header, line.strip().split('\\t'))}", "code_tokens": "def generate_split_tsv_lines ( fn , header ) : for line in generate_tsv_psms_line ( fn ) : yield { x : y for ( x , y ) in zip ( header , line . strip ( ) . split ( '\\t' ) ) }", "docstring_tokens": "Returns dicts with header - keys and psm statistic values", "label": 0}, {"idx": "cosqa-train-6127", "doc": "python capitalize all leter", "code": "def to_pascal_case(s):\n    \"\"\"Transform underscore separated string to pascal case\n\n    \"\"\"\n    return re.sub(r'(?!^)_([a-zA-Z])', lambda m: m.group(1).upper(), s.capitalize())", "code_tokens": "def to_pascal_case ( s ) : return re . sub ( r'(?!^)_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , s . capitalize ( ) )", "docstring_tokens": "Transform underscore separated string to pascal case", "label": 0}, {"idx": "cosqa-train-6128", "doc": "splitting up a string into a dictionary python", "code": "def string_to_identity(identity_str):\n    \"\"\"Parse string into Identity dictionary.\"\"\"\n    m = _identity_regexp.match(identity_str)\n    result = m.groupdict()\n    log.debug('parsed identity: %s', result)\n    return {k: v for k, v in result.items() if v}", "code_tokens": "def string_to_identity ( identity_str ) : m = _identity_regexp . match ( identity_str ) result = m . groupdict ( ) log . debug ( 'parsed identity: %s' , result ) return { k : v for k , v in result . items ( ) if v }", "docstring_tokens": "Parse string into Identity dictionary .", "label": 0}, {"idx": "cosqa-train-6129", "doc": "python capitalize all letters", "code": "def decamelise(text):\n    \"\"\"Convert CamelCase to lower_and_underscore.\"\"\"\n    s = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s).lower()", "code_tokens": "def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s ) . lower ( )", "docstring_tokens": "Convert CamelCase to lower_and_underscore .", "label": 0}, {"idx": "cosqa-train-6130", "doc": "sqlite in python create a dictionary", "code": "def sqliteRowsToDicts(sqliteRows):\n    \"\"\"\n    Unpacks sqlite rows as returned by fetchall\n    into an array of simple dicts.\n\n    :param sqliteRows: array of rows returned from fetchall DB call\n    :return:  array of dicts, keyed by the column names.\n    \"\"\"\n    return map(lambda r: dict(zip(r.keys(), r)), sqliteRows)", "code_tokens": "def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )", "docstring_tokens": "Unpacks sqlite rows as returned by fetchall into an array of simple dicts .", "label": 0}, {"idx": "cosqa-train-6131", "doc": "python case insesitive endswith comparison", "code": "def is_equal_strings_ignore_case(first, second):\n    \"\"\"The function compares strings ignoring case\"\"\"\n    if first and second:\n        return first.upper() == second.upper()\n    else:\n        return not (first or second)", "code_tokens": "def is_equal_strings_ignore_case ( first , second ) : if first and second : return first . upper ( ) == second . upper ( ) else : return not ( first or second )", "docstring_tokens": "The function compares strings ignoring case", "label": 0}, {"idx": "cosqa-train-6132", "doc": "stack python memory map", "code": "def stack_push(self, thing):\n        \"\"\"\n        Push 'thing' to the stack, writing the thing to memory and adjusting the stack pointer.\n        \"\"\"\n        # increment sp\n        sp = self.regs.sp + self.arch.stack_change\n        self.regs.sp = sp\n        return self.memory.store(sp, thing, endness=self.arch.memory_endness)", "code_tokens": "def stack_push ( self , thing ) : # increment sp sp = self . regs . sp + self . arch . stack_change self . regs . sp = sp return self . memory . store ( sp , thing , endness = self . arch . memory_endness )", "docstring_tokens": "Push thing to the stack writing the thing to memory and adjusting the stack pointer .", "label": 1}, {"idx": "cosqa-train-6133", "doc": "python cast as timestamp", "code": "def dt_to_ts(value):\n    \"\"\" If value is a datetime, convert to timestamp \"\"\"\n    if not isinstance(value, datetime):\n        return value\n    return calendar.timegm(value.utctimetuple()) + value.microsecond / 1000000.0", "code_tokens": "def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0", "docstring_tokens": "If value is a datetime convert to timestamp", "label": 0}, {"idx": "cosqa-train-6134", "doc": "stacked plot python time seriesmatplotlib", "code": "def stackplot(marray, seconds=None, start_time=None, ylabels=None):\n    \"\"\"\n    will plot a stack of traces one above the other assuming\n    marray.shape = numRows, numSamples\n    \"\"\"\n    tarray = np.transpose(marray)\n    stackplot_t(tarray, seconds=seconds, start_time=start_time, ylabels=ylabels)\n    plt.show()", "code_tokens": "def stackplot ( marray , seconds = None , start_time = None , ylabels = None ) : tarray = np . transpose ( marray ) stackplot_t ( tarray , seconds = seconds , start_time = start_time , ylabels = ylabels ) plt . show ( )", "docstring_tokens": "will plot a stack of traces one above the other assuming marray . shape = numRows numSamples", "label": 0}, {"idx": "cosqa-train-6135", "doc": "python cast comma seperated string as list", "code": "def comma_delimited_to_list(list_param):\n    \"\"\"Convert comma-delimited list / string into a list of strings\n\n    :param list_param: Comma-delimited string\n    :type list_param: str | unicode\n    :return: A list of strings\n    :rtype: list\n    \"\"\"\n    if isinstance(list_param, list):\n        return list_param\n    if isinstance(list_param, str):\n        return list_param.split(',')\n    else:\n        return []", "code_tokens": "def comma_delimited_to_list ( list_param ) : if isinstance ( list_param , list ) : return list_param if isinstance ( list_param , str ) : return list_param . split ( ',' ) else : return [ ]", "docstring_tokens": "Convert comma - delimited list / string into a list of strings", "label": 0}, {"idx": "cosqa-train-6136", "doc": "stackovrflow python send text message", "code": "async def _send_plain_text(self, request: Request, stack: Stack):\n        \"\"\"\n        Sends plain text using `_send_text()`.\n        \"\"\"\n\n        await self._send_text(request, stack, None)", "code_tokens": "async def _send_plain_text ( self , request : Request , stack : Stack ) : await self . _send_text ( request , stack , None )", "docstring_tokens": "Sends plain text using _send_text () .", "label": 0}, {"idx": "cosqa-train-6137", "doc": "python cast nontype to string", "code": "def to_str(obj):\n    \"\"\"Attempts to convert given object to a string object\n    \"\"\"\n    if not isinstance(obj, str) and PY3 and isinstance(obj, bytes):\n        obj = obj.decode('utf-8')\n    return obj if isinstance(obj, string_types) else str(obj)", "code_tokens": "def to_str ( obj ) : if not isinstance ( obj , str ) and PY3 and isinstance ( obj , bytes ) : obj = obj . decode ( 'utf-8' ) return obj if isinstance ( obj , string_types ) else str ( obj )", "docstring_tokens": "Attempts to convert given object to a string object", "label": 1}, {"idx": "cosqa-train-6138", "doc": "standard deviation across columns python", "code": "def weighted_std(values, weights):\n    \"\"\" Calculate standard deviation weighted by errors \"\"\"\n    average = np.average(values, weights=weights)\n    variance = np.average((values-average)**2, weights=weights)\n    return np.sqrt(variance)", "code_tokens": "def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )", "docstring_tokens": "Calculate standard deviation weighted by errors", "label": 0}, {"idx": "cosqa-train-6139", "doc": "python cast return type", "code": "def convert_value(bind, value):\n    \"\"\" Type casting. \"\"\"\n    type_name = get_type(bind)\n    try:\n        return typecast.cast(type_name, value)\n    except typecast.ConverterError:\n        return value", "code_tokens": "def convert_value ( bind , value ) : type_name = get_type ( bind ) try : return typecast . cast ( type_name , value ) except typecast . ConverterError : return value", "docstring_tokens": "Type casting .", "label": 0}, {"idx": "cosqa-train-6140", "doc": "standard deviation and average in python", "code": "def _mean_absolute_error(y, y_pred, w):\n    \"\"\"Calculate the mean absolute error.\"\"\"\n    return np.average(np.abs(y_pred - y), weights=w)", "code_tokens": "def _mean_absolute_error ( y , y_pred , w ) : return np . average ( np . abs ( y_pred - y ) , weights = w )", "docstring_tokens": "Calculate the mean absolute error .", "label": 0}, {"idx": "cosqa-train-6141", "doc": "python cast to precision", "code": "def round_to_int(number, precision):\n    \"\"\"Round a number to a precision\"\"\"\n    precision = int(precision)\n    rounded = (int(number) + precision / 2) // precision * precision\n    return rounded", "code_tokens": "def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded", "docstring_tokens": "Round a number to a precision", "label": 0}, {"idx": "cosqa-train-6142", "doc": "standard deviation using average code python without list", "code": "def lsem (inlist):\n    \"\"\"\nReturns the estimated standard error of the mean (sx-bar) of the\nvalues in the passed list.  sem = stdev / sqrt(n)\n\nUsage:   lsem(inlist)\n\"\"\"\n    sd = stdev(inlist)\n    n = len(inlist)\n    return sd/math.sqrt(n)", "code_tokens": "def lsem ( inlist ) : sd = stdev ( inlist ) n = len ( inlist ) return sd / math . sqrt ( n )", "docstring_tokens": "Returns the estimated standard error of the mean ( sx - bar ) of the values in the passed list . sem = stdev / sqrt ( n )", "label": 0}, {"idx": "cosqa-train-6143", "doc": "python casting string to bool", "code": "def FromString(self, string):\n    \"\"\"Parse a bool from a string.\"\"\"\n    if string.lower() in (\"false\", \"no\", \"n\"):\n      return False\n\n    if string.lower() in (\"true\", \"yes\", \"y\"):\n      return True\n\n    raise TypeValueError(\"%s is not recognized as a boolean value.\" % string)", "code_tokens": "def FromString ( self , string ) : if string . lower ( ) in ( \"false\" , \"no\" , \"n\" ) : return False if string . lower ( ) in ( \"true\" , \"yes\" , \"y\" ) : return True raise TypeValueError ( \"%s is not recognized as a boolean value.\" % string )", "docstring_tokens": "Parse a bool from a string .", "label": 1}, {"idx": "cosqa-train-6144", "doc": "start and stop must be an interger in range function in python fix", "code": "def range(*args, interval=0):\n    \"\"\"Generate a given range of numbers.\n\n    It supports the same arguments as the builtin function.\n    An optional interval can be given to space the values out.\n    \"\"\"\n    agen = from_iterable.raw(builtins.range(*args))\n    return time.spaceout.raw(agen, interval) if interval else agen", "code_tokens": "def range ( * args , interval = 0 ) : agen = from_iterable . raw ( builtins . range ( * args ) ) return time . spaceout . raw ( agen , interval ) if interval else agen", "docstring_tokens": "Generate a given range of numbers .", "label": 0}, {"idx": "cosqa-train-6145", "doc": "python cdll create object from dll", "code": "def load(self, name):\n        \"\"\"Loads and returns foreign library.\"\"\"\n        name = ctypes.util.find_library(name)\n        return ctypes.cdll.LoadLibrary(name)", "code_tokens": "def load ( self , name ) : name = ctypes . util . find_library ( name ) return ctypes . cdll . LoadLibrary ( name )", "docstring_tokens": "Loads and returns foreign library .", "label": 0}, {"idx": "cosqa-train-6146", "doc": "stat python linux file permsissions", "code": "def set_executable(filename):\n    \"\"\"Set the exectuable bit on the given filename\"\"\"\n    st = os.stat(filename)\n    os.chmod(filename, st.st_mode | stat.S_IEXEC)", "code_tokens": "def set_executable ( filename ) : st = os . stat ( filename ) os . chmod ( filename , st . st_mode | stat . S_IEXEC )", "docstring_tokens": "Set the exectuable bit on the given filename", "label": 0}, {"idx": "cosqa-train-6147", "doc": "python celery async result", "code": "async def result_processor(tasks):\n    \"\"\"An async result aggregator that combines all the results\n       This gets executed in unsync.loop and unsync.thread\"\"\"\n    output = {}\n    for task in tasks:\n        num, res = await task\n        output[num] = res\n    return output", "code_tokens": "async def result_processor ( tasks ) : output = { } for task in tasks : num , res = await task output [ num ] = res return output", "docstring_tokens": "An async result aggregator that combines all the results This gets executed in unsync . loop and unsync . thread", "label": 1}, {"idx": "cosqa-train-6148", "doc": "static method in python csdn", "code": "def _update_staticmethod(self, oldsm, newsm):\n        \"\"\"Update a staticmethod update.\"\"\"\n        # While we can't modify the staticmethod object itself (it has no\n        # mutable attributes), we *can* extract the underlying function\n        # (by calling __get__(), which returns it) and update it in-place.\n        # We don't have the class available to pass to __get__() but any\n        # object except None will do.\n        self._update(None, None, oldsm.__get__(0), newsm.__get__(0))", "code_tokens": "def _update_staticmethod ( self , oldsm , newsm ) : # While we can't modify the staticmethod object itself (it has no # mutable attributes), we *can* extract the underlying function # (by calling __get__(), which returns it) and update it in-place. # We don't have the class available to pass to __get__() but any # object except None will do. self . _update ( None , None , oldsm . __get__ ( 0 ) , newsm . __get__ ( 0 ) )", "docstring_tokens": "Update a staticmethod update .", "label": 0}, {"idx": "cosqa-train-6149", "doc": "python celery get task by id", "code": "def find_task_by_id(self, id, session=None):\n        \"\"\"\n        Find task with the given record ID.\n        \"\"\"\n        with self._session(session) as session:\n            return session.query(TaskRecord).get(id)", "code_tokens": "def find_task_by_id ( self , id , session = None ) : with self . _session ( session ) as session : return session . query ( TaskRecord ) . get ( id )", "docstring_tokens": "Find task with the given record ID .", "label": 0}, {"idx": "cosqa-train-6150", "doc": "std deviation in list python", "code": "def standard_deviation(numbers):\n    \"\"\"Return standard deviation.\"\"\"\n    numbers = list(numbers)\n    if not numbers:\n        return 0\n    mean = sum(numbers) / len(numbers)\n    return (sum((n - mean) ** 2 for n in numbers) /\n            len(numbers)) ** .5", "code_tokens": "def standard_deviation ( numbers ) : numbers = list ( numbers ) if not numbers : return 0 mean = sum ( numbers ) / len ( numbers ) return ( sum ( ( n - mean ) ** 2 for n in numbers ) / len ( numbers ) ) ** .5", "docstring_tokens": "Return standard deviation .", "label": 1}, {"idx": "cosqa-train-6151", "doc": "python celery type is not json serializable", "code": "def getExperiments(uuid: str):\n    \"\"\" list active (running or completed) experiments\"\"\"\n    return jsonify([x.deserialize() for x in Experiment.query.all()])", "code_tokens": "def getExperiments ( uuid : str ) : return jsonify ( [ x . deserialize ( ) for x in Experiment . query . all ( ) ] )", "docstring_tokens": "list active ( running or completed ) experiments", "label": 0}, {"idx": "cosqa-train-6152", "doc": "stdout flush terminate python", "code": "def safe_exit(output):\n    \"\"\"exit without breaking pipes.\"\"\"\n    try:\n        sys.stdout.write(output)\n        sys.stdout.flush()\n    except IOError:\n        pass", "code_tokens": "def safe_exit ( output ) : try : sys . stdout . write ( output ) sys . stdout . flush ( ) except IOError : pass", "docstring_tokens": "exit without breaking pipes .", "label": 0}, {"idx": "cosqa-train-6153", "doc": "python change camelcase to normal", "code": "def convert_camel_case_to_snake_case(name):\n    \"\"\"Convert CamelCase to snake_case.\"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def convert_camel_case_to_snake_case ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert CamelCase to snake_case .", "label": 0}, {"idx": "cosqa-train-6154", "doc": "stop a running task in python", "code": "def stop(self, timeout=None):\n        \"\"\"Stop the thread.\"\"\"\n        logger.debug(\"docker plugin - Close thread for container {}\".format(self._container.name))\n        self._stopper.set()", "code_tokens": "def stop ( self , timeout = None ) : logger . debug ( \"docker plugin - Close thread for container {}\" . format ( self . _container . name ) ) self . _stopper . set ( )", "docstring_tokens": "Stop the thread .", "label": 0}, {"idx": "cosqa-train-6155", "doc": "python change date to custom format", "code": "def inc_date(date_obj, num, date_fmt):\n    \"\"\"Increment the date by a certain number and return date object.\n    as the specific string format.\n    \"\"\"\n    return (date_obj + timedelta(days=num)).strftime(date_fmt)", "code_tokens": "def inc_date ( date_obj , num , date_fmt ) : return ( date_obj + timedelta ( days = num ) ) . strftime ( date_fmt )", "docstring_tokens": "Increment the date by a certain number and return date object . as the specific string format .", "label": 0}, {"idx": "cosqa-train-6156", "doc": "stop execution by sending ctrl c in python", "code": "def stop_button_click_handler(self):\n        \"\"\"Method to handle what to do when the stop button is pressed\"\"\"\n        self.stop_button.setDisabled(True)\n        # Interrupt computations or stop debugging\n        if not self.shellwidget._reading:\n            self.interrupt_kernel()\n        else:\n            self.shellwidget.write_to_stdin('exit')", "code_tokens": "def stop_button_click_handler ( self ) : self . stop_button . setDisabled ( True ) # Interrupt computations or stop debugging\n if not self . shellwidget . _reading : self . interrupt_kernel ( ) else : self . shellwidget . write_to_stdin ( 'exit' )", "docstring_tokens": "Method to handle what to do when the stop button is pressed", "label": 1}, {"idx": "cosqa-train-6157", "doc": "python change default traceback", "code": "def excepthook(self, except_type, exception, traceback):\n    \"\"\"Not Used: Custom exception hook to replace sys.excepthook\n\n    This is for CPython's default shell. IPython does not use sys.exepthook.\n\n    https://stackoverflow.com/questions/27674602/hide-traceback-unless-a-debug-flag-is-set\n    \"\"\"\n    if except_type is DeepReferenceError:\n        print(exception.msg)\n    else:\n        self.default_excepthook(except_type, exception, traceback)", "code_tokens": "def excepthook ( self , except_type , exception , traceback ) : if except_type is DeepReferenceError : print ( exception . msg ) else : self . default_excepthook ( except_type , exception , traceback )", "docstring_tokens": "Not Used : Custom exception hook to replace sys . excepthook", "label": 0}, {"idx": "cosqa-train-6158", "doc": "stopwords containing punctionation python", "code": "def wordify(text):\n    \"\"\"Generate a list of words given text, removing punctuation.\n\n    Parameters\n    ----------\n    text : unicode\n        A piece of english text.\n\n    Returns\n    -------\n    words : list\n        List of words.\n    \"\"\"\n    stopset = set(nltk.corpus.stopwords.words('english'))\n    tokens = nltk.WordPunctTokenizer().tokenize(text)\n    return [w for w in tokens if w not in stopset]", "code_tokens": "def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]", "docstring_tokens": "Generate a list of words given text removing punctuation .", "label": 0}, {"idx": "cosqa-train-6159", "doc": "python change dict element of one key, other key remain same", "code": "def dict_update_newkeys(dict_, dict2):\n    \"\"\" Like dict.update, but does not overwrite items \"\"\"\n    for key, val in six.iteritems(dict2):\n        if key not in dict_:\n            dict_[key] = val", "code_tokens": "def dict_update_newkeys ( dict_ , dict2 ) : for key , val in six . iteritems ( dict2 ) : if key not in dict_ : dict_ [ key ] = val", "docstring_tokens": "Like dict . update but does not overwrite items", "label": 0}, {"idx": "cosqa-train-6160", "doc": "store type of a variable in a list python", "code": "def toList(variable, types=(basestring, int, float, )):\n    \"\"\"Converts a variable of type string, int, float to a list, containing the\n    variable as the only element.\n\n    :param variable: any python object\n    :type variable: (str, int, float, others)\n\n    :returns: [variable] or variable\n    \"\"\"\n    if isinstance(variable, types):\n        return [variable]\n    else:\n        return variable", "code_tokens": "def toList ( variable , types = ( basestring , int , float , ) ) : if isinstance ( variable , types ) : return [ variable ] else : return variable", "docstring_tokens": "Converts a variable of type string int float to a list containing the variable as the only element .", "label": 0}, {"idx": "cosqa-train-6161", "doc": "python change dict to request body", "code": "def set_json_item(key, value):\n    \"\"\" manipulate json data on the fly\n    \"\"\"\n    data = get_json()\n    data[key] = value\n\n    request = get_request()\n    request[\"BODY\"] = json.dumps(data)", "code_tokens": "def set_json_item ( key , value ) : data = get_json ( ) data [ key ] = value request = get_request ( ) request [ \"BODY\" ] = json . dumps ( data )", "docstring_tokens": "manipulate json data on the fly", "label": 0}, {"idx": "cosqa-train-6162", "doc": "str cast to bytes python", "code": "def to_binary(s, encoding='utf8'):\n    \"\"\"Portable cast function.\n\n    In python 2 the ``str`` function which is used to coerce objects to bytes does not\n    accept an encoding argument, whereas python 3's ``bytes`` function requires one.\n\n    :param s: object to be converted to binary_type\n    :return: binary_type instance, representing s.\n    \"\"\"\n    if PY3:  # pragma: no cover\n        return s if isinstance(s, binary_type) else binary_type(s, encoding=encoding)\n    return binary_type(s)", "code_tokens": "def to_binary ( s , encoding = 'utf8' ) : if PY3 : # pragma: no cover return s if isinstance ( s , binary_type ) else binary_type ( s , encoding = encoding ) return binary_type ( s )", "docstring_tokens": "Portable cast function .", "label": 0}, {"idx": "cosqa-train-6163", "doc": "python change index in cellwidget combobox not valid index", "code": "def _updateItemComboBoxIndex(self, item, column, num):\n        \"\"\"Callback for comboboxes: notifies us that a combobox for the given item and column has changed\"\"\"\n        item._combobox_current_index[column] = num\n        item._combobox_current_value[column] = item._combobox_option_list[column][num][0]", "code_tokens": "def _updateItemComboBoxIndex ( self , item , column , num ) : item . _combobox_current_index [ column ] = num item . _combobox_current_value [ column ] = item . _combobox_option_list [ column ] [ num ] [ 0 ]", "docstring_tokens": "Callback for comboboxes : notifies us that a combobox for the given item and column has changed", "label": 1}, {"idx": "cosqa-train-6164", "doc": "str not callable python xpath", "code": "def xpathEvalExpression(self, str):\n        \"\"\"Evaluate the XPath expression in the given context. \"\"\"\n        ret = libxml2mod.xmlXPathEvalExpression(str, self._o)\n        if ret is None:raise xpathError('xmlXPathEvalExpression() failed')\n        return xpathObjectRet(ret)", "code_tokens": "def xpathEvalExpression ( self , str ) : ret = libxml2mod . xmlXPathEvalExpression ( str , self . _o ) if ret is None : raise xpathError ( 'xmlXPathEvalExpression() failed' ) return xpathObjectRet ( ret )", "docstring_tokens": "Evaluate the XPath expression in the given context .", "label": 0}, {"idx": "cosqa-train-6165", "doc": "python change key names", "code": "def unit_key_from_name(name):\n  \"\"\"Return a legal python name for the given name for use as a unit key.\"\"\"\n  result = name\n\n  for old, new in six.iteritems(UNIT_KEY_REPLACEMENTS):\n    result = result.replace(old, new)\n\n  # Collapse redundant underscores and convert to uppercase.\n  result = re.sub(r'_+', '_', result.upper())\n\n  return result", "code_tokens": "def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result", "docstring_tokens": "Return a legal python name for the given name for use as a unit key .", "label": 0}, {"idx": "cosqa-train-6166", "doc": "string as file object python", "code": "def loads(s, model=None, parser=None):\n    \"\"\"Deserialize s (a str) to a Python object.\"\"\"\n    with StringIO(s) as f:\n        return load(f, model=model, parser=parser)", "code_tokens": "def loads ( s , model = None , parser = None ) : with StringIO ( s ) as f : return load ( f , model = model , parser = parser )", "docstring_tokens": "Deserialize s ( a str ) to a Python object .", "label": 0}, {"idx": "cosqa-train-6167", "doc": "python change number to percent format", "code": "def to_percentage(number, rounding=2):\n    \"\"\"Creates a percentage string representation from the given `number`. The\n    number is multiplied by 100 before adding a '%' character.\n\n    Raises `ValueError` if `number` cannot be converted to a number.\n    \"\"\"\n    number = float(number) * 100\n    number_as_int = int(number)\n    rounded = round(number, rounding)\n\n    return '{}%'.format(number_as_int if number_as_int == rounded else rounded)", "code_tokens": "def to_percentage ( number , rounding = 2 ) : number = float ( number ) * 100 number_as_int = int ( number ) rounded = round ( number , rounding ) return '{}%' . format ( number_as_int if number_as_int == rounded else rounded )", "docstring_tokens": "Creates a percentage string representation from the given number . The number is multiplied by 100 before adding a % character .", "label": 1}, {"idx": "cosqa-train-6168", "doc": "string dot ascii in python", "code": "def _dotify(cls, data):\n    \"\"\"Add dots.\"\"\"\n    return ''.join(char if char in cls.PRINTABLE_DATA else '.' for char in data)", "code_tokens": "def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )", "docstring_tokens": "Add dots .", "label": 0}, {"idx": "cosqa-train-6169", "doc": "python change type from object to int", "code": "def _to_numeric(val):\n    \"\"\"\n    Helper function for conversion of various data types into numeric representation.\n    \"\"\"\n    if isinstance(val, (int, float, datetime.datetime, datetime.timedelta)):\n        return val\n    return float(val)", "code_tokens": "def _to_numeric ( val ) : if isinstance ( val , ( int , float , datetime . datetime , datetime . timedelta ) ) : return val return float ( val )", "docstring_tokens": "Helper function for conversion of various data types into numeric representation .", "label": 0}, {"idx": "cosqa-train-6170", "doc": "string is empty query python", "code": "def is_stats_query(query):\n    \"\"\"\n    check if the query is a normal search or select query\n    :param query:\n    :return:\n    \"\"\"\n    if not query:\n        return False\n\n    # remove all \" enclosed strings\n    nq = re.sub(r'\"[^\"]*\"', '', query)\n\n    # check if there's | .... select\n    if re.findall(r'\\|.*\\bselect\\b', nq, re.I|re.DOTALL):\n        return True\n\n    return False", "code_tokens": "def is_stats_query ( query ) : if not query : return False # remove all \" enclosed strings\n nq = re . sub ( r'\"[^\"]*\"' , '' , query ) # check if there's | .... select\n if re . findall ( r'\\|.*\\bselect\\b' , nq , re . I | re . DOTALL ) : return True return False", "docstring_tokens": "check if the query is a normal search or select query : param query : : return :", "label": 0}, {"idx": "cosqa-train-6171", "doc": "python change type np array into dictionary", "code": "def dump_nparray(self, obj, class_name=numpy_ndarray_class_name):\n        \"\"\"\n        ``numpy.ndarray`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: self._json_convert(obj.tolist())}", "code_tokens": "def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { \"$\" + class_name : self . _json_convert ( obj . tolist ( ) ) }", "docstring_tokens": "numpy . ndarray dumper .", "label": 0}, {"idx": "cosqa-train-6172", "doc": "string to objectid python", "code": "def get_obj(ref):\n    \"\"\"Get object from string reference.\"\"\"\n    oid = int(ref)\n    return server.id2ref.get(oid) or server.id2obj[oid]", "code_tokens": "def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]", "docstring_tokens": "Get object from string reference .", "label": 0}, {"idx": "cosqa-train-6173", "doc": "python change value of a global variable", "code": "def set_global(node: Node, key: str, value: Any):\n    \"\"\"Adds passed value to node's globals\"\"\"\n    node.node_globals[key] = value", "code_tokens": "def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "docstring_tokens": "Adds passed value to node s globals", "label": 0}, {"idx": "cosqa-train-6174", "doc": "strings to bytes python 3", "code": "def to_bytes(s, encoding=\"utf-8\"):\n    \"\"\"Convert a string to bytes.\"\"\"\n    if isinstance(s, six.binary_type):\n        return s\n    if six.PY3:\n        return bytes(s, encoding)\n    return s.encode(encoding)", "code_tokens": "def to_bytes ( s , encoding = \"utf-8\" ) : if isinstance ( s , six . binary_type ) : return s if six . PY3 : return bytes ( s , encoding ) return s . encode ( encoding )", "docstring_tokens": "Convert a string to bytes .", "label": 1}, {"idx": "cosqa-train-6175", "doc": "python chech if a string is in the list", "code": "def isin(elems, line):\n    \"\"\"Check if an element from a list is in a string.\n\n    :type elems: list\n    :type line: str\n\n    \"\"\"\n    found = False\n    for e in elems:\n        if e in line.lower():\n            found = True\n            break\n    return found", "code_tokens": "def isin ( elems , line ) : found = False for e in elems : if e in line . lower ( ) : found = True break return found", "docstring_tokens": "Check if an element from a list is in a string .", "label": 0}, {"idx": "cosqa-train-6176", "doc": "strip a character every line and return a list in python", "code": "def split_multiline(value):\n    \"\"\"Split a multiline string into a list, excluding blank lines.\"\"\"\n    return [element for element in (line.strip() for line in value.split('\\n'))\n            if element]", "code_tokens": "def split_multiline ( value ) : return [ element for element in ( line . strip ( ) for line in value . split ( '\\n' ) ) if element ]", "docstring_tokens": "Split a multiline string into a list excluding blank lines .", "label": 0}, {"idx": "cosqa-train-6177", "doc": "python check all elements in list equal", "code": "def _check_elements_equal(lst):\n    \"\"\"\n    Returns true if all of the elements in the list are equal.\n    \"\"\"\n    assert isinstance(lst, list), \"Input value must be a list.\"\n    return not lst or lst.count(lst[0]) == len(lst)", "code_tokens": "def _check_elements_equal ( lst ) : assert isinstance ( lst , list ) , \"Input value must be a list.\" return not lst or lst . count ( lst [ 0 ] ) == len ( lst )", "docstring_tokens": "Returns true if all of the elements in the list are equal .", "label": 1}, {"idx": "cosqa-train-6178", "doc": "strip spaces from a list python", "code": "def strip_spaces(value, sep=None, join=True):\n    \"\"\"Cleans trailing whitespaces and replaces also multiple whitespaces with a single space.\"\"\"\n    value = value.strip()\n    value = [v.strip() for v in value.split(sep)]\n    join_sep = sep or ' '\n    return join_sep.join(value) if join else value", "code_tokens": "def strip_spaces ( value , sep = None , join = True ) : value = value . strip ( ) value = [ v . strip ( ) for v in value . split ( sep ) ] join_sep = sep or ' ' return join_sep . join ( value ) if join else value", "docstring_tokens": "Cleans trailing whitespaces and replaces also multiple whitespaces with a single space .", "label": 0}, {"idx": "cosqa-train-6179", "doc": "python check all elements of nested list", "code": "def empty_tree(input_list):\n    \"\"\"Recursively iterate through values in nested lists.\"\"\"\n    for item in input_list:\n        if not isinstance(item, list) or not empty_tree(item):\n            return False\n    return True", "code_tokens": "def empty_tree ( input_list ) : for item in input_list : if not isinstance ( item , list ) or not empty_tree ( item ) : return False return True", "docstring_tokens": "Recursively iterate through values in nested lists .", "label": 0}, {"idx": "cosqa-train-6180", "doc": "strip spaces from columns in python", "code": "def strip_columns(tab):\n    \"\"\"Strip whitespace from string columns.\"\"\"\n    for colname in tab.colnames:\n        if tab[colname].dtype.kind in ['S', 'U']:\n            tab[colname] = np.core.defchararray.strip(tab[colname])", "code_tokens": "def strip_columns ( tab ) : for colname in tab . colnames : if tab [ colname ] . dtype . kind in [ 'S' , 'U' ] : tab [ colname ] = np . core . defchararray . strip ( tab [ colname ] )", "docstring_tokens": "Strip whitespace from string columns .", "label": 1}, {"idx": "cosqa-train-6181", "doc": "python check element exist", "code": "def is_element_present(driver, selector, by=By.CSS_SELECTOR):\n    \"\"\"\n    Returns whether the specified element selector is present on the page.\n    @Params\n    driver - the webdriver object (required)\n    selector - the locator that is used (required)\n    by - the method to search for the locator (Default: By.CSS_SELECTOR)\n    @Returns\n    Boolean (is element present)\n    \"\"\"\n    try:\n        driver.find_element(by=by, value=selector)\n        return True\n    except Exception:\n        return False", "code_tokens": "def is_element_present ( driver , selector , by = By . CSS_SELECTOR ) : try : driver . find_element ( by = by , value = selector ) return True except Exception : return False", "docstring_tokens": "Returns whether the specified element selector is present on the page .", "label": 1}, {"idx": "cosqa-train-6182", "doc": "strip underscore from strin python", "code": "def camelcase_underscore(name):\n    \"\"\" Convert camelcase names to underscore \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def camelcase_underscore ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert camelcase names to underscore", "label": 0}, {"idx": "cosqa-train-6183", "doc": "python check executione time", "code": "def _uptime_syllable():\n    \"\"\"Returns uptime in seconds or None, on Syllable.\"\"\"\n    global __boottime\n    try:\n        __boottime = os.stat('/dev/pty/mst/pty0').st_mtime\n        return time.time() - __boottime\n    except (NameError, OSError):\n        return None", "code_tokens": "def _uptime_syllable ( ) : global __boottime try : __boottime = os . stat ( '/dev/pty/mst/pty0' ) . st_mtime return time . time ( ) - __boottime except ( NameError , OSError ) : return None", "docstring_tokens": "Returns uptime in seconds or None on Syllable .", "label": 1}, {"idx": "cosqa-train-6184", "doc": "subsetting a python dictionary by keys that have certain values", "code": "def filter_dict(d, keys):\n    \"\"\"\n    Creates a new dict from an existing dict that only has the given keys\n    \"\"\"\n    return {k: v for k, v in d.items() if k in keys}", "code_tokens": "def filter_dict ( d , keys ) : return { k : v for k , v in d . items ( ) if k in keys }", "docstring_tokens": "Creates a new dict from an existing dict that only has the given keys", "label": 1}, {"idx": "cosqa-train-6185", "doc": "python check for valid regex match", "code": "def is_valid_regex(string):\n    \"\"\"\n    Checks whether the re module can compile the given regular expression.\n\n    Parameters\n    ----------\n    string: str\n\n    Returns\n    -------\n    boolean\n    \"\"\"\n    try:\n        re.compile(string)\n        is_valid = True\n    except re.error:\n        is_valid = False\n    return is_valid", "code_tokens": "def is_valid_regex ( string ) : try : re . compile ( string ) is_valid = True except re . error : is_valid = False return is_valid", "docstring_tokens": "Checks whether the re module can compile the given regular expression .", "label": 0}, {"idx": "cosqa-train-6186", "doc": "substitute an empty string for a pattern in python", "code": "def subn_filter(s, find, replace, count=0):\n    \"\"\"A non-optimal implementation of a regex filter\"\"\"\n    return re.gsub(find, replace, count, s)", "code_tokens": "def subn_filter ( s , find , replace , count = 0 ) : return re . gsub ( find , replace , count , s )", "docstring_tokens": "A non - optimal implementation of a regex filter", "label": 0}, {"idx": "cosqa-train-6187", "doc": "python check http 200", "code": "def raise_for_not_ok_status(response):\n    \"\"\"\n    Raises a `requests.exceptions.HTTPError` if the response has a non-200\n    status code.\n    \"\"\"\n    if response.code != OK:\n        raise HTTPError('Non-200 response code (%s) for url: %s' % (\n            response.code, uridecode(response.request.absoluteURI)))\n\n    return response", "code_tokens": "def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response", "docstring_tokens": "Raises a requests . exceptions . HTTPError if the response has a non - 200 status code .", "label": 0}, {"idx": "cosqa-train-6188", "doc": "sum of square components in python", "code": "def ss_tot(self):\n        \"\"\"Total sum of squares.\"\"\"\n        return np.sum(np.square(self.y - self.ybar), axis=0)", "code_tokens": "def ss_tot ( self ) : return np . sum ( np . square ( self . y - self . ybar ) , axis = 0 )", "docstring_tokens": "Total sum of squares .", "label": 0}, {"idx": "cosqa-train-6189", "doc": "python check if an object is numpy array", "code": "def is_integer_array(val):\n    \"\"\"\n    Checks whether a variable is a numpy integer array.\n\n    Parameters\n    ----------\n    val\n        The variable to check.\n\n    Returns\n    -------\n    bool\n        True if the variable is a numpy integer array. Otherwise False.\n\n    \"\"\"\n    return is_np_array(val) and issubclass(val.dtype.type, np.integer)", "code_tokens": "def is_integer_array ( val ) : return is_np_array ( val ) and issubclass ( val . dtype . type , np . integer )", "docstring_tokens": "Checks whether a variable is a numpy integer array .", "label": 0}, {"idx": "cosqa-train-6190", "doc": "syntax for making a list into a string in python", "code": "def list2string (inlist,delimit=' '):\n    \"\"\"\nConverts a 1D list to a single long string for file output, using\nthe string.join function.\n\nUsage:   list2string (inlist,delimit=' ')\nReturns: the string created from inlist\n\"\"\"\n    stringlist = [makestr(_) for _ in inlist]\n    return string.join(stringlist,delimit)", "code_tokens": "def list2string ( inlist , delimit = ' ' ) : stringlist = [ makestr ( _ ) for _ in inlist ] return string . join ( stringlist , delimit )", "docstring_tokens": "Converts a 1D list to a single long string for file output using the string . join function .", "label": 0}, {"idx": "cosqa-train-6191", "doc": "python check if any asyncio jobs are complete", "code": "async def wait_and_quit(loop):\n\t\"\"\"Wait until all task are executed.\"\"\"\n\tfrom pylp.lib.tasks import running\n\tif running:\n\t\tawait asyncio.wait(map(lambda runner: runner.future, running))", "code_tokens": "async def wait_and_quit ( loop ) : from pylp . lib . tasks import running if running : await asyncio . wait ( map ( lambda runner : runner . future , running ) )", "docstring_tokens": "Wait until all task are executed .", "label": 0}, {"idx": "cosqa-train-6192", "doc": "sys stdout python buffer apache slow", "code": "def stdout_display():\n    \"\"\" Print results straight to stdout \"\"\"\n    if sys.version_info[0] == 2:\n        yield SmartBuffer(sys.stdout)\n    else:\n        yield SmartBuffer(sys.stdout.buffer)", "code_tokens": "def stdout_display ( ) : if sys . version_info [ 0 ] == 2 : yield SmartBuffer ( sys . stdout ) else : yield SmartBuffer ( sys . stdout . buffer )", "docstring_tokens": "Print results straight to stdout", "label": 0}, {"idx": "cosqa-train-6193", "doc": "python check if connected to lan", "code": "def we_are_in_lyon():\n    \"\"\"Check if we are on a Lyon machine\"\"\"\n    import socket\n    try:\n        hostname = socket.gethostname()\n        ip = socket.gethostbyname(hostname)\n    except socket.gaierror:\n        return False\n    return ip.startswith(\"134.158.\")", "code_tokens": "def we_are_in_lyon ( ) : import socket try : hostname = socket . gethostname ( ) ip = socket . gethostbyname ( hostname ) except socket . gaierror : return False return ip . startswith ( \"134.158.\" )", "docstring_tokens": "Check if we are on a Lyon machine", "label": 0}, {"idx": "cosqa-train-6194", "doc": "table cell location center python", "code": "def get_tile_location(self, x, y):\n        \"\"\"Get the screen coordinate for the top-left corner of a tile.\"\"\"\n        x1, y1 = self.origin\n        x1 += self.BORDER + (self.BORDER + self.cell_width) * x\n        y1 += self.BORDER + (self.BORDER + self.cell_height) * y\n        return x1, y1", "code_tokens": "def get_tile_location ( self , x , y ) : x1 , y1 = self . origin x1 += self . BORDER + ( self . BORDER + self . cell_width ) * x y1 += self . BORDER + ( self . BORDER + self . cell_height ) * y return x1 , y1", "docstring_tokens": "Get the screen coordinate for the top - left corner of a tile .", "label": 0}, {"idx": "cosqa-train-6195", "doc": "python check if directory is writable", "code": "def _writable_dir(path):\n    \"\"\"Whether `path` is a directory, to which the user has write access.\"\"\"\n    return os.path.isdir(path) and os.access(path, os.W_OK)", "code_tokens": "def _writable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . W_OK )", "docstring_tokens": "Whether path is a directory to which the user has write access .", "label": 1}, {"idx": "cosqa-train-6196", "doc": "python check if empty array", "code": "def contains_empty(features):\n    \"\"\"Check features data are not empty\n\n    :param features: The features data to check.\n    :type features: list of numpy arrays.\n\n    :return: True if one of the array is empty, False else.\n\n    \"\"\"\n    if not features:\n        return True\n    for feature in features:\n        if feature.shape[0] == 0:\n            return True\n    return False", "code_tokens": "def contains_empty ( features ) : if not features : return True for feature in features : if feature . shape [ 0 ] == 0 : return True return False", "docstring_tokens": "Check features data are not empty", "label": 1}, {"idx": "cosqa-train-6197", "doc": "tensorflow python 2 ubuntu", "code": "def tf2():\n  \"\"\"Provide the root module of a TF-2.0 API for use within TensorBoard.\n\n  Returns:\n    The root module of a TF-2.0 API, if available.\n\n  Raises:\n    ImportError: if a TF-2.0 API is not available.\n  \"\"\"\n  # Import the `tf` compat API from this file and check if it's already TF 2.0.\n  if tf.__version__.startswith('2.'):\n    return tf\n  elif hasattr(tf, 'compat') and hasattr(tf.compat, 'v2'):\n    # As a fallback, try `tensorflow.compat.v2` if it's defined.\n    return tf.compat.v2\n  raise ImportError('cannot import tensorflow 2.0 API')", "code_tokens": "def tf2 ( ) : # Import the `tf` compat API from this file and check if it's already TF 2.0. if tf . __version__ . startswith ( '2.' ) : return tf elif hasattr ( tf , 'compat' ) and hasattr ( tf . compat , 'v2' ) : # As a fallback, try `tensorflow.compat.v2` if it's defined. return tf . compat . v2 raise ImportError ( 'cannot import tensorflow 2.0 API' )", "docstring_tokens": "Provide the root module of a TF - 2 . 0 API for use within TensorBoard .", "label": 0}, {"idx": "cosqa-train-6198", "doc": "python check if field name exists", "code": "def has_field(mc, field_name):\n    \"\"\"\n    detect if a model has a given field has\n\n    :param field_name:\n    :param mc:\n    :return:\n    \"\"\"\n    try:\n        mc._meta.get_field(field_name)\n    except FieldDoesNotExist:\n        return False\n    return True", "code_tokens": "def has_field ( mc , field_name ) : try : mc . _meta . get_field ( field_name ) except FieldDoesNotExist : return False return True", "docstring_tokens": "detect if a model has a given field has", "label": 0}, {"idx": "cosqa-train-6199", "doc": "tensorflow set pythonpath is a directory", "code": "def tfds_dir():\n  \"\"\"Path to tensorflow_datasets directory.\"\"\"\n  return os.path.dirname(os.path.dirname(os.path.dirname(__file__)))", "code_tokens": "def tfds_dir ( ) : return os . path . dirname ( os . path . dirname ( os . path . dirname ( __file__ ) ) )", "docstring_tokens": "Path to tensorflow_datasets directory .", "label": 0}, {"idx": "cosqa-train-6200", "doc": "python check if file exists bytes", "code": "def is_binary(filename):\n    \"\"\" Returns True if the file is binary\n\n    \"\"\"\n    with open(filename, 'rb') as fp:\n        data = fp.read(1024)\n        if not data:\n            return False\n        if b'\\0' in data:\n            return True\n        return False", "code_tokens": "def is_binary ( filename ) : with open ( filename , 'rb' ) as fp : data = fp . read ( 1024 ) if not data : return False if b'\\0' in data : return True return False", "docstring_tokens": "Returns True if the file is binary", "label": 0}, {"idx": "cosqa-train-6201", "doc": "terminate windows services with python", "code": "def do_exit(self, arg):\n        \"\"\"Exit the shell session.\"\"\"\n\n        if self.current:\n            self.current.close()\n        self.resource_manager.close()\n        del self.resource_manager\n        return True", "code_tokens": "def do_exit ( self , arg ) : if self . current : self . current . close ( ) self . resource_manager . close ( ) del self . resource_manager return True", "docstring_tokens": "Exit the shell session .", "label": 0}, {"idx": "cosqa-train-6202", "doc": "python check if file is binary file", "code": "def is_binary(filename):\n    \"\"\" Returns True if the file is binary\n\n    \"\"\"\n    with open(filename, 'rb') as fp:\n        data = fp.read(1024)\n        if not data:\n            return False\n        if b'\\0' in data:\n            return True\n        return False", "code_tokens": "def is_binary ( filename ) : with open ( filename , 'rb' ) as fp : data = fp . read ( 1024 ) if not data : return False if b'\\0' in data : return True return False", "docstring_tokens": "Returns True if the file is binary", "label": 1}, {"idx": "cosqa-train-6203", "doc": "test assert type in python", "code": "def _assert_is_type(name, value, value_type):\n    \"\"\"Assert that a value must be a given type.\"\"\"\n    if not isinstance(value, value_type):\n        if type(value_type) is tuple:\n            types = ', '.join(t.__name__ for t in value_type)\n            raise ValueError('{0} must be one of ({1})'.format(name, types))\n        else:\n            raise ValueError('{0} must be {1}'\n                             .format(name, value_type.__name__))", "code_tokens": "def _assert_is_type ( name , value , value_type ) : if not isinstance ( value , value_type ) : if type ( value_type ) is tuple : types = ', ' . join ( t . __name__ for t in value_type ) raise ValueError ( '{0} must be one of ({1})' . format ( name , types ) ) else : raise ValueError ( '{0} must be {1}' . format ( name , value_type . __name__ ) )", "docstring_tokens": "Assert that a value must be a given type .", "label": 0}, {"idx": "cosqa-train-6204", "doc": "python check if http port is listening", "code": "def is_http_running_on(port):\n  \"\"\" Check if an http server runs on a given port.\n\n  Args:\n    The port to check.\n  Returns:\n    True if it is used by an http server. False otherwise.\n  \"\"\"\n  try:\n    conn = httplib.HTTPConnection('127.0.0.1:' + str(port))\n    conn.connect()\n    conn.close()\n    return True\n  except Exception:\n    return False", "code_tokens": "def is_http_running_on ( port ) : try : conn = httplib . HTTPConnection ( '127.0.0.1:' + str ( port ) ) conn . connect ( ) conn . close ( ) return True except Exception : return False", "docstring_tokens": "Check if an http server runs on a given port .", "label": 1}, {"idx": "cosqa-train-6205", "doc": "test for membership in an enum python", "code": "def has_value_name(self, name):\n        \"\"\"Check if this `enum` has a particular name among its values.\n\n        :param name: Enumeration value name\n        :type name: str\n        :rtype: True if there is an enumeration value with the given name\n        \"\"\"\n        for val, _ in self._values:\n            if val == name:\n                return True\n        return False", "code_tokens": "def has_value_name ( self , name ) : for val , _ in self . _values : if val == name : return True return False", "docstring_tokens": "Check if this enum has a particular name among its values .", "label": 0}, {"idx": "cosqa-train-6206", "doc": "testing whether python is in your path", "code": "def launched():\n    \"\"\"Test whether the current python environment is the correct lore env.\n\n    :return:  :any:`True` if the environment is launched\n    :rtype: bool\n    \"\"\"\n    if not PREFIX:\n        return False\n\n    return os.path.realpath(sys.prefix) == os.path.realpath(PREFIX)", "code_tokens": "def launched ( ) : if not PREFIX : return False return os . path . realpath ( sys . prefix ) == os . path . realpath ( PREFIX )", "docstring_tokens": "Test whether the current python environment is the correct lore env .", "label": 0}, {"idx": "cosqa-train-6207", "doc": "python check if it is a datetime object", "code": "def _datetime_to_date(arg):\n    \"\"\"\n    convert datetime/str to date\n    :param arg:\n    :return:\n    \"\"\"\n    _arg = parse(arg)\n    if isinstance(_arg, datetime.datetime):\n        _arg = _arg.date()\n    return _arg", "code_tokens": "def _datetime_to_date ( arg ) : _arg = parse ( arg ) if isinstance ( _arg , datetime . datetime ) : _arg = _arg . date ( ) return _arg", "docstring_tokens": "convert datetime / str to date : param arg : : return :", "label": 0}, {"idx": "cosqa-train-6208", "doc": "the days to the end of the quarter python", "code": "def this_quarter():\n        \"\"\" Return start and end date of this quarter. \"\"\"\n        since = TODAY + delta(day=1)\n        while since.month % 3 != 0:\n            since -= delta(months=1)\n        until = since + delta(months=3)\n        return Date(since), Date(until)", "code_tokens": "def this_quarter ( ) : since = TODAY + delta ( day = 1 ) while since . month % 3 != 0 : since -= delta ( months = 1 ) until = since + delta ( months = 3 ) return Date ( since ) , Date ( until )", "docstring_tokens": "Return start and end date of this quarter .", "label": 1}, {"idx": "cosqa-train-6209", "doc": "python check if iter last", "code": "def iter_with_last(iterable):\n    \"\"\"\n    :return: generator of tuples (isLastFlag, item)\n    \"\"\"\n    # Ensure it's an iterator and get the first field\n    iterable = iter(iterable)\n    prev = next(iterable)\n    for item in iterable:\n        # Lag by one item so I know I'm not at the end\n        yield False, prev\n        prev = item\n    # Last item\n    yield True, prev", "code_tokens": "def iter_with_last ( iterable ) : # Ensure it's an iterator and get the first field iterable = iter ( iterable ) prev = next ( iterable ) for item in iterable : # Lag by one item so I know I'm not at the end yield False , prev prev = item # Last item yield True , prev", "docstring_tokens": ": return : generator of tuples ( isLastFlag item )", "label": 0}, {"idx": "cosqa-train-6210", "doc": "thread safe singleton python", "code": "def singleton(class_):\n    \"\"\"Singleton definition.\n\n    Method 1 from\n    https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python\n    \"\"\"\n    instances = {}\n\n    def get_instance(*args, **kwargs):\n        if class_ not in instances:\n            instances[class_] = class_(*args, **kwargs)\n        return instances[class_]\n    return get_instance", "code_tokens": "def singleton ( class_ ) : instances = { } def get_instance ( * args , * * kwargs ) : if class_ not in instances : instances [ class_ ] = class_ ( * args , * * kwargs ) return instances [ class_ ] return get_instance", "docstring_tokens": "Singleton definition .", "label": 0}, {"idx": "cosqa-train-6211", "doc": "python check if json element exists", "code": "def task_property_present_predicate(service, task, prop):\n    \"\"\" True if the json_element passed is present for the task specified.\n    \"\"\"\n    try:\n        response = get_service_task(service, task)\n    except Exception as e:\n        pass\n\n    return (response is not None) and (prop in response)", "code_tokens": "def task_property_present_predicate ( service , task , prop ) : try : response = get_service_task ( service , task ) except Exception as e : pass return ( response is not None ) and ( prop in response )", "docstring_tokens": "True if the json_element passed is present for the task specified .", "label": 1}, {"idx": "cosqa-train-6212", "doc": "time the execution of python query", "code": "def querySQL(self, sql, args=()):\n        \"\"\"For use with SELECT (or SELECT-like PRAGMA) statements.\n        \"\"\"\n        if self.debug:\n            result = timeinto(self.queryTimes, self._queryandfetch, sql, args)\n        else:\n            result = self._queryandfetch(sql, args)\n        return result", "code_tokens": "def querySQL ( self , sql , args = ( ) ) : if self . debug : result = timeinto ( self . queryTimes , self . _queryandfetch , sql , args ) else : result = self . _queryandfetch ( sql , args ) return result", "docstring_tokens": "For use with SELECT ( or SELECT - like PRAGMA ) statements .", "label": 1}, {"idx": "cosqa-train-6213", "doc": "python check if list contains nested list", "code": "def empty_tree(input_list):\n    \"\"\"Recursively iterate through values in nested lists.\"\"\"\n    for item in input_list:\n        if not isinstance(item, list) or not empty_tree(item):\n            return False\n    return True", "code_tokens": "def empty_tree ( input_list ) : for item in input_list : if not isinstance ( item , list ) or not empty_tree ( item ) : return False return True", "docstring_tokens": "Recursively iterate through values in nested lists .", "label": 0}, {"idx": "cosqa-train-6214", "doc": "to print tht top element in queue in python", "code": "def get_top_priority(self):\n        \"\"\"Pops the element that has the top (smallest) priority.\n\n        :returns: element with the top (smallest) priority.\n        :raises: IndexError -- Priority queue is empty.\n\n        \"\"\"\n        if self.is_empty():\n            raise IndexError(\"Priority queue is empty.\")\n        _, _, element = heapq.heappop(self.pq)\n        if element in self.element_finder:\n            del self.element_finder[element]\n        return element", "code_tokens": "def get_top_priority ( self ) : if self . is_empty ( ) : raise IndexError ( \"Priority queue is empty.\" ) _ , _ , element = heapq . heappop ( self . pq ) if element in self . element_finder : del self . element_finder [ element ] return element", "docstring_tokens": "Pops the element that has the top ( smallest ) priority .", "label": 0}, {"idx": "cosqa-train-6215", "doc": "python check if list object has attribute", "code": "def is_list_of_ipachars(obj):\n    \"\"\"\n    Return ``True`` if the given object is a list of IPAChar objects.\n\n    :param object obj: the object to test\n    :rtype: bool\n    \"\"\"\n    if isinstance(obj, list):\n        for e in obj:\n            if not isinstance(e, IPAChar):\n                return False\n        return True\n    return False", "code_tokens": "def is_list_of_ipachars ( obj ) : if isinstance ( obj , list ) : for e in obj : if not isinstance ( e , IPAChar ) : return False return True return False", "docstring_tokens": "Return True if the given object is a list of IPAChar objects .", "label": 0}, {"idx": "cosqa-train-6216", "doc": "to remove duplicate elements in list in python", "code": "def unique(list):\n    \"\"\" Returns a copy of the list without duplicates.\n    \"\"\"\n    unique = []; [unique.append(x) for x in list if x not in unique]\n    return unique", "code_tokens": "def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique", "docstring_tokens": "Returns a copy of the list without duplicates .", "label": 0}, {"idx": "cosqa-train-6217", "doc": "python check if numerical type", "code": "def is_numeric_dtype(dtype):\n    \"\"\"Return ``True`` if ``dtype`` is a numeric type.\"\"\"\n    dtype = np.dtype(dtype)\n    return np.issubsctype(getattr(dtype, 'base', None), np.number)", "code_tokens": "def is_numeric_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . number )", "docstring_tokens": "Return True if dtype is a numeric type .", "label": 1}, {"idx": "cosqa-train-6218", "doc": "to timestamp from milliseconds python", "code": "def ms_to_datetime(ms):\n    \"\"\"\n    Converts a millisecond accuracy timestamp to a datetime\n    \"\"\"\n    dt = datetime.datetime.utcfromtimestamp(ms / 1000)\n    return dt.replace(microsecond=(ms % 1000) * 1000).replace(tzinfo=pytz.utc)", "code_tokens": "def ms_to_datetime ( ms ) : dt = datetime . datetime . utcfromtimestamp ( ms / 1000 ) return dt . replace ( microsecond = ( ms % 1000 ) * 1000 ) . replace ( tzinfo = pytz . utc )", "docstring_tokens": "Converts a millisecond accuracy timestamp to a datetime", "label": 0}, {"idx": "cosqa-train-6219", "doc": "python check if provess os listening", "code": "def _stdin_ready_posix():\n    \"\"\"Return True if there's something to read on stdin (posix version).\"\"\"\n    infds, outfds, erfds = select.select([sys.stdin],[],[],0)\n    return bool(infds)", "code_tokens": "def _stdin_ready_posix ( ) : infds , outfds , erfds = select . select ( [ sys . stdin ] , [ ] , [ ] , 0 ) return bool ( infds )", "docstring_tokens": "Return True if there s something to read on stdin ( posix version ) .", "label": 0}, {"idx": "cosqa-train-6220", "doc": "token for token in tokenize(lines) in python", "code": "def listified_tokenizer(source):\n    \"\"\"Tokenizes *source* and returns the tokens as a list of lists.\"\"\"\n    io_obj = io.StringIO(source)\n    return [list(a) for a in tokenize.generate_tokens(io_obj.readline)]", "code_tokens": "def listified_tokenizer ( source ) : io_obj = io . StringIO ( source ) return [ list ( a ) for a in tokenize . generate_tokens ( io_obj . readline ) ]", "docstring_tokens": "Tokenizes * source * and returns the tokens as a list of lists .", "label": 1}, {"idx": "cosqa-train-6221", "doc": "python check if stdout is a file", "code": "def _using_stdout(self):\n        \"\"\"\n        Return whether the handler is using sys.stdout.\n        \"\"\"\n        if WINDOWS and colorama:\n            # Then self.stream is an AnsiToWin32 object.\n            return self.stream.wrapped is sys.stdout\n\n        return self.stream is sys.stdout", "code_tokens": "def _using_stdout ( self ) : if WINDOWS and colorama : # Then self.stream is an AnsiToWin32 object. return self . stream . wrapped is sys . stdout return self . stream is sys . stdout", "docstring_tokens": "Return whether the handler is using sys . stdout .", "label": 0}, {"idx": "cosqa-train-6222", "doc": "tokenize items in list to list of lists python", "code": "def tokenize_list(self, text):\n        \"\"\"\n        Split a text into separate words.\n        \"\"\"\n        return [self.get_record_token(record) for record in self.analyze(text)]", "code_tokens": "def tokenize_list ( self , text ) : return [ self . get_record_token ( record ) for record in self . analyze ( text ) ]", "docstring_tokens": "Split a text into separate words .", "label": 0}, {"idx": "cosqa-train-6223", "doc": "python check if string is bytes type", "code": "def isstring(value):\n    \"\"\"Report whether the given value is a byte or unicode string.\"\"\"\n    classes = (str, bytes) if pyutils.PY3 else basestring  # noqa: F821\n    return isinstance(value, classes)", "code_tokens": "def isstring ( value ) : classes = ( str , bytes ) if pyutils . PY3 else basestring # noqa: F821 return isinstance ( value , classes )", "docstring_tokens": "Report whether the given value is a byte or unicode string .", "label": 0}, {"idx": "cosqa-train-6224", "doc": "total milliseconds datetime python", "code": "def datetime_to_ms(dt):\n    \"\"\"\n    Converts a datetime to a millisecond accuracy timestamp\n    \"\"\"\n    seconds = calendar.timegm(dt.utctimetuple())\n    return seconds * 1000 + int(dt.microsecond / 1000)", "code_tokens": "def datetime_to_ms ( dt ) : seconds = calendar . timegm ( dt . utctimetuple ( ) ) return seconds * 1000 + int ( dt . microsecond / 1000 )", "docstring_tokens": "Converts a datetime to a millisecond accuracy timestamp", "label": 0}, {"idx": "cosqa-train-6225", "doc": "python check if string is hex", "code": "def is_hex_string(string):\n    \"\"\"Check if the string is only composed of hex characters.\"\"\"\n    pattern = re.compile(r'[A-Fa-f0-9]+')\n    if isinstance(string, six.binary_type):\n        string = str(string)\n    return pattern.match(string) is not None", "code_tokens": "def is_hex_string ( string ) : pattern = re . compile ( r'[A-Fa-f0-9]+' ) if isinstance ( string , six . binary_type ) : string = str ( string ) return pattern . match ( string ) is not None", "docstring_tokens": "Check if the string is only composed of hex characters .", "label": 0}, {"idx": "cosqa-train-6226", "doc": "treeview not selectable python tkinter", "code": "def register_view(self, view):\n        \"\"\"Register callbacks for button press events and selection changed\"\"\"\n        super(ListViewController, self).register_view(view)\n        self.tree_view.connect('button_press_event', self.mouse_click)", "code_tokens": "def register_view ( self , view ) : super ( ListViewController , self ) . register_view ( view ) self . tree_view . connect ( 'button_press_event' , self . mouse_click )", "docstring_tokens": "Register callbacks for button press events and selection changed", "label": 0}, {"idx": "cosqa-train-6227", "doc": "python check if two strings match case sensitivity", "code": "def _match_literal(self, a, b=None):\n        \"\"\"Match two names.\"\"\"\n\n        return a.lower() == b if not self.case_sensitive else a == b", "code_tokens": "def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b", "docstring_tokens": "Match two names .", "label": 1}, {"idx": "cosqa-train-6228", "doc": "trim spaces string python", "code": "def slugify(string):\n    \"\"\"\n    Removes non-alpha characters, and converts spaces to hyphens. Useful for making file names.\n\n\n    Source: http://stackoverflow.com/questions/5574042/string-slugification-in-python\n    \"\"\"\n    string = re.sub('[^\\w .-]', '', string)\n    string = string.replace(\" \", \"-\")\n    return string", "code_tokens": "def slugify ( string ) : string = re . sub ( '[^\\w .-]' , '' , string ) string = string . replace ( \" \" , \"-\" ) return string", "docstring_tokens": "Removes non - alpha characters and converts spaces to hyphens . Useful for making file names . Source : http : // stackoverflow . com / questions / 5574042 / string - slugification - in - python", "label": 0}, {"idx": "cosqa-train-6229", "doc": "python check if value is integer or string json", "code": "def default_number_converter(number_str):\n    \"\"\"\n    Converts the string representation of a json number into its python object equivalent, an\n    int, long, float or whatever type suits.\n    \"\"\"\n    is_int = (number_str.startswith('-') and number_str[1:].isdigit()) or number_str.isdigit()\n    # FIXME: this handles a wider range of numbers than allowed by the json standard,\n    # etc.: float('nan') and float('inf'). But is this a problem?\n    return int(number_str) if is_int else float(number_str)", "code_tokens": "def default_number_converter ( number_str ) : is_int = ( number_str . startswith ( '-' ) and number_str [ 1 : ] . isdigit ( ) ) or number_str . isdigit ( ) # FIXME: this handles a wider range of numbers than allowed by the json standard, # etc.: float('nan') and float('inf'). But is this a problem? return int ( number_str ) if is_int else float ( number_str )", "docstring_tokens": "Converts the string representation of a json number into its python object equivalent an int long float or whatever type suits .", "label": 0}, {"idx": "cosqa-train-6230", "doc": "try multiple encodings pythons while opening a file", "code": "def _open_text(fname, **kwargs):\n    \"\"\"On Python 3 opens a file in text mode by using fs encoding and\n    a proper en/decoding errors handler.\n    On Python 2 this is just an alias for open(name, 'rt').\n    \"\"\"\n    if PY3:\n        kwargs.setdefault('encoding', ENCODING)\n        kwargs.setdefault('errors', ENCODING_ERRS)\n    return open(fname, \"rt\", **kwargs)", "code_tokens": "def _open_text ( fname , * * kwargs ) : if PY3 : kwargs . setdefault ( 'encoding' , ENCODING ) kwargs . setdefault ( 'errors' , ENCODING_ERRS ) return open ( fname , \"rt\" , * * kwargs )", "docstring_tokens": "On Python 3 opens a file in text mode by using fs encoding and a proper en / decoding errors handler . On Python 2 this is just an alias for open ( name rt ) .", "label": 0}, {"idx": "cosqa-train-6231", "doc": "python check if window is active win32", "code": "def get_active_window():\n    \"\"\"Get the currently focused window\n    \"\"\"\n    active_win = None\n    default = wnck.screen_get_default()\n    while gtk.events_pending():\n        gtk.main_iteration(False)\n    window_list = default.get_windows()\n    if len(window_list) == 0:\n        print \"No Windows Found\"\n    for win in window_list:\n        if win.is_active():\n            active_win = win.get_name()\n    return active_win", "code_tokens": "def get_active_window ( ) : active_win = None default = wnck . screen_get_default ( ) while gtk . events_pending ( ) : gtk . main_iteration ( False ) window_list = default . get_windows ( ) if len ( window_list ) == 0 : print \"No Windows Found\" for win in window_list : if win . is_active ( ) : active_win = win . get_name ( ) return active_win", "docstring_tokens": "Get the currently focused window", "label": 0}, {"idx": "cosqa-train-6232", "doc": "turn a string to a datetime object python", "code": "def parse_datetime(dt_str):\n    \"\"\"Parse datetime.\"\"\"\n    date_format = \"%Y-%m-%dT%H:%M:%S %z\"\n    dt_str = dt_str.replace(\"Z\", \" +0000\")\n    return datetime.datetime.strptime(dt_str, date_format)", "code_tokens": "def parse_datetime ( dt_str ) : date_format = \"%Y-%m-%dT%H:%M:%S %z\" dt_str = dt_str . replace ( \"Z\" , \" +0000\" ) return datetime . datetime . strptime ( dt_str , date_format )", "docstring_tokens": "Parse datetime .", "label": 1}, {"idx": "cosqa-train-6233", "doc": "python check in value in tuple or list", "code": "def is_list_of_list(item):\n    \"\"\"\n    check whether the item is list (tuple)\n    and consist of list (tuple) elements\n    \"\"\"\n    if (\n        type(item) in (list, tuple)\n        and len(item)\n        and isinstance(item[0], (list, tuple))\n    ):\n        return True\n    return False", "code_tokens": "def is_list_of_list ( item ) : if ( type ( item ) in ( list , tuple ) and len ( item ) and isinstance ( item [ 0 ] , ( list , tuple ) ) ) : return True return False", "docstring_tokens": "check whether the item is list ( tuple ) and consist of list ( tuple ) elements", "label": 0}, {"idx": "cosqa-train-6234", "doc": "turn array into a table python", "code": "def from_array(cls, arr):\n        \"\"\"Convert a structured NumPy array into a Table.\"\"\"\n        return cls().with_columns([(f, arr[f]) for f in arr.dtype.names])", "code_tokens": "def from_array ( cls , arr ) : return cls ( ) . with_columns ( [ ( f , arr [ f ] ) for f in arr . dtype . names ] )", "docstring_tokens": "Convert a structured NumPy array into a Table .", "label": 0}, {"idx": "cosqa-train-6235", "doc": "python check instance is number", "code": "def is_integer(obj):\n    \"\"\"Is this an integer.\n\n    :param object obj:\n    :return:\n    \"\"\"\n    if PYTHON3:\n        return isinstance(obj, int)\n    return isinstance(obj, (int, long))", "code_tokens": "def is_integer ( obj ) : if PYTHON3 : return isinstance ( obj , int ) return isinstance ( obj , ( int , long ) )", "docstring_tokens": "Is this an integer .", "label": 0}, {"idx": "cosqa-train-6236", "doc": "turn comma separated string to list python", "code": "def _str_to_list(s):\n    \"\"\"Converts a comma separated string to a list\"\"\"\n    _list = s.split(\",\")\n    return list(map(lambda i: i.lstrip(), _list))", "code_tokens": "def _str_to_list ( s ) : _list = s . split ( \",\" ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )", "docstring_tokens": "Converts a comma separated string to a list", "label": 0}, {"idx": "cosqa-train-6237", "doc": "python check is file executable", "code": "def is_executable(path):\n  \"\"\"Returns whether a path names an existing executable file.\"\"\"\n  return os.path.isfile(path) and os.access(path, os.X_OK)", "code_tokens": "def is_executable ( path ) : return os . path . isfile ( path ) and os . access ( path , os . X_OK )", "docstring_tokens": "Returns whether a path names an existing executable file .", "label": 1}, {"idx": "cosqa-train-6238", "doc": "turn csv into a list of strings python 3", "code": "def csvtolist(inputstr):\n    \"\"\" converts a csv string into a list \"\"\"\n    reader = csv.reader([inputstr], skipinitialspace=True)\n    output = []\n    for r in reader:\n        output += r\n    return output", "code_tokens": "def csvtolist ( inputstr ) : reader = csv . reader ( [ inputstr ] , skipinitialspace = True ) output = [ ] for r in reader : output += r return output", "docstring_tokens": "converts a csv string into a list", "label": 0}, {"idx": "cosqa-train-6239", "doc": "python check is numpy array or list", "code": "def is_iterable(value):\n    \"\"\"must be an iterable (list, array, tuple)\"\"\"\n    return isinstance(value, np.ndarray) or isinstance(value, list) or isinstance(value, tuple), value", "code_tokens": "def is_iterable ( value ) : return isinstance ( value , np . ndarray ) or isinstance ( value , list ) or isinstance ( value , tuple ) , value", "docstring_tokens": "must be an iterable ( list array tuple )", "label": 1}, {"idx": "cosqa-train-6240", "doc": "turn object into list in python", "code": "def as_list(self):\n        \"\"\"Return all child objects in nested lists of strings.\"\"\"\n        return [self.name, self.value, [x.as_list for x in self.children]]", "code_tokens": "def as_list ( self ) : return [ self . name , self . value , [ x . as_list for x in self . children ] ]", "docstring_tokens": "Return all child objects in nested lists of strings .", "label": 0}, {"idx": "cosqa-train-6241", "doc": "python check kernel memory", "code": "def get_free_memory_win():\n    \"\"\"Return current free memory on the machine for windows.\n\n    Warning : this script is really not robust\n    Return in MB unit\n    \"\"\"\n    stat = MEMORYSTATUSEX()\n    ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(stat))\n    return int(stat.ullAvailPhys / 1024 / 1024)", "code_tokens": "def get_free_memory_win ( ) : stat = MEMORYSTATUSEX ( ) ctypes . windll . kernel32 . GlobalMemoryStatusEx ( ctypes . byref ( stat ) ) return int ( stat . ullAvailPhys / 1024 / 1024 )", "docstring_tokens": "Return current free memory on the machine for windows .", "label": 1}, {"idx": "cosqa-train-6242", "doc": "turning a read file into string in python", "code": "def file_to_str(fname):\n    \"\"\"\n    Read a file into a string\n    PRE: fname is a small file (to avoid hogging memory and its discontents)\n    \"\"\"\n    data = None\n    # rU = read with Universal line terminator\n    with open(fname, 'rU') as fd:\n        data = fd.read()\n    return data", "code_tokens": "def file_to_str ( fname ) : data = None # rU = read with Universal line terminator with open ( fname , 'rU' ) as fd : data = fd . read ( ) return data", "docstring_tokens": "Read a file into a string PRE : fname is a small file ( to avoid hogging memory and its discontents )", "label": 0}, {"idx": "cosqa-train-6243", "doc": "python check match regardless uppercase", "code": "def _match_literal(self, a, b=None):\n        \"\"\"Match two names.\"\"\"\n\n        return a.lower() == b if not self.case_sensitive else a == b", "code_tokens": "def _match_literal ( self , a , b = None ) : return a . lower ( ) == b if not self . case_sensitive else a == b", "docstring_tokens": "Match two names .", "label": 0}, {"idx": "cosqa-train-6244", "doc": "turning string to float and detection python", "code": "def covstr(s):\n  \"\"\" convert string to int or float. \"\"\"\n  try:\n    ret = int(s)\n  except ValueError:\n    ret = float(s)\n  return ret", "code_tokens": "def covstr ( s ) : try : ret = int ( s ) except ValueError : ret = float ( s ) return ret", "docstring_tokens": "convert string to int or float .", "label": 0}, {"idx": "cosqa-train-6245", "doc": "python check matrix invertible", "code": "def is_square_matrix(mat):\n    \"\"\"Test if an array is a square matrix.\"\"\"\n    mat = np.array(mat)\n    if mat.ndim != 2:\n        return False\n    shape = mat.shape\n    return shape[0] == shape[1]", "code_tokens": "def is_square_matrix ( mat ) : mat = np . array ( mat ) if mat . ndim != 2 : return False shape = mat . shape return shape [ 0 ] == shape [ 1 ]", "docstring_tokens": "Test if an array is a square matrix .", "label": 0}, {"idx": "cosqa-train-6246", "doc": "type casting in python to string", "code": "def to_str(obj):\n    \"\"\"Attempts to convert given object to a string object\n    \"\"\"\n    if not isinstance(obj, str) and PY3 and isinstance(obj, bytes):\n        obj = obj.decode('utf-8')\n    return obj if isinstance(obj, string_types) else str(obj)", "code_tokens": "def to_str ( obj ) : if not isinstance ( obj , str ) and PY3 and isinstance ( obj , bytes ) : obj = obj . decode ( 'utf-8' ) return obj if isinstance ( obj , string_types ) else str ( obj )", "docstring_tokens": "Attempts to convert given object to a string object", "label": 0}, {"idx": "cosqa-train-6247", "doc": "python check type in list comprehension", "code": "def _valid_other_type(x, types):\n    \"\"\"\n    Do all elements of x have a type from types?\n    \"\"\"\n    return all(any(isinstance(el, t) for t in types) for el in np.ravel(x))", "code_tokens": "def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )", "docstring_tokens": "Do all elements of x have a type from types?", "label": 0}, {"idx": "cosqa-train-6248", "doc": "typecast to string python", "code": "def bytes_to_str(s, encoding='utf-8'):\n    \"\"\"Returns a str if a bytes object is given.\"\"\"\n    if six.PY3 and isinstance(s, bytes):\n        return s.decode(encoding)\n    return s", "code_tokens": "def bytes_to_str ( s , encoding = 'utf-8' ) : if six . PY3 and isinstance ( s , bytes ) : return s . decode ( encoding ) return s", "docstring_tokens": "Returns a str if a bytes object is given .", "label": 0}, {"idx": "cosqa-train-6249", "doc": "python check url working", "code": "def _is_valid_url(self, url):\n        \"\"\"Callback for is_valid_url.\"\"\"\n        try:\n            r = requests.head(url, proxies=self.proxy_servers)\n            value = r.status_code in [200]\n        except Exception as error:\n            logger.error(str(error))\n            value = False\n\n        return value", "code_tokens": "def _is_valid_url ( self , url ) : try : r = requests . head ( url , proxies = self . proxy_servers ) value = r . status_code in [ 200 ] except Exception as error : logger . error ( str ( error ) ) value = False return value", "docstring_tokens": "Callback for is_valid_url .", "label": 0}, {"idx": "cosqa-train-6250", "doc": "undefiened counter in python veribwl", "code": "def counter(items):\n    \"\"\"\n    Simplest required implementation of collections.Counter. Required as 2.6\n    does not have Counter in collections.\n    \"\"\"\n    results = {}\n    for item in items:\n        results[item] = results.get(item, 0) + 1\n    return results", "code_tokens": "def counter ( items ) : results = { } for item in items : results [ item ] = results . get ( item , 0 ) + 1 return results", "docstring_tokens": "Simplest required implementation of collections . Counter . Required as 2 . 6 does not have Counter in collections .", "label": 0}, {"idx": "cosqa-train-6251", "doc": "python check whether a datatype is numerical", "code": "def is_numeric_dtype(dtype):\n    \"\"\"Return ``True`` if ``dtype`` is a numeric type.\"\"\"\n    dtype = np.dtype(dtype)\n    return np.issubsctype(getattr(dtype, 'base', None), np.number)", "code_tokens": "def is_numeric_dtype ( dtype ) : dtype = np . dtype ( dtype ) return np . issubsctype ( getattr ( dtype , 'base' , None ) , np . number )", "docstring_tokens": "Return True if dtype is a numeric type .", "label": 0}, {"idx": "cosqa-train-6252", "doc": "python checking if something is a directory", "code": "def isdir(s):\n    \"\"\"Return true if the pathname refers to an existing directory.\"\"\"\n    try:\n        st = os.stat(s)\n    except os.error:\n        return False\n    return stat.S_ISDIR(st.st_mode)", "code_tokens": "def isdir ( s ) : try : st = os . stat ( s ) except os . error : return False return stat . S_ISDIR ( st . st_mode )", "docstring_tokens": "Return true if the pathname refers to an existing directory .", "label": 1}, {"idx": "cosqa-train-6253", "doc": "unzipping multiple zip files in python", "code": "def extract_all(zipfile, dest_folder):\n    \"\"\"\n    reads the zip file, determines compression\n    and unzips recursively until source files \n    are extracted \n    \"\"\"\n    z = ZipFile(zipfile)\n    print(z)\n    z.extract(dest_folder)", "code_tokens": "def extract_all ( zipfile , dest_folder ) : z = ZipFile ( zipfile ) print ( z ) z . extract ( dest_folder )", "docstring_tokens": "reads the zip file determines compression and unzips recursively until source files are extracted", "label": 0}, {"idx": "cosqa-train-6254", "doc": "python checking object for attributes", "code": "def hasattrs(object, *names):\n    \"\"\"\n    Takes in an object and a variable length amount of named attributes,\n    and checks to see if the object has each property. If any of the\n    attributes are missing, this returns false.\n\n    :param object: an object that may or may not contain the listed attributes\n    :param names: a variable amount of attribute names to check for\n    :return: True if the object contains each named attribute, false otherwise\n    \"\"\"\n    for name in names:\n        if not hasattr(object, name):\n            return False\n    return True", "code_tokens": "def hasattrs ( object , * names ) : for name in names : if not hasattr ( object , name ) : return False return True", "docstring_tokens": "Takes in an object and a variable length amount of named attributes and checks to see if the object has each property . If any of the attributes are missing this returns false .", "label": 0}, {"idx": "cosqa-train-6255", "doc": "updatating plot object inline python juypter", "code": "def _push_render(self):\n        \"\"\"Render the plot with bokeh.io and push to notebook.\n        \"\"\"\n        bokeh.io.push_notebook(handle=self.handle)\n        self.last_update = time.time()", "code_tokens": "def _push_render ( self ) : bokeh . io . push_notebook ( handle = self . handle ) self . last_update = time . time ( )", "docstring_tokens": "Render the plot with bokeh . io and push to notebook .", "label": 1}, {"idx": "cosqa-train-6256", "doc": "python chmod read and write", "code": "def make_writeable(filename):\n    \"\"\"\n    Make sure that the file is writeable.\n    Useful if our source is read-only.\n    \"\"\"\n    if not os.access(filename, os.W_OK):\n        st = os.stat(filename)\n        new_permissions = stat.S_IMODE(st.st_mode) | stat.S_IWUSR\n        os.chmod(filename, new_permissions)", "code_tokens": "def make_writeable ( filename ) : if not os . access ( filename , os . W_OK ) : st = os . stat ( filename ) new_permissions = stat . S_IMODE ( st . st_mode ) | stat . S_IWUSR os . chmod ( filename , new_permissions )", "docstring_tokens": "Make sure that the file is writeable . Useful if our source is read - only .", "label": 0}, {"idx": "cosqa-train-6257", "doc": "update parent from child python", "code": "def add_parent(self, parent):\n        \"\"\"\n        Adds self as child of parent, then adds parent.\n        \"\"\"\n        parent.add_child(self)\n        self.parent = parent\n        return parent", "code_tokens": "def add_parent ( self , parent ) : parent . add_child ( self ) self . parent = parent return parent", "docstring_tokens": "Adds self as child of parent then adds parent .", "label": 1}, {"idx": "cosqa-train-6258", "doc": "python choose best object with attribute closest", "code": "def find_object(self, object_type):\n        \"\"\"Finds the closest object of a given type.\"\"\"\n        node = self\n        while node is not None:\n            if isinstance(node.obj, object_type):\n                return node.obj\n            node = node.parent", "code_tokens": "def find_object ( self , object_type ) : node = self while node is not None : if isinstance ( node . obj , object_type ) : return node . obj node = node . parent", "docstring_tokens": "Finds the closest object of a given type .", "label": 1}, {"idx": "cosqa-train-6259", "doc": "updating mongo field with large dictionary from python", "code": "def update_one(self, query, doc):\n        \"\"\"\n        Updates one element of the collection\n\n        :param query: dictionary representing the mongo query\n        :param doc: dictionary representing the item to be updated\n        :return: UpdateResult\n        \"\"\"\n        if self.table is None:\n            self.build_table()\n\n        if u\"$set\" in doc:\n            doc = doc[u\"$set\"]\n\n        allcond = self.parse_query(query)\n\n        try:\n            result = self.table.update(doc, allcond)\n        except:\n            # TODO: check table.update result\n            # check what pymongo does in that case\n            result = None\n\n        return UpdateResult(raw_result=result)", "code_tokens": "def update_one ( self , query , doc ) : if self . table is None : self . build_table ( ) if u\"$set\" in doc : doc = doc [ u\"$set\" ] allcond = self . parse_query ( query ) try : result = self . table . update ( doc , allcond ) except : # TODO: check table.update result # check what pymongo does in that case result = None return UpdateResult ( raw_result = result )", "docstring_tokens": "Updates one element of the collection", "label": 0}, {"idx": "cosqa-train-6260", "doc": "python chunked md5 sum save memory", "code": "def file_md5sum(filename):\n    \"\"\"\n    :param filename: The filename of the file to process\n    :returns: The MD5 hash of the file\n    \"\"\"\n    hash_md5 = hashlib.md5()\n    with open(filename, 'rb') as f:\n        for chunk in iter(lambda: f.read(1024 * 4), b''):\n            hash_md5.update(chunk)\n    return hash_md5.hexdigest()", "code_tokens": "def file_md5sum ( filename ) : hash_md5 = hashlib . md5 ( ) with open ( filename , 'rb' ) as f : for chunk in iter ( lambda : f . read ( 1024 * 4 ) , b'' ) : hash_md5 . update ( chunk ) return hash_md5 . hexdigest ( )", "docstring_tokens": ": param filename : The filename of the file to process : returns : The MD5 hash of the file", "label": 1}, {"idx": "cosqa-train-6261", "doc": "upper case in a list python", "code": "def upcaseTokens(s,l,t):\n    \"\"\"Helper parse action to convert tokens to upper case.\"\"\"\n    return [ tt.upper() for tt in map(_ustr,t) ]", "code_tokens": "def upcaseTokens ( s , l , t ) : return [ tt . upper ( ) for tt in map ( _ustr , t ) ]", "docstring_tokens": "Helper parse action to convert tokens to upper case .", "label": 0}, {"idx": "cosqa-train-6262", "doc": "python clear a certain y axis plot", "code": "def axes_off(ax):\n    \"\"\"Get rid of all axis ticks, lines, etc.\n    \"\"\"\n    ax.set_frame_on(False)\n    ax.axes.get_yaxis().set_visible(False)\n    ax.axes.get_xaxis().set_visible(False)", "code_tokens": "def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )", "docstring_tokens": "Get rid of all axis ticks lines etc .", "label": 0}, {"idx": "cosqa-train-6263", "doc": "use a button from breezypythongui to close gui python", "code": "def closeEvent(self, e):\n        \"\"\"Qt slot when the window is closed.\"\"\"\n        self.emit('close_widget')\n        super(DockWidget, self).closeEvent(e)", "code_tokens": "def closeEvent ( self , e ) : self . emit ( 'close_widget' ) super ( DockWidget , self ) . closeEvent ( e )", "docstring_tokens": "Qt slot when the window is closed .", "label": 0}, {"idx": "cosqa-train-6264", "doc": "python clear a dir and remove it", "code": "def remove_examples_all():\n    \"\"\"remove arduino/examples/all directory.\n\n    :rtype: None\n\n    \"\"\"\n    d = examples_all_dir()\n    if d.exists():\n        log.debug('remove %s', d)\n        d.rmtree()\n    else:\n        log.debug('nothing to remove: %s', d)", "code_tokens": "def remove_examples_all ( ) : d = examples_all_dir ( ) if d . exists ( ) : log . debug ( 'remove %s' , d ) d . rmtree ( ) else : log . debug ( 'nothing to remove: %s' , d )", "docstring_tokens": "remove arduino / examples / all directory .", "label": 1}, {"idx": "cosqa-train-6265", "doc": "use javascript variable in python", "code": "def add_to_js(self, name, var):\n        \"\"\"Add an object to Javascript.\"\"\"\n        frame = self.page().mainFrame()\n        frame.addToJavaScriptWindowObject(name, var)", "code_tokens": "def add_to_js ( self , name , var ) : frame = self . page ( ) . mainFrame ( ) frame . addToJavaScriptWindowObject ( name , var )", "docstring_tokens": "Add an object to Javascript .", "label": 0}, {"idx": "cosqa-train-6266", "doc": "python clear contents of a folder", "code": "def _clear_dir(dirName):\n    \"\"\" Remove a directory and it contents. Ignore any failures.\n    \"\"\"\n    # If we got here, clear dir  \n    for fname in os.listdir(dirName):\n        try:\n            os.remove( os.path.join(dirName, fname) )\n        except Exception:\n            pass\n    try:\n        os.rmdir(dirName)\n    except Exception:\n        pass", "code_tokens": "def _clear_dir ( dirName ) : # If we got here, clear dir   for fname in os . listdir ( dirName ) : try : os . remove ( os . path . join ( dirName , fname ) ) except Exception : pass try : os . rmdir ( dirName ) except Exception : pass", "docstring_tokens": "Remove a directory and it contents . Ignore any failures .", "label": 0}, {"idx": "cosqa-train-6267", "doc": "use kwargs with a dict in python", "code": "def _sourced_dict(self, source=None, **kwargs):\n        \"\"\"Like ``dict(**kwargs)``, but where the ``source`` key is special.\n        \"\"\"\n        if source:\n            kwargs['source'] = source\n        elif self.source:\n            kwargs['source'] = self.source\n        return kwargs", "code_tokens": "def _sourced_dict ( self , source = None , * * kwargs ) : if source : kwargs [ 'source' ] = source elif self . source : kwargs [ 'source' ] = self . source return kwargs", "docstring_tokens": "Like dict ( ** kwargs ) but where the source key is special .", "label": 1}, {"idx": "cosqa-train-6268", "doc": "python clear specific objects", "code": "def detach_all(self):\n        \"\"\"\n        Detach from all tracked classes and objects.\n        Restore the original constructors and cleanse the tracking lists.\n        \"\"\"\n        self.detach_all_classes()\n        self.objects.clear()\n        self.index.clear()\n        self._keepalive[:] = []", "code_tokens": "def detach_all ( self ) : self . detach_all_classes ( ) self . objects . clear ( ) self . index . clear ( ) self . _keepalive [ : ] = [ ]", "docstring_tokens": "Detach from all tracked classes and objects . Restore the original constructors and cleanse the tracking lists .", "label": 0}, {"idx": "cosqa-train-6269", "doc": "use numpy array as list indices in python", "code": "def _transform_triple_numpy(x):\n    \"\"\"Transform triple index into a 1-D numpy array.\"\"\"\n    return np.array([x.head, x.relation, x.tail], dtype=np.int64)", "code_tokens": "def _transform_triple_numpy ( x ) : return np . array ( [ x . head , x . relation , x . tail ] , dtype = np . int64 )", "docstring_tokens": "Transform triple index into a 1 - D numpy array .", "label": 0}, {"idx": "cosqa-train-6270", "doc": "python clone a mask", "code": "def bit_clone( bits ):\n    \"\"\"\n    Clone a bitset\n    \"\"\"\n    new = BitSet( bits.size )\n    new.ior( bits )\n    return new", "code_tokens": "def bit_clone ( bits ) : new = BitSet ( bits . size ) new . ior ( bits ) return new", "docstring_tokens": "Clone a bitset", "label": 0}, {"idx": "cosqa-train-6271", "doc": "use python to test java", "code": "def test_python_java_rt():\n    \"\"\" Run Python test cases against Java runtime classes. \"\"\"\n    sub_env = {'PYTHONPATH': _build_dir()}\n\n    log.info('Executing Python unit tests (against Java runtime classes)...')\n    return jpyutil._execute_python_scripts(python_java_rt_tests,\n                                           env=sub_env)", "code_tokens": "def test_python_java_rt ( ) : sub_env = { 'PYTHONPATH' : _build_dir ( ) } log . info ( 'Executing Python unit tests (against Java runtime classes)...' ) return jpyutil . _execute_python_scripts ( python_java_rt_tests , env = sub_env )", "docstring_tokens": "Run Python test cases against Java runtime classes .", "label": 1}, {"idx": "cosqa-train-6272", "doc": "python clone query set", "code": "def _clone(self, *args, **kwargs):\n        \"\"\"\n        Ensure attributes are copied to subsequent queries.\n        \"\"\"\n        for attr in (\"_search_terms\", \"_search_fields\", \"_search_ordered\"):\n            kwargs[attr] = getattr(self, attr)\n        return super(SearchableQuerySet, self)._clone(*args, **kwargs)", "code_tokens": "def _clone ( self , * args , * * kwargs ) : for attr in ( \"_search_terms\" , \"_search_fields\" , \"_search_ordered\" ) : kwargs [ attr ] = getattr ( self , attr ) return super ( SearchableQuerySet , self ) . _clone ( * args , * * kwargs )", "docstring_tokens": "Ensure attributes are copied to subsequent queries .", "label": 0}, {"idx": "cosqa-train-6273", "doc": "use single quotes in python string", "code": "def quote(self, s):\n        \"\"\"Return a shell-escaped version of the string s.\"\"\"\n\n        if six.PY2:\n            from pipes import quote\n        else:\n            from shlex import quote\n\n        return quote(s)", "code_tokens": "def quote ( self , s ) : if six . PY2 : from pipes import quote else : from shlex import quote return quote ( s )", "docstring_tokens": "Return a shell - escaped version of the string s .", "label": 0}, {"idx": "cosqa-train-6274", "doc": "python close browser after 5 mins", "code": "def kill(self):\n        \"\"\"Kill the browser.\n\n        This is useful when the browser is stuck.\n        \"\"\"\n        if self.process:\n            self.process.kill()\n            self.process.wait()", "code_tokens": "def kill ( self ) : if self . process : self . process . kill ( ) self . process . wait ( )", "docstring_tokens": "Kill the browser .", "label": 0}, {"idx": "cosqa-train-6275", "doc": "using a dict in reverse python", "code": "def invert(dict_):\n    \"\"\"Return an inverted dictionary, where former values are keys\n    and former keys are values.\n\n    .. warning::\n\n        If more than one key maps to any given value in input dictionary,\n        it is undefined which one will be chosen for the result.\n\n    :param dict_: Dictionary to swap keys and values in\n    :return: Inverted dictionary\n    \"\"\"\n    ensure_mapping(dict_)\n    return dict_.__class__(izip(itervalues(dict_), iterkeys(dict_)))", "code_tokens": "def invert ( dict_ ) : ensure_mapping ( dict_ ) return dict_ . __class__ ( izip ( itervalues ( dict_ ) , iterkeys ( dict_ ) ) )", "docstring_tokens": "Return an inverted dictionary where former values are keys and former keys are values .", "label": 1}, {"idx": "cosqa-train-6276", "doc": "python close logging file", "code": "def close_log(log, verbose=True):\n    \"\"\"Close log\n\n    This method closes and active logging.Logger instance.\n\n    Parameters\n    ----------\n    log : logging.Logger\n        Logging instance\n\n    \"\"\"\n\n    if verbose:\n        print('Closing log file:', log.name)\n\n    # Send closing message.\n    log.info('The log file has been closed.')\n\n    # Remove all handlers from log.\n    [log.removeHandler(handler) for handler in log.handlers]", "code_tokens": "def close_log ( log , verbose = True ) : if verbose : print ( 'Closing log file:' , log . name ) # Send closing message. log . info ( 'The log file has been closed.' ) # Remove all handlers from log. [ log . removeHandler ( handler ) for handler in log . handlers ]", "docstring_tokens": "Close log", "label": 0}, {"idx": "cosqa-train-6277", "doc": "using colorama in windows python", "code": "def _write_color_colorama (fp, text, color):\n    \"\"\"Colorize text with given color.\"\"\"\n    foreground, background, style = get_win_color(color)\n    colorama.set_console(foreground=foreground, background=background,\n      style=style)\n    fp.write(text)\n    colorama.reset_console()", "code_tokens": "def _write_color_colorama ( fp , text , color ) : foreground , background , style = get_win_color ( color ) colorama . set_console ( foreground = foreground , background = background , style = style ) fp . write ( text ) colorama . reset_console ( )", "docstring_tokens": "Colorize text with given color .", "label": 1}, {"idx": "cosqa-train-6278", "doc": "python closing database before terminating", "code": "def cleanup(self, app):\n        \"\"\"Close all connections.\"\"\"\n        if hasattr(self.database.obj, 'close_all'):\n            self.database.close_all()", "code_tokens": "def cleanup ( self , app ) : if hasattr ( self . database . obj , 'close_all' ) : self . database . close_all ( )", "docstring_tokens": "Close all connections .", "label": 0}, {"idx": "cosqa-train-6279", "doc": "using functions to make a table aligned python", "code": "def get_table(ports):\n    \"\"\"\n    This function returns a pretty table used to display the port results.\n\n    :param ports: list of found ports\n    :return: the table to display\n    \"\"\"\n    table = PrettyTable([\"Name\", \"Port\", \"Protocol\", \"Description\"])\n    table.align[\"Name\"] = \"l\"\n    table.align[\"Description\"] = \"l\"\n    table.padding_width = 1\n\n    for port in ports:\n        table.add_row(port)\n\n    return table", "code_tokens": "def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "docstring_tokens": "This function returns a pretty table used to display the port results .", "label": 0}, {"idx": "cosqa-train-6280", "doc": "python code for euclidean distance between those two points", "code": "def euclidean(c1, c2):\n    \"\"\"Square of the euclidean distance\"\"\"\n    diffs = ((i - j) for i, j in zip(c1, c2))\n    return sum(x * x for x in diffs)", "code_tokens": "def euclidean ( c1 , c2 ) : diffs = ( ( i - j ) for i , j in zip ( c1 , c2 ) ) return sum ( x * x for x in diffs )", "docstring_tokens": "Square of the euclidean distance", "label": 0}, {"idx": "cosqa-train-6281", "doc": "using python to check to see if the url is active with an http call", "code": "def _is_valid_url(self, url):\n        \"\"\"Callback for is_valid_url.\"\"\"\n        try:\n            r = requests.head(url, proxies=self.proxy_servers)\n            value = r.status_code in [200]\n        except Exception as error:\n            logger.error(str(error))\n            value = False\n\n        return value", "code_tokens": "def _is_valid_url ( self , url ) : try : r = requests . head ( url , proxies = self . proxy_servers ) value = r . status_code in [ 200 ] except Exception as error : logger . error ( str ( error ) ) value = False return value", "docstring_tokens": "Callback for is_valid_url .", "label": 0}, {"idx": "cosqa-train-6282", "doc": "python code in extension pause every interval", "code": "def execute_until_false(method, interval_s):  # pylint: disable=invalid-name\n  \"\"\"Executes a method forever until the method returns a false value.\n\n  Args:\n    method: The callable to execute.\n    interval_s: The number of seconds to start the execution after each method\n        finishes.\n  Returns:\n    An Interval object.\n  \"\"\"\n  interval = Interval(method, stop_if_false=True)\n  interval.start(interval_s)\n  return interval", "code_tokens": "def execute_until_false ( method , interval_s ) : # pylint: disable=invalid-name interval = Interval ( method , stop_if_false = True ) interval . start ( interval_s ) return interval", "docstring_tokens": "Executes a method forever until the method returns a false value .", "label": 0}, {"idx": "cosqa-train-6283", "doc": "using python user defined function to execute a java jar", "code": "def version_jar(self):\n\t\t\"\"\"\n\t\tSpecial case of version() when the executable is a JAR file.\n\t\t\"\"\"\n\t\tcmd = config.get_command('java')\n\t\tcmd.append('-jar')\n\t\tcmd += self.cmd\n\t\tself.version(cmd=cmd, path=self.cmd[0])", "code_tokens": "def version_jar ( self ) : cmd = config . get_command ( 'java' ) cmd . append ( '-jar' ) cmd += self . cmd self . version ( cmd = cmd , path = self . cmd [ 0 ] )", "docstring_tokens": "Special case of version () when the executable is a JAR file .", "label": 1}, {"idx": "cosqa-train-6284", "doc": "python code object detection tensorflow with custom dataset", "code": "def _int64_feature(value):\n  \"\"\"Wrapper for inserting int64 features into Example proto.\"\"\"\n  if not isinstance(value, list):\n    value = [value]\n  return tf.train.Feature(int64_list=tf.train.Int64List(value=value))", "code_tokens": "def _int64_feature ( value ) : if not isinstance ( value , list ) : value = [ value ] return tf . train . Feature ( int64_list = tf . train . Int64List ( value = value ) )", "docstring_tokens": "Wrapper for inserting int64 features into Example proto .", "label": 0}, {"idx": "cosqa-train-6285", "doc": "using session to pull data from a http url python", "code": "def _get_url(url):\n    \"\"\"Retrieve requested URL\"\"\"\n    try:\n        data = HTTP_SESSION.get(url, stream=True)\n        data.raise_for_status()\n    except requests.exceptions.RequestException as exc:\n        raise FetcherException(exc)\n\n    return data", "code_tokens": "def _get_url ( url ) : try : data = HTTP_SESSION . get ( url , stream = True ) data . raise_for_status ( ) except requests . exceptions . RequestException as exc : raise FetcherException ( exc ) return data", "docstring_tokens": "Retrieve requested URL", "label": 0}, {"idx": "cosqa-train-6286", "doc": "python code tell what type of data", "code": "def _get_type(self, value):\n        \"\"\"Get the data type for *value*.\"\"\"\n        if value is None:\n            return type(None)\n        elif type(value) in int_types:\n            return int\n        elif type(value) in float_types:\n            return float\n        elif isinstance(value, binary_type):\n            return binary_type\n        else:\n            return text_type", "code_tokens": "def _get_type ( self , value ) : if value is None : return type ( None ) elif type ( value ) in int_types : return int elif type ( value ) in float_types : return float elif isinstance ( value , binary_type ) : return binary_type else : return text_type", "docstring_tokens": "Get the data type for * value * .", "label": 0}, {"idx": "cosqa-train-6287", "doc": "using slice for list python", "code": "def iget_list_column_slice(list_, start=None, stop=None, stride=None):\n    \"\"\" iterator version of get_list_column \"\"\"\n    if isinstance(start, slice):\n        slice_ = start\n    else:\n        slice_ = slice(start, stop, stride)\n    return (row[slice_] for row in list_)", "code_tokens": "def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )", "docstring_tokens": "iterator version of get_list_column", "label": 0}, {"idx": "cosqa-train-6288", "doc": "python code to list all the prime number", "code": "def getPrimeFactors(n):\n    \"\"\"\n    Get all the prime factor of given integer\n    @param n integer\n    @return list [1, ..., n]\n    \"\"\"\n    lo = [1]\n    n2 = n // 2\n    k = 2\n    for k in range(2, n2 + 1):\n        if (n // k)*k == n:\n            lo.append(k)\n    return lo + [n, ]", "code_tokens": "def getPrimeFactors ( n ) : lo = [ 1 ] n2 = n // 2 k = 2 for k in range ( 2 , n2 + 1 ) : if ( n // k ) * k == n : lo . append ( k ) return lo + [ n , ]", "docstring_tokens": "Get all the prime factor of given integer", "label": 0}, {"idx": "cosqa-train-6289", "doc": "using yield next file python", "code": "def read_next_block(infile, block_size=io.DEFAULT_BUFFER_SIZE):\n    \"\"\"Iterates over the file in blocks.\"\"\"\n    chunk = infile.read(block_size)\n\n    while chunk:\n        yield chunk\n\n        chunk = infile.read(block_size)", "code_tokens": "def read_next_block ( infile , block_size = io . DEFAULT_BUFFER_SIZE ) : chunk = infile . read ( block_size ) while chunk : yield chunk chunk = infile . read ( block_size )", "docstring_tokens": "Iterates over the file in blocks .", "label": 0}, {"idx": "cosqa-train-6290", "doc": "python color text content contained within brackets", "code": "def sprint(text, *colors):\n    \"\"\"Format text with color or other effects into ANSI escaped string.\"\"\"\n    return \"\\33[{}m{content}\\33[{}m\".format(\";\".join([str(color) for color in colors]), RESET, content=text) if IS_ANSI_TERMINAL and colors else text", "code_tokens": "def sprint ( text , * colors ) : return \"\\33[{}m{content}\\33[{}m\" . format ( \";\" . join ( [ str ( color ) for color in colors ] ) , RESET , content = text ) if IS_ANSI_TERMINAL and colors else text", "docstring_tokens": "Format text with color or other effects into ANSI escaped string .", "label": 1}, {"idx": "cosqa-train-6291", "doc": "valid file path check in python", "code": "def is_valid_file(parser, arg):\n    \"\"\"Check if arg is a valid file that already exists on the file system.\"\"\"\n    arg = os.path.abspath(arg)\n    if not os.path.exists(arg):\n        parser.error(\"The file %s does not exist!\" % arg)\n    else:\n        return arg", "code_tokens": "def is_valid_file ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . exists ( arg ) : parser . error ( \"The file %s does not exist!\" % arg ) else : return arg", "docstring_tokens": "Check if arg is a valid file that already exists on the file system .", "label": 0}, {"idx": "cosqa-train-6292", "doc": "python column names to a dictionary", "code": "def row_to_dict(row):\n    \"\"\"Convert a table row to a dictionary.\"\"\"\n    o = {}\n    for colname in row.colnames:\n\n        if isinstance(row[colname], np.string_) and row[colname].dtype.kind in ['S', 'U']:\n            o[colname] = str(row[colname])\n        else:\n            o[colname] = row[colname]\n\n    return o", "code_tokens": "def row_to_dict ( row ) : o = { } for colname in row . colnames : if isinstance ( row [ colname ] , np . string_ ) and row [ colname ] . dtype . kind in [ 'S' , 'U' ] : o [ colname ] = str ( row [ colname ] ) else : o [ colname ] = row [ colname ] return o", "docstring_tokens": "Convert a table row to a dictionary .", "label": 0}, {"idx": "cosqa-train-6293", "doc": "validate a url in python", "code": "def is_valid_url(url):\n    \"\"\"Checks if a given string is an url\"\"\"\n    pieces = urlparse(url)\n    return all([pieces.scheme, pieces.netloc])", "code_tokens": "def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )", "docstring_tokens": "Checks if a given string is an url", "label": 0}, {"idx": "cosqa-train-6294", "doc": "python combine several images into one", "code": "def join_images(img_files, out_file):\n    \"\"\"Join the list of images into the out file\"\"\"\n    images = [PIL.Image.open(f) for f in img_files]\n    joined = PIL.Image.new(\n        'RGB',\n        (sum(i.size[0] for i in images), max(i.size[1] for i in images))\n    )\n    left = 0\n    for img in images:\n        joined.paste(im=img, box=(left, 0))\n        left = left + img.size[0]\n    joined.save(out_file)", "code_tokens": "def join_images ( img_files , out_file ) : images = [ PIL . Image . open ( f ) for f in img_files ] joined = PIL . Image . new ( 'RGB' , ( sum ( i . size [ 0 ] for i in images ) , max ( i . size [ 1 ] for i in images ) ) ) left = 0 for img in images : joined . paste ( im = img , box = ( left , 0 ) ) left = left + img . size [ 0 ] joined . save ( out_file )", "docstring_tokens": "Join the list of images into the out file", "label": 1}, {"idx": "cosqa-train-6295", "doc": "validate the type of all elements in a list python", "code": "def _valid_other_type(x, types):\n    \"\"\"\n    Do all elements of x have a type from types?\n    \"\"\"\n    return all(any(isinstance(el, t) for t in types) for el in np.ravel(x))", "code_tokens": "def _valid_other_type ( x , types ) : return all ( any ( isinstance ( el , t ) for t in types ) for el in np . ravel ( x ) )", "docstring_tokens": "Do all elements of x have a type from types?", "label": 0}, {"idx": "cosqa-train-6296", "doc": "python combine to dictionaries", "code": "def merge_dict(data, *args):\n    \"\"\"Merge any number of dictionaries\n    \"\"\"\n    results = {}\n    for current in (data,) + args:\n        results.update(current)\n    return results", "code_tokens": "def merge_dict ( data , * args ) : results = { } for current in ( data , ) + args : results . update ( current ) return results", "docstring_tokens": "Merge any number of dictionaries", "label": 1}, {"idx": "cosqa-train-6297", "doc": "value of all the keys in dictionary is same python", "code": "def make_symmetric(dict):\n    \"\"\"Makes the given dictionary symmetric. Values are assumed to be unique.\"\"\"\n    for key, value in list(dict.items()):\n        dict[value] = key\n    return dict", "code_tokens": "def make_symmetric ( dict ) : for key , value in list ( dict . items ( ) ) : dict [ value ] = key return dict", "docstring_tokens": "Makes the given dictionary symmetric . Values are assumed to be unique .", "label": 0}, {"idx": "cosqa-train-6298", "doc": "python combobox set value", "code": "def onchange(self, value):\n        \"\"\"Called when a new DropDownItem gets selected.\n        \"\"\"\n        log.debug('combo box. selected %s' % value)\n        self.select_by_value(value)\n        return (value, )", "code_tokens": "def onchange ( self , value ) : log . debug ( 'combo box. selected %s' % value ) self . select_by_value ( value ) return ( value , )", "docstring_tokens": "Called when a new DropDownItem gets selected .", "label": 0}, {"idx": "cosqa-train-6299", "doc": "variance from svr prediction python", "code": "def explained_variance(returns, values):\n    \"\"\" Calculate how much variance in returns do the values explain \"\"\"\n    exp_var = 1 - torch.var(returns - values) / torch.var(returns)\n    return exp_var.item()", "code_tokens": "def explained_variance ( returns , values ) : exp_var = 1 - torch . var ( returns - values ) / torch . var ( returns ) return exp_var . item ( )", "docstring_tokens": "Calculate how much variance in returns do the values explain", "label": 0}, {"idx": "cosqa-train-6300", "doc": "python combobox update values", "code": "def _updateItemComboBoxIndex(self, item, column, num):\n        \"\"\"Callback for comboboxes: notifies us that a combobox for the given item and column has changed\"\"\"\n        item._combobox_current_index[column] = num\n        item._combobox_current_value[column] = item._combobox_option_list[column][num][0]", "code_tokens": "def _updateItemComboBoxIndex ( self , item , column , num ) : item . _combobox_current_index [ column ] = num item . _combobox_current_value [ column ] = item . _combobox_option_list [ column ] [ num ] [ 0 ]", "docstring_tokens": "Callback for comboboxes : notifies us that a combobox for the given item and column has changed", "label": 0}, {"idx": "cosqa-train-6301", "doc": "vectorize a function python", "code": "def apply(f, obj, *args, **kwargs):\n    \"\"\"Apply a function in parallel to each element of the input\"\"\"\n    return vectorize(f)(obj, *args, **kwargs)", "code_tokens": "def apply ( f , obj , * args , * * kwargs ) : return vectorize ( f ) ( obj , * args , * * kwargs )", "docstring_tokens": "Apply a function in parallel to each element of the input", "label": 0}, {"idx": "cosqa-train-6302", "doc": "python compare length of 2 strings", "code": "def count_string_diff(a,b):\n    \"\"\"Return the number of characters in two strings that don't exactly match\"\"\"\n    shortest = min(len(a), len(b))\n    return sum(a[i] != b[i] for i in range(shortest))", "code_tokens": "def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )", "docstring_tokens": "Return the number of characters in two strings that don t exactly match", "label": 0}, {"idx": "cosqa-train-6303", "doc": "vs unittest python coverage", "code": "def cover(session):\n    \"\"\"Run the final coverage report.\n    This outputs the coverage report aggregating coverage from the unit\n    test runs (not system test runs), and then erases coverage data.\n    \"\"\"\n    session.interpreter = 'python3.6'\n    session.install('coverage', 'pytest-cov')\n    session.run('coverage', 'report', '--show-missing', '--fail-under=100')\n    session.run('coverage', 'erase')", "code_tokens": "def cover ( session ) : session . interpreter = 'python3.6' session . install ( 'coverage' , 'pytest-cov' ) session . run ( 'coverage' , 'report' , '--show-missing' , '--fail-under=100' ) session . run ( 'coverage' , 'erase' )", "docstring_tokens": "Run the final coverage report . This outputs the coverage report aggregating coverage from the unit test runs ( not system test runs ) and then erases coverage data .", "label": 0}, {"idx": "cosqa-train-6304", "doc": "python compare string diff len", "code": "def count_string_diff(a,b):\n    \"\"\"Return the number of characters in two strings that don't exactly match\"\"\"\n    shortest = min(len(a), len(b))\n    return sum(a[i] != b[i] for i in range(shortest))", "code_tokens": "def count_string_diff ( a , b ) : shortest = min ( len ( a ) , len ( b ) ) return sum ( a [ i ] != b [ i ] for i in range ( shortest ) )", "docstring_tokens": "Return the number of characters in two strings that don t exactly match", "label": 0}, {"idx": "cosqa-train-6305", "doc": "what axis is column in numpy python", "code": "def nrows_expected(self):\n        \"\"\" based on our axes, compute the expected nrows \"\"\"\n        return np.prod([i.cvalues.shape[0] for i in self.index_axes])", "code_tokens": "def nrows_expected ( self ) : return np . prod ( [ i . cvalues . shape [ 0 ] for i in self . index_axes ] )", "docstring_tokens": "based on our axes compute the expected nrows", "label": 0}, {"idx": "cosqa-train-6306", "doc": "what can iterators be iterated only once in python", "code": "def _fill(self):\n    \"\"\"Advance the iterator without returning the old head.\"\"\"\n    try:\n      self._head = self._iterable.next()\n    except StopIteration:\n      self._head = None", "code_tokens": "def _fill ( self ) : try : self . _head = self . _iterable . next ( ) except StopIteration : self . _head = None", "docstring_tokens": "Advance the iterator without returning the old head .", "label": 1}, {"idx": "cosqa-train-6307", "doc": "python compute euclidean distance of two vectors", "code": "def vector_distance(a, b):\n    \"\"\"The Euclidean distance between two vectors.\"\"\"\n    a = np.array(a)\n    b = np.array(b)\n    return np.linalg.norm(a - b)", "code_tokens": "def vector_distance ( a , b ) : a = np . array ( a ) b = np . array ( b ) return np . linalg . norm ( a - b )", "docstring_tokens": "The Euclidean distance between two vectors .", "label": 0}, {"idx": "cosqa-train-6308", "doc": "what colors can i use in python", "code": "def set_color(self, fg=None, bg=None, intensify=False, target=sys.stdout):\n        \"\"\"Set foreground- and background colors and intensity.\"\"\"\n        raise NotImplementedError", "code_tokens": "def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError", "docstring_tokens": "Set foreground - and background colors and intensity .", "label": 0}, {"idx": "cosqa-train-6309", "doc": "python concat str bool", "code": "def boolean(value):\n    \"\"\"\n    Configuration-friendly boolean type converter.\n\n    Supports both boolean-valued and string-valued inputs (e.g. from env vars).\n\n    \"\"\"\n    if isinstance(value, bool):\n        return value\n\n    if value == \"\":\n        return False\n\n    return strtobool(value)", "code_tokens": "def boolean ( value ) : if isinstance ( value , bool ) : return value if value == \"\" : return False return strtobool ( value )", "docstring_tokens": "Configuration - friendly boolean type converter .", "label": 0}, {"idx": "cosqa-train-6310", "doc": "what does next(file) return in python", "code": "def rAsciiLine(ifile):\n    \"\"\"Returns the next non-blank line in an ASCII file.\"\"\"\n\n    _line = ifile.readline().strip()\n    while len(_line) == 0:\n        _line = ifile.readline().strip()\n    return _line", "code_tokens": "def rAsciiLine ( ifile ) : _line = ifile . readline ( ) . strip ( ) while len ( _line ) == 0 : _line = ifile . readline ( ) . strip ( ) return _line", "docstring_tokens": "Returns the next non - blank line in an ASCII file .", "label": 0}, {"idx": "cosqa-train-6311", "doc": "python concatenate all items in tuple", "code": "def compose_all(tups):\n  \"\"\"Compose all given tuples together.\"\"\"\n  from . import ast  # I weep for humanity\n  return functools.reduce(lambda x, y: x.compose(y), map(ast.make_tuple, tups), ast.make_tuple({}))", "code_tokens": "def compose_all ( tups ) : from . import ast # I weep for humanity return functools . reduce ( lambda x , y : x . compose ( y ) , map ( ast . make_tuple , tups ) , ast . make_tuple ( { } ) )", "docstring_tokens": "Compose all given tuples together .", "label": 0}, {"idx": "cosqa-train-6312", "doc": "what to return a max in python without the max function", "code": "def max(self):\n        \"\"\"\n        Returns the maximum value of the domain.\n\n        :rtype: `float` or `np.inf`\n        \"\"\"\n        return int(self._max) if not np.isinf(self._max) else self._max", "code_tokens": "def max ( self ) : return int ( self . _max ) if not np . isinf ( self . _max ) else self . _max", "docstring_tokens": "Returns the maximum value of the domain .", "label": 0}, {"idx": "cosqa-train-6313", "doc": "python concert numpy array to list", "code": "def recarray(self):\n        \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"\n        return numpy.rec.fromrecords(self.records, names=self.names)", "code_tokens": "def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "docstring_tokens": "Returns data as : class : numpy . recarray .", "label": 0}, {"idx": "cosqa-train-6314", "doc": "word leter count to dictionary python", "code": "def np_counts(self):\n    \"\"\"Dictionary of noun phrase frequencies in this text.\n    \"\"\"\n    counts = defaultdict(int)\n    for phrase in self.noun_phrases:\n        counts[phrase] += 1\n    return counts", "code_tokens": "def np_counts ( self ) : counts = defaultdict ( int ) for phrase in self . noun_phrases : counts [ phrase ] += 1 return counts", "docstring_tokens": "Dictionary of noun phrase frequencies in this text .", "label": 0}, {"idx": "cosqa-train-6315", "doc": "python conditional with none", "code": "def less_strict_bool(x):\n    \"\"\"Idempotent and None-safe version of strict_bool.\"\"\"\n    if x is None:\n        return False\n    elif x is True or x is False:\n        return x\n    else:\n        return strict_bool(x)", "code_tokens": "def less_strict_bool ( x ) : if x is None : return False elif x is True or x is False : return x else : return strict_bool ( x )", "docstring_tokens": "Idempotent and None - safe version of strict_bool .", "label": 0}, {"idx": "cosqa-train-6316", "doc": "write a configure file python format", "code": "def write_config(self, outfile):\n        \"\"\"Write the configuration dictionary to an output file.\"\"\"\n        utils.write_yaml(self.config, outfile, default_flow_style=False)", "code_tokens": "def write_config ( self , outfile ) : utils . write_yaml ( self . config , outfile , default_flow_style = False )", "docstring_tokens": "Write the configuration dictionary to an output file .", "label": 0}, {"idx": "cosqa-train-6317", "doc": "python confidence interval for t distribution", "code": "def student_t(degrees_of_freedom, confidence=0.95):\n    \"\"\"Return Student-t statistic for given DOF and confidence interval.\"\"\"\n    return scipy.stats.t.interval(alpha=confidence,\n                                  df=degrees_of_freedom)[-1]", "code_tokens": "def student_t ( degrees_of_freedom , confidence = 0.95 ) : return scipy . stats . t . interval ( alpha = confidence , df = degrees_of_freedom ) [ - 1 ]", "docstring_tokens": "Return Student - t statistic for given DOF and confidence interval .", "label": 0}, {"idx": "cosqa-train-6318", "doc": "write a function that finds the median of a list of numbers python", "code": "def getMedian(numericValues):\n    \"\"\"\n    Gets the median of a list of values\n    Returns a float/int\n    \"\"\"\n    theValues = sorted(numericValues)\n\n    if len(theValues) % 2 == 1:\n        return theValues[(len(theValues) + 1) / 2 - 1]\n    else:\n        lower = theValues[len(theValues) / 2 - 1]\n        upper = theValues[len(theValues) / 2]\n\n        return (float(lower + upper)) / 2", "code_tokens": "def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2", "docstring_tokens": "Gets the median of a list of values Returns a float / int", "label": 1}, {"idx": "cosqa-train-6319", "doc": "python configparser get all values in a section", "code": "def items(self, section_name):\n        \"\"\":return: list((option, value), ...) pairs of all items in the given section\"\"\"\n        return [(k, v) for k, v in super(GitConfigParser, self).items(section_name) if k != '__name__']", "code_tokens": "def items ( self , section_name ) : return [ ( k , v ) for k , v in super ( GitConfigParser , self ) . items ( section_name ) if k != '__name__' ]", "docstring_tokens": ": return : list (( option value ) ... ) pairs of all items in the given section", "label": 0}, {"idx": "cosqa-train-6320", "doc": "write dict to json file in python", "code": "def _write_json(file, contents):\n    \"\"\"Write a dict to a JSON file.\"\"\"\n    with open(file, 'w') as f:\n        return json.dump(contents, f, indent=2, sort_keys=True)", "code_tokens": "def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )", "docstring_tokens": "Write a dict to a JSON file .", "label": 1}, {"idx": "cosqa-train-6321", "doc": "python conn is not defined", "code": "def connect(*args, **kwargs):\n    \"\"\"Creates or returns a singleton :class:`.Connection` object\"\"\"\n    global __CONNECTION\n    if __CONNECTION is None:\n        __CONNECTION = Connection(*args, **kwargs)\n\n    return __CONNECTION", "code_tokens": "def connect ( * args , * * kwargs ) : global __CONNECTION if __CONNECTION is None : __CONNECTION = Connection ( * args , * * kwargs ) return __CONNECTION", "docstring_tokens": "Creates or returns a singleton : class : . Connection object", "label": 0}, {"idx": "cosqa-train-6322", "doc": "writing a list as tsv file in python", "code": "def write_tsv_line_from_list(linelist, outfp):\n    \"\"\"Utility method to convert list to tsv line with carriage return\"\"\"\n    line = '\\t'.join(linelist)\n    outfp.write(line)\n    outfp.write('\\n')", "code_tokens": "def write_tsv_line_from_list ( linelist , outfp ) : line = '\\t' . join ( linelist ) outfp . write ( line ) outfp . write ( '\\n' )", "docstring_tokens": "Utility method to convert list to tsv line with carriage return", "label": 1}, {"idx": "cosqa-train-6323", "doc": "python connect to postgresql database", "code": "def install_postgres(user=None, dbname=None, password=None):\n    \"\"\"Install Postgres on remote\"\"\"\n    execute(pydiploy.django.install_postgres_server,\n            user=user, dbname=dbname, password=password)", "code_tokens": "def install_postgres ( user = None , dbname = None , password = None ) : execute ( pydiploy . django . install_postgres_server , user = user , dbname = dbname , password = password )", "docstring_tokens": "Install Postgres on remote", "label": 0}, {"idx": "cosqa-train-6324", "doc": "python construct parallel line segments", "code": "def make_segments(x, y):\n    \"\"\"\n    Create list of line segments from x and y coordinates, in the correct format\n    for LineCollection: an array of the form numlines x (points per line) x 2 (x\n    and y) array\n    \"\"\"\n\n    points = np.array([x, y]).T.reshape(-1, 1, 2)\n    segments = np.concatenate([points[:-1], points[1:]], axis=1)\n    return segments", "code_tokens": "def make_segments ( x , y ) : points = np . array ( [ x , y ] ) . T . reshape ( - 1 , 1 , 2 ) segments = np . concatenate ( [ points [ : - 1 ] , points [ 1 : ] ] , axis = 1 ) return segments", "docstring_tokens": "Create list of line segments from x and y coordinates in the correct format for LineCollection : an array of the form numlines x ( points per line ) x 2 ( x and y ) array", "label": 0}, {"idx": "cosqa-train-6325", "doc": "wxpython bitmap change image", "code": "def set_icon(self, bmp):\n        \"\"\"Sets main window icon to given wx.Bitmap\"\"\"\n\n        _icon = wx.EmptyIcon()\n        _icon.CopyFromBitmap(bmp)\n        self.SetIcon(_icon)", "code_tokens": "def set_icon ( self , bmp ) : _icon = wx . EmptyIcon ( ) _icon . CopyFromBitmap ( bmp ) self . SetIcon ( _icon )", "docstring_tokens": "Sets main window icon to given wx . Bitmap", "label": 0}, {"idx": "cosqa-train-6326", "doc": "python construct variable as dictionary", "code": "def conv_dict(self):\n        \"\"\"dictionary of conversion\"\"\"\n        return dict(integer=self.integer, real=self.real, no_type=self.no_type)", "code_tokens": "def conv_dict ( self ) : return dict ( integer = self . integer , real = self . real , no_type = self . no_type )", "docstring_tokens": "dictionary of conversion", "label": 0}, {"idx": "cosqa-train-6327", "doc": "wxpython set background color of text", "code": "def _update_fontcolor(self, fontcolor):\n        \"\"\"Updates text font color button\n\n        Parameters\n        ----------\n\n        fontcolor: Integer\n        \\tText color in integer RGB format\n\n        \"\"\"\n\n        textcolor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)\n        textcolor.SetRGB(fontcolor)\n\n        self.textcolor_choice.SetColour(textcolor)", "code_tokens": "def _update_fontcolor ( self , fontcolor ) : textcolor = wx . SystemSettings_GetColour ( wx . SYS_COLOUR_WINDOWTEXT ) textcolor . SetRGB ( fontcolor ) self . textcolor_choice . SetColour ( textcolor )", "docstring_tokens": "Updates text font color button", "label": 0}, {"idx": "cosqa-train-6328", "doc": "python contour spline interpolation", "code": "def get_line_flux(line_wave, wave, flux, **kwargs):\n    \"\"\"Interpolated flux at a given wavelength (calls np.interp).\"\"\"\n    return np.interp(line_wave, wave, flux, **kwargs)", "code_tokens": "def get_line_flux ( line_wave , wave , flux , * * kwargs ) : return np . interp ( line_wave , wave , flux , * * kwargs )", "docstring_tokens": "Interpolated flux at a given wavelength ( calls np . interp ) .", "label": 0}, {"idx": "cosqa-train-6329", "doc": "wxpython sizer add align", "code": "def _do_layout(self):\n        \"\"\"Sizer hell, returns a sizer that contains all widgets\"\"\"\n\n        sizer_csvoptions = wx.FlexGridSizer(5, 4, 5, 5)\n\n        # Adding parameter widgets to sizer_csvoptions\n        leftpos = wx.LEFT | wx.ADJUST_MINSIZE\n        rightpos = wx.RIGHT | wx.EXPAND\n\n        current_label_margin = 0  # smaller for left column\n        other_label_margin = 15\n\n        for label, widget in zip(self.param_labels, self.param_widgets):\n            sizer_csvoptions.Add(label, 0, leftpos, current_label_margin)\n            sizer_csvoptions.Add(widget, 0, rightpos, current_label_margin)\n\n            current_label_margin, other_label_margin = \\\n                other_label_margin, current_label_margin\n\n        sizer_csvoptions.AddGrowableCol(1)\n        sizer_csvoptions.AddGrowableCol(3)\n\n        self.sizer_csvoptions = sizer_csvoptions", "code_tokens": "def _do_layout ( self ) : sizer_csvoptions = wx . FlexGridSizer ( 5 , 4 , 5 , 5 ) # Adding parameter widgets to sizer_csvoptions leftpos = wx . LEFT | wx . ADJUST_MINSIZE rightpos = wx . RIGHT | wx . EXPAND current_label_margin = 0 # smaller for left column other_label_margin = 15 for label , widget in zip ( self . param_labels , self . param_widgets ) : sizer_csvoptions . Add ( label , 0 , leftpos , current_label_margin ) sizer_csvoptions . Add ( widget , 0 , rightpos , current_label_margin ) current_label_margin , other_label_margin = other_label_margin , current_label_margin sizer_csvoptions . AddGrowableCol ( 1 ) sizer_csvoptions . AddGrowableCol ( 3 ) self . sizer_csvoptions = sizer_csvoptions", "docstring_tokens": "Sizer hell returns a sizer that contains all widgets", "label": 0}, {"idx": "cosqa-train-6330", "doc": "python convention underscore or capitalize", "code": "def camelcase_underscore(name):\n    \"\"\" Convert camelcase names to underscore \"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def camelcase_underscore ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert camelcase names to underscore", "label": 0}, {"idx": "cosqa-train-6331", "doc": "x , y coordinates with python grid", "code": "def coords_on_grid(self, x, y):\n        \"\"\" Snap coordinates on the grid with integer coordinates \"\"\"\n\n        if isinstance(x, float):\n            x = int(self._round(x))\n        if isinstance(y, float):\n            y = int(self._round(y))\n        if not self._y_coord_down:\n            y = self._extents - y\n        return x, y", "code_tokens": "def coords_on_grid ( self , x , y ) : if isinstance ( x , float ) : x = int ( self . _round ( x ) ) if isinstance ( y , float ) : y = int ( self . _round ( y ) ) if not self . _y_coord_down : y = self . _extents - y return x , y", "docstring_tokens": "Snap coordinates on the grid with integer coordinates", "label": 1}, {"idx": "cosqa-train-6332", "doc": "python conver int to date", "code": "def int_to_date(date):\n    \"\"\"\n    Convert an int of form yyyymmdd to a python date object.\n    \"\"\"\n\n    year = date // 10**4\n    month = date % 10**4 // 10**2\n    day = date % 10**2\n\n    return datetime.date(year, month, day)", "code_tokens": "def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )", "docstring_tokens": "Convert an int of form yyyymmdd to a python date object .", "label": 0}, {"idx": "cosqa-train-6333", "doc": "x lim for subplots on python", "code": "def set_xlimits(self, row, column, min=None, max=None):\n        \"\"\"Set x-axis limits of a subplot.\n\n        :param row,column: specify the subplot.\n        :param min: minimal axis value\n        :param max: maximum axis value\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_xlimits(min, max)", "code_tokens": "def set_xlimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_xlimits ( min , max )", "docstring_tokens": "Set x - axis limits of a subplot .", "label": 0}, {"idx": "cosqa-train-6334", "doc": "python conver list str to float", "code": "def string_to_float_list(string_var):\n        \"\"\"Pull comma separated string values out of a text file and converts them to float list\"\"\"\n        try:\n            return [float(s) for s in string_var.strip('[').strip(']').split(', ')]\n        except:\n            return [float(s) for s in string_var.strip('[').strip(']').split(',')]", "code_tokens": "def string_to_float_list ( string_var ) : try : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ', ' ) ] except : return [ float ( s ) for s in string_var . strip ( '[' ) . strip ( ']' ) . split ( ',' ) ]", "docstring_tokens": "Pull comma separated string values out of a text file and converts them to float list", "label": 0}, {"idx": "cosqa-train-6335", "doc": "x^2 fourier transform python mathematica", "code": "def multiply(traj):\n    \"\"\"Sophisticated simulation of multiplication\"\"\"\n    z=traj.x*traj.y\n    traj.f_add_result('z',z=z, comment='I am the product of two reals!')", "code_tokens": "def multiply ( traj ) : z = traj . x * traj . y traj . f_add_result ( 'z' , z = z , comment = 'I am the product of two reals!' )", "docstring_tokens": "Sophisticated simulation of multiplication", "label": 0}, {"idx": "cosqa-train-6336", "doc": "python conver to camelcase", "code": "def convert_camel_case_to_snake_case(name):\n    \"\"\"Convert CamelCase to snake_case.\"\"\"\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "code_tokens": "def convert_camel_case_to_snake_case ( name ) : s1 = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , name ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Convert CamelCase to snake_case .", "label": 1}, {"idx": "cosqa-train-6337", "doc": "xsd schema parsing in python", "code": "def schemaParse(self):\n        \"\"\"parse a schema definition resource and build an internal\n           XML Shema struture which can be used to validate instances. \"\"\"\n        ret = libxml2mod.xmlSchemaParse(self._o)\n        if ret is None:raise parserError('xmlSchemaParse() failed')\n        __tmp = Schema(_obj=ret)\n        return __tmp", "code_tokens": "def schemaParse ( self ) : ret = libxml2mod . xmlSchemaParse ( self . _o ) if ret is None : raise parserError ( 'xmlSchemaParse() failed' ) __tmp = Schema ( _obj = ret ) return __tmp", "docstring_tokens": "parse a schema definition resource and build an internal XML Shema struture which can be used to validate instances .", "label": 0}, {"idx": "cosqa-train-6338", "doc": "python convolution kernel to fuse boundary", "code": "def convolve_fft(array, kernel):\n    \"\"\"\n    Convolve an array with a kernel using FFT.\n    Implemntation based on the convolve_fft function from astropy.\n\n    https://github.com/astropy/astropy/blob/master/astropy/convolution/convolve.py\n    \"\"\"\n\n    array = np.asarray(array, dtype=np.complex)\n    kernel = np.asarray(kernel, dtype=np.complex)\n\n    if array.ndim != kernel.ndim:\n        raise ValueError(\"Image and kernel must have same number of \"\n                         \"dimensions\")\n\n    array_shape = array.shape\n    kernel_shape = kernel.shape\n    new_shape = np.array(array_shape) + np.array(kernel_shape)\n\n    array_slices = []\n    kernel_slices = []\n    for (new_dimsize, array_dimsize, kernel_dimsize) in zip(\n            new_shape, array_shape, kernel_shape):\n        center = new_dimsize - (new_dimsize + 1) // 2\n        array_slices += [slice(center - array_dimsize // 2,\n                         center + (array_dimsize + 1) // 2)]\n        kernel_slices += [slice(center - kernel_dimsize // 2,\n                          center + (kernel_dimsize + 1) // 2)]\n\n    array_slices = tuple(array_slices)\n    kernel_slices = tuple(kernel_slices)\n\n    if not np.all(new_shape == array_shape):\n        big_array = np.zeros(new_shape, dtype=np.complex)\n        big_array[array_slices] = array\n    else:\n        big_array = array\n\n    if not np.all(new_shape == kernel_shape):\n        big_kernel = np.zeros(new_shape, dtype=np.complex)\n        big_kernel[kernel_slices] = kernel\n    else:\n        big_kernel = kernel\n\n    array_fft = np.fft.fftn(big_array)\n    kernel_fft = np.fft.fftn(np.fft.ifftshift(big_kernel))\n\n    rifft = np.fft.ifftn(array_fft * kernel_fft)\n\n    return rifft[array_slices].real", "code_tokens": "def convolve_fft ( array , kernel ) : array = np . asarray ( array , dtype = np . complex ) kernel = np . asarray ( kernel , dtype = np . complex ) if array . ndim != kernel . ndim : raise ValueError ( \"Image and kernel must have same number of \" \"dimensions\" ) array_shape = array . shape kernel_shape = kernel . shape new_shape = np . array ( array_shape ) + np . array ( kernel_shape ) array_slices = [ ] kernel_slices = [ ] for ( new_dimsize , array_dimsize , kernel_dimsize ) in zip ( new_shape , array_shape , kernel_shape ) : center = new_dimsize - ( new_dimsize + 1 ) // 2 array_slices += [ slice ( center - array_dimsize // 2 , center + ( array_dimsize + 1 ) // 2 ) ] kernel_slices += [ slice ( center - kernel_dimsize // 2 , center + ( kernel_dimsize + 1 ) // 2 ) ] array_slices = tuple ( array_slices ) kernel_slices = tuple ( kernel_slices ) if not np . all ( new_shape == array_shape ) : big_array = np . zeros ( new_shape , dtype = np . complex ) big_array [ array_slices ] = array else : big_array = array if not np . all ( new_shape == kernel_shape ) : big_kernel = np . zeros ( new_shape , dtype = np . complex ) big_kernel [ kernel_slices ] = kernel else : big_kernel = kernel array_fft = np . fft . fftn ( big_array ) kernel_fft = np . fft . fftn ( np . fft . ifftshift ( big_kernel ) ) rifft = np . fft . ifftn ( array_fft * kernel_fft ) return rifft [ array_slices ] . real", "docstring_tokens": "Convolve an array with a kernel using FFT . Implemntation based on the convolve_fft function from astropy .", "label": 1}, {"idx": "cosqa-train-6339", "doc": "yaml array values parsing in python", "code": "def Parse(text):\n  \"\"\"Parses a YAML source into a Python object.\n\n  Args:\n    text: A YAML source to parse.\n\n  Returns:\n    A Python data structure corresponding to the YAML source.\n  \"\"\"\n  precondition.AssertType(text, Text)\n\n  if compatibility.PY2:\n    text = text.encode(\"utf-8\")\n\n  return yaml.safe_load(text)", "code_tokens": "def Parse ( text ) : precondition . AssertType ( text , Text ) if compatibility . PY2 : text = text . encode ( \"utf-8\" ) return yaml . safe_load ( text )", "docstring_tokens": "Parses a YAML source into a Python object .", "label": 0}, {"idx": "cosqa-train-6340", "doc": "python convolution with gaussian", "code": "def convolve_gaussian_2d(image, gaussian_kernel_1d):\n    \"\"\"Convolve 2d gaussian.\"\"\"\n    result = scipy.ndimage.filters.correlate1d(\n        image, gaussian_kernel_1d, axis=0)\n    result = scipy.ndimage.filters.correlate1d(\n        result, gaussian_kernel_1d, axis=1)\n    return result", "code_tokens": "def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result", "docstring_tokens": "Convolve 2d gaussian .", "label": 0}, {"idx": "cosqa-train-6341", "doc": "python copy cell to cell and limit length", "code": "def pad_cells(table):\n    \"\"\"Pad each cell to the size of the largest cell in its column.\"\"\"\n    col_sizes = [max(map(len, col)) for col in zip(*table)]\n    for row in table:\n        for cell_num, cell in enumerate(row):\n            row[cell_num] = pad_to(cell, col_sizes[cell_num])\n    return table", "code_tokens": "def pad_cells ( table ) : col_sizes = [ max ( map ( len , col ) ) for col in zip ( * table ) ] for row in table : for cell_num , cell in enumerate ( row ) : row [ cell_num ] = pad_to ( cell , col_sizes [ cell_num ] ) return table", "docstring_tokens": "Pad each cell to the size of the largest cell in its column .", "label": 0}, {"idx": "cosqa-train-6342", "doc": "python compile file to pyc", "code": "def execfile(fname, variables):\n    \"\"\" This is builtin in python2, but we have to roll our own on py3. \"\"\"\n    with open(fname) as f:\n        code = compile(f.read(), fname, 'exec')\n        exec(code, variables)", "code_tokens": "def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )", "docstring_tokens": "This is builtin in python2 but we have to roll our own on py3 .", "label": 1}, {"idx": "cosqa-train-6343", "doc": "\"bytes to str\" python3", "code": "def ub_to_str(string):\n    \"\"\"\n    converts py2 unicode / py3 bytestring into str\n    Args:\n        string (unicode, byte_string): string to be converted\n        \n    Returns:\n        (str)\n    \"\"\"\n    if not isinstance(string, str):\n        if six.PY2:\n            return str(string)\n        else:\n            return string.decode()\n    return string", "code_tokens": "def ub_to_str ( string ) : if not isinstance ( string , str ) : if six . PY2 : return str ( string ) else : return string . decode ( ) return string", "docstring_tokens": "converts py2 unicode / py3 bytestring into str Args : string ( unicode byte_string ) : string to be converted Returns : ( str )", "label": 0}, {"idx": "cosqa-train-6344", "doc": "python compression string to gzip", "code": "def ungzip_data(input_data):\n    \"\"\"Return a string of data after gzip decoding\n\n    :param the input gziped data\n    :return  the gzip decoded data\"\"\"\n    buf = StringIO(input_data)\n    f = gzip.GzipFile(fileobj=buf)\n    return f", "code_tokens": "def ungzip_data ( input_data ) : buf = StringIO ( input_data ) f = gzip . GzipFile ( fileobj = buf ) return f", "docstring_tokens": "Return a string of data after gzip decoding", "label": 0}, {"idx": "cosqa-train-6345", "doc": "\"python 3\" ssl has no attribute sslcontext", "code": "def enable_ssl(self, *args, **kwargs):\n        \"\"\"\n        Transforms the regular socket.socket to an ssl.SSLSocket for secure\n        connections. Any arguments are passed to ssl.wrap_socket:\n        http://docs.python.org/dev/library/ssl.html#ssl.wrap_socket\n        \"\"\"\n        if self.handshake_sent:\n            raise SSLError('can only enable SSL before handshake')\n\n        self.secure = True\n        self.sock = ssl.wrap_socket(self.sock, *args, **kwargs)", "code_tokens": "def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )", "docstring_tokens": "Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket", "label": 1}, {"idx": "cosqa-train-6346", "doc": "python compute greatest common divisor", "code": "def _gcd_array(X):\n    \"\"\"\n    Return the largest real value h such that all elements in x are integer\n    multiples of h.\n    \"\"\"\n    greatest_common_divisor = 0.0\n    for x in X:\n        greatest_common_divisor = _gcd(greatest_common_divisor, x)\n\n    return greatest_common_divisor", "code_tokens": "def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor", "docstring_tokens": "Return the largest real value h such that all elements in x are integer multiples of h .", "label": 1}, {"idx": "cosqa-train-6347", "doc": "python \"not in\" array", "code": "def notin(arg, values):\n    \"\"\"\n    Like isin, but checks whether this expression's value(s) are not\n    contained in the passed values. See isin docs for full usage.\n    \"\"\"\n    op = ops.NotContains(arg, values)\n    return op.to_expr()", "code_tokens": "def notin ( arg , values ) : op = ops . NotContains ( arg , values ) return op . to_expr ( )", "docstring_tokens": "Like isin but checks whether this expression s value ( s ) are not contained in the passed values . See isin docs for full usage .", "label": 1}, {"idx": "cosqa-train-6348", "doc": "python compute hash of numpy array", "code": "def np_hash(a):\n    \"\"\"Return a hash of a NumPy array.\"\"\"\n    if a is None:\n        return hash(None)\n    # Ensure that hashes are equal whatever the ordering in memory (C or\n    # Fortran)\n    a = np.ascontiguousarray(a)\n    # Compute the digest and return a decimal int\n    return int(hashlib.sha1(a.view(a.dtype)).hexdigest(), 16)", "code_tokens": "def np_hash ( a ) : if a is None : return hash ( None ) # Ensure that hashes are equal whatever the ordering in memory (C or # Fortran) a = np . ascontiguousarray ( a ) # Compute the digest and return a decimal int return int ( hashlib . sha1 ( a . view ( a . dtype ) ) . hexdigest ( ) , 16 )", "docstring_tokens": "Return a hash of a NumPy array .", "label": 1}, {"idx": "cosqa-train-6349", "doc": "python code on how to remove \"\" yaml dumper adds while writting into yaml file", "code": "def string_presenter(self, dumper, data):\n    \"\"\"Presenter to force yaml.dump to use multi-line string style.\"\"\"\n    if '\\n' in data:\n      return dumper.represent_scalar('tag:yaml.org,2002:str', data, style='|')\n    else:\n      return dumper.represent_scalar('tag:yaml.org,2002:str', data)", "code_tokens": "def string_presenter ( self , dumper , data ) : if '\\n' in data : return dumper . represent_scalar ( 'tag:yaml.org,2002:str' , data , style = '|' ) else : return dumper . represent_scalar ( 'tag:yaml.org,2002:str' , data )", "docstring_tokens": "Presenter to force yaml . dump to use multi - line string style .", "label": 1}, {"idx": "cosqa-train-6350", "doc": "python concat on different column names", "code": "def join_cols(cols):\n    \"\"\"Join list of columns into a string for a SQL query\"\"\"\n    return \", \".join([i for i in cols]) if isinstance(cols, (list, tuple, set)) else cols", "code_tokens": "def join_cols ( cols ) : return \", \" . join ( [ i for i in cols ] ) if isinstance ( cols , ( list , tuple , set ) ) else cols", "docstring_tokens": "Join list of columns into a string for a SQL query", "label": 0}, {"idx": "cosqa-train-6351", "doc": "python encode(\"base64\") carriage returns", "code": "def bytes_base64(x):\n    \"\"\"Turn bytes into base64\"\"\"\n    if six.PY2:\n        return base64.encodestring(x).replace('\\n', '')\n    return base64.encodebytes(bytes_encode(x)).replace(b'\\n', b'')", "code_tokens": "def bytes_base64 ( x ) : if six . PY2 : return base64 . encodestring ( x ) . replace ( '\\n' , '' ) return base64 . encodebytes ( bytes_encode ( x ) ) . replace ( b'\\n' , b'' )", "docstring_tokens": "Turn bytes into base64", "label": 1}, {"idx": "cosqa-train-6352", "doc": "python concat to datetime", "code": "def date_to_datetime(x):\n    \"\"\"Convert a date into a datetime\"\"\"\n    if not isinstance(x, datetime) and isinstance(x, date):\n        return datetime.combine(x, time())\n    return x", "code_tokens": "def date_to_datetime ( x ) : if not isinstance ( x , datetime ) and isinstance ( x , date ) : return datetime . combine ( x , time ( ) ) return x", "docstring_tokens": "Convert a date into a datetime", "label": 0}, {"idx": "cosqa-train-6353", "doc": "12 bit image stored as uint16 map to uint8 python", "code": "def uint32_to_uint8(cls, img):\n        \"\"\"\n        Cast uint32 RGB image to 4 uint8 channels.\n        \"\"\"\n        return np.flipud(img.view(dtype=np.uint8).reshape(img.shape + (4,)))", "code_tokens": "def uint32_to_uint8 ( cls , img ) : return np . flipud ( img . view ( dtype = np . uint8 ) . reshape ( img . shape + ( 4 , ) ) )", "docstring_tokens": "Cast uint32 RGB image to 4 uint8 channels .", "label": 0}, {"idx": "cosqa-train-6354", "doc": "python connect to redis in other docker container", "code": "def __connect():\n    \"\"\"\n    Connect to a redis instance.\n    \"\"\"\n    global redis_instance\n    if use_tcp_socket:\n        redis_instance = redis.StrictRedis(host=hostname, port=port)\n    else:\n        redis_instance = redis.StrictRedis(unix_socket_path=unix_socket)", "code_tokens": "def __connect ( ) : global redis_instance if use_tcp_socket : redis_instance = redis . StrictRedis ( host = hostname , port = port ) else : redis_instance = redis . StrictRedis ( unix_socket_path = unix_socket )", "docstring_tokens": "Connect to a redis instance .", "label": 1}, {"idx": "cosqa-train-6355", "doc": "2 grams python tokenize", "code": "def tokenize(string):\n    \"\"\"Match and yield all the tokens of the input string.\"\"\"\n    for match in TOKENS_REGEX.finditer(string):\n        yield Token(match.lastgroup, match.group().strip(), match.span())", "code_tokens": "def tokenize ( string ) : for match in TOKENS_REGEX . finditer ( string ) : yield Token ( match . lastgroup , match . group ( ) . strip ( ) , match . span ( ) )", "docstring_tokens": "Match and yield all the tokens of the input string .", "label": 1}, {"idx": "cosqa-train-6356", "doc": "python constant conform upper case", "code": "def normalize_enum_constant(s):\n    \"\"\"Return enum constant `s` converted to a canonical snake-case.\"\"\"\n    if s.islower(): return s\n    if s.isupper(): return s.lower()\n    return \"\".join(ch if ch.islower() else \"_\" + ch.lower() for ch in s).strip(\"_\")", "code_tokens": "def normalize_enum_constant ( s ) : if s . islower ( ) : return s if s . isupper ( ) : return s . lower ( ) return \"\" . join ( ch if ch . islower ( ) else \"_\" + ch . lower ( ) for ch in s ) . strip ( \"_\" )", "docstring_tokens": "Return enum constant s converted to a canonical snake - case .", "label": 0}, {"idx": "cosqa-train-6357", "doc": "2d array of list in python", "code": "def torecarray(*args, **kwargs):\n    \"\"\"\n    Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.\n\n    \"\"\"\n\n    import numpy as np\n    return toarray(*args, **kwargs).view(np.recarray)", "code_tokens": "def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )", "docstring_tokens": "Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) .", "label": 1}, {"idx": "cosqa-train-6358", "doc": "python constructor merge dict", "code": "def fromDict(cls, _dict):\n        \"\"\" Builds instance from dictionary of properties. \"\"\"\n        obj = cls()\n        obj.__dict__.update(_dict)\n        return obj", "code_tokens": "def fromDict ( cls , _dict ) : obj = cls ( ) obj . __dict__ . update ( _dict ) return obj", "docstring_tokens": "Builds instance from dictionary of properties .", "label": 1}, {"idx": "cosqa-train-6359", "doc": "2d arrays python access elements", "code": "def array(self):\n        \"\"\"\n        The underlying array of shape (N, L, I)\n        \"\"\"\n        return numpy.array([self[sid].array for sid in sorted(self)])", "code_tokens": "def array ( self ) : return numpy . array ( [ self [ sid ] . array for sid in sorted ( self ) ] )", "docstring_tokens": "The underlying array of shape ( N L I )", "label": 0}, {"idx": "cosqa-train-6360", "doc": "python contains logicl test", "code": "def instance_contains(container, item):\n    \"\"\"Search into instance attributes, properties and return values of no-args methods.\"\"\"\n    return item in (member for _, member in inspect.getmembers(container))", "code_tokens": "def instance_contains ( container , item ) : return item in ( member for _ , member in inspect . getmembers ( container ) )", "docstring_tokens": "Search into instance attributes properties and return values of no - args methods .", "label": 1}, {"idx": "cosqa-train-6361", "doc": "2d convolution python numpy", "code": "def conv1x1(in_planes, out_planes, stride=1):\n    \"\"\"1x1 convolution\"\"\"\n    return nn.Conv2d(in_planes, out_planes, kernel_size=1, stride=stride, bias=False)", "code_tokens": "def conv1x1 ( in_planes , out_planes , stride = 1 ) : return nn . Conv2d ( in_planes , out_planes , kernel_size = 1 , stride = stride , bias = False )", "docstring_tokens": "1x1 convolution", "label": 0}, {"idx": "cosqa-train-6362", "doc": "python contour plot interpolation", "code": "def get_line_flux(line_wave, wave, flux, **kwargs):\n    \"\"\"Interpolated flux at a given wavelength (calls np.interp).\"\"\"\n    return np.interp(line_wave, wave, flux, **kwargs)", "code_tokens": "def get_line_flux ( line_wave , wave , flux , * * kwargs ) : return np . interp ( line_wave , wave , flux , * * kwargs )", "docstring_tokens": "Interpolated flux at a given wavelength ( calls np . interp ) .", "label": 0}, {"idx": "cosqa-train-6363", "doc": "3d line intersection python", "code": "def line_line_intersect(x, y):\n    \"\"\"Compute the intersection point of two lines\n\n    Parameters\n    ----------\n    x = x4 array: x1, x2, x3, x4\n    y = x4 array: y1, y2, y3, y4\n    line 1 is defined by p1,p2\n    line 2 is defined by p3,p4\n\n    Returns\n    -------\n    Ix: x-coordinate of intersection\n    Iy: y-coordinate of intersection\n    \"\"\"\n    A = x[0] * y[1] - y[0] * x[1]\n    B = x[2] * y[3] - y[2] * x[4]\n    C = (x[0] - x[1]) * (y[2] - y[3]) - (y[0] - y[1]) * (x[2] - x[3])\n\n    Ix = (A * (x[2] - x[3]) - (x[0] - x[1]) * B) / C\n    Iy = (A * (y[2] - y[3]) - (y[0] - y[1]) * B) / C\n    return Ix, Iy", "code_tokens": "def line_line_intersect ( x , y ) : A = x [ 0 ] * y [ 1 ] - y [ 0 ] * x [ 1 ] B = x [ 2 ] * y [ 3 ] - y [ 2 ] * x [ 4 ] C = ( x [ 0 ] - x [ 1 ] ) * ( y [ 2 ] - y [ 3 ] ) - ( y [ 0 ] - y [ 1 ] ) * ( x [ 2 ] - x [ 3 ] ) Ix = ( A * ( x [ 2 ] - x [ 3 ] ) - ( x [ 0 ] - x [ 1 ] ) * B ) / C Iy = ( A * ( y [ 2 ] - y [ 3 ] ) - ( y [ 0 ] - y [ 1 ] ) * B ) / C return Ix , Iy", "docstring_tokens": "Compute the intersection point of two lines", "label": 0}, {"idx": "cosqa-train-6364", "doc": "python conver string date to date object", "code": "def deserialize_date(string):\n    \"\"\"\n    Deserializes string to date.\n\n    :param string: str.\n    :type string: str\n    :return: date.\n    :rtype: date\n    \"\"\"\n    try:\n        from dateutil.parser import parse\n        return parse(string).date()\n    except ImportError:\n        return string", "code_tokens": "def deserialize_date ( string ) : try : from dateutil . parser import parse return parse ( string ) . date ( ) except ImportError : return string", "docstring_tokens": "Deserializes string to date .", "label": 1}, {"idx": "cosqa-train-6365", "doc": "a comment in python is indicated by a", "code": "def to_comment(value):\n  \"\"\"\n  Builds a comment.\n  \"\"\"\n  if value is None:\n    return\n  if len(value.split('\\n')) == 1:\n    return \"* \" + value\n  else:\n    return '\\n'.join([' * ' + l for l in value.split('\\n')[:-1]])", "code_tokens": "def to_comment ( value ) : if value is None : return if len ( value . split ( '\\n' ) ) == 1 : return \"* \" + value else : return '\\n' . join ( [ ' * ' + l for l in value . split ( '\\n' ) [ : - 1 ] ] )", "docstring_tokens": "Builds a comment .", "label": 0}, {"idx": "cosqa-train-6366", "doc": "python converta series to percentage", "code": "def from_series(series):\n        \"\"\"\n        Deseralize a PercentRankTransform the given pandas.Series, as returned\n        by `to_series()`.\n\n        Parameters\n        ----------\n        series : pandas.Series\n\n        Returns\n        -------\n        PercentRankTransform\n\n        \"\"\"\n        result = PercentRankTransform()\n        result.cdf = series.values\n        result.bin_edges = series.index.values[1:-1]\n        return result", "code_tokens": "def from_series ( series ) : result = PercentRankTransform ( ) result . cdf = series . values result . bin_edges = series . index . values [ 1 : - 1 ] return result", "docstring_tokens": "Deseralize a PercentRankTransform the given pandas . Series as returned by to_series () .", "label": 0}, {"idx": "cosqa-train-6367", "doc": "accesing elements in a heap in python", "code": "def fix(h, i):\n    \"\"\"Rearrange the heap after the item at position i got updated.\"\"\"\n    down(h, i, h.size())\n    up(h, i)", "code_tokens": "def fix ( h , i ) : down ( h , i , h . size ( ) ) up ( h , i )", "docstring_tokens": "Rearrange the heap after the item at position i got updated .", "label": 1}, {"idx": "cosqa-train-6368", "doc": "python convolve gives bright spot in center of image", "code": "def convolve_gaussian_2d(image, gaussian_kernel_1d):\n    \"\"\"Convolve 2d gaussian.\"\"\"\n    result = scipy.ndimage.filters.correlate1d(\n        image, gaussian_kernel_1d, axis=0)\n    result = scipy.ndimage.filters.correlate1d(\n        result, gaussian_kernel_1d, axis=1)\n    return result", "code_tokens": "def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result", "docstring_tokens": "Convolve 2d gaussian .", "label": 1}, {"idx": "cosqa-train-6369", "doc": "access column in python row cursor", "code": "def get_cursor(self):\n        \"\"\"Returns current grid cursor cell (row, col, tab)\"\"\"\n\n        return self.grid.GetGridCursorRow(), self.grid.GetGridCursorCol(), \\\n            self.grid.current_table", "code_tokens": "def get_cursor ( self ) : return self . grid . GetGridCursorRow ( ) , self . grid . GetGridCursorCol ( ) , self . grid . current_table", "docstring_tokens": "Returns current grid cursor cell ( row col tab )", "label": 0}, {"idx": "cosqa-train-6370", "doc": "python copy and replace file without asking", "code": "def copyFile(input, output, replace=None):\n    \"\"\"Copy a file whole from input to output.\"\"\"\n\n    _found = findFile(output)\n    if not _found or (_found and replace):\n        shutil.copy2(input, output)", "code_tokens": "def copyFile ( input , output , replace = None ) : _found = findFile ( output ) if not _found or ( _found and replace ) : shutil . copy2 ( input , output )", "docstring_tokens": "Copy a file whole from input to output .", "label": 1}, {"idx": "cosqa-train-6371", "doc": "access first element of queue python", "code": "def PopTask(self):\n    \"\"\"Retrieves and removes the first task from the heap.\n\n    Returns:\n      Task: the task or None if the heap is empty.\n    \"\"\"\n    try:\n      _, task = heapq.heappop(self._heap)\n\n    except IndexError:\n      return None\n    self._task_identifiers.remove(task.identifier)\n    return task", "code_tokens": "def PopTask ( self ) : try : _ , task = heapq . heappop ( self . _heap ) except IndexError : return None self . _task_identifiers . remove ( task . identifier ) return task", "docstring_tokens": "Retrieves and removes the first task from the heap .", "label": 1}, {"idx": "cosqa-train-6372", "doc": "python copy array to ctypes array", "code": "def c_array(ctype, values):\n    \"\"\"Convert a python string to c array.\"\"\"\n    if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype):\n        return (ctype * len(values)).from_buffer_copy(values)\n    return (ctype * len(values))(*values)", "code_tokens": "def c_array ( ctype , values ) : if isinstance ( values , np . ndarray ) and values . dtype . itemsize == ctypes . sizeof ( ctype ) : return ( ctype * len ( values ) ) . from_buffer_copy ( values ) return ( ctype * len ( values ) ) ( * values )", "docstring_tokens": "Convert a python string to c array .", "label": 1}, {"idx": "cosqa-train-6373", "doc": "access parent pointer python", "code": "def find_root(self):\n        \"\"\" Traverse parent refs to top. \"\"\"\n        cmd = self\n        while cmd.parent:\n            cmd = cmd.parent\n        return cmd", "code_tokens": "def find_root ( self ) : cmd = self while cmd . parent : cmd = cmd . parent return cmd", "docstring_tokens": "Traverse parent refs to top .", "label": 0}, {"idx": "cosqa-train-6374", "doc": "accessing input field in a form python flask", "code": "def parse_form(self, req, name, field):\n        \"\"\"Pull a form value from the request.\"\"\"\n        return get_value(req.body_arguments, name, field)", "code_tokens": "def parse_form ( self , req , name , field ) : return get_value ( req . body_arguments , name , field )", "docstring_tokens": "Pull a form value from the request .", "label": 0}, {"idx": "cosqa-train-6375", "doc": "python count the frequency of a particular word in a text file", "code": "def wordfreq(text, is_filename=False):\n    \"\"\"Return a dictionary of words and word counts in a string.\"\"\"\n    if is_filename:\n        with open(text) as f:\n            text = f.read()\n    freqs = {}\n    for word in text.split():\n        lword = word.lower()\n        freqs[lword] = freqs.get(lword, 0) + 1\n    return freqs", "code_tokens": "def wordfreq ( text , is_filename = False ) : if is_filename : with open ( text ) as f : text = f . read ( ) freqs = { } for word in text . split ( ) : lword = word . lower ( ) freqs [ lword ] = freqs . get ( lword , 0 ) + 1 return freqs", "docstring_tokens": "Return a dictionary of words and word counts in a string .", "label": 1}, {"idx": "cosqa-train-6376", "doc": "add 1 to a letter to increment it python", "code": "def _increment_numeric_suffix(s):\n        \"\"\"Increment (or add) numeric suffix to identifier.\"\"\"\n        if re.match(r\".*\\d+$\", s):\n            return re.sub(r\"\\d+$\", lambda n: str(int(n.group(0)) + 1), s)\n        return s + \"_2\"", "code_tokens": "def _increment_numeric_suffix ( s ) : if re . match ( r\".*\\d+$\" , s ) : return re . sub ( r\"\\d+$\" , lambda n : str ( int ( n . group ( 0 ) ) + 1 ) , s ) return s + \"_2\"", "docstring_tokens": "Increment ( or add ) numeric suffix to identifier .", "label": 0}, {"idx": "cosqa-train-6377", "doc": "python count words in sentences", "code": "def count(lines):\n  \"\"\" Counts the word frequences in a list of sentences.\n\n  Note:\n    This is a helper function for parallel execution of `Vocabulary.from_text`\n    method.\n  \"\"\"\n  words = [w for l in lines for w in l.strip().split()]\n  return Counter(words)", "code_tokens": "def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )", "docstring_tokens": "Counts the word frequences in a list of sentences .", "label": 0}, {"idx": "cosqa-train-6378", "doc": "add a comma in python to a string", "code": "def seq_to_str(obj, sep=\",\"):\n    \"\"\"\n    Given a sequence convert it to a comma separated string.\n    If, however, the argument is a single object, return its string\n    representation.\n    \"\"\"\n    if isinstance(obj, string_classes):\n        return obj\n    elif isinstance(obj, (list, tuple)):\n        return sep.join([str(x) for x in obj])\n    else:\n        return str(obj)", "code_tokens": "def seq_to_str ( obj , sep = \",\" ) : if isinstance ( obj , string_classes ) : return obj elif isinstance ( obj , ( list , tuple ) ) : return sep . join ( [ str ( x ) for x in obj ] ) else : return str ( obj )", "docstring_tokens": "Given a sequence convert it to a comma separated string . If however the argument is a single object return its string representation .", "label": 1}, {"idx": "cosqa-train-6379", "doc": "python covert datetime to timestamp", "code": "def convert_timestamp(timestamp):\n    \"\"\"\n    Converts bokehJS timestamp to datetime64.\n    \"\"\"\n    datetime = dt.datetime.utcfromtimestamp(timestamp/1000.)\n    return np.datetime64(datetime.replace(tzinfo=None))", "code_tokens": "def convert_timestamp ( timestamp ) : datetime = dt . datetime . utcfromtimestamp ( timestamp / 1000. ) return np . datetime64 ( datetime . replace ( tzinfo = None ) )", "docstring_tokens": "Converts bokehJS timestamp to datetime64 .", "label": 1}, {"idx": "cosqa-train-6380", "doc": "add conda python to environment variables", "code": "def update(packages, env=None, user=None):\n    \"\"\"\n    Update conda packages in a conda env\n\n    Attributes\n    ----------\n        packages: list of packages comma delimited\n    \"\"\"\n    packages = ' '.join(packages.split(','))\n    cmd = _create_conda_cmd('update', args=[packages, '--yes', '-q'], env=env, user=user)\n    return _execcmd(cmd, user=user)", "code_tokens": "def update ( packages , env = None , user = None ) : packages = ' ' . join ( packages . split ( ',' ) ) cmd = _create_conda_cmd ( 'update' , args = [ packages , '--yes' , '-q' ] , env = env , user = user ) return _execcmd ( cmd , user = user )", "docstring_tokens": "Update conda packages in a conda env", "label": 0}, {"idx": "cosqa-train-6381", "doc": "python covert namedtuple to unnamed", "code": "def get_ntobj(self):\n        \"\"\"Create namedtuple object with GOEA fields.\"\"\"\n        if self.nts:\n            return cx.namedtuple(\"ntgoea\", \" \".join(vars(next(iter(self.nts))).keys()))", "code_tokens": "def get_ntobj ( self ) : if self . nts : return cx . namedtuple ( \"ntgoea\" , \" \" . join ( vars ( next ( iter ( self . nts ) ) ) . keys ( ) ) )", "docstring_tokens": "Create namedtuple object with GOEA fields .", "label": 0}, {"idx": "cosqa-train-6382", "doc": "add index support objects python", "code": "def to_index(self, index_type, index_name, includes=None):\n        \"\"\" Create an index field from this field \"\"\"\n        return IndexField(self.name, self.data_type, index_type, index_name, includes)", "code_tokens": "def to_index ( self , index_type , index_name , includes = None ) : return IndexField ( self . name , self . data_type , index_type , index_name , includes )", "docstring_tokens": "Create an index field from this field", "label": 1}, {"idx": "cosqa-train-6383", "doc": "python create a hash value from a numpy array", "code": "def array_sha256(a):\n    \"\"\"Create a SHA256 hash from a Numpy array.\"\"\"\n    dtype = str(a.dtype).encode()\n    shape = numpy.array(a.shape)\n    sha = hashlib.sha256()\n    sha.update(dtype)\n    sha.update(shape)\n    sha.update(a.tobytes())\n    return sha.hexdigest()", "code_tokens": "def array_sha256 ( a ) : dtype = str ( a . dtype ) . encode ( ) shape = numpy . array ( a . shape ) sha = hashlib . sha256 ( ) sha . update ( dtype ) sha . update ( shape ) sha . update ( a . tobytes ( ) ) return sha . hexdigest ( )", "docstring_tokens": "Create a SHA256 hash from a Numpy array .", "label": 1}, {"idx": "cosqa-train-6384", "doc": "add method to enum python", "code": "def _Enum(docstring, *names):\n  \"\"\"Utility to generate enum classes used by annotations.\n\n  Args:\n    docstring: Docstring for the generated enum class.\n    *names: Enum names.\n\n  Returns:\n    A class that contains enum names as attributes.\n  \"\"\"\n  enums = dict(zip(names, range(len(names))))\n  reverse = dict((value, key) for key, value in enums.iteritems())\n  enums['reverse_mapping'] = reverse\n  enums['__doc__'] = docstring\n  return type('Enum', (object,), enums)", "code_tokens": "def _Enum ( docstring , * names ) : enums = dict ( zip ( names , range ( len ( names ) ) ) ) reverse = dict ( ( value , key ) for key , value in enums . iteritems ( ) ) enums [ 'reverse_mapping' ] = reverse enums [ '__doc__' ] = docstring return type ( 'Enum' , ( object , ) , enums )", "docstring_tokens": "Utility to generate enum classes used by annotations .", "label": 0}, {"idx": "cosqa-train-6385", "doc": "python create a logfile with date", "code": "def create_run_logfile(folder):\n    \"\"\"Create a 'run.log' within folder. This file contains the time of the\n       latest successful run.\n    \"\"\"\n    with open(os.path.join(folder, \"run.log\"), \"w\") as f:\n        datestring = datetime.datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%S\")\n        f.write(\"timestamp: '%s'\" % datestring)", "code_tokens": "def create_run_logfile ( folder ) : with open ( os . path . join ( folder , \"run.log\" ) , \"w\" ) as f : datestring = datetime . datetime . utcnow ( ) . strftime ( \"%Y-%m-%d %H:%M:%S\" ) f . write ( \"timestamp: '%s'\" % datestring )", "docstring_tokens": "Create a run . log within folder . This file contains the time of the latest successful run .", "label": 1}, {"idx": "cosqa-train-6386", "doc": "add noise on image using python", "code": "def shot_noise(x, severity=1):\n  \"\"\"Shot noise corruption to images.\n\n  Args:\n    x: numpy array, uncorrupted image, assumed to have uint8 pixel in [0,255].\n    severity: integer, severity of corruption.\n\n  Returns:\n    numpy array, image with uint8 pixels in [0,255]. Added shot noise.\n  \"\"\"\n  c = [60, 25, 12, 5, 3][severity - 1]\n  x = np.array(x) / 255.\n  x_clip = np.clip(np.random.poisson(x * c) / float(c), 0, 1) * 255\n  return around_and_astype(x_clip)", "code_tokens": "def shot_noise ( x , severity = 1 ) : c = [ 60 , 25 , 12 , 5 , 3 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( np . random . poisson ( x * c ) / float ( c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )", "docstring_tokens": "Shot noise corruption to images .", "label": 0}, {"idx": "cosqa-train-6387", "doc": "python create a type from a type name", "code": "def construct_from_string(cls, string):\n        \"\"\"\n        Construction from a string, raise a TypeError if not\n        possible\n        \"\"\"\n        if string == cls.name:\n            return cls()\n        raise TypeError(\"Cannot construct a '{}' from \"\n                        \"'{}'\".format(cls, string))", "code_tokens": "def construct_from_string ( cls , string ) : if string == cls . name : return cls ( ) raise TypeError ( \"Cannot construct a '{}' from \" \"'{}'\" . format ( cls , string ) )", "docstring_tokens": "Construction from a string raise a TypeError if not possible", "label": 1}, {"idx": "cosqa-train-6388", "doc": "add standard deviations to graph python", "code": "def weighted_std(values, weights):\n    \"\"\" Calculate standard deviation weighted by errors \"\"\"\n    average = np.average(values, weights=weights)\n    variance = np.average((values-average)**2, weights=weights)\n    return np.sqrt(variance)", "code_tokens": "def weighted_std ( values , weights ) : average = np . average ( values , weights = weights ) variance = np . average ( ( values - average ) ** 2 , weights = weights ) return np . sqrt ( variance )", "docstring_tokens": "Calculate standard deviation weighted by errors", "label": 1}, {"idx": "cosqa-train-6389", "doc": "python create array from bytes", "code": "def be_array_from_bytes(fmt, data):\n    \"\"\"\n    Reads an array from bytestring with big-endian data.\n    \"\"\"\n    arr = array.array(str(fmt), data)\n    return fix_byteorder(arr)", "code_tokens": "def be_array_from_bytes ( fmt , data ) : arr = array . array ( str ( fmt ) , data ) return fix_byteorder ( arr )", "docstring_tokens": "Reads an array from bytestring with big - endian data .", "label": 0}, {"idx": "cosqa-train-6390", "doc": "add suffixes on concat python", "code": "def add_suffix(fullname, suffix):\n    \"\"\" Add suffix to a full file name\"\"\"\n    name, ext = os.path.splitext(fullname)\n    return name + '_' + suffix + ext", "code_tokens": "def add_suffix ( fullname , suffix ) : name , ext = os . path . splitext ( fullname ) return name + '_' + suffix + ext", "docstring_tokens": "Add suffix to a full file name", "label": 1}, {"idx": "cosqa-train-6391", "doc": "python create blank column in df", "code": "def add_blank_row(self, label):\n        \"\"\"\n        Add a blank row with only an index value to self.df.\n        This is done inplace.\n        \"\"\"\n        col_labels = self.df.columns\n        blank_item = pd.Series({}, index=col_labels, name=label)\n        # use .loc to add in place (append won't do that)\n        self.df.loc[blank_item.name] = blank_item\n        return self.df", "code_tokens": "def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df", "docstring_tokens": "Add a blank row with only an index value to self . df . This is done inplace .", "label": 1}, {"idx": "cosqa-train-6392", "doc": "add text im image in python", "code": "def add_text_to_image(fname, txt, opFilename):\n    \"\"\" convert an image by adding text \"\"\"\n    ft = ImageFont.load(\"T://user//dev//src//python//_AS_LIB//timR24.pil\")\n    #wh = ft.getsize(txt)\n    print(\"Adding text \", txt, \" to \", fname, \" pixels wide to file \" , opFilename)\n    im = Image.open(fname)\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), txt, fill=(0, 0, 0), font=ft)\n    del draw  \n    im.save(opFilename)", "code_tokens": "def add_text_to_image ( fname , txt , opFilename ) : ft = ImageFont . load ( \"T://user//dev//src//python//_AS_LIB//timR24.pil\" ) #wh = ft.getsize(txt) print ( \"Adding text \" , txt , \" to \" , fname , \" pixels wide to file \" , opFilename ) im = Image . open ( fname ) draw = ImageDraw . Draw ( im ) draw . text ( ( 0 , 0 ) , txt , fill = ( 0 , 0 , 0 ) , font = ft ) del draw im . save ( opFilename )", "docstring_tokens": "convert an image by adding text", "label": 0}, {"idx": "cosqa-train-6393", "doc": "python create column as dictionary", "code": "def to_dict(self):\n        \"\"\"\n        Serialize representation of the column for local caching.\n        \"\"\"\n        return {'schema': self.schema, 'table': self.table, 'name': self.name, 'type': self.type}", "code_tokens": "def to_dict ( self ) : return { 'schema' : self . schema , 'table' : self . table , 'name' : self . name , 'type' : self . type }", "docstring_tokens": "Serialize representation of the column for local caching .", "label": 1}, {"idx": "cosqa-train-6394", "doc": "add update merge comncatentate two dictionaries python", "code": "def deep_update(d, u):\n  \"\"\"Deeply updates a dictionary. List values are concatenated.\n\n  Args:\n    d (dict): First dictionary which will be updated\n    u (dict): Second dictionary use to extend the first one\n\n  Returns:\n    dict: The merge dictionary\n\n  \"\"\"\n\n  for k, v in u.items():\n    if isinstance(v, Mapping):\n      d[k] = deep_update(d.get(k, {}), v)\n    elif isinstance(v, list):\n      existing_elements = d.get(k, [])\n      d[k] = existing_elements + [ele for ele in v if ele not in existing_elements]\n    else:\n      d[k] = v\n\n  return d", "code_tokens": "def deep_update ( d , u ) : for k , v in u . items ( ) : if isinstance ( v , Mapping ) : d [ k ] = deep_update ( d . get ( k , { } ) , v ) elif isinstance ( v , list ) : existing_elements = d . get ( k , [ ] ) d [ k ] = existing_elements + [ ele for ele in v if ele not in existing_elements ] else : d [ k ] = v return d", "docstring_tokens": "Deeply updates a dictionary . List values are concatenated .", "label": 1}, {"idx": "cosqa-train-6395", "doc": "python create directory and any missing parent directories", "code": "def makedirs(directory):\n    \"\"\" Resursively create a named directory. \"\"\"\n    parent = os.path.dirname(os.path.abspath(directory))\n    if not os.path.exists(parent):\n        makedirs(parent)\n    os.mkdir(directory)", "code_tokens": "def makedirs ( directory ) : parent = os . path . dirname ( os . path . abspath ( directory ) ) if not os . path . exists ( parent ) : makedirs ( parent ) os . mkdir ( directory )", "docstring_tokens": "Resursively create a named directory .", "label": 1}, {"idx": "cosqa-train-6396", "doc": "adding multiple spaces between characters in a string python", "code": "def indent(s, spaces=4):\n    \"\"\"\n    Inserts `spaces` after each string of new lines in `s`\n    and before the start of the string.\n    \"\"\"\n    new = re.sub('(\\n+)', '\\\\1%s' % (' ' * spaces), s)\n    return (' ' * spaces) + new.strip()", "code_tokens": "def indent ( s , spaces = 4 ) : new = re . sub ( '(\\n+)' , '\\\\1%s' % ( ' ' * spaces ) , s ) return ( ' ' * spaces ) + new . strip ( )", "docstring_tokens": "Inserts spaces after each string of new lines in s and before the start of the string .", "label": 1}, {"idx": "cosqa-train-6397", "doc": "python create directory parent", "code": "def makedirs(directory):\n    \"\"\" Resursively create a named directory. \"\"\"\n    parent = os.path.dirname(os.path.abspath(directory))\n    if not os.path.exists(parent):\n        makedirs(parent)\n    os.mkdir(directory)", "code_tokens": "def makedirs ( directory ) : parent = os . path . dirname ( os . path . abspath ( directory ) ) if not os . path . exists ( parent ) : makedirs ( parent ) os . mkdir ( directory )", "docstring_tokens": "Resursively create a named directory .", "label": 1}, {"idx": "cosqa-train-6398", "doc": "adding python code in html", "code": "def  make_html_code( self, lines ):\n        \"\"\" convert a code sequence to HTML \"\"\"\n        line = code_header + '\\n'\n        for l in lines:\n            line = line + html_quote( l ) + '\\n'\n\n        return line + code_footer", "code_tokens": "def make_html_code ( self , lines ) : line = code_header + '\\n' for l in lines : line = line + html_quote ( l ) + '\\n' return line + code_footer", "docstring_tokens": "convert a code sequence to HTML", "label": 0}, {"idx": "cosqa-train-6399", "doc": "python create enum type at runtime", "code": "def _Enum(docstring, *names):\n  \"\"\"Utility to generate enum classes used by annotations.\n\n  Args:\n    docstring: Docstring for the generated enum class.\n    *names: Enum names.\n\n  Returns:\n    A class that contains enum names as attributes.\n  \"\"\"\n  enums = dict(zip(names, range(len(names))))\n  reverse = dict((value, key) for key, value in enums.iteritems())\n  enums['reverse_mapping'] = reverse\n  enums['__doc__'] = docstring\n  return type('Enum', (object,), enums)", "code_tokens": "def _Enum ( docstring , * names ) : enums = dict ( zip ( names , range ( len ( names ) ) ) ) reverse = dict ( ( value , key ) for key , value in enums . iteritems ( ) ) enums [ 'reverse_mapping' ] = reverse enums [ '__doc__' ] = docstring return type ( 'Enum' , ( object , ) , enums )", "docstring_tokens": "Utility to generate enum classes used by annotations .", "label": 1}, {"idx": "cosqa-train-6400", "doc": "adding vertices to a digraph in python", "code": "def CreateVertices(self, points):\n        \"\"\"\n        Returns a dictionary object with keys that are 2tuples\n        represnting a point.\n        \"\"\"\n        gr = digraph()\n\n        for z, x, Q in points:\n            node = (z, x, Q)\n            gr.add_nodes([node])\n\n        return gr", "code_tokens": "def CreateVertices ( self , points ) : gr = digraph ( ) for z , x , Q in points : node = ( z , x , Q ) gr . add_nodes ( [ node ] ) return gr", "docstring_tokens": "Returns a dictionary object with keys that are 2tuples represnting a point .", "label": 1}, {"idx": "cosqa-train-6401", "doc": "python create hash of a file", "code": "def generate_hash(filepath):\n    \"\"\"Public function that reads a local file and generates a SHA256 hash digest for it\"\"\"\n    fr = FileReader(filepath)\n    data = fr.read_bin()\n    return _calculate_sha256(data)", "code_tokens": "def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )", "docstring_tokens": "Public function that reads a local file and generates a SHA256 hash digest for it", "label": 1}, {"idx": "cosqa-train-6402", "doc": "adjust column width table python", "code": "def get_table_width(table):\n    \"\"\"\n    Gets the width of the table that would be printed.\n    :rtype: ``int``\n    \"\"\"\n    columns = transpose_table(prepare_rows(table))\n    widths = [max(len(cell) for cell in column) for column in columns]\n    return len('+' + '|'.join('-' * (w + 2) for w in widths) + '+')", "code_tokens": "def get_table_width ( table ) : columns = transpose_table ( prepare_rows ( table ) ) widths = [ max ( len ( cell ) for cell in column ) for column in columns ] return len ( '+' + '|' . join ( '-' * ( w + 2 ) for w in widths ) + '+' )", "docstring_tokens": "Gets the width of the table that would be printed . : rtype : int", "label": 1}, {"idx": "cosqa-train-6403", "doc": "python create key name from variable", "code": "def unit_key_from_name(name):\n  \"\"\"Return a legal python name for the given name for use as a unit key.\"\"\"\n  result = name\n\n  for old, new in six.iteritems(UNIT_KEY_REPLACEMENTS):\n    result = result.replace(old, new)\n\n  # Collapse redundant underscores and convert to uppercase.\n  result = re.sub(r'_+', '_', result.upper())\n\n  return result", "code_tokens": "def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result", "docstring_tokens": "Return a legal python name for the given name for use as a unit key .", "label": 0}, {"idx": "cosqa-train-6404", "doc": "adjust time zone python", "code": "def normalize_time(timestamp):\n    \"\"\"Normalize time in arbitrary timezone to UTC naive object.\"\"\"\n    offset = timestamp.utcoffset()\n    if offset is None:\n        return timestamp\n    return timestamp.replace(tzinfo=None) - offset", "code_tokens": "def normalize_time ( timestamp ) : offset = timestamp . utcoffset ( ) if offset is None : return timestamp return timestamp . replace ( tzinfo = None ) - offset", "docstring_tokens": "Normalize time in arbitrary timezone to UTC naive object .", "label": 0}, {"idx": "cosqa-train-6405", "doc": "python create list from comma delimeted string", "code": "def split_elements(value):\n    \"\"\"Split a string with comma or space-separated elements into a list.\"\"\"\n    l = [v.strip() for v in value.split(',')]\n    if len(l) == 1:\n        l = value.split()\n    return l", "code_tokens": "def split_elements ( value ) : l = [ v . strip ( ) for v in value . split ( ',' ) ] if len ( l ) == 1 : l = value . split ( ) return l", "docstring_tokens": "Split a string with comma or space - separated elements into a list .", "label": 1}, {"idx": "cosqa-train-6406", "doc": "anaconda python 3 tensorflow", "code": "def transformer_ae_a3():\n  \"\"\"Set of hyperparameters.\"\"\"\n  hparams = transformer_ae_base()\n  hparams.batch_size = 4096\n  hparams.layer_prepostprocess_dropout = 0.3\n  hparams.optimizer = \"Adafactor\"\n  hparams.learning_rate = 0.25\n  hparams.learning_rate_warmup_steps = 10000\n  return hparams", "code_tokens": "def transformer_ae_a3 ( ) : hparams = transformer_ae_base ( ) hparams . batch_size = 4096 hparams . layer_prepostprocess_dropout = 0.3 hparams . optimizer = \"Adafactor\" hparams . learning_rate = 0.25 hparams . learning_rate_warmup_steps = 10000 return hparams", "docstring_tokens": "Set of hyperparameters .", "label": 1}, {"idx": "cosqa-train-6407", "doc": "python create null pointer with ctypes", "code": "def POINTER(obj):\n    \"\"\"\n    Create ctypes pointer to object.\n\n    Notes\n    -----\n    This function converts None to a real NULL pointer because of bug\n    in how ctypes handles None on 64-bit platforms.\n\n    \"\"\"\n\n    p = ctypes.POINTER(obj)\n    if not isinstance(p.from_param, classmethod):\n        def from_param(cls, x):\n            if x is None:\n                return cls()\n            else:\n                return x\n        p.from_param = classmethod(from_param)\n\n    return p", "code_tokens": "def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p", "docstring_tokens": "Create ctypes pointer to object .", "label": 1}, {"idx": "cosqa-train-6408", "doc": "angle between two vectors python", "code": "def vec_angle(a, b):\n    \"\"\"\n    Calculate angle between two vectors\n    \"\"\"\n    cosang = np.dot(a, b)\n    sinang = fast_norm(np.cross(a, b))\n    return np.arctan2(sinang, cosang)", "code_tokens": "def vec_angle ( a , b ) : cosang = np . dot ( a , b ) sinang = fast_norm ( np . cross ( a , b ) ) return np . arctan2 ( sinang , cosang )", "docstring_tokens": "Calculate angle between two vectors", "label": 1}, {"idx": "cosqa-train-6409", "doc": "python create random sparse matrix", "code": "def sp_rand(m,n,a):\n    \"\"\"\n    Generates an mxn sparse 'd' matrix with round(a*m*n) nonzeros.\n    \"\"\"\n    if m == 0 or n == 0: return spmatrix([], [], [], (m,n))\n    nnz = min(max(0, int(round(a*m*n))), m*n)\n    nz = matrix(random.sample(range(m*n), nnz), tc='i')\n    return spmatrix(normal(nnz,1), nz%m, matrix([int(ii) for ii in nz/m]), (m,n))", "code_tokens": "def sp_rand ( m , n , a ) : if m == 0 or n == 0 : return spmatrix ( [ ] , [ ] , [ ] , ( m , n ) ) nnz = min ( max ( 0 , int ( round ( a * m * n ) ) ) , m * n ) nz = matrix ( random . sample ( range ( m * n ) , nnz ) , tc = 'i' ) return spmatrix ( normal ( nnz , 1 ) , nz % m , matrix ( [ int ( ii ) for ii in nz / m ] ) , ( m , n ) )", "docstring_tokens": "Generates an mxn sparse d matrix with round ( a * m * n ) nonzeros .", "label": 0}, {"idx": "cosqa-train-6410", "doc": "append to end of line in file python", "code": "def prepend_line(filepath, line):\n    \"\"\"Rewrite a file adding a line to its beginning.\n    \"\"\"\n    with open(filepath) as f:\n        lines = f.readlines()\n\n    lines.insert(0, line)\n\n    with open(filepath, 'w') as f:\n        f.writelines(lines)", "code_tokens": "def prepend_line ( filepath , line ) : with open ( filepath ) as f : lines = f . readlines ( ) lines . insert ( 0 , line ) with open ( filepath , 'w' ) as f : f . writelines ( lines )", "docstring_tokens": "Rewrite a file adding a line to its beginning .", "label": 0}, {"idx": "cosqa-train-6411", "doc": "python create remote file ssh", "code": "def send_file(self, local_path, remote_path, user='root', unix_mode=None):\n        \"\"\"Upload a local file on the remote host.\n        \"\"\"\n        self.enable_user(user)\n        return self.ssh_pool.send_file(user, local_path, remote_path, unix_mode=unix_mode)", "code_tokens": "def send_file ( self , local_path , remote_path , user = 'root' , unix_mode = None ) : self . enable_user ( user ) return self . ssh_pool . send_file ( user , local_path , remote_path , unix_mode = unix_mode )", "docstring_tokens": "Upload a local file on the remote host .", "label": 1}, {"idx": "cosqa-train-6412", "doc": "appending and saving images in one pdf python", "code": "def save_image(pdf_path, img_path, page_num):\n    \"\"\"\n\n    Creates images for a page of the input pdf document and saves it\n    at img_path.\n\n    :param pdf_path: path to pdf to create images for.\n    :param img_path: path where to save the images.\n    :param page_num: page number to create image from in the pdf file.\n    :return:\n    \"\"\"\n    pdf_img = Image(filename=\"{}[{}]\".format(pdf_path, page_num))\n    with pdf_img.convert(\"png\") as converted:\n        # Set white background.\n        converted.background_color = Color(\"white\")\n        converted.alpha_channel = \"remove\"\n        converted.save(filename=img_path)", "code_tokens": "def save_image ( pdf_path , img_path , page_num ) : pdf_img = Image ( filename = \"{}[{}]\" . format ( pdf_path , page_num ) ) with pdf_img . convert ( \"png\" ) as converted : # Set white background. converted . background_color = Color ( \"white\" ) converted . alpha_channel = \"remove\" converted . save ( filename = img_path )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-6413", "doc": "python creating a directory path", "code": "def create_path(path):\n    \"\"\"Creates a absolute path in the file system.\n\n    :param path: The path to be created\n    \"\"\"\n    import os\n    if not os.path.exists(path):\n        os.makedirs(path)", "code_tokens": "def create_path ( path ) : import os if not os . path . exists ( path ) : os . makedirs ( path )", "docstring_tokens": "Creates a absolute path in the file system .", "label": 1}, {"idx": "cosqa-train-6414", "doc": "python csv print raw", "code": "def csvpretty(csvfile: csvfile=sys.stdin):\n    \"\"\" Pretty print a CSV file. \"\"\"\n    shellish.tabulate(csv.reader(csvfile))", "code_tokens": "def csvpretty ( csvfile : csvfile = sys . stdin ) : shellish . tabulate ( csv . reader ( csvfile ) )", "docstring_tokens": "Pretty print a CSV file .", "label": 0}, {"idx": "cosqa-train-6415", "doc": "are arange and linspace equivalent in python", "code": "def to_linspace(self):\n        \"\"\"\n        convert from full to linspace\n        \"\"\"\n        if hasattr(self.shape, '__len__'):\n            raise NotImplementedError(\"can only convert flat Full arrays to linspace\")\n        return Linspace(self.fill_value, self.fill_value, self.shape)", "code_tokens": "def to_linspace ( self ) : if hasattr ( self . shape , '__len__' ) : raise NotImplementedError ( \"can only convert flat Full arrays to linspace\" ) return Linspace ( self . fill_value , self . fill_value , self . shape )", "docstring_tokens": "convert from full to linspace", "label": 0}, {"idx": "cosqa-train-6416", "doc": "python ctype pointer to offset", "code": "def cint8_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes int pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_int8)):\n        return np.fromiter(cptr, dtype=np.int8, count=length)\n    else:\n        raise RuntimeError('Expected int pointer')", "code_tokens": "def cint8_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int8 ) ) : return np . fromiter ( cptr , dtype = np . int8 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "docstring_tokens": "Convert a ctypes int pointer array to a numpy array .", "label": 1}, {"idx": "cosqa-train-6417", "doc": "argparse python add subparser to subparser", "code": "def set_subparsers_args(self, *args, **kwargs):\n        \"\"\"\n        Sets args and kwargs that are passed when creating a subparsers group\n        in an argparse.ArgumentParser i.e. when calling\n        argparser.ArgumentParser.add_subparsers\n        \"\"\"\n        self.subparsers_args = args\n        self.subparsers_kwargs = kwargs", "code_tokens": "def set_subparsers_args ( self , * args , * * kwargs ) : self . subparsers_args = args self . subparsers_kwargs = kwargs", "docstring_tokens": "Sets args and kwargs that are passed when creating a subparsers group in an argparse . ArgumentParser i . e . when calling argparser . ArgumentParser . add_subparsers", "label": 1}, {"idx": "cosqa-train-6418", "doc": "python ctype return array with unknown length", "code": "def c_array(ctype, values):\n    \"\"\"Convert a python string to c array.\"\"\"\n    if isinstance(values, np.ndarray) and values.dtype.itemsize == ctypes.sizeof(ctype):\n        return (ctype * len(values)).from_buffer_copy(values)\n    return (ctype * len(values))(*values)", "code_tokens": "def c_array ( ctype , values ) : if isinstance ( values , np . ndarray ) and values . dtype . itemsize == ctypes . sizeof ( ctype ) : return ( ctype * len ( values ) ) . from_buffer_copy ( values ) return ( ctype * len ( values ) ) ( * values )", "docstring_tokens": "Convert a python string to c array .", "label": 1}, {"idx": "cosqa-train-6419", "doc": "ascii to hex converter in python", "code": "def hex_escape(bin_str):\n  \"\"\"\n  Hex encode a binary string\n  \"\"\"\n  printable = string.ascii_letters + string.digits + string.punctuation + ' '\n  return ''.join(ch if ch in printable else r'0x{0:02x}'.format(ord(ch)) for ch in bin_str)", "code_tokens": "def hex_escape ( bin_str ) : printable = string . ascii_letters + string . digits + string . punctuation + ' ' return '' . join ( ch if ch in printable else r'0x{0:02x}' . format ( ord ( ch ) ) for ch in bin_str )", "docstring_tokens": "Hex encode a binary string", "label": 1}, {"idx": "cosqa-train-6420", "doc": "assert match any value in python", "code": "def rex_assert(self, rex, byte=False):\n        \"\"\"\n        If `rex` expression is not found then raise `DataNotFound` exception.\n        \"\"\"\n\n        self.rex_search(rex, byte=byte)", "code_tokens": "def rex_assert ( self , rex , byte = False ) : self . rex_search ( rex , byte = byte )", "docstring_tokens": "If rex expression is not found then raise DataNotFound exception .", "label": 0}, {"idx": "cosqa-train-6421", "doc": "python ctypes callback function", "code": "def _monitor_callback_wrapper(callback):\n    \"\"\"A wrapper for the user-defined handle.\"\"\"\n    def callback_handle(name, array, _):\n        \"\"\" ctypes function \"\"\"\n        callback(name, array)\n    return callback_handle", "code_tokens": "def _monitor_callback_wrapper ( callback ) : def callback_handle ( name , array , _ ) : \"\"\" ctypes function \"\"\" callback ( name , array ) return callback_handle", "docstring_tokens": "A wrapper for the user - defined handle .", "label": 0}, {"idx": "cosqa-train-6422", "doc": "asyncio python open file", "code": "def _open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None,\n          closefd=True, opener=None, *, loop=None, executor=None):\n    \"\"\"Open an asyncio file.\"\"\"\n    if loop is None:\n        loop = asyncio.get_event_loop()\n    cb = partial(sync_open, file, mode=mode, buffering=buffering,\n                 encoding=encoding, errors=errors, newline=newline,\n                 closefd=closefd, opener=opener)\n    f = yield from loop.run_in_executor(executor, cb)\n\n    return wrap(f, loop=loop, executor=executor)", "code_tokens": "def _open ( file , mode = 'r' , buffering = - 1 , encoding = None , errors = None , newline = None , closefd = True , opener = None , * , loop = None , executor = None ) : if loop is None : loop = asyncio . get_event_loop ( ) cb = partial ( sync_open , file , mode = mode , buffering = buffering , encoding = encoding , errors = errors , newline = newline , closefd = closefd , opener = opener ) f = yield from loop . run_in_executor ( executor , cb ) return wrap ( f , loop = loop , executor = executor )", "docstring_tokens": "Open an asyncio file .", "label": 0}, {"idx": "cosqa-train-6423", "doc": "python ctypes copy string into buffer", "code": "def getBuffer(x):\n    \"\"\"\n    Copy @x into a (modifiable) ctypes byte array\n    \"\"\"\n    b = bytes(x)\n    return (c_ubyte * len(b)).from_buffer_copy(bytes(x))", "code_tokens": "def getBuffer ( x ) : b = bytes ( x ) return ( c_ubyte * len ( b ) ) . from_buffer_copy ( bytes ( x ) )", "docstring_tokens": "Copy", "label": 0}, {"idx": "cosqa-train-6424", "doc": "automatic logout from a script in php or python", "code": "def destroy(self):\n\t\t\"\"\"Finish up a session.\n\t\t\"\"\"\n\t\tif self.session_type == 'bash':\n\t\t\t# TODO: does this work/handle already being logged out/logged in deep OK?\n\t\t\tself.logout()\n\t\telif self.session_type == 'vagrant':\n\t\t\t# TODO: does this work/handle already being logged out/logged in deep OK?\n\t\t\tself.logout()", "code_tokens": "def destroy ( self ) : if self . session_type == 'bash' : # TODO: does this work/handle already being logged out/logged in deep OK? self . logout ( ) elif self . session_type == 'vagrant' : # TODO: does this work/handle already being logged out/logged in deep OK? self . logout ( )", "docstring_tokens": "Finish up a session .", "label": 1}, {"idx": "cosqa-train-6425", "doc": "python ctypes pointer to pointer and initialize", "code": "def POINTER(obj):\n    \"\"\"\n    Create ctypes pointer to object.\n\n    Notes\n    -----\n    This function converts None to a real NULL pointer because of bug\n    in how ctypes handles None on 64-bit platforms.\n\n    \"\"\"\n\n    p = ctypes.POINTER(obj)\n    if not isinstance(p.from_param, classmethod):\n        def from_param(cls, x):\n            if x is None:\n                return cls()\n            else:\n                return x\n        p.from_param = classmethod(from_param)\n\n    return p", "code_tokens": "def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p", "docstring_tokens": "Create ctypes pointer to object .", "label": 0}, {"idx": "cosqa-train-6426", "doc": "python ctypes type without pointer", "code": "def POINTER(obj):\n    \"\"\"\n    Create ctypes pointer to object.\n\n    Notes\n    -----\n    This function converts None to a real NULL pointer because of bug\n    in how ctypes handles None on 64-bit platforms.\n\n    \"\"\"\n\n    p = ctypes.POINTER(obj)\n    if not isinstance(p.from_param, classmethod):\n        def from_param(cls, x):\n            if x is None:\n                return cls()\n            else:\n                return x\n        p.from_param = classmethod(from_param)\n\n    return p", "code_tokens": "def POINTER ( obj ) : p = ctypes . POINTER ( obj ) if not isinstance ( p . from_param , classmethod ) : def from_param ( cls , x ) : if x is None : return cls ( ) else : return x p . from_param = classmethod ( from_param ) return p", "docstring_tokens": "Create ctypes pointer to object .", "label": 0}, {"idx": "cosqa-train-6427", "doc": "average intensity of image python stacke overflow", "code": "def min_max_normalize(img):\n    \"\"\"Centre and normalize a given array.\n\n    Parameters:\n    ----------\n    img: np.ndarray\n\n    \"\"\"\n\n    min_img = img.min()\n    max_img = img.max()\n\n    return (img - min_img) / (max_img - min_img)", "code_tokens": "def min_max_normalize ( img ) : min_img = img . min ( ) max_img = img . max ( ) return ( img - min_img ) / ( max_img - min_img )", "docstring_tokens": "Centre and normalize a given array .", "label": 0}, {"idx": "cosqa-train-6428", "doc": "python ctypes, pointer to array", "code": "def cint32_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes int pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_int32)):\n        return np.fromiter(cptr, dtype=np.int32, count=length)\n    else:\n        raise RuntimeError('Expected int pointer')", "code_tokens": "def cint32_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_int32 ) ) : return np . fromiter ( cptr , dtype = np . int32 , count = length ) else : raise RuntimeError ( 'Expected int pointer' )", "docstring_tokens": "Convert a ctypes int pointer array to a numpy array .", "label": 0}, {"idx": "cosqa-train-6429", "doc": "aws python save files to s3 bucket", "code": "def s3(ctx, bucket_name, data_file, region):\n    \"\"\"Use the S3 SWAG backend.\"\"\"\n    if not ctx.data_file:\n        ctx.data_file = data_file\n\n    if not ctx.bucket_name:\n        ctx.bucket_name = bucket_name\n\n    if not ctx.region:\n        ctx.region = region\n\n    ctx.type = 's3'", "code_tokens": "def s3 ( ctx , bucket_name , data_file , region ) : if not ctx . data_file : ctx . data_file = data_file if not ctx . bucket_name : ctx . bucket_name = bucket_name if not ctx . region : ctx . region = region ctx . type = 's3'", "docstring_tokens": "Use the S3 SWAG backend .", "label": 0}, {"idx": "cosqa-train-6430", "doc": "python current utc date time", "code": "def now(self):\n\t\t\"\"\"\n\t\tReturn a :py:class:`datetime.datetime` instance representing the current time.\n\n\t\t:rtype: :py:class:`datetime.datetime`\n\t\t\"\"\"\n\t\tif self.use_utc:\n\t\t\treturn datetime.datetime.utcnow()\n\t\telse:\n\t\t\treturn datetime.datetime.now()", "code_tokens": "def now ( self ) : if self . use_utc : return datetime . datetime . utcnow ( ) else : return datetime . datetime . now ( )", "docstring_tokens": "Return a : py : class : datetime . datetime instance representing the current time .", "label": 1}, {"idx": "cosqa-train-6431", "doc": "aws s3 list all objects in a bucket python", "code": "def get_files(client, bucket, prefix=''):\n    \"\"\"Lists files/objects on a bucket.\n    \n    TODO: docstring\"\"\"\n    bucket = client.get_bucket(bucket)\n    files = list(bucket.list_blobs(prefix=prefix))    \n    return files", "code_tokens": "def get_files ( client , bucket , prefix = '' ) : bucket = client . get_bucket ( bucket ) files = list ( bucket . list_blobs ( prefix = prefix ) ) return files", "docstring_tokens": "Lists files / objects on a bucket . TODO : docstring", "label": 0}, {"idx": "cosqa-train-6432", "doc": "python cv2 get frame size", "code": "def get_capture_dimensions(capture):\n    \"\"\"Get the dimensions of a capture\"\"\"\n    width = int(capture.get(cv2.CAP_PROP_FRAME_WIDTH))\n    height = int(capture.get(cv2.CAP_PROP_FRAME_HEIGHT))\n    return width, height", "code_tokens": "def get_capture_dimensions ( capture ) : width = int ( capture . get ( cv2 . CAP_PROP_FRAME_WIDTH ) ) height = int ( capture . get ( cv2 . CAP_PROP_FRAME_HEIGHT ) ) return width , height", "docstring_tokens": "Get the dimensions of a capture", "label": 1}, {"idx": "cosqa-train-6433", "doc": "azure blob storage check if blob exists python", "code": "def exists(self, digest):\n        \"\"\"\n        Check if a blob exists\n\n        :param digest: Hex digest of the blob\n        :return: Boolean indicating existence of the blob\n        \"\"\"\n        return self.conn.client.blob_exists(self.container_name, digest)", "code_tokens": "def exists ( self , digest ) : return self . conn . client . blob_exists ( self . container_name , digest )", "docstring_tokens": "Check if a blob exists", "label": 0}, {"idx": "cosqa-train-6434", "doc": "python data frame setvalue", "code": "def SetValue(self, row, col, value):\n        \"\"\"\n        Set value in the pandas DataFrame\n        \"\"\"\n        self.dataframe.iloc[row, col] = value", "code_tokens": "def SetValue ( self , row , col , value ) : self . dataframe . iloc [ row , col ] = value", "docstring_tokens": "Set value in the pandas DataFrame", "label": 1}, {"idx": "cosqa-train-6435", "doc": "b' b python to string", "code": "def s2b(s):\n    \"\"\"\n    String to binary.\n    \"\"\"\n    ret = []\n    for c in s:\n        ret.append(bin(ord(c))[2:].zfill(8))\n    return \"\".join(ret)", "code_tokens": "def s2b ( s ) : ret = [ ] for c in s : ret . append ( bin ( ord ( c ) ) [ 2 : ] . zfill ( 8 ) ) return \"\" . join ( ret )", "docstring_tokens": "String to binary .", "label": 0}, {"idx": "cosqa-train-6436", "doc": "python date minus weeks", "code": "def weekly(date=datetime.date.today()):\n    \"\"\"\n    Weeks start are fixes at Monday for now.\n    \"\"\"\n    return date - datetime.timedelta(days=date.weekday())", "code_tokens": "def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )", "docstring_tokens": "Weeks start are fixes at Monday for now .", "label": 0}, {"idx": "cosqa-train-6437", "doc": "best python approach to check for finding similarity of sentences", "code": "def basic_word_sim(word1, word2):\n    \"\"\"\n    Simple measure of similarity: Number of letters in common / max length\n    \"\"\"\n    return sum([1 for c in word1 if c in word2]) / max(len(word1), len(word2))", "code_tokens": "def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )", "docstring_tokens": "Simple measure of similarity : Number of letters in common / max length", "label": 0}, {"idx": "cosqa-train-6438", "doc": "python date object year only", "code": "def today(year=None):\n    \"\"\"this day, last year\"\"\"\n    return datetime.date(int(year), _date.month, _date.day) if year else _date", "code_tokens": "def today ( year = None ) : return datetime . date ( int ( year ) , _date . month , _date . day ) if year else _date", "docstring_tokens": "this day last year", "label": 1}, {"idx": "cosqa-train-6439", "doc": "best way to traverse a directory in python", "code": "def get_files(dir_name):\n    \"\"\"Simple directory walker\"\"\"\n    return [(os.path.join('.', d), [os.path.join(d, f) for f in files]) for d, _, files in os.walk(dir_name)]", "code_tokens": "def get_files ( dir_name ) : return [ ( os . path . join ( '.' , d ) , [ os . path . join ( d , f ) for f in files ] ) for d , _ , files in os . walk ( dir_name ) ]", "docstring_tokens": "Simple directory walker", "label": 0}, {"idx": "cosqa-train-6440", "doc": "python date to begin of month", "code": "def start_of_month(val):\n    \"\"\"\n    Return a new datetime.datetime object with values that represent\n    a start of a month.\n    :param val: Date to ...\n    :type val: datetime.datetime | datetime.date\n    :rtype: datetime.datetime\n    \"\"\"\n    if type(val) == date:\n        val = datetime.fromordinal(val.toordinal())\n    return start_of_day(val).replace(day=1)", "code_tokens": "def start_of_month ( val ) : if type ( val ) == date : val = datetime . fromordinal ( val . toordinal ( ) ) return start_of_day ( val ) . replace ( day = 1 )", "docstring_tokens": "Return a new datetime . datetime object with values that represent a start of a month . : param val : Date to ... : type val : datetime . datetime | datetime . date : rtype : datetime . datetime", "label": 0}, {"idx": "cosqa-train-6441", "doc": "best xml parser in python for huge files", "code": "def xmltreefromfile(filename):\n    \"\"\"Internal function to read an XML file\"\"\"\n    try:\n        return ElementTree.parse(filename, ElementTree.XMLParser(collect_ids=False))\n    except TypeError:\n        return ElementTree.parse(filename, ElementTree.XMLParser())", "code_tokens": "def xmltreefromfile ( filename ) : try : return ElementTree . parse ( filename , ElementTree . XMLParser ( collect_ids = False ) ) except TypeError : return ElementTree . parse ( filename , ElementTree . XMLParser ( ) )", "docstring_tokens": "Internal function to read an XML file", "label": 1}, {"idx": "cosqa-train-6442", "doc": "python datetime add weeks to date", "code": "def weekly(date=datetime.date.today()):\n    \"\"\"\n    Weeks start are fixes at Monday for now.\n    \"\"\"\n    return date - datetime.timedelta(days=date.weekday())", "code_tokens": "def weekly ( date = datetime . date . today ( ) ) : return date - datetime . timedelta ( days = date . weekday ( ) )", "docstring_tokens": "Weeks start are fixes at Monday for now .", "label": 1}, {"idx": "cosqa-train-6443", "doc": "boolean of a string python", "code": "def FromString(self, string):\n    \"\"\"Parse a bool from a string.\"\"\"\n    if string.lower() in (\"false\", \"no\", \"n\"):\n      return False\n\n    if string.lower() in (\"true\", \"yes\", \"y\"):\n      return True\n\n    raise TypeValueError(\"%s is not recognized as a boolean value.\" % string)", "code_tokens": "def FromString ( self , string ) : if string . lower ( ) in ( \"false\" , \"no\" , \"n\" ) : return False if string . lower ( ) in ( \"true\" , \"yes\" , \"y\" ) : return True raise TypeValueError ( \"%s is not recognized as a boolean value.\" % string )", "docstring_tokens": "Parse a bool from a string .", "label": 1}, {"idx": "cosqa-train-6444", "doc": "boto3 athena python pagination", "code": "def get_bucket_page(page):\n    \"\"\"\n    Returns all the keys in a s3 bucket paginator page.\n    \"\"\"\n    key_list = page.get('Contents', [])\n    logger.debug(\"Retrieving page with {} keys\".format(\n        len(key_list),\n    ))\n    return dict((k.get('Key'), k) for k in key_list)", "code_tokens": "def get_bucket_page ( page ) : key_list = page . get ( 'Contents' , [ ] ) logger . debug ( \"Retrieving page with {} keys\" . format ( len ( key_list ) , ) ) return dict ( ( k . get ( 'Key' ) , k ) for k in key_list )", "docstring_tokens": "Returns all the keys in a s3 bucket paginator page .", "label": 1}, {"idx": "cosqa-train-6445", "doc": "python datetime aware or naive", "code": "def get_naive(dt):\n  \"\"\"Gets a naive datetime from a datetime.\n\n  datetime_tz objects can't just have tzinfo replaced with None, you need to\n  call asdatetime.\n\n  Args:\n    dt: datetime object.\n\n  Returns:\n    datetime object without any timezone information.\n  \"\"\"\n  if not dt.tzinfo:\n    return dt\n  if hasattr(dt, \"asdatetime\"):\n    return dt.asdatetime()\n  return dt.replace(tzinfo=None)", "code_tokens": "def get_naive ( dt ) : if not dt . tzinfo : return dt if hasattr ( dt , \"asdatetime\" ) : return dt . asdatetime ( ) return dt . replace ( tzinfo = None )", "docstring_tokens": "Gets a naive datetime from a datetime .", "label": 1}, {"idx": "cosqa-train-6446", "doc": "c call python dependencies", "code": "def check_dependencies_remote(args):\n    \"\"\"\n    Invoke this command on a remote Python.\n    \"\"\"\n    cmd = [args.python, '-m', 'depends', args.requirement]\n    env = dict(PYTHONPATH=os.path.dirname(__file__))\n    return subprocess.check_call(cmd, env=env)", "code_tokens": "def check_dependencies_remote ( args ) : cmd = [ args . python , '-m' , 'depends' , args . requirement ] env = dict ( PYTHONPATH = os . path . dirname ( __file__ ) ) return subprocess . check_call ( cmd , env = env )", "docstring_tokens": "Invoke this command on a remote Python .", "label": 0}, {"idx": "cosqa-train-6447", "doc": "python datetime make date from string", "code": "def string_to_date(value):\n    \"\"\"\n    Return a Python date that corresponds to the specified string\n    representation.\n\n    @param value: string representation of a date.\n\n    @return: an instance ``datetime.datetime`` represented by the string.\n    \"\"\"\n    if isinstance(value, datetime.date):\n        return value\n\n    return dateutil.parser.parse(value).date()", "code_tokens": "def string_to_date ( value ) : if isinstance ( value , datetime . date ) : return value return dateutil . parser . parse ( value ) . date ( )", "docstring_tokens": "Return a Python date that corresponds to the specified string representation .", "label": 1}, {"idx": "cosqa-train-6448", "doc": "calculat the angle between two points in python", "code": "def angle_between_vectors(x, y):\n    \"\"\" Compute the angle between vector x and y \"\"\"\n    dp = dot_product(x, y)\n    if dp == 0:\n        return 0\n    xm = magnitude(x)\n    ym = magnitude(y)\n    return math.acos(dp / (xm*ym)) * (180. / math.pi)", "code_tokens": "def angle_between_vectors ( x , y ) : dp = dot_product ( x , y ) if dp == 0 : return 0 xm = magnitude ( x ) ym = magnitude ( y ) return math . acos ( dp / ( xm * ym ) ) * ( 180. / math . pi )", "docstring_tokens": "Compute the angle between vector x and y", "label": 1}, {"idx": "cosqa-train-6449", "doc": "python datetime timestamp microseconds", "code": "def ToDatetime(self):\n    \"\"\"Converts Timestamp to datetime.\"\"\"\n    return datetime.utcfromtimestamp(\n        self.seconds + self.nanos / float(_NANOS_PER_SECOND))", "code_tokens": "def ToDatetime ( self ) : return datetime . utcfromtimestamp ( self . seconds + self . nanos / float ( _NANOS_PER_SECOND ) )", "docstring_tokens": "Converts Timestamp to datetime .", "label": 0}, {"idx": "cosqa-train-6450", "doc": "calculate 25 50 75 percentile in python", "code": "def ci(a, which=95, axis=None):\n    \"\"\"Return a percentile range from an array of values.\"\"\"\n    p = 50 - which / 2, 50 + which / 2\n    return percentiles(a, p, axis)", "code_tokens": "def ci ( a , which = 95 , axis = None ) : p = 50 - which / 2 , 50 + which / 2 return percentiles ( a , p , axis )", "docstring_tokens": "Return a percentile range from an array of values .", "label": 1}, {"idx": "cosqa-train-6451", "doc": "python dds to numpyarray", "code": "def dict_to_numpy_array(d):\n    \"\"\"\n    Convert a dict of 1d array to a numpy recarray\n    \"\"\"\n    return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))", "code_tokens": "def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )", "docstring_tokens": "Convert a dict of 1d array to a numpy recarray", "label": 0}, {"idx": "cosqa-train-6452", "doc": "calculate accuracy rate python between labels", "code": "def error_rate(predictions, labels):\n  \"\"\"Return the error rate based on dense predictions and 1-hot labels.\"\"\"\n  return 100.0 - (\n      100.0 *\n      np.sum(np.argmax(predictions, 1) == np.argmax(labels, 1)) /\n      predictions.shape[0])", "code_tokens": "def error_rate ( predictions , labels ) : return 100.0 - ( 100.0 * np . sum ( np . argmax ( predictions , 1 ) == np . argmax ( labels , 1 ) ) / predictions . shape [ 0 ] )", "docstring_tokens": "Return the error rate based on dense predictions and 1 - hot labels .", "label": 1}, {"idx": "cosqa-train-6453", "doc": "python decimal strip trailing zeros", "code": "def drop_trailing_zeros_decimal(num):\n    \"\"\" Drops the trailinz zeros from decimal value.\n        Returns a string\n    \"\"\"\n    out = str(num)\n    return out.rstrip('0').rstrip('.') if '.' in out else out", "code_tokens": "def drop_trailing_zeros_decimal ( num ) : out = str ( num ) return out . rstrip ( '0' ) . rstrip ( '.' ) if '.' in out else out", "docstring_tokens": "Drops the trailinz zeros from decimal value . Returns a string", "label": 1}, {"idx": "cosqa-train-6454", "doc": "calculate the average price of an order using python", "code": "def average_price(quantity_1, price_1, quantity_2, price_2):\n    \"\"\"Calculates the average price between two asset states.\"\"\"\n    return (quantity_1 * price_1 + quantity_2 * price_2) / \\\n            (quantity_1 + quantity_2)", "code_tokens": "def average_price ( quantity_1 , price_1 , quantity_2 , price_2 ) : return ( quantity_1 * price_1 + quantity_2 * price_2 ) / ( quantity_1 + quantity_2 )", "docstring_tokens": "Calculates the average price between two asset states .", "label": 1}, {"idx": "cosqa-train-6455", "doc": "python decision tree scikit learn", "code": "def human__decision_tree():\n    \"\"\" Decision Tree\n    \"\"\"\n\n    # build data\n    N = 1000000\n    M = 3\n    X = np.zeros((N,M))\n    X.shape\n    y = np.zeros(N)\n    X[0, 0] = 1\n    y[0] = 8\n    X[1, 1] = 1\n    y[1] = 8\n    X[2, 0:2] = 1\n    y[2] = 4\n\n    # fit model\n    xor_model = sklearn.tree.DecisionTreeRegressor(max_depth=2)\n    xor_model.fit(X, y)\n\n    return xor_model", "code_tokens": "def human__decision_tree ( ) : # build data N = 1000000 M = 3 X = np . zeros ( ( N , M ) ) X . shape y = np . zeros ( N ) X [ 0 , 0 ] = 1 y [ 0 ] = 8 X [ 1 , 1 ] = 1 y [ 1 ] = 8 X [ 2 , 0 : 2 ] = 1 y [ 2 ] = 4 # fit model xor_model = sklearn . tree . DecisionTreeRegressor ( max_depth = 2 ) xor_model . fit ( X , y ) return xor_model", "docstring_tokens": "Decision Tree", "label": 0}, {"idx": "cosqa-train-6456", "doc": "calculate time delta python", "code": "def elapsed_time_from(start_time):\n    \"\"\"calculate time delta from latched time and current time\"\"\"\n    time_then = make_time(start_time)\n    time_now = datetime.utcnow().replace(microsecond=0)\n    if time_then is None:\n        return\n    delta_t = time_now - time_then\n    return delta_t", "code_tokens": "def elapsed_time_from ( start_time ) : time_then = make_time ( start_time ) time_now = datetime . utcnow ( ) . replace ( microsecond = 0 ) if time_then is None : return delta_t = time_now - time_then return delta_t", "docstring_tokens": "calculate time delta from latched time and current time", "label": 1}, {"idx": "cosqa-train-6457", "doc": "python decode byte string var", "code": "def read_string(cls, string):\n        \"\"\"Decodes a given bencoded string or bytestring.\n\n        Returns decoded structure(s).\n\n        :param str string:\n        :rtype: list\n        \"\"\"\n        if PY3 and not isinstance(string, byte_types):\n            string = string.encode()\n\n        return cls.decode(string)", "code_tokens": "def read_string ( cls , string ) : if PY3 and not isinstance ( string , byte_types ) : string = string . encode ( ) return cls . decode ( string )", "docstring_tokens": "Decodes a given bencoded string or bytestring .", "label": 0}, {"idx": "cosqa-train-6458", "doc": "call a function every few seconds python", "code": "def set(self, f):\n        \"\"\"Call a function after a delay, unless another function is set\n        in the meantime.\"\"\"\n        self.stop()\n        self._create_timer(f)\n        self.start()", "code_tokens": "def set ( self , f ) : self . stop ( ) self . _create_timer ( f ) self . start ( )", "docstring_tokens": "Call a function after a delay unless another function is set in the meantime .", "label": 1}, {"idx": "cosqa-train-6459", "doc": "python deep copy instance", "code": "def __copy__(self):\n        \"\"\"A magic method to implement shallow copy behavior.\"\"\"\n        return self.__class__.load(self.dump(), context=self.context)", "code_tokens": "def __copy__ ( self ) : return self . __class__ . load ( self . dump ( ) , context = self . context )", "docstring_tokens": "A magic method to implement shallow copy behavior .", "label": 0}, {"idx": "cosqa-train-6460", "doc": "call javascript variable from python", "code": "def eval_script(self, expr):\n    \"\"\" Evaluates a piece of Javascript in the context of the current page and\n    returns its value. \"\"\"\n    ret = self.conn.issue_command(\"Evaluate\", expr)\n    return json.loads(\"[%s]\" % ret)[0]", "code_tokens": "def eval_script ( self , expr ) : ret = self . conn . issue_command ( \"Evaluate\" , expr ) return json . loads ( \"[%s]\" % ret ) [ 0 ]", "docstring_tokens": "Evaluates a piece of Javascript in the context of the current page and returns its value .", "label": 0}, {"idx": "cosqa-train-6461", "doc": "python def list of list of string", "code": "def validate_string_list(lst):\n    \"\"\"Validate that the input is a list of strings.\n\n    Raises ValueError if not.\"\"\"\n    if not isinstance(lst, list):\n        raise ValueError('input %r must be a list' % lst)\n    for x in lst:\n        if not isinstance(x, basestring):\n            raise ValueError('element %r in list must be a string' % x)", "code_tokens": "def validate_string_list ( lst ) : if not isinstance ( lst , list ) : raise ValueError ( 'input %r must be a list' % lst ) for x in lst : if not isinstance ( x , basestring ) : raise ValueError ( 'element %r in list must be a string' % x )", "docstring_tokens": "Validate that the input is a list of strings .", "label": 0}, {"idx": "cosqa-train-6462", "doc": "call python compiled file", "code": "def execfile(fname, variables):\n    \"\"\" This is builtin in python2, but we have to roll our own on py3. \"\"\"\n    with open(fname) as f:\n        code = compile(f.read(), fname, 'exec')\n        exec(code, variables)", "code_tokens": "def execfile ( fname , variables ) : with open ( fname ) as f : code = compile ( f . read ( ) , fname , 'exec' ) exec ( code , variables )", "docstring_tokens": "This is builtin in python2 but we have to roll our own on py3 .", "label": 0}, {"idx": "cosqa-train-6463", "doc": "python default menuitem select", "code": "def get_python(self):\n        \"\"\"Only return cursor instance if configured for multiselect\"\"\"\n        if self.multiselect:\n            return super(MultiSelectField, self).get_python()\n\n        return self._get()", "code_tokens": "def get_python ( self ) : if self . multiselect : return super ( MultiSelectField , self ) . get_python ( ) return self . _get ( )", "docstring_tokens": "Only return cursor instance if configured for multiselect", "label": 1}, {"idx": "cosqa-train-6464", "doc": "camelcase to underscore python", "code": "def camel_to_under(name):\n    \"\"\"\n    Converts camel-case string to lowercase string separated by underscores.\n\n    Written by epost (http://stackoverflow.com/questions/1175208).\n\n    :param name: String to be converted\n    :return: new String with camel-case converted to lowercase, underscored\n    \"\"\"\n    s1 = re.sub(\"(.)([A-Z][a-z]+)\", r\"\\1_\\2\", name)\n    return re.sub(\"([a-z0-9])([A-Z])\", r\"\\1_\\2\", s1).lower()", "code_tokens": "def camel_to_under ( name ) : s1 = re . sub ( \"(.)([A-Z][a-z]+)\" , r\"\\1_\\2\" , name ) return re . sub ( \"([a-z0-9])([A-Z])\" , r\"\\1_\\2\" , s1 ) . lower ( )", "docstring_tokens": "Converts camel - case string to lowercase string separated by underscores .", "label": 0}, {"idx": "cosqa-train-6465", "doc": "python default param not recognized as string", "code": "def arg_default(*args, **kwargs):\n    \"\"\"Return default argument value as given by argparse's add_argument().\n\n    The argument is passed through a mocked-up argument parser. This way, we\n    get default parameters even if the feature is called directly and not\n    through the CLI.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(*args, **kwargs)\n    args = vars(parser.parse_args([]))\n    _, default = args.popitem()\n    return default", "code_tokens": "def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default", "docstring_tokens": "Return default argument value as given by argparse s add_argument () .", "label": 0}, {"idx": "cosqa-train-6466", "doc": "can array in python is strings", "code": "def ndarr2str(arr, encoding='ascii'):\n    \"\"\" This is used to ensure that the return value of arr.tostring()\n    is actually a string.  This will prevent lots of if-checks in calling\n    code.  As of numpy v1.6.1 (in Python 3.2.3), the tostring() function\n    still returns type 'bytes', not 'str' as it advertises. \"\"\"\n    # be fast, don't check - just assume 'arr' is a numpy array - the tostring\n    # call will fail anyway if not\n    retval = arr.tostring()\n    # would rather check \"if isinstance(retval, bytes)\", but support 2.5.\n    # could rm the if PY3K check, but it makes this faster on 2.x.\n    if PY3K and not isinstance(retval, str):\n        return retval.decode(encoding)\n    else: # is str\n        return retval", "code_tokens": "def ndarr2str ( arr , encoding = 'ascii' ) : # be fast, don't check - just assume 'arr' is a numpy array - the tostring # call will fail anyway if not retval = arr . tostring ( ) # would rather check \"if isinstance(retval, bytes)\", but support 2.5. # could rm the if PY3K check, but it makes this faster on 2.x. if PY3K and not isinstance ( retval , str ) : return retval . decode ( encoding ) else : # is str return retval", "docstring_tokens": "This is used to ensure that the return value of arr . tostring () is actually a string . This will prevent lots of if - checks in calling code . As of numpy v1 . 6 . 1 ( in Python 3 . 2 . 3 ) the tostring () function still returns type bytes not str as it advertises .", "label": 1}, {"idx": "cosqa-train-6467", "doc": "python default value is mutable set", "code": "def setdefault(obj, field, default):\n    \"\"\"Set an object's field to default if it doesn't have a value\"\"\"\n    setattr(obj, field, getattr(obj, field, default))", "code_tokens": "def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )", "docstring_tokens": "Set an object s field to default if it doesn t have a value", "label": 1}, {"idx": "cosqa-train-6468", "doc": "can ints have decimals in python", "code": "def get_decimal_quantum(precision):\n    \"\"\"Return minimal quantum of a number, as defined by precision.\"\"\"\n    assert isinstance(precision, (int, decimal.Decimal))\n    return decimal.Decimal(10) ** (-precision)", "code_tokens": "def get_decimal_quantum ( precision ) : assert isinstance ( precision , ( int , decimal . Decimal ) ) return decimal . Decimal ( 10 ) ** ( - precision )", "docstring_tokens": "Return minimal quantum of a number as defined by precision .", "label": 0}, {"idx": "cosqa-train-6469", "doc": "python defining a varible as global from a function", "code": "def get_var(name, factory=None):\n    \"\"\"Gets a global variable given its name.\n\n    If factory is not None and the variable is not set, factory\n    is a callable that will set the variable.\n\n    If not set, returns None.\n    \"\"\"\n    if name not in _VARS and factory is not None:\n        _VARS[name] = factory()\n    return _VARS.get(name)", "code_tokens": "def get_var ( name , factory = None ) : if name not in _VARS and factory is not None : _VARS [ name ] = factory ( ) return _VARS . get ( name )", "docstring_tokens": "Gets a global variable given its name .", "label": 0}, {"idx": "cosqa-train-6470", "doc": "can javascript call python serverside", "code": "def eval_script(self, expr):\n    \"\"\" Evaluates a piece of Javascript in the context of the current page and\n    returns its value. \"\"\"\n    ret = self.conn.issue_command(\"Evaluate\", expr)\n    return json.loads(\"[%s]\" % ret)[0]", "code_tokens": "def eval_script ( self , expr ) : ret = self . conn . issue_command ( \"Evaluate\" , expr ) return json . loads ( \"[%s]\" % ret ) [ 0 ]", "docstring_tokens": "Evaluates a piece of Javascript in the context of the current page and returns its value .", "label": 0}, {"idx": "cosqa-train-6471", "doc": "python del whole namespace", "code": "def uninstall(cls):\n        \"\"\"Remove the package manager from the system.\"\"\"\n        if os.path.exists(cls.home):\n            shutil.rmtree(cls.home)", "code_tokens": "def uninstall ( cls ) : if os . path . exists ( cls . home ) : shutil . rmtree ( cls . home )", "docstring_tokens": "Remove the package manager from the system .", "label": 0}, {"idx": "cosqa-train-6472", "doc": "can python pickle read a manually created file", "code": "def unpickle_file(picklefile, **kwargs):\n    \"\"\"Helper function to unpickle data from `picklefile`.\"\"\"\n    with open(picklefile, 'rb') as f:\n        return pickle.load(f, **kwargs)", "code_tokens": "def unpickle_file ( picklefile , * * kwargs ) : with open ( picklefile , 'rb' ) as f : return pickle . load ( f , * * kwargs )", "docstring_tokens": "Helper function to unpickle data from picklefile .", "label": 1}, {"idx": "cosqa-train-6473", "doc": "python delete duplicate in string list", "code": "def dedupe_list(seq):\n    \"\"\"\n    Utility function to remove duplicates from a list\n    :param seq: The sequence (list) to deduplicate\n    :return: A list with original duplicates removed\n    \"\"\"\n    seen = set()\n    return [x for x in seq if not (x in seen or seen.add(x))]", "code_tokens": "def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed", "label": 0}, {"idx": "cosqa-train-6474", "doc": "can you index into a dictionary python", "code": "def edge_index(self):\n        \"\"\"A map to look up the index of a edge\"\"\"\n        return dict((edge, index) for index, edge in enumerate(self.edges))", "code_tokens": "def edge_index ( self ) : return dict ( ( edge , index ) for index , edge in enumerate ( self . edges ) )", "docstring_tokens": "A map to look up the index of a edge", "label": 1}, {"idx": "cosqa-train-6475", "doc": "python delete files and folders", "code": "def clean_out_dir(directory):\n    \"\"\"\n    Delete all the files and subdirectories in a directory.\n    \"\"\"\n    if not isinstance(directory, path):\n        directory = path(directory)\n    for file_path in directory.files():\n        file_path.remove()\n    for dir_path in directory.dirs():\n        dir_path.rmtree()", "code_tokens": "def clean_out_dir ( directory ) : if not isinstance ( directory , path ) : directory = path ( directory ) for file_path in directory . files ( ) : file_path . remove ( ) for dir_path in directory . dirs ( ) : dir_path . rmtree ( )", "docstring_tokens": "Delete all the files and subdirectories in a directory .", "label": 1}, {"idx": "cosqa-train-6476", "doc": "can you return a tuple in python", "code": "def getTuple(self):\n        \"\"\" Returns the shape of the region as (x, y, w, h) \"\"\"\n        return (self.x, self.y, self.w, self.h)", "code_tokens": "def getTuple ( self ) : return ( self . x , self . y , self . w , self . h )", "docstring_tokens": "Returns the shape of the region as ( x y w h )", "label": 0}, {"idx": "cosqa-train-6477", "doc": "python delete if it exists", "code": "def safe_delete(filename):\n  \"\"\"Delete a file safely. If it's not present, no-op.\"\"\"\n  try:\n    os.unlink(filename)\n  except OSError as e:\n    if e.errno != errno.ENOENT:\n      raise", "code_tokens": "def safe_delete ( filename ) : try : os . unlink ( filename ) except OSError as e : if e . errno != errno . ENOENT : raise", "docstring_tokens": "Delete a file safely . If it s not present no - op .", "label": 0}, {"idx": "cosqa-train-6478", "doc": "can you split in python based on specific characters", "code": "def _split(string, splitters):\n    \"\"\"Splits a string into parts at multiple characters\"\"\"\n    part = ''\n    for character in string:\n        if character in splitters:\n            yield part\n            part = ''\n        else:\n            part += character\n    yield part", "code_tokens": "def _split ( string , splitters ) : part = '' for character in string : if character in splitters : yield part part = '' else : part += character yield part", "docstring_tokens": "Splits a string into parts at multiple characters", "label": 1}, {"idx": "cosqa-train-6479", "doc": "python delete instance in a list", "code": "def pop():\n        \"\"\"Remove instance from instance list\"\"\"\n        pid = os.getpid()\n        thread = threading.current_thread()\n        Wdb._instances.pop((pid, thread))", "code_tokens": "def pop ( ) : pid = os . getpid ( ) thread = threading . current_thread ( ) Wdb . _instances . pop ( ( pid , thread ) )", "docstring_tokens": "Remove instance from instance list", "label": 1}, {"idx": "cosqa-train-6480", "doc": "can you split parts of a string in python", "code": "def _split(string, splitters):\n    \"\"\"Splits a string into parts at multiple characters\"\"\"\n    part = ''\n    for character in string:\n        if character in splitters:\n            yield part\n            part = ''\n        else:\n            part += character\n    yield part", "code_tokens": "def _split ( string , splitters ) : part = '' for character in string : if character in splitters : yield part part = '' else : part += character yield part", "docstring_tokens": "Splits a string into parts at multiple characters", "label": 1}, {"idx": "cosqa-train-6481", "doc": "python delete keys from dictionary is value none", "code": "def rm_keys_from_dict(d, keys):\n    \"\"\"\n    Given a dictionary and a key list, remove any data in the dictionary with the given keys.\n\n    :param dict d: Metadata\n    :param list keys: Keys to be removed\n    :return dict d: Metadata\n    \"\"\"\n    # Loop for each key given\n    for key in keys:\n        # Is the key in the dictionary?\n        if key in d:\n            try:\n                d.pop(key, None)\n            except KeyError:\n                # Not concerned with an error. Keep going.\n                pass\n    return d", "code_tokens": "def rm_keys_from_dict ( d , keys ) : # Loop for each key given for key in keys : # Is the key in the dictionary? if key in d : try : d . pop ( key , None ) except KeyError : # Not concerned with an error. Keep going. pass return d", "docstring_tokens": "Given a dictionary and a key list remove any data in the dictionary with the given keys .", "label": 0}, {"idx": "cosqa-train-6482", "doc": "python detect if file is symbolic link", "code": "def is_symlink(self):\n        \"\"\"\n        Whether this path is a symbolic link.\n        \"\"\"\n        try:\n            return S_ISLNK(self.lstat().st_mode)\n        except OSError as e:\n            if e.errno != ENOENT:\n                raise\n            # Path doesn't exist\n            return False", "code_tokens": "def is_symlink ( self ) : try : return S_ISLNK ( self . lstat ( ) . st_mode ) except OSError as e : if e . errno != ENOENT : raise # Path doesn't exist return False", "docstring_tokens": "Whether this path is a symbolic link .", "label": 1}, {"idx": "cosqa-train-6483", "doc": "cant make file with python makedir", "code": "def makedirs(path, mode=0o777, exist_ok=False):\n    \"\"\"A wrapper of os.makedirs().\"\"\"\n    os.makedirs(path, mode, exist_ok)", "code_tokens": "def makedirs ( path , mode = 0o777 , exist_ok = False ) : os . makedirs ( path , mode , exist_ok )", "docstring_tokens": "A wrapper of os . makedirs () .", "label": 1}, {"idx": "cosqa-train-6484", "doc": "python detect if linux or windows", "code": "def _platform_is_windows(platform=sys.platform):\n        \"\"\"Is the current OS a Windows?\"\"\"\n        matched = platform in ('cygwin', 'win32', 'win64')\n        if matched:\n            error_msg = \"Windows isn't supported yet\"\n            raise OSError(error_msg)\n        return matched", "code_tokens": "def _platform_is_windows ( platform = sys . platform ) : matched = platform in ( 'cygwin' , 'win32' , 'win64' ) if matched : error_msg = \"Windows isn't supported yet\" raise OSError ( error_msg ) return matched", "docstring_tokens": "Is the current OS a Windows?", "label": 1}, {"idx": "cosqa-train-6485", "doc": "capitalize list items + python", "code": "def _snake_to_camel_case(value):\n    \"\"\"Convert snake case string to camel case.\"\"\"\n    words = value.split(\"_\")\n    return words[0] + \"\".join(map(str.capitalize, words[1:]))", "code_tokens": "def _snake_to_camel_case ( value ) : words = value . split ( \"_\" ) return words [ 0 ] + \"\" . join ( map ( str . capitalize , words [ 1 : ] ) )", "docstring_tokens": "Convert snake case string to camel case .", "label": 0}, {"idx": "cosqa-train-6486", "doc": "python detect windows or mac", "code": "def _platform_is_windows(platform=sys.platform):\n        \"\"\"Is the current OS a Windows?\"\"\"\n        matched = platform in ('cygwin', 'win32', 'win64')\n        if matched:\n            error_msg = \"Windows isn't supported yet\"\n            raise OSError(error_msg)\n        return matched", "code_tokens": "def _platform_is_windows ( platform = sys . platform ) : matched = platform in ( 'cygwin' , 'win32' , 'win64' ) if matched : error_msg = \"Windows isn't supported yet\" raise OSError ( error_msg ) return matched", "docstring_tokens": "Is the current OS a Windows?", "label": 0}, {"idx": "cosqa-train-6487", "doc": "capture changes datatable bokeh python", "code": "def _push_render(self):\n        \"\"\"Render the plot with bokeh.io and push to notebook.\n        \"\"\"\n        bokeh.io.push_notebook(handle=self.handle)\n        self.last_update = time.time()", "code_tokens": "def _push_render ( self ) : bokeh . io . push_notebook ( handle = self . handle ) self . last_update = time . time ( )", "docstring_tokens": "Render the plot with bokeh . io and push to notebook .", "label": 1}, {"idx": "cosqa-train-6488", "doc": "python determine if a string contains unique characters", "code": "def first_unique_char(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if (len(s) == 1):\n        return 0\n    ban = []\n    for i in range(len(s)):\n        if all(s[i] != s[k] for k in range(i + 1, len(s))) == True and s[i] not in ban:\n            return i\n        else:\n            ban.append(s[i])\n    return -1", "code_tokens": "def first_unique_char ( s ) : if ( len ( s ) == 1 ) : return 0 ban = [ ] for i in range ( len ( s ) ) : if all ( s [ i ] != s [ k ] for k in range ( i + 1 , len ( s ) ) ) == True and s [ i ] not in ban : return i else : ban . append ( s [ i ] ) return - 1", "docstring_tokens": ": type s : str : rtype : int", "label": 1}, {"idx": "cosqa-train-6489", "doc": "capturing return values from a python subprocess call", "code": "def call_out(command):\n  \"\"\"\n  Run the given command (with shell=False) and return a tuple of\n  (int returncode, str output). Strip the output of enclosing whitespace.\n  \"\"\"\n  # start external command process\n  p = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n  # get outputs\n  out, _ = p.communicate()\n\n  return p.returncode, out.strip()", "code_tokens": "def call_out ( command ) : # start external command process p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) # get outputs out , _ = p . communicate ( ) return p . returncode , out . strip ( )", "docstring_tokens": "Run the given command ( with shell = False ) and return a tuple of ( int returncode str output ) . Strip the output of enclosing whitespace .", "label": 0}, {"idx": "cosqa-train-6490", "doc": "python determine if interactive or not", "code": "def determine_interactive(self):\n\t\t\"\"\"Determine whether we're in an interactive shell.\n\t\tSets interactivity off if appropriate.\n\t\tcf http://stackoverflow.com/questions/24861351/how-to-detect-if-python-script-is-being-run-as-a-background-process\n\t\t\"\"\"\n\t\ttry:\n\t\t\tif not sys.stdout.isatty() or os.getpgrp() != os.tcgetpgrp(sys.stdout.fileno()):\n\t\t\t\tself.interactive = 0\n\t\t\t\treturn False\n\t\texcept Exception:\n\t\t\tself.interactive = 0\n\t\t\treturn False\n\t\tif self.interactive == 0:\n\t\t\treturn False\n\t\treturn True", "code_tokens": "def determine_interactive ( self ) : try : if not sys . stdout . isatty ( ) or os . getpgrp ( ) != os . tcgetpgrp ( sys . stdout . fileno ( ) ) : self . interactive = 0 return False except Exception : self . interactive = 0 return False if self . interactive == 0 : return False return True", "docstring_tokens": "Determine whether we re in an interactive shell . Sets interactivity off if appropriate . cf http : // stackoverflow . com / questions / 24861351 / how - to - detect - if - python - script - is - being - run - as - a - background - process", "label": 1}, {"idx": "cosqa-train-6491", "doc": "cast a string to bool python", "code": "def FromString(self, string):\n    \"\"\"Parse a bool from a string.\"\"\"\n    if string.lower() in (\"false\", \"no\", \"n\"):\n      return False\n\n    if string.lower() in (\"true\", \"yes\", \"y\"):\n      return True\n\n    raise TypeValueError(\"%s is not recognized as a boolean value.\" % string)", "code_tokens": "def FromString ( self , string ) : if string . lower ( ) in ( \"false\" , \"no\" , \"n\" ) : return False if string . lower ( ) in ( \"true\" , \"yes\" , \"y\" ) : return True raise TypeValueError ( \"%s is not recognized as a boolean value.\" % string )", "docstring_tokens": "Parse a bool from a string .", "label": 0}, {"idx": "cosqa-train-6492", "doc": "python dialog box to specify folder", "code": "def ask_folder(message='Select folder.', default='', title=''):\n    \"\"\"\n    A dialog to get a directory name.\n    Returns the name of a directory, or None if user chose to cancel.\n    If the \"default\" argument specifies a directory name, and that\n    directory exists, then the dialog box will start with that directory.\n\n    :param message: message to be displayed.\n    :param title: window title\n    :param default: default folder path\n    :rtype: None or string\n    \"\"\"\n    return backend_api.opendialog(\"ask_folder\", dict(message=message, default=default, title=title))", "code_tokens": "def ask_folder ( message = 'Select folder.' , default = '' , title = '' ) : return backend_api . opendialog ( \"ask_folder\" , dict ( message = message , default = default , title = title ) )", "docstring_tokens": "A dialog to get a directory name . Returns the name of a directory or None if user chose to cancel . If the default argument specifies a directory name and that directory exists then the dialog box will start with that directory .", "label": 1}, {"idx": "cosqa-train-6493", "doc": "cast boolean to 1 or 0 python", "code": "def strToBool(val):\n    \"\"\"\n    Helper function to turn a string representation of \"true\" into\n    boolean True.\n    \"\"\"\n    if isinstance(val, str):\n        val = val.lower()\n\n    return val in ['true', 'on', 'yes', True]", "code_tokens": "def strToBool ( val ) : if isinstance ( val , str ) : val = val . lower ( ) return val in [ 'true' , 'on' , 'yes' , True ]", "docstring_tokens": "Helper function to turn a string representation of true into boolean True .", "label": 0}, {"idx": "cosqa-train-6494", "doc": "python dict beautify string", "code": "def stringify_dict_contents(dct):\n    \"\"\"Turn dict keys and values into native strings.\"\"\"\n    return {\n        str_if_nested_or_str(k): str_if_nested_or_str(v)\n        for k, v in dct.items()\n    }", "code_tokens": "def stringify_dict_contents ( dct ) : return { str_if_nested_or_str ( k ) : str_if_nested_or_str ( v ) for k , v in dct . items ( ) }", "docstring_tokens": "Turn dict keys and values into native strings .", "label": 1}, {"idx": "cosqa-train-6495", "doc": "cast list as csv python", "code": "def list_to_csv(value):\n    \"\"\"\n    Converts list to string with comma separated values. For string is no-op.\n    \"\"\"\n    if isinstance(value, (list, tuple, set)):\n        value = \",\".join(value)\n    return value", "code_tokens": "def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = \",\" . join ( value ) return value", "docstring_tokens": "Converts list to string with comma separated values . For string is no - op .", "label": 1}, {"idx": "cosqa-train-6496", "doc": "python dict get value default key not exist none", "code": "def _defaultdict(dct, fallback=_illegal_character):\n    \"\"\"Wraps the given dictionary such that the given fallback function will be called when a nonexistent key is\n    accessed.\n    \"\"\"\n    out = defaultdict(lambda: fallback)\n    for k, v in six.iteritems(dct):\n        out[k] = v\n    return out", "code_tokens": "def _defaultdict ( dct , fallback = _illegal_character ) : out = defaultdict ( lambda : fallback ) for k , v in six . iteritems ( dct ) : out [ k ] = v return out", "docstring_tokens": "Wraps the given dictionary such that the given fallback function will be called when a nonexistent key is accessed .", "label": 0}, {"idx": "cosqa-train-6497", "doc": "cast to byte in python", "code": "def str2bytes(x):\n  \"\"\"Convert input argument to bytes\"\"\"\n  if type(x) is bytes:\n    return x\n  elif type(x) is str:\n    return bytes([ ord(i) for i in x ])\n  else:\n    return str2bytes(str(x))", "code_tokens": "def str2bytes ( x ) : if type ( x ) is bytes : return x elif type ( x ) is str : return bytes ( [ ord ( i ) for i in x ] ) else : return str2bytes ( str ( x ) )", "docstring_tokens": "Convert input argument to bytes", "label": 1}, {"idx": "cosqa-train-6498", "doc": "python dict remove empty values", "code": "def purge_dict(idict):\n    \"\"\"Remove null items from a dictionary \"\"\"\n    odict = {}\n    for key, val in idict.items():\n        if is_null(val):\n            continue\n        odict[key] = val\n    return odict", "code_tokens": "def purge_dict ( idict ) : odict = { } for key , val in idict . items ( ) : if is_null ( val ) : continue odict [ key ] = val return odict", "docstring_tokens": "Remove null items from a dictionary", "label": 1}, {"idx": "cosqa-train-6499", "doc": "cehcking if string is custom date python", "code": "def parse_date(s):\n    \"\"\"Fast %Y-%m-%d parsing.\"\"\"\n    try:\n        return datetime.date(int(s[:4]), int(s[5:7]), int(s[8:10]))\n    except ValueError:  # other accepted format used in one-day data set\n        return datetime.datetime.strptime(s, '%d %B %Y').date()", "code_tokens": "def parse_date ( s ) : try : return datetime . date ( int ( s [ : 4 ] ) , int ( s [ 5 : 7 ] ) , int ( s [ 8 : 10 ] ) ) except ValueError : # other accepted format used in one-day data set return datetime . datetime . strptime ( s , '%d %B %Y' ) . date ( )", "docstring_tokens": "Fast %Y - %m - %d parsing .", "label": 1}, {"idx": "cosqa-train-6500", "doc": "python dictionary get first element of a dictionary", "code": "def get_single_value(d):\n    \"\"\"Get a value from a dict which contains just one item.\"\"\"\n    assert len(d) == 1, 'Single-item dict must have just one item, not %d.' % len(d)\n    return next(six.itervalues(d))", "code_tokens": "def get_single_value ( d ) : assert len ( d ) == 1 , 'Single-item dict must have just one item, not %d.' % len ( d ) return next ( six . itervalues ( d ) )", "docstring_tokens": "Get a value from a dict which contains just one item .", "label": 1}, {"idx": "cosqa-train-6501", "doc": "change an object to a datetime python", "code": "def date_to_datetime(x):\n    \"\"\"Convert a date into a datetime\"\"\"\n    if not isinstance(x, datetime) and isinstance(x, date):\n        return datetime.combine(x, time())\n    return x", "code_tokens": "def date_to_datetime ( x ) : if not isinstance ( x , datetime ) and isinstance ( x , date ) : return datetime . combine ( x , time ( ) ) return x", "docstring_tokens": "Convert a date into a datetime", "label": 0}, {"idx": "cosqa-train-6502", "doc": "python dictionary to eliminate words", "code": "def _remove_keywords(d):\n    \"\"\"\n    copy the dict, filter_keywords\n\n    Parameters\n    ----------\n    d : dict\n    \"\"\"\n    return { k:v for k, v in iteritems(d) if k not in RESERVED }", "code_tokens": "def _remove_keywords ( d ) : return { k : v for k , v in iteritems ( d ) if k not in RESERVED }", "docstring_tokens": "copy the dict filter_keywords", "label": 0}, {"idx": "cosqa-train-6503", "doc": "change array into string python", "code": "def bitsToString(arr):\n  \"\"\"Returns a string representing a numpy array of 0's and 1's\"\"\"\n  s = array('c','.'*len(arr))\n  for i in xrange(len(arr)):\n    if arr[i] == 1:\n      s[i]='*'\n  return s", "code_tokens": "def bitsToString ( arr ) : s = array ( 'c' , '.' * len ( arr ) ) for i in xrange ( len ( arr ) ) : if arr [ i ] == 1 : s [ i ] = '*' return s", "docstring_tokens": "Returns a string representing a numpy array of 0 s and 1 s", "label": 0}, {"idx": "cosqa-train-6504", "doc": "python dictionary value change copy", "code": "def data(self, data):\n        \"\"\"Store a copy of the data.\"\"\"\n        self._data = {det: d.copy() for (det, d) in data.items()}", "code_tokens": "def data ( self , data ) : self . _data = { det : d . copy ( ) for ( det , d ) in data . items ( ) }", "docstring_tokens": "Store a copy of the data .", "label": 0}, {"idx": "cosqa-train-6505", "doc": "change filenames to lowercase python", "code": "def lower_ext(abspath):\n    \"\"\"Convert file extension to lowercase.\n    \"\"\"\n    fname, ext = os.path.splitext(abspath)\n    return fname + ext.lower()", "code_tokens": "def lower_ext ( abspath ) : fname , ext = os . path . splitext ( abspath ) return fname + ext . lower ( )", "docstring_tokens": "Convert file extension to lowercase .", "label": 1}, {"idx": "cosqa-train-6506", "doc": "python disable keyboardinterrupt during procedure", "code": "def stop_button_click_handler(self):\n        \"\"\"Method to handle what to do when the stop button is pressed\"\"\"\n        self.stop_button.setDisabled(True)\n        # Interrupt computations or stop debugging\n        if not self.shellwidget._reading:\n            self.interrupt_kernel()\n        else:\n            self.shellwidget.write_to_stdin('exit')", "code_tokens": "def stop_button_click_handler ( self ) : self . stop_button . setDisabled ( True ) # Interrupt computations or stop debugging\n if not self . shellwidget . _reading : self . interrupt_kernel ( ) else : self . shellwidget . write_to_stdin ( 'exit' )", "docstring_tokens": "Method to handle what to do when the stop button is pressed", "label": 1}, {"idx": "cosqa-train-6507", "doc": "change from timestamp to datetime python", "code": "def timestamp_to_datetime(timestamp):\n    \"\"\"Convert an ARF timestamp to a datetime.datetime object (naive local time)\"\"\"\n    from datetime import datetime, timedelta\n    obj = datetime.fromtimestamp(timestamp[0])\n    return obj + timedelta(microseconds=int(timestamp[1]))", "code_tokens": "def timestamp_to_datetime ( timestamp ) : from datetime import datetime , timedelta obj = datetime . fromtimestamp ( timestamp [ 0 ] ) return obj + timedelta ( microseconds = int ( timestamp [ 1 ] ) )", "docstring_tokens": "Convert an ARF timestamp to a datetime . datetime object ( naive local time )", "label": 1}, {"idx": "cosqa-train-6508", "doc": "python disable stdout line buffering", "code": "def disable_stdout_buffering():\n    \"\"\"This turns off stdout buffering so that outputs are immediately\n    materialized and log messages show up before the program exits\"\"\"\n    stdout_orig = sys.stdout\n    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)\n    # NOTE(brandyn): This removes the original stdout\n    return stdout_orig", "code_tokens": "def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig", "docstring_tokens": "This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits", "label": 0}, {"idx": "cosqa-train-6509", "doc": "change height and width of an image in python", "code": "def scale_image(image, new_width):\n    \"\"\"Resizes an image preserving the aspect ratio.\n    \"\"\"\n    (original_width, original_height) = image.size\n    aspect_ratio = original_height/float(original_width)\n    new_height = int(aspect_ratio * new_width)\n\n    # This scales it wider than tall, since characters are biased\n    new_image = image.resize((new_width*2, new_height))\n    return new_image", "code_tokens": "def scale_image ( image , new_width ) : ( original_width , original_height ) = image . size aspect_ratio = original_height / float ( original_width ) new_height = int ( aspect_ratio * new_width ) # This scales it wider than tall, since characters are biased new_image = image . resize ( ( new_width * 2 , new_height ) ) return new_image", "docstring_tokens": "Resizes an image preserving the aspect ratio .", "label": 0}, {"idx": "cosqa-train-6510", "doc": "python discord leave voice channel", "code": "async def join(self, ctx, *, channel: discord.VoiceChannel):\n        \"\"\"Joins a voice channel\"\"\"\n\n        if ctx.voice_client is not None:\n            return await ctx.voice_client.move_to(channel)\n\n        await channel.connect()", "code_tokens": "async def join ( self , ctx , * , channel : discord . VoiceChannel ) : if ctx . voice_client is not None : return await ctx . voice_client . move_to ( channel ) await channel . connect ( )", "docstring_tokens": "Joins a voice channel", "label": 1}, {"idx": "cosqa-train-6511", "doc": "change label of treemap from code to names using squarify in python", "code": "def _renamer(self, tre):\n        \"\"\" renames newick from numbers to sample names\"\"\"\n        ## get the tre with numbered tree tip labels\n        names = tre.get_leaves()\n\n        ## replace numbered names with snames\n        for name in names:\n            name.name = self.samples[int(name.name)]\n\n        ## return with only topology and leaf labels\n        return tre.write(format=9)", "code_tokens": "def _renamer ( self , tre ) : ## get the tre with numbered tree tip labels names = tre . get_leaves ( ) ## replace numbered names with snames for name in names : name . name = self . samples [ int ( name . name ) ] ## return with only topology and leaf labels return tre . write ( format = 9 )", "docstring_tokens": "renames newick from numbers to sample names", "label": 1}, {"idx": "cosqa-train-6512", "doc": "python display local timezone", "code": "def with_tz(request):\n    \"\"\"\n    Get the time with TZ enabled\n\n    \"\"\"\n    \n    dt = datetime.now() \n    t = Template('{% load tz %}{% localtime on %}{% get_current_timezone as TIME_ZONE %}{{ TIME_ZONE }}{% endlocaltime %}') \n    c = RequestContext(request)\n    response = t.render(c)\n    return HttpResponse(response)", "code_tokens": "def with_tz ( request ) : dt = datetime . now ( ) t = Template ( '{% load tz %}{% localtime on %}{% get_current_timezone as TIME_ZONE %}{{ TIME_ZONE }}{% endlocaltime %}' ) c = RequestContext ( request ) response = t . render ( c ) return HttpResponse ( response )", "docstring_tokens": "Get the time with TZ enabled", "label": 0}, {"idx": "cosqa-train-6513", "doc": "change permissions on file python", "code": "def add_exec_permission_to(target_file):\n    \"\"\"Add executable permissions to the file\n\n    :param target_file: the target file whose permission to be changed\n    \"\"\"\n    mode = os.stat(target_file).st_mode\n    os.chmod(target_file, mode | stat.S_IXUSR)", "code_tokens": "def add_exec_permission_to ( target_file ) : mode = os . stat ( target_file ) . st_mode os . chmod ( target_file , mode | stat . S_IXUSR )", "docstring_tokens": "Add executable permissions to the file", "label": 0}, {"idx": "cosqa-train-6514", "doc": "python distance matrix fucntion", "code": "def get_distance_matrix(x):\n    \"\"\"Get distance matrix given a matrix. Used in testing.\"\"\"\n    square = nd.sum(x ** 2.0, axis=1, keepdims=True)\n    distance_square = square + square.transpose() - (2.0 * nd.dot(x, x.transpose()))\n    return nd.sqrt(distance_square)", "code_tokens": "def get_distance_matrix ( x ) : square = nd . sum ( x ** 2.0 , axis = 1 , keepdims = True ) distance_square = square + square . transpose ( ) - ( 2.0 * nd . dot ( x , x . transpose ( ) ) ) return nd . sqrt ( distance_square )", "docstring_tokens": "Get distance matrix given a matrix . Used in testing .", "label": 0}, {"idx": "cosqa-train-6515", "doc": "change python dict string to values", "code": "def str_dict(some_dict):\n    \"\"\"Convert dict of ascii str/unicode to dict of str, if necessary\"\"\"\n    return {str(k): str(v) for k, v in some_dict.items()}", "code_tokens": "def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }", "docstring_tokens": "Convert dict of ascii str / unicode to dict of str if necessary", "label": 0}, {"idx": "cosqa-train-6516", "doc": "python django postgres flow", "code": "def install_postgres(user=None, dbname=None, password=None):\n    \"\"\"Install Postgres on remote\"\"\"\n    execute(pydiploy.django.install_postgres_server,\n            user=user, dbname=dbname, password=password)", "code_tokens": "def install_postgres ( user = None , dbname = None , password = None ) : execute ( pydiploy . django . install_postgres_server , user = user , dbname = dbname , password = password )", "docstring_tokens": "Install Postgres on remote", "label": 1}, {"idx": "cosqa-train-6517", "doc": "change rgb to graysclae with 3 value in python", "code": "def name2rgb(hue):\n    \"\"\"Originally used to calculate color based on module name.\n    \"\"\"\n    r, g, b = colorsys.hsv_to_rgb(hue / 360.0, .8, .7)\n    return tuple(int(x * 256) for x in [r, g, b])", "code_tokens": "def name2rgb ( hue ) : r , g , b = colorsys . hsv_to_rgb ( hue / 360.0 , .8 , .7 ) return tuple ( int ( x * 256 ) for x in [ r , g , b ] )", "docstring_tokens": "Originally used to calculate color based on module name .", "label": 1}, {"idx": "cosqa-train-6518", "doc": "python django static pictures in settings", "code": "def get_static_url():\n    \"\"\"Return a base static url, always ending with a /\"\"\"\n    path = getattr(settings, 'STATIC_URL', None)\n    if not path:\n        path = getattr(settings, 'MEDIA_URL', None)\n    if not path:\n        path = '/'\n    return path", "code_tokens": "def get_static_url ( ) : path = getattr ( settings , 'STATIC_URL' , None ) if not path : path = getattr ( settings , 'MEDIA_URL' , None ) if not path : path = '/' return path", "docstring_tokens": "Return a base static url always ending with a /", "label": 1}, {"idx": "cosqa-train-6519", "doc": "change shape of list in python", "code": "def shape_list(l,shape,dtype):\n    \"\"\" Shape a list of lists into the appropriate shape and data type \"\"\"\n    return np.array(l, dtype=dtype).reshape(shape)", "code_tokens": "def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )", "docstring_tokens": "Shape a list of lists into the appropriate shape and data type", "label": 0}, {"idx": "cosqa-train-6520", "doc": "python django test 1090 you cant delete all columns", "code": "def delete_all_from_db():\n    \"\"\"Clear the database.\n\n    Used for testing and debugging.\n\n    \"\"\"\n    # The models.CASCADE property is set on all ForeignKey fields, so tables can\n    # be deleted in any order without breaking constraints.\n    for model in django.apps.apps.get_models():\n        model.objects.all().delete()", "code_tokens": "def delete_all_from_db ( ) : # The models.CASCADE property is set on all ForeignKey fields, so tables can # be deleted in any order without breaking constraints. for model in django . apps . apps . get_models ( ) : model . objects . all ( ) . delete ( )", "docstring_tokens": "Clear the database .", "label": 0}, {"idx": "cosqa-train-6521", "doc": "change sparse matrix datatype to python", "code": "def scipy_sparse_to_spmatrix(A):\n    \"\"\"Efficient conversion from scipy sparse matrix to cvxopt sparse matrix\"\"\"\n    coo = A.tocoo()\n    SP = spmatrix(coo.data.tolist(), coo.row.tolist(), coo.col.tolist(), size=A.shape)\n    return SP", "code_tokens": "def scipy_sparse_to_spmatrix ( A ) : coo = A . tocoo ( ) SP = spmatrix ( coo . data . tolist ( ) , coo . row . tolist ( ) , coo . col . tolist ( ) , size = A . shape ) return SP", "docstring_tokens": "Efficient conversion from scipy sparse matrix to cvxopt sparse matrix", "label": 0}, {"idx": "cosqa-train-6522", "doc": "python django using ftp connection", "code": "def connect():\n    \"\"\"Connect to FTP server, login and return an ftplib.FTP instance.\"\"\"\n    ftp_class = ftplib.FTP if not SSL else ftplib.FTP_TLS\n    ftp = ftp_class(timeout=TIMEOUT)\n    ftp.connect(HOST, PORT)\n    ftp.login(USER, PASSWORD)\n    if SSL:\n        ftp.prot_p()  # secure data connection\n    return ftp", "code_tokens": "def connect ( ) : ftp_class = ftplib . FTP if not SSL else ftplib . FTP_TLS ftp = ftp_class ( timeout = TIMEOUT ) ftp . connect ( HOST , PORT ) ftp . login ( USER , PASSWORD ) if SSL : ftp . prot_p ( ) # secure data connection return ftp", "docstring_tokens": "Connect to FTP server login and return an ftplib . FTP instance .", "label": 1}, {"idx": "cosqa-train-6523", "doc": "change string column to date python", "code": "def convert_str_to_datetime(df, *, column: str, format: str):\n    \"\"\"\n    Convert string column into datetime column\n\n    ---\n\n    ### Parameters\n\n    *mandatory :*\n    - `column` (*str*): name of the column to format\n    - `format` (*str*): current format of the values (see [available formats](\n    https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior))\n    \"\"\"\n    df[column] = pd.to_datetime(df[column], format=format)\n    return df", "code_tokens": "def convert_str_to_datetime ( df , * , column : str , format : str ) : df [ column ] = pd . to_datetime ( df [ column ] , format = format ) return df", "docstring_tokens": "Convert string column into datetime column", "label": 1}, {"idx": "cosqa-train-6524", "doc": "python do something if not interactive", "code": "def is_interactive(self):\n        \"\"\" Determine if the user requested interactive mode.\n        \"\"\"\n        # The Python interpreter sets sys.flags correctly, so use them!\n        if sys.flags.interactive:\n            return True\n\n        # IPython does not set sys.flags when -i is specified, so first\n        # check it if it is already imported.\n        if '__IPYTHON__' not in dir(six.moves.builtins):\n            return False\n\n        # Then we check the application singleton and determine based on\n        # a variable it sets.\n        try:\n            from IPython.config.application import Application as App\n            return App.initialized() and App.instance().interact\n        except (ImportError, AttributeError):\n            return False", "code_tokens": "def is_interactive ( self ) : # The Python interpreter sets sys.flags correctly, so use them! if sys . flags . interactive : return True # IPython does not set sys.flags when -i is specified, so first # check it if it is already imported. if '__IPYTHON__' not in dir ( six . moves . builtins ) : return False # Then we check the application singleton and determine based on # a variable it sets. try : from IPython . config . application import Application as App return App . initialized ( ) and App . instance ( ) . interact except ( ImportError , AttributeError ) : return False", "docstring_tokens": "Determine if the user requested interactive mode .", "label": 0}, {"idx": "cosqa-train-6525", "doc": "change the position of 3d coordinate in python", "code": "def list(self):\n        \"\"\"position in 3d space\"\"\"\n        return [self._pos3d.x, self._pos3d.y, self._pos3d.z]", "code_tokens": "def list ( self ) : return [ self . _pos3d . x , self . _pos3d . y , self . _pos3d . z ]", "docstring_tokens": "position in 3d space", "label": 1}, {"idx": "cosqa-train-6526", "doc": "python docker postgresql connect", "code": "def install_postgres(user=None, dbname=None, password=None):\n    \"\"\"Install Postgres on remote\"\"\"\n    execute(pydiploy.django.install_postgres_server,\n            user=user, dbname=dbname, password=password)", "code_tokens": "def install_postgres ( user = None , dbname = None , password = None ) : execute ( pydiploy . django . install_postgres_server , user = user , dbname = dbname , password = password )", "docstring_tokens": "Install Postgres on remote", "label": 0}, {"idx": "cosqa-train-6527", "doc": "change to factor in python", "code": "def multiply(self, number):\n        \"\"\"Return a Vector as the product of the vector and a real number.\"\"\"\n        return self.from_list([x * number for x in self.to_list()])", "code_tokens": "def multiply ( self , number ) : return self . from_list ( [ x * number for x in self . to_list ( ) ] )", "docstring_tokens": "Return a Vector as the product of the vector and a real number .", "label": 0}, {"idx": "cosqa-train-6528", "doc": "python docstring for abstractmethod", "code": "def inheritdoc(method):\n    \"\"\"Set __doc__ of *method* to __doc__ of *method* in its parent class.\n\n    Since this is used on :class:`.StringMixIn`, the \"parent class\" used is\n    ``str``. This function can be used as a decorator.\n    \"\"\"\n    method.__doc__ = getattr(str, method.__name__).__doc__\n    return method", "code_tokens": "def inheritdoc ( method ) : method . __doc__ = getattr ( str , method . __name__ ) . __doc__ return method", "docstring_tokens": "Set __doc__ of * method * to __doc__ of * method * in its parent class .", "label": 0}, {"idx": "cosqa-train-6529", "doc": "change to int64 data type python", "code": "def decode_arr(data):\n    \"\"\"Extract a numpy array from a base64 buffer\"\"\"\n    data = data.encode('utf-8')\n    return frombuffer(base64.b64decode(data), float64)", "code_tokens": "def decode_arr ( data ) : data = data . encode ( 'utf-8' ) return frombuffer ( base64 . b64decode ( data ) , float64 )", "docstring_tokens": "Extract a numpy array from a base64 buffer", "label": 1}, {"idx": "cosqa-train-6530", "doc": "python docstring restructured text example", "code": "def format_doc_text(text):\n    \"\"\"\n    A very thin wrapper around textwrap.fill to consistently wrap documentation text\n    for display in a command line environment. The text is wrapped to 99 characters with an\n    indentation depth of 4 spaces. Each line is wrapped independently in order to preserve\n    manually added line breaks.\n\n    :param text: The text to format, it is cleaned by inspect.cleandoc.\n    :return: The formatted doc text.\n    \"\"\"\n\n    return '\\n'.join(\n        textwrap.fill(line, width=99, initial_indent='    ', subsequent_indent='    ')\n        for line in inspect.cleandoc(text).splitlines())", "code_tokens": "def format_doc_text ( text ) : return '\\n' . join ( textwrap . fill ( line , width = 99 , initial_indent = '    ' , subsequent_indent = '    ' ) for line in inspect . cleandoc ( text ) . splitlines ( ) )", "docstring_tokens": "A very thin wrapper around textwrap . fill to consistently wrap documentation text for display in a command line environment . The text is wrapped to 99 characters with an indentation depth of 4 spaces . Each line is wrapped independently in order to preserve manually added line breaks .", "label": 0}, {"idx": "cosqa-train-6531", "doc": "changing precision in decimal function in python", "code": "def round_to_int(number, precision):\n    \"\"\"Round a number to a precision\"\"\"\n    precision = int(precision)\n    rounded = (int(number) + precision / 2) // precision * precision\n    return rounded", "code_tokens": "def round_to_int ( number , precision ) : precision = int ( precision ) rounded = ( int ( number ) + precision / 2 ) // precision * precision return rounded", "docstring_tokens": "Round a number to a precision", "label": 0}, {"idx": "cosqa-train-6532", "doc": "python docx add sections", "code": "def fill_document(doc):\n    \"\"\"Add a section, a subsection and some text to the document.\n\n    :param doc: the document\n    :type doc: :class:`pylatex.document.Document` instance\n    \"\"\"\n    with doc.create(Section('A section')):\n        doc.append('Some regular text and some ')\n        doc.append(italic('italic text. '))\n\n        with doc.create(Subsection('A subsection')):\n            doc.append('Also some crazy characters: $&#{}')", "code_tokens": "def fill_document ( doc ) : with doc . create ( Section ( 'A section' ) ) : doc . append ( 'Some regular text and some ' ) doc . append ( italic ( 'italic text. ' ) ) with doc . create ( Subsection ( 'A subsection' ) ) : doc . append ( 'Also some crazy characters: $&#{}' )", "docstring_tokens": "Add a section a subsection and some text to the document .", "label": 1}, {"idx": "cosqa-train-6533", "doc": "changing python locale settings", "code": "def set_locale(request):\n    \"\"\"Return locale from GET lang param or automatically.\"\"\"\n    return request.query.get('lang', app.ps.babel.select_locale_by_request(request))", "code_tokens": "def set_locale ( request ) : return request . query . get ( 'lang' , app . ps . babel . select_locale_by_request ( request ) )", "docstring_tokens": "Return locale from GET lang param or automatically .", "label": 0}, {"idx": "cosqa-train-6534", "doc": "python docx template filled but still editable", "code": "def inline_inputs(self):\n        \"\"\"Inline all input latex files references by this document. The\n        inlining is accomplished recursively. The document is modified\n        in place.\n        \"\"\"\n        self.text = texutils.inline(self.text,\n                                    os.path.dirname(self._filepath))\n        # Remove children\n        self._children = {}", "code_tokens": "def inline_inputs ( self ) : self . text = texutils . inline ( self . text , os . path . dirname ( self . _filepath ) ) # Remove children self . _children = { }", "docstring_tokens": "Inline all input latex files references by this document . The inlining is accomplished recursively . The document is modified in place .", "label": 0}, {"idx": "cosqa-train-6535", "doc": "changing width and height of tk in python", "code": "def setwinsize(self, rows, cols):\n        \"\"\"Set the terminal window size of the child tty.\n        \"\"\"\n        self._winsize = (rows, cols)\n        self.pty.set_size(cols, rows)", "code_tokens": "def setwinsize ( self , rows , cols ) : self . _winsize = ( rows , cols ) self . pty . set_size ( cols , rows )", "docstring_tokens": "Set the terminal window size of the child tty .", "label": 0}, {"idx": "cosqa-train-6536", "doc": "character encoding detector python", "code": "def get_best_encoding(stream):\n    \"\"\"Returns the default stream encoding if not found.\"\"\"\n    rv = getattr(stream, 'encoding', None) or sys.getdefaultencoding()\n    if is_ascii_encoding(rv):\n        return 'utf-8'\n    return rv", "code_tokens": "def get_best_encoding ( stream ) : rv = getattr ( stream , 'encoding' , None ) or sys . getdefaultencoding ( ) if is_ascii_encoding ( rv ) : return 'utf-8' return rv", "docstring_tokens": "Returns the default stream encoding if not found .", "label": 0}, {"idx": "cosqa-train-6537", "doc": "python drop mongo collections if exist", "code": "def delete_collection(mongo_uri, database_name, collection_name):\n    \"\"\"\n    Delete a mongo document collection using pymongo. Mongo daemon assumed to be running.\n\n    Inputs: - mongo_uri: A MongoDB URI.\n            - database_name: The mongo database name as a python string.\n            - collection_name: The mongo collection as a python string.\n    \"\"\"\n    client = pymongo.MongoClient(mongo_uri)\n\n    db = client[database_name]\n\n    db.drop_collection(collection_name)", "code_tokens": "def delete_collection ( mongo_uri , database_name , collection_name ) : client = pymongo . MongoClient ( mongo_uri ) db = client [ database_name ] db . drop_collection ( collection_name )", "docstring_tokens": "Delete a mongo document collection using pymongo . Mongo daemon assumed to be running .", "label": 1}, {"idx": "cosqa-train-6538", "doc": "check if 2 values are approximetly equal python", "code": "def _float_almost_equal(float1, float2, places=7):\n    \"\"\"Return True if two numbers are equal up to the\n    specified number of \"places\" after the decimal point.\n    \"\"\"\n\n    if round(abs(float2 - float1), places) == 0:\n        return True\n\n    return False", "code_tokens": "def _float_almost_equal ( float1 , float2 , places = 7 ) : if round ( abs ( float2 - float1 ) , places ) == 0 : return True return False", "docstring_tokens": "Return True if two numbers are equal up to the specified number of places after the decimal point .", "label": 1}, {"idx": "cosqa-train-6539", "doc": "python dump string pretty", "code": "def _get_pretty_string(obj):\n    \"\"\"Return a prettier version of obj\n\n    Parameters\n    ----------\n    obj : object\n        Object to pretty print\n\n    Returns\n    -------\n    s : str\n        Pretty print object repr\n    \"\"\"\n    sio = StringIO()\n    pprint.pprint(obj, stream=sio)\n    return sio.getvalue()", "code_tokens": "def _get_pretty_string ( obj ) : sio = StringIO ( ) pprint . pprint ( obj , stream = sio ) return sio . getvalue ( )", "docstring_tokens": "Return a prettier version of obj", "label": 0}, {"idx": "cosqa-train-6540", "doc": "check if a keyword is in a list of strings in python", "code": "def any_contains_any(strings, candidates):\n    \"\"\"Whether any of the strings contains any of the candidates.\"\"\"\n    for string in strings:\n        for c in candidates:\n            if c in string:\n                return True", "code_tokens": "def any_contains_any ( strings , candidates ) : for string in strings : for c in candidates : if c in string : return True", "docstring_tokens": "Whether any of the strings contains any of the candidates .", "label": 1}, {"idx": "cosqa-train-6541", "doc": "python dynamic code loading", "code": "def get_code(module):\n    \"\"\"\n    Compile and return a Module's code object.\n    \"\"\"\n    fp = open(module.path)\n    try:\n        return compile(fp.read(), str(module.name), 'exec')\n    finally:\n        fp.close()", "code_tokens": "def get_code ( module ) : fp = open ( module . path ) try : return compile ( fp . read ( ) , str ( module . name ) , 'exec' ) finally : fp . close ( )", "docstring_tokens": "Compile and return a Module s code object .", "label": 0}, {"idx": "cosqa-train-6542", "doc": "check if a number is complex in python", "code": "def is_complex(dtype):\n  \"\"\"Returns whether this is a complex floating point type.\"\"\"\n  dtype = tf.as_dtype(dtype)\n  if hasattr(dtype, 'is_complex'):\n    return dtype.is_complex\n  return np.issubdtype(np.dtype(dtype), np.complex)", "code_tokens": "def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )", "docstring_tokens": "Returns whether this is a complex floating point type .", "label": 1}, {"idx": "cosqa-train-6543", "doc": "python dynamically set a method name", "code": "def command(name, mode):\n    \"\"\" Label a method as a command with name. \"\"\"\n    def decorator(fn):\n        commands[name] = fn.__name__\n        _Client._addMethod(fn.__name__, name, mode)\n        return fn\n    return decorator", "code_tokens": "def command ( name , mode ) : def decorator ( fn ) : commands [ name ] = fn . __name__ _Client . _addMethod ( fn . __name__ , name , mode ) return fn return decorator", "docstring_tokens": "Label a method as a command with name .", "label": 0}, {"idx": "cosqa-train-6544", "doc": "check if a number is complex python", "code": "def is_complex(dtype):\n  \"\"\"Returns whether this is a complex floating point type.\"\"\"\n  dtype = tf.as_dtype(dtype)\n  if hasattr(dtype, 'is_complex'):\n    return dtype.is_complex\n  return np.issubdtype(np.dtype(dtype), np.complex)", "code_tokens": "def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )", "docstring_tokens": "Returns whether this is a complex floating point type .", "label": 1}, {"idx": "cosqa-train-6545", "doc": "python easygui window freeze on closing", "code": "def closing_plugin(self, cancelable=False):\n        \"\"\"Perform actions before parent main window is closed\"\"\"\n        self.dialog_manager.close_all()\n        self.shell.exit_interpreter()\n        return True", "code_tokens": "def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True", "docstring_tokens": "Perform actions before parent main window is closed", "label": 1}, {"idx": "cosqa-train-6546", "doc": "check if a property is null python", "code": "def _is_initialized(self, entity):\n    \"\"\"Internal helper to ask if the entity has a value for this Property.\n\n    This returns False if a value is stored but it is None.\n    \"\"\"\n    return (not self._required or\n            ((self._has_value(entity) or self._default is not None) and\n             self._get_value(entity) is not None))", "code_tokens": "def _is_initialized ( self , entity ) : return ( not self . _required or ( ( self . _has_value ( entity ) or self . _default is not None ) and self . _get_value ( entity ) is not None ) )", "docstring_tokens": "Internal helper to ask if the entity has a value for this Property .", "label": 1}, {"idx": "cosqa-train-6547", "doc": "python elasticsearch api scroll", "code": "def scan(client, query=None, scroll='5m', raise_on_error=True,\n         preserve_order=False, size=1000, **kwargs):\n    \"\"\"\n    Simple abstraction on top of the\n    :meth:`~elasticsearch.Elasticsearch.scroll` api - a simple iterator that\n    yields all hits as returned by underlining scroll requests.\n    By default scan does not return results in any pre-determined order. To\n    have a standard order in the returned documents (either by score or\n    explicit sort definition) when scrolling, use ``preserve_order=True``. This\n    may be an expensive operation and will negate the performance benefits of\n    using ``scan``.\n    :arg client: instance of :class:`~elasticsearch.Elasticsearch` to use\n    :arg query: body for the :meth:`~elasticsearch.Elasticsearch.search` api\n    :arg scroll: Specify how long a consistent view of the index should be\n        maintained for scrolled search\n    :arg raise_on_error: raises an exception (``ScanError``) if an error is\n        encountered (some shards fail to execute). By default we raise.\n    :arg preserve_order: don't set the ``search_type`` to ``scan`` - this will\n        cause the scroll to paginate with preserving the order. Note that this\n        can be an extremely expensive operation and can easily lead to\n        unpredictable results, use with caution.\n    :arg size: size (per shard) of the batch send at each iteration.\n    Any additional keyword arguments will be passed to the initial\n    :meth:`~elasticsearch.Elasticsearch.search` call::\n        scan(es,\n            query={\"query\": {\"match\": {\"title\": \"python\"}}},\n            index=\"orders-*\",\n            doc_type=\"books\"\n        )\n    \"\"\"\n    if not preserve_order:\n        kwargs['search_type'] = 'scan'\n    # initial search\n    resp = client.search(body=query, scroll=scroll, size=size, **kwargs)\n\n    scroll_id = resp.get('_scroll_id')\n    if scroll_id is None:\n        return\n\n    first_run = True\n    while True:\n        # if we didn't set search_type to scan initial search contains data\n        if preserve_order and first_run:\n            first_run = False\n        else:\n            resp = client.scroll(scroll_id, scroll=scroll)\n\n        for hit in resp['hits']['hits']:\n            yield hit\n\n        # check if we have any errrors\n        if resp[\"_shards\"][\"failed\"]:\n            logger.warning(\n                'Scroll request has failed on %d shards out of %d.',\n                resp['_shards']['failed'], resp['_shards']['total']\n            )\n            if raise_on_error:\n                raise ScanError(\n                    'Scroll request has failed on %d shards out of %d.' %\n                    (resp['_shards']['failed'], resp['_shards']['total'])\n                )\n\n        scroll_id = resp.get('_scroll_id')\n        # end of scroll\n        if scroll_id is None or not resp['hits']['hits']:\n            break", "code_tokens": "def scan ( client , query = None , scroll = '5m' , raise_on_error = True , preserve_order = False , size = 1000 , * * kwargs ) : if not preserve_order : kwargs [ 'search_type' ] = 'scan' # initial search resp = client . search ( body = query , scroll = scroll , size = size , * * kwargs ) scroll_id = resp . get ( '_scroll_id' ) if scroll_id is None : return first_run = True while True : # if we didn't set search_type to scan initial search contains data if preserve_order and first_run : first_run = False else : resp = client . scroll ( scroll_id , scroll = scroll ) for hit in resp [ 'hits' ] [ 'hits' ] : yield hit # check if we have any errrors if resp [ \"_shards\" ] [ \"failed\" ] : logger . warning ( 'Scroll request has failed on %d shards out of %d.' , resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) if raise_on_error : raise ScanError ( 'Scroll request has failed on %d shards out of %d.' % ( resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) ) scroll_id = resp . get ( '_scroll_id' ) # end of scroll if scroll_id is None or not resp [ 'hits' ] [ 'hits' ] : break", "docstring_tokens": "Simple abstraction on top of the : meth : ~elasticsearch . Elasticsearch . scroll api - a simple iterator that yields all hits as returned by underlining scroll requests . By default scan does not return results in any pre - determined order . To have a standard order in the returned documents ( either by score or explicit sort definition ) when scrolling use preserve_order = True . This may be an expensive operation and will negate the performance benefits of using scan . : arg client : instance of : class : ~elasticsearch . Elasticsearch to use : arg query : body for the : meth : ~elasticsearch . Elasticsearch . search api : arg scroll : Specify how long a consistent view of the index should be maintained for scrolled search : arg raise_on_error : raises an exception ( ScanError ) if an error is encountered ( some shards fail to execute ) . By default we raise . : arg preserve_order : don t set the search_type to scan - this will cause the scroll to paginate with preserving the order . Note that this can be an extremely expensive operation and can easily lead to unpredictable results use with caution . : arg size : size ( per shard ) of the batch send at each iteration . Any additional keyword arguments will be passed to the initial : meth : ~elasticsearch . Elasticsearch . search call :: scan ( es query = { query : { match : { title : python }}} index = orders - * doc_type = books )", "label": 1}, {"idx": "cosqa-train-6548", "doc": "check if a word contains punctuation python", "code": "def is_punctuation(text):\n    \"\"\"Check if given string is a punctuation\"\"\"\n    return not (text.lower() in config.AVRO_VOWELS or\n                text.lower() in config.AVRO_CONSONANTS)", "code_tokens": "def is_punctuation ( text ) : return not ( text . lower ( ) in config . AVRO_VOWELS or text . lower ( ) in config . AVRO_CONSONANTS )", "docstring_tokens": "Check if given string is a punctuation", "label": 1}, {"idx": "cosqa-train-6549", "doc": "python elasticsearch delete field", "code": "def clear_es():\n        \"\"\"Clear all indexes in the es core\"\"\"\n        # TODO: should receive a catalog slug.\n        ESHypermap.es.indices.delete(ESHypermap.index_name, ignore=[400, 404])\n        LOGGER.debug('Elasticsearch: Index cleared')", "code_tokens": "def clear_es ( ) : # TODO: should receive a catalog slug. ESHypermap . es . indices . delete ( ESHypermap . index_name , ignore = [ 400 , 404 ] ) LOGGER . debug ( 'Elasticsearch: Index cleared' )", "docstring_tokens": "Clear all indexes in the es core", "label": 0}, {"idx": "cosqa-train-6550", "doc": "check if all variables in array are integers python", "code": "def is_int_vector(l):\n    r\"\"\"Checks if l is a numpy array of integers\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 1 and (l.dtype.kind == 'i' or l.dtype.kind == 'u'):\n            return True\n    return False", "code_tokens": "def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False", "docstring_tokens": "r Checks if l is a numpy array of integers", "label": 0}, {"idx": "cosqa-train-6551", "doc": "python elasticsearch limit results", "code": "def scan(client, query=None, scroll='5m', raise_on_error=True,\n         preserve_order=False, size=1000, **kwargs):\n    \"\"\"\n    Simple abstraction on top of the\n    :meth:`~elasticsearch.Elasticsearch.scroll` api - a simple iterator that\n    yields all hits as returned by underlining scroll requests.\n    By default scan does not return results in any pre-determined order. To\n    have a standard order in the returned documents (either by score or\n    explicit sort definition) when scrolling, use ``preserve_order=True``. This\n    may be an expensive operation and will negate the performance benefits of\n    using ``scan``.\n    :arg client: instance of :class:`~elasticsearch.Elasticsearch` to use\n    :arg query: body for the :meth:`~elasticsearch.Elasticsearch.search` api\n    :arg scroll: Specify how long a consistent view of the index should be\n        maintained for scrolled search\n    :arg raise_on_error: raises an exception (``ScanError``) if an error is\n        encountered (some shards fail to execute). By default we raise.\n    :arg preserve_order: don't set the ``search_type`` to ``scan`` - this will\n        cause the scroll to paginate with preserving the order. Note that this\n        can be an extremely expensive operation and can easily lead to\n        unpredictable results, use with caution.\n    :arg size: size (per shard) of the batch send at each iteration.\n    Any additional keyword arguments will be passed to the initial\n    :meth:`~elasticsearch.Elasticsearch.search` call::\n        scan(es,\n            query={\"query\": {\"match\": {\"title\": \"python\"}}},\n            index=\"orders-*\",\n            doc_type=\"books\"\n        )\n    \"\"\"\n    if not preserve_order:\n        kwargs['search_type'] = 'scan'\n    # initial search\n    resp = client.search(body=query, scroll=scroll, size=size, **kwargs)\n\n    scroll_id = resp.get('_scroll_id')\n    if scroll_id is None:\n        return\n\n    first_run = True\n    while True:\n        # if we didn't set search_type to scan initial search contains data\n        if preserve_order and first_run:\n            first_run = False\n        else:\n            resp = client.scroll(scroll_id, scroll=scroll)\n\n        for hit in resp['hits']['hits']:\n            yield hit\n\n        # check if we have any errrors\n        if resp[\"_shards\"][\"failed\"]:\n            logger.warning(\n                'Scroll request has failed on %d shards out of %d.',\n                resp['_shards']['failed'], resp['_shards']['total']\n            )\n            if raise_on_error:\n                raise ScanError(\n                    'Scroll request has failed on %d shards out of %d.' %\n                    (resp['_shards']['failed'], resp['_shards']['total'])\n                )\n\n        scroll_id = resp.get('_scroll_id')\n        # end of scroll\n        if scroll_id is None or not resp['hits']['hits']:\n            break", "code_tokens": "def scan ( client , query = None , scroll = '5m' , raise_on_error = True , preserve_order = False , size = 1000 , * * kwargs ) : if not preserve_order : kwargs [ 'search_type' ] = 'scan' # initial search resp = client . search ( body = query , scroll = scroll , size = size , * * kwargs ) scroll_id = resp . get ( '_scroll_id' ) if scroll_id is None : return first_run = True while True : # if we didn't set search_type to scan initial search contains data if preserve_order and first_run : first_run = False else : resp = client . scroll ( scroll_id , scroll = scroll ) for hit in resp [ 'hits' ] [ 'hits' ] : yield hit # check if we have any errrors if resp [ \"_shards\" ] [ \"failed\" ] : logger . warning ( 'Scroll request has failed on %d shards out of %d.' , resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) if raise_on_error : raise ScanError ( 'Scroll request has failed on %d shards out of %d.' % ( resp [ '_shards' ] [ 'failed' ] , resp [ '_shards' ] [ 'total' ] ) ) scroll_id = resp . get ( '_scroll_id' ) # end of scroll if scroll_id is None or not resp [ 'hits' ] [ 'hits' ] : break", "docstring_tokens": "Simple abstraction on top of the : meth : ~elasticsearch . Elasticsearch . scroll api - a simple iterator that yields all hits as returned by underlining scroll requests . By default scan does not return results in any pre - determined order . To have a standard order in the returned documents ( either by score or explicit sort definition ) when scrolling use preserve_order = True . This may be an expensive operation and will negate the performance benefits of using scan . : arg client : instance of : class : ~elasticsearch . Elasticsearch to use : arg query : body for the : meth : ~elasticsearch . Elasticsearch . search api : arg scroll : Specify how long a consistent view of the index should be maintained for scrolled search : arg raise_on_error : raises an exception ( ScanError ) if an error is encountered ( some shards fail to execute ) . By default we raise . : arg preserve_order : don t set the search_type to scan - this will cause the scroll to paginate with preserving the order . Note that this can be an extremely expensive operation and can easily lead to unpredictable results use with caution . : arg size : size ( per shard ) of the batch send at each iteration . Any additional keyword arguments will be passed to the initial : meth : ~elasticsearch . Elasticsearch . search call :: scan ( es query = { query : { match : { title : python }}} index = orders - * doc_type = books )", "label": 1}, {"idx": "cosqa-train-6552", "doc": "check if an item is not none python", "code": "def _not_none(items):\n    \"\"\"Whether the item is a placeholder or contains a placeholder.\"\"\"\n    if not isinstance(items, (tuple, list)):\n        items = (items,)\n    return all(item is not _none for item in items)", "code_tokens": "def _not_none ( items ) : if not isinstance ( items , ( tuple , list ) ) : items = ( items , ) return all ( item is not _none for item in items )", "docstring_tokens": "Whether the item is a placeholder or contains a placeholder .", "label": 1}, {"idx": "cosqa-train-6553", "doc": "python element wises addition", "code": "def __add__(self, other):\n        \"\"\"Handle the `+` operator.\"\"\"\n        return self._handle_type(other)(self.value + other.value)", "code_tokens": "def __add__ ( self , other ) : return self . _handle_type ( other ) ( self . value + other . value )", "docstring_tokens": "Handle the + operator .", "label": 0}, {"idx": "cosqa-train-6554", "doc": "check if authentication failed with requests in python", "code": "def _is_expired_response(self, response):\n        \"\"\"\n        Check if the response failed because of an expired access token.\n        \"\"\"\n        if response.status_code != 401:\n            return False\n        challenge = response.headers.get('www-authenticate', '')\n        return 'error=\"invalid_token\"' in challenge", "code_tokens": "def _is_expired_response ( self , response ) : if response . status_code != 401 : return False challenge = response . headers . get ( 'www-authenticate' , '' ) return 'error=\"invalid_token\"' in challenge", "docstring_tokens": "Check if the response failed because of an expired access token .", "label": 0}, {"idx": "cosqa-train-6555", "doc": "python elementtree get value by id", "code": "def get_element_with_id(self, id):\n        \"\"\"Return the element with the specified ID.\"\"\"\n        # Should we maintain a hashmap of ids to make this more efficient? Probably overkill.\n        # TODO: Elements can contain nested elements (captions, footnotes, table cells, etc.)\n        return next((el for el in self.elements if el.id == id), None)", "code_tokens": "def get_element_with_id ( self , id ) : # Should we maintain a hashmap of ids to make this more efficient? Probably overkill. # TODO: Elements can contain nested elements (captions, footnotes, table cells, etc.) return next ( ( el for el in self . elements if el . id == id ) , None )", "docstring_tokens": "Return the element with the specified ID .", "label": 1}, {"idx": "cosqa-train-6556", "doc": "check if boolean in python", "code": "def isbinary(*args):\n    \"\"\"Checks if value can be part of binary/bitwise operations.\"\"\"\n    return all(map(lambda c: isnumber(c) or isbool(c), args))", "code_tokens": "def isbinary ( * args ) : return all ( map ( lambda c : isnumber ( c ) or isbool ( c ) , args ) )", "docstring_tokens": "Checks if value can be part of binary / bitwise operations .", "label": 0}, {"idx": "cosqa-train-6557", "doc": "python embed parent into child", "code": "def add_parent(self, parent):\n        \"\"\"\n        Adds self as child of parent, then adds parent.\n        \"\"\"\n        parent.add_child(self)\n        self.parent = parent\n        return parent", "code_tokens": "def add_parent ( self , parent ) : parent . add_child ( self ) self . parent = parent return parent", "docstring_tokens": "Adds self as child of parent then adds parent .", "label": 1}, {"idx": "cosqa-train-6558", "doc": "check if column exists python", "code": "def column_exists(cr, table, column):\n    \"\"\" Check whether a certain column exists \"\"\"\n    cr.execute(\n        'SELECT count(attname) FROM pg_attribute '\n        'WHERE attrelid = '\n        '( SELECT oid FROM pg_class WHERE relname = %s ) '\n        'AND attname = %s',\n        (table, column))\n    return cr.fetchone()[0] == 1", "code_tokens": "def column_exists ( cr , table , column ) : cr . execute ( 'SELECT count(attname) FROM pg_attribute ' 'WHERE attrelid = ' '( SELECT oid FROM pg_class WHERE relname = %s ) ' 'AND attname = %s' , ( table , column ) ) return cr . fetchone ( ) [ 0 ] == 1", "docstring_tokens": "Check whether a certain column exists", "label": 1}, {"idx": "cosqa-train-6559", "doc": "python empty string check nothing", "code": "def is_non_empty_string(input_string):\n    \"\"\"\n    Validate if non empty string\n\n    :param input_string: Input is a *str*.\n    :return: True if input is string and non empty.\n       Raise :exc:`Exception` otherwise.\n    \"\"\"\n    try:\n        if not input_string.strip():\n            raise ValueError()\n    except AttributeError as error:\n        raise TypeError(error)\n\n    return True", "code_tokens": "def is_non_empty_string ( input_string ) : try : if not input_string . strip ( ) : raise ValueError ( ) except AttributeError as error : raise TypeError ( error ) return True", "docstring_tokens": "Validate if non empty string", "label": 1}, {"idx": "cosqa-train-6560", "doc": "check if domain is valid python", "code": "def _is_valid_url(url):\n        \"\"\" Helper function to validate that URLs are well formed, i.e that it contains a valid\n            protocol and a valid domain. It does not actually check if the URL exists\n        \"\"\"\n        try:\n            parsed = urlparse(url)\n            mandatory_parts = [parsed.scheme, parsed.netloc]\n            return all(mandatory_parts)\n        except:\n            return False", "code_tokens": "def _is_valid_url ( url ) : try : parsed = urlparse ( url ) mandatory_parts = [ parsed . scheme , parsed . netloc ] return all ( mandatory_parts ) except : return False", "docstring_tokens": "Helper function to validate that URLs are well formed i . e that it contains a valid protocol and a valid domain . It does not actually check if the URL exists", "label": 0}, {"idx": "cosqa-train-6561", "doc": "python enum for type checking", "code": "def is_enum_type(type_):\n    \"\"\" Checks if the given type is an enum type.\n\n    :param type_: The type to check\n    :return: True if the type is a enum type, otherwise False\n    :rtype: bool\n    \"\"\"\n\n    return isinstance(type_, type) and issubclass(type_, tuple(_get_types(Types.ENUM)))", "code_tokens": "def is_enum_type ( type_ ) : return isinstance ( type_ , type ) and issubclass ( type_ , tuple ( _get_types ( Types . ENUM ) ) )", "docstring_tokens": "Checks if the given type is an enum type .", "label": 1}, {"idx": "cosqa-train-6562", "doc": "check if element of a list is null python list", "code": "def is_nullable_list(val, vtype):\n    \"\"\"Return True if list contains either values of type `vtype` or None.\"\"\"\n    return (isinstance(val, list) and\n            any(isinstance(v, vtype) for v in val) and\n            all((isinstance(v, vtype) or v is None) for v in val))", "code_tokens": "def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )", "docstring_tokens": "Return True if list contains either values of type vtype or None .", "label": 1}, {"idx": "cosqa-train-6563", "doc": "python enum value name", "code": "def EnumValueName(self, enum, value):\n    \"\"\"Returns the string name of an enum value.\n\n    This is just a small helper method to simplify a common operation.\n\n    Args:\n      enum: string name of the Enum.\n      value: int, value of the enum.\n\n    Returns:\n      string name of the enum value.\n\n    Raises:\n      KeyError if either the Enum doesn't exist or the value is not a valid\n        value for the enum.\n    \"\"\"\n    return self.enum_types_by_name[enum].values_by_number[value].name", "code_tokens": "def EnumValueName ( self , enum , value ) : return self . enum_types_by_name [ enum ] . values_by_number [ value ] . name", "docstring_tokens": "Returns the string name of an enum value .", "label": 1}, {"idx": "cosqa-train-6564", "doc": "check if get request is 200 python", "code": "def raise_for_not_ok_status(response):\n    \"\"\"\n    Raises a `requests.exceptions.HTTPError` if the response has a non-200\n    status code.\n    \"\"\"\n    if response.code != OK:\n        raise HTTPError('Non-200 response code (%s) for url: %s' % (\n            response.code, uridecode(response.request.absoluteURI)))\n\n    return response", "code_tokens": "def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response", "docstring_tokens": "Raises a requests . exceptions . HTTPError if the response has a non - 200 status code .", "label": 0}, {"idx": "cosqa-train-6565", "doc": "python enumerate enum values", "code": "def write_enum(fo, datum, schema):\n    \"\"\"An enum is encoded by a int, representing the zero-based position of\n    the symbol in the schema.\"\"\"\n    index = schema['symbols'].index(datum)\n    write_int(fo, index)", "code_tokens": "def write_enum ( fo , datum , schema ) : index = schema [ 'symbols' ] . index ( datum ) write_int ( fo , index )", "docstring_tokens": "An enum is encoded by a int representing the zero - based position of the symbol in the schema .", "label": 1}, {"idx": "cosqa-train-6566", "doc": "check if it is a string or not python", "code": "def is_string(obj):\n    \"\"\"Is this a string.\n\n    :param object obj:\n    :rtype: bool\n    \"\"\"\n    if PYTHON3:\n        str_type = (bytes, str)\n    else:\n        str_type = (bytes, str, unicode)\n    return isinstance(obj, str_type)", "code_tokens": "def is_string ( obj ) : if PYTHON3 : str_type = ( bytes , str ) else : str_type = ( bytes , str , unicode ) return isinstance ( obj , str_type )", "docstring_tokens": "Is this a string .", "label": 1}, {"idx": "cosqa-train-6567", "doc": "python escape string in query postgres", "code": "def _escape(s):\n    \"\"\" Helper method that escapes parameters to a SQL query. \"\"\"\n    e = s\n    e = e.replace('\\\\', '\\\\\\\\')\n    e = e.replace('\\n', '\\\\n')\n    e = e.replace('\\r', '\\\\r')\n    e = e.replace(\"'\", \"\\\\'\")\n    e = e.replace('\"', '\\\\\"')\n    return e", "code_tokens": "def _escape ( s ) : e = s e = e . replace ( '\\\\' , '\\\\\\\\' ) e = e . replace ( '\\n' , '\\\\n' ) e = e . replace ( '\\r' , '\\\\r' ) e = e . replace ( \"'\" , \"\\\\'\" ) e = e . replace ( '\"' , '\\\\\"' ) return e", "docstring_tokens": "Helper method that escapes parameters to a SQL query .", "label": 1}, {"idx": "cosqa-train-6568", "doc": "check if matrix is float python", "code": "def contains_all(self, array):\n        \"\"\"Test if `array` is an array of real numbers.\"\"\"\n        dtype = getattr(array, 'dtype', None)\n        if dtype is None:\n            dtype = np.result_type(*array)\n        return is_real_dtype(dtype)", "code_tokens": "def contains_all ( self , array ) : dtype = getattr ( array , 'dtype' , None ) if dtype is None : dtype = np . result_type ( * array ) return is_real_dtype ( dtype )", "docstring_tokens": "Test if array is an array of real numbers .", "label": 0}, {"idx": "cosqa-train-6569", "doc": "python exchange get user email by id", "code": "def get_user_id_from_email(self, email):\n        \"\"\" Uses the get-all-user-accounts Portals API to retrieve the\n        user-id by supplying an email. \"\"\"\n        accts = self.get_all_user_accounts()\n\n        for acct in accts:\n            if acct['email'] == email:\n                return acct['id']\n        return None", "code_tokens": "def get_user_id_from_email ( self , email ) : accts = self . get_all_user_accounts ( ) for acct in accts : if acct [ 'email' ] == email : return acct [ 'id' ] return None", "docstring_tokens": "Uses the get - all - user - accounts Portals API to retrieve the user - id by supplying an email .", "label": 0}, {"idx": "cosqa-train-6570", "doc": "check if object is callable in python", "code": "def is_function(self):\n        \"\"\"return True if callback is a vanilla plain jane function\"\"\"\n        if self.is_instance() or self.is_class(): return False\n        return isinstance(self.callback, (Callable, classmethod))", "code_tokens": "def is_function ( self ) : if self . is_instance ( ) or self . is_class ( ) : return False return isinstance ( self . callback , ( Callable , classmethod ) )", "docstring_tokens": "return True if callback is a vanilla plain jane function", "label": 0}, {"idx": "cosqa-train-6571", "doc": "python exclude key from dictionary", "code": "def _remove_dict_keys_with_value(dict_, val):\n  \"\"\"Removes `dict` keys which have have `self` as value.\"\"\"\n  return {k: v for k, v in dict_.items() if v is not val}", "code_tokens": "def _remove_dict_keys_with_value ( dict_ , val ) : return { k : v for k , v in dict_ . items ( ) if v is not val }", "docstring_tokens": "Removes dict keys which have have self as value .", "label": 1}, {"idx": "cosqa-train-6572", "doc": "check if python var is int", "code": "def is_int_type(val):\n    \"\"\"Return True if `val` is of integer type.\"\"\"\n    try:               # Python 2\n        return isinstance(val, (int, long))\n    except NameError:  # Python 3\n        return isinstance(val, int)", "code_tokens": "def is_int_type ( val ) : try : # Python 2 return isinstance ( val , ( int , long ) ) except NameError : # Python 3 return isinstance ( val , int )", "docstring_tokens": "Return True if val is of integer type .", "label": 0}, {"idx": "cosqa-train-6573", "doc": "python expand to absulate path", "code": "def expandpath(path):\n    \"\"\"\n    Expand a filesystem path that may or may not contain user/env vars.\n\n    :param str path: path to expand\n    :return str: expanded version of input path\n    \"\"\"\n    return os.path.expandvars(os.path.expanduser(path)).replace(\"//\", \"/\")", "code_tokens": "def expandpath ( path ) : return os . path . expandvars ( os . path . expanduser ( path ) ) . replace ( \"//\" , \"/\" )", "docstring_tokens": "Expand a filesystem path that may or may not contain user / env vars .", "label": 0}, {"idx": "cosqa-train-6574", "doc": "check if singular matrix python", "code": "def is_square_matrix(mat):\n    \"\"\"Test if an array is a square matrix.\"\"\"\n    mat = np.array(mat)\n    if mat.ndim != 2:\n        return False\n    shape = mat.shape\n    return shape[0] == shape[1]", "code_tokens": "def is_square_matrix ( mat ) : mat = np . array ( mat ) if mat . ndim != 2 : return False shape = mat . shape return shape [ 0 ] == shape [ 1 ]", "docstring_tokens": "Test if an array is a square matrix .", "label": 1}, {"idx": "cosqa-train-6575", "doc": "python expandvars replace non defined with empty string", "code": "def _expand(self, str, local_vars={}):\n        \"\"\"Expand $vars in a string.\"\"\"\n        return ninja_syntax.expand(str, self.vars, local_vars)", "code_tokens": "def _expand ( self , str , local_vars = { } ) : return ninja_syntax . expand ( str , self . vars , local_vars )", "docstring_tokens": "Expand $vars in a string .", "label": 1}, {"idx": "cosqa-train-6576", "doc": "check if two files are the same python", "code": "def is_same_file (filename1, filename2):\n    \"\"\"Check if filename1 and filename2 point to the same file object.\n    There can be false negatives, ie. the result is False, but it is\n    the same file anyway. Reason is that network filesystems can create\n    different paths to the same physical file.\n    \"\"\"\n    if filename1 == filename2:\n        return True\n    if os.name == 'posix':\n        return os.path.samefile(filename1, filename2)\n    return is_same_filename(filename1, filename2)", "code_tokens": "def is_same_file ( filename1 , filename2 ) : if filename1 == filename2 : return True if os . name == 'posix' : return os . path . samefile ( filename1 , filename2 ) return is_same_filename ( filename1 , filename2 )", "docstring_tokens": "Check if filename1 and filename2 point to the same file object . There can be false negatives ie . the result is False but it is the same file anyway . Reason is that network filesystems can create different paths to the same physical file .", "label": 0}, {"idx": "cosqa-train-6577", "doc": "python expected type 'str', got 'bytes' instead", "code": "def validate_string(option, value):\n    \"\"\"Validates that 'value' is an instance of `basestring` for Python 2\n    or `str` for Python 3.\n    \"\"\"\n    if isinstance(value, string_type):\n        return value\n    raise TypeError(\"Wrong type for %s, value must be \"\n                    \"an instance of %s\" % (option, string_type.__name__))", "code_tokens": "def validate_string ( option , value ) : if isinstance ( value , string_type ) : return value raise TypeError ( \"Wrong type for %s, value must be \" \"an instance of %s\" % ( option , string_type . __name__ ) )", "docstring_tokens": "Validates that value is an instance of basestring for Python 2 or str for Python 3 .", "label": 0}, {"idx": "cosqa-train-6578", "doc": "check if two string is same python", "code": "def eqstr(a, b):\n    \"\"\"\n    Determine whether two strings are equivalent.\n\n    http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/eqstr_c.html\n\n    :param a: Arbitrary character string.\n    :type a: str\n    :param b: Arbitrary character string.\n    :type b: str\n    :return: True if A and B are equivalent.\n    :rtype: bool\n    \"\"\"\n    return bool(libspice.eqstr_c(stypes.stringToCharP(a), stypes.stringToCharP(b)))", "code_tokens": "def eqstr ( a , b ) : return bool ( libspice . eqstr_c ( stypes . stringToCharP ( a ) , stypes . stringToCharP ( b ) ) )", "docstring_tokens": "Determine whether two strings are equivalent .", "label": 0}, {"idx": "cosqa-train-6579", "doc": "python express the normal distribution pdf", "code": "def EvalGaussianPdf(x, mu, sigma):\n    \"\"\"Computes the unnormalized PDF of the normal distribution.\n\n    x: value\n    mu: mean\n    sigma: standard deviation\n    \n    returns: float probability density\n    \"\"\"\n    return scipy.stats.norm.pdf(x, mu, sigma)", "code_tokens": "def EvalGaussianPdf ( x , mu , sigma ) : return scipy . stats . norm . pdf ( x , mu , sigma )", "docstring_tokens": "Computes the unnormalized PDF of the normal distribution .", "label": 0}, {"idx": "cosqa-train-6580", "doc": "check is end of file reached python", "code": "def eof(fd):\n    \"\"\"Determine if end-of-file is reached for file fd.\"\"\"\n    b = fd.read(1)\n    end = len(b) == 0\n    if not end:\n        curpos = fd.tell()\n        fd.seek(curpos - 1)\n    return end", "code_tokens": "def eof ( fd ) : b = fd . read ( 1 ) end = len ( b ) == 0 if not end : curpos = fd . tell ( ) fd . seek ( curpos - 1 ) return end", "docstring_tokens": "Determine if end - of - file is reached for file fd .", "label": 1}, {"idx": "cosqa-train-6581", "doc": "python extract 5 pages from pdf", "code": "def resources(self):\n        \"\"\"Retrieve contents of each page of PDF\"\"\"\n        return [self.pdf.getPage(i) for i in range(self.pdf.getNumPages())]", "code_tokens": "def resources ( self ) : return [ self . pdf . getPage ( i ) for i in range ( self . pdf . getNumPages ( ) ) ]", "docstring_tokens": "Retrieve contents of each page of PDF", "label": 0}, {"idx": "cosqa-train-6582", "doc": "check the number of cores in a computer python", "code": "def _num_cpus_darwin():\n    \"\"\"Return the number of active CPUs on a Darwin system.\"\"\"\n    p = subprocess.Popen(['sysctl','-n','hw.ncpu'],stdout=subprocess.PIPE)\n    return p.stdout.read()", "code_tokens": "def _num_cpus_darwin ( ) : p = subprocess . Popen ( [ 'sysctl' , '-n' , 'hw.ncpu' ] , stdout = subprocess . PIPE ) return p . stdout . read ( )", "docstring_tokens": "Return the number of active CPUs on a Darwin system .", "label": 0}, {"idx": "cosqa-train-6583", "doc": "python extract url domain", "code": "def parse_domain(url):\n    \"\"\" parse the domain from the url \"\"\"\n    domain_match = lib.DOMAIN_REGEX.match(url)\n    if domain_match:\n        return domain_match.group()", "code_tokens": "def parse_domain ( url ) : domain_match = lib . DOMAIN_REGEX . match ( url ) if domain_match : return domain_match . group ( )", "docstring_tokens": "parse the domain from the url", "label": 0}, {"idx": "cosqa-train-6584", "doc": "check the type of a str python", "code": "def isString(s):\n    \"\"\"Convenience method that works with all 2.x versions of Python\n    to determine whether or not something is stringlike.\"\"\"\n    try:\n        return isinstance(s, unicode) or isinstance(s, basestring)\n    except NameError:\n        return isinstance(s, str)", "code_tokens": "def isString ( s ) : try : return isinstance ( s , unicode ) or isinstance ( s , basestring ) except NameError : return isinstance ( s , str )", "docstring_tokens": "Convenience method that works with all 2 . x versions of Python to determine whether or not something is stringlike .", "label": 1}, {"idx": "cosqa-train-6585", "doc": "python extract zip path too long", "code": "def _relpath(name):\n    \"\"\"\n    Strip absolute components from path.\n    Inspired from zipfile.write().\n    \"\"\"\n    return os.path.normpath(os.path.splitdrive(name)[1]).lstrip(_allsep)", "code_tokens": "def _relpath ( name ) : return os . path . normpath ( os . path . splitdrive ( name ) [ 1 ] ) . lstrip ( _allsep )", "docstring_tokens": "Strip absolute components from path . Inspired from zipfile . write () .", "label": 0}, {"idx": "cosqa-train-6586", "doc": "check variable type in python as double", "code": "def contains_geometric_info(var):\n    \"\"\" Check whether the passed variable is a tuple with two floats or integers \"\"\"\n    return isinstance(var, tuple) and len(var) == 2 and all(isinstance(val, (int, float)) for val in var)", "code_tokens": "def contains_geometric_info ( var ) : return isinstance ( var , tuple ) and len ( var ) == 2 and all ( isinstance ( val , ( int , float ) ) for val in var )", "docstring_tokens": "Check whether the passed variable is a tuple with two floats or integers", "label": 1}, {"idx": "cosqa-train-6587", "doc": "python fabric verbose logging", "code": "def logv(msg, *args, **kwargs):\n    \"\"\"\n    Print out a log message, only if verbose mode.\n    \"\"\"\n    if settings.VERBOSE:\n        log(msg, *args, **kwargs)", "code_tokens": "def logv ( msg , * args , * * kwargs ) : if settings . VERBOSE : log ( msg , * args , * * kwargs )", "docstring_tokens": "Print out a log message only if verbose mode .", "label": 1}, {"idx": "cosqa-train-6588", "doc": "check vert in 2d list python", "code": "def _rectangular(n):\n    \"\"\"Checks to see if a 2D list is a valid 2D matrix\"\"\"\n    for i in n:\n        if len(i) != len(n[0]):\n            return False\n    return True", "code_tokens": "def _rectangular ( n ) : for i in n : if len ( i ) != len ( n [ 0 ] ) : return False return True", "docstring_tokens": "Checks to see if a 2D list is a valid 2D matrix", "label": 0}, {"idx": "cosqa-train-6589", "doc": "python factorials using n!", "code": "def computeFactorial(n):\n    \"\"\"\n    computes factorial of n\n    \"\"\"\n    sleep_walk(10)\n    ret = 1\n    for i in range(n):\n        ret = ret * (i + 1)\n    return ret", "code_tokens": "def computeFactorial ( n ) : sleep_walk ( 10 ) ret = 1 for i in range ( n ) : ret = ret * ( i + 1 ) return ret", "docstring_tokens": "computes factorial of n", "label": 1}, {"idx": "cosqa-train-6590", "doc": "check whether a string match a regex in python", "code": "def match(string, patterns):\n    \"\"\"Given a string return true if it matches the supplied list of\n    patterns.\n\n    Parameters\n    ----------\n    string : str\n        The string to be matched.\n    patterns : None or [pattern, ...]\n        The series of regular expressions to attempt to match.\n    \"\"\"\n    if patterns is None:\n        return True\n    else:\n        return any(re.match(pattern, string)\n                   for pattern in patterns)", "code_tokens": "def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )", "docstring_tokens": "Given a string return true if it matches the supplied list of patterns .", "label": 1}, {"idx": "cosqa-train-6591", "doc": "python faled to get appdata path", "code": "def data_directory():\n    \"\"\"Return the absolute path to the directory containing the package data.\"\"\"\n    package_directory = os.path.abspath(os.path.dirname(__file__))\n    return os.path.join(package_directory, \"data\")", "code_tokens": "def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , \"data\" )", "docstring_tokens": "Return the absolute path to the directory containing the package data .", "label": 0}, {"idx": "cosqa-train-6592", "doc": "check whether input is integer or not python", "code": "def is_int_type(val):\n    \"\"\"Return True if `val` is of integer type.\"\"\"\n    try:               # Python 2\n        return isinstance(val, (int, long))\n    except NameError:  # Python 3\n        return isinstance(val, int)", "code_tokens": "def is_int_type ( val ) : try : # Python 2 return isinstance ( val , ( int , long ) ) except NameError : # Python 3 return isinstance ( val , int )", "docstring_tokens": "Return True if val is of integer type .", "label": 0}, {"idx": "cosqa-train-6593", "doc": "python fast way to get random sample from list", "code": "def get_randomized_guid_sample(self, item_count):\n        \"\"\" Fetch a subset of randomzied GUIDs from the whitelist \"\"\"\n        dataset = self.get_whitelist()\n        random.shuffle(dataset)\n        return dataset[:item_count]", "code_tokens": "def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]", "docstring_tokens": "Fetch a subset of randomzied GUIDs from the whitelist", "label": 1}, {"idx": "cosqa-train-6594", "doc": "check whether two images is same or not python", "code": "def is_same_shape(self, other_im, check_channels=False):\n        \"\"\" Checks if two images have the same height and width (and optionally channels).\n\n        Parameters\n        ----------\n        other_im : :obj:`Image`\n            image to compare\n        check_channels : bool\n            whether or not to check equality of the channels\n\n        Returns\n        -------\n        bool\n            True if the images are the same shape, False otherwise\n        \"\"\"\n        if self.height == other_im.height and self.width == other_im.width:\n            if check_channels and self.channels != other_im.channels:\n                return False\n            return True\n        return False", "code_tokens": "def is_same_shape ( self , other_im , check_channels = False ) : if self . height == other_im . height and self . width == other_im . width : if check_channels and self . channels != other_im . channels : return False return True return False", "docstring_tokens": "Checks if two images have the same height and width ( and optionally channels ) .", "label": 0}, {"idx": "cosqa-train-6595", "doc": "python fastest way to filter images", "code": "def filter_greys_using_image(image, target):\n    \"\"\"Filter out any values in target not in image\n\n    :param image: image containing values to appear in filtered image\n    :param target: the image to filter\n    :rtype: 2d  :class:`numpy.ndarray` containing only value in image\n        and with the same dimensions as target\n\n    \"\"\"\n    maskbase = numpy.array(range(256), dtype=numpy.uint8)\n    mask = numpy.where(numpy.in1d(maskbase, numpy.unique(image)), maskbase, 0)\n    return mask[target]", "code_tokens": "def filter_greys_using_image ( image , target ) : maskbase = numpy . array ( range ( 256 ) , dtype = numpy . uint8 ) mask = numpy . where ( numpy . in1d ( maskbase , numpy . unique ( image ) ) , maskbase , 0 ) return mask [ target ]", "docstring_tokens": "Filter out any values in target not in image : param image : image containing values to appear in filtered image : param target : the image to filter : rtype : 2d : class : numpy . ndarray containing only value in image and with the same dimensions as target", "label": 0}, {"idx": "cosqa-train-6596", "doc": "checking a url code in python", "code": "def get_url_nofollow(url):\n\t\"\"\" \n\tfunction to get return code of a url\n\n\tCredits: http://blog.jasonantman.com/2013/06/python-script-to-check-a-list-of-urls-for-return-code-and-final-return-code-if-redirected/\n\t\"\"\"\n\ttry:\n\t\tresponse = urlopen(url)\n\t\tcode = response.getcode()\n\t\treturn code\n\texcept HTTPError as e:\n\t\treturn e.code\n\texcept:\n\t\treturn 0", "code_tokens": "def get_url_nofollow ( url ) : try : response = urlopen ( url ) code = response . getcode ( ) return code except HTTPError as e : return e . code except : return 0", "docstring_tokens": "function to get return code of a url", "label": 0}, {"idx": "cosqa-train-6597", "doc": "python fetch file from remote server", "code": "def get_remote_content(filepath):\n        \"\"\" A handy wrapper to get a remote file content \"\"\"\n        with hide('running'):\n            temp = BytesIO()\n            get(filepath, temp)\n            content = temp.getvalue().decode('utf-8')\n        return content.strip()", "code_tokens": "def get_remote_content ( filepath ) : with hide ( 'running' ) : temp = BytesIO ( ) get ( filepath , temp ) content = temp . getvalue ( ) . decode ( 'utf-8' ) return content . strip ( )", "docstring_tokens": "A handy wrapper to get a remote file content", "label": 0}, {"idx": "cosqa-train-6598", "doc": "checking if variable is a number type in python", "code": "def numberp(v):\n    \"\"\"Return true iff 'v' is a number.\"\"\"\n    return (not(isinstance(v, bool)) and\n            (isinstance(v, int) or isinstance(v, float)))", "code_tokens": "def numberp ( v ) : return ( not ( isinstance ( v , bool ) ) and ( isinstance ( v , int ) or isinstance ( v , float ) ) )", "docstring_tokens": "Return true iff v is a number .", "label": 1}, {"idx": "cosqa-train-6599", "doc": "python fft is giving me fraction frequencies and i want integer frequencies", "code": "def fft_freqs(n_fft, fs):\n    \"\"\"Return frequencies for DFT\n\n    Parameters\n    ----------\n    n_fft : int\n        Number of points in the FFT.\n    fs : float\n        The sampling rate.\n    \"\"\"\n    return np.arange(0, (n_fft // 2 + 1)) / float(n_fft) * float(fs)", "code_tokens": "def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )", "docstring_tokens": "Return frequencies for DFT", "label": 0}, {"idx": "cosqa-train-6600", "doc": "checking objects for equality python", "code": "def __eq__(self, other):\n        \"\"\"Determine if two objects are equal.\"\"\"\n        return isinstance(other, self.__class__) \\\n            and self._freeze() == other._freeze()", "code_tokens": "def __eq__ ( self , other ) : return isinstance ( other , self . __class__ ) and self . _freeze ( ) == other . _freeze ( )", "docstring_tokens": "Determine if two objects are equal .", "label": 1}, {"idx": "cosqa-train-6601", "doc": "python fft takes long time", "code": "def stft_magnitude(signal, fft_length,\n                   hop_length=None,\n                   window_length=None):\n  \"\"\"Calculate the short-time Fourier transform magnitude.\n\n  Args:\n    signal: 1D np.array of the input time-domain signal.\n    fft_length: Size of the FFT to apply.\n    hop_length: Advance (in samples) between each frame passed to FFT.\n    window_length: Length of each block of samples to pass to FFT.\n\n  Returns:\n    2D np.array where each row contains the magnitudes of the fft_length/2+1\n    unique values of the FFT for the corresponding frame of input samples.\n  \"\"\"\n  frames = frame(signal, window_length, hop_length)\n  # Apply frame window to each frame. We use a periodic Hann (cosine of period\n  # window_length) instead of the symmetric Hann of np.hanning (period\n  # window_length-1).\n  window = periodic_hann(window_length)\n  windowed_frames = frames * window\n  return np.abs(np.fft.rfft(windowed_frames, int(fft_length)))", "code_tokens": "def stft_magnitude ( signal , fft_length , hop_length = None , window_length = None ) : frames = frame ( signal , window_length , hop_length ) # Apply frame window to each frame. We use a periodic Hann (cosine of period # window_length) instead of the symmetric Hann of np.hanning (period # window_length-1). window = periodic_hann ( window_length ) windowed_frames = frames * window return np . abs ( np . fft . rfft ( windowed_frames , int ( fft_length ) ) )", "docstring_tokens": "Calculate the short - time Fourier transform magnitude .", "label": 1}, {"idx": "cosqa-train-6602", "doc": "checking the memory occupied by an object in python", "code": "def memory_used(self):\n        \"\"\"To know the allocated memory at function termination.\n\n        ..versionadded:: 4.1\n\n        This property might return None if the function is still running.\n\n        This function should help to show memory leaks or ram greedy code.\n        \"\"\"\n        if self._end_memory:\n            memory_used = self._end_memory - self._start_memory\n            return memory_used\n        else:\n            return None", "code_tokens": "def memory_used ( self ) : if self . _end_memory : memory_used = self . _end_memory - self . _start_memory return memory_used else : return None", "docstring_tokens": "To know the allocated memory at function termination .", "label": 0}, {"idx": "cosqa-train-6603", "doc": "python fft with non constant sampling time", "code": "def fft_freqs(n_fft, fs):\n    \"\"\"Return frequencies for DFT\n\n    Parameters\n    ----------\n    n_fft : int\n        Number of points in the FFT.\n    fs : float\n        The sampling rate.\n    \"\"\"\n    return np.arange(0, (n_fft // 2 + 1)) / float(n_fft) * float(fs)", "code_tokens": "def fft_freqs ( n_fft , fs ) : return np . arange ( 0 , ( n_fft // 2 + 1 ) ) / float ( n_fft ) * float ( fs )", "docstring_tokens": "Return frequencies for DFT", "label": 1}, {"idx": "cosqa-train-6604", "doc": "chek if type list python", "code": "def is_iter_non_string(obj):\n    \"\"\"test if object is a list or tuple\"\"\"\n    if isinstance(obj, list) or isinstance(obj, tuple):\n        return True\n    return False", "code_tokens": "def is_iter_non_string ( obj ) : if isinstance ( obj , list ) or isinstance ( obj , tuple ) : return True return False", "docstring_tokens": "test if object is a list or tuple", "label": 1}, {"idx": "cosqa-train-6605", "doc": "python fftt low pass filter", "code": "def fft_bandpassfilter(data, fs, lowcut, highcut):\n    \"\"\"\n    http://www.swharden.com/blog/2009-01-21-signal-filtering-with-python/#comment-16801\n    \"\"\"\n    fft = np.fft.fft(data)\n    # n = len(data)\n    # timestep = 1.0 / fs\n    # freq = np.fft.fftfreq(n, d=timestep)\n    bp = fft.copy()\n\n    # Zero out fft coefficients\n    # bp[10:-10] = 0\n\n    # Normalise\n    # bp *= real(fft.dot(fft))/real(bp.dot(bp))\n\n    bp *= fft.dot(fft) / bp.dot(bp)\n\n    # must multipy by 2 to get the correct amplitude\n    ibp = 12 * np.fft.ifft(bp)\n    return ibp", "code_tokens": "def fft_bandpassfilter ( data , fs , lowcut , highcut ) : fft = np . fft . fft ( data ) # n = len(data) # timestep = 1.0 / fs # freq = np.fft.fftfreq(n, d=timestep) bp = fft . copy ( ) # Zero out fft coefficients # bp[10:-10] = 0 # Normalise # bp *= real(fft.dot(fft))/real(bp.dot(bp)) bp *= fft . dot ( fft ) / bp . dot ( bp ) # must multipy by 2 to get the correct amplitude ibp = 12 * np . fft . ifft ( bp ) return ibp", "docstring_tokens": "http : // www . swharden . com / blog / 2009 - 01 - 21 - signal - filtering - with - python / #comment - 16801", "label": 1}, {"idx": "cosqa-train-6606", "doc": "choose 75 percentile of a list python", "code": "def percentile(values, k):\n    \"\"\"Find the percentile of a list of values.\n\n    :param list values: The list of values to find the percentile of\n    :param int k: The percentile to find\n    :rtype: float or int\n\n    \"\"\"\n    if not values:\n        return None\n    values.sort()\n    index = (len(values) * (float(k) / 100)) - 1\n    return values[int(math.ceil(index))]", "code_tokens": "def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]", "docstring_tokens": "Find the percentile of a list of values .", "label": 0}, {"idx": "cosqa-train-6607", "doc": "python file auto flush", "code": "def file_writelines_flush_sync(path, lines):\n    \"\"\"\n    Fill file at @path with @lines then flush all buffers\n    (Python and system buffers)\n    \"\"\"\n    fp = open(path, 'w')\n    try:\n        fp.writelines(lines)\n        flush_sync_file_object(fp)\n    finally:\n        fp.close()", "code_tokens": "def file_writelines_flush_sync ( path , lines ) : fp = open ( path , 'w' ) try : fp . writelines ( lines ) flush_sync_file_object ( fp ) finally : fp . close ( )", "docstring_tokens": "Fill file at", "label": 1}, {"idx": "cosqa-train-6608", "doc": "clean illegal characters in text python code", "code": "def drop_bad_characters(text):\n    \"\"\"Takes a text and drops all non-printable and non-ascii characters and\n    also any whitespace characters that aren't space.\n\n    :arg str text: the text to fix\n\n    :returns: text with all bad characters dropped\n\n    \"\"\"\n    # Strip all non-ascii and non-printable characters\n    text = ''.join([c for c in text if c in ALLOWED_CHARS])\n    return text", "code_tokens": "def drop_bad_characters ( text ) : # Strip all non-ascii and non-printable characters text = '' . join ( [ c for c in text if c in ALLOWED_CHARS ] ) return text", "docstring_tokens": "Takes a text and drops all non - printable and non - ascii characters and also any whitespace characters that aren t space .", "label": 0}, {"idx": "cosqa-train-6609", "doc": "python file check if writable", "code": "def is_writable_by_others(filename):\n    \"\"\"Check if file or directory is world writable.\"\"\"\n    mode = os.stat(filename)[stat.ST_MODE]\n    return mode & stat.S_IWOTH", "code_tokens": "def is_writable_by_others ( filename ) : mode = os . stat ( filename ) [ stat . ST_MODE ] return mode & stat . S_IWOTH", "docstring_tokens": "Check if file or directory is world writable .", "label": 1}, {"idx": "cosqa-train-6610", "doc": "clear a canvas python", "code": "def _clear(self):\n        \"\"\"\n        Helper that clears the composition.\n        \"\"\"\n        draw = ImageDraw.Draw(self._background_image)\n        draw.rectangle(self._device.bounding_box,\n                       fill=\"black\")\n        del draw", "code_tokens": "def _clear ( self ) : draw = ImageDraw . Draw ( self . _background_image ) draw . rectangle ( self . _device . bounding_box , fill = \"black\" ) del draw", "docstring_tokens": "Helper that clears the composition .", "label": 1}, {"idx": "cosqa-train-6611", "doc": "python file line iter", "code": "def txt_line_iterator(path):\n  \"\"\"Iterate through lines of file.\"\"\"\n  with tf.gfile.Open(path) as f:\n    for line in f:\n      yield line.strip()", "code_tokens": "def txt_line_iterator ( path ) : with tf . gfile . Open ( path ) as f : for line in f : yield line . strip ( )", "docstring_tokens": "Iterate through lines of file .", "label": 0}, {"idx": "cosqa-train-6612", "doc": "clear all stored variable in python", "code": "def Flush(self):\n    \"\"\"Flush all items from cache.\"\"\"\n    while self._age:\n      node = self._age.PopLeft()\n      self.KillObject(node.data)\n\n    self._hash = dict()", "code_tokens": "def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )", "docstring_tokens": "Flush all items from cache .", "label": 0}, {"idx": "cosqa-train-6613", "doc": "python file open flag", "code": "def open_file(file, mode):\n\t\"\"\"Open a file.\n\n\t:arg file: file-like or path-like object.\n\t:arg str mode: ``mode`` argument for :func:`open`.\n\t\"\"\"\n\tif hasattr(file, \"read\"):\n\t\treturn file\n\tif hasattr(file, \"open\"):\n\t\treturn file.open(mode)\n\treturn open(file, mode)", "code_tokens": "def open_file ( file , mode ) : if hasattr ( file , \"read\" ) : return file if hasattr ( file , \"open\" ) : return file . open ( mode ) return open ( file , mode )", "docstring_tokens": "Open a file .", "label": 0}, {"idx": "cosqa-train-6614", "doc": "clear all variable python", "code": "def clear_globals_reload_modules(self):\n        \"\"\"Clears globals and reloads modules\"\"\"\n\n        self.code_array.clear_globals()\n        self.code_array.reload_modules()\n\n        # Clear result cache\n        self.code_array.result_cache.clear()", "code_tokens": "def clear_globals_reload_modules ( self ) : self . code_array . clear_globals ( ) self . code_array . reload_modules ( ) # Clear result cache self . code_array . result_cache . clear ( )", "docstring_tokens": "Clears globals and reloads modules", "label": 0}, {"idx": "cosqa-train-6615", "doc": "python file pointer reset back to begining of file", "code": "def rewindbody(self):\n        \"\"\"Rewind the file to the start of the body (if seekable).\"\"\"\n        if not self.seekable:\n            raise IOError, \"unseekable file\"\n        self.fp.seek(self.startofbody)", "code_tokens": "def rewindbody ( self ) : if not self . seekable : raise IOError , \"unseekable file\" self . fp . seek ( self . startofbody )", "docstring_tokens": "Rewind the file to the start of the body ( if seekable ) .", "label": 0}, {"idx": "cosqa-train-6616", "doc": "clearing python memory during a for loop", "code": "def Flush(self):\n    \"\"\"Flush all items from cache.\"\"\"\n    while self._age:\n      node = self._age.PopLeft()\n      self.KillObject(node.data)\n\n    self._hash = dict()", "code_tokens": "def Flush ( self ) : while self . _age : node = self . _age . PopLeft ( ) self . KillObject ( node . data ) self . _hash = dict ( )", "docstring_tokens": "Flush all items from cache .", "label": 1}, {"idx": "cosqa-train-6617", "doc": "python filename fromm url", "code": "def get_file_name(url):\n  \"\"\"Returns file name of file at given url.\"\"\"\n  return os.path.basename(urllib.parse.urlparse(url).path) or 'unknown_name'", "code_tokens": "def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'", "docstring_tokens": "Returns file name of file at given url .", "label": 0}, {"idx": "cosqa-train-6618", "doc": "close all figures python", "code": "def close_all_but_this(self):\n        \"\"\"Close all files but the current one\"\"\"\n        self.close_all_right()\n        for i in range(0, self.get_stack_count()-1  ):\n            self.close_file(0)", "code_tokens": "def close_all_but_this ( self ) : self . close_all_right ( ) for i in range ( 0 , self . get_stack_count ( ) - 1 ) : self . close_file ( 0 )", "docstring_tokens": "Close all files but the current one", "label": 0}, {"idx": "cosqa-train-6619", "doc": "python fill an array with a list", "code": "def _fill_array_from_list(the_list, the_array):\n        \"\"\"Fill an `array` from a `list`\"\"\"\n        for i, val in enumerate(the_list):\n            the_array[i] = val\n        return the_array", "code_tokens": "def _fill_array_from_list ( the_list , the_array ) : for i , val in enumerate ( the_list ) : the_array [ i ] = val return the_array", "docstring_tokens": "Fill an array from a list", "label": 0}, {"idx": "cosqa-train-6620", "doc": "close stdin subprocess python", "code": "def _finish(self):\n        \"\"\"\n        Closes and waits for subprocess to exit.\n        \"\"\"\n        if self._process.returncode is None:\n            self._process.stdin.flush()\n            self._process.stdin.close()\n            self._process.wait()\n            self.closed = True", "code_tokens": "def _finish ( self ) : if self . _process . returncode is None : self . _process . stdin . flush ( ) self . _process . stdin . close ( ) self . _process . wait ( ) self . closed = True", "docstring_tokens": "Closes and waits for subprocess to exit .", "label": 1}, {"idx": "cosqa-train-6621", "doc": "python fillna with other columns values", "code": "def _maybe_fill(arr, fill_value=np.nan):\n    \"\"\"\n    if we have a compatible fill_value and arr dtype, then fill\n    \"\"\"\n    if _isna_compat(arr, fill_value):\n        arr.fill(fill_value)\n    return arr", "code_tokens": "def _maybe_fill ( arr , fill_value = np . nan ) : if _isna_compat ( arr , fill_value ) : arr . fill ( fill_value ) return arr", "docstring_tokens": "if we have a compatible fill_value and arr dtype then fill", "label": 1}, {"idx": "cosqa-train-6622", "doc": "column stack every item in a list of lists python", "code": "def column_stack_2d(data):\n    \"\"\"Perform column-stacking on a list of 2d data blocks.\"\"\"\n    return list(list(itt.chain.from_iterable(_)) for _ in zip(*data))", "code_tokens": "def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )", "docstring_tokens": "Perform column - stacking on a list of 2d data blocks .", "label": 1}, {"idx": "cosqa-train-6623", "doc": "python filter data in a data frame", "code": "def apply_filters(df, filters):\n        \"\"\"Basic filtering for a dataframe.\"\"\"\n        idx = pd.Series([True]*df.shape[0])\n        for k, v in list(filters.items()):\n            if k not in df.columns:\n                continue\n            idx &= (df[k] == v)\n\n        return df.loc[idx]", "code_tokens": "def apply_filters ( df , filters ) : idx = pd . Series ( [ True ] * df . shape [ 0 ] ) for k , v in list ( filters . items ( ) ) : if k not in df . columns : continue idx &= ( df [ k ] == v ) return df . loc [ idx ]", "docstring_tokens": "Basic filtering for a dataframe .", "label": 0}, {"idx": "cosqa-train-6624", "doc": "combine list elements python as one item", "code": "def combinations(l):\n    \"\"\"Pure-Python implementation of itertools.combinations(l, 2).\"\"\"\n    result = []\n    for x in xrange(len(l) - 1):\n        ls = l[x + 1:]\n        for y in ls:\n            result.append((l[x], y))\n    return result", "code_tokens": "def combinations ( l ) : result = [ ] for x in xrange ( len ( l ) - 1 ) : ls = l [ x + 1 : ] for y in ls : result . append ( ( l [ x ] , y ) ) return result", "docstring_tokens": "Pure - Python implementation of itertools . combinations ( l 2 ) .", "label": 1}, {"idx": "cosqa-train-6625", "doc": "python filter lambda return none if empty", "code": "def BROADCAST_FILTER_NOT(func):\n        \"\"\"\n        Composes the passed filters into an and-joined filter.\n        \"\"\"\n        return lambda u, command, *args, **kwargs: not func(u, command, *args, **kwargs)", "code_tokens": "def BROADCAST_FILTER_NOT ( func ) : return lambda u , command , * args , * * kwargs : not func ( u , command , * args , * * kwargs )", "docstring_tokens": "Composes the passed filters into an and - joined filter .", "label": 1}, {"idx": "cosqa-train-6626", "doc": "compare filename in python regex", "code": "def file_matches(filename, patterns):\n    \"\"\"Does this filename match any of the patterns?\"\"\"\n    return any(fnmatch.fnmatch(filename, pat) for pat in patterns)", "code_tokens": "def file_matches ( filename , patterns ) : return any ( fnmatch . fnmatch ( filename , pat ) for pat in patterns )", "docstring_tokens": "Does this filename match any of the patterns?", "label": 1}, {"idx": "cosqa-train-6627", "doc": "python filter lowpass minmum cutoff frequency", "code": "def fft_bandpassfilter(data, fs, lowcut, highcut):\n    \"\"\"\n    http://www.swharden.com/blog/2009-01-21-signal-filtering-with-python/#comment-16801\n    \"\"\"\n    fft = np.fft.fft(data)\n    # n = len(data)\n    # timestep = 1.0 / fs\n    # freq = np.fft.fftfreq(n, d=timestep)\n    bp = fft.copy()\n\n    # Zero out fft coefficients\n    # bp[10:-10] = 0\n\n    # Normalise\n    # bp *= real(fft.dot(fft))/real(bp.dot(bp))\n\n    bp *= fft.dot(fft) / bp.dot(bp)\n\n    # must multipy by 2 to get the correct amplitude\n    ibp = 12 * np.fft.ifft(bp)\n    return ibp", "code_tokens": "def fft_bandpassfilter ( data , fs , lowcut , highcut ) : fft = np . fft . fft ( data ) # n = len(data) # timestep = 1.0 / fs # freq = np.fft.fftfreq(n, d=timestep) bp = fft . copy ( ) # Zero out fft coefficients # bp[10:-10] = 0 # Normalise # bp *= real(fft.dot(fft))/real(bp.dot(bp)) bp *= fft . dot ( fft ) / bp . dot ( bp ) # must multipy by 2 to get the correct amplitude ibp = 12 * np . fft . ifft ( bp ) return ibp", "docstring_tokens": "http : // www . swharden . com / blog / 2009 - 01 - 21 - signal - filtering - with - python / #comment - 16801", "label": 1}, {"idx": "cosqa-train-6628", "doc": "compare image similarity python", "code": "def _sim_fill(r1, r2, imsize):\n    \"\"\"\n        calculate the fill similarity over the image\n    \"\"\"\n    bbsize = (\n        (max(r1[\"max_x\"], r2[\"max_x\"]) - min(r1[\"min_x\"], r2[\"min_x\"]))\n        * (max(r1[\"max_y\"], r2[\"max_y\"]) - min(r1[\"min_y\"], r2[\"min_y\"]))\n    )\n    return 1.0 - (bbsize - r1[\"size\"] - r2[\"size\"]) / imsize", "code_tokens": "def _sim_fill ( r1 , r2 , imsize ) : bbsize = ( ( max ( r1 [ \"max_x\" ] , r2 [ \"max_x\" ] ) - min ( r1 [ \"min_x\" ] , r2 [ \"min_x\" ] ) ) * ( max ( r1 [ \"max_y\" ] , r2 [ \"max_y\" ] ) - min ( r1 [ \"min_y\" ] , r2 [ \"min_y\" ] ) ) ) return 1.0 - ( bbsize - r1 [ \"size\" ] - r2 [ \"size\" ] ) / imsize", "docstring_tokens": "calculate the fill similarity over the image", "label": 0}, {"idx": "cosqa-train-6629", "doc": "python fitting 2d function", "code": "def apply_fit(xy,coeffs):\n    \"\"\" Apply the coefficients from a linear fit to\n        an array of x,y positions.\n\n        The coeffs come from the 'coeffs' member of the\n        'fit_arrays()' output.\n    \"\"\"\n    x_new = coeffs[0][2] + coeffs[0][0]*xy[:,0] + coeffs[0][1]*xy[:,1]\n    y_new = coeffs[1][2] + coeffs[1][0]*xy[:,0] + coeffs[1][1]*xy[:,1]\n\n    return x_new,y_new", "code_tokens": "def apply_fit ( xy , coeffs ) : x_new = coeffs [ 0 ] [ 2 ] + coeffs [ 0 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 0 ] [ 1 ] * xy [ : , 1 ] y_new = coeffs [ 1 ] [ 2 ] + coeffs [ 1 ] [ 0 ] * xy [ : , 0 ] + coeffs [ 1 ] [ 1 ] * xy [ : , 1 ] return x_new , y_new", "docstring_tokens": "Apply the coefficients from a linear fit to an array of x y positions .", "label": 0}, {"idx": "cosqa-train-6630", "doc": "compare python string using wildcard *", "code": "def match(string, patterns):\n    \"\"\"Given a string return true if it matches the supplied list of\n    patterns.\n\n    Parameters\n    ----------\n    string : str\n        The string to be matched.\n    patterns : None or [pattern, ...]\n        The series of regular expressions to attempt to match.\n    \"\"\"\n    if patterns is None:\n        return True\n    else:\n        return any(re.match(pattern, string)\n                   for pattern in patterns)", "code_tokens": "def match ( string , patterns ) : if patterns is None : return True else : return any ( re . match ( pattern , string ) for pattern in patterns )", "docstring_tokens": "Given a string return true if it matches the supplied list of patterns .", "label": 1}, {"idx": "cosqa-train-6631", "doc": "python flake8 windows crushed", "code": "def lint(args):\n    \"\"\"Run lint checks using flake8.\"\"\"\n    application = get_current_application()\n    if not args:\n        args = [application.name, 'tests']\n    args = ['flake8'] + list(args)\n    run.main(args, standalone_mode=False)", "code_tokens": "def lint ( args ) : application = get_current_application ( ) if not args : args = [ application . name , 'tests' ] args = [ 'flake8' ] + list ( args ) run . main ( args , standalone_mode = False )", "docstring_tokens": "Run lint checks using flake8 .", "label": 0}, {"idx": "cosqa-train-6632", "doc": "compare similarity between 2 images python", "code": "def _sim_fill(r1, r2, imsize):\n    \"\"\"\n        calculate the fill similarity over the image\n    \"\"\"\n    bbsize = (\n        (max(r1[\"max_x\"], r2[\"max_x\"]) - min(r1[\"min_x\"], r2[\"min_x\"]))\n        * (max(r1[\"max_y\"], r2[\"max_y\"]) - min(r1[\"min_y\"], r2[\"min_y\"]))\n    )\n    return 1.0 - (bbsize - r1[\"size\"] - r2[\"size\"]) / imsize", "code_tokens": "def _sim_fill ( r1 , r2 , imsize ) : bbsize = ( ( max ( r1 [ \"max_x\" ] , r2 [ \"max_x\" ] ) - min ( r1 [ \"min_x\" ] , r2 [ \"min_x\" ] ) ) * ( max ( r1 [ \"max_y\" ] , r2 [ \"max_y\" ] ) - min ( r1 [ \"min_y\" ] , r2 [ \"min_y\" ] ) ) ) return 1.0 - ( bbsize - r1 [ \"size\" ] - r2 [ \"size\" ] ) / imsize", "docstring_tokens": "calculate the fill similarity over the image", "label": 0}, {"idx": "cosqa-train-6633", "doc": "python flask annotated function", "code": "def docannotate(func):\n    \"\"\"Annotate a function using information from its docstring.\n\n    The annotation actually happens at the time the function is first called\n    to improve startup time.  For this function to work, the docstring must be\n    formatted correctly.  You should use the typedargs pylint plugin to make\n    sure there are no errors in the docstring.\n    \"\"\"\n\n    func = annotated(func)\n    func.metadata.load_from_doc = True\n\n    if func.decorated:\n        return func\n\n    func.decorated = True\n    return decorate(func, _check_and_execute)", "code_tokens": "def docannotate ( func ) : func = annotated ( func ) func . metadata . load_from_doc = True if func . decorated : return func func . decorated = True return decorate ( func , _check_and_execute )", "docstring_tokens": "Annotate a function using information from its docstring .", "label": 0}, {"idx": "cosqa-train-6634", "doc": "compare with every element in set python3", "code": "def unique(transactions):\n    \"\"\" Remove any duplicate entries. \"\"\"\n    seen = set()\n    # TODO: Handle comments\n    return [x for x in transactions if not (x in seen or seen.add(x))]", "code_tokens": "def unique ( transactions ) : seen = set ( ) # TODO: Handle comments return [ x for x in transactions if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Remove any duplicate entries .", "label": 0}, {"idx": "cosqa-train-6635", "doc": "python flask api in multi direcotry", "code": "def initialize_api(flask_app):\n    \"\"\"Initialize an API.\"\"\"\n    if not flask_restplus:\n        return\n\n    api = flask_restplus.Api(version=\"1.0\", title=\"My Example API\")\n    api.add_resource(HelloWorld, \"/hello\")\n\n    blueprint = flask.Blueprint(\"api\", __name__, url_prefix=\"/api\")\n    api.init_app(blueprint)\n    flask_app.register_blueprint(blueprint)", "code_tokens": "def initialize_api ( flask_app ) : if not flask_restplus : return api = flask_restplus . Api ( version = \"1.0\" , title = \"My Example API\" ) api . add_resource ( HelloWorld , \"/hello\" ) blueprint = flask . Blueprint ( \"api\" , __name__ , url_prefix = \"/api\" ) api . init_app ( blueprint ) flask_app . register_blueprint ( blueprint )", "docstring_tokens": "Initialize an API .", "label": 1}, {"idx": "cosqa-train-6636", "doc": "comparing matrices in python 3", "code": "def converged(matrix1, matrix2):\n    \"\"\"\n    Check for convergence by determining if \n    matrix1 and matrix2 are approximately equal.\n    \n    :param matrix1: The matrix to compare with matrix2\n    :param matrix2: The matrix to compare with matrix1\n    :returns: True if matrix1 and matrix2 approximately equal\n    \"\"\"\n    if isspmatrix(matrix1) or isspmatrix(matrix2):\n        return sparse_allclose(matrix1, matrix2)\n\n    return np.allclose(matrix1, matrix2)", "code_tokens": "def converged ( matrix1 , matrix2 ) : if isspmatrix ( matrix1 ) or isspmatrix ( matrix2 ) : return sparse_allclose ( matrix1 , matrix2 ) return np . allclose ( matrix1 , matrix2 )", "docstring_tokens": "Check for convergence by determining if matrix1 and matrix2 are approximately equal . : param matrix1 : The matrix to compare with matrix2 : param matrix2 : The matrix to compare with matrix1 : returns : True if matrix1 and matrix2 approximately equal", "label": 0}, {"idx": "cosqa-train-6637", "doc": "python flask auto refresh", "code": "def touch_project():\n    \"\"\"\n    Touches the project to trigger refreshing its cauldron.json state.\n    \"\"\"\n    r = Response()\n    project = cd.project.get_internal_project()\n\n    if project:\n        project.refresh()\n    else:\n        r.fail(\n            code='NO_PROJECT',\n            message='No open project to refresh'\n        )\n\n    return r.update(\n        sync_time=sync_status.get('time', 0)\n    ).flask_serialize()", "code_tokens": "def touch_project ( ) : r = Response ( ) project = cd . project . get_internal_project ( ) if project : project . refresh ( ) else : r . fail ( code = 'NO_PROJECT' , message = 'No open project to refresh' ) return r . update ( sync_time = sync_status . get ( 'time' , 0 ) ) . flask_serialize ( )", "docstring_tokens": "Touches the project to trigger refreshing its cauldron . json state .", "label": 1}, {"idx": "cosqa-train-6638", "doc": "comparing sets python with boolean and set", "code": "def isetdiff_flags(list1, list2):\n    \"\"\"\n    move to util_iter\n    \"\"\"\n    set2 = set(list2)\n    return (item not in set2 for item in list1)", "code_tokens": "def isetdiff_flags ( list1 , list2 ) : set2 = set ( list2 ) return ( item not in set2 for item in list1 )", "docstring_tokens": "move to util_iter", "label": 1}, {"idx": "cosqa-train-6639", "doc": "compile python code as a dll", "code": "def get_code(module):\n    \"\"\"\n    Compile and return a Module's code object.\n    \"\"\"\n    fp = open(module.path)\n    try:\n        return compile(fp.read(), str(module.name), 'exec')\n    finally:\n        fp.close()", "code_tokens": "def get_code ( module ) : fp = open ( module . path ) try : return compile ( fp . read ( ) , str ( module . name ) , 'exec' ) finally : fp . close ( )", "docstring_tokens": "Compile and return a Module s code object .", "label": 1}, {"idx": "cosqa-train-6640", "doc": "python flask change static folder", "code": "def staticdir():\n    \"\"\"Return the location of the static data directory.\"\"\"\n    root = os.path.abspath(os.path.dirname(__file__))\n    return os.path.join(root, \"static\")", "code_tokens": "def staticdir ( ) : root = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( root , \"static\" )", "docstring_tokens": "Return the location of the static data directory .", "label": 0}, {"idx": "cosqa-train-6641", "doc": "concatenate 2d arrays in python", "code": "def _concatenate_virtual_arrays(arrs, cols=None, scaling=None):\n    \"\"\"Return a virtual concatenate of several NumPy arrays.\"\"\"\n    return None if not len(arrs) else ConcatenatedArrays(arrs, cols,\n                                                         scaling=scaling)", "code_tokens": "def _concatenate_virtual_arrays ( arrs , cols = None , scaling = None ) : return None if not len ( arrs ) else ConcatenatedArrays ( arrs , cols , scaling = scaling )", "docstring_tokens": "Return a virtual concatenate of several NumPy arrays .", "label": 1}, {"idx": "cosqa-train-6642", "doc": "python flask config from file", "code": "def init_app(self, app):\n        \"\"\"Initialize Flask application.\"\"\"\n        app.config.from_pyfile('{0}.cfg'.format(app.name), silent=True)", "code_tokens": "def init_app ( self , app ) : app . config . from_pyfile ( '{0}.cfg' . format ( app . name ) , silent = True )", "docstring_tokens": "Initialize Flask application .", "label": 1}, {"idx": "cosqa-train-6643", "doc": "concatenate multidiminsional arrays python", "code": "def _concatenate_virtual_arrays(arrs, cols=None, scaling=None):\n    \"\"\"Return a virtual concatenate of several NumPy arrays.\"\"\"\n    return None if not len(arrs) else ConcatenatedArrays(arrs, cols,\n                                                         scaling=scaling)", "code_tokens": "def _concatenate_virtual_arrays ( arrs , cols = None , scaling = None ) : return None if not len ( arrs ) else ConcatenatedArrays ( arrs , cols , scaling = scaling )", "docstring_tokens": "Return a virtual concatenate of several NumPy arrays .", "label": 0}, {"idx": "cosqa-train-6644", "doc": "python flask don't display images outside of static", "code": "def serve_static(request, path, insecure=False, **kwargs):\n    \"\"\"Collect and serve static files.\n\n    This view serves up static files, much like Django's\n    :py:func:`~django.views.static.serve` view, with the addition that it\n    collects static files first (if enabled). This allows images, fonts, and\n    other assets to be served up without first loading a page using the\n    ``{% javascript %}`` or ``{% stylesheet %}`` template tags.\n\n    You can use this view by adding the following to any :file:`urls.py`::\n\n        urlpatterns += static('static/', view='pipeline.views.serve_static')\n    \"\"\"\n    # Follow the same logic Django uses for determining access to the\n    # static-serving view.\n    if not django_settings.DEBUG and not insecure:\n        raise ImproperlyConfigured(\"The staticfiles view can only be used in \"\n                                   \"debug mode or if the --insecure \"\n                                   \"option of 'runserver' is used\")\n\n    if not settings.PIPELINE_ENABLED and settings.PIPELINE_COLLECTOR_ENABLED:\n        # Collect only the requested file, in order to serve the result as\n        # fast as possible. This won't interfere with the template tags in any\n        # way, as those will still cause Django to collect all media.\n        default_collector.collect(request, files=[path])\n\n    return serve(request, path, document_root=django_settings.STATIC_ROOT,\n                 **kwargs)", "code_tokens": "def serve_static ( request , path , insecure = False , * * kwargs ) : # Follow the same logic Django uses for determining access to the # static-serving view. if not django_settings . DEBUG and not insecure : raise ImproperlyConfigured ( \"The staticfiles view can only be used in \" \"debug mode or if the --insecure \" \"option of 'runserver' is used\" ) if not settings . PIPELINE_ENABLED and settings . PIPELINE_COLLECTOR_ENABLED : # Collect only the requested file, in order to serve the result as # fast as possible. This won't interfere with the template tags in any # way, as those will still cause Django to collect all media. default_collector . collect ( request , files = [ path ] ) return serve ( request , path , document_root = django_settings . STATIC_ROOT , * * kwargs )", "docstring_tokens": "Collect and serve static files .", "label": 1}, {"idx": "cosqa-train-6645", "doc": "concatinate 2 functions in python", "code": "def generic_add(a, b):\n    \"\"\"Simple function to add two numbers\"\"\"\n    logger.debug('Called generic_add({}, {})'.format(a, b))\n    return a + b", "code_tokens": "def generic_add ( a , b ) : logger . debug ( 'Called generic_add({}, {})' . format ( a , b ) ) return a + b", "docstring_tokens": "Simple function to add two numbers", "label": 0}, {"idx": "cosqa-train-6646", "doc": "python flask form get", "code": "def parse_form(self, req, name, field):\n        \"\"\"Pull a form value from the request.\"\"\"\n        return get_value(req.body_arguments, name, field)", "code_tokens": "def parse_form ( self , req , name , field ) : return get_value ( req . body_arguments , name , field )", "docstring_tokens": "Pull a form value from the request .", "label": 1}, {"idx": "cosqa-train-6647", "doc": "configure python random state", "code": "def reseed_random(seed):\n    \"\"\"Reseed factory.fuzzy's random generator.\"\"\"\n    r = random.Random(seed)\n    random_internal_state = r.getstate()\n    set_random_state(random_internal_state)", "code_tokens": "def reseed_random ( seed ) : r = random . Random ( seed ) random_internal_state = r . getstate ( ) set_random_state ( random_internal_state )", "docstring_tokens": "Reseed factory . fuzzy s random generator .", "label": 1}, {"idx": "cosqa-train-6648", "doc": "python flask render a table", "code": "def html(header_rows):\n    \"\"\"\n    Convert a list of tuples describing a table into a HTML string\n    \"\"\"\n    name = 'table%d' % next(tablecounter)\n    return HtmlTable([map(str, row) for row in header_rows], name).render()", "code_tokens": "def html ( header_rows ) : name = 'table%d' % next ( tablecounter ) return HtmlTable ( [ map ( str , row ) for row in header_rows ] , name ) . render ( )", "docstring_tokens": "Convert a list of tuples describing a table into a HTML string", "label": 0}, {"idx": "cosqa-train-6649", "doc": "configuring python to use a proxy", "code": "def enable_proxy(self, host, port):\n        \"\"\"Enable a default web proxy\"\"\"\n\n        self.proxy = [host, _number(port)]\n        self.proxy_enabled = True", "code_tokens": "def enable_proxy ( self , host , port ) : self . proxy = [ host , _number ( port ) ] self . proxy_enabled = True", "docstring_tokens": "Enable a default web proxy", "label": 0}, {"idx": "cosqa-train-6650", "doc": "python flask routes add", "code": "def add_url_rule(self, route, endpoint, handler):\n        \"\"\"Add a new url route.\n\n        Args:\n            See flask.Flask.add_url_route().\n        \"\"\"\n        self.app.add_url_rule(route, endpoint, handler)", "code_tokens": "def add_url_rule ( self , route , endpoint , handler ) : self . app . add_url_rule ( route , endpoint , handler )", "docstring_tokens": "Add a new url route .", "label": 1}, {"idx": "cosqa-train-6651", "doc": "connect the points with a line python", "code": "def _linepoint(self, t, x0, y0, x1, y1):\n        \"\"\" Returns coordinates for point at t on the line.\n            Calculates the coordinates of x and y for a point at t on a straight line.\n            The t parameter is a number between 0.0 and 1.0,\n            x0 and y0 define the starting point of the line,\n            x1 and y1 the ending point of the line.\n        \"\"\"\n        # Originally from nodebox-gl\n        out_x = x0 + t * (x1 - x0)\n        out_y = y0 + t * (y1 - y0)\n        return (out_x, out_y)", "code_tokens": "def _linepoint ( self , t , x0 , y0 , x1 , y1 ) : # Originally from nodebox-gl out_x = x0 + t * ( x1 - x0 ) out_y = y0 + t * ( y1 - y0 ) return ( out_x , out_y )", "docstring_tokens": "Returns coordinates for point at t on the line . Calculates the coordinates of x and y for a point at t on a straight line . The t parameter is a number between 0 . 0 and 1 . 0 x0 and y0 define the starting point of the line x1 and y1 the ending point of the line .", "label": 0}, {"idx": "cosqa-train-6652", "doc": "python flask separate functions get and post", "code": "def handleFlaskPostRequest(flaskRequest, endpoint):\n    \"\"\"\n    Handles the specified flask request for one of the POST URLS\n    Invokes the specified endpoint to generate a response.\n    \"\"\"\n    if flaskRequest.method == \"POST\":\n        return handleHttpPost(flaskRequest, endpoint)\n    elif flaskRequest.method == \"OPTIONS\":\n        return handleHttpOptions()\n    else:\n        raise exceptions.MethodNotAllowedException()", "code_tokens": "def handleFlaskPostRequest ( flaskRequest , endpoint ) : if flaskRequest . method == \"POST\" : return handleHttpPost ( flaskRequest , endpoint ) elif flaskRequest . method == \"OPTIONS\" : return handleHttpOptions ( ) else : raise exceptions . MethodNotAllowedException ( )", "docstring_tokens": "Handles the specified flask request for one of the POST URLS Invokes the specified endpoint to generate a response .", "label": 1}, {"idx": "cosqa-train-6653", "doc": "connect to ftp server from python", "code": "def connect(host, port, username, password):\n        \"\"\"Connect and login to an FTP server and return ftplib.FTP object.\"\"\"\n        # Instantiate ftplib client\n        session = ftplib.FTP()\n\n        # Connect to host without auth\n        session.connect(host, port)\n\n        # Authenticate connection\n        session.login(username, password)\n        return session", "code_tokens": "def connect ( host , port , username , password ) : # Instantiate ftplib client session = ftplib . FTP ( ) # Connect to host without auth session . connect ( host , port ) # Authenticate connection session . login ( username , password ) return session", "docstring_tokens": "Connect and login to an FTP server and return ftplib . FTP object .", "label": 1}, {"idx": "cosqa-train-6654", "doc": "python flask start a thread outside web context", "code": "def run(context, port):\n    \"\"\" Run the Webserver/SocketIO and app\n    \"\"\"\n    global ctx\n    ctx = context\n    app.run(port=port)", "code_tokens": "def run ( context , port ) : global ctx ctx = context app . run ( port = port )", "docstring_tokens": "Run the Webserver / SocketIO and app", "label": 0}, {"idx": "cosqa-train-6655", "doc": "connect to python ftp server host", "code": "def connect(host, port, username, password):\n        \"\"\"Connect and login to an FTP server and return ftplib.FTP object.\"\"\"\n        # Instantiate ftplib client\n        session = ftplib.FTP()\n\n        # Connect to host without auth\n        session.connect(host, port)\n\n        # Authenticate connection\n        session.login(username, password)\n        return session", "code_tokens": "def connect ( host , port , username , password ) : # Instantiate ftplib client session = ftplib . FTP ( ) # Connect to host without auth session . connect ( host , port ) # Authenticate connection session . login ( username , password ) return session", "docstring_tokens": "Connect and login to an FTP server and return ftplib . FTP object .", "label": 1}, {"idx": "cosqa-train-6656", "doc": "python float fortran opnfl", "code": "def _loadf(ins):\n    \"\"\" Loads a floating point value from a memory address.\n    If 2nd arg. start with '*', it is always treated as\n    an indirect value.\n    \"\"\"\n    output = _float_oper(ins.quad[2])\n    output.extend(_fpush())\n    return output", "code_tokens": "def _loadf ( ins ) : output = _float_oper ( ins . quad [ 2 ] ) output . extend ( _fpush ( ) ) return output", "docstring_tokens": "Loads a floating point value from a memory address . If 2nd arg . start with * it is always treated as an indirect value .", "label": 1}, {"idx": "cosqa-train-6657", "doc": "converst datetime to string python", "code": "def serialize(self, value):\n        \"\"\"Takes a datetime object and returns a string\"\"\"\n        if isinstance(value, str):\n            return value\n        return value.strftime(DATETIME_FORMAT)", "code_tokens": "def serialize ( self , value ) : if isinstance ( value , str ) : return value return value . strftime ( DATETIME_FORMAT )", "docstring_tokens": "Takes a datetime object and returns a string", "label": 1}, {"idx": "cosqa-train-6658", "doc": "python for loop+horizontat stack each column of an array", "code": "def column_stack_2d(data):\n    \"\"\"Perform column-stacking on a list of 2d data blocks.\"\"\"\n    return list(list(itt.chain.from_iterable(_)) for _ in zip(*data))", "code_tokens": "def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )", "docstring_tokens": "Perform column - stacking on a list of 2d data blocks .", "label": 1}, {"idx": "cosqa-train-6659", "doc": "correlation matrix of all columns in python", "code": "def sample_correlations(self):\n        \"\"\"Returns an `ExpMatrix` containing all pairwise sample correlations.\n\n        Returns\n        -------\n        `ExpMatrix`\n            The sample correlation matrix.\n\n        \"\"\"\n        C = np.corrcoef(self.X.T)\n        corr_matrix = ExpMatrix(genes=self.samples, samples=self.samples, X=C)\n        return corr_matrix", "code_tokens": "def sample_correlations ( self ) : C = np . corrcoef ( self . X . T ) corr_matrix = ExpMatrix ( genes = self . samples , samples = self . samples , X = C ) return corr_matrix", "docstring_tokens": "Returns an ExpMatrix containing all pairwise sample correlations .", "label": 1}, {"idx": "cosqa-train-6660", "doc": "python force plot window to close", "code": "def raise_figure_window(f=0):\n    \"\"\"\n    Raises the supplied figure number or figure window.\n    \"\"\"\n    if _fun.is_a_number(f): f = _pylab.figure(f)\n    f.canvas.manager.window.raise_()", "code_tokens": "def raise_figure_window ( f = 0 ) : if _fun . is_a_number ( f ) : f = _pylab . figure ( f ) f . canvas . manager . window . raise_ ( )", "docstring_tokens": "Raises the supplied figure number or figure window .", "label": 1}, {"idx": "cosqa-train-6661", "doc": "count all element in index elasticsearch python", "code": "def index_all(self, index_name):\n        \"\"\"Index all available documents, using streaming_bulk for speed\n        Args:\n\n        index_name (string): The index\n        \"\"\"\n        oks = 0\n        notoks = 0\n        for ok, item in streaming_bulk(\n            self.es_client,\n            self._iter_documents(index_name)\n        ):\n            if ok:\n                oks += 1\n            else:\n                notoks += 1\n        logging.info(\n            \"Import results: %d ok, %d not ok\",\n            oks,\n            notoks\n        )", "code_tokens": "def index_all ( self , index_name ) : oks = 0 notoks = 0 for ok , item in streaming_bulk ( self . es_client , self . _iter_documents ( index_name ) ) : if ok : oks += 1 else : notoks += 1 logging . info ( \"Import results: %d ok, %d not ok\" , oks , notoks )", "docstring_tokens": "Index all available documents using streaming_bulk for speed Args :", "label": 0}, {"idx": "cosqa-train-6662", "doc": "count non empty lines python", "code": "def empty_line_count_at_the_end(self):\n        \"\"\"\n        Return number of empty lines at the end of the document.\n        \"\"\"\n        count = 0\n        for line in self.lines[::-1]:\n            if not line or line.isspace():\n                count += 1\n            else:\n                break\n\n        return count", "code_tokens": "def empty_line_count_at_the_end ( self ) : count = 0 for line in self . lines [ : : - 1 ] : if not line or line . isspace ( ) : count += 1 else : break return count", "docstring_tokens": "Return number of empty lines at the end of the document .", "label": 0}, {"idx": "cosqa-train-6663", "doc": "python format f rounding", "code": "def _saferound(value, decimal_places):\n    \"\"\"\n    Rounds a float value off to the desired precision\n    \"\"\"\n    try:\n        f = float(value)\n    except ValueError:\n        return ''\n    format = '%%.%df' % decimal_places\n    return format % f", "code_tokens": "def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f", "docstring_tokens": "Rounds a float value off to the desired precision", "label": 1}, {"idx": "cosqa-train-6664", "doc": "count number of pixels in python string", "code": "def _visual_width(line):\n    \"\"\"Get the the number of columns required to display a string\"\"\"\n\n    return len(re.sub(colorama.ansitowin32.AnsiToWin32.ANSI_CSI_RE, \"\", line))", "code_tokens": "def _visual_width ( line ) : return len ( re . sub ( colorama . ansitowin32 . AnsiToWin32 . ANSI_CSI_RE , \"\" , line ) )", "docstring_tokens": "Get the the number of columns required to display a string", "label": 1}, {"idx": "cosqa-train-6665", "doc": "python format string comflict curly brace", "code": "def string_format_func(s):\n\t\"\"\"\n\tFunction used internally to format string data for output to XML.\n\tEscapes back-slashes and quotes, and wraps the resulting string in\n\tquotes.\n\t\"\"\"\n\treturn u\"\\\"%s\\\"\" % unicode(s).replace(u\"\\\\\", u\"\\\\\\\\\").replace(u\"\\\"\", u\"\\\\\\\"\")", "code_tokens": "def string_format_func ( s ) : return u\"\\\"%s\\\"\" % unicode ( s ) . replace ( u\"\\\\\" , u\"\\\\\\\\\" ) . replace ( u\"\\\"\" , u\"\\\\\\\"\" )", "docstring_tokens": "Function used internally to format string data for output to XML . Escapes back - slashes and quotes and wraps the resulting string in quotes .", "label": 0}, {"idx": "cosqa-train-6666", "doc": "count sentence frequencies in documents python", "code": "def count(lines):\n  \"\"\" Counts the word frequences in a list of sentences.\n\n  Note:\n    This is a helper function for parallel execution of `Vocabulary.from_text`\n    method.\n  \"\"\"\n  words = [w for l in lines for w in l.strip().split()]\n  return Counter(words)", "code_tokens": "def count ( lines ) : words = [ w for l in lines for w in l . strip ( ) . split ( ) ] return Counter ( words )", "docstring_tokens": "Counts the word frequences in a list of sentences .", "label": 1}, {"idx": "cosqa-train-6667", "doc": "python ftps ssl/tls passive", "code": "def connect():\n    \"\"\"Connect to FTP server, login and return an ftplib.FTP instance.\"\"\"\n    ftp_class = ftplib.FTP if not SSL else ftplib.FTP_TLS\n    ftp = ftp_class(timeout=TIMEOUT)\n    ftp.connect(HOST, PORT)\n    ftp.login(USER, PASSWORD)\n    if SSL:\n        ftp.prot_p()  # secure data connection\n    return ftp", "code_tokens": "def connect ( ) : ftp_class = ftplib . FTP if not SSL else ftplib . FTP_TLS ftp = ftp_class ( timeout = TIMEOUT ) ftp . connect ( HOST , PORT ) ftp . login ( USER , PASSWORD ) if SSL : ftp . prot_p ( ) # secure data connection return ftp", "docstring_tokens": "Connect to FTP server login and return an ftplib . FTP instance .", "label": 0}, {"idx": "cosqa-train-6668", "doc": "counting depth on a binary tree python", "code": "def min_depth(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if root is None:\n        return 0\n    if root.left is not None or root.right is not None:\n        return max(self.minDepth(root.left), self.minDepth(root.right))+1\n    return min(self.minDepth(root.left), self.minDepth(root.right)) + 1", "code_tokens": "def min_depth ( self , root ) : if root is None : return 0 if root . left is not None or root . right is not None : return max ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1 return min ( self . minDepth ( root . left ) , self . minDepth ( root . right ) ) + 1", "docstring_tokens": ": type root : TreeNode : rtype : int", "label": 0}, {"idx": "cosqa-train-6669", "doc": "python function dot name", "code": "def _fullname(o):\n    \"\"\"Return the fully-qualified name of a function.\"\"\"\n    return o.__module__ + \".\" + o.__name__ if o.__module__ else o.__name__", "code_tokens": "def _fullname ( o ) : return o . __module__ + \".\" + o . __name__ if o . __module__ else o . __name__", "docstring_tokens": "Return the fully - qualified name of a function .", "label": 0}, {"idx": "cosqa-train-6670", "doc": "create a 3d matrix out of 3 vectors python", "code": "def cross_product_matrix(vec):\n    \"\"\"Returns a 3x3 cross-product matrix from a 3-element vector.\"\"\"\n    return np.array([[0, -vec[2], vec[1]],\n                     [vec[2], 0, -vec[0]],\n                     [-vec[1], vec[0], 0]])", "code_tokens": "def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )", "docstring_tokens": "Returns a 3x3 cross - product matrix from a 3 - element vector .", "label": 0}, {"idx": "cosqa-train-6671", "doc": "python function name case", "code": "def method_name(func):\n    \"\"\"Method wrapper that adds the name of the method being called to its arguments list in Pascal case\n\n    \"\"\"\n    @wraps(func)\n    def _method_name(*args, **kwargs):\n        name = to_pascal_case(func.__name__)\n        return func(name=name, *args, **kwargs)\n    return _method_name", "code_tokens": "def method_name ( func ) : @ wraps ( func ) def _method_name ( * args , * * kwargs ) : name = to_pascal_case ( func . __name__ ) return func ( name = name , * args , * * kwargs ) return _method_name", "docstring_tokens": "Method wrapper that adds the name of the method being called to its arguments list in Pascal case", "label": 0}, {"idx": "cosqa-train-6672", "doc": "create a datetime objecr python", "code": "def Timestamp(year, month, day, hour, minute, second):\n    \"\"\"Constructs an object holding a datetime/timestamp value.\"\"\"\n    return datetime.datetime(year, month, day, hour, minute, second)", "code_tokens": "def Timestamp ( year , month , day , hour , minute , second ) : return datetime . datetime ( year , month , day , hour , minute , second )", "docstring_tokens": "Constructs an object holding a datetime / timestamp value .", "label": 0}, {"idx": "cosqa-train-6673", "doc": "python function not defined input", "code": "def get_input(input_func, input_str):\n    \"\"\"\n    Get input from the user given an input function and an input string\n    \"\"\"\n    val = input_func(\"Please enter your {0}: \".format(input_str))\n    while not val or not len(val.strip()):\n        val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))\n    return val", "code_tokens": "def get_input ( input_func , input_str ) : val = input_func ( \"Please enter your {0}: \" . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( \"You didn't enter a valid {0}, please try again: \" . format ( input_str ) ) return val", "docstring_tokens": "Get input from the user given an input function and an input string", "label": 0}, {"idx": "cosqa-train-6674", "doc": "create a distinct copy of array python", "code": "def copy(a):\n    \"\"\" Copy an array to the shared memory. \n\n        Notes\n        -----\n        copy is not always necessary because the private memory is always copy-on-write.\n\n        Use :code:`a = copy(a)` to immediately dereference the old 'a' on private memory\n    \"\"\"\n    shared = anonymousmemmap(a.shape, dtype=a.dtype)\n    shared[:] = a[:]\n    return shared", "code_tokens": "def copy ( a ) : shared = anonymousmemmap ( a . shape , dtype = a . dtype ) shared [ : ] = a [ : ] return shared", "docstring_tokens": "Copy an array to the shared memory .", "label": 1}, {"idx": "cosqa-train-6675", "doc": "python function round to nearest 1/10th", "code": "def ceil_nearest(x, dx=1):\n    \"\"\"\n    ceil a number to within a given rounding accuracy\n    \"\"\"\n    precision = get_sig_digits(dx)\n    return round(math.ceil(float(x) / dx) * dx, precision)", "code_tokens": "def ceil_nearest ( x , dx = 1 ) : precision = get_sig_digits ( dx ) return round ( math . ceil ( float ( x ) / dx ) * dx , precision )", "docstring_tokens": "ceil a number to within a given rounding accuracy", "label": 1}, {"idx": "cosqa-train-6676", "doc": "create a latex table in python", "code": "def get_latex_table(self, parameters=None, transpose=False, caption=None,\n                        label=\"tab:model_params\", hlines=True, blank_fill=\"--\"):  # pragma: no cover\n        \"\"\" Generates a LaTeX table from parameter summaries.\n\n        Parameters\n        ----------\n        parameters : list[str], optional\n            A list of what parameters to include in the table. By default, includes all parameters\n        transpose : bool, optional\n            Defaults to False, which gives each column as a parameter, each chain (framework)\n            as a row. You can swap it so that you have a parameter each row and a framework\n            each column by setting this to True\n        caption : str, optional\n            If you want to generate a caption for the table through Python, use this.\n            Defaults to an empty string\n        label : str, optional\n            If you want to generate a label for the table through Python, use this.\n            Defaults to an empty string\n        hlines : bool, optional\n            Inserts ``\\\\hline`` before and after the header, and at the end of table.\n        blank_fill : str, optional\n            If a framework does not have a particular parameter, will fill that cell of\n            the table with this string.\n\n        Returns\n        -------\n        str\n            the LaTeX table.\n        \"\"\"\n        if parameters is None:\n            parameters = self.parent._all_parameters\n        for p in parameters:\n            assert isinstance(p, str), \\\n                \"Generating a LaTeX table requires all parameters have labels\"\n        num_parameters = len(parameters)\n        num_chains = len(self.parent.chains)\n        fit_values = self.get_summary(squeeze=False)\n        if label is None:\n            label = \"\"\n        if caption is None:\n            caption = \"\"\n\n        end_text = \" \\\\\\\\ \\n\"\n        if transpose:\n            column_text = \"c\" * (num_chains + 1)\n        else:\n            column_text = \"c\" * (num_parameters + 1)\n\n        center_text = \"\"\n        hline_text = \"\\\\hline\\n\"\n        if hlines:\n            center_text += hline_text + \"\\t\\t\"\n        if transpose:\n            center_text += \" & \".join([\"Parameter\"] + [c.name for c in self.parent.chains]) + end_text\n            if hlines:\n                center_text += \"\\t\\t\" + hline_text\n            for p in parameters:\n                arr = [\"\\t\\t\" + p]\n                for chain_res in fit_values:\n                    if p in chain_res:\n                        arr.append(self.get_parameter_text(*chain_res[p], wrap=True))\n                    else:\n                        arr.append(blank_fill)\n                center_text += \" & \".join(arr) + end_text\n        else:\n            center_text += \" & \".join([\"Model\"] + parameters) + end_text\n            if hlines:\n                center_text += \"\\t\\t\" + hline_text\n            for name, chain_res in zip([c.name for c in self.parent.chains], fit_values):\n                arr = [\"\\t\\t\" + name]\n                for p in parameters:\n                    if p in chain_res:\n                        arr.append(self.get_parameter_text(*chain_res[p], wrap=True))\n                    else:\n                        arr.append(blank_fill)\n                center_text += \" & \".join(arr) + end_text\n        if hlines:\n            center_text += \"\\t\\t\" + hline_text\n        final_text = get_latex_table_frame(caption, label) % (column_text, center_text)\n\n        return final_text", "code_tokens": "def get_latex_table ( self , parameters = None , transpose = False , caption = None , label = \"tab:model_params\" , hlines = True , blank_fill = \"--\" ) : # pragma: no cover if parameters is None : parameters = self . parent . _all_parameters for p in parameters : assert isinstance ( p , str ) , \"Generating a LaTeX table requires all parameters have labels\" num_parameters = len ( parameters ) num_chains = len ( self . parent . chains ) fit_values = self . get_summary ( squeeze = False ) if label is None : label = \"\" if caption is None : caption = \"\" end_text = \" \\\\\\\\ \\n\" if transpose : column_text = \"c\" * ( num_chains + 1 ) else : column_text = \"c\" * ( num_parameters + 1 ) center_text = \"\" hline_text = \"\\\\hline\\n\" if hlines : center_text += hline_text + \"\\t\\t\" if transpose : center_text += \" & \" . join ( [ \"Parameter\" ] + [ c . name for c in self . parent . chains ] ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text for p in parameters : arr = [ \"\\t\\t\" + p ] for chain_res in fit_values : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += \" & \" . join ( arr ) + end_text else : center_text += \" & \" . join ( [ \"Model\" ] + parameters ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text for name , chain_res in zip ( [ c . name for c in self . parent . chains ] , fit_values ) : arr = [ \"\\t\\t\" + name ] for p in parameters : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += \" & \" . join ( arr ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text final_text = get_latex_table_frame ( caption , label ) % ( column_text , center_text ) return final_text", "docstring_tokens": "Generates a LaTeX table from parameter summaries .", "label": 0}, {"idx": "cosqa-train-6677", "doc": "create an empty column in data frame python", "code": "def add_blank_row(self, label):\n        \"\"\"\n        Add a blank row with only an index value to self.df.\n        This is done inplace.\n        \"\"\"\n        col_labels = self.df.columns\n        blank_item = pd.Series({}, index=col_labels, name=label)\n        # use .loc to add in place (append won't do that)\n        self.df.loc[blank_item.name] = blank_item\n        return self.df", "code_tokens": "def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df", "docstring_tokens": "Add a blank row with only an index value to self . df . This is done inplace .", "label": 1}, {"idx": "cosqa-train-6678", "doc": "python function that takes a string and returns an int", "code": "def get_number(s, cast=int):\n    \"\"\"\n    Try to get a number out of a string, and cast it.\n    \"\"\"\n    import string\n    d = \"\".join(x for x in str(s) if x in string.digits)\n    return cast(d)", "code_tokens": "def get_number ( s , cast = int ) : import string d = \"\" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )", "docstring_tokens": "Try to get a number out of a string and cast it .", "label": 1}, {"idx": "cosqa-train-6679", "doc": "create bold output in python", "code": "def good(txt):\n    \"\"\"Print, emphasized 'good', the given 'txt' message\"\"\"\n\n    print(\"%s# %s%s%s\" % (PR_GOOD_CC, get_time_stamp(), txt, PR_NC))\n    sys.stdout.flush()", "code_tokens": "def good ( txt ) : print ( \"%s# %s%s%s\" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "docstring_tokens": "Print emphasized good the given txt message", "label": 0}, {"idx": "cosqa-train-6680", "doc": "python function to get item from queue", "code": "def get_item_from_queue(Q, timeout=0.01):\n    \"\"\" Attempts to retrieve an item from the queue Q. If Q is\n        empty, None is returned.\n\n        Blocks for 'timeout' seconds in case the queue is empty,\n        so don't use this method for speedy retrieval of multiple\n        items (use get_all_from_queue for that).\n    \"\"\"\n    try:\n        item = Q.get(True, 0.01)\n    except Queue.Empty:\n        return None\n\n    return item", "code_tokens": "def get_item_from_queue ( Q , timeout = 0.01 ) : try : item = Q . get ( True , 0.01 ) except Queue . Empty : return None return item", "docstring_tokens": "Attempts to retrieve an item from the queue Q . If Q is empty None is returned . Blocks for timeout seconds in case the queue is empty so don t use this method for speedy retrieval of multiple items ( use get_all_from_queue for that ) .", "label": 1}, {"idx": "cosqa-train-6681", "doc": "create copy that doesn't alter original python", "code": "def copy(obj):\n    def copy(self):\n        \"\"\"\n        Copy self to a new object.\n        \"\"\"\n        from copy import deepcopy\n\n        return deepcopy(self)\n    obj.copy = copy\n    return obj", "code_tokens": "def copy ( obj ) : def copy ( self ) : \"\"\"\n        Copy self to a new object.\n        \"\"\" from copy import deepcopy return deepcopy ( self ) obj . copy = copy return obj", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-6682", "doc": "python function to reduce image size", "code": "def resize_by_area(img, size):\n  \"\"\"image resize function used by quite a few image problems.\"\"\"\n  return tf.to_int64(\n      tf.image.resize_images(img, [size, size], tf.image.ResizeMethod.AREA))", "code_tokens": "def resize_by_area ( img , size ) : return tf . to_int64 ( tf . image . resize_images ( img , [ size , size ] , tf . image . ResizeMethod . AREA ) )", "docstring_tokens": "image resize function used by quite a few image problems .", "label": 1}, {"idx": "cosqa-train-6683", "doc": "create file open dialog box in python", "code": "def fileopenbox(msg=None, title=None, argInitialFile=None):\n    \"\"\"Original doc: A dialog to get a file name.\n        Returns the name of a file, or None if user chose to cancel.\n\n        if argInitialFile contains a valid filename, the dialog will\n        be positioned at that file when it appears.\n        \"\"\"\n    return psidialogs.ask_file(message=msg, title=title, default=argInitialFile)", "code_tokens": "def fileopenbox ( msg = None , title = None , argInitialFile = None ) : return psidialogs . ask_file ( message = msg , title = title , default = argInitialFile )", "docstring_tokens": "Original doc : A dialog to get a file name . Returns the name of a file or None if user chose to cancel .", "label": 1}, {"idx": "cosqa-train-6684", "doc": "python function to remove headers", "code": "def remove_hop_by_hop_headers(headers):\n    \"\"\"Remove all HTTP/1.1 \"Hop-by-Hop\" headers from a list or\n    :class:`Headers` object.  This operation works in-place.\n\n    .. versionadded:: 0.5\n\n    :param headers: a list or :class:`Headers` object.\n    \"\"\"\n    headers[:] = [\n        (key, value) for key, value in headers if not is_hop_by_hop_header(key)\n    ]", "code_tokens": "def remove_hop_by_hop_headers ( headers ) : headers [ : ] = [ ( key , value ) for key , value in headers if not is_hop_by_hop_header ( key ) ]", "docstring_tokens": "Remove all HTTP / 1 . 1 Hop - by - Hop headers from a list or : class : Headers object . This operation works in - place .", "label": 1}, {"idx": "cosqa-train-6685", "doc": "create modelas in sqlalchemy python", "code": "def create_db(app, appbuilder):\n    \"\"\"\n        Create all your database objects (SQLAlchemy specific).\n    \"\"\"\n    from flask_appbuilder.models.sqla import Base\n\n    _appbuilder = import_application(app, appbuilder)\n    engine = _appbuilder.get_session.get_bind(mapper=None, clause=None)\n    Base.metadata.create_all(engine)\n    click.echo(click.style(\"DB objects created\", fg=\"green\"))", "code_tokens": "def create_db ( app , appbuilder ) : from flask_appbuilder . models . sqla import Base _appbuilder = import_application ( app , appbuilder ) engine = _appbuilder . get_session . get_bind ( mapper = None , clause = None ) Base . metadata . create_all ( engine ) click . echo ( click . style ( \"DB objects created\" , fg = \"green\" ) )", "docstring_tokens": "Create all your database objects ( SQLAlchemy specific ) .", "label": 0}, {"idx": "cosqa-train-6686", "doc": "python function to remove whitespace", "code": "def text_remove_empty_lines(text):\n    \"\"\"\n    Whitespace normalization:\n\n      - Strip empty lines\n      - Strip trailing whitespace\n    \"\"\"\n    lines = [ line.rstrip()  for line in text.splitlines()  if line.strip() ]\n    return \"\\n\".join(lines)", "code_tokens": "def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return \"\\n\" . join ( lines )", "docstring_tokens": "Whitespace normalization :", "label": 0}, {"idx": "cosqa-train-6687", "doc": "create new data frame that is a subset of another python", "code": "def intersect(self, other):\n        \"\"\" Return a new :class:`DataFrame` containing rows only in\n        both this frame and another frame.\n\n        This is equivalent to `INTERSECT` in SQL.\n        \"\"\"\n        return DataFrame(self._jdf.intersect(other._jdf), self.sql_ctx)", "code_tokens": "def intersect ( self , other ) : return DataFrame ( self . _jdf . intersect ( other . _jdf ) , self . sql_ctx )", "docstring_tokens": "Return a new : class : DataFrame containing rows only in both this frame and another frame .", "label": 1}, {"idx": "cosqa-train-6688", "doc": "python function to show time to execute", "code": "def timeit(output):\n    \"\"\"\n    If output is string, then print the string and also time used\n    \"\"\"\n    b = time.time()\n    yield\n    print output, 'time used: %.3fs' % (time.time()-b)", "code_tokens": "def timeit ( output ) : b = time . time ( ) yield print output , 'time used: %.3fs' % ( time . time ( ) - b )", "docstring_tokens": "If output is string then print the string and also time used", "label": 0}, {"idx": "cosqa-train-6689", "doc": "create parquet file from rdd using python", "code": "def _to_java_object_rdd(rdd):\n    \"\"\" Return a JavaRDD of Object by unpickling\n\n    It will convert each Python object into Java object by Pyrolite, whenever the\n    RDD is serialized in batch or not.\n    \"\"\"\n    rdd = rdd._reserialize(AutoBatchedSerializer(PickleSerializer()))\n    return rdd.ctx._jvm.org.apache.spark.mllib.api.python.SerDe.pythonToJava(rdd._jrdd, True)", "code_tokens": "def _to_java_object_rdd ( rdd ) : rdd = rdd . _reserialize ( AutoBatchedSerializer ( PickleSerializer ( ) ) ) return rdd . ctx . _jvm . org . apache . spark . mllib . api . python . SerDe . pythonToJava ( rdd . _jrdd , True )", "docstring_tokens": "Return a JavaRDD of Object by unpickling", "label": 1}, {"idx": "cosqa-train-6690", "doc": "python garbage collect force", "code": "def cleanup_storage(*args):\n    \"\"\"Clean up processes after SIGTERM or SIGINT is received.\"\"\"\n    ShardedClusters().cleanup()\n    ReplicaSets().cleanup()\n    Servers().cleanup()\n    sys.exit(0)", "code_tokens": "def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )", "docstring_tokens": "Clean up processes after SIGTERM or SIGINT is received .", "label": 1}, {"idx": "cosqa-train-6691", "doc": "create python dictionary based on data frame value and index", "code": "def as_dict(df, ix=':'):\n    \"\"\" converts df to dict and adds a datetime field if df is datetime \"\"\"\n    if isinstance(df.index, pd.DatetimeIndex):\n        df['datetime'] = df.index\n    return df.to_dict(orient='records')[ix]", "code_tokens": "def as_dict ( df , ix = ':' ) : if isinstance ( df . index , pd . DatetimeIndex ) : df [ 'datetime' ] = df . index return df . to_dict ( orient = 'records' ) [ ix ]", "docstring_tokens": "converts df to dict and adds a datetime field if df is datetime", "label": 1}, {"idx": "cosqa-train-6692", "doc": "python generate a random string of length 5", "code": "def uniqueID(size=6, chars=string.ascii_uppercase + string.digits):\n    \"\"\"A quick and dirty way to get a unique string\"\"\"\n    return ''.join(random.choice(chars) for x in xrange(size))", "code_tokens": "def uniqueID ( size = 6 , chars = string . ascii_uppercase + string . digits ) : return '' . join ( random . choice ( chars ) for x in xrange ( size ) )", "docstring_tokens": "A quick and dirty way to get a unique string", "label": 1}, {"idx": "cosqa-train-6693", "doc": "create valiable by concatinate strings in python", "code": "def remove_from_string(string, values):\n    \"\"\"\n\n    Parameters\n    ----------\n    string:\n    values:\n\n    Returns\n    -------\n    \"\"\"\n    for v in values:\n        string = string.replace(v, '')\n\n    return string", "code_tokens": "def remove_from_string ( string , values ) : for v in values : string = string . replace ( v , '' ) return string", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-6694", "doc": "python get a function from name", "code": "def get_function(function_name):\n    \"\"\"\n    Given a Python function name, return the function it refers to.\n    \"\"\"\n    module, basename = str(function_name).rsplit('.', 1)\n    try:\n        return getattr(__import__(module, fromlist=[basename]), basename)\n    except (ImportError, AttributeError):\n        raise FunctionNotFound(function_name)", "code_tokens": "def get_function ( function_name ) : module , basename = str ( function_name ) . rsplit ( '.' , 1 ) try : return getattr ( __import__ ( module , fromlist = [ basename ] ) , basename ) except ( ImportError , AttributeError ) : raise FunctionNotFound ( function_name )", "docstring_tokens": "Given a Python function name return the function it refers to .", "label": 0}, {"idx": "cosqa-train-6695", "doc": "creating a accesible menu in python", "code": "def add(self, name, desc, func=None, args=None, krgs=None):\n        \"\"\"Add a menu entry.\"\"\"\n        self.entries.append(MenuEntry(name, desc, func, args or [], krgs or {}))", "code_tokens": "def add ( self , name , desc , func = None , args = None , krgs = None ) : self . entries . append ( MenuEntry ( name , desc , func , args or [ ] , krgs or { } ) )", "docstring_tokens": "Add a menu entry .", "label": 1}, {"idx": "cosqa-train-6696", "doc": "python get a list of dates between two dates", "code": "def dates_in_range(start_date, end_date):\n    \"\"\"Returns all dates between two dates.\n\n    Inclusive of the start date but not the end date.\n\n    Args:\n        start_date (datetime.date)\n        end_date (datetime.date)\n\n    Returns:\n        (list) of datetime.date objects\n    \"\"\"\n    return [\n        start_date + timedelta(n)\n        for n in range(int((end_date - start_date).days))\n    ]", "code_tokens": "def dates_in_range ( start_date , end_date ) : return [ start_date + timedelta ( n ) for n in range ( int ( ( end_date - start_date ) . days ) ) ]", "docstring_tokens": "Returns all dates between two dates .", "label": 0}, {"idx": "cosqa-train-6697", "doc": "creating a range of values with step size python", "code": "def _xxrange(self, start, end, step_count):\n        \"\"\"Generate n values between start and end.\"\"\"\n        _step = (end - start) / float(step_count)\n        return (start + (i * _step) for i in xrange(int(step_count)))", "code_tokens": "def _xxrange ( self , start , end , step_count ) : _step = ( end - start ) / float ( step_count ) return ( start + ( i * _step ) for i in xrange ( int ( step_count ) ) )", "docstring_tokens": "Generate n values between start and end .", "label": 1}, {"idx": "cosqa-train-6698", "doc": "python get all logging handlers", "code": "def _get_loggers():\n    \"\"\"Return list of Logger classes.\"\"\"\n    from .. import loader\n    modules = loader.get_package_modules('logger')\n    return list(loader.get_plugins(modules, [_Logger]))", "code_tokens": "def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )", "docstring_tokens": "Return list of Logger classes .", "label": 0}, {"idx": "cosqa-train-6699", "doc": "creating custom loggers python", "code": "def register_logging_factories(loader):\n    \"\"\"\n    Registers default factories for logging standard package.\n\n    :param loader: Loader where you want register default logging factories\n    \"\"\"\n    loader.register_factory(logging.Logger, LoggerFactory)\n    loader.register_factory(logging.Handler, LoggingHandlerFactory)", "code_tokens": "def register_logging_factories ( loader ) : loader . register_factory ( logging . Logger , LoggerFactory ) loader . register_factory ( logging . Handler , LoggingHandlerFactory )", "docstring_tokens": "Registers default factories for logging standard package .", "label": 1}, {"idx": "cosqa-train-6700", "doc": "python get all the factors of a number", "code": "def _factor_generator(n):\n    \"\"\"\n    From a given natural integer, returns the prime factors and their multiplicity\n    :param n: Natural integer\n    :return:\n    \"\"\"\n    p = prime_factors(n)\n    factors = {}\n    for p1 in p:\n        try:\n            factors[p1] += 1\n        except KeyError:\n            factors[p1] = 1\n    return factors", "code_tokens": "def _factor_generator ( n ) : p = prime_factors ( n ) factors = { } for p1 in p : try : factors [ p1 ] += 1 except KeyError : factors [ p1 ] = 1 return factors", "docstring_tokens": "From a given natural integer returns the prime factors and their multiplicity : param n : Natural integer : return :", "label": 1}, {"idx": "cosqa-train-6701", "doc": "cumulative sum of a list in python", "code": "def cumsum(inlist):\n    \"\"\"\nReturns a list consisting of the cumulative sum of the items in the\npassed list.\n\nUsage:   lcumsum(inlist)\n\"\"\"\n    newlist = copy.deepcopy(inlist)\n    for i in range(1, len(newlist)):\n        newlist[i] = newlist[i] + newlist[i - 1]\n    return newlist", "code_tokens": "def cumsum ( inlist ) : newlist = copy . deepcopy ( inlist ) for i in range ( 1 , len ( newlist ) ) : newlist [ i ] = newlist [ i ] + newlist [ i - 1 ] return newlist", "docstring_tokens": "Returns a list consisting of the cumulative sum of the items in the passed list .", "label": 0}, {"idx": "cosqa-train-6702", "doc": "python get all the variable names of a table", "code": "def get_column_keys_and_names(table):\n    \"\"\"\n    Return a generator of tuples k, c such that k is the name of the python attribute for\n    the column and c is the name of the column in the sql table.\n    \"\"\"\n    ins = inspect(table)\n    return ((k, c.name) for k, c in ins.mapper.c.items())", "code_tokens": "def get_column_keys_and_names ( table ) : ins = inspect ( table ) return ( ( k , c . name ) for k , c in ins . mapper . c . items ( ) )", "docstring_tokens": "Return a generator of tuples k c such that k is the name of the python attribute for the column and c is the name of the column in the sql table .", "label": 0}, {"idx": "cosqa-train-6703", "doc": "current time hours minutes seconds miliseconds if python", "code": "def now_time(str=False):\n    \"\"\"Get the current time.\"\"\"\n    if str:\n        return datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    return datetime.datetime.now()", "code_tokens": "def now_time ( str = False ) : if str : return datetime . datetime . now ( ) . strftime ( \"%Y-%m-%d %H:%M:%S\" ) return datetime . datetime . now ( )", "docstring_tokens": "Get the current time .", "label": 1}, {"idx": "cosqa-train-6704", "doc": "python get average volume of audio", "code": "def calc_volume(self, sample: np.ndarray):\n        \"\"\"Find the RMS of the audio\"\"\"\n        return sqrt(np.mean(np.square(sample)))", "code_tokens": "def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )", "docstring_tokens": "Find the RMS of the audio", "label": 1}, {"idx": "cosqa-train-6705", "doc": "customizing raise function in python", "code": "def reraise(error):\n    \"\"\"Re-raises the error that was processed by prepare_for_reraise earlier.\"\"\"\n    if hasattr(error, \"_type_\"):\n        six.reraise(type(error), error, error._traceback)\n    raise error", "code_tokens": "def reraise ( error ) : if hasattr ( error , \"_type_\" ) : six . reraise ( type ( error ) , error , error . _traceback ) raise error", "docstring_tokens": "Re - raises the error that was processed by prepare_for_reraise earlier .", "label": 1}, {"idx": "cosqa-train-6706", "doc": "python get borders of 2d regions", "code": "def bbox(self):\n        \"\"\"\n        The bounding box ``(ymin, xmin, ymax, xmax)`` of the minimal\n        rectangular region containing the source segment.\n        \"\"\"\n\n        # (stop - 1) to return the max pixel location, not the slice index\n        return (self._slice[0].start, self._slice[1].start,\n                self._slice[0].stop - 1, self._slice[1].stop - 1) * u.pix", "code_tokens": "def bbox ( self ) : # (stop - 1) to return the max pixel location, not the slice index return ( self . _slice [ 0 ] . start , self . _slice [ 1 ] . start , self . _slice [ 0 ] . stop - 1 , self . _slice [ 1 ] . stop - 1 ) * u . pix", "docstring_tokens": "The bounding box ( ymin xmin ymax xmax ) of the minimal rectangular region containing the source segment .", "label": 1}, {"idx": "cosqa-train-6707", "doc": "date to string inpython", "code": "def QA_util_datetime_to_strdate(dt):\n    \"\"\"\n    :param dt:  pythone datetime.datetime\n    :return:  1999-02-01 string type\n    \"\"\"\n    strdate = \"%04d-%02d-%02d\" % (dt.year, dt.month, dt.day)\n    return strdate", "code_tokens": "def QA_util_datetime_to_strdate ( dt ) : strdate = \"%04d-%02d-%02d\" % ( dt . year , dt . month , dt . day ) return strdate", "docstring_tokens": ": param dt : pythone datetime . datetime : return : 1999 - 02 - 01 string type", "label": 1}, {"idx": "cosqa-train-6708", "doc": "python get comma separated data in list", "code": "def vectorize(values):\n    \"\"\"\n    Takes a value or list of values and returns a single result, joined by \",\"\n    if necessary.\n    \"\"\"\n    if isinstance(values, list):\n        return ','.join(str(v) for v in values)\n    return values", "code_tokens": "def vectorize ( values ) : if isinstance ( values , list ) : return ',' . join ( str ( v ) for v in values ) return values", "docstring_tokens": "Takes a value or list of values and returns a single result joined by if necessary .", "label": 0}, {"idx": "cosqa-train-6709", "doc": "datetime list array python", "code": "def get_dt_list(fn_list):\n    \"\"\"Get list of datetime objects, extracted from a filename\n    \"\"\"\n    dt_list = np.array([fn_getdatetime(fn) for fn in fn_list])\n    return dt_list", "code_tokens": "def get_dt_list ( fn_list ) : dt_list = np . array ( [ fn_getdatetime ( fn ) for fn in fn_list ] ) return dt_list", "docstring_tokens": "Get list of datetime objects extracted from a filename", "label": 1}, {"idx": "cosqa-train-6710", "doc": "python get corners of array", "code": "def bbox(img):\n    \"\"\"Find the bounding box around nonzero elements in the given array\n\n    Copied from https://stackoverflow.com/a/31402351/5703449 .\n\n    Returns:\n        rowmin, rowmax, colmin, colmax\n    \"\"\"\n    rows = np.any(img, axis=1)\n    cols = np.any(img, axis=0)\n    rmin, rmax = np.where(rows)[0][[0, -1]]\n    cmin, cmax = np.where(cols)[0][[0, -1]]\n\n    return rmin, rmax, cmin, cmax", "code_tokens": "def bbox ( img ) : rows = np . any ( img , axis = 1 ) cols = np . any ( img , axis = 0 ) rmin , rmax = np . where ( rows ) [ 0 ] [ [ 0 , - 1 ] ] cmin , cmax = np . where ( cols ) [ 0 ] [ [ 0 , - 1 ] ] return rmin , rmax , cmin , cmax", "docstring_tokens": "Find the bounding box around nonzero elements in the given array", "label": 1}, {"idx": "cosqa-train-6711", "doc": "datetime serialize to json python", "code": "def _time_to_json(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\"\"\"\n    if isinstance(value, datetime.time):\n        value = value.isoformat()\n    return value", "code_tokens": "def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 0}, {"idx": "cosqa-train-6712", "doc": "python get days in a month", "code": "def get_month_start_end_day():\n    \"\"\"\n    Get the month start date a nd end date\n    \"\"\"\n    t = date.today()\n    n = mdays[t.month]\n    return (date(t.year, t.month, 1), date(t.year, t.month, n))", "code_tokens": "def get_month_start_end_day ( ) : t = date . today ( ) n = mdays [ t . month ] return ( date ( t . year , t . month , 1 ) , date ( t . year , t . month , n ) )", "docstring_tokens": "Get the month start date a nd end date", "label": 0}, {"idx": "cosqa-train-6713", "doc": "dcm to numpy array python 3", "code": "def _matrix3_to_dcm_array(self, m):\n        \"\"\"\n        Converts Matrix3 in an array\n        :param m: Matrix3\n        :returns: 3x3 array\n        \"\"\"\n        assert(isinstance(m, Matrix3))\n        return np.array([[m.a.x, m.a.y, m.a.z],\n                         [m.b.x, m.b.y, m.b.z],\n                         [m.c.x, m.c.y, m.c.z]])", "code_tokens": "def _matrix3_to_dcm_array ( self , m ) : assert ( isinstance ( m , Matrix3 ) ) return np . array ( [ [ m . a . x , m . a . y , m . a . z ] , [ m . b . x , m . b . y , m . b . z ] , [ m . c . x , m . c . y , m . c . z ] ] )", "docstring_tokens": "Converts Matrix3 in an array : param m : Matrix3 : returns : 3x3 array", "label": 1}, {"idx": "cosqa-train-6714", "doc": "python get device storage size linux", "code": "def current_memory_usage():\n    \"\"\"\n    Returns this programs current memory usage in bytes\n    \"\"\"\n    import psutil\n    proc = psutil.Process(os.getpid())\n    #meminfo = proc.get_memory_info()\n    meminfo = proc.memory_info()\n    rss = meminfo[0]  # Resident Set Size / Mem Usage\n    vms = meminfo[1]  # Virtual Memory Size / VM Size  # NOQA\n    return rss", "code_tokens": "def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss", "docstring_tokens": "Returns this programs current memory usage in bytes", "label": 1}, {"idx": "cosqa-train-6715", "doc": "decision tree python matplotlib", "code": "def human__decision_tree():\n    \"\"\" Decision Tree\n    \"\"\"\n\n    # build data\n    N = 1000000\n    M = 3\n    X = np.zeros((N,M))\n    X.shape\n    y = np.zeros(N)\n    X[0, 0] = 1\n    y[0] = 8\n    X[1, 1] = 1\n    y[1] = 8\n    X[2, 0:2] = 1\n    y[2] = 4\n\n    # fit model\n    xor_model = sklearn.tree.DecisionTreeRegressor(max_depth=2)\n    xor_model.fit(X, y)\n\n    return xor_model", "code_tokens": "def human__decision_tree ( ) : # build data N = 1000000 M = 3 X = np . zeros ( ( N , M ) ) X . shape y = np . zeros ( N ) X [ 0 , 0 ] = 1 y [ 0 ] = 8 X [ 1 , 1 ] = 1 y [ 1 ] = 8 X [ 2 , 0 : 2 ] = 1 y [ 2 ] = 4 # fit model xor_model = sklearn . tree . DecisionTreeRegressor ( max_depth = 2 ) xor_model . fit ( X , y ) return xor_model", "docstring_tokens": "Decision Tree", "label": 0}, {"idx": "cosqa-train-6716", "doc": "python get dictionary value by key with default", "code": "def get_value(key, obj, default=missing):\n    \"\"\"Helper for pulling a keyed value off various types of objects\"\"\"\n    if isinstance(key, int):\n        return _get_value_for_key(key, obj, default)\n    return _get_value_for_keys(key.split('.'), obj, default)", "code_tokens": "def get_value ( key , obj , default = missing ) : if isinstance ( key , int ) : return _get_value_for_key ( key , obj , default ) return _get_value_for_keys ( key . split ( '.' ) , obj , default )", "docstring_tokens": "Helper for pulling a keyed value off various types of objects", "label": 1}, {"idx": "cosqa-train-6717", "doc": "declaring a variable as a dictionary python", "code": "def conv_dict(self):\n        \"\"\"dictionary of conversion\"\"\"\n        return dict(integer=self.integer, real=self.real, no_type=self.no_type)", "code_tokens": "def conv_dict ( self ) : return dict ( integer = self . integer , real = self . real , no_type = self . no_type )", "docstring_tokens": "dictionary of conversion", "label": 1}, {"idx": "cosqa-train-6718", "doc": "python get elelemnts by name", "code": "def get_by(self, name):\n    \"\"\"get element by name\"\"\"\n    return next((item for item in self if item.name == name), None)", "code_tokens": "def get_by ( self , name ) : return next ( ( item for item in self if item . name == name ) , None )", "docstring_tokens": "get element by name", "label": 0}, {"idx": "cosqa-train-6719", "doc": "declaring multiple empty strings in python", "code": "def join(mapping, bind, values):\n    \"\"\" Merge all the strings. Put space between them. \"\"\"\n    return [' '.join([six.text_type(v) for v in values if v is not None])]", "code_tokens": "def join ( mapping , bind , values ) : return [ ' ' . join ( [ six . text_type ( v ) for v in values if v is not None ] ) ]", "docstring_tokens": "Merge all the strings . Put space between them .", "label": 0}, {"idx": "cosqa-train-6720", "doc": "python get fields of pdf", "code": "def security(self):\n        \"\"\"Print security object information for a pdf document\"\"\"\n        return {k: v for i in self.pdf.resolvedObjects.items() for k, v in i[1].items()}", "code_tokens": "def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "docstring_tokens": "Print security object information for a pdf document", "label": 0}, {"idx": "cosqa-train-6721", "doc": "default value passed to a function in python", "code": "def arg_default(*args, **kwargs):\n    \"\"\"Return default argument value as given by argparse's add_argument().\n\n    The argument is passed through a mocked-up argument parser. This way, we\n    get default parameters even if the feature is called directly and not\n    through the CLI.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(*args, **kwargs)\n    args = vars(parser.parse_args([]))\n    _, default = args.popitem()\n    return default", "code_tokens": "def arg_default ( * args , * * kwargs ) : parser = argparse . ArgumentParser ( ) parser . add_argument ( * args , * * kwargs ) args = vars ( parser . parse_args ( [ ] ) ) _ , default = args . popitem ( ) return default", "docstring_tokens": "Return default argument value as given by argparse s add_argument () .", "label": 0}, {"idx": "cosqa-train-6722", "doc": "python get file absolute self path", "code": "def base_path(self):\n        \"\"\"Base absolute path of container.\"\"\"\n        return os.path.join(self.container.base_path, self.name)", "code_tokens": "def base_path ( self ) : return os . path . join ( self . container . base_path , self . name )", "docstring_tokens": "Base absolute path of container .", "label": 1}, {"idx": "cosqa-train-6723", "doc": "define dtype of ndarray in python", "code": "def dict_to_numpy_array(d):\n    \"\"\"\n    Convert a dict of 1d array to a numpy recarray\n    \"\"\"\n    return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))", "code_tokens": "def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )", "docstring_tokens": "Convert a dict of 1d array to a numpy recarray", "label": 0}, {"idx": "cosqa-train-6724", "doc": "defining global variables in python to use in def", "code": "def set_global(node: Node, key: str, value: Any):\n    \"\"\"Adds passed value to node's globals\"\"\"\n    node.node_globals[key] = value", "code_tokens": "def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "docstring_tokens": "Adds passed value to node s globals", "label": 0}, {"idx": "cosqa-train-6725", "doc": "python get file that are not duplicated", "code": "def _remove_duplicate_files(xs):\n    \"\"\"Remove files specified multiple times in a list.\n    \"\"\"\n    seen = set([])\n    out = []\n    for x in xs:\n        if x[\"path\"] not in seen:\n            out.append(x)\n            seen.add(x[\"path\"])\n    return out", "code_tokens": "def _remove_duplicate_files ( xs ) : seen = set ( [ ] ) out = [ ] for x in xs : if x [ \"path\" ] not in seen : out . append ( x ) seen . add ( x [ \"path\" ] ) return out", "docstring_tokens": "Remove files specified multiple times in a list .", "label": 1}, {"idx": "cosqa-train-6726", "doc": "delete a virtual env in python", "code": "def rm(venv_name):\n    \"\"\" Removes the venv by name \"\"\"\n    inenv = InenvManager()\n    venv = inenv.get_venv(venv_name)\n    click.confirm(\"Delete dir {}\".format(venv.path))\n    shutil.rmtree(venv.path)", "code_tokens": "def rm ( venv_name ) : inenv = InenvManager ( ) venv = inenv . get_venv ( venv_name ) click . confirm ( \"Delete dir {}\" . format ( venv . path ) ) shutil . rmtree ( venv . path )", "docstring_tokens": "Removes the venv by name", "label": 1}, {"idx": "cosqa-train-6727", "doc": "delete contents of a text file in python open file", "code": "def delete(filething):\n    \"\"\"Remove tags from a file.\n\n    Args:\n        filething (filething)\n    Raises:\n        mutagen.MutagenError\n    \"\"\"\n\n    f = FLAC(filething)\n    filething.fileobj.seek(0)\n    f.delete(filething)", "code_tokens": "def delete ( filething ) : f = FLAC ( filething ) filething . fileobj . seek ( 0 ) f . delete ( filething )", "docstring_tokens": "Remove tags from a file .", "label": 0}, {"idx": "cosqa-train-6728", "doc": "python get first element condition", "code": "def findfirst(f, coll):\n    \"\"\"Return first occurrence matching f, otherwise None\"\"\"\n    result = list(dropwhile(f, coll))\n    return result[0] if result else None", "code_tokens": "def findfirst ( f , coll ) : result = list ( dropwhile ( f , coll ) ) return result [ 0 ] if result else None", "docstring_tokens": "Return first occurrence matching f otherwise None", "label": 0}, {"idx": "cosqa-train-6729", "doc": "delete items from index python", "code": "def clear_es():\n        \"\"\"Clear all indexes in the es core\"\"\"\n        # TODO: should receive a catalog slug.\n        ESHypermap.es.indices.delete(ESHypermap.index_name, ignore=[400, 404])\n        LOGGER.debug('Elasticsearch: Index cleared')", "code_tokens": "def clear_es ( ) : # TODO: should receive a catalog slug. ESHypermap . es . indices . delete ( ESHypermap . index_name , ignore = [ 400 , 404 ] ) LOGGER . debug ( 'Elasticsearch: Index cleared' )", "docstring_tokens": "Clear all indexes in the es core", "label": 1}, {"idx": "cosqa-train-6730", "doc": "python get first object in a list", "code": "def findfirst(f, coll):\n    \"\"\"Return first occurrence matching f, otherwise None\"\"\"\n    result = list(dropwhile(f, coll))\n    return result[0] if result else None", "code_tokens": "def findfirst ( f , coll ) : result = list ( dropwhile ( f , coll ) ) return result [ 0 ] if result else None", "docstring_tokens": "Return first occurrence matching f otherwise None", "label": 1}, {"idx": "cosqa-train-6731", "doc": "deleting a folder if it is empty python", "code": "def safe_rmtree(directory):\n  \"\"\"Delete a directory if it's present. If it's not present, no-op.\"\"\"\n  if os.path.exists(directory):\n    shutil.rmtree(directory, True)", "code_tokens": "def safe_rmtree ( directory ) : if os . path . exists ( directory ) : shutil . rmtree ( directory , True )", "docstring_tokens": "Delete a directory if it s present . If it s not present no - op .", "label": 0}, {"idx": "cosqa-train-6732", "doc": "python get function keyword names", "code": "def parse_func_kwarg_keys(func, with_vals=False):\n    \"\"\" hacky inference of kwargs keys\n\n    SeeAlso:\n        argparse_funckw\n        recursive_parse_kwargs\n        parse_kwarg_keys\n        parse_func_kwarg_keys\n        get_func_kwargs\n\n    \"\"\"\n    sourcecode = get_func_sourcecode(func, strip_docstr=True,\n                                     strip_comments=True)\n    kwkeys = parse_kwarg_keys(sourcecode, with_vals=with_vals)\n    #ut.get_func_kwargs  TODO\n    return kwkeys", "code_tokens": "def parse_func_kwarg_keys ( func , with_vals = False ) : sourcecode = get_func_sourcecode ( func , strip_docstr = True , strip_comments = True ) kwkeys = parse_kwarg_keys ( sourcecode , with_vals = with_vals ) #ut.get_func_kwargs  TODO return kwkeys", "docstring_tokens": "hacky inference of kwargs keys", "label": 1}, {"idx": "cosqa-train-6733", "doc": "design hit counter python", "code": "def counter(items):\n    \"\"\"\n    Simplest required implementation of collections.Counter. Required as 2.6\n    does not have Counter in collections.\n    \"\"\"\n    results = {}\n    for item in items:\n        results[item] = results.get(item, 0) + 1\n    return results", "code_tokens": "def counter ( items ) : results = { } for item in items : results [ item ] = results . get ( item , 0 ) + 1 return results", "docstring_tokens": "Simplest required implementation of collections . Counter . Required as 2 . 6 does not have Counter in collections .", "label": 1}, {"idx": "cosqa-train-6734", "doc": "python get index of element equal to", "code": "def percentile_index(a, q):\n    \"\"\"\n    Returns the index of the value at the Qth percentile in array a.\n    \"\"\"\n    return np.where(\n        a==np.percentile(a, q, interpolation='nearest')\n    )[0][0]", "code_tokens": "def percentile_index ( a , q ) : return np . where ( a == np . percentile ( a , q , interpolation = 'nearest' ) ) [ 0 ] [ 0 ]", "docstring_tokens": "Returns the index of the value at the Qth percentile in array a .", "label": 1}, {"idx": "cosqa-train-6735", "doc": "destination host unreachable ping python", "code": "def pingback_url(self, server_name, target_url):\n        \"\"\"\n        Do a pingback call for the target URL.\n        \"\"\"\n        try:\n            server = ServerProxy(server_name)\n            reply = server.pingback.ping(self.entry_url, target_url)\n        except (Error, socket.error):\n            reply = '%s cannot be pinged.' % target_url\n        return reply", "code_tokens": "def pingback_url ( self , server_name , target_url ) : try : server = ServerProxy ( server_name ) reply = server . pingback . ping ( self . entry_url , target_url ) except ( Error , socket . error ) : reply = '%s cannot be pinged.' % target_url return reply", "docstring_tokens": "Do a pingback call for the target URL .", "label": 0}, {"idx": "cosqa-train-6736", "doc": "python get java absolute path", "code": "def get_java_path():\n  \"\"\"Get the path of java executable\"\"\"\n  java_home = os.environ.get(\"JAVA_HOME\")\n  return os.path.join(java_home, BIN_DIR, \"java\")", "code_tokens": "def get_java_path ( ) : java_home = os . environ . get ( \"JAVA_HOME\" ) return os . path . join ( java_home , BIN_DIR , \"java\" )", "docstring_tokens": "Get the path of java executable", "label": 1}, {"idx": "cosqa-train-6737", "doc": "detect angle and rotate image in python", "code": "def rotateImage(img, angle):\n    \"\"\"\n\n    querries scipy.ndimage.rotate routine\n    :param img: image to be rotated\n    :param angle: angle to be rotated (radian)\n    :return: rotated image\n    \"\"\"\n    imgR = scipy.ndimage.rotate(img, angle, reshape=False)\n    return imgR", "code_tokens": "def rotateImage ( img , angle ) : imgR = scipy . ndimage . rotate ( img , angle , reshape = False ) return imgR", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-6738", "doc": "python get last line of git log file", "code": "def get_last_commit_line(git_path=None):\n    \"\"\"\n    Get one-line description of HEAD commit for repository in current dir.\n    \"\"\"\n    if git_path is None: git_path = GIT_PATH\n    output = check_output([git_path, \"log\", \"--pretty=format:'%ad %h %s'\",\n                           \"--date=short\", \"-n1\"])\n    return output.strip()[1:-1]", "code_tokens": "def get_last_commit_line ( git_path = None ) : if git_path is None : git_path = GIT_PATH output = check_output ( [ git_path , \"log\" , \"--pretty=format:'%ad %h %s'\" , \"--date=short\" , \"-n1\" ] ) return output . strip ( ) [ 1 : - 1 ]", "docstring_tokens": "Get one - line description of HEAD commit for repository in current dir .", "label": 0}, {"idx": "cosqa-train-6739", "doc": "detemine intensity black and white image python", "code": "def lighting(im, b, c):\n    \"\"\" Adjust image balance and contrast \"\"\"\n    if b==0 and c==1: return im\n    mu = np.average(im)\n    return np.clip((im-mu)*c+mu+b,0.,1.).astype(np.float32)", "code_tokens": "def lighting ( im , b , c ) : if b == 0 and c == 1 : return im mu = np . average ( im ) return np . clip ( ( im - mu ) * c + mu + b , 0. , 1. ) . astype ( np . float32 )", "docstring_tokens": "Adjust image balance and contrast", "label": 1}, {"idx": "cosqa-train-6740", "doc": "python get last modified time", "code": "def last_modified_date(filename):\n    \"\"\"Last modified timestamp as a UTC datetime\"\"\"\n    mtime = os.path.getmtime(filename)\n    dt = datetime.datetime.utcfromtimestamp(mtime)\n    return dt.replace(tzinfo=pytz.utc)", "code_tokens": "def last_modified_date ( filename ) : mtime = os . path . getmtime ( filename ) dt = datetime . datetime . utcfromtimestamp ( mtime ) return dt . replace ( tzinfo = pytz . utc )", "docstring_tokens": "Last modified timestamp as a UTC datetime", "label": 1}, {"idx": "cosqa-train-6741", "doc": "determine if datetime type python", "code": "def is_date_type(cls):\n    \"\"\"Return True if the class is a date type.\"\"\"\n    if not isinstance(cls, type):\n        return False\n    return issubclass(cls, date) and not issubclass(cls, datetime)", "code_tokens": "def is_date_type ( cls ) : if not isinstance ( cls , type ) : return False return issubclass ( cls , date ) and not issubclass ( cls , datetime )", "docstring_tokens": "Return True if the class is a date type .", "label": 1}, {"idx": "cosqa-train-6742", "doc": "python get last monday", "code": "def prevmonday(num):\n    \"\"\"\n    Return unix SECOND timestamp of \"num\" mondays ago\n    \"\"\"\n    today = get_today()\n    lastmonday = today - timedelta(days=today.weekday(), weeks=num)\n    return lastmonday", "code_tokens": "def prevmonday ( num ) : today = get_today ( ) lastmonday = today - timedelta ( days = today . weekday ( ) , weeks = num ) return lastmonday", "docstring_tokens": "Return unix SECOND timestamp of num mondays ago", "label": 1}, {"idx": "cosqa-train-6743", "doc": "determine string only lower case python", "code": "def clean(some_string, uppercase=False):\n    \"\"\"\n    helper to clean up an input string\n    \"\"\"\n    if uppercase:\n        return some_string.strip().upper()\n    else:\n        return some_string.strip().lower()", "code_tokens": "def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )", "docstring_tokens": "helper to clean up an input string", "label": 1}, {"idx": "cosqa-train-6744", "doc": "python get length of string of every words", "code": "def display_len(text):\n    \"\"\"\n    Get the display length of a string. This can differ from the character\n    length if the string contains wide characters.\n    \"\"\"\n    text = unicodedata.normalize('NFD', text)\n    return sum(char_width(char) for char in text)", "code_tokens": "def display_len ( text ) : text = unicodedata . normalize ( 'NFD' , text ) return sum ( char_width ( char ) for char in text )", "docstring_tokens": "Get the display length of a string . This can differ from the character length if the string contains wide characters .", "label": 1}, {"idx": "cosqa-train-6745", "doc": "determine the longest sentence in corpus in nlp python ocde", "code": "def get_longest_orf(orfs):\n    \"\"\"Find longest ORF from the given list of ORFs.\"\"\"\n    sorted_orf = sorted(orfs, key=lambda x: len(x['sequence']), reverse=True)[0]\n    return sorted_orf", "code_tokens": "def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf", "docstring_tokens": "Find longest ORF from the given list of ORFs .", "label": 1}, {"idx": "cosqa-train-6746", "doc": "python get linux memory utilization", "code": "def get_shared_memory_bytes():\n    \"\"\"Get the size of the shared memory file system.\n\n    Returns:\n        The size of the shared memory file system in bytes.\n    \"\"\"\n    # Make sure this is only called on Linux.\n    assert sys.platform == \"linux\" or sys.platform == \"linux2\"\n\n    shm_fd = os.open(\"/dev/shm\", os.O_RDONLY)\n    try:\n        shm_fs_stats = os.fstatvfs(shm_fd)\n        # The value shm_fs_stats.f_bsize is the block size and the\n        # value shm_fs_stats.f_bavail is the number of available\n        # blocks.\n        shm_avail = shm_fs_stats.f_bsize * shm_fs_stats.f_bavail\n    finally:\n        os.close(shm_fd)\n\n    return shm_avail", "code_tokens": "def get_shared_memory_bytes ( ) : # Make sure this is only called on Linux. assert sys . platform == \"linux\" or sys . platform == \"linux2\" shm_fd = os . open ( \"/dev/shm\" , os . O_RDONLY ) try : shm_fs_stats = os . fstatvfs ( shm_fd ) # The value shm_fs_stats.f_bsize is the block size and the # value shm_fs_stats.f_bavail is the number of available # blocks. shm_avail = shm_fs_stats . f_bsize * shm_fs_stats . f_bavail finally : os . close ( shm_fd ) return shm_avail", "docstring_tokens": "Get the size of the shared memory file system .", "label": 0}, {"idx": "cosqa-train-6747", "doc": "determine the quarter in python based on a start date", "code": "def previous_quarter(d):\n    \"\"\"\n    Retrieve the previous quarter for dt\n    \"\"\"\n    from django_toolkit.datetime_util import quarter as datetime_quarter\n    return quarter( (datetime_quarter(datetime(d.year, d.month, d.day))[0] + timedelta(days=-1)).date() )", "code_tokens": "def previous_quarter ( d ) : from django_toolkit . datetime_util import quarter as datetime_quarter return quarter ( ( datetime_quarter ( datetime ( d . year , d . month , d . day ) ) [ 0 ] + timedelta ( days = - 1 ) ) . date ( ) )", "docstring_tokens": "Retrieve the previous quarter for dt", "label": 0}, {"idx": "cosqa-train-6748", "doc": "python get list of methods on object", "code": "def get_methods(*objs):\n    \"\"\" Return the names of all callable attributes of an object\"\"\"\n    return set(\n        attr\n        for obj in objs\n        for attr in dir(obj)\n        if not attr.startswith('_') and callable(getattr(obj, attr))\n    )", "code_tokens": "def get_methods ( * objs ) : return set ( attr for obj in objs for attr in dir ( obj ) if not attr . startswith ( '_' ) and callable ( getattr ( obj , attr ) ) )", "docstring_tokens": "Return the names of all callable attributes of an object", "label": 1}, {"idx": "cosqa-train-6749", "doc": "determining number of bins for histogram python", "code": "def _histplot_bins(column, bins=100):\n    \"\"\"Helper to get bins for histplot.\"\"\"\n    col_min = np.min(column)\n    col_max = np.max(column)\n    return range(col_min, col_max + 2, max((col_max - col_min) // bins, 1))", "code_tokens": "def _histplot_bins ( column , bins = 100 ) : col_min = np . min ( column ) col_max = np . max ( column ) return range ( col_min , col_max + 2 , max ( ( col_max - col_min ) // bins , 1 ) )", "docstring_tokens": "Helper to get bins for histplot .", "label": 1}, {"idx": "cosqa-train-6750", "doc": "python get modified date", "code": "def last_modified_date(filename):\n    \"\"\"Last modified timestamp as a UTC datetime\"\"\"\n    mtime = os.path.getmtime(filename)\n    dt = datetime.datetime.utcfromtimestamp(mtime)\n    return dt.replace(tzinfo=pytz.utc)", "code_tokens": "def last_modified_date ( filename ) : mtime = os . path . getmtime ( filename ) dt = datetime . datetime . utcfromtimestamp ( mtime ) return dt . replace ( tzinfo = pytz . utc )", "docstring_tokens": "Last modified timestamp as a UTC datetime", "label": 1}, {"idx": "cosqa-train-6751", "doc": "dictionary with multilist in python", "code": "def multidict_to_dict(d):\n    \"\"\"\n    Turns a werkzeug.MultiDict or django.MultiValueDict into a dict with\n    list values\n    :param d: a MultiDict or MultiValueDict instance\n    :return: a dict instance\n    \"\"\"\n    return dict((k, v[0] if len(v) == 1 else v) for k, v in iterlists(d))", "code_tokens": "def multidict_to_dict ( d ) : return dict ( ( k , v [ 0 ] if len ( v ) == 1 else v ) for k , v in iterlists ( d ) )", "docstring_tokens": "Turns a werkzeug . MultiDict or django . MultiValueDict into a dict with list values : param d : a MultiDict or MultiValueDict instance : return : a dict instance", "label": 1}, {"idx": "cosqa-train-6752", "doc": "python get numeric group id for group name", "code": "def _get_gid(name):\n    \"\"\"Returns a gid, given a group name.\"\"\"\n    if getgrnam is None or name is None:\n        return None\n    try:\n        result = getgrnam(name)\n    except KeyError:\n        result = None\n    if result is not None:\n        return result[2]\n    return None", "code_tokens": "def _get_gid ( name ) : if getgrnam is None or name is None : return None try : result = getgrnam ( name ) except KeyError : result = None if result is not None : return result [ 2 ] return None", "docstring_tokens": "Returns a gid given a group name .", "label": 0}, {"idx": "cosqa-train-6753", "doc": "direct python output to screen", "code": "def stdout_display():\n    \"\"\" Print results straight to stdout \"\"\"\n    if sys.version_info[0] == 2:\n        yield SmartBuffer(sys.stdout)\n    else:\n        yield SmartBuffer(sys.stdout.buffer)", "code_tokens": "def stdout_display ( ) : if sys . version_info [ 0 ] == 2 : yield SmartBuffer ( sys . stdout ) else : yield SmartBuffer ( sys . stdout . buffer )", "docstring_tokens": "Print results straight to stdout", "label": 1}, {"idx": "cosqa-train-6754", "doc": "python get object through id", "code": "def retrieve_by_id(self, id_):\n        \"\"\"Return a JSSObject for the element with ID id_\"\"\"\n        items_with_id = [item for item in self if item.id == int(id_)]\n        if len(items_with_id) == 1:\n            return items_with_id[0].retrieve()", "code_tokens": "def retrieve_by_id ( self , id_ ) : items_with_id = [ item for item in self if item . id == int ( id_ ) ] if len ( items_with_id ) == 1 : return items_with_id [ 0 ] . retrieve ( )", "docstring_tokens": "Return a JSSObject for the element with ID id_", "label": 0}, {"idx": "cosqa-train-6755", "doc": "discord bot delete message python", "code": "async def delete(self):\n        \"\"\"\n        Delete this message\n\n        :return: bool\n        \"\"\"\n        return await self.bot.delete_message(self.chat.id, self.message_id)", "code_tokens": "async def delete ( self ) : return await self . bot . delete_message ( self . chat . id , self . message_id )", "docstring_tokens": "Delete this message", "label": 1}, {"idx": "cosqa-train-6756", "doc": "python get part region of image", "code": "def border(self):\n        \"\"\"Region formed by taking border elements.\n\n        :returns: :class:`jicimagelib.region.Region`\n        \"\"\"\n\n        border_array = self.bitmap - self.inner.bitmap\n        return Region(border_array)", "code_tokens": "def border ( self ) : border_array = self . bitmap - self . inner . bitmap return Region ( border_array )", "docstring_tokens": "Region formed by taking border elements .", "label": 0}, {"idx": "cosqa-train-6757", "doc": "discover file extension python", "code": "def _get_compiled_ext():\n    \"\"\"Official way to get the extension of compiled files (.pyc or .pyo)\"\"\"\n    for ext, mode, typ in imp.get_suffixes():\n        if typ == imp.PY_COMPILED:\n            return ext", "code_tokens": "def _get_compiled_ext ( ) : for ext , mode , typ in imp . get_suffixes ( ) : if typ == imp . PY_COMPILED : return ext", "docstring_tokens": "Official way to get the extension of compiled files ( . pyc or . pyo )", "label": 1}, {"idx": "cosqa-train-6758", "doc": "python get process memory info", "code": "def machine_info():\n    \"\"\"Retrieve core and memory information for the current machine.\n    \"\"\"\n    import psutil\n    BYTES_IN_GIG = 1073741824.0\n    free_bytes = psutil.virtual_memory().total\n    return [{\"memory\": float(\"%.1f\" % (free_bytes / BYTES_IN_GIG)), \"cores\": multiprocessing.cpu_count(),\n             \"name\": socket.gethostname()}]", "code_tokens": "def machine_info ( ) : import psutil BYTES_IN_GIG = 1073741824.0 free_bytes = psutil . virtual_memory ( ) . total return [ { \"memory\" : float ( \"%.1f\" % ( free_bytes / BYTES_IN_GIG ) ) , \"cores\" : multiprocessing . cpu_count ( ) , \"name\" : socket . gethostname ( ) } ]", "docstring_tokens": "Retrieve core and memory information for the current machine .", "label": 1}, {"idx": "cosqa-train-6759", "doc": "display column names in sql python", "code": "def column_names(self, table):\n      \"\"\"An iterable of column names, for a particular table or\n      view.\"\"\"\n\n      table_info = self.execute(\n        u'PRAGMA table_info(%s)' % quote(table))\n      return (column['name'] for column in table_info)", "code_tokens": "def column_names ( self , table ) : table_info = self . execute ( u'PRAGMA table_info(%s)' % quote ( table ) ) return ( column [ 'name' ] for column in table_info )", "docstring_tokens": "An iterable of column names for a particular table or view .", "label": 0}, {"idx": "cosqa-train-6760", "doc": "python get rid of comments in json string", "code": "def strip_comments(string, comment_symbols=frozenset(('#', '//'))):\n    \"\"\"Strip comments from json string.\n\n    :param string: A string containing json with comments started by comment_symbols.\n    :param comment_symbols: Iterable of symbols that start a line comment (default # or //).\n    :return: The string with the comments removed.\n    \"\"\"\n    lines = string.splitlines()\n    for k in range(len(lines)):\n        for symbol in comment_symbols:\n            lines[k] = strip_comment_line_with_symbol(lines[k], start=symbol)\n    return '\\n'.join(lines)", "code_tokens": "def strip_comments ( string , comment_symbols = frozenset ( ( '#' , '//' ) ) ) : lines = string . splitlines ( ) for k in range ( len ( lines ) ) : for symbol in comment_symbols : lines [ k ] = strip_comment_line_with_symbol ( lines [ k ] , start = symbol ) return '\\n' . join ( lines )", "docstring_tokens": "Strip comments from json string .", "label": 1}, {"idx": "cosqa-train-6761", "doc": "display python output in real time php", "code": "def stdout_display():\n    \"\"\" Print results straight to stdout \"\"\"\n    if sys.version_info[0] == 2:\n        yield SmartBuffer(sys.stdout)\n    else:\n        yield SmartBuffer(sys.stdout.buffer)", "code_tokens": "def stdout_display ( ) : if sys . version_info [ 0 ] == 2 : yield SmartBuffer ( sys . stdout ) else : yield SmartBuffer ( sys . stdout . buffer )", "docstring_tokens": "Print results straight to stdout", "label": 1}, {"idx": "cosqa-train-6762", "doc": "python get rid of new line character after a string", "code": "def get_line_ending(line):\n    \"\"\"Return line ending.\"\"\"\n    non_whitespace_index = len(line.rstrip()) - len(line)\n    if not non_whitespace_index:\n        return ''\n    else:\n        return line[non_whitespace_index:]", "code_tokens": "def get_line_ending ( line ) : non_whitespace_index = len ( line . rstrip ( ) ) - len ( line ) if not non_whitespace_index : return '' else : return line [ non_whitespace_index : ]", "docstring_tokens": "Return line ending .", "label": 1}, {"idx": "cosqa-train-6763", "doc": "display the value of tensor in tensorflow python", "code": "def Print(x, data, message, **kwargs):  # pylint: disable=invalid-name\n  \"\"\"Call tf.Print.\n\n  Args:\n    x: a Tensor.\n    data: a list of Tensor\n    message: a string\n    **kwargs: keyword arguments to tf.Print\n  Returns:\n    a Tensor which is identical in value to x\n  \"\"\"\n  return PrintOperation(x, data, message, **kwargs).outputs[0]", "code_tokens": "def Print ( x , data , message , * * kwargs ) : # pylint: disable=invalid-name return PrintOperation ( x , data , message , * * kwargs ) . outputs [ 0 ]", "docstring_tokens": "Call tf . Print .", "label": 0}, {"idx": "cosqa-train-6764", "doc": "python get screen resolution", "code": "def getScreenDims(self):\n        \"\"\"returns a tuple that contains (screen_width,screen_height)\n        \"\"\"\n        width = ale_lib.getScreenWidth(self.obj)\n        height = ale_lib.getScreenHeight(self.obj)\n        return (width,height)", "code_tokens": "def getScreenDims ( self ) : width = ale_lib . getScreenWidth ( self . obj ) height = ale_lib . getScreenHeight ( self . obj ) return ( width , height )", "docstring_tokens": "returns a tuple that contains ( screen_width screen_height )", "label": 1}, {"idx": "cosqa-train-6765", "doc": "display time taken in minutes and seconds python", "code": "def pprint(self, seconds):\n        \"\"\"\n        Pretty Prints seconds as Hours:Minutes:Seconds.MilliSeconds\n\n        :param seconds:  The time in seconds.\n        \"\"\"\n        return (\"%d:%02d:%02d.%03d\", reduce(lambda ll, b: divmod(ll[0], b) + ll[1:], [(seconds * 1000,), 1000, 60, 60]))", "code_tokens": "def pprint ( self , seconds ) : return ( \"%d:%02d:%02d.%03d\" , reduce ( lambda ll , b : divmod ( ll [ 0 ] , b ) + ll [ 1 : ] , [ ( seconds * 1000 , ) , 1000 , 60 , 60 ] ) )", "docstring_tokens": "Pretty Prints seconds as Hours : Minutes : Seconds . MilliSeconds", "label": 1}, {"idx": "cosqa-train-6766", "doc": "python get shelve keys", "code": "def get_keys_from_shelve(file_name, file_location):\n    \"\"\"\n    Function to retreive all keys in a shelve\n    Args:\n        file_name: Shelve storage file name\n        file_location: The location of the file, derive from the os module\n\n    Returns:\n        a list of the keys\n\n    \"\"\"\n    temp_list = list()\n    file = __os.path.join(file_location, file_name)\n    shelve_store = __shelve.open(file)\n    for key in shelve_store:\n        temp_list.append(key)\n    shelve_store.close()\n    return temp_list", "code_tokens": "def get_keys_from_shelve ( file_name , file_location ) : temp_list = list ( ) file = __os . path . join ( file_location , file_name ) shelve_store = __shelve . open ( file ) for key in shelve_store : temp_list . append ( key ) shelve_store . close ( ) return temp_list", "docstring_tokens": "Function to retreive all keys in a shelve Args : file_name : Shelve storage file name file_location : The location of the file derive from the os module", "label": 1}, {"idx": "cosqa-train-6767", "doc": "display top 2 sum in column python", "code": "def table_top_abs(self):\n        \"\"\"Returns the absolute position of table top\"\"\"\n        table_height = np.array([0, 0, self.table_full_size[2]])\n        return string_to_array(self.floor.get(\"pos\")) + table_height", "code_tokens": "def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( \"pos\" ) ) + table_height", "docstring_tokens": "Returns the absolute position of table top", "label": 0}, {"idx": "cosqa-train-6768", "doc": "python get size from file object", "code": "def file_length(file_obj):\n    \"\"\"\n    Returns the length in bytes of a given file object.\n    Necessary because os.fstat only works on real files and not file-like\n    objects. This works on more types of streams, primarily StringIO.\n    \"\"\"\n    file_obj.seek(0, 2)\n    length = file_obj.tell()\n    file_obj.seek(0)\n    return length", "code_tokens": "def file_length ( file_obj ) : file_obj . seek ( 0 , 2 ) length = file_obj . tell ( ) file_obj . seek ( 0 ) return length", "docstring_tokens": "Returns the length in bytes of a given file object . Necessary because os . fstat only works on real files and not file - like objects . This works on more types of streams primarily StringIO .", "label": 1}, {"idx": "cosqa-train-6769", "doc": "python get size of queue", "code": "def qsize(self):\n        \"\"\"Return the approximate size of the queue (not reliable!).\"\"\"\n        self.mutex.acquire()\n        n = self._qsize()\n        self.mutex.release()\n        return n", "code_tokens": "def qsize ( self ) : self . mutex . acquire ( ) n = self . _qsize ( ) self . mutex . release ( ) return n", "docstring_tokens": "Return the approximate size of the queue ( not reliable! ) .", "label": 0}, {"idx": "cosqa-train-6770", "doc": "distance between 2 strings python", "code": "def hamming_distance(str1, str2):\n    \"\"\"Calculate the Hamming distance between two bit strings\n\n    Args:\n        str1 (str): First string.\n        str2 (str): Second string.\n    Returns:\n        int: Distance between strings.\n    Raises:\n        VisualizationError: Strings not same length\n    \"\"\"\n    if len(str1) != len(str2):\n        raise VisualizationError('Strings not same length.')\n    return sum(s1 != s2 for s1, s2 in zip(str1, str2))", "code_tokens": "def hamming_distance ( str1 , str2 ) : if len ( str1 ) != len ( str2 ) : raise VisualizationError ( 'Strings not same length.' ) return sum ( s1 != s2 for s1 , s2 in zip ( str1 , str2 ) )", "docstring_tokens": "Calculate the Hamming distance between two bit strings", "label": 1}, {"idx": "cosqa-train-6771", "doc": "python get skimage coordinate of max value", "code": "def max(self):\n        \"\"\"\n        The maximum integer value of a value-set. It is only defined when there is exactly one region.\n\n        :return: A integer that represents the maximum integer value of this value-set.\n        :rtype:  int\n        \"\"\"\n\n        if len(self.regions) != 1:\n            raise ClaripyVSAOperationError(\"'max()' onlly works on single-region value-sets.\")\n\n        return self.get_si(next(iter(self.regions))).max", "code_tokens": "def max ( self ) : if len ( self . regions ) != 1 : raise ClaripyVSAOperationError ( \"'max()' onlly works on single-region value-sets.\" ) return self . get_si ( next ( iter ( self . regions ) ) ) . max", "docstring_tokens": "The maximum integer value of a value - set . It is only defined when there is exactly one region .", "label": 1}, {"idx": "cosqa-train-6772", "doc": "divide a string into 5 letter blocks python", "code": "def group(data, num):\n    \"\"\" Split data into chunks of num chars each \"\"\"\n    return [data[i:i+num] for i in range(0, len(data), num)]", "code_tokens": "def group ( data , num ) : return [ data [ i : i + num ] for i in range ( 0 , len ( data ) , num ) ]", "docstring_tokens": "Split data into chunks of num chars each", "label": 1}, {"idx": "cosqa-train-6773", "doc": "python get str from type", "code": "def check_str(obj):\n        \"\"\" Returns a string for various input types \"\"\"\n        if isinstance(obj, str):\n            return obj\n        if isinstance(obj, float):\n            return str(int(obj))\n        else:\n            return str(obj)", "code_tokens": "def check_str ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , float ) : return str ( int ( obj ) ) else : return str ( obj )", "docstring_tokens": "Returns a string for various input types", "label": 0}, {"idx": "cosqa-train-6774", "doc": "divide string into n parts python", "code": "def _split_str(s, n):\n    \"\"\"\n    split string into list of strings by specified number.\n    \"\"\"\n    length = len(s)\n    return [s[i:i + n] for i in range(0, length, n)]", "code_tokens": "def _split_str ( s , n ) : length = len ( s ) return [ s [ i : i + n ] for i in range ( 0 , length , n ) ]", "docstring_tokens": "split string into list of strings by specified number .", "label": 1}, {"idx": "cosqa-train-6775", "doc": "python get string representation of int in base", "code": "def int2str(num, radix=10, alphabet=BASE85):\n    \"\"\"helper function for quick base conversions from integers to strings\"\"\"\n    return NumConv(radix, alphabet).int2str(num)", "code_tokens": "def int2str ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . int2str ( num )", "docstring_tokens": "helper function for quick base conversions from integers to strings", "label": 1}, {"idx": "cosqa-train-6776", "doc": "dividing a string into multiple sentences python", "code": "def split_into_sentences(s):\n  \"\"\"Split text into list of sentences.\"\"\"\n  s = re.sub(r\"\\s+\", \" \", s)\n  s = re.sub(r\"[\\\\.\\\\?\\\\!]\", \"\\n\", s)\n  return s.split(\"\\n\")", "code_tokens": "def split_into_sentences ( s ) : s = re . sub ( r\"\\s+\" , \" \" , s ) s = re . sub ( r\"[\\\\.\\\\?\\\\!]\" , \"\\n\" , s ) return s . split ( \"\\n\" )", "docstring_tokens": "Split text into list of sentences .", "label": 0}, {"idx": "cosqa-train-6777", "doc": "python get structure of pdf", "code": "def security(self):\n        \"\"\"Print security object information for a pdf document\"\"\"\n        return {k: v for i in self.pdf.resolvedObjects.items() for k, v in i[1].items()}", "code_tokens": "def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "docstring_tokens": "Print security object information for a pdf document", "label": 0}, {"idx": "cosqa-train-6778", "doc": "django python rollback makemigration", "code": "def rollback(name, database=None, directory=None, verbose=None):\n    \"\"\"Rollback a migration with given name.\"\"\"\n    router = get_router(directory, database, verbose)\n    router.rollback(name)", "code_tokens": "def rollback ( name , database = None , directory = None , verbose = None ) : router = get_router ( directory , database , verbose ) router . rollback ( name )", "docstring_tokens": "Rollback a migration with given name .", "label": 0}, {"idx": "cosqa-train-6779", "doc": "python get text from page", "code": "def get_page_text(self, page):\n        \"\"\"\n        Downloads and returns the full text of a particular page\n        in the document.\n        \"\"\"\n        url = self.get_page_text_url(page)\n        return self._get_url(url)", "code_tokens": "def get_page_text ( self , page ) : url = self . get_page_text_url ( page ) return self . _get_url ( url )", "docstring_tokens": "Downloads and returns the full text of a particular page in the document .", "label": 0}, {"idx": "cosqa-train-6780", "doc": "do i have to activate my python virtual environment every time", "code": "def get_python():\n    \"\"\"Determine the path to the virtualenv python\"\"\"\n    if sys.platform == 'win32':\n        python = path.join(VE_ROOT, 'Scripts', 'python.exe')\n    else:\n        python = path.join(VE_ROOT, 'bin', 'python')\n    return python", "code_tokens": "def get_python ( ) : if sys . platform == 'win32' : python = path . join ( VE_ROOT , 'Scripts' , 'python.exe' ) else : python = path . join ( VE_ROOT , 'bin' , 'python' ) return python", "docstring_tokens": "Determine the path to the virtualenv python", "label": 1}, {"idx": "cosqa-train-6781", "doc": "python get the closest monday", "code": "def _get_closest_week(self, metric_date):\n        \"\"\"\n        Gets the closest monday to the date provided.\n        \"\"\"\n        #find the offset to the closest monday\n        days_after_monday = metric_date.isoweekday() - 1\n\n        return metric_date - datetime.timedelta(days=days_after_monday)", "code_tokens": "def _get_closest_week ( self , metric_date ) : #find the offset to the closest monday days_after_monday = metric_date . isoweekday ( ) - 1 return metric_date - datetime . timedelta ( days = days_after_monday )", "docstring_tokens": "Gets the closest monday to the date provided .", "label": 0}, {"idx": "cosqa-train-6782", "doc": "do you use onehotencoder on categorical variables in python", "code": "def one_hot(x, size, dtype=np.float32):\n  \"\"\"Make a n+1 dim one-hot array from n dim int-categorical array.\"\"\"\n  return np.array(x[..., np.newaxis] == np.arange(size), dtype)", "code_tokens": "def one_hot ( x , size , dtype = np . float32 ) : return np . array ( x [ ... , np . newaxis ] == np . arange ( size ) , dtype )", "docstring_tokens": "Make a n + 1 dim one - hot array from n dim int - categorical array .", "label": 1}, {"idx": "cosqa-train-6783", "doc": "python get the date of creation of file", "code": "def get_creation_datetime(filepath):\n    \"\"\"\n    Get the date that a file was created.\n\n    Parameters\n    ----------\n    filepath : str\n\n    Returns\n    -------\n    creation_datetime : datetime.datetime or None\n    \"\"\"\n    if platform.system() == 'Windows':\n        return datetime.fromtimestamp(os.path.getctime(filepath))\n    else:\n        stat = os.stat(filepath)\n        try:\n            return datetime.fromtimestamp(stat.st_birthtime)\n        except AttributeError:\n            # We're probably on Linux. No easy way to get creation dates here,\n            # so we'll settle for when its content was last modified.\n            return None", "code_tokens": "def get_creation_datetime ( filepath ) : if platform . system ( ) == 'Windows' : return datetime . fromtimestamp ( os . path . getctime ( filepath ) ) else : stat = os . stat ( filepath ) try : return datetime . fromtimestamp ( stat . st_birthtime ) except AttributeError : # We're probably on Linux. No easy way to get creation dates here, # so we'll settle for when its content was last modified. return None", "docstring_tokens": "Get the date that a file was created .", "label": 1}, {"idx": "cosqa-train-6784", "doc": "does django python run sql server", "code": "def server(port):\n    \"\"\"Start the Django dev server.\"\"\"\n    args = ['python', 'manage.py', 'runserver']\n    if port:\n        args.append(port)\n    run.main(args)", "code_tokens": "def server ( port ) : args = [ 'python' , 'manage.py' , 'runserver' ] if port : args . append ( port ) run . main ( args )", "docstring_tokens": "Start the Django dev server .", "label": 0}, {"idx": "cosqa-train-6785", "doc": "python get the dimenstions of a variable", "code": "def get_grid_spatial_dimensions(self, variable):\n        \"\"\"Returns (width, height) for the given variable\"\"\"\n\n        data = self.open_dataset(self.service).variables[variable.variable]\n        dimensions = list(data.dimensions)\n        return data.shape[dimensions.index(variable.x_dimension)], data.shape[dimensions.index(variable.y_dimension)]", "code_tokens": "def get_grid_spatial_dimensions ( self , variable ) : data = self . open_dataset ( self . service ) . variables [ variable . variable ] dimensions = list ( data . dimensions ) return data . shape [ dimensions . index ( variable . x_dimension ) ] , data . shape [ dimensions . index ( variable . y_dimension ) ]", "docstring_tokens": "Returns ( width height ) for the given variable", "label": 0}, {"idx": "cosqa-train-6786", "doc": "does python automatically return a float", "code": "def _force_float(v):\n    \"\"\" Converts given argument to float. On fail logs warning and returns 0.0.\n\n    Args:\n        v (any): value to convert to float\n\n    Returns:\n        float: converted v or 0.0 if conversion failed.\n\n    \"\"\"\n    try:\n        return float(v)\n    except Exception as exc:\n        return float('nan')\n        logger.warning('Failed to convert {} to float with {} error. Using 0 instead.'.format(v, exc))", "code_tokens": "def _force_float ( v ) : try : return float ( v ) except Exception as exc : return float ( 'nan' ) logger . warning ( 'Failed to convert {} to float with {} error. Using 0 instead.' . format ( v , exc ) )", "docstring_tokens": "Converts given argument to float . On fail logs warning and returns 0 . 0 .", "label": 0}, {"idx": "cosqa-train-6787", "doc": "python get the index of an element in a list", "code": "def binSearch(arr, val):\n  \"\"\" \n  Function for running binary search on a sorted list.\n\n  :param arr: (list) a sorted list of integers to search\n  :param val: (int)  a integer to search for in the sorted array\n  :returns: (int) the index of the element if it is found and -1 otherwise.\n  \"\"\"\n  i = bisect_left(arr, val)\n  if i != len(arr) and arr[i] == val:\n    return i\n  return -1", "code_tokens": "def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1", "docstring_tokens": "Function for running binary search on a sorted list .", "label": 0}, {"idx": "cosqa-train-6788", "doc": "does python max works with none", "code": "def min_or_none(val1, val2):\n    \"\"\"Returns min(val1, val2) returning None only if both values are None\"\"\"\n    return min(val1, val2, key=lambda x: sys.maxint if x is None else x)", "code_tokens": "def min_or_none ( val1 , val2 ) : return min ( val1 , val2 , key = lambda x : sys . maxint if x is None else x )", "docstring_tokens": "Returns min ( val1 val2 ) returning None only if both values are None", "label": 1}, {"idx": "cosqa-train-6789", "doc": "python get the last item in a queryset", "code": "def end_index(self):\n        \"\"\"\n        Returns the 1-based index of the last object on this page,\n        relative to total objects found (hits).\n        \"\"\"\n        return ((self.number - 1) * self.paginator.per_page +\n            len(self.object_list))", "code_tokens": "def end_index ( self ) : return ( ( self . number - 1 ) * self . paginator . per_page + len ( self . object_list ) )", "docstring_tokens": "Returns the 1 - based index of the last object on this page relative to total objects found ( hits ) .", "label": 0}, {"idx": "cosqa-train-6790", "doc": "dos python history up arrow", "code": "def end_of_history(event):\n    \"\"\"\n    Move to the end of the input history, i.e., the line currently being entered.\n    \"\"\"\n    event.current_buffer.history_forward(count=10**100)\n    buff = event.current_buffer\n    buff.go_to_history(len(buff._working_lines) - 1)", "code_tokens": "def end_of_history ( event ) : event . current_buffer . history_forward ( count = 10 ** 100 ) buff = event . current_buffer buff . go_to_history ( len ( buff . _working_lines ) - 1 )", "docstring_tokens": "Move to the end of the input history i . e . the line currently being entered .", "label": 1}, {"idx": "cosqa-train-6791", "doc": "dot function from string python", "code": "def _dotify(cls, data):\n    \"\"\"Add dots.\"\"\"\n    return ''.join(char if char in cls.PRINTABLE_DATA else '.' for char in data)", "code_tokens": "def _dotify ( cls , data ) : return '' . join ( char if char in cls . PRINTABLE_DATA else '.' for char in data )", "docstring_tokens": "Add dots .", "label": 1}, {"idx": "cosqa-train-6792", "doc": "python get the size of a type", "code": "def size(dtype):\n  \"\"\"Returns the number of bytes to represent this `dtype`.\"\"\"\n  dtype = tf.as_dtype(dtype)\n  if hasattr(dtype, 'size'):\n    return dtype.size\n  return np.dtype(dtype).itemsize", "code_tokens": "def size ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'size' ) : return dtype . size return np . dtype ( dtype ) . itemsize", "docstring_tokens": "Returns the number of bytes to represent this dtype .", "label": 1}, {"idx": "cosqa-train-6793", "doc": "dot product of 2 vector sin python", "code": "def dot_v2(vec1, vec2):\n    \"\"\"Return the dot product of two vectors\"\"\"\n\n    return vec1.x * vec2.x + vec1.y * vec2.y", "code_tokens": "def dot_v2 ( vec1 , vec2 ) : return vec1 . x * vec2 . x + vec1 . y * vec2 . y", "docstring_tokens": "Return the dot product of two vectors", "label": 0}, {"idx": "cosqa-train-6794", "doc": "python get the size of raw disk", "code": "def get_shared_memory_bytes():\n    \"\"\"Get the size of the shared memory file system.\n\n    Returns:\n        The size of the shared memory file system in bytes.\n    \"\"\"\n    # Make sure this is only called on Linux.\n    assert sys.platform == \"linux\" or sys.platform == \"linux2\"\n\n    shm_fd = os.open(\"/dev/shm\", os.O_RDONLY)\n    try:\n        shm_fs_stats = os.fstatvfs(shm_fd)\n        # The value shm_fs_stats.f_bsize is the block size and the\n        # value shm_fs_stats.f_bavail is the number of available\n        # blocks.\n        shm_avail = shm_fs_stats.f_bsize * shm_fs_stats.f_bavail\n    finally:\n        os.close(shm_fd)\n\n    return shm_avail", "code_tokens": "def get_shared_memory_bytes ( ) : # Make sure this is only called on Linux. assert sys . platform == \"linux\" or sys . platform == \"linux2\" shm_fd = os . open ( \"/dev/shm\" , os . O_RDONLY ) try : shm_fs_stats = os . fstatvfs ( shm_fd ) # The value shm_fs_stats.f_bsize is the block size and the # value shm_fs_stats.f_bavail is the number of available # blocks. shm_avail = shm_fs_stats . f_bsize * shm_fs_stats . f_bavail finally : os . close ( shm_fd ) return shm_avail", "docstring_tokens": "Get the size of the shared memory file system .", "label": 0}, {"idx": "cosqa-train-6795", "doc": "dot product of vectors in python", "code": "def dot_v3(v, w):\n    \"\"\"Return the dotproduct of two vectors.\"\"\"\n\n    return sum([x * y for x, y in zip(v, w)])", "code_tokens": "def dot_v3 ( v , w ) : return sum ( [ x * y for x , y in zip ( v , w ) ] )", "docstring_tokens": "Return the dotproduct of two vectors .", "label": 1}, {"idx": "cosqa-train-6796", "doc": "python get the text on the page", "code": "def get_page_text(self, page):\n        \"\"\"\n        Downloads and returns the full text of a particular page\n        in the document.\n        \"\"\"\n        url = self.get_page_text_url(page)\n        return self._get_url(url)", "code_tokens": "def get_page_text ( self , page ) : url = self . get_page_text_url ( page ) return self . _get_url ( url )", "docstring_tokens": "Downloads and returns the full text of a particular page in the document .", "label": 1}, {"idx": "cosqa-train-6797", "doc": "drop all databases python", "code": "def drop_all_tables(self):\n        \"\"\"Drop all tables in the database\"\"\"\n        for table_name in self.table_names():\n            self.execute_sql(\"DROP TABLE %s\" % table_name)\n        self.connection.commit()", "code_tokens": "def drop_all_tables ( self ) : for table_name in self . table_names ( ) : self . execute_sql ( \"DROP TABLE %s\" % table_name ) self . connection . commit ( )", "docstring_tokens": "Drop all tables in the database", "label": 0}, {"idx": "cosqa-train-6798", "doc": "python get timestamp of a file", "code": "def get_time(filename):\n\t\"\"\"\n\tGet the modified time for a file as a datetime instance\n\t\"\"\"\n\tts = os.stat(filename).st_mtime\n\treturn datetime.datetime.utcfromtimestamp(ts)", "code_tokens": "def get_time ( filename ) : ts = os . stat ( filename ) . st_mtime return datetime . datetime . utcfromtimestamp ( ts )", "docstring_tokens": "Get the modified time for a file as a datetime instance", "label": 1}, {"idx": "cosqa-train-6799", "doc": "drop column if all column values are nan in python", "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True):\n    \"\"\"Clean a pandas dataframe by:\n        1. Filling empty values with Nan\n        2. Dropping columns with all empty values\n\n    Args:\n        df: Pandas DataFrame\n        fill_nan (bool): If any empty values (strings, None, etc) should be replaced with NaN\n        drop_empty_columns (bool): If columns whose values are all empty should be dropped\n\n    Returns:\n        DataFrame: cleaned DataFrame\n\n    \"\"\"\n    if fill_nan:\n        df = df.fillna(value=np.nan)\n    if drop_empty_columns:\n        df = df.dropna(axis=1, how='all')\n    return df.sort_index()", "code_tokens": "def clean_df ( df , fill_nan = True , drop_empty_columns = True ) : if fill_nan : df = df . fillna ( value = np . nan ) if drop_empty_columns : df = df . dropna ( axis = 1 , how = 'all' ) return df . sort_index ( )", "docstring_tokens": "Clean a pandas dataframe by : 1 . Filling empty values with Nan 2 . Dropping columns with all empty values", "label": 1}, {"idx": "cosqa-train-6800", "doc": "python get type in str", "code": "def check_str(obj):\n        \"\"\" Returns a string for various input types \"\"\"\n        if isinstance(obj, str):\n            return obj\n        if isinstance(obj, float):\n            return str(int(obj))\n        else:\n            return str(obj)", "code_tokens": "def check_str ( obj ) : if isinstance ( obj , str ) : return obj if isinstance ( obj , float ) : return str ( int ( obj ) ) else : return str ( obj )", "docstring_tokens": "Returns a string for various input types", "label": 0}, {"idx": "cosqa-train-6801", "doc": "drop columns with na in python", "code": "def clean_df(df, fill_nan=True, drop_empty_columns=True):\n    \"\"\"Clean a pandas dataframe by:\n        1. Filling empty values with Nan\n        2. Dropping columns with all empty values\n\n    Args:\n        df: Pandas DataFrame\n        fill_nan (bool): If any empty values (strings, None, etc) should be replaced with NaN\n        drop_empty_columns (bool): If columns whose values are all empty should be dropped\n\n    Returns:\n        DataFrame: cleaned DataFrame\n\n    \"\"\"\n    if fill_nan:\n        df = df.fillna(value=np.nan)\n    if drop_empty_columns:\n        df = df.dropna(axis=1, how='all')\n    return df.sort_index()", "code_tokens": "def clean_df ( df , fill_nan = True , drop_empty_columns = True ) : if fill_nan : df = df . fillna ( value = np . nan ) if drop_empty_columns : df = df . dropna ( axis = 1 , how = 'all' ) return df . sort_index ( )", "docstring_tokens": "Clean a pandas dataframe by : 1 . Filling empty values with Nan 2 . Dropping columns with all empty values", "label": 0}, {"idx": "cosqa-train-6802", "doc": "python get width and height of pdf", "code": "def dimensions(self):\n        \"\"\"Get width and height of a PDF\"\"\"\n        size = self.pdf.getPage(0).mediaBox\n        return {'w': float(size[2]), 'h': float(size[3])}", "code_tokens": "def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "docstring_tokens": "Get width and height of a PDF", "label": 0}, {"idx": "cosqa-train-6803", "doc": "dynamically create unique lists in a for loop python", "code": "def unique(input_list):\n    \"\"\"\n    Return a list of unique items (similar to set functionality).\n\n    Parameters\n    ----------\n    input_list : list\n        A list containg some items that can occur more than once.\n\n    Returns\n    -------\n    list\n        A list with only unique occurances of an item.\n\n    \"\"\"\n    output = []\n    for item in input_list:\n        if item not in output:\n            output.append(item)\n    return output", "code_tokens": "def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output", "docstring_tokens": "Return a list of unique items ( similar to set functionality ) .", "label": 0}, {"idx": "cosqa-train-6804", "doc": "python get windows user id", "code": "def get_nt_system_uid():\n    \"\"\"Get the MachineGuid from\n    HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Cryptography\\MachineGuid\n    \"\"\"\n    try:\n        import _winreg as winreg\n    except ImportError:\n        import winreg\n    lm = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)\n    try:\n        key = winreg.OpenKey(lm, r\"Software\\Microsoft\\Cryptography\")\n        try:\n            return winreg.QueryValueEx(key, \"MachineGuid\")[0]\n        finally:\n            key.Close()\n    finally:\n        lm.Close()", "code_tokens": "def get_nt_system_uid ( ) : try : import _winreg as winreg except ImportError : import winreg lm = winreg . ConnectRegistry ( None , winreg . HKEY_LOCAL_MACHINE ) try : key = winreg . OpenKey ( lm , r\"Software\\Microsoft\\Cryptography\" ) try : return winreg . QueryValueEx ( key , \"MachineGuid\" ) [ 0 ] finally : key . Close ( ) finally : lm . Close ( )", "docstring_tokens": "Get the MachineGuid from HKEY_LOCAL_MACHINE \\ Software \\ Microsoft \\ Cryptography \\ MachineGuid", "label": 1}, {"idx": "cosqa-train-6805", "doc": "dynamodb get item python examples", "code": "def batch_get_item(self, batch_list):\n        \"\"\"\n        Return a set of attributes for a multiple items in\n        multiple tables using their primary keys.\n\n        :type batch_list: :class:`boto.dynamodb.batch.BatchList`\n        :param batch_list: A BatchList object which consists of a\n            list of :class:`boto.dynamoddb.batch.Batch` objects.\n            Each Batch object contains the information about one\n            batch of objects that you wish to retrieve in this\n            request.\n        \"\"\"\n        request_items = self.dynamize_request_items(batch_list)\n        return self.layer1.batch_get_item(request_items,\n                                          object_hook=item_object_hook)", "code_tokens": "def batch_get_item ( self , batch_list ) : request_items = self . dynamize_request_items ( batch_list ) return self . layer1 . batch_get_item ( request_items , object_hook = item_object_hook )", "docstring_tokens": "Return a set of attributes for a multiple items in multiple tables using their primary keys .", "label": 1}, {"idx": "cosqa-train-6806", "doc": "python gevent pool repeat", "code": "def fetch_event(urls):\n    \"\"\"\n    This parallel fetcher uses gevent one uses gevent\n    \"\"\"\n    rs = (grequests.get(u) for u in urls)\n    return [content.json() for content in grequests.map(rs)]", "code_tokens": "def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]", "docstring_tokens": "This parallel fetcher uses gevent one uses gevent", "label": 1}, {"idx": "cosqa-train-6807", "doc": "easy was to format a table in python", "code": "def get_table(ports):\n    \"\"\"\n    This function returns a pretty table used to display the port results.\n\n    :param ports: list of found ports\n    :return: the table to display\n    \"\"\"\n    table = PrettyTable([\"Name\", \"Port\", \"Protocol\", \"Description\"])\n    table.align[\"Name\"] = \"l\"\n    table.align[\"Description\"] = \"l\"\n    table.padding_width = 1\n\n    for port in ports:\n        table.add_row(port)\n\n    return table", "code_tokens": "def get_table ( ports ) : table = PrettyTable ( [ \"Name\" , \"Port\" , \"Protocol\" , \"Description\" ] ) table . align [ \"Name\" ] = \"l\" table . align [ \"Description\" ] = \"l\" table . padding_width = 1 for port in ports : table . add_row ( port ) return table", "docstring_tokens": "This function returns a pretty table used to display the port results .", "label": 1}, {"idx": "cosqa-train-6808", "doc": "python gevent several group task", "code": "def fetch_event(urls):\n    \"\"\"\n    This parallel fetcher uses gevent one uses gevent\n    \"\"\"\n    rs = (grequests.get(u) for u in urls)\n    return [content.json() for content in grequests.map(rs)]", "code_tokens": "def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]", "docstring_tokens": "This parallel fetcher uses gevent one uses gevent", "label": 1}, {"idx": "cosqa-train-6809", "doc": "email validation pattern in python", "code": "def validate_email(email):\n    \"\"\"\n    Validates an email address\n    Source: Himanshu Shankar (https://github.com/iamhssingh)\n    Parameters\n    ----------\n    email: str\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    from django.core.validators import validate_email\n    from django.core.exceptions import ValidationError\n    try:\n        validate_email(email)\n        return True\n    except ValidationError:\n        return False", "code_tokens": "def validate_email ( email ) : from django . core . validators import validate_email from django . core . exceptions import ValidationError try : validate_email ( email ) return True except ValidationError : return False", "docstring_tokens": "Validates an email address Source : Himanshu Shankar ( https : // github . com / iamhssingh ) Parameters ---------- email : str", "label": 0}, {"idx": "cosqa-train-6810", "doc": "python gevent urllib2 urlopen list not callable", "code": "def fetch_event(urls):\n    \"\"\"\n    This parallel fetcher uses gevent one uses gevent\n    \"\"\"\n    rs = (grequests.get(u) for u in urls)\n    return [content.json() for content in grequests.map(rs)]", "code_tokens": "def fetch_event ( urls ) : rs = ( grequests . get ( u ) for u in urls ) return [ content . json ( ) for content in grequests . map ( rs ) ]", "docstring_tokens": "This parallel fetcher uses gevent one uses gevent", "label": 0}, {"idx": "cosqa-train-6811", "doc": "encoding bytes to json python", "code": "def _bytes_to_json(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\"\"\"\n    if isinstance(value, bytes):\n        value = base64.standard_b64encode(value).decode(\"ascii\")\n    return value", "code_tokens": "def _bytes_to_json ( value ) : if isinstance ( value , bytes ) : value = base64 . standard_b64encode ( value ) . decode ( \"ascii\" ) return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 0}, {"idx": "cosqa-train-6812", "doc": "python give all column headers", "code": "def printheader(h=None):\n    \"\"\"Print the header for the CSV table.\"\"\"\n    writer = csv.writer(sys.stdout)\n    writer.writerow(header_fields(h))", "code_tokens": "def printheader ( h = None ) : writer = csv . writer ( sys . stdout ) writer . writerow ( header_fields ( h ) )", "docstring_tokens": "Print the header for the CSV table .", "label": 0}, {"idx": "cosqa-train-6813", "doc": "epoch to gmt datetime python 3", "code": "def _dt_to_epoch(dt):\n        \"\"\"Convert datetime to epoch seconds.\"\"\"\n        try:\n            epoch = dt.timestamp()\n        except AttributeError:  # py2\n            epoch = (dt - datetime(1970, 1, 1)).total_seconds()\n        return epoch", "code_tokens": "def _dt_to_epoch ( dt ) : try : epoch = dt . timestamp ( ) except AttributeError : # py2 epoch = ( dt - datetime ( 1970 , 1 , 1 ) ) . total_seconds ( ) return epoch", "docstring_tokens": "Convert datetime to epoch seconds .", "label": 1}, {"idx": "cosqa-train-6814", "doc": "python go to parent directory", "code": "def go_to_parent_directory(self):\n        \"\"\"Go to parent directory\"\"\"\n        self.chdir(osp.abspath(osp.join(getcwd_or_home(), os.pardir)))", "code_tokens": "def go_to_parent_directory ( self ) : self . chdir ( osp . abspath ( osp . join ( getcwd_or_home ( ) , os . pardir ) ) )", "docstring_tokens": "Go to parent directory", "label": 1}, {"idx": "cosqa-train-6815", "doc": "epython name is notdefined", "code": "def page_guiref(arg_s=None):\n    \"\"\"Show a basic reference about the GUI Console.\"\"\"\n    from IPython.core import page\n    page.page(gui_reference, auto_html=True)", "code_tokens": "def page_guiref ( arg_s = None ) : from IPython . core import page page . page ( gui_reference , auto_html = True )", "docstring_tokens": "Show a basic reference about the GUI Console .", "label": 1}, {"idx": "cosqa-train-6816", "doc": "python gradient grayscale image", "code": "def average_gradient(data, *kwargs):\n    \"\"\" Compute average gradient norm of an image\n    \"\"\"\n    return np.average(np.array(np.gradient(data))**2)", "code_tokens": "def average_gradient ( data , * kwargs ) : return np . average ( np . array ( np . gradient ( data ) ) ** 2 )", "docstring_tokens": "Compute average gradient norm of an image", "label": 0}, {"idx": "cosqa-train-6817", "doc": "equivalent of throw in python", "code": "def reraise(error):\n    \"\"\"Re-raises the error that was processed by prepare_for_reraise earlier.\"\"\"\n    if hasattr(error, \"_type_\"):\n        six.reraise(type(error), error, error._traceback)\n    raise error", "code_tokens": "def reraise ( error ) : if hasattr ( error , \"_type_\" ) : six . reraise ( type ( error ) , error , error . _traceback ) raise error", "docstring_tokens": "Re - raises the error that was processed by prepare_for_reraise earlier .", "label": 1}, {"idx": "cosqa-train-6818", "doc": "python graphviz executables not found", "code": "def _check_graphviz_available(output_format):\n    \"\"\"check if we need graphviz for different output format\"\"\"\n    try:\n        subprocess.call([\"dot\", \"-V\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    except OSError:\n        print(\n            \"The output format '%s' is currently not available.\\n\"\n            \"Please install 'Graphviz' to have other output formats \"\n            \"than 'dot' or 'vcg'.\" % output_format\n        )\n        sys.exit(32)", "code_tokens": "def _check_graphviz_available ( output_format ) : try : subprocess . call ( [ \"dot\" , \"-V\" ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) except OSError : print ( \"The output format '%s' is currently not available.\\n\" \"Please install 'Graphviz' to have other output formats \" \"than 'dot' or 'vcg'.\" % output_format ) sys . exit ( 32 )", "docstring_tokens": "check if we need graphviz for different output format", "label": 1}, {"idx": "cosqa-train-6819", "doc": "escape characters in python sql query", "code": "def _escape(s):\n    \"\"\" Helper method that escapes parameters to a SQL query. \"\"\"\n    e = s\n    e = e.replace('\\\\', '\\\\\\\\')\n    e = e.replace('\\n', '\\\\n')\n    e = e.replace('\\r', '\\\\r')\n    e = e.replace(\"'\", \"\\\\'\")\n    e = e.replace('\"', '\\\\\"')\n    return e", "code_tokens": "def _escape ( s ) : e = s e = e . replace ( '\\\\' , '\\\\\\\\' ) e = e . replace ( '\\n' , '\\\\n' ) e = e . replace ( '\\r' , '\\\\r' ) e = e . replace ( \"'\" , \"\\\\'\" ) e = e . replace ( '\"' , '\\\\\"' ) return e", "docstring_tokens": "Helper method that escapes parameters to a SQL query .", "label": 0}, {"idx": "cosqa-train-6820", "doc": "python guid to uuid", "code": "def normalize_job_id(job_id):\n\t\"\"\"\n\tConvert a value to a job id.\n\n\t:param job_id: Value to convert.\n\t:type job_id: int, str\n\t:return: The job id.\n\t:rtype: :py:class:`uuid.UUID`\n\t\"\"\"\n\tif not isinstance(job_id, uuid.UUID):\n\t\tjob_id = uuid.UUID(job_id)\n\treturn job_id", "code_tokens": "def normalize_job_id ( job_id ) : if not isinstance ( job_id , uuid . UUID ) : job_id = uuid . UUID ( job_id ) return job_id", "docstring_tokens": "Convert a value to a job id .", "label": 0}, {"idx": "cosqa-train-6821", "doc": "escape string for sql python", "code": "def _escape(s):\n    \"\"\" Helper method that escapes parameters to a SQL query. \"\"\"\n    e = s\n    e = e.replace('\\\\', '\\\\\\\\')\n    e = e.replace('\\n', '\\\\n')\n    e = e.replace('\\r', '\\\\r')\n    e = e.replace(\"'\", \"\\\\'\")\n    e = e.replace('\"', '\\\\\"')\n    return e", "code_tokens": "def _escape ( s ) : e = s e = e . replace ( '\\\\' , '\\\\\\\\' ) e = e . replace ( '\\n' , '\\\\n' ) e = e . replace ( '\\r' , '\\\\r' ) e = e . replace ( \"'\" , \"\\\\'\" ) e = e . replace ( '\"' , '\\\\\"' ) return e", "docstring_tokens": "Helper method that escapes parameters to a SQL query .", "label": 1}, {"idx": "cosqa-train-6822", "doc": "python gzip bytes str", "code": "def ungzip_data(input_data):\n    \"\"\"Return a string of data after gzip decoding\n\n    :param the input gziped data\n    :return  the gzip decoded data\"\"\"\n    buf = StringIO(input_data)\n    f = gzip.GzipFile(fileobj=buf)\n    return f", "code_tokens": "def ungzip_data ( input_data ) : buf = StringIO ( input_data ) f = gzip . GzipFile ( fileobj = buf ) return f", "docstring_tokens": "Return a string of data after gzip decoding", "label": 0}, {"idx": "cosqa-train-6823", "doc": "euclidean distance python 2d", "code": "def euclidean(x, y):\n    \"\"\"Standard euclidean distance.\n\n    ..math::\n        D(x, y) = \\sqrt{\\sum_i (x_i - y_i)^2}\n    \"\"\"\n    result = 0.0\n    for i in range(x.shape[0]):\n        result += (x[i] - y[i]) ** 2\n    return np.sqrt(result)", "code_tokens": "def euclidean ( x , y ) : result = 0.0 for i in range ( x . shape [ 0 ] ) : result += ( x [ i ] - y [ i ] ) ** 2 return np . sqrt ( result )", "docstring_tokens": "Standard euclidean distance .", "label": 0}, {"idx": "cosqa-train-6824", "doc": "python gzip decompress stream", "code": "def load_streams(chunks):\n    \"\"\"\n    Given a gzipped stream of data, yield streams of decompressed data.\n    \"\"\"\n    chunks = peekable(chunks)\n    while chunks:\n        if six.PY3:\n            dc = zlib.decompressobj(wbits=zlib.MAX_WBITS | 16)\n        else:\n            dc = zlib.decompressobj(zlib.MAX_WBITS | 16)\n        yield load_stream(dc, chunks)\n        if dc.unused_data:\n            chunks = peekable(itertools.chain((dc.unused_data,), chunks))", "code_tokens": "def load_streams ( chunks ) : chunks = peekable ( chunks ) while chunks : if six . PY3 : dc = zlib . decompressobj ( wbits = zlib . MAX_WBITS | 16 ) else : dc = zlib . decompressobj ( zlib . MAX_WBITS | 16 ) yield load_stream ( dc , chunks ) if dc . unused_data : chunks = peekable ( itertools . chain ( ( dc . unused_data , ) , chunks ) )", "docstring_tokens": "Given a gzipped stream of data yield streams of decompressed data .", "label": 1}, {"idx": "cosqa-train-6825", "doc": "eval source code in python", "code": "def runcode(code):\n\t\"\"\"Run the given code line by line with printing, as list of lines, and return variable 'ans'.\"\"\"\n\tfor line in code:\n\t\tprint('# '+line)\n\t\texec(line,globals())\n\tprint('# return ans')\n\treturn ans", "code_tokens": "def runcode ( code ) : for line in code : print ( '# ' + line ) exec ( line , globals ( ) ) print ( '# return ans' ) return ans", "docstring_tokens": "Run the given code line by line with printing as list of lines and return variable ans .", "label": 0}, {"idx": "cosqa-train-6826", "doc": "python hierarchical clustering for both rows and columns", "code": "def hclust_linearize(U):\n    \"\"\"Sorts the rows of a matrix by hierarchical clustering.\n\n    Parameters:\n        U (ndarray) : matrix of data\n\n    Returns:\n        prm (ndarray) : permutation of the rows\n    \"\"\"\n\n    from scipy.cluster import hierarchy\n    Z = hierarchy.ward(U)\n    return hierarchy.leaves_list(hierarchy.optimal_leaf_ordering(Z, U))", "code_tokens": "def hclust_linearize ( U ) : from scipy . cluster import hierarchy Z = hierarchy . ward ( U ) return hierarchy . leaves_list ( hierarchy . optimal_leaf_ordering ( Z , U ) )", "docstring_tokens": "Sorts the rows of a matrix by hierarchical clustering .", "label": 0}, {"idx": "cosqa-train-6827", "doc": "exclude stop words python", "code": "def _removeStopwords(text_list):\n    \"\"\"\n    Removes stopwords contained in a list of words.\n\n    :param text_string: A list of strings.\n    :type text_string: list.\n\n    :returns: The input ``text_list`` with stopwords removed.\n    :rtype: list\n    \"\"\"\n\n    output_list = []\n\n    for word in text_list:\n        if word.lower() not in _stopwords:\n            output_list.append(word)\n\n    return output_list", "code_tokens": "def _removeStopwords ( text_list ) : output_list = [ ] for word in text_list : if word . lower ( ) not in _stopwords : output_list . append ( word ) return output_list", "docstring_tokens": "Removes stopwords contained in a list of words .", "label": 0}, {"idx": "cosqa-train-6828", "doc": "python how change input to bytes", "code": "def str2bytes(x):\n  \"\"\"Convert input argument to bytes\"\"\"\n  if type(x) is bytes:\n    return x\n  elif type(x) is str:\n    return bytes([ ord(i) for i in x ])\n  else:\n    return str2bytes(str(x))", "code_tokens": "def str2bytes ( x ) : if type ( x ) is bytes : return x elif type ( x ) is str : return bytes ( [ ord ( i ) for i in x ] ) else : return str2bytes ( str ( x ) )", "docstring_tokens": "Convert input argument to bytes", "label": 0}, {"idx": "cosqa-train-6829", "doc": "execute python test with unittest from command line", "code": "def main(argv=sys.argv, stream=sys.stderr):\n    \"\"\"Entry point for ``tappy`` command.\"\"\"\n    args = parse_args(argv)\n    suite = build_suite(args)\n    runner = unittest.TextTestRunner(verbosity=args.verbose, stream=stream)\n    result = runner.run(suite)\n\n    return get_status(result)", "code_tokens": "def main ( argv = sys . argv , stream = sys . stderr ) : args = parse_args ( argv ) suite = build_suite ( args ) runner = unittest . TextTestRunner ( verbosity = args . verbose , stream = stream ) result = runner . run ( suite ) return get_status ( result )", "docstring_tokens": "Entry point for tappy command .", "label": 0}, {"idx": "cosqa-train-6830", "doc": "python how do i inspect code of builtin", "code": "def activate(self):\n        \"\"\"Store ipython references in the __builtin__ namespace.\"\"\"\n\n        add_builtin = self.add_builtin\n        for name, func in self.auto_builtins.iteritems():\n            add_builtin(name, func)", "code_tokens": "def activate ( self ) : add_builtin = self . add_builtin for name , func in self . auto_builtins . iteritems ( ) : add_builtin ( name , func )", "docstring_tokens": "Store ipython references in the __builtin__ namespace .", "label": 1}, {"idx": "cosqa-train-6831", "doc": "exit a for loop python before it finishes", "code": "def _loop_timeout_cb(self, main_loop):\n        \"\"\"Stops the loop after the time specified in the `loop` call.\n        \"\"\"\n        self._anything_done = True\n        logger.debug(\"_loop_timeout_cb() called\")\n        main_loop.quit()", "code_tokens": "def _loop_timeout_cb ( self , main_loop ) : self . _anything_done = True logger . debug ( \"_loop_timeout_cb() called\" ) main_loop . quit ( )", "docstring_tokens": "Stops the loop after the time specified in the loop call .", "label": 0}, {"idx": "cosqa-train-6832", "doc": "python how do i save cookies between each requests", "code": "def save_config_value(request, response, key, value):\n    \"\"\"Sets value of key `key` to `value` in both session and cookies.\"\"\"\n    request.session[key] = value\n    response.set_cookie(key, value, expires=one_year_from_now())\n    return response", "code_tokens": "def save_config_value ( request , response , key , value ) : request . session [ key ] = value response . set_cookie ( key , value , expires = one_year_from_now ( ) ) return response", "docstring_tokens": "Sets value of key key to value in both session and cookies .", "label": 1}, {"idx": "cosqa-train-6833", "doc": "exit python running in cmd", "code": "def call_and_exit(self, cmd, shell=True):\n        \"\"\"Run the *cmd* and exit with the proper exit code.\"\"\"\n        sys.exit(subprocess.call(cmd, shell=shell))", "code_tokens": "def call_and_exit ( self , cmd , shell = True ) : sys . exit ( subprocess . call ( cmd , shell = shell ) )", "docstring_tokens": "Run the * cmd * and exit with the proper exit code .", "label": 1}, {"idx": "cosqa-train-6834", "doc": "python how long does it take to check if two sets are equal", "code": "def sets_are_rooted_compat(one_set, other):\n    \"\"\"treats the 2 sets are sets of taxon IDs on the same (unstated)\n    universe of taxon ids.\n    Returns True clades implied by each are compatible and False otherwise\n    \"\"\"\n    if one_set.issubset(other) or other.issubset(one_set):\n        return True\n    return not intersection_not_empty(one_set, other)", "code_tokens": "def sets_are_rooted_compat ( one_set , other ) : if one_set . issubset ( other ) or other . issubset ( one_set ) : return True return not intersection_not_empty ( one_set , other )", "docstring_tokens": "treats the 2 sets are sets of taxon IDs on the same ( unstated ) universe of taxon ids . Returns True clades implied by each are compatible and False otherwise", "label": 1}, {"idx": "cosqa-train-6835", "doc": "expanding addresses with python", "code": "def ip_address_list(ips):\n    \"\"\" IP address range validation and expansion. \"\"\"\n    # first, try it as a single IP address\n    try:\n        return ip_address(ips)\n    except ValueError:\n        pass\n    # then, consider it as an ipaddress.IPv[4|6]Network instance and expand it\n    return list(ipaddress.ip_network(u(ips)).hosts())", "code_tokens": "def ip_address_list ( ips ) : # first, try it as a single IP address try : return ip_address ( ips ) except ValueError : pass # then, consider it as an ipaddress.IPv[4|6]Network instance and expand it return list ( ipaddress . ip_network ( u ( ips ) ) . hosts ( ) )", "docstring_tokens": "IP address range validation and expansion .", "label": 1}, {"idx": "cosqa-train-6836", "doc": "python how to break line between and flake8", "code": "def lint(args):\n    \"\"\"Run lint checks using flake8.\"\"\"\n    application = get_current_application()\n    if not args:\n        args = [application.name, 'tests']\n    args = ['flake8'] + list(args)\n    run.main(args, standalone_mode=False)", "code_tokens": "def lint ( args ) : application = get_current_application ( ) if not args : args = [ application . name , 'tests' ] args = [ 'flake8' ] + list ( args ) run . main ( args , standalone_mode = False )", "docstring_tokens": "Run lint checks using flake8 .", "label": 1}, {"idx": "cosqa-train-6837", "doc": "extract integers from string in python", "code": "def get_numbers(s):\n    \"\"\"Extracts all integers from a string an return them in a list\"\"\"\n\n    result = map(int, re.findall(r'[0-9]+', unicode(s)))\n    return result + [1] * (2 - len(result))", "code_tokens": "def get_numbers ( s ) : result = map ( int , re . findall ( r'[0-9]+' , unicode ( s ) ) ) return result + [ 1 ] * ( 2 - len ( result ) )", "docstring_tokens": "Extracts all integers from a string an return them in a list", "label": 1}, {"idx": "cosqa-train-6838", "doc": "python how to calculate length between two points", "code": "def skip_connection_distance(a, b):\n    \"\"\"The distance between two skip-connections.\"\"\"\n    if a[2] != b[2]:\n        return 1.0\n    len_a = abs(a[1] - a[0])\n    len_b = abs(b[1] - b[0])\n    return (abs(a[0] - b[0]) + abs(len_a - len_b)) / (max(a[0], b[0]) + max(len_a, len_b))", "code_tokens": "def skip_connection_distance ( a , b ) : if a [ 2 ] != b [ 2 ] : return 1.0 len_a = abs ( a [ 1 ] - a [ 0 ] ) len_b = abs ( b [ 1 ] - b [ 0 ] ) return ( abs ( a [ 0 ] - b [ 0 ] ) + abs ( len_a - len_b ) ) / ( max ( a [ 0 ] , b [ 0 ] ) + max ( len_a , len_b ) )", "docstring_tokens": "The distance between two skip - connections .", "label": 1}, {"idx": "cosqa-train-6839", "doc": "extract make a list with integers from a string python", "code": "def get_numbers(s):\n    \"\"\"Extracts all integers from a string an return them in a list\"\"\"\n\n    result = map(int, re.findall(r'[0-9]+', unicode(s)))\n    return result + [1] * (2 - len(result))", "code_tokens": "def get_numbers ( s ) : result = map ( int , re . findall ( r'[0-9]+' , unicode ( s ) ) ) return result + [ 1 ] * ( 2 - len ( result ) )", "docstring_tokens": "Extracts all integers from a string an return them in a list", "label": 0}, {"idx": "cosqa-train-6840", "doc": "python how to call stored procedures in multithread", "code": "def parallel(processes, threads):\n    \"\"\"\n    execute jobs in processes using N threads\n    \"\"\"\n    pool = multithread(threads)\n    pool.map(run_process, processes)\n    pool.close()\n    pool.join()", "code_tokens": "def parallel ( processes , threads ) : pool = multithread ( threads ) pool . map ( run_process , processes ) pool . close ( ) pool . join ( )", "docstring_tokens": "execute jobs in processes using N threads", "label": 1}, {"idx": "cosqa-train-6841", "doc": "extract tweets from twitter api python", "code": "def search_for_tweets_about(user_id, params):\n    \"\"\" Search twitter API \"\"\"\n    url = \"https://api.twitter.com/1.1/search/tweets.json\"\n    response = make_twitter_request(url, user_id, params)\n    return process_tweets(response.json()[\"statuses\"])", "code_tokens": "def search_for_tweets_about ( user_id , params ) : url = \"https://api.twitter.com/1.1/search/tweets.json\" response = make_twitter_request ( url , user_id , params ) return process_tweets ( response . json ( ) [ \"statuses\" ] )", "docstring_tokens": "Search twitter API", "label": 0}, {"idx": "cosqa-train-6842", "doc": "python how to chain replace on a string", "code": "def fmt_subst(regex, subst):\n    \"\"\"Replace regex with string.\"\"\"\n    return lambda text: re.sub(regex, subst, text) if text else text", "code_tokens": "def fmt_subst ( regex , subst ) : return lambda text : re . sub ( regex , subst , text ) if text else text", "docstring_tokens": "Replace regex with string .", "label": 1}, {"idx": "cosqa-train-6843", "doc": "python how to check for empty list", "code": "def contains_empty(features):\n    \"\"\"Check features data are not empty\n\n    :param features: The features data to check.\n    :type features: list of numpy arrays.\n\n    :return: True if one of the array is empty, False else.\n\n    \"\"\"\n    if not features:\n        return True\n    for feature in features:\n        if feature.shape[0] == 0:\n            return True\n    return False", "code_tokens": "def contains_empty ( features ) : if not features : return True for feature in features : if feature . shape [ 0 ] == 0 : return True return False", "docstring_tokens": "Check features data are not empty", "label": 1}, {"idx": "cosqa-train-6844", "doc": "fastest way to create dictionary python", "code": "def to_dict(dictish):\n    \"\"\"\n    Given something that closely resembles a dictionary, we attempt\n    to coerce it into a propery dictionary.\n    \"\"\"\n    if hasattr(dictish, 'iterkeys'):\n        m = dictish.iterkeys\n    elif hasattr(dictish, 'keys'):\n        m = dictish.keys\n    else:\n        raise ValueError(dictish)\n\n    return dict((k, dictish[k]) for k in m())", "code_tokens": "def to_dict ( dictish ) : if hasattr ( dictish , 'iterkeys' ) : m = dictish . iterkeys elif hasattr ( dictish , 'keys' ) : m = dictish . keys else : raise ValueError ( dictish ) return dict ( ( k , dictish [ k ] ) for k in m ( ) )", "docstring_tokens": "Given something that closely resembles a dictionary we attempt to coerce it into a propery dictionary .", "label": 0}, {"idx": "cosqa-train-6845", "doc": "python how to check if email and password exist", "code": "def check_auth(email, password):\n    \"\"\"Check if a username/password combination is valid.\n    \"\"\"\n    try:\n        user = User.get(User.email == email)\n    except User.DoesNotExist:\n        return False\n    return password == user.password", "code_tokens": "def check_auth ( email , password ) : try : user = User . get ( User . email == email ) except User . DoesNotExist : return False return password == user . password", "docstring_tokens": "Check if a username / password combination is valid .", "label": 1}, {"idx": "cosqa-train-6846", "doc": "fasting way to loop over a large list in python", "code": "def chunked_list(_list, _chunk_size=50):\n    \"\"\"\n    Break lists into small lists for processing:w\n    \"\"\"\n    for i in range(0, len(_list), _chunk_size):\n        yield _list[i:i + _chunk_size]", "code_tokens": "def chunked_list ( _list , _chunk_size = 50 ) : for i in range ( 0 , len ( _list ) , _chunk_size ) : yield _list [ i : i + _chunk_size ]", "docstring_tokens": "Break lists into small lists for processing : w", "label": 1}, {"idx": "cosqa-train-6847", "doc": "python how to check if process is running", "code": "def is_running(self):\n        \"\"\"Returns a bool determining if the process is in a running state or\n        not\n\n        :rtype: bool\n\n        \"\"\"\n        return self.state in [self.STATE_IDLE, self.STATE_ACTIVE,\n                              self.STATE_SLEEPING]", "code_tokens": "def is_running ( self ) : return self . state in [ self . STATE_IDLE , self . STATE_ACTIVE , self . STATE_SLEEPING ]", "docstring_tokens": "Returns a bool determining if the process is in a running state or not", "label": 1}, {"idx": "cosqa-train-6848", "doc": "fetch a variable from its name + python", "code": "def _get_var_from_string(item):\n    \"\"\" Get resource variable. \"\"\"\n    modname, varname = _split_mod_var_names(item)\n    if modname:\n        mod = __import__(modname, globals(), locals(), [varname], -1)\n        return getattr(mod, varname)\n    else:\n        return globals()[varname]", "code_tokens": "def _get_var_from_string ( item ) : modname , varname = _split_mod_var_names ( item ) if modname : mod = __import__ ( modname , globals ( ) , locals ( ) , [ varname ] , - 1 ) return getattr ( mod , varname ) else : return globals ( ) [ varname ]", "docstring_tokens": "Get resource variable .", "label": 1}, {"idx": "cosqa-train-6849", "doc": "python how to check if something is punctuation", "code": "def is_punctuation(text):\n    \"\"\"Check if given string is a punctuation\"\"\"\n    return not (text.lower() in config.AVRO_VOWELS or\n                text.lower() in config.AVRO_CONSONANTS)", "code_tokens": "def is_punctuation ( text ) : return not ( text . lower ( ) in config . AVRO_VOWELS or text . lower ( ) in config . AVRO_CONSONANTS )", "docstring_tokens": "Check if given string is a punctuation", "label": 1}, {"idx": "cosqa-train-6850", "doc": "field value empty check in python", "code": "def run(self, value):\n        \"\"\" Determines if value value is empty.\n        Keyword arguments:\n        value str -- the value of the associated field to compare\n        \"\"\"\n        if self.pass_ and not value.strip():\n            return True\n\n        if not value:\n            return False\n        return True", "code_tokens": "def run ( self , value ) : if self . pass_ and not value . strip ( ) : return True if not value : return False return True", "docstring_tokens": "Determines if value value is empty . Keyword arguments : value str -- the value of the associated field to compare", "label": 0}, {"idx": "cosqa-train-6851", "doc": "python how to check the time taken for a function", "code": "def time_func(func, name, *args, **kwargs):\n    \"\"\" call a func with args and kwargs, print name of func and how\n    long it took. \"\"\"\n    tic = time.time()\n    out = func(*args, **kwargs)\n    toc = time.time()\n    print('%s took %0.2f seconds' % (name, toc - tic))\n    return out", "code_tokens": "def time_func ( func , name , * args , * * kwargs ) : tic = time . time ( ) out = func ( * args , * * kwargs ) toc = time . time ( ) print ( '%s took %0.2f seconds' % ( name , toc - tic ) ) return out", "docstring_tokens": "call a func with args and kwargs print name of func and how long it took .", "label": 1}, {"idx": "cosqa-train-6852", "doc": "fields of a struct python", "code": "def struct2dict(struct):\n    \"\"\"convert a ctypes structure to a dictionary\"\"\"\n    return {x: getattr(struct, x) for x in dict(struct._fields_).keys()}", "code_tokens": "def struct2dict ( struct ) : return { x : getattr ( struct , x ) for x in dict ( struct . _fields_ ) . keys ( ) }", "docstring_tokens": "convert a ctypes structure to a dictionary", "label": 0}, {"idx": "cosqa-train-6853", "doc": "python how to connect all list to a string", "code": "def commajoin_as_strings(iterable):\n    \"\"\" Join the given iterable with ',' \"\"\"\n    return _(u',').join((six.text_type(i) for i in iterable))", "code_tokens": "def commajoin_as_strings ( iterable ) : return _ ( u',' ) . join ( ( six . text_type ( i ) for i in iterable ) )", "docstring_tokens": "Join the given iterable with", "label": 1}, {"idx": "cosqa-train-6854", "doc": "filling null value sin data frame in python", "code": "def clean_dataframe(df):\n    \"\"\"Fill NaNs with the previous value, the next value or if all are NaN then 1.0\"\"\"\n    df = df.fillna(method='ffill')\n    df = df.fillna(0.0)\n    return df", "code_tokens": "def clean_dataframe ( df ) : df = df . fillna ( method = 'ffill' ) df = df . fillna ( 0.0 ) return df", "docstring_tokens": "Fill NaNs with the previous value the next value or if all are NaN then 1 . 0", "label": 1}, {"idx": "cosqa-train-6855", "doc": "python how to declaare an array of unknown length", "code": "def __init__(self, capacity=10):\n        \"\"\"\n        Initialize python List with capacity of 10 or user given input.\n        Python List type is a dynamic array, so we have to restrict its\n        dynamic nature to make it work like a static array.\n        \"\"\"\n        super().__init__()\n        self._array = [None] * capacity\n        self._front = 0\n        self._rear = 0", "code_tokens": "def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0", "docstring_tokens": "Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array .", "label": 1}, {"idx": "cosqa-train-6856", "doc": "filter a dataset in python on multiple fields", "code": "def filter_set(input, **params):\n    \"\"\"\n    Apply WHERE filter to input dataset\n    :param input:\n    :param params:\n    :return: filtered data\n    \"\"\"\n    PARAM_WHERE = 'where'\n\n    return Converter.df2list(pd.DataFrame.from_records(input).query(params.get(PARAM_WHERE)))", "code_tokens": "def filter_set ( input , * * params ) : PARAM_WHERE = 'where' return Converter . df2list ( pd . DataFrame . from_records ( input ) . query ( params . get ( PARAM_WHERE ) ) )", "docstring_tokens": "Apply WHERE filter to input dataset : param input : : param params : : return : filtered data", "label": 1}, {"idx": "cosqa-train-6857", "doc": "python how to delete unnamed columns", "code": "def del_Unnamed(df):\n    \"\"\"\n    Deletes all the unnamed columns\n\n    :param df: pandas dataframe\n    \"\"\"\n    cols_del=[c for c in df.columns if 'Unnamed' in c]\n    return df.drop(cols_del,axis=1)", "code_tokens": "def del_Unnamed ( df ) : cols_del = [ c for c in df . columns if 'Unnamed' in c ] return df . drop ( cols_del , axis = 1 )", "docstring_tokens": "Deletes all the unnamed columns", "label": 0}, {"idx": "cosqa-train-6858", "doc": "filter a list based on index python", "code": "def filter_list_by_indices(lst, indices):\n    \"\"\"Return a modified list containing only the indices indicated.\n\n    Args:\n        lst: Original list of values\n        indices: List of indices to keep from the original list\n\n    Returns:\n        list: Filtered list of values\n\n    \"\"\"\n    return [x for i, x in enumerate(lst) if i in indices]", "code_tokens": "def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]", "docstring_tokens": "Return a modified list containing only the indices indicated .", "label": 0}, {"idx": "cosqa-train-6859", "doc": "python how to determine type of function paramters", "code": "def _py_ex_argtype(executable):\n    \"\"\"Returns the code to create the argtype to assign to the methods argtypes\n    attribute.\n    \"\"\"\n    result = []\n    for p in executable.ordered_parameters:\n        atypes = p.argtypes\n        if atypes is not None:\n            result.extend(p.argtypes)\n        else:\n            print((\"No argtypes for: {}\".format(p.definition())))\n\n    if type(executable).__name__ == \"Function\":\n        result.extend(executable.argtypes)        \n            \n    return result", "code_tokens": "def _py_ex_argtype ( executable ) : result = [ ] for p in executable . ordered_parameters : atypes = p . argtypes if atypes is not None : result . extend ( p . argtypes ) else : print ( ( \"No argtypes for: {}\" . format ( p . definition ( ) ) ) ) if type ( executable ) . __name__ == \"Function\" : result . extend ( executable . argtypes ) return result", "docstring_tokens": "Returns the code to create the argtype to assign to the methods argtypes attribute .", "label": 0}, {"idx": "cosqa-train-6860", "doc": "filter list using an index logic python", "code": "def filter_list_by_indices(lst, indices):\n    \"\"\"Return a modified list containing only the indices indicated.\n\n    Args:\n        lst: Original list of values\n        indices: List of indices to keep from the original list\n\n    Returns:\n        list: Filtered list of values\n\n    \"\"\"\n    return [x for i, x in enumerate(lst) if i in indices]", "code_tokens": "def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]", "docstring_tokens": "Return a modified list containing only the indices indicated .", "label": 1}, {"idx": "cosqa-train-6861", "doc": "python how to document properties", "code": "def properties(self):\n        \"\"\"All compartment properties as a dict.\"\"\"\n        properties = {'id': self._id}\n        if self._name is not None:\n            properties['name'] = self._name\n\n        return properties", "code_tokens": "def properties ( self ) : properties = { 'id' : self . _id } if self . _name is not None : properties [ 'name' ] = self . _name return properties", "docstring_tokens": "All compartment properties as a dict .", "label": 0}, {"idx": "cosqa-train-6862", "doc": "finc uniqe values in list of list python", "code": "def unique_list(lst):\n    \"\"\"Make a list unique, retaining order of initial appearance.\"\"\"\n    uniq = []\n    for item in lst:\n        if item not in uniq:\n            uniq.append(item)\n    return uniq", "code_tokens": "def unique_list ( lst ) : uniq = [ ] for item in lst : if item not in uniq : uniq . append ( item ) return uniq", "docstring_tokens": "Make a list unique retaining order of initial appearance .", "label": 1}, {"idx": "cosqa-train-6863", "doc": "python how to get index of a tree item", "code": "def indexTupleFromItem(self, treeItem): # TODO: move to BaseTreeItem?\n        \"\"\" Return (first column model index, last column model index) tuple for a configTreeItem\n        \"\"\"\n        if not treeItem:\n            return (QtCore.QModelIndex(), QtCore.QModelIndex())\n\n        if not treeItem.parentItem: # TODO: only necessary because of childNumber?\n            return (QtCore.QModelIndex(), QtCore.QModelIndex())\n\n        # Is there a bug in Qt in QStandardItemModel::indexFromItem?\n        # It passes the parent in createIndex. TODO: investigate\n\n        row =  treeItem.childNumber()\n        return (self.createIndex(row, 0, treeItem),\n                self.createIndex(row, self.columnCount() - 1, treeItem))", "code_tokens": "def indexTupleFromItem ( self , treeItem ) : # TODO: move to BaseTreeItem? if not treeItem : return ( QtCore . QModelIndex ( ) , QtCore . QModelIndex ( ) ) if not treeItem . parentItem : # TODO: only necessary because of childNumber? return ( QtCore . QModelIndex ( ) , QtCore . QModelIndex ( ) ) # Is there a bug in Qt in QStandardItemModel::indexFromItem? # It passes the parent in createIndex. TODO: investigate row = treeItem . childNumber ( ) return ( self . createIndex ( row , 0 , treeItem ) , self . createIndex ( row , self . columnCount ( ) - 1 , treeItem ) )", "docstring_tokens": "Return ( first column model index last column model index ) tuple for a configTreeItem", "label": 1}, {"idx": "cosqa-train-6864", "doc": "finding a command in python", "code": "def locate(command, on):\n    \"\"\"Locate the command's man page.\"\"\"\n    location = find_page_location(command, on)\n    click.echo(location)", "code_tokens": "def locate ( command , on ) : location = find_page_location ( command , on ) click . echo ( location )", "docstring_tokens": "Locate the command s man page .", "label": 0}, {"idx": "cosqa-train-6865", "doc": "python how to get object id", "code": "def get_obj(ref):\n    \"\"\"Get object from string reference.\"\"\"\n    oid = int(ref)\n    return server.id2ref.get(oid) or server.id2obj[oid]", "code_tokens": "def get_obj ( ref ) : oid = int ( ref ) return server . id2ref . get ( oid ) or server . id2obj [ oid ]", "docstring_tokens": "Get object from string reference .", "label": 0}, {"idx": "cosqa-train-6866", "doc": "finding an element in a 2d list in python", "code": "def find_geom(geom, geoms):\n    \"\"\"\n    Returns the index of a geometry in a list of geometries avoiding\n    expensive equality checks of `in` operator.\n    \"\"\"\n    for i, g in enumerate(geoms):\n        if g is geom:\n            return i", "code_tokens": "def find_geom ( geom , geoms ) : for i , g in enumerate ( geoms ) : if g is geom : return i", "docstring_tokens": "Returns the index of a geometry in a list of geometries avoiding expensive equality checks of in operator .", "label": 1}, {"idx": "cosqa-train-6867", "doc": "python how to get pdf values", "code": "def security(self):\n        \"\"\"Print security object information for a pdf document\"\"\"\n        return {k: v for i in self.pdf.resolvedObjects.items() for k, v in i[1].items()}", "code_tokens": "def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "docstring_tokens": "Print security object information for a pdf document", "label": 1}, {"idx": "cosqa-train-6868", "doc": "finding average of numbers in a list python", "code": "def calc_list_average(l):\n    \"\"\"\n    Calculates the average value of a list of numbers\n    Returns a float\n    \"\"\"\n    total = 0.0\n    for value in l:\n        total += value\n    return total / len(l)", "code_tokens": "def calc_list_average ( l ) : total = 0.0 for value in l : total += value return total / len ( l )", "docstring_tokens": "Calculates the average value of a list of numbers Returns a float", "label": 0}, {"idx": "cosqa-train-6869", "doc": "python how to get year over year growth rate", "code": "def growthfromrange(rangegrowth, startdate, enddate):\n    \"\"\"\n    Annual growth given growth from start date to end date.\n    \"\"\"\n    _yrs = (pd.Timestamp(enddate) - pd.Timestamp(startdate)).total_seconds() /\\\n            dt.timedelta(365.25).total_seconds()\n    return yrlygrowth(rangegrowth, _yrs)", "code_tokens": "def growthfromrange ( rangegrowth , startdate , enddate ) : _yrs = ( pd . Timestamp ( enddate ) - pd . Timestamp ( startdate ) ) . total_seconds ( ) / dt . timedelta ( 365.25 ) . total_seconds ( ) return yrlygrowth ( rangegrowth , _yrs )", "docstring_tokens": "Annual growth given growth from start date to end date .", "label": 1}, {"idx": "cosqa-train-6870", "doc": "finding centroid of a 2d array python", "code": "def find_centroid(region):\n    \"\"\"\n    Finds an approximate centroid for a region that is within the region.\n    \n    Parameters\n    ----------\n    region : np.ndarray(shape=(m, n), dtype='bool')\n        mask of the region.\n\n    Returns\n    -------\n    i, j : tuple(int, int)\n        2d index within the region nearest the center of mass.\n    \"\"\"\n\n    x, y = center_of_mass(region)\n    w = np.argwhere(region)\n    i, j = w[np.argmin(np.linalg.norm(w - (x, y), axis=1))]\n    return i, j", "code_tokens": "def find_centroid ( region ) : x , y = center_of_mass ( region ) w = np . argwhere ( region ) i , j = w [ np . argmin ( np . linalg . norm ( w - ( x , y ) , axis = 1 ) ) ] return i , j", "docstring_tokens": "Finds an approximate centroid for a region that is within the region . Parameters ---------- region : np . ndarray ( shape = ( m n ) dtype = bool ) mask of the region .", "label": 1}, {"idx": "cosqa-train-6871", "doc": "python how to json serialize datetime", "code": "def _time_to_json(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\"\"\"\n    if isinstance(value, datetime.time):\n        value = value.isoformat()\n    return value", "code_tokens": "def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 0}, {"idx": "cosqa-train-6872", "doc": "finding index of number in a list python", "code": "def is_in(self, search_list, pair):\n        \"\"\"\n        If pair is in search_list, return the index. Otherwise return -1\n        \"\"\"\n        index = -1\n        for nr, i in enumerate(search_list):\n            if(np.all(i == pair)):\n                return nr\n        return index", "code_tokens": "def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index", "docstring_tokens": "If pair is in search_list return the index . Otherwise return - 1", "label": 1}, {"idx": "cosqa-train-6873", "doc": "python how to lemmatizer", "code": "def register_modele(self, modele: Modele):\n        \"\"\" Register a modele onto the lemmatizer\n\n        :param modele: Modele to register\n        \"\"\"\n        self.lemmatiseur._modeles[modele.gr()] = modele", "code_tokens": "def register_modele ( self , modele : Modele ) : self . lemmatiseur . _modeles [ modele . gr ( ) ] = modele", "docstring_tokens": "Register a modele onto the lemmatizer", "label": 1}, {"idx": "cosqa-train-6874", "doc": "finding longest element of a list python", "code": "def get_longest_orf(orfs):\n    \"\"\"Find longest ORF from the given list of ORFs.\"\"\"\n    sorted_orf = sorted(orfs, key=lambda x: len(x['sequence']), reverse=True)[0]\n    return sorted_orf", "code_tokens": "def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf", "docstring_tokens": "Find longest ORF from the given list of ORFs .", "label": 1}, {"idx": "cosqa-train-6875", "doc": "python how to make a copy instead of a reference", "code": "def copy(obj):\n    def copy(self):\n        \"\"\"\n        Copy self to a new object.\n        \"\"\"\n        from copy import deepcopy\n\n        return deepcopy(self)\n    obj.copy = copy\n    return obj", "code_tokens": "def copy ( obj ) : def copy ( self ) : \"\"\"\n        Copy self to a new object.\n        \"\"\" from copy import deepcopy return deepcopy ( self ) obj . copy = copy return obj", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-6876", "doc": "finding median of a list python", "code": "def getMedian(numericValues):\n    \"\"\"\n    Gets the median of a list of values\n    Returns a float/int\n    \"\"\"\n    theValues = sorted(numericValues)\n\n    if len(theValues) % 2 == 1:\n        return theValues[(len(theValues) + 1) / 2 - 1]\n    else:\n        lower = theValues[len(theValues) / 2 - 1]\n        upper = theValues[len(theValues) / 2]\n\n        return (float(lower + upper)) / 2", "code_tokens": "def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2", "docstring_tokens": "Gets the median of a list of values Returns a float / int", "label": 1}, {"idx": "cosqa-train-6877", "doc": "python how to make a input defined", "code": "def get_input(input_func, input_str):\n    \"\"\"\n    Get input from the user given an input function and an input string\n    \"\"\"\n    val = input_func(\"Please enter your {0}: \".format(input_str))\n    while not val or not len(val.strip()):\n        val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))\n    return val", "code_tokens": "def get_input ( input_func , input_str ) : val = input_func ( \"Please enter your {0}: \" . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( \"You didn't enter a valid {0}, please try again: \" . format ( input_str ) ) return val", "docstring_tokens": "Get input from the user given an input function and an input string", "label": 1}, {"idx": "cosqa-train-6878", "doc": "finding the longest string in a list using lambda expressions and streams python", "code": "def get_longest_orf(orfs):\n    \"\"\"Find longest ORF from the given list of ORFs.\"\"\"\n    sorted_orf = sorted(orfs, key=lambda x: len(x['sequence']), reverse=True)[0]\n    return sorted_orf", "code_tokens": "def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf", "docstring_tokens": "Find longest ORF from the given list of ORFs .", "label": 1}, {"idx": "cosqa-train-6879", "doc": "python how to make a toolbar", "code": "def add_to_toolbar(self, toolbar, widget):\n        \"\"\"Add widget actions to toolbar\"\"\"\n        actions = widget.toolbar_actions\n        if actions is not None:\n            add_actions(toolbar, actions)", "code_tokens": "def add_to_toolbar ( self , toolbar , widget ) : actions = widget . toolbar_actions if actions is not None : add_actions ( toolbar , actions )", "docstring_tokens": "Add widget actions to toolbar", "label": 0}, {"idx": "cosqa-train-6880", "doc": "finding the minimum distance between two points from a lsit of points in python", "code": "def distL1(x1,y1,x2,y2):\n    \"\"\"Compute the L1-norm (Manhattan) distance between two points.\n\n    The distance is rounded to the closest integer, for compatibility\n    with the TSPLIB convention.\n\n    The two points are located on coordinates (x1,y1) and (x2,y2),\n    sent as parameters\"\"\"\n    return int(abs(x2-x1) + abs(y2-y1)+.5)", "code_tokens": "def distL1 ( x1 , y1 , x2 , y2 ) : return int ( abs ( x2 - x1 ) + abs ( y2 - y1 ) + .5 )", "docstring_tokens": "Compute the L1 - norm ( Manhattan ) distance between two points .", "label": 0}, {"idx": "cosqa-train-6881", "doc": "python how to make a trace back error", "code": "def format_exception(e):\n    \"\"\"Returns a string containing the type and text of the exception.\n\n    \"\"\"\n    from .utils.printing import fill\n    return '\\n'.join(fill(line) for line in traceback.format_exception_only(type(e), e))", "code_tokens": "def format_exception ( e ) : from . utils . printing import fill return '\\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )", "docstring_tokens": "Returns a string containing the type and text of the exception .", "label": 1}, {"idx": "cosqa-train-6882", "doc": "finding the xml path to a specific value in python", "code": "def find(self, node, path):\n        \"\"\"Wrapper for lxml`s find.\"\"\"\n\n        return node.find(path, namespaces=self.namespaces)", "code_tokens": "def find ( self , node , path ) : return node . find ( path , namespaces = self . namespaces )", "docstring_tokens": "Wrapper for lxml s find .", "label": 0}, {"idx": "cosqa-train-6883", "doc": "python how to mark function as deprecated", "code": "def deprecated(operation=None):\n    \"\"\"\n    Mark an operation deprecated.\n    \"\"\"\n    def inner(o):\n        o.deprecated = True\n        return o\n    return inner(operation) if operation else inner", "code_tokens": "def deprecated ( operation = None ) : def inner ( o ) : o . deprecated = True return o return inner ( operation ) if operation else inner", "docstring_tokens": "Mark an operation deprecated .", "label": 0}, {"idx": "cosqa-train-6884", "doc": "finding types of values in a column in python", "code": "def _getTypename(self, defn):\n        \"\"\" Returns the SQL typename required to store the given FieldDefinition \"\"\"\n        return 'REAL' if defn.type.float or 'TIME' in defn.type.name or defn.dntoeu else 'INTEGER'", "code_tokens": "def _getTypename ( self , defn ) : return 'REAL' if defn . type . float or 'TIME' in defn . type . name or defn . dntoeu else 'INTEGER'", "docstring_tokens": "Returns the SQL typename required to store the given FieldDefinition", "label": 1}, {"idx": "cosqa-train-6885", "doc": "python how to modify all field names", "code": "def es_field_sort(fld_name):\n    \"\"\" Used with lambda to sort fields \"\"\"\n    parts = fld_name.split(\".\")\n    if \"_\" not in parts[-1]:\n        parts[-1] = \"_\" + parts[-1]\n    return \".\".join(parts)", "code_tokens": "def es_field_sort ( fld_name ) : parts = fld_name . split ( \".\" ) if \"_\" not in parts [ - 1 ] : parts [ - 1 ] = \"_\" + parts [ - 1 ] return \".\" . join ( parts )", "docstring_tokens": "Used with lambda to sort fields", "label": 1}, {"idx": "cosqa-train-6886", "doc": "first duplicate element in list in python", "code": "def purge_duplicates(list_in):\n    \"\"\"Remove duplicates from list while preserving order.\n\n    Parameters\n    ----------\n    list_in: Iterable\n\n    Returns\n    -------\n    list\n        List of first occurences in order\n    \"\"\"\n    _list = []\n    for item in list_in:\n        if item not in _list:\n            _list.append(item)\n    return _list", "code_tokens": "def purge_duplicates ( list_in ) : _list = [ ] for item in list_in : if item not in _list : _list . append ( item ) return _list", "docstring_tokens": "Remove duplicates from list while preserving order .", "label": 1}, {"idx": "cosqa-train-6887", "doc": "python how to modify mappingproxy", "code": "def _make_proxy_property(bind_attr, attr_name):\n    def proxy_property(self):\n        \"\"\"\n        proxy\n        \"\"\"\n        bind = getattr(self, bind_attr)\n        return getattr(bind, attr_name)\n    return property(proxy_property)", "code_tokens": "def _make_proxy_property ( bind_attr , attr_name ) : def proxy_property ( self ) : \"\"\"\n        proxy\n        \"\"\" bind = getattr ( self , bind_attr ) return getattr ( bind , attr_name ) return property ( proxy_property )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-6888", "doc": "first index greater than a number in python", "code": "def find_ge(a, x):\n    \"\"\"Find leftmost item greater than or equal to x.\"\"\"\n    i = bs.bisect_left(a, x)\n    if i != len(a): return i\n    raise ValueError", "code_tokens": "def find_ge ( a , x ) : i = bs . bisect_left ( a , x ) if i != len ( a ) : return i raise ValueError", "docstring_tokens": "Find leftmost item greater than or equal to x .", "label": 1}, {"idx": "cosqa-train-6889", "doc": "python how to obtain methods and members of a object", "code": "def get_public_members(obj):\n    \"\"\"\n    Retrieves a list of member-like objects (members or properties) that are\n    publically exposed.\n\n    :param obj: The object to probe.\n    :return:    A list of strings.\n    \"\"\"\n    return {attr: getattr(obj, attr) for attr in dir(obj)\n            if not attr.startswith(\"_\")\n            and not hasattr(getattr(obj, attr), '__call__')}", "code_tokens": "def get_public_members ( obj ) : return { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( \"_\" ) and not hasattr ( getattr ( obj , attr ) , '__call__' ) }", "docstring_tokens": "Retrieves a list of member - like objects ( members or properties ) that are publically exposed .", "label": 1}, {"idx": "cosqa-train-6890", "doc": "fitting to an exponential function with python", "code": "def exp_fit_fun(x, a, tau, c):\n    \"\"\"Function used to fit the exponential decay.\"\"\"\n    # pylint: disable=invalid-name\n    return a * np.exp(-x / tau) + c", "code_tokens": "def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "docstring_tokens": "Function used to fit the exponential decay .", "label": 0}, {"idx": "cosqa-train-6891", "doc": "python how to output pprint with a file", "code": "def py(self, output):\n        \"\"\"Output data as a nicely-formatted python data structure\"\"\"\n        import pprint\n        pprint.pprint(output, stream=self.outfile)", "code_tokens": "def py ( self , output ) : import pprint pprint . pprint ( output , stream = self . outfile )", "docstring_tokens": "Output data as a nicely - formatted python data structure", "label": 1}, {"idx": "cosqa-train-6892", "doc": "fix ssl handshake failure python", "code": "def _shutdown_transport(self):\n        \"\"\"Unwrap a Python 2.6 SSL socket, so we can call shutdown()\"\"\"\n        if self.sock is not None:\n            try:\n                unwrap = self.sock.unwrap\n            except AttributeError:\n                return\n            try:\n                self.sock = unwrap()\n            except ValueError:\n                # Failure within SSL might mean unwrap exists but socket is not\n                # deemed wrapped\n                pass", "code_tokens": "def _shutdown_transport ( self ) : if self . sock is not None : try : unwrap = self . sock . unwrap except AttributeError : return try : self . sock = unwrap ( ) except ValueError : # Failure within SSL might mean unwrap exists but socket is not # deemed wrapped pass", "docstring_tokens": "Unwrap a Python 2 . 6 SSL socket so we can call shutdown ()", "label": 1}, {"idx": "cosqa-train-6893", "doc": "python how to remove dublicate letters from a string", "code": "def slugify(string):\n    \"\"\"\n    Removes non-alpha characters, and converts spaces to hyphens. Useful for making file names.\n\n\n    Source: http://stackoverflow.com/questions/5574042/string-slugification-in-python\n    \"\"\"\n    string = re.sub('[^\\w .-]', '', string)\n    string = string.replace(\" \", \"-\")\n    return string", "code_tokens": "def slugify ( string ) : string = re . sub ( '[^\\w .-]' , '' , string ) string = string . replace ( \" \" , \"-\" ) return string", "docstring_tokens": "Removes non - alpha characters and converts spaces to hyphens . Useful for making file names . Source : http : // stackoverflow . com / questions / 5574042 / string - slugification - in - python", "label": 1}, {"idx": "cosqa-train-6894", "doc": "flask python retrieve response header", "code": "def get_trace_id_from_flask():\n    \"\"\"Get trace_id from flask request headers.\n\n    :rtype: str\n    :returns: TraceID in HTTP request headers.\n    \"\"\"\n    if flask is None or not flask.request:\n        return None\n\n    header = flask.request.headers.get(_FLASK_TRACE_HEADER)\n\n    if header is None:\n        return None\n\n    trace_id = header.split(\"/\", 1)[0]\n\n    return trace_id", "code_tokens": "def get_trace_id_from_flask ( ) : if flask is None or not flask . request : return None header = flask . request . headers . get ( _FLASK_TRACE_HEADER ) if header is None : return None trace_id = header . split ( \"/\" , 1 ) [ 0 ] return trace_id", "docstring_tokens": "Get trace_id from flask request headers .", "label": 0}, {"idx": "cosqa-train-6895", "doc": "python how to remove empty element in list", "code": "def unique(_list):\n    \"\"\"\n    Makes the list have unique items only and maintains the order\n\n    list(set()) won't provide that\n\n    :type _list list\n    :rtype: list\n    \"\"\"\n    ret = []\n\n    for item in _list:\n        if item not in ret:\n            ret.append(item)\n\n    return ret", "code_tokens": "def unique ( _list ) : ret = [ ] for item in _list : if item not in ret : ret . append ( item ) return ret", "docstring_tokens": "Makes the list have unique items only and maintains the order", "label": 1}, {"idx": "cosqa-train-6896", "doc": "float image to uint8 python", "code": "def uint32_to_uint8(cls, img):\n        \"\"\"\n        Cast uint32 RGB image to 4 uint8 channels.\n        \"\"\"\n        return np.flipud(img.view(dtype=np.uint8).reshape(img.shape + (4,)))", "code_tokens": "def uint32_to_uint8 ( cls , img ) : return np . flipud ( img . view ( dtype = np . uint8 ) . reshape ( img . shape + ( 4 , ) ) )", "docstring_tokens": "Cast uint32 RGB image to 4 uint8 channels .", "label": 1}, {"idx": "cosqa-train-6897", "doc": "python how to return a copy of a buffer instead of pointer", "code": "def getBuffer(x):\n    \"\"\"\n    Copy @x into a (modifiable) ctypes byte array\n    \"\"\"\n    b = bytes(x)\n    return (c_ubyte * len(b)).from_buffer_copy(bytes(x))", "code_tokens": "def getBuffer ( x ) : b = bytes ( x ) return ( c_ubyte * len ( b ) ) . from_buffer_copy ( bytes ( x ) )", "docstring_tokens": "Copy", "label": 1}, {"idx": "cosqa-train-6898", "doc": "force window position in python", "code": "def OnMove(self, event):\n        \"\"\"Main window move event\"\"\"\n\n        # Store window position in config\n        position = self.main_window.GetScreenPositionTuple()\n\n        config[\"window_position\"] = repr(position)", "code_tokens": "def OnMove ( self , event ) : # Store window position in config position = self . main_window . GetScreenPositionTuple ( ) config [ \"window_position\" ] = repr ( position )", "docstring_tokens": "Main window move event", "label": 1}, {"idx": "cosqa-train-6899", "doc": "python how to save std out", "code": "def _stdout_raw(self, s):\n        \"\"\"Writes the string to stdout\"\"\"\n        print(s, end='', file=sys.stdout)\n        sys.stdout.flush()", "code_tokens": "def _stdout_raw ( self , s ) : print ( s , end = '' , file = sys . stdout ) sys . stdout . flush ( )", "docstring_tokens": "Writes the string to stdout", "label": 1}, {"idx": "cosqa-train-6900", "doc": "format output two decimals python", "code": "def fixed(ctx, number, decimals=2, no_commas=False):\n    \"\"\"\n    Formats the given number in decimal format using a period and commas\n    \"\"\"\n    value = _round(ctx, number, decimals)\n    format_str = '{:f}' if no_commas else '{:,f}'\n    return format_str.format(value)", "code_tokens": "def fixed ( ctx , number , decimals = 2 , no_commas = False ) : value = _round ( ctx , number , decimals ) format_str = '{:f}' if no_commas else '{:,f}' return format_str . format ( value )", "docstring_tokens": "Formats the given number in decimal format using a period and commas", "label": 0}, {"idx": "cosqa-train-6901", "doc": "python how to see all libraries", "code": "def list_backends(_):\n    \"\"\"List all available backends.\"\"\"\n    backends = [b.__name__ for b in available_backends()]\n    print('\\n'.join(backends))", "code_tokens": "def list_backends ( _ ) : backends = [ b . __name__ for b in available_backends ( ) ] print ( '\\n' . join ( backends ) )", "docstring_tokens": "List all available backends .", "label": 1}, {"idx": "cosqa-train-6902", "doc": "fourier series with python", "code": "def fourier_series(x, f, n=0):\n    \"\"\"\n    Returns a symbolic fourier series of order `n`.\n\n    :param n: Order of the fourier series.\n    :param x: Independent variable\n    :param f: Frequency of the fourier series\n    \"\"\"\n    # Make the parameter objects for all the terms\n    a0, *cos_a = parameters(','.join(['a{}'.format(i) for i in range(0, n + 1)]))\n    sin_b = parameters(','.join(['b{}'.format(i) for i in range(1, n + 1)]))\n    # Construct the series\n    series = a0 + sum(ai * cos(i * f * x) + bi * sin(i * f * x)\n                     for i, (ai, bi) in enumerate(zip(cos_a, sin_b), start=1))\n    return series", "code_tokens": "def fourier_series ( x , f , n = 0 ) : # Make the parameter objects for all the terms a0 ,  * cos_a = parameters ( ',' . join ( [ 'a{}' . format ( i ) for i in range ( 0 , n + 1 ) ] ) ) sin_b = parameters ( ',' . join ( [ 'b{}' . format ( i ) for i in range ( 1 , n + 1 ) ] ) ) # Construct the series series = a0 + sum ( ai * cos ( i * f * x ) + bi * sin ( i * f * x ) for i , ( ai , bi ) in enumerate ( zip ( cos_a , sin_b ) , start = 1 ) ) return series", "docstring_tokens": "Returns a symbolic fourier series of order n .", "label": 1}, {"idx": "cosqa-train-6903", "doc": "python how to see all the attributes an object contains", "code": "def dict_from_object(obj: object):\n    \"\"\"Convert a object into dictionary with all of its readable attributes.\"\"\"\n\n    # If object is a dict instance, no need to convert.\n    return (obj if isinstance(obj, dict)\n            else {attr: getattr(obj, attr)\n                  for attr in dir(obj) if not attr.startswith('_')})", "code_tokens": "def dict_from_object ( obj : object ) : # If object is a dict instance, no need to convert. return ( obj if isinstance ( obj , dict ) else { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( '_' ) } )", "docstring_tokens": "Convert a object into dictionary with all of its readable attributes .", "label": 1}, {"idx": "cosqa-train-6904", "doc": "from meter to degree python longitude", "code": "def _convert_latitude(self, latitude):\n        \"\"\"Convert from latitude to the y position in overall map.\"\"\"\n        return int((180 - (180 / pi * log(tan(\n            pi / 4 + latitude * pi / 360)))) * (2 ** self._zoom) * self._size / 360)", "code_tokens": "def _convert_latitude ( self , latitude ) : return int ( ( 180 - ( 180 / pi * log ( tan ( pi / 4 + latitude * pi / 360 ) ) ) ) * ( 2 ** self . _zoom ) * self . _size / 360 )", "docstring_tokens": "Convert from latitude to the y position in overall map .", "label": 0}, {"idx": "cosqa-train-6905", "doc": "python how to set default jvm path", "code": "def get_java_path():\n  \"\"\"Get the path of java executable\"\"\"\n  java_home = os.environ.get(\"JAVA_HOME\")\n  return os.path.join(java_home, BIN_DIR, \"java\")", "code_tokens": "def get_java_path ( ) : java_home = os . environ . get ( \"JAVA_HOME\" ) return os . path . join ( java_home , BIN_DIR , \"java\" )", "docstring_tokens": "Get the path of java executable", "label": 0}, {"idx": "cosqa-train-6906", "doc": "python how to set the x ticks for loglog plot", "code": "def set_logxticks_for_all(self, row_column_list=None, logticks=None):\n        \"\"\"Manually specify the x-axis log tick values.\n\n        :param row_column_list: a list containing (row, column) tuples to\n            specify the subplots, or None to indicate *all* subplots.\n        :type row_column_list: list or None\n        :param logticks: logarithm of the locations for the ticks along the\n            axis.\n\n        For example, if you specify [1, 2, 3], ticks will be placed at 10,\n        100 and 1000.\n\n        \"\"\"\n        if row_column_list is None:\n            self.ticks['x'] = ['1e%d' % u for u in logticks]\n        else:\n            for row, column in row_column_list:\n                self.set_logxticks(row, column, logticks)", "code_tokens": "def set_logxticks_for_all ( self , row_column_list = None , logticks = None ) : if row_column_list is None : self . ticks [ 'x' ] = [ '1e%d' % u for u in logticks ] else : for row , column in row_column_list : self . set_logxticks ( row , column , logticks )", "docstring_tokens": "Manually specify the x - axis log tick values .", "label": 0}, {"idx": "cosqa-train-6907", "doc": "frop row if column value matches in data frame in python", "code": "def remove_rows_matching(df, column, match):\n    \"\"\"\n    Return a ``DataFrame`` with rows where `column` values match `match` are removed.\n\n    The selected `column` series of values from the supplied Pandas ``DataFrame`` is compared\n    to `match`, and those rows that match are removed from the DataFrame.\n\n    :param df: Pandas ``DataFrame``\n    :param column: Column indexer\n    :param match: ``str`` match target\n    :return: Pandas ``DataFrame`` filtered\n    \"\"\"\n    df = df.copy()\n    mask = df[column].values != match\n    return df.iloc[mask, :]", "code_tokens": "def remove_rows_matching ( df , column , match ) : df = df . copy ( ) mask = df [ column ] . values != match return df . iloc [ mask , : ]", "docstring_tokens": "Return a DataFrame with rows where column values match match are removed .", "label": 1}, {"idx": "cosqa-train-6908", "doc": "python how to specify type", "code": "def get_kind(self, value):\n        \"\"\"Return the kind (type) of the attribute\"\"\"\n        if isinstance(value, float):\n            return 'f'\n        elif isinstance(value, int):\n            return 'i'\n        else:\n            raise ValueError(\"Only integer or floating point values can be stored.\")", "code_tokens": "def get_kind ( self , value ) : if isinstance ( value , float ) : return 'f' elif isinstance ( value , int ) : return 'i' else : raise ValueError ( \"Only integer or floating point values can be stored.\" )", "docstring_tokens": "Return the kind ( type ) of the attribute", "label": 0}, {"idx": "cosqa-train-6909", "doc": "funcions in python to show bottom five rows in python", "code": "def table_top_abs(self):\n        \"\"\"Returns the absolute position of table top\"\"\"\n        table_height = np.array([0, 0, self.table_full_size[2]])\n        return string_to_array(self.floor.get(\"pos\")) + table_height", "code_tokens": "def table_top_abs ( self ) : table_height = np . array ( [ 0 , 0 , self . table_full_size [ 2 ] ] ) return string_to_array ( self . floor . get ( \"pos\" ) ) + table_height", "docstring_tokens": "Returns the absolute position of table top", "label": 1}, {"idx": "cosqa-train-6910", "doc": "python how to tell if all the items in a list are the same", "code": "def allsame(list_, strict=True):\n    \"\"\"\n    checks to see if list is equal everywhere\n\n    Args:\n        list_ (list):\n\n    Returns:\n        True if all items in the list are equal\n    \"\"\"\n    if len(list_) == 0:\n        return True\n    first_item = list_[0]\n    return list_all_eq_to(list_, first_item, strict)", "code_tokens": "def allsame ( list_ , strict = True ) : if len ( list_ ) == 0 : return True first_item = list_ [ 0 ] return list_all_eq_to ( list_ , first_item , strict )", "docstring_tokens": "checks to see if list is equal everywhere", "label": 1}, {"idx": "cosqa-train-6911", "doc": "function for euclidean distances in python", "code": "def euclidean(c1, c2):\n    \"\"\"Square of the euclidean distance\"\"\"\n    diffs = ((i - j) for i, j in zip(c1, c2))\n    return sum(x * x for x in diffs)", "code_tokens": "def euclidean ( c1 , c2 ) : diffs = ( ( i - j ) for i , j in zip ( c1 , c2 ) ) return sum ( x * x for x in diffs )", "docstring_tokens": "Square of the euclidean distance", "label": 0}, {"idx": "cosqa-train-6912", "doc": "python how to tell methods and properties of an object", "code": "def get_public_members(obj):\n    \"\"\"\n    Retrieves a list of member-like objects (members or properties) that are\n    publically exposed.\n\n    :param obj: The object to probe.\n    :return:    A list of strings.\n    \"\"\"\n    return {attr: getattr(obj, attr) for attr in dir(obj)\n            if not attr.startswith(\"_\")\n            and not hasattr(getattr(obj, attr), '__call__')}", "code_tokens": "def get_public_members ( obj ) : return { attr : getattr ( obj , attr ) for attr in dir ( obj ) if not attr . startswith ( \"_\" ) and not hasattr ( getattr ( obj , attr ) , '__call__' ) }", "docstring_tokens": "Retrieves a list of member - like objects ( members or properties ) that are publically exposed .", "label": 0}, {"idx": "cosqa-train-6913", "doc": "function to inverse matrix python", "code": "def inh(table):\n    \"\"\"\n    inverse hyperbolic sine transformation\n    \"\"\"\n    t = []\n    for i in table:\n        t.append(np.ndarray.tolist(np.arcsinh(i)))\n    return t", "code_tokens": "def inh ( table ) : t = [ ] for i in table : t . append ( np . ndarray . tolist ( np . arcsinh ( i ) ) ) return t", "docstring_tokens": "inverse hyperbolic sine transformation", "label": 1}, {"idx": "cosqa-train-6914", "doc": "python how to turn a string into a list", "code": "def path_to_list(pathstr):\n    \"\"\"Conver a path string to a list of path elements.\"\"\"\n    return [elem for elem in pathstr.split(os.path.pathsep) if elem]", "code_tokens": "def path_to_list ( pathstr ) : return [ elem for elem in pathstr . split ( os . path . pathsep ) if elem ]", "docstring_tokens": "Conver a path string to a list of path elements .", "label": 1}, {"idx": "cosqa-train-6915", "doc": "function you can use after dot python", "code": "def exit_if_missing_graphviz(self):\n        \"\"\"\n        Detect the presence of the dot utility to make a png graph.\n        \"\"\"\n        (out, err) = utils.capture_shell(\"which dot\")\n\n        if \"dot\" not in out:\n            ui.error(c.MESSAGES[\"dot_missing\"])", "code_tokens": "def exit_if_missing_graphviz ( self ) : ( out , err ) = utils . capture_shell ( \"which dot\" ) if \"dot\" not in out : ui . error ( c . MESSAGES [ \"dot_missing\" ] )", "docstring_tokens": "Detect the presence of the dot utility to make a png graph .", "label": 1}, {"idx": "cosqa-train-6916", "doc": "python how to unpack scroll bar in grid", "code": "def __grid_widgets(self):\n        \"\"\"Places all the child widgets in the appropriate positions.\"\"\"\n        scrollbar_column = 0 if self.__compound is tk.LEFT else 2\n        self._canvas.grid(row=0, column=1, sticky=\"nswe\")\n        self._scrollbar.grid(row=0, column=scrollbar_column, sticky=\"ns\")", "code_tokens": "def __grid_widgets ( self ) : scrollbar_column = 0 if self . __compound is tk . LEFT else 2 self . _canvas . grid ( row = 0 , column = 1 , sticky = \"nswe\" ) self . _scrollbar . grid ( row = 0 , column = scrollbar_column , sticky = \"ns\" )", "docstring_tokens": "Places all the child widgets in the appropriate positions .", "label": 1}, {"idx": "cosqa-train-6917", "doc": "generate 100 unique 15 numbers in python", "code": "def _uniqueid(n=30):\n    \"\"\"Return a unique string with length n.\n\n    :parameter int N: number of character in the uniqueid\n    :return: the uniqueid\n    :rtype: str\n    \"\"\"\n    return ''.join(random.SystemRandom().choice(\n                   string.ascii_uppercase + string.ascii_lowercase)\n                   for _ in range(n))", "code_tokens": "def _uniqueid ( n = 30 ) : return '' . join ( random . SystemRandom ( ) . choice ( string . ascii_uppercase + string . ascii_lowercase ) for _ in range ( n ) )", "docstring_tokens": "Return a unique string with length n .", "label": 1}, {"idx": "cosqa-train-6918", "doc": "python how to use matplot histogram and not show plot", "code": "def plot(self):\n        \"\"\"Plot the empirical histogram versus best-fit distribution's PDF.\"\"\"\n        plt.plot(self.bin_edges, self.hist, self.bin_edges, self.best_pdf)", "code_tokens": "def plot ( self ) : plt . plot ( self . bin_edges , self . hist , self . bin_edges , self . best_pdf )", "docstring_tokens": "Plot the empirical histogram versus best - fit distribution s PDF .", "label": 0}, {"idx": "cosqa-train-6919", "doc": "generate a dotfile in python d tree", "code": "def to_dotfile(self):\n        \"\"\" Writes a DOT graphviz file of the domain structure, and returns the filename\"\"\"\n        domain = self.get_domain()\n        filename = \"%s.dot\" % (self.__class__.__name__)\n        nx.write_dot(domain, filename)\n        return filename", "code_tokens": "def to_dotfile ( self ) : domain = self . get_domain ( ) filename = \"%s.dot\" % ( self . __class__ . __name__ ) nx . write_dot ( domain , filename ) return filename", "docstring_tokens": "Writes a DOT graphviz file of the domain structure and returns the filename", "label": 1}, {"idx": "cosqa-train-6920", "doc": "python how to write an empty line in write", "code": "def write_line(self, line, count=1):\n        \"\"\"writes the line and count newlines after the line\"\"\"\n        self.write(line)\n        self.write_newlines(count)", "code_tokens": "def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )", "docstring_tokens": "writes the line and count newlines after the line", "label": 0}, {"idx": "cosqa-train-6921", "doc": "generate a list with gap python", "code": "def _gaps_from(intervals):\n    \"\"\"\n    From a list of intervals extract\n    a list of sorted gaps in the form of [(g,i)]\n    where g is the size of the ith gap.\n    \"\"\"\n    sliding_window = zip(intervals, intervals[1:])\n    gaps = [b[0] - a[1] for a, b in sliding_window]\n    return gaps", "code_tokens": "def _gaps_from ( intervals ) : sliding_window = zip ( intervals , intervals [ 1 : ] ) gaps = [ b [ 0 ] - a [ 1 ] for a , b in sliding_window ] return gaps", "docstring_tokens": "From a list of intervals extract a list of sorted gaps in the form of [ ( g i ) ] where g is the size of the ith gap .", "label": 1}, {"idx": "cosqa-train-6922", "doc": "python how to write dict to json file", "code": "def _write_json(file, contents):\n    \"\"\"Write a dict to a JSON file.\"\"\"\n    with open(file, 'w') as f:\n        return json.dump(contents, f, indent=2, sort_keys=True)", "code_tokens": "def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )", "docstring_tokens": "Write a dict to a JSON file .", "label": 1}, {"idx": "cosqa-train-6923", "doc": "generate latex table python", "code": "def get_latex_table(self, parameters=None, transpose=False, caption=None,\n                        label=\"tab:model_params\", hlines=True, blank_fill=\"--\"):  # pragma: no cover\n        \"\"\" Generates a LaTeX table from parameter summaries.\n\n        Parameters\n        ----------\n        parameters : list[str], optional\n            A list of what parameters to include in the table. By default, includes all parameters\n        transpose : bool, optional\n            Defaults to False, which gives each column as a parameter, each chain (framework)\n            as a row. You can swap it so that you have a parameter each row and a framework\n            each column by setting this to True\n        caption : str, optional\n            If you want to generate a caption for the table through Python, use this.\n            Defaults to an empty string\n        label : str, optional\n            If you want to generate a label for the table through Python, use this.\n            Defaults to an empty string\n        hlines : bool, optional\n            Inserts ``\\\\hline`` before and after the header, and at the end of table.\n        blank_fill : str, optional\n            If a framework does not have a particular parameter, will fill that cell of\n            the table with this string.\n\n        Returns\n        -------\n        str\n            the LaTeX table.\n        \"\"\"\n        if parameters is None:\n            parameters = self.parent._all_parameters\n        for p in parameters:\n            assert isinstance(p, str), \\\n                \"Generating a LaTeX table requires all parameters have labels\"\n        num_parameters = len(parameters)\n        num_chains = len(self.parent.chains)\n        fit_values = self.get_summary(squeeze=False)\n        if label is None:\n            label = \"\"\n        if caption is None:\n            caption = \"\"\n\n        end_text = \" \\\\\\\\ \\n\"\n        if transpose:\n            column_text = \"c\" * (num_chains + 1)\n        else:\n            column_text = \"c\" * (num_parameters + 1)\n\n        center_text = \"\"\n        hline_text = \"\\\\hline\\n\"\n        if hlines:\n            center_text += hline_text + \"\\t\\t\"\n        if transpose:\n            center_text += \" & \".join([\"Parameter\"] + [c.name for c in self.parent.chains]) + end_text\n            if hlines:\n                center_text += \"\\t\\t\" + hline_text\n            for p in parameters:\n                arr = [\"\\t\\t\" + p]\n                for chain_res in fit_values:\n                    if p in chain_res:\n                        arr.append(self.get_parameter_text(*chain_res[p], wrap=True))\n                    else:\n                        arr.append(blank_fill)\n                center_text += \" & \".join(arr) + end_text\n        else:\n            center_text += \" & \".join([\"Model\"] + parameters) + end_text\n            if hlines:\n                center_text += \"\\t\\t\" + hline_text\n            for name, chain_res in zip([c.name for c in self.parent.chains], fit_values):\n                arr = [\"\\t\\t\" + name]\n                for p in parameters:\n                    if p in chain_res:\n                        arr.append(self.get_parameter_text(*chain_res[p], wrap=True))\n                    else:\n                        arr.append(blank_fill)\n                center_text += \" & \".join(arr) + end_text\n        if hlines:\n            center_text += \"\\t\\t\" + hline_text\n        final_text = get_latex_table_frame(caption, label) % (column_text, center_text)\n\n        return final_text", "code_tokens": "def get_latex_table ( self , parameters = None , transpose = False , caption = None , label = \"tab:model_params\" , hlines = True , blank_fill = \"--\" ) : # pragma: no cover if parameters is None : parameters = self . parent . _all_parameters for p in parameters : assert isinstance ( p , str ) , \"Generating a LaTeX table requires all parameters have labels\" num_parameters = len ( parameters ) num_chains = len ( self . parent . chains ) fit_values = self . get_summary ( squeeze = False ) if label is None : label = \"\" if caption is None : caption = \"\" end_text = \" \\\\\\\\ \\n\" if transpose : column_text = \"c\" * ( num_chains + 1 ) else : column_text = \"c\" * ( num_parameters + 1 ) center_text = \"\" hline_text = \"\\\\hline\\n\" if hlines : center_text += hline_text + \"\\t\\t\" if transpose : center_text += \" & \" . join ( [ \"Parameter\" ] + [ c . name for c in self . parent . chains ] ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text for p in parameters : arr = [ \"\\t\\t\" + p ] for chain_res in fit_values : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += \" & \" . join ( arr ) + end_text else : center_text += \" & \" . join ( [ \"Model\" ] + parameters ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text for name , chain_res in zip ( [ c . name for c in self . parent . chains ] , fit_values ) : arr = [ \"\\t\\t\" + name ] for p in parameters : if p in chain_res : arr . append ( self . get_parameter_text ( * chain_res [ p ] , wrap = True ) ) else : arr . append ( blank_fill ) center_text += \" & \" . join ( arr ) + end_text if hlines : center_text += \"\\t\\t\" + hline_text final_text = get_latex_table_frame ( caption , label ) % ( column_text , center_text ) return final_text", "docstring_tokens": "Generates a LaTeX table from parameter summaries .", "label": 0}, {"idx": "cosqa-train-6924", "doc": "python how to write string to file", "code": "def write_str2file(pathname, astr):\n    \"\"\"writes a string to file\"\"\"\n    fname = pathname\n    fhandle = open(fname, 'wb')\n    fhandle.write(astr)\n    fhandle.close()", "code_tokens": "def write_str2file ( pathname , astr ) : fname = pathname fhandle = open ( fname , 'wb' ) fhandle . write ( astr ) fhandle . close ( )", "docstring_tokens": "writes a string to file", "label": 1}, {"idx": "cosqa-train-6925", "doc": "generate log normal distribution in python", "code": "def ln_norm(x, mu, sigma=1.0):\n    \"\"\" Natural log of scipy norm function truncated at zero \"\"\"\n    return np.log(stats.norm(loc=mu, scale=sigma).pdf(x))", "code_tokens": "def ln_norm ( x , mu , sigma = 1.0 ) : return np . log ( stats . norm ( loc = mu , scale = sigma ) . pdf ( x ) )", "docstring_tokens": "Natural log of scipy norm function truncated at zero", "label": 1}, {"idx": "cosqa-train-6926", "doc": "python html table template", "code": "def html(header_rows):\n    \"\"\"\n    Convert a list of tuples describing a table into a HTML string\n    \"\"\"\n    name = 'table%d' % next(tablecounter)\n    return HtmlTable([map(str, row) for row in header_rows], name).render()", "code_tokens": "def html ( header_rows ) : name = 'table%d' % next ( tablecounter ) return HtmlTable ( [ map ( str , row ) for row in header_rows ] , name ) . render ( )", "docstring_tokens": "Convert a list of tuples describing a table into a HTML string", "label": 1}, {"idx": "cosqa-train-6927", "doc": "generate string of random variables in python", "code": "def _get_random_id():\n    \"\"\" Get a random (i.e., unique) string identifier\"\"\"\n    symbols = string.ascii_uppercase + string.ascii_lowercase + string.digits\n    return ''.join(random.choice(symbols) for _ in range(15))", "code_tokens": "def _get_random_id ( ) : symbols = string . ascii_uppercase + string . ascii_lowercase + string . digits return '' . join ( random . choice ( symbols ) for _ in range ( 15 ) )", "docstring_tokens": "Get a random ( i . e . unique ) string identifier", "label": 1}, {"idx": "cosqa-train-6928", "doc": "python http header identfication", "code": "def add_header(self, name, value):\n        \"\"\" Add an additional response header, not removing duplicates. \"\"\"\n        self._headers.setdefault(_hkey(name), []).append(_hval(value))", "code_tokens": "def add_header ( self , name , value ) : self . _headers . setdefault ( _hkey ( name ) , [ ] ) . append ( _hval ( value ) )", "docstring_tokens": "Add an additional response header not removing duplicates .", "label": 1}, {"idx": "cosqa-train-6929", "doc": "generate uniform random variables in python", "code": "def runiform(lower, upper, size=None):\n    \"\"\"\n    Random uniform variates.\n    \"\"\"\n    return np.random.uniform(lower, upper, size)", "code_tokens": "def runiform ( lower , upper , size = None ) : return np . random . uniform ( lower , upper , size )", "docstring_tokens": "Random uniform variates .", "label": 1}, {"idx": "cosqa-train-6930", "doc": "python identify a url and filename", "code": "def get_file_name(url):\n  \"\"\"Returns file name of file at given url.\"\"\"\n  return os.path.basename(urllib.parse.urlparse(url).path) or 'unknown_name'", "code_tokens": "def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'", "docstring_tokens": "Returns file name of file at given url .", "label": 1}, {"idx": "cosqa-train-6931", "doc": "generate white noise python", "code": "def normal_noise(points):\n    \"\"\"Init a noise variable.\"\"\"\n    return np.random.rand(1) * np.random.randn(points, 1) \\\n        + random.sample([2, -2], 1)", "code_tokens": "def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "docstring_tokens": "Init a noise variable .", "label": 0}, {"idx": "cosqa-train-6932", "doc": "python identify dns server lookup", "code": "def test():\n    \"\"\"Test for ReverseDNS class\"\"\"\n    dns = ReverseDNS()\n\n    print(dns.lookup('192.168.0.1'))\n    print(dns.lookup('8.8.8.8'))\n\n    # Test cache\n    print(dns.lookup('8.8.8.8'))", "code_tokens": "def test ( ) : dns = ReverseDNS ( ) print ( dns . lookup ( '192.168.0.1' ) ) print ( dns . lookup ( '8.8.8.8' ) ) # Test cache print ( dns . lookup ( '8.8.8.8' ) )", "docstring_tokens": "Test for ReverseDNS class", "label": 0}, {"idx": "cosqa-train-6933", "doc": "python identify the lowest value", "code": "def find_le(a, x):\n    \"\"\"Find rightmost value less than or equal to x.\"\"\"\n    i = bs.bisect_right(a, x)\n    if i: return i - 1\n    raise ValueError", "code_tokens": "def find_le ( a , x ) : i = bs . bisect_right ( a , x ) if i : return i - 1 raise ValueError", "docstring_tokens": "Find rightmost value less than or equal to x .", "label": 0}, {"idx": "cosqa-train-6934", "doc": "generating random alphanumeric values in python", "code": "def random_alphanum(length):\n    \"\"\"\n    Return a random string of ASCII letters and digits.\n\n    :param int length: The length of string to return\n    :returns: A random string\n    :rtype: str\n    \"\"\"\n    charset = string.ascii_letters + string.digits\n    return random_string(length, charset)", "code_tokens": "def random_alphanum ( length ) : charset = string . ascii_letters + string . digits return random_string ( length , charset )", "docstring_tokens": "Return a random string of ASCII letters and digits .", "label": 1}, {"idx": "cosqa-train-6935", "doc": "python if a series is nan", "code": "def na_if(series, *values):\n    \"\"\"\n    If values in a series match a specified value, change them to `np.nan`.\n\n    Args:\n        series: Series or vector, often symbolic.\n        *values: Value(s) to convert to `np.nan` in the series.\n    \"\"\"\n\n    series = pd.Series(series)\n    series[series.isin(values)] = np.nan\n    return series", "code_tokens": "def na_if ( series , * values ) : series = pd . Series ( series ) series [ series . isin ( values ) ] = np . nan return series", "docstring_tokens": "If values in a series match a specified value change them to np . nan .", "label": 1}, {"idx": "cosqa-train-6936", "doc": "get a list of all availible bluetooth devices python", "code": "def get_available_gpus():\n  \"\"\"\n  Returns a list of string names of all available GPUs\n  \"\"\"\n  local_device_protos = device_lib.list_local_devices()\n  return [x.name for x in local_device_protos if x.device_type == 'GPU']", "code_tokens": "def get_available_gpus ( ) : local_device_protos = device_lib . list_local_devices ( ) return [ x . name for x in local_device_protos if x . device_type == 'GPU' ]", "docstring_tokens": "Returns a list of string names of all available GPUs", "label": 1}, {"idx": "cosqa-train-6937", "doc": "python if a web element is present", "code": "def is_element_present(driver, selector, by=By.CSS_SELECTOR):\n    \"\"\"\n    Returns whether the specified element selector is present on the page.\n    @Params\n    driver - the webdriver object (required)\n    selector - the locator that is used (required)\n    by - the method to search for the locator (Default: By.CSS_SELECTOR)\n    @Returns\n    Boolean (is element present)\n    \"\"\"\n    try:\n        driver.find_element(by=by, value=selector)\n        return True\n    except Exception:\n        return False", "code_tokens": "def is_element_present ( driver , selector , by = By . CSS_SELECTOR ) : try : driver . find_element ( by = by , value = selector ) return True except Exception : return False", "docstring_tokens": "Returns whether the specified element selector is present on the page .", "label": 0}, {"idx": "cosqa-train-6938", "doc": "get all permutations python", "code": "def circ_permutation(items):\n    \"\"\"Calculate the circular permutation for a given list of items.\"\"\"\n    permutations = []\n    for i in range(len(items)):\n        permutations.append(items[i:] + items[:i])\n    return permutations", "code_tokens": "def circ_permutation ( items ) : permutations = [ ] for i in range ( len ( items ) ) : permutations . append ( items [ i : ] + items [ : i ] ) return permutations", "docstring_tokens": "Calculate the circular permutation for a given list of items .", "label": 0}, {"idx": "cosqa-train-6939", "doc": "python if variarble exists", "code": "def _is_name_used_as_variadic(name, variadics):\n    \"\"\"Check if the given name is used as a variadic argument.\"\"\"\n    return any(\n        variadic.value == name or variadic.value.parent_of(name)\n        for variadic in variadics\n    )", "code_tokens": "def _is_name_used_as_variadic ( name , variadics ) : return any ( variadic . value == name or variadic . value . parent_of ( name ) for variadic in variadics )", "docstring_tokens": "Check if the given name is used as a variadic argument .", "label": 1}, {"idx": "cosqa-train-6940", "doc": "get ancestors of a node networkx python", "code": "def ancestors(self, node):\n        \"\"\"Returns set of the ancestors of a node as DAGNodes.\"\"\"\n        if isinstance(node, int):\n            warnings.warn('Calling ancestors() with a node id is deprecated,'\n                          ' use a DAGNode instead',\n                          DeprecationWarning, 2)\n            node = self._id_to_node[node]\n\n        return nx.ancestors(self._multi_graph, node)", "code_tokens": "def ancestors ( self , node ) : if isinstance ( node , int ) : warnings . warn ( 'Calling ancestors() with a node id is deprecated,' ' use a DAGNode instead' , DeprecationWarning , 2 ) node = self . _id_to_node [ node ] return nx . ancestors ( self . _multi_graph , node )", "docstring_tokens": "Returns set of the ancestors of a node as DAGNodes .", "label": 1}, {"idx": "cosqa-train-6941", "doc": "python image background crop", "code": "def _trim(image):\n    \"\"\"Trim a PIL image and remove white space.\"\"\"\n    background = PIL.Image.new(image.mode, image.size, image.getpixel((0, 0)))\n    diff = PIL.ImageChops.difference(image, background)\n    diff = PIL.ImageChops.add(diff, diff, 2.0, -100)\n    bbox = diff.getbbox()\n    if bbox:\n        image = image.crop(bbox)\n    return image", "code_tokens": "def _trim ( image ) : background = PIL . Image . new ( image . mode , image . size , image . getpixel ( ( 0 , 0 ) ) ) diff = PIL . ImageChops . difference ( image , background ) diff = PIL . ImageChops . add ( diff , diff , 2.0 , - 100 ) bbox = diff . getbbox ( ) if bbox : image = image . crop ( bbox ) return image", "docstring_tokens": "Trim a PIL image and remove white space .", "label": 1}, {"idx": "cosqa-train-6942", "doc": "get array tif image python", "code": "def ReadTif(tifFile):\n        \"\"\"Reads a tif file to a 2D NumPy array\"\"\"\n        img = Image.open(tifFile)\n        img = np.array(img)\n        return img", "code_tokens": "def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img", "docstring_tokens": "Reads a tif file to a 2D NumPy array", "label": 0}, {"idx": "cosqa-train-6943", "doc": "python image convolve with mask", "code": "def convolve_gaussian_2d(image, gaussian_kernel_1d):\n    \"\"\"Convolve 2d gaussian.\"\"\"\n    result = scipy.ndimage.filters.correlate1d(\n        image, gaussian_kernel_1d, axis=0)\n    result = scipy.ndimage.filters.correlate1d(\n        result, gaussian_kernel_1d, axis=1)\n    return result", "code_tokens": "def convolve_gaussian_2d ( image , gaussian_kernel_1d ) : result = scipy . ndimage . filters . correlate1d ( image , gaussian_kernel_1d , axis = 0 ) result = scipy . ndimage . filters . correlate1d ( result , gaussian_kernel_1d , axis = 1 ) return result", "docstring_tokens": "Convolve 2d gaussian .", "label": 1}, {"idx": "cosqa-train-6944", "doc": "get attr function python", "code": "def get_attr(self, method_name):\n        \"\"\"Get attribute from the target object\"\"\"\n        return self.attrs.get(method_name) or self.get_callable_attr(method_name)", "code_tokens": "def get_attr ( self , method_name ) : return self . attrs . get ( method_name ) or self . get_callable_attr ( method_name )", "docstring_tokens": "Get attribute from the target object", "label": 0}, {"idx": "cosqa-train-6945", "doc": "python image detect shape", "code": "def get_shape(img):\n    \"\"\"Return the shape of img.\n\n    Paramerers\n    -----------\n    img:\n\n    Returns\n    -------\n    shape: tuple\n    \"\"\"\n    if hasattr(img, 'shape'):\n        shape = img.shape\n    else:\n        shape = img.get_data().shape\n    return shape", "code_tokens": "def get_shape ( img ) : if hasattr ( img , 'shape' ) : shape = img . shape else : shape = img . get_data ( ) . shape return shape", "docstring_tokens": "Return the shape of img .", "label": 1}, {"idx": "cosqa-train-6946", "doc": "get child loggers python", "code": "def _get_loggers():\n    \"\"\"Return list of Logger classes.\"\"\"\n    from .. import loader\n    modules = loader.get_package_modules('logger')\n    return list(loader.get_plugins(modules, [_Logger]))", "code_tokens": "def _get_loggers ( ) : from . . import loader modules = loader . get_package_modules ( 'logger' ) return list ( loader . get_plugins ( modules , [ _Logger ] ) )", "docstring_tokens": "Return list of Logger classes .", "label": 1}, {"idx": "cosqa-train-6947", "doc": "python image getcolors red blue green", "code": "def get_colors(img):\n    \"\"\"\n    Returns a list of all the image's colors.\n    \"\"\"\n    w, h = img.size\n    return [color[:3] for count, color in img.convert('RGB').getcolors(w * h)]", "code_tokens": "def get_colors ( img ) : w , h = img . size return [ color [ : 3 ] for count , color in img . convert ( 'RGB' ) . getcolors ( w * h ) ]", "docstring_tokens": "Returns a list of all the image s colors .", "label": 1}, {"idx": "cosqa-train-6948", "doc": "get content from macos clipboard python", "code": "def osx_clipboard_get():\n    \"\"\" Get the clipboard's text on OS X.\n    \"\"\"\n    p = subprocess.Popen(['pbpaste', '-Prefer', 'ascii'],\n        stdout=subprocess.PIPE)\n    text, stderr = p.communicate()\n    # Text comes in with old Mac \\r line endings. Change them to \\n.\n    text = text.replace('\\r', '\\n')\n    return text", "code_tokens": "def osx_clipboard_get ( ) : p = subprocess . Popen ( [ 'pbpaste' , '-Prefer' , 'ascii' ] , stdout = subprocess . PIPE ) text , stderr = p . communicate ( ) # Text comes in with old Mac \\r line endings. Change them to \\n. text = text . replace ( '\\r' , '\\n' ) return text", "docstring_tokens": "Get the clipboard s text on OS X .", "label": 1}, {"idx": "cosqa-train-6949", "doc": "python image linear stretch", "code": "def show(data, negate=False):\n    \"\"\"Show the stretched data.\n    \"\"\"\n    from PIL import Image as pil\n    data = np.array((data - data.min()) * 255.0 /\n                    (data.max() - data.min()), np.uint8)\n    if negate:\n        data = 255 - data\n    img = pil.fromarray(data)\n    img.show()", "code_tokens": "def show ( data , negate = False ) : from PIL import Image as pil data = np . array ( ( data - data . min ( ) ) * 255.0 / ( data . max ( ) - data . min ( ) ) , np . uint8 ) if negate : data = 255 - data img = pil . fromarray ( data ) img . show ( )", "docstring_tokens": "Show the stretched data .", "label": 1}, {"idx": "cosqa-train-6950", "doc": "get current position of iterator python", "code": "def index(self, elem):\n        \"\"\"Find the index of elem in the reversed iterator.\"\"\"\n        return _coconut.len(self._iter) - self._iter.index(elem) - 1", "code_tokens": "def index ( self , elem ) : return _coconut . len ( self . _iter ) - self . _iter . index ( elem ) - 1", "docstring_tokens": "Find the index of elem in the reversed iterator .", "label": 0}, {"idx": "cosqa-train-6951", "doc": "python image read get width height size", "code": "def get_image_dimension(self, url):\n        \"\"\"\n        Return a tuple that contains (width, height)\n        Pass in a url to an image and find out its size without loading the whole file\n        If the image wxh could not be found, the tuple will contain `None` values\n        \"\"\"\n        w_h = (None, None)\n        try:\n            if url.startswith('//'):\n                url = 'http:' + url\n            data = requests.get(url).content\n            im = Image.open(BytesIO(data))\n\n            w_h = im.size\n        except Exception:\n            logger.warning(\"Error getting image size {}\".format(url), exc_info=True)\n\n        return w_h", "code_tokens": "def get_image_dimension ( self , url ) : w_h = ( None , None ) try : if url . startswith ( '//' ) : url = 'http:' + url data = requests . get ( url ) . content im = Image . open ( BytesIO ( data ) ) w_h = im . size except Exception : logger . warning ( \"Error getting image size {}\" . format ( url ) , exc_info = True ) return w_h", "docstring_tokens": "Return a tuple that contains ( width height ) Pass in a url to an image and find out its size without loading the whole file If the image wxh could not be found the tuple will contain None values", "label": 0}, {"idx": "cosqa-train-6952", "doc": "get data from ajax request python", "code": "def get_active_ajax_datatable(self):\n        \"\"\" Returns a single datatable according to the hint GET variable from an AJAX request. \"\"\"\n        data = getattr(self.request, self.request.method)\n        datatables_dict = self.get_datatables(only=data['datatable'])\n        return list(datatables_dict.values())[0]", "code_tokens": "def get_active_ajax_datatable ( self ) : data = getattr ( self . request , self . request . method ) datatables_dict = self . get_datatables ( only = data [ 'datatable' ] ) return list ( datatables_dict . values ( ) ) [ 0 ]", "docstring_tokens": "Returns a single datatable according to the hint GET variable from an AJAX request .", "label": 0}, {"idx": "cosqa-train-6953", "doc": "python image simplify contour", "code": "def filter_contour(imageFile, opFile):\n    \"\"\" convert an image by applying a contour \"\"\"\n    im = Image.open(imageFile)\n    im1 = im.filter(ImageFilter.CONTOUR)\n    im1.save(opFile)", "code_tokens": "def filter_contour ( imageFile , opFile ) : im = Image . open ( imageFile ) im1 = im . filter ( ImageFilter . CONTOUR ) im1 . save ( opFile )", "docstring_tokens": "convert an image by applying a contour", "label": 1}, {"idx": "cosqa-train-6954", "doc": "get date modified from path python", "code": "def last_modified_time(path):\n    \"\"\"\n    Get the last modified time of path as a Timestamp.\n    \"\"\"\n    return pd.Timestamp(os.path.getmtime(path), unit='s', tz='UTC')", "code_tokens": "def last_modified_time ( path ) : return pd . Timestamp ( os . path . getmtime ( path ) , unit = 's' , tz = 'UTC' )", "docstring_tokens": "Get the last modified time of path as a Timestamp .", "label": 1}, {"idx": "cosqa-train-6955", "doc": "get file parent location python", "code": "def get_parent_folder_name(file_path):\n    \"\"\"Finds parent folder of file\n\n    :param file_path: path\n    :return: Name of folder container\n    \"\"\"\n    return os.path.split(os.path.split(os.path.abspath(file_path))[0])[-1]", "code_tokens": "def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]", "docstring_tokens": "Finds parent folder of file", "label": 0}, {"idx": "cosqa-train-6956", "doc": "python ind integer for normalized vector", "code": "def normalize_vector(v):\n    \"\"\"Take a vector and return the normalized vector\n    :param v: a vector v\n    :returns : normalized vector v\n    \"\"\"\n    norm = np.linalg.norm(v)\n    return v/norm if not norm == 0 else v", "code_tokens": "def normalize_vector ( v ) : norm = np . linalg . norm ( v ) return v / norm if not norm == 0 else v", "docstring_tokens": "Take a vector and return the normalized vector : param v : a vector v : returns : normalized vector v", "label": 0}, {"idx": "cosqa-train-6957", "doc": "get geolocation from iphone python", "code": "def get_geoip(ip):\n    \"\"\"Lookup country for IP address.\"\"\"\n    reader = geolite2.reader()\n    ip_data = reader.get(ip) or {}\n    return ip_data.get('country', {}).get('iso_code')", "code_tokens": "def get_geoip ( ip ) : reader = geolite2 . reader ( ) ip_data = reader . get ( ip ) or { } return ip_data . get ( 'country' , { } ) . get ( 'iso_code' )", "docstring_tokens": "Lookup country for IP address .", "label": 1}, {"idx": "cosqa-train-6958", "doc": "python index last number of values in array", "code": "def other_ind(self):\n        \"\"\"last row or column of square A\"\"\"\n        return np.full(self.n_min, self.size - 1, dtype=np.int)", "code_tokens": "def other_ind ( self ) : return np . full ( self . n_min , self . size - 1 , dtype = np . int )", "docstring_tokens": "last row or column of square A", "label": 1}, {"idx": "cosqa-train-6959", "doc": "get image shape python", "code": "def out_shape_from_array(arr):\n    \"\"\"Get the output shape from an array.\"\"\"\n    arr = np.asarray(arr)\n    if arr.ndim == 1:\n        return arr.shape\n    else:\n        return (arr.shape[1],)", "code_tokens": "def out_shape_from_array ( arr ) : arr = np . asarray ( arr ) if arr . ndim == 1 : return arr . shape else : return ( arr . shape [ 1 ] , )", "docstring_tokens": "Get the output shape from an array .", "label": 0}, {"idx": "cosqa-train-6960", "doc": "python index object remove", "code": "def remove_index(self):\n        \"\"\"Remove Elasticsearch index associated to the campaign\"\"\"\n        self.index_client.close(self.index_name)\n        self.index_client.delete(self.index_name)", "code_tokens": "def remove_index ( self ) : self . index_client . close ( self . index_name ) self . index_client . delete ( self . index_name )", "docstring_tokens": "Remove Elasticsearch index associated to the campaign", "label": 1}, {"idx": "cosqa-train-6961", "doc": "python index of match in list", "code": "def is_in(self, search_list, pair):\n        \"\"\"\n        If pair is in search_list, return the index. Otherwise return -1\n        \"\"\"\n        index = -1\n        for nr, i in enumerate(search_list):\n            if(np.all(i == pair)):\n                return nr\n        return index", "code_tokens": "def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index", "docstring_tokens": "If pair is in search_list return the index . Otherwise return - 1", "label": 0}, {"idx": "cosqa-train-6962", "doc": "get index of row with na value python", "code": "def find_start_point(self):\n        \"\"\"\n        Find the first location in our array that is not empty\n        \"\"\"\n        for i, row in enumerate(self.data):\n            for j, _ in enumerate(row):\n                if self.data[i, j] != 0:  # or not np.isfinite(self.data[i,j]):\n                    return i, j", "code_tokens": "def find_start_point ( self ) : for i , row in enumerate ( self . data ) : for j , _ in enumerate ( row ) : if self . data [ i , j ] != 0 : # or not np.isfinite(self.data[i,j]): return i , j", "docstring_tokens": "Find the first location in our array that is not empty", "label": 1}, {"idx": "cosqa-train-6963", "doc": "python inhibit new line at end of print", "code": "def end_block(self):\n        \"\"\"Ends an indentation block, leaving an empty line afterwards\"\"\"\n        self.current_indent -= 1\n\n        # If we did not add a new line automatically yet, now it's the time!\n        if not self.auto_added_line:\n            self.writeln()\n            self.auto_added_line = True", "code_tokens": "def end_block ( self ) : self . current_indent -= 1 # If we did not add a new line automatically yet, now it's the time! if not self . auto_added_line : self . writeln ( ) self . auto_added_line = True", "docstring_tokens": "Ends an indentation block leaving an empty line afterwards", "label": 1}, {"idx": "cosqa-train-6964", "doc": "get indices of matrix for a given value python", "code": "def get_inputs_from_cm(index, cm):\n    \"\"\"Return indices of inputs to the node with the given index.\"\"\"\n    return tuple(i for i in range(cm.shape[0]) if cm[i][index])", "code_tokens": "def get_inputs_from_cm ( index , cm ) : return tuple ( i for i in range ( cm . shape [ 0 ] ) if cm [ i ] [ index ] )", "docstring_tokens": "Return indices of inputs to the node with the given index .", "label": 0}, {"idx": "cosqa-train-6965", "doc": "python input text prompt default", "code": "def input(self, prompt, default=None, show_default=True):\n        \"\"\"Provide a command prompt.\"\"\"\n        return click.prompt(prompt, default=default, show_default=show_default)", "code_tokens": "def input ( self , prompt , default = None , show_default = True ) : return click . prompt ( prompt , default = default , show_default = show_default )", "docstring_tokens": "Provide a command prompt .", "label": 0}, {"idx": "cosqa-train-6966", "doc": "get last month python", "code": "def last_day(year=_year, month=_month):\n    \"\"\"\n    get the current month's last day\n    :param year:  default to current year\n    :param month:  default to current month\n    :return: month's last day\n    \"\"\"\n    last_day = calendar.monthrange(year, month)[1]\n    return datetime.date(year=year, month=month, day=last_day)", "code_tokens": "def last_day ( year = _year , month = _month ) : last_day = calendar . monthrange ( year , month ) [ 1 ] return datetime . date ( year = year , month = month , day = last_day )", "docstring_tokens": "get the current month s last day : param year : default to current year : param month : default to current month : return : month s last day", "label": 1}, {"idx": "cosqa-train-6967", "doc": "python int float comparison", "code": "def _check_for_int(x):\n    \"\"\"\n    This is a compatibility function that takes a C{float} and converts it to an\n    C{int} if the values are equal.\n    \"\"\"\n    try:\n        y = int(x)\n    except (OverflowError, ValueError):\n        pass\n    else:\n        # There is no way in AMF0 to distinguish between integers and floats\n        if x == x and y == x:\n            return y\n\n    return x", "code_tokens": "def _check_for_int ( x ) : try : y = int ( x ) except ( OverflowError , ValueError ) : pass else : # There is no way in AMF0 to distinguish between integers and floats if x == x and y == x : return y return x", "docstring_tokens": "This is a compatibility function that takes a C { float } and converts it to an C { int } if the values are equal .", "label": 1}, {"idx": "cosqa-train-6968", "doc": "get last number i array python", "code": "def other_ind(self):\n        \"\"\"last row or column of square A\"\"\"\n        return np.full(self.n_min, self.size - 1, dtype=np.int)", "code_tokens": "def other_ind ( self ) : return np . full ( self . n_min , self . size - 1 , dtype = np . int )", "docstring_tokens": "last row or column of square A", "label": 1}, {"idx": "cosqa-train-6969", "doc": "python interpolate now working", "code": "def lin_interp(x, rangeX, rangeY):\n    \"\"\"\n    Interpolate linearly variable x in rangeX onto rangeY.\n    \"\"\"\n    s = (x - rangeX[0]) / mag(rangeX[1] - rangeX[0])\n    y = rangeY[0] * (1 - s) + rangeY[1] * s\n    return y", "code_tokens": "def lin_interp ( x , rangeX , rangeY ) : s = ( x - rangeX [ 0 ] ) / mag ( rangeX [ 1 ] - rangeX [ 0 ] ) y = rangeY [ 0 ] * ( 1 - s ) + rangeY [ 1 ] * s return y", "docstring_tokens": "Interpolate linearly variable x in rangeX onto rangeY .", "label": 1}, {"idx": "cosqa-train-6970", "doc": "python invalidate all other connections to db mysql", "code": "def close( self ):\n        \"\"\"\n        Close the db and release memory\n        \"\"\"\n        if self.db is not None:\n            self.db.commit()\n            self.db.close()\n            self.db = None\n\n        return", "code_tokens": "def close ( self ) : if self . db is not None : self . db . commit ( ) self . db . close ( ) self . db = None return", "docstring_tokens": "Close the db and release memory", "label": 0}, {"idx": "cosqa-train-6971", "doc": "get last row python", "code": "def get_last(self, table=None):\n        \"\"\"Just the last entry.\"\"\"\n        if table is None: table = self.main_table\n        query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table\n        return self.own_cursor.execute(query).fetchone()", "code_tokens": "def get_last ( self , table = None ) : if table is None : table = self . main_table query = 'SELECT * FROM \"%s\" ORDER BY ROWID DESC LIMIT 1;' % table return self . own_cursor . execute ( query ) . fetchone ( )", "docstring_tokens": "Just the last entry .", "label": 0}, {"idx": "cosqa-train-6972", "doc": "python invert dictionary of lists", "code": "def invertDictMapping(d):\n    \"\"\" Invert mapping of dictionary (i.e. map values to list of keys) \"\"\"\n    inv_map = {}\n    for k, v in d.items():\n        inv_map[v] = inv_map.get(v, [])\n        inv_map[v].append(k)\n    return inv_map", "code_tokens": "def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map", "docstring_tokens": "Invert mapping of dictionary ( i . e . map values to list of keys )", "label": 1}, {"idx": "cosqa-train-6973", "doc": "get length of 'list' object in python", "code": "def __len__(self):\n        \"\"\"Return total data length of the list and its headers.\"\"\"\n        return self.chunk_length() + len(self.type) + len(self.header) + 4", "code_tokens": "def __len__ ( self ) : return self . chunk_length ( ) + len ( self . type ) + len ( self . header ) + 4", "docstring_tokens": "Return total data length of the list and its headers .", "label": 1}, {"idx": "cosqa-train-6974", "doc": "python io buffered reader", "code": "def get_iter_string_reader(stdin):\n    \"\"\" return an iterator that returns a chunk of a string every time it is\n    called.  notice that even though bufsize_type might be line buffered, we're\n    not doing any line buffering here.  that's because our StreamBufferer\n    handles all buffering.  we just need to return a reasonable-sized chunk. \"\"\"\n    bufsize = 1024\n    iter_str = (stdin[i:i + bufsize] for i in range(0, len(stdin), bufsize))\n    return get_iter_chunk_reader(iter_str)", "code_tokens": "def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )", "docstring_tokens": "return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk .", "label": 1}, {"idx": "cosqa-train-6975", "doc": "get number of different elements of two array python", "code": "def difference(ydata1, ydata2):\n    \"\"\"\n\n    Returns the number you should add to ydata1 to make it line up with ydata2\n\n    \"\"\"\n\n    y1 = _n.array(ydata1)\n    y2 = _n.array(ydata2)\n\n    return(sum(y2-y1)/len(ydata1))", "code_tokens": "def difference ( ydata1 , ydata2 ) : y1 = _n . array ( ydata1 ) y2 = _n . array ( ydata2 ) return ( sum ( y2 - y1 ) / len ( ydata1 ) )", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-6976", "doc": "python ioctl access linux", "code": "def _ioctl (self, func, args):\n        \"\"\"Call ioctl() with given parameters.\"\"\"\n        import fcntl\n        return fcntl.ioctl(self.sockfd.fileno(), func, args)", "code_tokens": "def _ioctl ( self , func , args ) : import fcntl return fcntl . ioctl ( self . sockfd . fileno ( ) , func , args )", "docstring_tokens": "Call ioctl () with given parameters .", "label": 0}, {"idx": "cosqa-train-6977", "doc": "get orders indexes in a list python", "code": "def _index_ordering(redshift_list):\n        \"\"\"\n\n        :param redshift_list: list of redshifts\n        :return: indexes in acending order to be evaluated (from z=0 to z=z_source)\n        \"\"\"\n        redshift_list = np.array(redshift_list)\n        sort_index = np.argsort(redshift_list)\n        return sort_index", "code_tokens": "def _index_ordering ( redshift_list ) : redshift_list = np . array ( redshift_list ) sort_index = np . argsort ( redshift_list ) return sort_index", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-6978", "doc": "python ip to integer converter", "code": "def _ipv4_text_to_int(self, ip_text):\n        \"\"\"convert ip v4 string to integer.\"\"\"\n        if ip_text is None:\n            return None\n        assert isinstance(ip_text, str)\n        return struct.unpack('!I', addrconv.ipv4.text_to_bin(ip_text))[0]", "code_tokens": "def _ipv4_text_to_int ( self , ip_text ) : if ip_text is None : return None assert isinstance ( ip_text , str ) return struct . unpack ( '!I' , addrconv . ipv4 . text_to_bin ( ip_text ) ) [ 0 ]", "docstring_tokens": "convert ip v4 string to integer .", "label": 1}, {"idx": "cosqa-train-6979", "doc": "get parent object python", "code": "def _lookup_parent(self, cls):\n        \"\"\"Lookup a transitive parent object that is an instance\n            of a given class.\"\"\"\n        codeobj = self.parent\n        while codeobj is not None and not isinstance(codeobj, cls):\n            codeobj = codeobj.parent\n        return codeobj", "code_tokens": "def _lookup_parent ( self , cls ) : codeobj = self . parent while codeobj is not None and not isinstance ( codeobj , cls ) : codeobj = codeobj . parent return codeobj", "docstring_tokens": "Lookup a transitive parent object that is an instance of a given class .", "label": 1}, {"idx": "cosqa-train-6980", "doc": "python iterable to array", "code": "def A(*a):\n    \"\"\"convert iterable object into numpy array\"\"\"\n    return np.array(a[0]) if len(a)==1 else [np.array(o) for o in a]", "code_tokens": "def A ( * a ) : return np . array ( a [ 0 ] ) if len ( a ) == 1 else [ np . array ( o ) for o in a ]", "docstring_tokens": "convert iterable object into numpy array", "label": 0}, {"idx": "cosqa-train-6981", "doc": "get previous week end and month end python", "code": "def get_week_start_end_day():\n    \"\"\"\n    Get the week start date and end date\n    \"\"\"\n    t = date.today()\n    wd = t.weekday()\n    return (t - timedelta(wd), t + timedelta(6 - wd))", "code_tokens": "def get_week_start_end_day ( ) : t = date . today ( ) wd = t . weekday ( ) return ( t - timedelta ( wd ) , t + timedelta ( 6 - wd ) )", "docstring_tokens": "Get the week start date and end date", "label": 1}, {"idx": "cosqa-train-6982", "doc": "python iterate directory for filenames with filter", "code": "def match_files(files, pattern: Pattern):\n    \"\"\"Yields file name if matches a regular expression pattern.\"\"\"\n\n    for name in files:\n        if re.match(pattern, name):\n            yield name", "code_tokens": "def match_files ( files , pattern : Pattern ) : for name in files : if re . match ( pattern , name ) : yield name", "docstring_tokens": "Yields file name if matches a regular expression pattern .", "label": 1}, {"idx": "cosqa-train-6983", "doc": "get process memory usage in python", "code": "def get_memory_usage():\n    \"\"\"Gets RAM memory usage\n\n    :return: MB of memory used by this process\n    \"\"\"\n    process = psutil.Process(os.getpid())\n    mem = process.memory_info().rss\n    return mem / (1024 * 1024)", "code_tokens": "def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )", "docstring_tokens": "Gets RAM memory usage", "label": 1}, {"idx": "cosqa-train-6984", "doc": "python iterate through words in line of text file", "code": "def extract_words(lines):\n    \"\"\"\n    Extract from the given iterable of lines the list of words.\n\n    :param lines: an iterable of lines;\n    :return: a generator of words of lines.\n    \"\"\"\n    for line in lines:\n        for word in re.findall(r\"\\w+\", line):\n            yield word", "code_tokens": "def extract_words ( lines ) : for line in lines : for word in re . findall ( r\"\\w+\" , line ) : yield word", "docstring_tokens": "Extract from the given iterable of lines the list of words .", "label": 1}, {"idx": "cosqa-train-6985", "doc": "get size of image at url python", "code": "def get_image_dimension(self, url):\n        \"\"\"\n        Return a tuple that contains (width, height)\n        Pass in a url to an image and find out its size without loading the whole file\n        If the image wxh could not be found, the tuple will contain `None` values\n        \"\"\"\n        w_h = (None, None)\n        try:\n            if url.startswith('//'):\n                url = 'http:' + url\n            data = requests.get(url).content\n            im = Image.open(BytesIO(data))\n\n            w_h = im.size\n        except Exception:\n            logger.warning(\"Error getting image size {}\".format(url), exc_info=True)\n\n        return w_h", "code_tokens": "def get_image_dimension ( self , url ) : w_h = ( None , None ) try : if url . startswith ( '//' ) : url = 'http:' + url data = requests . get ( url ) . content im = Image . open ( BytesIO ( data ) ) w_h = im . size except Exception : logger . warning ( \"Error getting image size {}\" . format ( url ) , exc_info = True ) return w_h", "docstring_tokens": "Return a tuple that contains ( width height ) Pass in a url to an image and find out its size without loading the whole file If the image wxh could not be found the tuple will contain None values", "label": 1}, {"idx": "cosqa-train-6986", "doc": "python iterator with delete", "code": "def reset(self):\n\t\t\"\"\"\n\t\tResets the iterator to the start.\n\n\t\tAny remaining values in the current iteration are discarded.\n\t\t\"\"\"\n\t\tself.__iterator, self.__saved = itertools.tee(self.__saved)", "code_tokens": "def reset ( self ) : self . __iterator , self . __saved = itertools . tee ( self . __saved )", "docstring_tokens": "Resets the iterator to the start .", "label": 1}, {"idx": "cosqa-train-6987", "doc": "get start date and end date of week python", "code": "def get_week_start_end_day():\n    \"\"\"\n    Get the week start date and end date\n    \"\"\"\n    t = date.today()\n    wd = t.weekday()\n    return (t - timedelta(wd), t + timedelta(6 - wd))", "code_tokens": "def get_week_start_end_day ( ) : t = date . today ( ) wd = t . weekday ( ) return ( t - timedelta ( wd ) , t + timedelta ( 6 - wd ) )", "docstring_tokens": "Get the week start date and end date", "label": 1}, {"idx": "cosqa-train-6988", "doc": "python jinja2 super not work", "code": "def rstjinja(app, docname, source):\n    \"\"\"\n    Render our pages as a jinja template for fancy templating goodness.\n    \"\"\"\n    # Make sure we're outputting HTML\n    if app.builder.format != 'html':\n        return\n    src = source[0]\n    rendered = app.builder.templates.render_string(\n        src, app.config.html_context\n    )\n    source[0] = rendered", "code_tokens": "def rstjinja ( app , docname , source ) : # Make sure we're outputting HTML if app . builder . format != 'html' : return src = source [ 0 ] rendered = app . builder . templates . render_string ( src , app . config . html_context ) source [ 0 ] = rendered", "docstring_tokens": "Render our pages as a jinja template for fancy templating goodness .", "label": 1}, {"idx": "cosqa-train-6989", "doc": "get the first and only row, usingfindchild('tr') python", "code": "def pop_row(self, idr=None, tags=False):\n        \"\"\"Pops a row, default the last\"\"\"\n        idr = idr if idr is not None else len(self.body) - 1\n        row = self.body.pop(idr)\n        return row if tags else [cell.childs[0] for cell in row]", "code_tokens": "def pop_row ( self , idr = None , tags = False ) : idr = idr if idr is not None else len ( self . body ) - 1 row = self . body . pop ( idr ) return row if tags else [ cell . childs [ 0 ] for cell in row ]", "docstring_tokens": "Pops a row default the last", "label": 0}, {"idx": "cosqa-train-6990", "doc": "python join a date and a time to a datetime", "code": "def convert_time_string(date_str):\n    \"\"\" Change a date string from the format 2018-08-15T23:55:17 into a datetime object \"\"\"\n    dt, _, _ = date_str.partition(\".\")\n    dt = datetime.strptime(dt, \"%Y-%m-%dT%H:%M:%S\")\n    return dt", "code_tokens": "def convert_time_string ( date_str ) : dt , _ , _ = date_str . partition ( \".\" ) dt = datetime . strptime ( dt , \"%Y-%m-%dT%H:%M:%S\" ) return dt", "docstring_tokens": "Change a date string from the format 2018 - 08 - 15T23 : 55 : 17 into a datetime object", "label": 0}, {"idx": "cosqa-train-6991", "doc": "get the index of a null value in series in python", "code": "def find_start_point(self):\n        \"\"\"\n        Find the first location in our array that is not empty\n        \"\"\"\n        for i, row in enumerate(self.data):\n            for j, _ in enumerate(row):\n                if self.data[i, j] != 0:  # or not np.isfinite(self.data[i,j]):\n                    return i, j", "code_tokens": "def find_start_point ( self ) : for i , row in enumerate ( self . data ) : for j , _ in enumerate ( row ) : if self . data [ i , j ] != 0 : # or not np.isfinite(self.data[i,j]): return i , j", "docstring_tokens": "Find the first location in our array that is not empty", "label": 1}, {"idx": "cosqa-train-6992", "doc": "python josn dump to file", "code": "def save_notebook(work_notebook, write_file):\n    \"\"\"Saves the Jupyter work_notebook to write_file\"\"\"\n    with open(write_file, 'w') as out_nb:\n        json.dump(work_notebook, out_nb, indent=2)", "code_tokens": "def save_notebook ( work_notebook , write_file ) : with open ( write_file , 'w' ) as out_nb : json . dump ( work_notebook , out_nb , indent = 2 )", "docstring_tokens": "Saves the Jupyter work_notebook to write_file", "label": 1}, {"idx": "cosqa-train-6993", "doc": "get the nth element from array python", "code": "def _nth(arr, n):\n    \"\"\"\n    Return the nth value of array\n\n    If it is missing return NaN\n    \"\"\"\n    try:\n        return arr.iloc[n]\n    except (KeyError, IndexError):\n        return np.nan", "code_tokens": "def _nth ( arr , n ) : try : return arr . iloc [ n ] except ( KeyError , IndexError ) : return np . nan", "docstring_tokens": "Return the nth value of array", "label": 0}, {"idx": "cosqa-train-6994", "doc": "python json apply diff", "code": "def record_diff(old, new):\n    \"\"\"Return a JSON-compatible structure capable turn the `new` record back\n    into the `old` record. The parameters must be structures compatible with\n    json.dumps *or* strings compatible with json.loads. Note that by design,\n    `old == record_patch(new, record_diff(old, new))`\"\"\"\n    old, new = _norm_json_params(old, new)\n    return json_delta.diff(new, old, verbose=False)", "code_tokens": "def record_diff ( old , new ) : old , new = _norm_json_params ( old , new ) return json_delta . diff ( new , old , verbose = False )", "docstring_tokens": "Return a JSON - compatible structure capable turn the new record back into the old record . The parameters must be structures compatible with json . dumps * or * strings compatible with json . loads . Note that by design old == record_patch ( new record_diff ( old new ))", "label": 0}, {"idx": "cosqa-train-6995", "doc": "get the tenth percentile of a list python", "code": "def percentile(values, k):\n    \"\"\"Find the percentile of a list of values.\n\n    :param list values: The list of values to find the percentile of\n    :param int k: The percentile to find\n    :rtype: float or int\n\n    \"\"\"\n    if not values:\n        return None\n    values.sort()\n    index = (len(values) * (float(k) / 100)) - 1\n    return values[int(math.ceil(index))]", "code_tokens": "def percentile ( values , k ) : if not values : return None values . sort ( ) index = ( len ( values ) * ( float ( k ) / 100 ) ) - 1 return values [ int ( math . ceil ( index ) ) ]", "docstring_tokens": "Find the percentile of a list of values .", "label": 1}, {"idx": "cosqa-train-6996", "doc": "python json deserialize to object", "code": "def from_json(cls, json_str):\n        \"\"\"Deserialize the object from a JSON string.\"\"\"\n        d = json.loads(json_str)\n        return cls.from_dict(d)", "code_tokens": "def from_json ( cls , json_str ) : d = json . loads ( json_str ) return cls . from_dict ( d )", "docstring_tokens": "Deserialize the object from a JSON string .", "label": 1}, {"idx": "cosqa-train-6997", "doc": "get variance of vector python", "code": "def explained_variance(returns, values):\n    \"\"\" Calculate how much variance in returns do the values explain \"\"\"\n    exp_var = 1 - torch.var(returns - values) / torch.var(returns)\n    return exp_var.item()", "code_tokens": "def explained_variance ( returns , values ) : exp_var = 1 - torch . var ( returns - values ) / torch . var ( returns ) return exp_var . item ( )", "docstring_tokens": "Calculate how much variance in returns do the values explain", "label": 1}, {"idx": "cosqa-train-6998", "doc": "python json dumps return type", "code": "def dump_json(obj):\n    \"\"\"Dump Python object as JSON string.\"\"\"\n    return simplejson.dumps(obj, ignore_nan=True, default=json_util.default)", "code_tokens": "def dump_json ( obj ) : return simplejson . dumps ( obj , ignore_nan = True , default = json_util . default )", "docstring_tokens": "Dump Python object as JSON string .", "label": 1}, {"idx": "cosqa-train-6999", "doc": "get windows and ram in python", "code": "def get_free_memory_win():\n    \"\"\"Return current free memory on the machine for windows.\n\n    Warning : this script is really not robust\n    Return in MB unit\n    \"\"\"\n    stat = MEMORYSTATUSEX()\n    ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(stat))\n    return int(stat.ullAvailPhys / 1024 / 1024)", "code_tokens": "def get_free_memory_win ( ) : stat = MEMORYSTATUSEX ( ) ctypes . windll . kernel32 . GlobalMemoryStatusEx ( ctypes . byref ( stat ) ) return int ( stat . ullAvailPhys / 1024 / 1024 )", "docstring_tokens": "Return current free memory on the machine for windows .", "label": 0}, {"idx": "cosqa-train-7000", "doc": "python json load u", "code": "def read_json(location):\n    \"\"\"Open and load JSON from file.\n\n    location (Path): Path to JSON file.\n    RETURNS (dict): Loaded JSON content.\n    \"\"\"\n    location = ensure_path(location)\n    with location.open('r', encoding='utf8') as f:\n        return ujson.load(f)", "code_tokens": "def read_json ( location ) : location = ensure_path ( location ) with location . open ( 'r' , encoding = 'utf8' ) as f : return ujson . load ( f )", "docstring_tokens": "Open and load JSON from file .", "label": 0}, {"idx": "cosqa-train-7001", "doc": "get word frequency from file python", "code": "def wordfreq(text, is_filename=False):\n    \"\"\"Return a dictionary of words and word counts in a string.\"\"\"\n    if is_filename:\n        with open(text) as f:\n            text = f.read()\n    freqs = {}\n    for word in text.split():\n        lword = word.lower()\n        freqs[lword] = freqs.get(lword, 0) + 1\n    return freqs", "code_tokens": "def wordfreq ( text , is_filename = False ) : if is_filename : with open ( text ) as f : text = f . read ( ) freqs = { } for word in text . split ( ) : lword = word . lower ( ) freqs [ lword ] = freqs . get ( lword , 0 ) + 1 return freqs", "docstring_tokens": "Return a dictionary of words and word counts in a string .", "label": 0}, {"idx": "cosqa-train-7002", "doc": "python json load unorde", "code": "def read_json(location):\n    \"\"\"Open and load JSON from file.\n\n    location (Path): Path to JSON file.\n    RETURNS (dict): Loaded JSON content.\n    \"\"\"\n    location = ensure_path(location)\n    with location.open('r', encoding='utf8') as f:\n        return ujson.load(f)", "code_tokens": "def read_json ( location ) : location = ensure_path ( location ) with location . open ( 'r' , encoding = 'utf8' ) as f : return ujson . load ( f )", "docstring_tokens": "Open and load JSON from file .", "label": 1}, {"idx": "cosqa-train-7003", "doc": "git rid of box around legend python", "code": "def mpl_outside_legend(ax, **kwargs):\n    \"\"\" Places a legend box outside a matplotlib Axes instance. \"\"\"\n    box = ax.get_position()\n    ax.set_position([box.x0, box.y0, box.width * 0.75, box.height])\n    # Put a legend to the right of the current axis\n    ax.legend(loc='upper left', bbox_to_anchor=(1, 1), **kwargs)", "code_tokens": "def mpl_outside_legend ( ax , * * kwargs ) : box = ax . get_position ( ) ax . set_position ( [ box . x0 , box . y0 , box . width * 0.75 , box . height ] ) # Put a legend to the right of the current axis ax . legend ( loc = 'upper left' , bbox_to_anchor = ( 1 , 1 ) , * * kwargs )", "docstring_tokens": "Places a legend box outside a matplotlib Axes instance .", "label": 1}, {"idx": "cosqa-train-7004", "doc": "giving widget the focus in python", "code": "def focusInEvent(self, event):\n        \"\"\"Reimplement Qt method to send focus change notification\"\"\"\n        self.focus_changed.emit()\n        return super(ControlWidget, self).focusInEvent(event)", "code_tokens": "def focusInEvent ( self , event ) : self . focus_changed . emit ( ) return super ( ControlWidget , self ) . focusInEvent ( event )", "docstring_tokens": "Reimplement Qt method to send focus change notification", "label": 1}, {"idx": "cosqa-train-7005", "doc": "python json loads try", "code": "def json(body, charset='utf-8', **kwargs):\n    \"\"\"Takes JSON formatted data, converting it into native Python objects\"\"\"\n    return json_converter.loads(text(body, charset=charset))", "code_tokens": "def json ( body , charset = 'utf-8' , * * kwargs ) : return json_converter . loads ( text ( body , charset = charset ) )", "docstring_tokens": "Takes JSON formatted data converting it into native Python objects", "label": 1}, {"idx": "cosqa-train-7006", "doc": "global fitting exponential python", "code": "def exp_fit_fun(x, a, tau, c):\n    \"\"\"Function used to fit the exponential decay.\"\"\"\n    # pylint: disable=invalid-name\n    return a * np.exp(-x / tau) + c", "code_tokens": "def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "docstring_tokens": "Function used to fit the exponential decay .", "label": 0}, {"idx": "cosqa-train-7007", "doc": "python json null instead of none", "code": "def get_prep_value(self, value):\n        \"\"\"Convert JSON object to a string\"\"\"\n        if self.null and value is None:\n            return None\n        return json.dumps(value, **self.dump_kwargs)", "code_tokens": "def get_prep_value ( self , value ) : if self . null and value is None : return None return json . dumps ( value , * * self . dump_kwargs )", "docstring_tokens": "Convert JSON object to a string", "label": 0}, {"idx": "cosqa-train-7008", "doc": "global font type python", "code": "def setLib(self, lib):\n        \"\"\" Copy the lib items into our font. \"\"\"\n        for name, item in lib.items():\n            self.font.lib[name] = item", "code_tokens": "def setLib ( self , lib ) : for name , item in lib . items ( ) : self . font . lib [ name ] = item", "docstring_tokens": "Copy the lib items into our font .", "label": 1}, {"idx": "cosqa-train-7009", "doc": "python json parse to attributes", "code": "def _unjsonify(x, isattributes=False):\n    \"\"\"Convert JSON string to an ordered defaultdict.\"\"\"\n    if isattributes:\n        obj = json.loads(x)\n        return dict_class(obj)\n    return json.loads(x)", "code_tokens": "def _unjsonify ( x , isattributes = False ) : if isattributes : obj = json . loads ( x ) return dict_class ( obj ) return json . loads ( x )", "docstring_tokens": "Convert JSON string to an ordered defaultdict .", "label": 1}, {"idx": "cosqa-train-7010", "doc": "go back to parent directory in python", "code": "def go_to_parent_directory(self):\n        \"\"\"Go to parent directory\"\"\"\n        self.chdir(osp.abspath(osp.join(getcwd_or_home(), os.pardir)))", "code_tokens": "def go_to_parent_directory ( self ) : self . chdir ( osp . abspath ( osp . join ( getcwd_or_home ( ) , os . pardir ) ) )", "docstring_tokens": "Go to parent directory", "label": 1}, {"idx": "cosqa-train-7011", "doc": "python judge if is numeric", "code": "def is_numeric(value):\n        \"\"\"Test if a value is numeric.\n        \"\"\"\n        return type(value) in [\n            int,\n            float,\n            \n            np.int8,\n            np.int16,\n            np.int32,\n            np.int64,\n\n            np.float16,\n            np.float32,\n            np.float64,\n            np.float128\n        ]", "code_tokens": "def is_numeric ( value ) : return type ( value ) in [ int , float , np . int8 , np . int16 , np . int32 , np . int64 , np . float16 , np . float32 , np . float64 , np . float128 ]", "docstring_tokens": "Test if a value is numeric .", "label": 0}, {"idx": "cosqa-train-7012", "doc": "good naming convention for functions in python", "code": "def export(defn):\n    \"\"\"Decorator to explicitly mark functions that are exposed in a lib.\"\"\"\n    globals()[defn.__name__] = defn\n    __all__.append(defn.__name__)\n    return defn", "code_tokens": "def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "docstring_tokens": "Decorator to explicitly mark functions that are exposed in a lib .", "label": 0}, {"idx": "cosqa-train-7013", "doc": "python judge matrix is identity matrix", "code": "def is_identity():\n        \"\"\"Check to see if this matrix is an identity matrix.\"\"\"\n        for index, row in enumerate(self.dta):\n            if row[index] == 1:\n                for num, element in enumerate(row):\n                    if num != index:\n                        if element != 0:\n                            return False\n            else:\n                return False\n\n        return True", "code_tokens": "def is_identity ( ) : for index , row in enumerate ( self . dta ) : if row [ index ] == 1 : for num , element in enumerate ( row ) : if num != index : if element != 0 : return False else : return False return True", "docstring_tokens": "Check to see if this matrix is an identity matrix .", "label": 0}, {"idx": "cosqa-train-7014", "doc": "grabbing certain box pixels in array python", "code": "def bounding_box(img):\n    r\"\"\"\n    Return the bounding box incorporating all non-zero values in the image.\n    \n    Parameters\n    ----------\n    img : array_like\n        An array containing non-zero objects.\n        \n    Returns\n    -------\n    bbox : a list of slicer objects defining the bounding box\n    \"\"\"\n    locations = numpy.argwhere(img)\n    mins = locations.min(0)\n    maxs = locations.max(0) + 1\n    return [slice(x, y) for x, y in zip(mins, maxs)]", "code_tokens": "def bounding_box ( img ) : locations = numpy . argwhere ( img ) mins = locations . min ( 0 ) maxs = locations . max ( 0 ) + 1 return [ slice ( x , y ) for x , y in zip ( mins , maxs ) ]", "docstring_tokens": "r Return the bounding box incorporating all non - zero values in the image . Parameters ---------- img : array_like An array containing non - zero objects . Returns ------- bbox : a list of slicer objects defining the bounding box", "label": 1}, {"idx": "cosqa-train-7015", "doc": "python judge whether a file is used", "code": "def do_files_exist(filenames):\n  \"\"\"Whether any of the filenames exist.\"\"\"\n  preexisting = [tf.io.gfile.exists(f) for f in filenames]\n  return any(preexisting)", "code_tokens": "def do_files_exist ( filenames ) : preexisting = [ tf . io . gfile . exists ( f ) for f in filenames ] return any ( preexisting )", "docstring_tokens": "Whether any of the filenames exist .", "label": 1}, {"idx": "cosqa-train-7016", "doc": "graph with adjacency matrix and python", "code": "def adjacency(tree):\n    \"\"\"\n    Construct the adjacency matrix of the tree\n    :param tree:\n    :return:\n    \"\"\"\n    dd = ids(tree)\n    N = len(dd)\n    A = np.zeros((N, N))\n\n    def _adj(node):\n        if np.isscalar(node):\n            return\n        elif isinstance(node, tuple) and len(node) == 2:\n            A[dd[node], dd[node[0]]] = 1\n            A[dd[node[0]], dd[node]] = 1\n            _adj(node[0])\n\n            A[dd[node], dd[node[1]]] = 1\n            A[dd[node[1]], dd[node]] = 1\n            _adj(node[1])\n\n    _adj(tree)\n    return A", "code_tokens": "def adjacency ( tree ) : dd = ids ( tree ) N = len ( dd ) A = np . zeros ( ( N , N ) ) def _adj ( node ) : if np . isscalar ( node ) : return elif isinstance ( node , tuple ) and len ( node ) == 2 : A [ dd [ node ] , dd [ node [ 0 ] ] ] = 1 A [ dd [ node [ 0 ] ] , dd [ node ] ] = 1 _adj ( node [ 0 ] ) A [ dd [ node ] , dd [ node [ 1 ] ] ] = 1 A [ dd [ node [ 1 ] ] , dd [ node ] ] = 1 _adj ( node [ 1 ] ) _adj ( tree ) return A", "docstring_tokens": "Construct the adjacency matrix of the tree : param tree : : return :", "label": 1}, {"idx": "cosqa-train-7017", "doc": "python kill signal without break", "code": "def signal_handler(signal_name, frame):\n    \"\"\"Quit signal handler.\"\"\"\n    sys.stdout.flush()\n    print(\"\\nSIGINT in frame signal received. Quitting...\")\n    sys.stdout.flush()\n    sys.exit(0)", "code_tokens": "def signal_handler ( signal_name , frame ) : sys . stdout . flush ( ) print ( \"\\nSIGINT in frame signal received. Quitting...\" ) sys . stdout . flush ( ) sys . exit ( 0 )", "docstring_tokens": "Quit signal handler .", "label": 1}, {"idx": "cosqa-train-7018", "doc": "greatest common divisor of three numbers python", "code": "def _gcd_array(X):\n    \"\"\"\n    Return the largest real value h such that all elements in x are integer\n    multiples of h.\n    \"\"\"\n    greatest_common_divisor = 0.0\n    for x in X:\n        greatest_common_divisor = _gcd(greatest_common_divisor, x)\n\n    return greatest_common_divisor", "code_tokens": "def _gcd_array ( X ) : greatest_common_divisor = 0.0 for x in X : greatest_common_divisor = _gcd ( greatest_common_divisor , x ) return greatest_common_divisor", "docstring_tokens": "Return the largest real value h such that all elements in x are integer multiples of h .", "label": 1}, {"idx": "cosqa-train-7019", "doc": "python kivy change background color", "code": "def _set_widget_background_color(widget, color):\n        \"\"\"\n        Changes the base color of a widget (background).\n        :param widget: widget to modify\n        :param color: the color to apply\n        \"\"\"\n        pal = widget.palette()\n        pal.setColor(pal.Base, color)\n        widget.setPalette(pal)", "code_tokens": "def _set_widget_background_color ( widget , color ) : pal = widget . palette ( ) pal . setColor ( pal . Base , color ) widget . setPalette ( pal )", "docstring_tokens": "Changes the base color of a widget ( background ) . : param widget : widget to modify : param color : the color to apply", "label": 1}, {"idx": "cosqa-train-7020", "doc": "hash of a dictionary python", "code": "def dict_hash(dct):\n    \"\"\"Return a hash of the contents of a dictionary\"\"\"\n    dct_s = json.dumps(dct, sort_keys=True)\n\n    try:\n        m = md5(dct_s)\n    except TypeError:\n        m = md5(dct_s.encode())\n\n    return m.hexdigest()", "code_tokens": "def dict_hash ( dct ) : dct_s = json . dumps ( dct , sort_keys = True ) try : m = md5 ( dct_s ) except TypeError : m = md5 ( dct_s . encode ( ) ) return m . hexdigest ( )", "docstring_tokens": "Return a hash of the contents of a dictionary", "label": 1}, {"idx": "cosqa-train-7021", "doc": "python labelencoder with onehotencoder", "code": "def one_hot_encoding(input_tensor, num_labels):\n    \"\"\" One-hot encode labels from input \"\"\"\n    xview = input_tensor.view(-1, 1).to(torch.long)\n\n    onehot = torch.zeros(xview.size(0), num_labels, device=input_tensor.device, dtype=torch.float)\n    onehot.scatter_(1, xview, 1)\n    return onehot.view(list(input_tensor.shape) + [-1])", "code_tokens": "def one_hot_encoding ( input_tensor , num_labels ) : xview = input_tensor . view ( - 1 , 1 ) . to ( torch . long ) onehot = torch . zeros ( xview . size ( 0 ) , num_labels , device = input_tensor . device , dtype = torch . float ) onehot . scatter_ ( 1 , xview , 1 ) return onehot . view ( list ( input_tensor . shape ) + [ - 1 ] )", "docstring_tokens": "One - hot encode labels from input", "label": 0}, {"idx": "cosqa-train-7022", "doc": "hash out multiple lines python", "code": "def _add_hash(source):\n    \"\"\"Add a leading hash '#' at the beginning of every line in the source.\"\"\"\n    source = '\\n'.join('# ' + line.rstrip()\n                       for line in source.splitlines())\n    return source", "code_tokens": "def _add_hash ( source ) : source = '\\n' . join ( '# ' + line . rstrip ( ) for line in source . splitlines ( ) ) return source", "docstring_tokens": "Add a leading hash # at the beginning of every line in the source .", "label": 0}, {"idx": "cosqa-train-7023", "doc": "python lambda function with 3 params", "code": "def make_lambda(call):\n    \"\"\"Wrap an AST Call node to lambda expression node.\n    call: ast.Call node\n    \"\"\"\n    empty_args = ast.arguments(args=[], vararg=None, kwarg=None, defaults=[])\n    return ast.Lambda(args=empty_args, body=call)", "code_tokens": "def make_lambda ( call ) : empty_args = ast . arguments ( args = [ ] , vararg = None , kwarg = None , defaults = [ ] ) return ast . Lambda ( args = empty_args , body = call )", "docstring_tokens": "Wrap an AST Call node to lambda expression node . call : ast . Call node", "label": 1}, {"idx": "cosqa-train-7024", "doc": "have a datetime field, get the first day of the month in python", "code": "def monthly(date=datetime.date.today()):\n    \"\"\"\n    Take a date object and return the first day of the month.\n    \"\"\"\n    return datetime.date(date.year, date.month, 1)", "code_tokens": "def monthly ( date = datetime . date . today ( ) ) : return datetime . date ( date . year , date . month , 1 )", "docstring_tokens": "Take a date object and return the first day of the month .", "label": 1}, {"idx": "cosqa-train-7025", "doc": "python ldap compare two objects", "code": "def compare(self, dn, attr, value):\n        \"\"\"\n        Compare the ``attr`` of the entry ``dn`` with given ``value``.\n\n        This is a convenience wrapper for the ldap library's ``compare``\n        function that returns a boolean value instead of 1 or 0.\n        \"\"\"\n        return self.connection.compare_s(dn, attr, value) == 1", "code_tokens": "def compare ( self , dn , attr , value ) : return self . connection . compare_s ( dn , attr , value ) == 1", "docstring_tokens": "Compare the attr of the entry dn with given value .", "label": 0}, {"idx": "cosqa-train-7026", "doc": "have not empty check python", "code": "def _one_exists(input_files):\n    \"\"\"\n    at least one file must exist for multiqc to run properly\n    \"\"\"\n    for f in input_files:\n        if os.path.exists(f):\n            return True\n    return False", "code_tokens": "def _one_exists ( input_files ) : for f in input_files : if os . path . exists ( f ) : return True return False", "docstring_tokens": "at least one file must exist for multiqc to run properly", "label": 0}, {"idx": "cosqa-train-7027", "doc": "python leading zero series", "code": "def prox_zero(X, step):\n    \"\"\"Proximal operator to project onto zero\n    \"\"\"\n    return np.zeros(X.shape, dtype=X.dtype)", "code_tokens": "def prox_zero ( X , step ) : return np . zeros ( X . shape , dtype = X . dtype )", "docstring_tokens": "Proximal operator to project onto zero", "label": 1}, {"idx": "cosqa-train-7028", "doc": "heap max value python", "code": "def heappop_max(heap):\n    \"\"\"Maxheap version of a heappop.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup_max(heap, 0)\n        return returnitem\n    return lastelt", "code_tokens": "def heappop_max ( heap ) : lastelt = heap . pop ( ) # raises appropriate IndexError if heap is empty if heap : returnitem = heap [ 0 ] heap [ 0 ] = lastelt _siftup_max ( heap , 0 ) return returnitem return lastelt", "docstring_tokens": "Maxheap version of a heappop .", "label": 0}, {"idx": "cosqa-train-7029", "doc": "python leapyear return number of days for given month/year", "code": "def days_in_month(year, month):\n    \"\"\"\n    returns number of days for the given year and month\n\n    :param int year: calendar year\n    :param int month: calendar month\n    :return int:\n    \"\"\"\n\n    eom = _days_per_month[month - 1]\n    if is_leap_year(year) and month == 2:\n        eom += 1\n\n    return eom", "code_tokens": "def days_in_month ( year , month ) : eom = _days_per_month [ month - 1 ] if is_leap_year ( year ) and month == 2 : eom += 1 return eom", "docstring_tokens": "returns number of days for the given year and month", "label": 0}, {"idx": "cosqa-train-7030", "doc": "python left to right or right to left evaluation", "code": "def on_binop(self, node):    # ('left', 'op', 'right')\n        \"\"\"Binary operator.\"\"\"\n        return op2func(node.op)(self.run(node.left),\n                                self.run(node.right))", "code_tokens": "def on_binop ( self , node ) : # ('left', 'op', 'right') return op2func ( node . op ) ( self . run ( node . left ) , self . run ( node . right ) )", "docstring_tokens": "Binary operator .", "label": 1}, {"idx": "cosqa-train-7031", "doc": "hide a window in wx python", "code": "def disable_wx(self):\n        \"\"\"Disable event loop integration with wxPython.\n\n        This merely sets PyOS_InputHook to NULL.\n        \"\"\"\n        if self._apps.has_key(GUI_WX):\n            self._apps[GUI_WX]._in_event_loop = False\n        self.clear_inputhook()", "code_tokens": "def disable_wx ( self ) : if self . _apps . has_key ( GUI_WX ) : self . _apps [ GUI_WX ] . _in_event_loop = False self . clear_inputhook ( )", "docstring_tokens": "Disable event loop integration with wxPython .", "label": 0}, {"idx": "cosqa-train-7032", "doc": "python length of each item in data frame column", "code": "def _shape(self, df):\n        \"\"\"\n        Calculate table chape considering index levels.\n        \"\"\"\n\n        row, col = df.shape\n        return row + df.columns.nlevels, col + df.index.nlevels", "code_tokens": "def _shape ( self , df ) : row , col = df . shape return row + df . columns . nlevels , col + df . index . nlevels", "docstring_tokens": "Calculate table chape considering index levels .", "label": 1}, {"idx": "cosqa-train-7033", "doc": "hierarchical print children python", "code": "def print_item_with_children(ac, classes, level):\n    \"\"\" Print the given item and all children items \"\"\"\n    print_row(ac.id, ac.name, f\"{ac.allocation:,.2f}\", level)\n    print_children_recursively(classes, ac, level + 1)", "code_tokens": "def print_item_with_children ( ac , classes , level ) : print_row ( ac . id , ac . name , f\"{ac.allocation:,.2f}\" , level ) print_children_recursively ( classes , ac , level + 1 )", "docstring_tokens": "Print the given item and all children items", "label": 0}, {"idx": "cosqa-train-7034", "doc": "how can i automatically create a string of a particular length python", "code": "def random_str(size=10):\n    \"\"\"\n    create random string of selected size\n\n    :param size: int, length of the string\n    :return: the string\n    \"\"\"\n    return ''.join(random.choice(string.ascii_lowercase) for _ in range(size))", "code_tokens": "def random_str ( size = 10 ) : return '' . join ( random . choice ( string . ascii_lowercase ) for _ in range ( size ) )", "docstring_tokens": "create random string of selected size", "label": 1}, {"idx": "cosqa-train-7035", "doc": "python limiting decimal places rounding", "code": "def _saferound(value, decimal_places):\n    \"\"\"\n    Rounds a float value off to the desired precision\n    \"\"\"\n    try:\n        f = float(value)\n    except ValueError:\n        return ''\n    format = '%%.%df' % decimal_places\n    return format % f", "code_tokens": "def _saferound ( value , decimal_places ) : try : f = float ( value ) except ValueError : return '' format = '%%.%df' % decimal_places return format % f", "docstring_tokens": "Rounds a float value off to the desired precision", "label": 1}, {"idx": "cosqa-train-7036", "doc": "how can i scale numbers to a number between 0 and 1 in python", "code": "def _scaleSinglePoint(point, scale=1, convertToInteger=True):\n    \"\"\"\n    Scale a single point\n    \"\"\"\n    x, y = point\n    if convertToInteger:\n        return int(round(x * scale)), int(round(y * scale))\n    else:\n        return (x * scale, y * scale)", "code_tokens": "def _scaleSinglePoint ( point , scale = 1 , convertToInteger = True ) : x , y = point if convertToInteger : return int ( round ( x * scale ) ) , int ( round ( y * scale ) ) else : return ( x * scale , y * scale )", "docstring_tokens": "Scale a single point", "label": 1}, {"idx": "cosqa-train-7037", "doc": "python linalg norm for 3d", "code": "def l2_norm(params):\n    \"\"\"Computes l2 norm of params by flattening them into a vector.\"\"\"\n    flattened, _ = flatten(params)\n    return np.dot(flattened, flattened)", "code_tokens": "def l2_norm ( params ) : flattened , _ = flatten ( params ) return np . dot ( flattened , flattened )", "docstring_tokens": "Computes l2 norm of params by flattening them into a vector .", "label": 0}, {"idx": "cosqa-train-7038", "doc": "how can we implement stack in python with including libray file", "code": "def poke_array(self, store, name, elemtype, elements, container, visited, _stack):\n        \"\"\"abstract method\"\"\"\n        raise NotImplementedError", "code_tokens": "def poke_array ( self , store , name , elemtype , elements , container , visited , _stack ) : raise NotImplementedError", "docstring_tokens": "abstract method", "label": 0}, {"idx": "cosqa-train-7039", "doc": "python list check for not null", "code": "def is_nullable_list(val, vtype):\n    \"\"\"Return True if list contains either values of type `vtype` or None.\"\"\"\n    return (isinstance(val, list) and\n            any(isinstance(v, vtype) for v in val) and\n            all((isinstance(v, vtype) or v is None) for v in val))", "code_tokens": "def is_nullable_list ( val , vtype ) : return ( isinstance ( val , list ) and any ( isinstance ( v , vtype ) for v in val ) and all ( ( isinstance ( v , vtype ) or v is None ) for v in val ) )", "docstring_tokens": "Return True if list contains either values of type vtype or None .", "label": 0}, {"idx": "cosqa-train-7040", "doc": "how can we know encoding of a file in python", "code": "def read_from_file(file_path, encoding=\"utf-8\"):\n    \"\"\"\n    Read helper method\n\n    :type file_path: str|unicode\n    :type encoding: str|unicode\n    :rtype: str|unicode\n    \"\"\"\n    with codecs.open(file_path, \"r\", encoding) as f:\n        return f.read()", "code_tokens": "def read_from_file ( file_path , encoding = \"utf-8\" ) : with codecs . open ( file_path , \"r\" , encoding ) as f : return f . read ( )", "docstring_tokens": "Read helper method", "label": 1}, {"idx": "cosqa-train-7041", "doc": "python list filter nont none", "code": "def filter_none(list_of_points):\n    \"\"\"\n    \n    :param list_of_points: \n    :return: list_of_points with None's removed\n    \"\"\"\n    remove_elementnone = filter(lambda p: p is not None, list_of_points)\n    remove_sublistnone = filter(lambda p: not contains_none(p), remove_elementnone)\n    return list(remove_sublistnone)", "code_tokens": "def filter_none ( list_of_points ) : remove_elementnone = filter ( lambda p : p is not None , list_of_points ) remove_sublistnone = filter ( lambda p : not contains_none ( p ) , remove_elementnone ) return list ( remove_sublistnone )", "docstring_tokens": ": param list_of_points : : return : list_of_points with None s removed", "label": 0}, {"idx": "cosqa-train-7042", "doc": "how develop network proxy in python", "code": "def _prepare_proxy(self, conn):\n        \"\"\"\n        Establish tunnel connection early, because otherwise httplib\n        would improperly set Host: header to proxy's IP:port.\n        \"\"\"\n        conn.set_tunnel(self._proxy_host, self.port, self.proxy_headers)\n        conn.connect()", "code_tokens": "def _prepare_proxy ( self , conn ) : conn . set_tunnel ( self . _proxy_host , self . port , self . proxy_headers ) conn . connect ( )", "docstring_tokens": "Establish tunnel connection early because otherwise httplib would improperly set Host : header to proxy s IP : port .", "label": 0}, {"idx": "cosqa-train-7043", "doc": "python list get with default", "code": "def list_get(l, idx, default=None):\n    \"\"\"\n    Get from a list with an optional default value.\n    \"\"\"\n    try:\n        if l[idx]:\n            return l[idx]\n        else:\n            return default\n    except IndexError:\n        return default", "code_tokens": "def list_get ( l , idx , default = None ) : try : if l [ idx ] : return l [ idx ] else : return default except IndexError : return default", "docstring_tokens": "Get from a list with an optional default value .", "label": 1}, {"idx": "cosqa-train-7044", "doc": "how do i check for a value in a column for executing tasks in python", "code": "def get_extract_value_function(column_identifier):\n    \"\"\"\n    returns a function that extracts the value for a column.\n    \"\"\"\n    def extract_value(run_result):\n        pos = None\n        for i, column in enumerate(run_result.columns):\n            if column.title == column_identifier:\n                pos = i\n                break\n        if pos is None:\n            sys.exit('CPU time missing for task {0}.'.format(run_result.task_id[0]))\n        return Util.to_decimal(run_result.values[pos])\n    return extract_value", "code_tokens": "def get_extract_value_function ( column_identifier ) : def extract_value ( run_result ) : pos = None for i , column in enumerate ( run_result . columns ) : if column . title == column_identifier : pos = i break if pos is None : sys . exit ( 'CPU time missing for task {0}.' . format ( run_result . task_id [ 0 ] ) ) return Util . to_decimal ( run_result . values [ pos ] ) return extract_value", "docstring_tokens": "returns a function that extracts the value for a column .", "label": 1}, {"idx": "cosqa-train-7045", "doc": "python list has no attribute reshape", "code": "def shape_list(l,shape,dtype):\n    \"\"\" Shape a list of lists into the appropriate shape and data type \"\"\"\n    return np.array(l, dtype=dtype).reshape(shape)", "code_tokens": "def shape_list ( l , shape , dtype ) : return np . array ( l , dtype = dtype ) . reshape ( shape )", "docstring_tokens": "Shape a list of lists into the appropriate shape and data type", "label": 0}, {"idx": "cosqa-train-7046", "doc": "how do i count the number of records in a python table", "code": "def count_rows(self, table_name):\n        \"\"\"Return the number of entries in a table by counting them.\"\"\"\n        self.table_must_exist(table_name)\n        query = \"SELECT COUNT (*) FROM `%s`\" % table_name.lower()\n        self.own_cursor.execute(query)\n        return int(self.own_cursor.fetchone()[0])", "code_tokens": "def count_rows ( self , table_name ) : self . table_must_exist ( table_name ) query = \"SELECT COUNT (*) FROM `%s`\" % table_name . lower ( ) self . own_cursor . execute ( query ) return int ( self . own_cursor . fetchone ( ) [ 0 ] )", "docstring_tokens": "Return the number of entries in a table by counting them .", "label": 1}, {"idx": "cosqa-train-7047", "doc": "python list of objects to dictionary", "code": "def items_to_dict(items):\n    \"\"\"\n    Converts list of tuples to dictionary with duplicate keys converted to\n    lists.\n\n    :param list items:\n        List of tuples.\n\n    :returns:\n        :class:`dict`\n\n    \"\"\"\n\n    res = collections.defaultdict(list)\n\n    for k, v in items:\n        res[k].append(v)\n\n    return normalize_dict(dict(res))", "code_tokens": "def items_to_dict ( items ) : res = collections . defaultdict ( list ) for k , v in items : res [ k ] . append ( v ) return normalize_dict ( dict ( res ) )", "docstring_tokens": "Converts list of tuples to dictionary with duplicate keys converted to lists .", "label": 1}, {"idx": "cosqa-train-7048", "doc": "how do i encode a string to a url python", "code": "def url_encode(url):\n    \"\"\"\n    Convert special characters using %xx escape.\n\n    :param url: str\n    :return: str - encoded url\n    \"\"\"\n    if isinstance(url, text_type):\n        url = url.encode('utf8')\n    return quote(url, ':/%?&=')", "code_tokens": "def url_encode ( url ) : if isinstance ( url , text_type ) : url = url . encode ( 'utf8' ) return quote ( url , ':/%?&=' )", "docstring_tokens": "Convert special characters using %xx escape .", "label": 0}, {"idx": "cosqa-train-7049", "doc": "python list of self variables", "code": "def vars_(self):\n        \"\"\" Returns symbol instances corresponding to variables\n        of the current scope.\n        \"\"\"\n        return [x for x in self[self.current_scope].values() if x.class_ == CLASS.var]", "code_tokens": "def vars_ ( self ) : return [ x for x in self [ self . current_scope ] . values ( ) if x . class_ == CLASS . var ]", "docstring_tokens": "Returns symbol instances corresponding to variables of the current scope .", "label": 1}, {"idx": "cosqa-train-7050", "doc": "how do i recognize python as an internal or external command", "code": "def IPYTHON_MAIN():\n    \"\"\"Decide if the Ipython command line is running code.\"\"\"\n    import pkg_resources\n\n    runner_frame = inspect.getouterframes(inspect.currentframe())[-2]\n    return (\n        getattr(runner_frame, \"function\", None)\n        == pkg_resources.load_entry_point(\"ipython\", \"console_scripts\", \"ipython\").__name__\n    )", "code_tokens": "def IPYTHON_MAIN ( ) : import pkg_resources runner_frame = inspect . getouterframes ( inspect . currentframe ( ) ) [ - 2 ] return ( getattr ( runner_frame , \"function\" , None ) == pkg_resources . load_entry_point ( \"ipython\" , \"console_scripts\" , \"ipython\" ) . __name__ )", "docstring_tokens": "Decide if the Ipython command line is running code .", "label": 1}, {"idx": "cosqa-train-7051", "doc": "python list sort and unique", "code": "def deduplicate(list_object):\n    \"\"\"Rebuild `list_object` removing duplicated and keeping order\"\"\"\n    new = []\n    for item in list_object:\n        if item not in new:\n            new.append(item)\n    return new", "code_tokens": "def deduplicate ( list_object ) : new = [ ] for item in list_object : if item not in new : new . append ( item ) return new", "docstring_tokens": "Rebuild list_object removing duplicated and keeping order", "label": 0}, {"idx": "cosqa-train-7052", "doc": "how do i store as a list in python", "code": "def to_list(self):\n        \"\"\"Convert this confusion matrix into a 2x2 plain list of values.\"\"\"\n        return [[int(self.table.cell_values[0][1]), int(self.table.cell_values[0][2])],\n                [int(self.table.cell_values[1][1]), int(self.table.cell_values[1][2])]]", "code_tokens": "def to_list ( self ) : return [ [ int ( self . table . cell_values [ 0 ] [ 1 ] ) , int ( self . table . cell_values [ 0 ] [ 2 ] ) ] , [ int ( self . table . cell_values [ 1 ] [ 1 ] ) , int ( self . table . cell_values [ 1 ] [ 2 ] ) ] ]", "docstring_tokens": "Convert this confusion matrix into a 2x2 plain list of values .", "label": 1}, {"idx": "cosqa-train-7053", "doc": "python list tostring to list", "code": "def string_list_to_array(l):\n    \"\"\"\n    Turns a Python unicode string list into a Java String array.\n\n    :param l: the string list\n    :type: list\n    :rtype: java string array\n    :return: JB_Object\n    \"\"\"\n    result = javabridge.get_env().make_object_array(len(l), javabridge.get_env().find_class(\"java/lang/String\"))\n    for i in range(len(l)):\n        javabridge.get_env().set_object_array_element(result, i, javabridge.get_env().new_string_utf(l[i]))\n    return result", "code_tokens": "def string_list_to_array ( l ) : result = javabridge . get_env ( ) . make_object_array ( len ( l ) , javabridge . get_env ( ) . find_class ( \"java/lang/String\" ) ) for i in range ( len ( l ) ) : javabridge . get_env ( ) . set_object_array_element ( result , i , javabridge . get_env ( ) . new_string_utf ( l [ i ] ) ) return result", "docstring_tokens": "Turns a Python unicode string list into a Java String array .", "label": 1}, {"idx": "cosqa-train-7054", "doc": "how do i write a python dictionary to a csv file", "code": "def save_dict_to_file(filename, dictionary):\n  \"\"\"Saves dictionary as CSV file.\"\"\"\n  with open(filename, 'w') as f:\n    writer = csv.writer(f)\n    for k, v in iteritems(dictionary):\n      writer.writerow([str(k), str(v)])", "code_tokens": "def save_dict_to_file ( filename , dictionary ) : with open ( filename , 'w' ) as f : writer = csv . writer ( f ) for k , v in iteritems ( dictionary ) : writer . writerow ( [ str ( k ) , str ( v ) ] )", "docstring_tokens": "Saves dictionary as CSV file .", "label": 1}, {"idx": "cosqa-train-7055", "doc": "python list with no repeated", "code": "def get_uniques(l):\n    \"\"\" Returns a list with no repeated elements.\n    \"\"\"\n    result = []\n\n    for i in l:\n        if i not in result:\n            result.append(i)\n\n    return result", "code_tokens": "def get_uniques ( l ) : result = [ ] for i in l : if i not in result : result . append ( i ) return result", "docstring_tokens": "Returns a list with no repeated elements .", "label": 1}, {"idx": "cosqa-train-7056", "doc": "how do i write natural logarithm in python", "code": "def log(x):\n    \"\"\"\n    Natural logarithm\n    \"\"\"\n    if isinstance(x, UncertainFunction):\n        mcpts = np.log(x._mcpts)\n        return UncertainFunction(mcpts)\n    else:\n        return np.log(x)", "code_tokens": "def log ( x ) : if isinstance ( x , UncertainFunction ) : mcpts = np . log ( x . _mcpts ) return UncertainFunction ( mcpts ) else : return np . log ( x )", "docstring_tokens": "Natural logarithm", "label": 0}, {"idx": "cosqa-train-7057", "doc": "python load hdf5 to dict", "code": "def hdf5_to_dict(filepath, group='/'):\n    \"\"\"load the content of an hdf5 file to a dict.\n\n    # TODO: how to split domain_type_dev : parameter : value ?\n    \"\"\"\n    if not h5py.is_hdf5(filepath):\n        raise RuntimeError(filepath, 'is not a valid HDF5 file.')\n\n    with h5py.File(filepath, 'r') as handler:\n        dic = walk_hdf5_to_dict(handler[group])\n    return dic", "code_tokens": "def hdf5_to_dict ( filepath , group = '/' ) : if not h5py . is_hdf5 ( filepath ) : raise RuntimeError ( filepath , 'is not a valid HDF5 file.' ) with h5py . File ( filepath , 'r' ) as handler : dic = walk_hdf5_to_dict ( handler [ group ] ) return dic", "docstring_tokens": "load the content of an hdf5 file to a dict .", "label": 0}, {"idx": "cosqa-train-7058", "doc": "how do you create an hash of value in python", "code": "def get_point_hash(self, point):\n        \"\"\"\n        return geohash for given point with self.precision\n        :param point: GeoPoint instance\n        :return: string\n        \"\"\"\n        return geohash.encode(point.latitude, point.longitude, self.precision)", "code_tokens": "def get_point_hash ( self , point ) : return geohash . encode ( point . latitude , point . longitude , self . precision )", "docstring_tokens": "return geohash for given point with self . precision : param point : GeoPoint instance : return : string", "label": 1}, {"idx": "cosqa-train-7059", "doc": "python load in a text file", "code": "def Load(file):\n    \"\"\" Loads a model from specified file \"\"\"\n    with open(file, 'rb') as file:\n        model = dill.load(file)\n        return model", "code_tokens": "def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model", "docstring_tokens": "Loads a model from specified file", "label": 0}, {"idx": "cosqa-train-7060", "doc": "how do you do deepcopy in python", "code": "def __deepcopy__(self, memo):\n        \"\"\"Create a deep copy of the node\"\"\"\n        # noinspection PyArgumentList\n        return self.__class__(\n            **{key: deepcopy(getattr(self, key), memo) for key in self.keys}\n        )", "code_tokens": "def __deepcopy__ ( self , memo ) : # noinspection PyArgumentList return self . __class__ ( * * { key : deepcopy ( getattr ( self , key ) , memo ) for key in self . keys } )", "docstring_tokens": "Create a deep copy of the node", "label": 1}, {"idx": "cosqa-train-7061", "doc": "how do you save something as a python file", "code": "def pickle_save(thing,fname):\n    \"\"\"save something to a pickle file\"\"\"\n    pickle.dump(thing, open(fname,\"wb\"),pickle.HIGHEST_PROTOCOL)\n    return thing", "code_tokens": "def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , \"wb\" ) , pickle . HIGHEST_PROTOCOL ) return thing", "docstring_tokens": "save something to a pickle file", "label": 0}, {"idx": "cosqa-train-7062", "doc": "python load json from a json formatted string", "code": "def from_json_str(cls, json_str):\n    \"\"\"Convert json string representation into class instance.\n\n    Args:\n      json_str: json representation as string.\n\n    Returns:\n      New instance of the class with data loaded from json string.\n    \"\"\"\n    return cls.from_json(json.loads(json_str, cls=JsonDecoder))", "code_tokens": "def from_json_str ( cls , json_str ) : return cls . from_json ( json . loads ( json_str , cls = JsonDecoder ) )", "docstring_tokens": "Convert json string representation into class instance .", "label": 1}, {"idx": "cosqa-train-7063", "doc": "python load text of file", "code": "def Load(file):\n    \"\"\" Loads a model from specified file \"\"\"\n    with open(file, 'rb') as file:\n        model = dill.load(file)\n        return model", "code_tokens": "def Load ( file ) : with open ( file , 'rb' ) as file : model = dill . load ( file ) return model", "docstring_tokens": "Loads a model from specified file", "label": 0}, {"idx": "cosqa-train-7064", "doc": "how in python change text to title case", "code": "def camel_case(self, snake_case):\n        \"\"\" Convert snake case to camel case \"\"\"\n        components = snake_case.split('_')\n        return components[0] + \"\".join(x.title() for x in components[1:])", "code_tokens": "def camel_case ( self , snake_case ) : components = snake_case . split ( '_' ) return components [ 0 ] + \"\" . join ( x . title ( ) for x in components [ 1 : ] )", "docstring_tokens": "Convert snake case to camel case", "label": 0}, {"idx": "cosqa-train-7065", "doc": "python locals from stack frame", "code": "def get_frame_locals(stepback=0):\n    \"\"\"Returns locals dictionary from a given frame.\n\n    :param int stepback:\n\n    :rtype: dict\n\n    \"\"\"\n    with Frame(stepback=stepback) as frame:\n        locals_dict = frame.f_locals\n\n    return locals_dict", "code_tokens": "def get_frame_locals ( stepback = 0 ) : with Frame ( stepback = stepback ) as frame : locals_dict = frame . f_locals return locals_dict", "docstring_tokens": "Returns locals dictionary from a given frame .", "label": 0}, {"idx": "cosqa-train-7066", "doc": "how is the memory efficiency of python mmap", "code": "def align_to_mmap(num, round_up):\n    \"\"\"\n    Align the given integer number to the closest page offset, which usually is 4096 bytes.\n\n    :param round_up: if True, the next higher multiple of page size is used, otherwise\n        the lower page_size will be used (i.e. if True, 1 becomes 4096, otherwise it becomes 0)\n    :return: num rounded to closest page\"\"\"\n    res = (num // ALLOCATIONGRANULARITY) * ALLOCATIONGRANULARITY\n    if round_up and (res != num):\n        res += ALLOCATIONGRANULARITY\n    # END handle size\n    return res", "code_tokens": "def align_to_mmap ( num , round_up ) : res = ( num // ALLOCATIONGRANULARITY ) * ALLOCATIONGRANULARITY if round_up and ( res != num ) : res += ALLOCATIONGRANULARITY # END handle size return res", "docstring_tokens": "Align the given integer number to the closest page offset which usually is 4096 bytes .", "label": 1}, {"idx": "cosqa-train-7067", "doc": "python localtime with timezone from unix timestamp", "code": "def fromtimestamp(cls, timestamp):\n    \"\"\"Returns a datetime object of a given timestamp (in local tz).\"\"\"\n    d = cls.utcfromtimestamp(timestamp)\n    return d.astimezone(localtz())", "code_tokens": "def fromtimestamp ( cls , timestamp ) : d = cls . utcfromtimestamp ( timestamp ) return d . astimezone ( localtz ( ) )", "docstring_tokens": "Returns a datetime object of a given timestamp ( in local tz ) .", "label": 0}, {"idx": "cosqa-train-7068", "doc": "how randomly select element on 2d array in python", "code": "def downsample(array, k):\n    \"\"\"Choose k random elements of array.\"\"\"\n    length = array.shape[0]\n    indices = random.sample(xrange(length), k)\n    return array[indices]", "code_tokens": "def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]", "docstring_tokens": "Choose k random elements of array .", "label": 1}, {"idx": "cosqa-train-7069", "doc": "python lock non blocking", "code": "def lock(self, block=True):\n\t\t\"\"\"\n\t\tLock connection from being used else where\n\t\t\"\"\"\n\t\tself._locked = True\n\t\treturn self._lock.acquire(block)", "code_tokens": "def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )", "docstring_tokens": "Lock connection from being used else where", "label": 0}, {"idx": "cosqa-train-7070", "doc": "how ro replace a letter in a user input with a underscore in python", "code": "def case_us2mc(x):\n    \"\"\" underscore to mixed case notation \"\"\"\n    return re.sub(r'_([a-z])', lambda m: (m.group(1).upper()), x)", "code_tokens": "def case_us2mc ( x ) : return re . sub ( r'_([a-z])' , lambda m : ( m . group ( 1 ) . upper ( ) ) , x )", "docstring_tokens": "underscore to mixed case notation", "label": 0}, {"idx": "cosqa-train-7071", "doc": "python lock with blocking", "code": "def lock(self, block=True):\n\t\t\"\"\"\n\t\tLock connection from being used else where\n\t\t\"\"\"\n\t\tself._locked = True\n\t\treturn self._lock.acquire(block)", "code_tokens": "def lock ( self , block = True ) : self . _locked = True return self . _lock . acquire ( block )", "docstring_tokens": "Lock connection from being used else where", "label": 1}, {"idx": "cosqa-train-7072", "doc": "how to access 2d array python diagonally", "code": "def length(self):\n        \"\"\"Array of vector lengths\"\"\"\n        return np.sqrt(np.sum(self**2, axis=1)).view(np.ndarray)", "code_tokens": "def length ( self ) : return np . sqrt ( np . sum ( self ** 2 , axis = 1 ) ) . view ( np . ndarray )", "docstring_tokens": "Array of vector lengths", "label": 1}, {"idx": "cosqa-train-7073", "doc": "python log exact request", "code": "def log_request(self, code='-', size='-'):\n        \"\"\"Selectively log an accepted request.\"\"\"\n\n        if self.server.logRequests:\n            BaseHTTPServer.BaseHTTPRequestHandler.log_request(self, code, size)", "code_tokens": "def log_request ( self , code = '-' , size = '-' ) : if self . server . logRequests : BaseHTTPServer . BaseHTTPRequestHandler . log_request ( self , code , size )", "docstring_tokens": "Selectively log an accepted request .", "label": 1}, {"idx": "cosqa-train-7074", "doc": "how to access files on server python", "code": "def do_file_show(client, args):\n    \"\"\"Output file contents to stdout\"\"\"\n    for src_uri in args.uris:\n        client.download_file(src_uri, sys.stdout.buffer)\n\n    return True", "code_tokens": "def do_file_show ( client , args ) : for src_uri in args . uris : client . download_file ( src_uri , sys . stdout . buffer ) return True", "docstring_tokens": "Output file contents to stdout", "label": 0}, {"idx": "cosqa-train-7075", "doc": "python log file don't wrap lines", "code": "def getLinesFromLogFile(stream):\n    \"\"\"\n    Returns all lines written to the passed in stream\n    \"\"\"\n    stream.flush()\n    stream.seek(0)\n    lines = stream.readlines()\n    return lines", "code_tokens": "def getLinesFromLogFile ( stream ) : stream . flush ( ) stream . seek ( 0 ) lines = stream . readlines ( ) return lines", "docstring_tokens": "Returns all lines written to the passed in stream", "label": 0}, {"idx": "cosqa-train-7076", "doc": "how to access multip dimensional arrays in python", "code": "def torecarray(*args, **kwargs):\n    \"\"\"\n    Convenient shorthand for ``toarray(*args, **kwargs).view(np.recarray)``.\n\n    \"\"\"\n\n    import numpy as np\n    return toarray(*args, **kwargs).view(np.recarray)", "code_tokens": "def torecarray ( * args , * * kwargs ) : import numpy as np return toarray ( * args , * * kwargs ) . view ( np . recarray )", "docstring_tokens": "Convenient shorthand for toarray ( * args ** kwargs ) . view ( np . recarray ) .", "label": 0}, {"idx": "cosqa-train-7077", "doc": "python logger close remove handler", "code": "def close_log(log, verbose=True):\n    \"\"\"Close log\n\n    This method closes and active logging.Logger instance.\n\n    Parameters\n    ----------\n    log : logging.Logger\n        Logging instance\n\n    \"\"\"\n\n    if verbose:\n        print('Closing log file:', log.name)\n\n    # Send closing message.\n    log.info('The log file has been closed.')\n\n    # Remove all handlers from log.\n    [log.removeHandler(handler) for handler in log.handlers]", "code_tokens": "def close_log ( log , verbose = True ) : if verbose : print ( 'Closing log file:' , log . name ) # Send closing message. log . info ( 'The log file has been closed.' ) # Remove all handlers from log. [ log . removeHandler ( handler ) for handler in log . handlers ]", "docstring_tokens": "Close log", "label": 1}, {"idx": "cosqa-train-7078", "doc": "how to achieve logarithmic complexity in python", "code": "def log_loss(preds, labels):\n    \"\"\"Logarithmic loss with non-necessarily-binary labels.\"\"\"\n    log_likelihood = np.sum(labels * np.log(preds)) / len(preds)\n    return -log_likelihood", "code_tokens": "def log_loss ( preds , labels ) : log_likelihood = np . sum ( labels * np . log ( preds ) ) / len ( preds ) return - log_likelihood", "docstring_tokens": "Logarithmic loss with non - necessarily - binary labels .", "label": 1}, {"idx": "cosqa-train-7079", "doc": "python logger info not printing", "code": "def pylog(self, *args, **kwargs):\n        \"\"\"Display all available logging information.\"\"\"\n        printerr(self.name, args, kwargs, traceback.format_exc())", "code_tokens": "def pylog ( self , * args , * * kwargs ) : printerr ( self . name , args , kwargs , traceback . format_exc ( ) )", "docstring_tokens": "Display all available logging information .", "label": 0}, {"idx": "cosqa-train-7080", "doc": "how to activate conda environment in command for python", "code": "def create_conda_env(sandbox_dir, env_name, dependencies, options=()):\n    \"\"\"\n    Create a conda environment inside the current sandbox for the given list of dependencies and options.\n\n    Parameters\n    ----------\n    sandbox_dir : str\n    env_name : str\n    dependencies : list\n        List of conda specs\n    options\n        List of additional options to pass to conda.  Things like [\"-c\", \"conda-forge\"]\n\n    Returns\n    -------\n    (env_dir, env_name)\n    \"\"\"\n\n    env_dir = os.path.join(sandbox_dir, env_name)\n    cmdline = [\"conda\", \"create\", \"--yes\", \"--copy\", \"--quiet\", \"-p\", env_dir] + list(options) + dependencies\n\n    log.info(\"Creating conda environment: \")\n    log.info(\"  command line: %s\", cmdline)\n    subprocess.check_call(cmdline, stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n    log.debug(\"Environment created\")\n\n    return env_dir, env_name", "code_tokens": "def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ \"conda\" , \"create\" , \"--yes\" , \"--copy\" , \"--quiet\" , \"-p\" , env_dir ] + list ( options ) + dependencies log . info ( \"Creating conda environment: \" ) log . info ( \"  command line: %s\" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( \"Environment created\" ) return env_dir , env_name", "docstring_tokens": "Create a conda environment inside the current sandbox for the given list of dependencies and options .", "label": 0}, {"idx": "cosqa-train-7081", "doc": "python logger not writing to file after first messages", "code": "def log_no_newline(self, msg):\n      \"\"\" print the message to the predefined log file without newline \"\"\"\n      self.print2file(self.logfile, False, False, msg)", "code_tokens": "def log_no_newline ( self , msg ) : self . print2file ( self . logfile , False , False , msg )", "docstring_tokens": "print the message to the predefined log file without newline", "label": 1}, {"idx": "cosqa-train-7082", "doc": "how to activate conda environment in python script", "code": "def create_conda_env(sandbox_dir, env_name, dependencies, options=()):\n    \"\"\"\n    Create a conda environment inside the current sandbox for the given list of dependencies and options.\n\n    Parameters\n    ----------\n    sandbox_dir : str\n    env_name : str\n    dependencies : list\n        List of conda specs\n    options\n        List of additional options to pass to conda.  Things like [\"-c\", \"conda-forge\"]\n\n    Returns\n    -------\n    (env_dir, env_name)\n    \"\"\"\n\n    env_dir = os.path.join(sandbox_dir, env_name)\n    cmdline = [\"conda\", \"create\", \"--yes\", \"--copy\", \"--quiet\", \"-p\", env_dir] + list(options) + dependencies\n\n    log.info(\"Creating conda environment: \")\n    log.info(\"  command line: %s\", cmdline)\n    subprocess.check_call(cmdline, stderr=subprocess.PIPE, stdout=subprocess.PIPE)\n    log.debug(\"Environment created\")\n\n    return env_dir, env_name", "code_tokens": "def create_conda_env ( sandbox_dir , env_name , dependencies , options = ( ) ) : env_dir = os . path . join ( sandbox_dir , env_name ) cmdline = [ \"conda\" , \"create\" , \"--yes\" , \"--copy\" , \"--quiet\" , \"-p\" , env_dir ] + list ( options ) + dependencies log . info ( \"Creating conda environment: \" ) log . info ( \"  command line: %s\" , cmdline ) subprocess . check_call ( cmdline , stderr = subprocess . PIPE , stdout = subprocess . PIPE ) log . debug ( \"Environment created\" ) return env_dir , env_name", "docstring_tokens": "Create a conda environment inside the current sandbox for the given list of dependencies and options .", "label": 1}, {"idx": "cosqa-train-7083", "doc": "python logger setup and tear down in unit tests", "code": "def _configure_logger():\n    \"\"\"Configure the logging module.\"\"\"\n    if not app.debug:\n        _configure_logger_for_production(logging.getLogger())\n    elif not app.testing:\n        _configure_logger_for_debugging(logging.getLogger())", "code_tokens": "def _configure_logger ( ) : if not app . debug : _configure_logger_for_production ( logging . getLogger ( ) ) elif not app . testing : _configure_logger_for_debugging ( logging . getLogger ( ) )", "docstring_tokens": "Configure the logging module .", "label": 1}, {"idx": "cosqa-train-7084", "doc": "how to add a validation for input strings in python", "code": "def input_validate_yubikey_secret(data, name='data'):\n    \"\"\" Input validation for YHSM_YubiKeySecret or string. \"\"\"\n    if isinstance(data, pyhsm.aead_cmd.YHSM_YubiKeySecret):\n        data = data.pack()\n    return input_validate_str(data, name)", "code_tokens": "def input_validate_yubikey_secret ( data , name = 'data' ) : if isinstance ( data , pyhsm . aead_cmd . YHSM_YubiKeySecret ) : data = data . pack ( ) return input_validate_str ( data , name )", "docstring_tokens": "Input validation for YHSM_YubiKeySecret or string .", "label": 0}, {"idx": "cosqa-train-7085", "doc": "python loggin env variable", "code": "def extract_log_level_from_environment(k, default):\n    \"\"\"Gets the log level from the environment variable.\"\"\"\n    return LOG_LEVELS.get(os.environ.get(k)) or int(os.environ.get(k, default))", "code_tokens": "def extract_log_level_from_environment ( k , default ) : return LOG_LEVELS . get ( os . environ . get ( k ) ) or int ( os . environ . get ( k , default ) )", "docstring_tokens": "Gets the log level from the environment variable .", "label": 1}, {"idx": "cosqa-train-7086", "doc": "how to add an indented block python", "code": "def dumped(text, level, indent=2):\n    \"\"\"Put curly brackets round an indented text\"\"\"\n    return indented(\"{\\n%s\\n}\" % indented(text, level + 1, indent) or \"None\", level, indent) + \"\\n\"", "code_tokens": "def dumped ( text , level , indent = 2 ) : return indented ( \"{\\n%s\\n}\" % indented ( text , level + 1 , indent ) or \"None\" , level , indent ) + \"\\n\"", "docstring_tokens": "Put curly brackets round an indented text", "label": 1}, {"idx": "cosqa-train-7087", "doc": "python logging can not create file", "code": "def log_no_newline(self, msg):\n      \"\"\" print the message to the predefined log file without newline \"\"\"\n      self.print2file(self.logfile, False, False, msg)", "code_tokens": "def log_no_newline ( self , msg ) : self . print2file ( self . logfile , False , False , msg )", "docstring_tokens": "print the message to the predefined log file without newline", "label": 1}, {"idx": "cosqa-train-7088", "doc": "how to add arrows to plot in python", "code": "def add_arrow(self, x1, y1, x2, y2, **kws):\n        \"\"\"add arrow to plot\"\"\"\n        self.panel.add_arrow(x1, y1, x2, y2, **kws)", "code_tokens": "def add_arrow ( self , x1 , y1 , x2 , y2 , * * kws ) : self . panel . add_arrow ( x1 , y1 , x2 , y2 , * * kws )", "docstring_tokens": "add arrow to plot", "label": 1}, {"idx": "cosqa-train-7089", "doc": "python logging clear handlers", "code": "def remove_all_handler(self):\n        \"\"\"\n        Unlink the file handler association.\n        \"\"\"\n        for handler in self.logger.handlers[:]:\n            self.logger.removeHandler(handler)\n            self._handler_cache.append(handler)", "code_tokens": "def remove_all_handler ( self ) : for handler in self . logger . handlers [ : ] : self . logger . removeHandler ( handler ) self . _handler_cache . append ( handler )", "docstring_tokens": "Unlink the file handler association .", "label": 1}, {"idx": "cosqa-train-7090", "doc": "how to add authentication token to a post request python", "code": "def auth_request(self, url, headers, body):\n        \"\"\"Perform auth request for token.\"\"\"\n\n        return self.req.post(url, headers, body=body)", "code_tokens": "def auth_request ( self , url , headers , body ) : return self . req . post ( url , headers , body = body )", "docstring_tokens": "Perform auth request for token .", "label": 0}, {"idx": "cosqa-train-7091", "doc": "python logging doesn't write to file unless it already exists", "code": "def log_all(self, file):\n        \"\"\"Log all data received from RFLink to file.\"\"\"\n        global rflink_log\n        if file == None:\n            rflink_log = None\n        else:\n            log.debug('logging to: %s', file)\n            rflink_log = open(file, 'a')", "code_tokens": "def log_all ( self , file ) : global rflink_log if file == None : rflink_log = None else : log . debug ( 'logging to: %s' , file ) rflink_log = open ( file , 'a' )", "docstring_tokens": "Log all data received from RFLink to file .", "label": 0}, {"idx": "cosqa-train-7092", "doc": "how to add axes title to subplot python", "code": "def set_title(self, title, **kwargs):\n        \"\"\"Sets the title on the underlying matplotlib AxesSubplot.\"\"\"\n        ax = self.get_axes()\n        ax.set_title(title, **kwargs)", "code_tokens": "def set_title ( self , title , * * kwargs ) : ax = self . get_axes ( ) ax . set_title ( title , * * kwargs )", "docstring_tokens": "Sets the title on the underlying matplotlib AxesSubplot .", "label": 1}, {"idx": "cosqa-train-7093", "doc": "python logging iterate all loggers", "code": "def setLoggerAll(self, mthd):\n        \"\"\" Sends all messages to ``logger.[mthd]()`` for handling \"\"\"\n        for key in self._logger_methods:\n            self._logger_methods[key] = mthd", "code_tokens": "def setLoggerAll ( self , mthd ) : for key in self . _logger_methods : self . _logger_methods [ key ] = mthd", "docstring_tokens": "Sends all messages to logger . [ mthd ] () for handling", "label": 1}, {"idx": "cosqa-train-7094", "doc": "how to add bounding box to image python", "code": "def adjust_bounding_box(bbox):\n    \"\"\"Adjust the bounding box as specified by user.\n    Returns the adjusted bounding box.\n\n    - bbox: Bounding box computed from the canvas drawings.\n    It must be a four-tuple of numbers.\n    \"\"\"\n    for i in range(0, 4):\n        if i in bounding_box:\n            bbox[i] = bounding_box[i]\n        else:\n            bbox[i] += delta_bounding_box[i]\n    return bbox", "code_tokens": "def adjust_bounding_box ( bbox ) : for i in range ( 0 , 4 ) : if i in bounding_box : bbox [ i ] = bounding_box [ i ] else : bbox [ i ] += delta_bounding_box [ i ] return bbox", "docstring_tokens": "Adjust the bounding box as specified by user . Returns the adjusted bounding box .", "label": 0}, {"idx": "cosqa-train-7095", "doc": "python logging log to file without print", "code": "def log_no_newline(self, msg):\n      \"\"\" print the message to the predefined log file without newline \"\"\"\n      self.print2file(self.logfile, False, False, msg)", "code_tokens": "def log_no_newline ( self , msg ) : self . print2file ( self . logfile , False , False , msg )", "docstring_tokens": "print the message to the predefined log file without newline", "label": 0}, {"idx": "cosqa-train-7096", "doc": "how to add keyboardinterrupt signal handler in python", "code": "def _turn_sigterm_into_systemexit(): # pragma: no cover\n    \"\"\"\n    Attempts to turn a SIGTERM exception into a SystemExit exception.\n    \"\"\"\n    try:\n        import signal\n    except ImportError:\n        return\n    def handle_term(signo, frame):\n        raise SystemExit\n    signal.signal(signal.SIGTERM, handle_term)", "code_tokens": "def _turn_sigterm_into_systemexit ( ) : # pragma: no cover try : import signal except ImportError : return def handle_term ( signo , frame ) : raise SystemExit signal . signal ( signal . SIGTERM , handle_term )", "docstring_tokens": "Attempts to turn a SIGTERM exception into a SystemExit exception .", "label": 0}, {"idx": "cosqa-train-7097", "doc": "python logging not saving", "code": "def info(self, message, *args, **kwargs):\n        \"\"\"More important level : default for print and save\n        \"\"\"\n        self._log(logging.INFO, message, *args, **kwargs)", "code_tokens": "def info ( self , message , * args , * * kwargs ) : self . _log ( logging . INFO , message , * args , * * kwargs )", "docstring_tokens": "More important level : default for print and save", "label": 1}, {"idx": "cosqa-train-7098", "doc": "how to add lines to 2d arrays python", "code": "def patch_lines(x):\n    \"\"\"\n    Draw lines between groups\n    \"\"\"\n    for idx in range(len(x)-1):\n        x[idx] = np.vstack([x[idx], x[idx+1][0,:]])\n    return x", "code_tokens": "def patch_lines ( x ) : for idx in range ( len ( x ) - 1 ) : x [ idx ] = np . vstack ( [ x [ idx ] , x [ idx + 1 ] [ 0 , : ] ] ) return x", "docstring_tokens": "Draw lines between groups", "label": 0}, {"idx": "cosqa-train-7099", "doc": "python logging print and save", "code": "def info(self, message, *args, **kwargs):\n        \"\"\"More important level : default for print and save\n        \"\"\"\n        self._log(logging.INFO, message, *args, **kwargs)", "code_tokens": "def info ( self , message , * args , * * kwargs ) : self . _log ( logging . INFO , message , * args , * * kwargs )", "docstring_tokens": "More important level : default for print and save", "label": 1}, {"idx": "cosqa-train-7100", "doc": "how to add noise to an image using python", "code": "def shot_noise(x, severity=1):\n  \"\"\"Shot noise corruption to images.\n\n  Args:\n    x: numpy array, uncorrupted image, assumed to have uint8 pixel in [0,255].\n    severity: integer, severity of corruption.\n\n  Returns:\n    numpy array, image with uint8 pixels in [0,255]. Added shot noise.\n  \"\"\"\n  c = [60, 25, 12, 5, 3][severity - 1]\n  x = np.array(x) / 255.\n  x_clip = np.clip(np.random.poisson(x * c) / float(c), 0, 1) * 255\n  return around_and_astype(x_clip)", "code_tokens": "def shot_noise ( x , severity = 1 ) : c = [ 60 , 25 , 12 , 5 , 3 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( np . random . poisson ( x * c ) / float ( c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )", "docstring_tokens": "Shot noise corruption to images .", "label": 1}, {"idx": "cosqa-train-7101", "doc": "python logging queue handler", "code": "def add_queue_handler(queue):\n    \"\"\"Add a queue log handler to the global logger.\"\"\"\n    handler = QueueLogHandler(queue)\n    handler.setFormatter(QueueFormatter())\n    handler.setLevel(DEBUG)\n    GLOBAL_LOGGER.addHandler(handler)", "code_tokens": "def add_queue_handler ( queue ) : handler = QueueLogHandler ( queue ) handler . setFormatter ( QueueFormatter ( ) ) handler . setLevel ( DEBUG ) GLOBAL_LOGGER . addHandler ( handler )", "docstring_tokens": "Add a queue log handler to the global logger .", "label": 0}, {"idx": "cosqa-train-7102", "doc": "how to add percentage success bar in python", "code": "def __init__(self, min_value, max_value, format=\"%(bar)s: %(percentage) 6.2f%% %(timeinfo)s\", width=40, barchar=\"#\", emptychar=\"-\", output=sys.stdout):\n\t\t\"\"\"\t\t\n\t\t\t:param min_value: minimum value for update(..)\n\t\t\t:param format: format specifier for the output\n\t\t\t:param width: width of the progress bar's (excluding extra text)\n\t\t\t:param barchar: character used to print the bar\n\t\t\t:param output: where to write the output to\n\t\t\"\"\"\n\t\tself.min_value = min_value\n\t\tself.max_value = max_value\n\t\tself.format = format\n\t\tself.width = width\n\t\tself.barchar = barchar\n\t\tself.emptychar = emptychar\n\t\tself.output = output\n\t\t\n\t\tself.firsttime = True\n\t\tself.prevtime = time.time()\n\t\tself.starttime = self.prevtime\n\t\tself.prevfraction = 0\n\t\tself.firsttimedone = False\n\t\tself.value = self.min_value", "code_tokens": "def __init__ ( self , min_value , max_value , format = \"%(bar)s: %(percentage) 6.2f%% %(timeinfo)s\" , width = 40 , barchar = \"#\" , emptychar = \"-\" , output = sys . stdout ) : self . min_value = min_value self . max_value = max_value self . format = format self . width = width self . barchar = barchar self . emptychar = emptychar self . output = output self . firsttime = True self . prevtime = time . time ( ) self . starttime = self . prevtime self . prevfraction = 0 self . firsttimedone = False self . value = self . min_value", "docstring_tokens": ": param min_value : minimum value for update ( .. ) : param format : format specifier for the output : param width : width of the progress bar s ( excluding extra text ) : param barchar : character used to print the bar : param output : where to write the output to", "label": 1}, {"idx": "cosqa-train-7103", "doc": "python long list of #define constants", "code": "def consts(self):\n        \"\"\"The constants referenced in this code object.\n        \"\"\"\n        # We cannot use a set comprehension because consts do not need\n        # to be hashable.\n        consts = []\n        append_const = consts.append\n        for instr in self.instrs:\n            if isinstance(instr, LOAD_CONST) and instr.arg not in consts:\n                append_const(instr.arg)\n        return tuple(consts)", "code_tokens": "def consts ( self ) : # We cannot use a set comprehension because consts do not need # to be hashable. consts = [ ] append_const = consts . append for instr in self . instrs : if isinstance ( instr , LOAD_CONST ) and instr . arg not in consts : append_const ( instr . arg ) return tuple ( consts )", "docstring_tokens": "The constants referenced in this code object .", "label": 0}, {"idx": "cosqa-train-7104", "doc": "how to add two polynomials in python", "code": "def __add__(self, other):\n        \"\"\"Left addition.\"\"\"\n        return chaospy.poly.collection.arithmetics.add(self, other)", "code_tokens": "def __add__ ( self , other ) : return chaospy . poly . collection . arithmetics . add ( self , other )", "docstring_tokens": "Left addition .", "label": 0}, {"idx": "cosqa-train-7105", "doc": "python longest consecutive ones group", "code": "def longest_run_1d(arr):\n    \"\"\"Return the length of the longest consecutive run of identical values.\n\n    Parameters\n    ----------\n    arr : bool array\n      Input array\n\n    Returns\n    -------\n    int\n      Length of longest run.\n    \"\"\"\n    v, rl = rle_1d(arr)[:2]\n    return np.where(v, rl, 0).max()", "code_tokens": "def longest_run_1d ( arr ) : v , rl = rle_1d ( arr ) [ : 2 ] return np . where ( v , rl , 0 ) . max ( )", "docstring_tokens": "Return the length of the longest consecutive run of identical values .", "label": 1}, {"idx": "cosqa-train-7106", "doc": "how to add white gaussian noise to an array with python", "code": "def gaussian_noise(x, severity=1):\n  \"\"\"Gaussian noise corruption to images.\n\n  Args:\n    x: numpy array, uncorrupted image, assumed to have uint8 pixel in [0,255].\n    severity: integer, severity of corruption.\n\n  Returns:\n    numpy array, image with uint8 pixels in [0,255]. Added Gaussian noise.\n  \"\"\"\n  c = [.08, .12, 0.18, 0.26, 0.38][severity - 1]\n  x = np.array(x) / 255.\n  x_clip = np.clip(x + np.random.normal(size=x.shape, scale=c), 0, 1) * 255\n  return around_and_astype(x_clip)", "code_tokens": "def gaussian_noise ( x , severity = 1 ) : c = [ .08 , .12 , 0.18 , 0.26 , 0.38 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( x + np . random . normal ( size = x . shape , scale = c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )", "docstring_tokens": "Gaussian noise corruption to images .", "label": 1}, {"idx": "cosqa-train-7107", "doc": "python lookup file size", "code": "def get_file_size(filename):\n    \"\"\"\n    Get the file size of a given file\n\n    :param filename: string: pathname of a file\n    :return: human readable filesize\n    \"\"\"\n    if os.path.isfile(filename):\n        return convert_size(os.path.getsize(filename))\n    return None", "code_tokens": "def get_file_size ( filename ) : if os . path . isfile ( filename ) : return convert_size ( os . path . getsize ( filename ) ) return None", "docstring_tokens": "Get the file size of a given file", "label": 1}, {"idx": "cosqa-train-7108", "doc": "how to allow connections to ssl sites without certs python request", "code": "def enable_ssl(self, *args, **kwargs):\n        \"\"\"\n        Transforms the regular socket.socket to an ssl.SSLSocket for secure\n        connections. Any arguments are passed to ssl.wrap_socket:\n        http://docs.python.org/dev/library/ssl.html#ssl.wrap_socket\n        \"\"\"\n        if self.handshake_sent:\n            raise SSLError('can only enable SSL before handshake')\n\n        self.secure = True\n        self.sock = ssl.wrap_socket(self.sock, *args, **kwargs)", "code_tokens": "def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )", "docstring_tokens": "Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket", "label": 0}, {"idx": "cosqa-train-7109", "doc": "python main thread how to kill daemon thread", "code": "def sigterm(self, signum, frame):\n        \"\"\"\n        These actions will be done after SIGTERM.\n        \"\"\"\n        self.logger.warning(\"Caught signal %s. Stopping daemon.\" % signum)\n        sys.exit(0)", "code_tokens": "def sigterm ( self , signum , frame ) : self . logger . warning ( \"Caught signal %s. Stopping daemon.\" % signum ) sys . exit ( 0 )", "docstring_tokens": "These actions will be done after SIGTERM .", "label": 0}, {"idx": "cosqa-train-7110", "doc": "how to ask for an input on python3", "code": "def _stdin_(p):\n    \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"\n    _v = sys.version[0]\n    return input(p) if _v is '3' else raw_input(p)", "code_tokens": "def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "docstring_tokens": "Takes input from user . Works for Python 2 and 3 .", "label": 0}, {"idx": "cosqa-train-7111", "doc": "python make a string mysql safe", "code": "def decode_mysql_string_literal(text):\n    \"\"\"\n    Removes quotes and decodes escape sequences from given MySQL string literal\n    returning the result.\n\n    :param text: MySQL string literal, with the quotes still included.\n    :type text: str\n\n    :return: Given string literal with quotes removed and escape sequences\n             decoded.\n    :rtype: str\n    \"\"\"\n    assert text.startswith(\"'\")\n    assert text.endswith(\"'\")\n\n    # Ditch quotes from the string literal.\n    text = text[1:-1]\n\n    return MYSQL_STRING_ESCAPE_SEQUENCE_PATTERN.sub(\n        unescape_single_character,\n        text,\n    )", "code_tokens": "def decode_mysql_string_literal ( text ) : assert text . startswith ( \"'\" ) assert text . endswith ( \"'\" ) # Ditch quotes from the string literal. text = text [ 1 : - 1 ] return MYSQL_STRING_ESCAPE_SEQUENCE_PATTERN . sub ( unescape_single_character , text , )", "docstring_tokens": "Removes quotes and decodes escape sequences from given MySQL string literal returning the result .", "label": 0}, {"idx": "cosqa-train-7112", "doc": "how to bin intervals for a histagram in python", "code": "def get_bin_indices(self, values):\n        \"\"\"Returns index tuple in histogram of bin which contains value\"\"\"\n        return tuple([self.get_axis_bin_index(values[ax_i], ax_i)\n                      for ax_i in range(self.dimensions)])", "code_tokens": "def get_bin_indices ( self , values ) : return tuple ( [ self . get_axis_bin_index ( values [ ax_i ] , ax_i ) for ax_i in range ( self . dimensions ) ] )", "docstring_tokens": "Returns index tuple in histogram of bin which contains value", "label": 1}, {"idx": "cosqa-train-7113", "doc": "python make dict keys a set", "code": "def make_symmetric(dict):\n    \"\"\"Makes the given dictionary symmetric. Values are assumed to be unique.\"\"\"\n    for key, value in list(dict.items()):\n        dict[value] = key\n    return dict", "code_tokens": "def make_symmetric ( dict ) : for key , value in list ( dict . items ( ) ) : dict [ value ] = key return dict", "docstring_tokens": "Makes the given dictionary symmetric . Values are assumed to be unique .", "label": 1}, {"idx": "cosqa-train-7114", "doc": "how to bold somethign in python", "code": "def good(txt):\n    \"\"\"Print, emphasized 'good', the given 'txt' message\"\"\"\n\n    print(\"%s# %s%s%s\" % (PR_GOOD_CC, get_time_stamp(), txt, PR_NC))\n    sys.stdout.flush()", "code_tokens": "def good ( txt ) : print ( \"%s# %s%s%s\" % ( PR_GOOD_CC , get_time_stamp ( ) , txt , PR_NC ) ) sys . stdout . flush ( )", "docstring_tokens": "Print emphasized good the given txt message", "label": 0}, {"idx": "cosqa-train-7115", "doc": "python make directory exists", "code": "def ensure_dir(f):\n    \"\"\" Ensure a a file exists and if not make the relevant path \"\"\"\n    d = os.path.dirname(f)\n    if not os.path.exists(d):\n        os.makedirs(d)", "code_tokens": "def ensure_dir ( f ) : d = os . path . dirname ( f ) if not os . path . exists ( d ) : os . makedirs ( d )", "docstring_tokens": "Ensure a a file exists and if not make the relevant path", "label": 1}, {"idx": "cosqa-train-7116", "doc": "how to break a string up into a tuple in python", "code": "def ver_to_tuple(value):\n    \"\"\"\n    Convert version like string to a tuple of integers.\n    \"\"\"\n    return tuple(int(_f) for _f in re.split(r'\\D+', value) if _f)", "code_tokens": "def ver_to_tuple ( value ) : return tuple ( int ( _f ) for _f in re . split ( r'\\D+' , value ) if _f )", "docstring_tokens": "Convert version like string to a tuple of integers .", "label": 1}, {"idx": "cosqa-train-7117", "doc": "python make nan values 0", "code": "def clean_with_zeros(self,x):\n        \"\"\" set nan and inf rows from x to zero\"\"\"\n        x[~np.any(np.isnan(x) | np.isinf(x),axis=1)] = 0\n        return x", "code_tokens": "def clean_with_zeros ( self , x ) : x [ ~ np . any ( np . isnan ( x ) | np . isinf ( x ) , axis = 1 ) ] = 0 return x", "docstring_tokens": "set nan and inf rows from x to zero", "label": 1}, {"idx": "cosqa-train-7118", "doc": "how to calculate accuracy of a model with train and test data python", "code": "def local_accuracy(X_train, y_train, X_test, y_test, attr_test, model_generator, metric, trained_model):\n    \"\"\" The how well do the features plus a constant base rate sum up to the model output.\n    \"\"\"\n\n    X_train, X_test = to_array(X_train, X_test)\n\n    # how many features to mask\n    assert X_train.shape[1] == X_test.shape[1]\n\n    # keep nkeep top features and re-train the model for each test explanation\n    yp_test = trained_model.predict(X_test)\n\n    return metric(yp_test, strip_list(attr_test).sum(1))", "code_tokens": "def local_accuracy ( X_train , y_train , X_test , y_test , attr_test , model_generator , metric , trained_model ) : X_train , X_test = to_array ( X_train , X_test ) # how many features to mask assert X_train . shape [ 1 ] == X_test . shape [ 1 ] # keep nkeep top features and re-train the model for each test explanation yp_test = trained_model . predict ( X_test ) return metric ( yp_test , strip_list ( attr_test ) . sum ( 1 ) )", "docstring_tokens": "The how well do the features plus a constant base rate sum up to the model output .", "label": 0}, {"idx": "cosqa-train-7119", "doc": "python making url string safe", "code": "def url_encode(url):\n    \"\"\"\n    Convert special characters using %xx escape.\n\n    :param url: str\n    :return: str - encoded url\n    \"\"\"\n    if isinstance(url, text_type):\n        url = url.encode('utf8')\n    return quote(url, ':/%?&=')", "code_tokens": "def url_encode ( url ) : if isinstance ( url , text_type ) : url = url . encode ( 'utf8' ) return quote ( url , ':/%?&=' )", "docstring_tokens": "Convert special characters using %xx escape .", "label": 1}, {"idx": "cosqa-train-7120", "doc": "how to calculate center of a bounding box python", "code": "def calculate_bbox_area(bbox, rows, cols):\n    \"\"\"Calculate the area of a bounding box in pixels.\"\"\"\n    bbox = denormalize_bbox(bbox, rows, cols)\n    x_min, y_min, x_max, y_max = bbox[:4]\n    area = (x_max - x_min) * (y_max - y_min)\n    return area", "code_tokens": "def calculate_bbox_area ( bbox , rows , cols ) : bbox = denormalize_bbox ( bbox , rows , cols ) x_min , y_min , x_max , y_max = bbox [ : 4 ] area = ( x_max - x_min ) * ( y_max - y_min ) return area", "docstring_tokens": "Calculate the area of a bounding box in pixels .", "label": 0}, {"idx": "cosqa-train-7121", "doc": "python manually delete object", "code": "def tearDown(self):\n        \"\"\" Clean up environment\n\n        \"\"\"\n        if self.sdkobject and self.sdkobject.id:\n            self.sdkobject.delete()\n            self.sdkobject.id = None", "code_tokens": "def tearDown ( self ) : if self . sdkobject and self . sdkobject . id : self . sdkobject . delete ( ) self . sdkobject . id = None", "docstring_tokens": "Clean up environment", "label": 0}, {"idx": "cosqa-train-7122", "doc": "how to calculate eigen values python", "code": "def center_eigenvalue_diff(mat):\n    \"\"\"Compute the eigvals of mat and then find the center eigval difference.\"\"\"\n    N = len(mat)\n    evals = np.sort(la.eigvals(mat))\n    diff = np.abs(evals[N/2] - evals[N/2-1])\n    return diff", "code_tokens": "def center_eigenvalue_diff ( mat ) : N = len ( mat ) evals = np . sort ( la . eigvals ( mat ) ) diff = np . abs ( evals [ N / 2 ] - evals [ N / 2 - 1 ] ) return diff", "docstring_tokens": "Compute the eigvals of mat and then find the center eigval difference .", "label": 1}, {"idx": "cosqa-train-7123", "doc": "python many to many fied", "code": "def handle_m2m(self, sender, instance, **kwargs):\n    \"\"\" Handle many to many relationships \"\"\"\n    self.handle_save(instance.__class__, instance)", "code_tokens": "def handle_m2m ( self , sender , instance , * * kwargs ) : self . handle_save ( instance . __class__ , instance )", "docstring_tokens": "Handle many to many relationships", "label": 1}, {"idx": "cosqa-train-7124", "doc": "how to calculate logprior in python", "code": "def _get_log_prior_cl_func(self):\n        \"\"\"Get the CL log prior compute function.\n\n        Returns:\n            str: the compute function for computing the log prior.\n        \"\"\"\n        return SimpleCLFunction.from_string('''\n            mot_float_type _computeLogPrior(local const mot_float_type* x, void* data){\n                return ''' + self._log_prior_func.get_cl_function_name() + '''(x, data);\n            }\n        ''', dependencies=[self._log_prior_func])", "code_tokens": "def _get_log_prior_cl_func ( self ) : return SimpleCLFunction . from_string ( '''\n            mot_float_type _computeLogPrior(local const mot_float_type* x, void* data){\n                return ''' + self . _log_prior_func . get_cl_function_name ( ) + '''(x, data);\n            }\n        ''' , dependencies = [ self . _log_prior_func ] )", "docstring_tokens": "Get the CL log prior compute function .", "label": 1}, {"idx": "cosqa-train-7125", "doc": "python match a series of datetimes", "code": "def datetime_match(data, dts):\n    \"\"\"\n    matching of datetimes in time columns for data filtering\n    \"\"\"\n    dts = dts if islistable(dts) else [dts]\n    if any([not isinstance(i, datetime.datetime) for i in dts]):\n        error_msg = (\n            \"`time` can only be filtered by datetimes\"\n        )\n        raise TypeError(error_msg)\n    return data.isin(dts)", "code_tokens": "def datetime_match ( data , dts ) : dts = dts if islistable ( dts ) else [ dts ] if any ( [ not isinstance ( i , datetime . datetime ) for i in dts ] ) : error_msg = ( \"`time` can only be filtered by datetimes\" ) raise TypeError ( error_msg ) return data . isin ( dts )", "docstring_tokens": "matching of datetimes in time columns for data filtering", "label": 1}, {"idx": "cosqa-train-7126", "doc": "how to call an index from a python df", "code": "def idx(df, index):\n    \"\"\"Universal indexing for numpy and pandas objects.\"\"\"\n    if isinstance(df, (pd.DataFrame, pd.Series)):\n        return df.iloc[index]\n    else:\n        return df[index, :]", "code_tokens": "def idx ( df , index ) : if isinstance ( df , ( pd . DataFrame , pd . Series ) ) : return df . iloc [ index ] else : return df [ index , : ]", "docstring_tokens": "Universal indexing for numpy and pandas objects .", "label": 1}, {"idx": "cosqa-train-7127", "doc": "python matplot set ylim", "code": "def set_ylimits(self, row, column, min=None, max=None):\n        \"\"\"Set y-axis limits of a subplot.\n\n        :param row,column: specify the subplot.\n        :param min: minimal axis value\n        :param max: maximum axis value\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_ylimits(min, max)", "code_tokens": "def set_ylimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_ylimits ( min , max )", "docstring_tokens": "Set y - axis limits of a subplot .", "label": 1}, {"idx": "cosqa-train-7128", "doc": "how to call get and print out its output from a rest api in python", "code": "def list_apis(awsclient):\n    \"\"\"List APIs in account.\"\"\"\n    client_api = awsclient.get_client('apigateway')\n\n    apis = client_api.get_rest_apis()['items']\n\n    for api in apis:\n        print(json2table(api))", "code_tokens": "def list_apis ( awsclient ) : client_api = awsclient . get_client ( 'apigateway' ) apis = client_api . get_rest_apis ( ) [ 'items' ] for api in apis : print ( json2table ( api ) )", "docstring_tokens": "List APIs in account .", "label": 1}, {"idx": "cosqa-train-7129", "doc": "python matplotlib img uint8 to uint16", "code": "def uint32_to_uint8(cls, img):\n        \"\"\"\n        Cast uint32 RGB image to 4 uint8 channels.\n        \"\"\"\n        return np.flipud(img.view(dtype=np.uint8).reshape(img.shape + (4,)))", "code_tokens": "def uint32_to_uint8 ( cls , img ) : return np . flipud ( img . view ( dtype = np . uint8 ) . reshape ( img . shape + ( 4 , ) ) )", "docstring_tokens": "Cast uint32 RGB image to 4 uint8 channels .", "label": 1}, {"idx": "cosqa-train-7130", "doc": "how to cancel code python", "code": "def quit(self):\n        \"\"\" Exit the program due to user's choices.\n        \"\"\"\n        self.script.LOG.warn(\"Abort due to user choice!\")\n        sys.exit(self.QUIT_RC)", "code_tokens": "def quit ( self ) : self . script . LOG . warn ( \"Abort due to user choice!\" ) sys . exit ( self . QUIT_RC )", "docstring_tokens": "Exit the program due to user s choices .", "label": 0}, {"idx": "cosqa-train-7131", "doc": "python matplotlib interactive leave figure open", "code": "def raise_figure_window(f=0):\n    \"\"\"\n    Raises the supplied figure number or figure window.\n    \"\"\"\n    if _fun.is_a_number(f): f = _pylab.figure(f)\n    f.canvas.manager.window.raise_()", "code_tokens": "def raise_figure_window ( f = 0 ) : if _fun . is_a_number ( f ) : f = _pylab . figure ( f ) f . canvas . manager . window . raise_ ( )", "docstring_tokens": "Raises the supplied figure number or figure window .", "label": 1}, {"idx": "cosqa-train-7132", "doc": "how to capitalize first word in python string", "code": "def mixedcase(path):\n    \"\"\"Removes underscores and capitalizes the neighbouring character\"\"\"\n    words = path.split('_')\n    return words[0] + ''.join(word.title() for word in words[1:])", "code_tokens": "def mixedcase ( path ) : words = path . split ( '_' ) return words [ 0 ] + '' . join ( word . title ( ) for word in words [ 1 : ] )", "docstring_tokens": "Removes underscores and capitalizes the neighbouring character", "label": 1}, {"idx": "cosqa-train-7133", "doc": "python matplotlib prevent figure window from appearing", "code": "def raise_figure_window(f=0):\n    \"\"\"\n    Raises the supplied figure number or figure window.\n    \"\"\"\n    if _fun.is_a_number(f): f = _pylab.figure(f)\n    f.canvas.manager.window.raise_()", "code_tokens": "def raise_figure_window ( f = 0 ) : if _fun . is_a_number ( f ) : f = _pylab . figure ( f ) f . canvas . manager . window . raise_ ( )", "docstring_tokens": "Raises the supplied figure number or figure window .", "label": 1}, {"idx": "cosqa-train-7134", "doc": "how to capitalize last letter of an input string python", "code": "def to_camel(s):\n    \"\"\"\n    :param string s: under_scored string to be CamelCased\n    :return: CamelCase version of input\n    :rtype: str\n    \"\"\"\n    # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups\n    return re.sub(r'_([a-zA-Z])', lambda m: m.group(1).upper(), '_' + s)", "code_tokens": "def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )", "docstring_tokens": ": param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str", "label": 0}, {"idx": "cosqa-train-7135", "doc": "python matplotlib pyplot aspect ratio square", "code": "def figsize(x=8, y=7., aspect=1.):\n    \"\"\" manually set the default figure size of plots\n    ::Arguments::\n        x (float): x-axis size\n        y (float): y-axis size\n        aspect (float): aspect ratio scalar\n    \"\"\"\n    # update rcparams with adjusted figsize params\n    mpl.rcParams.update({'figure.figsize': (x*aspect, y)})", "code_tokens": "def figsize ( x = 8 , y = 7. , aspect = 1. ) : # update rcparams with adjusted figsize params mpl . rcParams . update ( { 'figure.figsize' : ( x * aspect , y ) } )", "docstring_tokens": "manually set the default figure size of plots :: Arguments :: x ( float ) : x - axis size y ( float ) : y - axis size aspect ( float ) : aspect ratio scalar", "label": 0}, {"idx": "cosqa-train-7136", "doc": "how to capitalize some letters in python", "code": "def to_camel_case(text):\n    \"\"\"Convert to camel case.\n\n    :param str text:\n    :rtype: str\n    :return:\n    \"\"\"\n    split = text.split('_')\n    return split[0] + \"\".join(x.title() for x in split[1:])", "code_tokens": "def to_camel_case ( text ) : split = text . split ( '_' ) return split [ 0 ] + \"\" . join ( x . title ( ) for x in split [ 1 : ] )", "docstring_tokens": "Convert to camel case .", "label": 1}, {"idx": "cosqa-train-7137", "doc": "python matplotlib remove from legend", "code": "def _process_legend(self):\n        \"\"\"\n        Disables legends if show_legend is disabled.\n        \"\"\"\n        for l in self.handles['plot'].legend:\n            l.items[:] = []\n            l.border_line_alpha = 0\n            l.background_fill_alpha = 0", "code_tokens": "def _process_legend ( self ) : for l in self . handles [ 'plot' ] . legend : l . items [ : ] = [ ] l . border_line_alpha = 0 l . background_fill_alpha = 0", "docstring_tokens": "Disables legends if show_legend is disabled .", "label": 1}, {"idx": "cosqa-train-7138", "doc": "how to capitalize the first letter of userinput in python", "code": "def snake_to_camel(name):\n    \"\"\"Takes a snake_field_name and returns a camelCaseFieldName\n\n    Args:\n        name (str): E.g. snake_field_name or SNAKE_FIELD_NAME\n\n    Returns:\n        str: camelCase converted name. E.g. capsFieldName\n    \"\"\"\n    ret = \"\".join(x.title() for x in name.split(\"_\"))\n    ret = ret[0].lower() + ret[1:]\n    return ret", "code_tokens": "def snake_to_camel ( name ) : ret = \"\" . join ( x . title ( ) for x in name . split ( \"_\" ) ) ret = ret [ 0 ] . lower ( ) + ret [ 1 : ] return ret", "docstring_tokens": "Takes a snake_field_name and returns a camelCaseFieldName", "label": 1}, {"idx": "cosqa-train-7139", "doc": "python matplotlib remove y axis", "code": "def axes_off(ax):\n    \"\"\"Get rid of all axis ticks, lines, etc.\n    \"\"\"\n    ax.set_frame_on(False)\n    ax.axes.get_yaxis().set_visible(False)\n    ax.axes.get_xaxis().set_visible(False)", "code_tokens": "def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )", "docstring_tokens": "Get rid of all axis ticks lines etc .", "label": 1}, {"idx": "cosqa-train-7140", "doc": "how to cast a variable as a float in python", "code": "def _tofloat(obj):\n    \"\"\"Convert to float if object is a float string.\"\"\"\n    if \"inf\" in obj.lower().strip():\n        return obj\n    try:\n        return int(obj)\n    except ValueError:\n        try:\n            return float(obj)\n        except ValueError:\n            return obj", "code_tokens": "def _tofloat ( obj ) : if \"inf\" in obj . lower ( ) . strip ( ) : return obj try : return int ( obj ) except ValueError : try : return float ( obj ) except ValueError : return obj", "docstring_tokens": "Convert to float if object is a float string .", "label": 1}, {"idx": "cosqa-train-7141", "doc": "python matplotlib save svg figure", "code": "def fig2x(figure, format):\n    \"\"\"Returns svg from matplotlib chart\"\"\"\n\n    # Save svg to file like object svg_io\n    io = StringIO()\n    figure.savefig(io, format=format)\n\n    # Rewind the file like object\n    io.seek(0)\n\n    data = io.getvalue()\n    io.close()\n\n    return data", "code_tokens": "def fig2x ( figure , format ) : # Save svg to file like object svg_io io = StringIO ( ) figure . savefig ( io , format = format ) # Rewind the file like object io . seek ( 0 ) data = io . getvalue ( ) io . close ( ) return data", "docstring_tokens": "Returns svg from matplotlib chart", "label": 0}, {"idx": "cosqa-train-7142", "doc": "how to cast an object as a float python", "code": "def _tofloat(obj):\n    \"\"\"Convert to float if object is a float string.\"\"\"\n    if \"inf\" in obj.lower().strip():\n        return obj\n    try:\n        return int(obj)\n    except ValueError:\n        try:\n            return float(obj)\n        except ValueError:\n            return obj", "code_tokens": "def _tofloat ( obj ) : if \"inf\" in obj . lower ( ) . strip ( ) : return obj try : return int ( obj ) except ValueError : try : return float ( obj ) except ValueError : return obj", "docstring_tokens": "Convert to float if object is a float string .", "label": 1}, {"idx": "cosqa-train-7143", "doc": "python matplotlib set scale to auto", "code": "def set_scale(self, scale, no_reset=False):\n        \"\"\"Scale the image in a channel.\n        Also see :meth:`zoom_to`.\n\n        Parameters\n        ----------\n        scale : tuple of float\n            Scaling factors for the image in the X and Y axes.\n\n        no_reset : bool\n            Do not reset ``autozoom`` setting.\n\n        \"\"\"\n        return self.scale_to(*scale[:2], no_reset=no_reset)", "code_tokens": "def set_scale ( self , scale , no_reset = False ) : return self . scale_to ( * scale [ : 2 ] , no_reset = no_reset )", "docstring_tokens": "Scale the image in a channel . Also see : meth : zoom_to .", "label": 0}, {"idx": "cosqa-train-7144", "doc": "how to center align text in python 3", "code": "def center_text(text, width=80):\n    \"\"\"Center all lines of the text.\n\n    It is assumed that all lines width is smaller then B{width}, because the\n    line width will not be checked.\n\n    Args:\n        text (str): Text to wrap.\n        width (int): Maximum number of characters per line.\n\n    Returns:\n        str: Centered text.\n    \"\"\"\n    centered = []\n    for line in text.splitlines():\n        centered.append(line.center(width))\n    return \"\\n\".join(centered)", "code_tokens": "def center_text ( text , width = 80 ) : centered = [ ] for line in text . splitlines ( ) : centered . append ( line . center ( width ) ) return \"\\n\" . join ( centered )", "docstring_tokens": "Center all lines of the text . It is assumed that all lines width is smaller then B { width } because the line width will not be checked . Args : text ( str ) : Text to wrap . width ( int ) : Maximum number of characters per line . Returns : str : Centered text .", "label": 1}, {"idx": "cosqa-train-7145", "doc": "python matplotlib set xlim", "code": "def set_xlimits(self, row, column, min=None, max=None):\n        \"\"\"Set x-axis limits of a subplot.\n\n        :param row,column: specify the subplot.\n        :param min: minimal axis value\n        :param max: maximum axis value\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_xlimits(min, max)", "code_tokens": "def set_xlimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_xlimits ( min , max )", "docstring_tokens": "Set x - axis limits of a subplot .", "label": 1}, {"idx": "cosqa-train-7146", "doc": "how to change an list into a tuple in python", "code": "def as_tuple(self, value):\n        \"\"\"Utility function which converts lists to tuples.\"\"\"\n        if isinstance(value, list):\n            value = tuple(value)\n        return value", "code_tokens": "def as_tuple ( self , value ) : if isinstance ( value , list ) : value = tuple ( value ) return value", "docstring_tokens": "Utility function which converts lists to tuples .", "label": 1}, {"idx": "cosqa-train-7147", "doc": "python matplotlib wrap latex string", "code": "def print_display_png(o):\n    \"\"\"\n    A function to display sympy expression using display style LaTeX in PNG.\n    \"\"\"\n    s = latex(o, mode='plain')\n    s = s.strip('$')\n    # As matplotlib does not support display style, dvipng backend is\n    # used here.\n    png = latex_to_png('$$%s$$' % s, backend='dvipng')\n    return png", "code_tokens": "def print_display_png ( o ) : s = latex ( o , mode = 'plain' ) s = s . strip ( '$' ) # As matplotlib does not support display style, dvipng backend is # used here. png = latex_to_png ( '$$%s$$' % s , backend = 'dvipng' ) return png", "docstring_tokens": "A function to display sympy expression using display style LaTeX in PNG .", "label": 1}, {"idx": "cosqa-train-7148", "doc": "how to change array of strings to list of strings in python", "code": "def flatten_list(l):\n    \"\"\" Nested lists to single-level list, does not split strings\"\"\"\n    return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "code_tokens": "def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )", "docstring_tokens": "Nested lists to single - level list does not split strings", "label": 1}, {"idx": "cosqa-train-7149", "doc": "python matrix 3d rotation", "code": "def R_rot_3d(th):\n    \"\"\"Return a 3-dimensional rotation matrix.\n\n    Parameters\n    ----------\n    th: array, shape (n, 3)\n        Angles about which to rotate along each axis.\n\n    Returns\n    -------\n    R: array, shape (n, 3, 3)\n    \"\"\"\n    sx, sy, sz = np.sin(th).T\n    cx, cy, cz = np.cos(th).T\n    R = np.empty((len(th), 3, 3), dtype=np.float)\n\n    R[:, 0, 0] = cy * cz\n    R[:, 0, 1] = -cy * sz\n    R[:, 0, 2] = sy\n\n    R[:, 1, 0] = sx * sy * cz + cx * sz\n    R[:, 1, 1] = -sx * sy * sz + cx * cz\n    R[:, 1, 2] = -sx * cy\n\n    R[:, 2, 0] = -cx * sy * cz + sx * sz\n    R[:, 2, 1] = cx * sy * sz + sx * cz\n    R[:, 2, 2] = cx * cy\n    return R", "code_tokens": "def R_rot_3d ( th ) : sx , sy , sz = np . sin ( th ) . T cx , cy , cz = np . cos ( th ) . T R = np . empty ( ( len ( th ) , 3 , 3 ) , dtype = np . float ) R [ : , 0 , 0 ] = cy * cz R [ : , 0 , 1 ] = - cy * sz R [ : , 0 , 2 ] = sy R [ : , 1 , 0 ] = sx * sy * cz + cx * sz R [ : , 1 , 1 ] = - sx * sy * sz + cx * cz R [ : , 1 , 2 ] = - sx * cy R [ : , 2 , 0 ] = - cx * sy * cz + sx * sz R [ : , 2 , 1 ] = cx * sy * sz + sx * cz R [ : , 2 , 2 ] = cx * cy return R", "docstring_tokens": "Return a 3 - dimensional rotation matrix .", "label": 1}, {"idx": "cosqa-train-7150", "doc": "how to change colour sys python", "code": "def set_color(self, fg=None, bg=None, intensify=False, target=sys.stdout):\n        \"\"\"Set foreground- and background colors and intensity.\"\"\"\n        raise NotImplementedError", "code_tokens": "def set_color ( self , fg = None , bg = None , intensify = False , target = sys . stdout ) : raise NotImplementedError", "docstring_tokens": "Set foreground - and background colors and intensity .", "label": 1}, {"idx": "cosqa-train-7151", "doc": "python max to return 0 if list is empty", "code": "def _heappop_max(heap):\n    \"\"\"Maxheap version of a heappop.\"\"\"\n    lastelt = heap.pop()    # raises appropriate IndexError if heap is empty\n    if heap:\n        returnitem = heap[0]\n        heap[0] = lastelt\n        _siftup_max(heap, 0)\n        return returnitem\n    return lastelt", "code_tokens": "def _heappop_max ( heap ) : lastelt = heap . pop ( ) # raises appropriate IndexError if heap is empty if heap : returnitem = heap [ 0 ] heap [ 0 ] = lastelt _siftup_max ( heap , 0 ) return returnitem return lastelt", "docstring_tokens": "Maxheap version of a heappop .", "label": 0}, {"idx": "cosqa-train-7152", "doc": "python memory leak if thread join not called", "code": "def join(self):\n\t\t\"\"\"Note that the Executor must be close()'d elsewhere,\n\t\tor join() will never return.\n\t\t\"\"\"\n\t\tself.inputfeeder_thread.join()\n\t\tself.pool.join()\n\t\tself.resulttracker_thread.join()\n\t\tself.failuretracker_thread.join()", "code_tokens": "def join ( self ) : self . inputfeeder_thread . join ( ) self . pool . join ( ) self . resulttracker_thread . join ( ) self . failuretracker_thread . join ( )", "docstring_tokens": "Note that the Executor must be close () d elsewhere or join () will never return .", "label": 1}, {"idx": "cosqa-train-7153", "doc": "how to change file modified date in python", "code": "def set_time(filename, mod_time):\n\t\"\"\"\n\tSet the modified time of a file\n\t\"\"\"\n\tlog.debug('Setting modified time to %s', mod_time)\n\tmtime = calendar.timegm(mod_time.utctimetuple())\n\t# utctimetuple discards microseconds, so restore it (for consistency)\n\tmtime += mod_time.microsecond / 1000000\n\tatime = os.stat(filename).st_atime\n\tos.utime(filename, (atime, mtime))", "code_tokens": "def set_time ( filename , mod_time ) : log . debug ( 'Setting modified time to %s' , mod_time ) mtime = calendar . timegm ( mod_time . utctimetuple ( ) ) # utctimetuple discards microseconds, so restore it (for consistency)\n mtime += mod_time . microsecond / 1000000 atime = os . stat ( filename ) . st_atime os . utime ( filename , ( atime , mtime ) )", "docstring_tokens": "Set the modified time of a file", "label": 1}, {"idx": "cosqa-train-7154", "doc": "python memory usage for a function", "code": "def m(name='', **kwargs):\n    \"\"\"\n    Print out memory usage at this point in time\n\n    http://docs.python.org/2/library/resource.html\n    http://stackoverflow.com/a/15448600/5006\n    http://stackoverflow.com/questions/110259/which-python-memory-profiler-is-recommended\n    \"\"\"\n    with Reflect.context(**kwargs) as r:\n        kwargs[\"name\"] = name\n        instance = M_CLASS(r, stream, **kwargs)\n        instance()", "code_tokens": "def m ( name = '' , * * kwargs ) : with Reflect . context ( * * kwargs ) as r : kwargs [ \"name\" ] = name instance = M_CLASS ( r , stream , * * kwargs ) instance ( )", "docstring_tokens": "Print out memory usage at this point in time", "label": 1}, {"idx": "cosqa-train-7155", "doc": "how to change int values to time datatype in python", "code": "def dt_to_ts(value):\n    \"\"\" If value is a datetime, convert to timestamp \"\"\"\n    if not isinstance(value, datetime):\n        return value\n    return calendar.timegm(value.utctimetuple()) + value.microsecond / 1000000.0", "code_tokens": "def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0", "docstring_tokens": "If value is a datetime convert to timestamp", "label": 1}, {"idx": "cosqa-train-7156", "doc": "python merge dict nest", "code": "def nested_update(d, u):\n    \"\"\"Merge two nested dicts.\n\n    Nested dicts are sometimes used for representing various recursive structures. When\n    updating such a structure, it may be convenient to present the updated data as a\n    corresponding recursive structure. This function will then apply the update.\n\n    Args:\n      d: dict\n        dict that will be updated in-place. May or may not contain nested dicts.\n\n      u: dict\n        dict with contents that will be merged into ``d``. May or may not contain\n        nested dicts.\n\n    \"\"\"\n    for k, v in list(u.items()):\n        if isinstance(v, collections.Mapping):\n            r = nested_update(d.get(k, {}), v)\n            d[k] = r\n        else:\n            d[k] = u[k]\n    return d", "code_tokens": "def nested_update ( d , u ) : for k , v in list ( u . items ( ) ) : if isinstance ( v , collections . Mapping ) : r = nested_update ( d . get ( k , { } ) , v ) d [ k ] = r else : d [ k ] = u [ k ] return d", "docstring_tokens": "Merge two nested dicts .", "label": 0}, {"idx": "cosqa-train-7157", "doc": "how to change list type python", "code": "def flatten(l, types=(list, float)):\n    \"\"\"\n    Flat nested list of lists into a single list.\n    \"\"\"\n    l = [item if isinstance(item, types) else [item] for item in l]\n    return [item for sublist in l for item in sublist]", "code_tokens": "def flatten ( l , types = ( list , float ) ) : l = [ item if isinstance ( item , types ) else [ item ] for item in l ] return [ item for sublist in l for item in sublist ]", "docstring_tokens": "Flat nested list of lists into a single list .", "label": 0}, {"idx": "cosqa-train-7158", "doc": "python method objects by name", "code": "def FindMethodByName(self, name):\n    \"\"\"Searches for the specified method, and returns its descriptor.\"\"\"\n    for method in self.methods:\n      if name == method.name:\n        return method\n    return None", "code_tokens": "def FindMethodByName ( self , name ) : for method in self . methods : if name == method . name : return method return None", "docstring_tokens": "Searches for the specified method and returns its descriptor .", "label": 1}, {"idx": "cosqa-train-7159", "doc": "how to change string to date formate python", "code": "def std_datestr(self, datestr):\n        \"\"\"Reformat a date string to standard format.\n        \"\"\"\n        return date.strftime(\n                self.str2date(datestr), self.std_dateformat)", "code_tokens": "def std_datestr ( self , datestr ) : return date . strftime ( self . str2date ( datestr ) , self . std_dateformat )", "docstring_tokens": "Reformat a date string to standard format .", "label": 1}, {"idx": "cosqa-train-7160", "doc": "python milliseconds delta time to float", "code": "def datetime_delta_to_ms(delta):\n    \"\"\"\n    Given a datetime.timedelta object, return the delta in milliseconds\n    \"\"\"\n    delta_ms = delta.days * 24 * 60 * 60 * 1000\n    delta_ms += delta.seconds * 1000\n    delta_ms += delta.microseconds / 1000\n    delta_ms = int(delta_ms)\n    return delta_ms", "code_tokens": "def datetime_delta_to_ms ( delta ) : delta_ms = delta . days * 24 * 60 * 60 * 1000 delta_ms += delta . seconds * 1000 delta_ms += delta . microseconds / 1000 delta_ms = int ( delta_ms ) return delta_ms", "docstring_tokens": "Given a datetime . timedelta object return the delta in milliseconds", "label": 1}, {"idx": "cosqa-train-7161", "doc": "how to change string to object in python", "code": "def from_string(cls, s):\n        \"\"\"Return a `Status` instance from its string representation.\"\"\"\n        for num, text in cls._STATUS2STR.items():\n            if text == s:\n                return cls(num)\n        else:\n            raise ValueError(\"Wrong string %s\" % s)", "code_tokens": "def from_string ( cls , s ) : for num , text in cls . _STATUS2STR . items ( ) : if text == s : return cls ( num ) else : raise ValueError ( \"Wrong string %s\" % s )", "docstring_tokens": "Return a Status instance from its string representation .", "label": 0}, {"idx": "cosqa-train-7162", "doc": "python minidom node element getattribute", "code": "def _get_minidom_tag_value(station, tag_name):\n    \"\"\"get a value from a tag (if it exists)\"\"\"\n    tag = station.getElementsByTagName(tag_name)[0].firstChild\n    if tag:\n        return tag.nodeValue\n\n    return None", "code_tokens": "def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None", "docstring_tokens": "get a value from a tag ( if it exists )", "label": 0}, {"idx": "cosqa-train-7163", "doc": "how to change the attribute of an object python", "code": "def populate_obj(obj, attrs):\n    \"\"\"Populates an object's attributes using the provided dict\n    \"\"\"\n    for k, v in attrs.iteritems():\n        setattr(obj, k, v)", "code_tokens": "def populate_obj ( obj , attrs ) : for k , v in attrs . iteritems ( ) : setattr ( obj , k , v )", "docstring_tokens": "Populates an object s attributes using the provided dict", "label": 0}, {"idx": "cosqa-train-7164", "doc": "python mix**kwargs with default value kwargs", "code": "def update(self, dictionary=None, **kwargs):\n        \"\"\"\n        Adds/overwrites all the keys and values from the dictionary.\n        \"\"\"\n        if not dictionary == None: kwargs.update(dictionary)\n        for k in list(kwargs.keys()): self[k] = kwargs[k]", "code_tokens": "def update ( self , dictionary = None , * * kwargs ) : if not dictionary == None : kwargs . update ( dictionary ) for k in list ( kwargs . keys ( ) ) : self [ k ] = kwargs [ k ]", "docstring_tokens": "Adds / overwrites all the keys and values from the dictionary .", "label": 1}, {"idx": "cosqa-train-7165", "doc": "how to change the axis range in a plot in python for subplots", "code": "def set_xlimits(self, row, column, min=None, max=None):\n        \"\"\"Set x-axis limits of a subplot.\n\n        :param row,column: specify the subplot.\n        :param min: minimal axis value\n        :param max: maximum axis value\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_xlimits(min, max)", "code_tokens": "def set_xlimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_xlimits ( min , max )", "docstring_tokens": "Set x - axis limits of a subplot .", "label": 1}, {"idx": "cosqa-train-7166", "doc": "python mongo concatenate value in update", "code": "def update_one(self, query, doc):\n        \"\"\"\n        Updates one element of the collection\n\n        :param query: dictionary representing the mongo query\n        :param doc: dictionary representing the item to be updated\n        :return: UpdateResult\n        \"\"\"\n        if self.table is None:\n            self.build_table()\n\n        if u\"$set\" in doc:\n            doc = doc[u\"$set\"]\n\n        allcond = self.parse_query(query)\n\n        try:\n            result = self.table.update(doc, allcond)\n        except:\n            # TODO: check table.update result\n            # check what pymongo does in that case\n            result = None\n\n        return UpdateResult(raw_result=result)", "code_tokens": "def update_one ( self , query , doc ) : if self . table is None : self . build_table ( ) if u\"$set\" in doc : doc = doc [ u\"$set\" ] allcond = self . parse_query ( query ) try : result = self . table . update ( doc , allcond ) except : # TODO: check table.update result # check what pymongo does in that case result = None return UpdateResult ( raw_result = result )", "docstring_tokens": "Updates one element of the collection", "label": 1}, {"idx": "cosqa-train-7167", "doc": "how to change the name of a key in python", "code": "def unit_key_from_name(name):\n  \"\"\"Return a legal python name for the given name for use as a unit key.\"\"\"\n  result = name\n\n  for old, new in six.iteritems(UNIT_KEY_REPLACEMENTS):\n    result = result.replace(old, new)\n\n  # Collapse redundant underscores and convert to uppercase.\n  result = re.sub(r'_+', '_', result.upper())\n\n  return result", "code_tokens": "def unit_key_from_name ( name ) : result = name for old , new in six . iteritems ( UNIT_KEY_REPLACEMENTS ) : result = result . replace ( old , new ) # Collapse redundant underscores and convert to uppercase. result = re . sub ( r'_+' , '_' , result . upper ( ) ) return result", "docstring_tokens": "Return a legal python name for the given name for use as a unit key .", "label": 1}, {"idx": "cosqa-train-7168", "doc": "python mongo db cursor to json", "code": "def _obj_cursor_to_dictionary(self, cursor):\n        \"\"\"Handle conversion of pymongo cursor into a JSON object formatted for UI consumption\n\n        :param dict cursor: a mongo document that should be converted to primitive types for the client code\n        :returns: a primitive dictionary\n        :rtype: dict\n        \"\"\"\n        if not cursor:\n            return cursor\n\n        cursor = json.loads(json.dumps(cursor, cls=BSONEncoder))\n\n        if cursor.get(\"_id\"):\n            cursor[\"id\"] = cursor.get(\"_id\")\n            del cursor[\"_id\"]\n\n        return cursor", "code_tokens": "def _obj_cursor_to_dictionary ( self , cursor ) : if not cursor : return cursor cursor = json . loads ( json . dumps ( cursor , cls = BSONEncoder ) ) if cursor . get ( \"_id\" ) : cursor [ \"id\" ] = cursor . get ( \"_id\" ) del cursor [ \"_id\" ] return cursor", "docstring_tokens": "Handle conversion of pymongo cursor into a JSON object formatted for UI consumption", "label": 0}, {"idx": "cosqa-train-7169", "doc": "how to change the strings to float in python", "code": "def comma_converter(float_string):\n    \"\"\"Convert numbers to floats whether the decimal point is '.' or ','\"\"\"\n    trans_table = maketrans(b',', b'.')\n    return float(float_string.translate(trans_table))", "code_tokens": "def comma_converter ( float_string ) : trans_table = maketrans ( b',' , b'.' ) return float ( float_string . translate ( trans_table ) )", "docstring_tokens": "Convert numbers to floats whether the decimal point is . or", "label": 1}, {"idx": "cosqa-train-7170", "doc": "python mongo engine connect default database not set", "code": "def create_cursor(self, name=None):\n        \"\"\"\n        Returns an active connection cursor to the database.\n        \"\"\"\n        return Cursor(self.client_connection, self.connection, self.djongo_connection)", "code_tokens": "def create_cursor ( self , name = None ) : return Cursor ( self . client_connection , self . connection , self . djongo_connection )", "docstring_tokens": "Returns an active connection cursor to the database .", "label": 0}, {"idx": "cosqa-train-7171", "doc": "how to change the type of a column from series into list in python", "code": "def _possibly_convert_objects(values):\n    \"\"\"Convert arrays of datetime.datetime and datetime.timedelta objects into\n    datetime64 and timedelta64, according to the pandas convention.\n    \"\"\"\n    return np.asarray(pd.Series(values.ravel())).reshape(values.shape)", "code_tokens": "def _possibly_convert_objects ( values ) : return np . asarray ( pd . Series ( values . ravel ( ) ) ) . reshape ( values . shape )", "docstring_tokens": "Convert arrays of datetime . datetime and datetime . timedelta objects into datetime64 and timedelta64 according to the pandas convention .", "label": 0}, {"idx": "cosqa-train-7172", "doc": "python mouse left button", "code": "def onLeftDown(self, event=None):\n        \"\"\" left button down: report x,y coords, start zooming mode\"\"\"\n        if event is None:\n            return\n        self.cursor_mode_action('leftdown', event=event)\n        self.ForwardEvent(event=event.guiEvent)", "code_tokens": "def onLeftDown ( self , event = None ) : if event is None : return self . cursor_mode_action ( 'leftdown' , event = event ) self . ForwardEvent ( event = event . guiEvent )", "docstring_tokens": "left button down : report x y coords start zooming mode", "label": 1}, {"idx": "cosqa-train-7173", "doc": "how to check a variable consistently in python", "code": "def is_valid_variable_name(string_to_check):\n    \"\"\"\n    Returns whether the provided name is a valid variable name in Python\n\n    :param string_to_check: the string to be checked\n    :return: True or False\n    \"\"\"\n\n    try:\n\n        parse('{} = None'.format(string_to_check))\n        return True\n\n    except (SyntaxError, ValueError, TypeError):\n\n        return False", "code_tokens": "def is_valid_variable_name ( string_to_check ) : try : parse ( '{} = None' . format ( string_to_check ) ) return True except ( SyntaxError , ValueError , TypeError ) : return False", "docstring_tokens": "Returns whether the provided name is a valid variable name in Python", "label": 0}, {"idx": "cosqa-train-7174", "doc": "python move down a line without ruhnning code", "code": "def move_up(lines=1, file=sys.stdout):\n    \"\"\" Move the cursor up a number of lines.\n\n        Esc[ValueA:\n        Moves the cursor up by the specified number of lines without changing\n        columns. If the cursor is already on the top line, ANSI.SYS ignores\n        this sequence.\n    \"\"\"\n    move.up(lines).write(file=file)", "code_tokens": "def move_up ( lines = 1 , file = sys . stdout ) : move . up ( lines ) . write ( file = file )", "docstring_tokens": "Move the cursor up a number of lines .", "label": 0}, {"idx": "cosqa-train-7175", "doc": "how to check collection type in python", "code": "def is_collection(obj):\n    \"\"\"Tests if an object is a collection.\"\"\"\n\n    col = getattr(obj, '__getitem__', False)\n    val = False if (not col) else True\n\n    if isinstance(obj, basestring):\n        val = False\n\n    return val", "code_tokens": "def is_collection ( obj ) : col = getattr ( obj , '__getitem__' , False ) val = False if ( not col ) else True if isinstance ( obj , basestring ) : val = False return val", "docstring_tokens": "Tests if an object is a collection .", "label": 1}, {"idx": "cosqa-train-7176", "doc": "python mplot3d axes3d enlarge", "code": "def plot3d_init(fignum):\n    \"\"\"\n    initializes 3D plot\n    \"\"\"\n    from mpl_toolkits.mplot3d import Axes3D\n    fig = plt.figure(fignum)\n    ax = fig.add_subplot(111, projection='3d')\n    return ax", "code_tokens": "def plot3d_init ( fignum ) : from mpl_toolkits . mplot3d import Axes3D fig = plt . figure ( fignum ) ax = fig . add_subplot ( 111 , projection = '3d' ) return ax", "docstring_tokens": "initializes 3D plot", "label": 1}, {"idx": "cosqa-train-7177", "doc": "how to check for eof in python", "code": "def eof(fd):\n    \"\"\"Determine if end-of-file is reached for file fd.\"\"\"\n    b = fd.read(1)\n    end = len(b) == 0\n    if not end:\n        curpos = fd.tell()\n        fd.seek(curpos - 1)\n    return end", "code_tokens": "def eof ( fd ) : b = fd . read ( 1 ) end = len ( b ) == 0 if not end : curpos = fd . tell ( ) fd . seek ( curpos - 1 ) return end", "docstring_tokens": "Determine if end - of - file is reached for file fd .", "label": 1}, {"idx": "cosqa-train-7178", "doc": "python multiprocessing 100k lines file", "code": "def apply(self, func, workers=1, job_size=10000):\n    \"\"\"Apply `func` to lines of text in parallel or sequential.\n\n    Args:\n      func : a function that takes a list of lines.\n    \"\"\"\n    if workers == 1:\n      for lines in self.iter_chunks(job_size):\n        yield func(lines)\n    else:\n      with ProcessPoolExecutor(max_workers=workers) as executor:\n        for result in executor.map(func, self.iter_chunks(job_size)):\n          yield result", "code_tokens": "def apply ( self , func , workers = 1 , job_size = 10000 ) : if workers == 1 : for lines in self . iter_chunks ( job_size ) : yield func ( lines ) else : with ProcessPoolExecutor ( max_workers = workers ) as executor : for result in executor . map ( func , self . iter_chunks ( job_size ) ) : yield result", "docstring_tokens": "Apply func to lines of text in parallel or sequential .", "label": 0}, {"idx": "cosqa-train-7179", "doc": "how to check for valid url in python", "code": "def is_valid_url(url):\n    \"\"\"Checks if a given string is an url\"\"\"\n    pieces = urlparse(url)\n    return all([pieces.scheme, pieces.netloc])", "code_tokens": "def is_valid_url ( url ) : pieces = urlparse ( url ) return all ( [ pieces . scheme , pieces . netloc ] )", "docstring_tokens": "Checks if a given string is an url", "label": 1}, {"idx": "cosqa-train-7180", "doc": "python multiprocessing how to take only one iterable out of many", "code": "def multiprocess_mapping(func, iterable):\n    \"\"\"Multiprocess mapping the given function on the given iterable.\n\n    This only works in Linux and Mac systems since Windows has no forking capability. On Windows we fall back on\n    single processing. Also, if we reach memory limits we fall back on single cpu processing.\n\n    Args:\n        func (func): the function to apply\n        iterable (iterable): the iterable with the elements we want to apply the function on\n    \"\"\"\n    if os.name == 'nt':  # In Windows there is no fork.\n        return list(map(func, iterable))\n    try:\n        p = multiprocessing.Pool()\n        return_data = list(p.imap(func, iterable))\n        p.close()\n        p.join()\n        return return_data\n    except OSError:\n        return list(map(func, iterable))", "code_tokens": "def multiprocess_mapping ( func , iterable ) : if os . name == 'nt' : # In Windows there is no fork. return list ( map ( func , iterable ) ) try : p = multiprocessing . Pool ( ) return_data = list ( p . imap ( func , iterable ) ) p . close ( ) p . join ( ) return return_data except OSError : return list ( map ( func , iterable ) )", "docstring_tokens": "Multiprocess mapping the given function on the given iterable .", "label": 1}, {"idx": "cosqa-train-7181", "doc": "how to check gzip compression using python", "code": "def is_gzipped_fastq(file_name):\n    \"\"\"\n    Determine whether indicated file appears to be a gzipped FASTQ.\n\n    :param str file_name: Name/path of file to check as gzipped FASTQ.\n    :return bool: Whether indicated file appears to be in gzipped FASTQ format.\n    \"\"\"\n    _, ext = os.path.splitext(file_name)\n    return file_name.endswith(\".fastq.gz\") or file_name.endswith(\".fq.gz\")", "code_tokens": "def is_gzipped_fastq ( file_name ) : _ , ext = os . path . splitext ( file_name ) return file_name . endswith ( \".fastq.gz\" ) or file_name . endswith ( \".fq.gz\" )", "docstring_tokens": "Determine whether indicated file appears to be a gzipped FASTQ .", "label": 0}, {"idx": "cosqa-train-7182", "doc": "python multiprocessing map imap", "code": "def imapchain(*a, **kwa):\n    \"\"\" Like map but also chains the results. \"\"\"\n\n    imap_results = map( *a, **kwa )\n    return itertools.chain( *imap_results )", "code_tokens": "def imapchain ( * a , * * kwa ) : imap_results = map ( * a , * * kwa ) return itertools . chain ( * imap_results )", "docstring_tokens": "Like map but also chains the results .", "label": 1}, {"idx": "cosqa-train-7183", "doc": "how to check if 2 strings have the same characters python", "code": "def eqstr(a, b):\n    \"\"\"\n    Determine whether two strings are equivalent.\n\n    http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/C/cspice/eqstr_c.html\n\n    :param a: Arbitrary character string.\n    :type a: str\n    :param b: Arbitrary character string.\n    :type b: str\n    :return: True if A and B are equivalent.\n    :rtype: bool\n    \"\"\"\n    return bool(libspice.eqstr_c(stypes.stringToCharP(a), stypes.stringToCharP(b)))", "code_tokens": "def eqstr ( a , b ) : return bool ( libspice . eqstr_c ( stypes . stringToCharP ( a ) , stypes . stringToCharP ( b ) ) )", "docstring_tokens": "Determine whether two strings are equivalent .", "label": 0}, {"idx": "cosqa-train-7184", "doc": "python multiprocessing pool apply args", "code": "def compute(args):\n    x, y, params = args\n    \"\"\"Callable function for the multiprocessing pool.\"\"\"\n    return x, y, mandelbrot(x, y, params)", "code_tokens": "def compute ( args ) : x , y , params = args return x , y , mandelbrot ( x , y , params )", "docstring_tokens": "Callable function for the multiprocessing pool .", "label": 0}, {"idx": "cosqa-train-7185", "doc": "how to check if a field is null in python", "code": "def is_all_field_none(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n\n        if self._type_ is not None:\n            return False\n\n        if self._value is not None:\n            return False\n\n        if self._name is not None:\n            return False\n\n        return True", "code_tokens": "def is_all_field_none ( self ) : if self . _type_ is not None : return False if self . _value is not None : return False if self . _name is not None : return False return True", "docstring_tokens": ": rtype : bool", "label": 1}, {"idx": "cosqa-train-7186", "doc": "python multiprocessing queue dict or list or tuple", "code": "def get(self, queue_get):\n        \"\"\"\n        to get states from multiprocessing.queue\n        \"\"\"\n        if isinstance(queue_get, (tuple, list)):\n            self.result.extend(queue_get)", "code_tokens": "def get ( self , queue_get ) : if isinstance ( queue_get , ( tuple , list ) ) : self . result . extend ( queue_get )", "docstring_tokens": "to get states from multiprocessing . queue", "label": 1}, {"idx": "cosqa-train-7187", "doc": "how to check if a tag is empty is xml python", "code": "def match_empty(self, el):\n        \"\"\"Check if element is empty (if requested).\"\"\"\n\n        is_empty = True\n        for child in self.get_children(el, tags=False):\n            if self.is_tag(child):\n                is_empty = False\n                break\n            elif self.is_content_string(child) and RE_NOT_EMPTY.search(child):\n                is_empty = False\n                break\n        return is_empty", "code_tokens": "def match_empty ( self , el ) : is_empty = True for child in self . get_children ( el , tags = False ) : if self . is_tag ( child ) : is_empty = False break elif self . is_content_string ( child ) and RE_NOT_EMPTY . search ( child ) : is_empty = False break return is_empty", "docstring_tokens": "Check if element is empty ( if requested ) .", "label": 0}, {"idx": "cosqa-train-7188", "doc": "python multiprocessing terminate in cluster", "code": "def cleanup_storage(*args):\n    \"\"\"Clean up processes after SIGTERM or SIGINT is received.\"\"\"\n    ShardedClusters().cleanup()\n    ReplicaSets().cleanup()\n    Servers().cleanup()\n    sys.exit(0)", "code_tokens": "def cleanup_storage ( * args ) : ShardedClusters ( ) . cleanup ( ) ReplicaSets ( ) . cleanup ( ) Servers ( ) . cleanup ( ) sys . exit ( 0 )", "docstring_tokens": "Clean up processes after SIGTERM or SIGINT is received .", "label": 1}, {"idx": "cosqa-train-7189", "doc": "how to check if a value is present in every index in array, python", "code": "def isin(value, values):\n    \"\"\" Check that value is in values \"\"\"\n    for i, v in enumerate(value):\n        if v not in np.array(values)[:, i]:\n            return False\n    return True", "code_tokens": "def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True", "docstring_tokens": "Check that value is in values", "label": 0}, {"idx": "cosqa-train-7190", "doc": "python multirpocessing map with multi params", "code": "def imapchain(*a, **kwa):\n    \"\"\" Like map but also chains the results. \"\"\"\n\n    imap_results = map( *a, **kwa )\n    return itertools.chain( *imap_results )", "code_tokens": "def imapchain ( * a , * * kwa ) : imap_results = map ( * a , * * kwa ) return itertools . chain ( * imap_results )", "docstring_tokens": "Like map but also chains the results .", "label": 1}, {"idx": "cosqa-train-7191", "doc": "how to check if all elements in a list are the same python", "code": "def allsame(list_, strict=True):\n    \"\"\"\n    checks to see if list is equal everywhere\n\n    Args:\n        list_ (list):\n\n    Returns:\n        True if all items in the list are equal\n    \"\"\"\n    if len(list_) == 0:\n        return True\n    first_item = list_[0]\n    return list_all_eq_to(list_, first_item, strict)", "code_tokens": "def allsame ( list_ , strict = True ) : if len ( list_ ) == 0 : return True first_item = list_ [ 0 ] return list_all_eq_to ( list_ , first_item , strict )", "docstring_tokens": "checks to see if list is equal everywhere", "label": 1}, {"idx": "cosqa-train-7192", "doc": "python multivariate normal distribution 3 sigma", "code": "def norm(x, mu, sigma=1.0):\n    \"\"\" Scipy norm function \"\"\"\n    return stats.norm(loc=mu, scale=sigma).pdf(x)", "code_tokens": "def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )", "docstring_tokens": "Scipy norm function", "label": 0}, {"idx": "cosqa-train-7193", "doc": "how to check if all items are same in list in python", "code": "def allsame(list_, strict=True):\n    \"\"\"\n    checks to see if list is equal everywhere\n\n    Args:\n        list_ (list):\n\n    Returns:\n        True if all items in the list are equal\n    \"\"\"\n    if len(list_) == 0:\n        return True\n    first_item = list_[0]\n    return list_all_eq_to(list_, first_item, strict)", "code_tokens": "def allsame ( list_ , strict = True ) : if len ( list_ ) == 0 : return True first_item = list_ [ 0 ] return list_all_eq_to ( list_ , first_item , strict )", "docstring_tokens": "checks to see if list is equal everywhere", "label": 1}, {"idx": "cosqa-train-7194", "doc": "python must construct a qapplication before qwidget", "code": "def get_qapp():\n    \"\"\"Return an instance of QApplication. Creates one if neccessary.\n\n    :returns: a QApplication instance\n    :rtype: QApplication\n    :raises: None\n    \"\"\"\n    global app\n    app = QtGui.QApplication.instance()\n    if app is None:\n        app = QtGui.QApplication([], QtGui.QApplication.GuiClient)\n    return app", "code_tokens": "def get_qapp ( ) : global app app = QtGui . QApplication . instance ( ) if app is None : app = QtGui . QApplication ( [ ] , QtGui . QApplication . GuiClient ) return app", "docstring_tokens": "Return an instance of QApplication . Creates one if neccessary .", "label": 0}, {"idx": "cosqa-train-7195", "doc": "how to check if file doesn't exist in python", "code": "def is_valid_file(parser, arg):\n    \"\"\"Check if arg is a valid file that already exists on the file system.\"\"\"\n    arg = os.path.abspath(arg)\n    if not os.path.exists(arg):\n        parser.error(\"The file %s does not exist!\" % arg)\n    else:\n        return arg", "code_tokens": "def is_valid_file ( parser , arg ) : arg = os . path . abspath ( arg ) if not os . path . exists ( arg ) : parser . error ( \"The file %s does not exist!\" % arg ) else : return arg", "docstring_tokens": "Check if arg is a valid file that already exists on the file system .", "label": 1}, {"idx": "cosqa-train-7196", "doc": "python mysql cursor execute mutli query", "code": "def store_many(self, sql, values):\n        \"\"\"Abstraction over executemany method\"\"\"\n        cursor = self.get_cursor()\n        cursor.executemany(sql, values)\n        self.conn.commit()", "code_tokens": "def store_many ( self , sql , values ) : cursor = self . get_cursor ( ) cursor . executemany ( sql , values ) self . conn . commit ( )", "docstring_tokens": "Abstraction over executemany method", "label": 0}, {"idx": "cosqa-train-7197", "doc": "how to check if file is in folder python", "code": "def contained_in(filename, directory):\n    \"\"\"Test if a file is located within the given directory.\"\"\"\n    filename = os.path.normcase(os.path.abspath(filename))\n    directory = os.path.normcase(os.path.abspath(directory))\n    return os.path.commonprefix([filename, directory]) == directory", "code_tokens": "def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory", "docstring_tokens": "Test if a file is located within the given directory .", "label": 1}, {"idx": "cosqa-train-7198", "doc": "python namedtuple fromt struct", "code": "def unpack(self, s):\n        \"\"\"Parse bytes and return a namedtuple.\"\"\"\n        return self._create(super(NamedStruct, self).unpack(s))", "code_tokens": "def unpack ( self , s ) : return self . _create ( super ( NamedStruct , self ) . unpack ( s ) )", "docstring_tokens": "Parse bytes and return a namedtuple .", "label": 0}, {"idx": "cosqa-train-7199", "doc": "how to check if it is datetime in python", "code": "def is_timestamp(instance):\n    \"\"\"Validates data is a timestamp\"\"\"\n    if not isinstance(instance, (int, str)):\n        return True\n    return datetime.fromtimestamp(int(instance))", "code_tokens": "def is_timestamp ( instance ) : if not isinstance ( instance , ( int , str ) ) : return True return datetime . fromtimestamp ( int ( instance ) )", "docstring_tokens": "Validates data is a timestamp", "label": 0}, {"idx": "cosqa-train-7200", "doc": "python natural log entire array", "code": "def to_distribution_values(self, values):\n        \"\"\"\n        Returns numpy array of natural logarithms of ``values``.\n        \"\"\"\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            # avoid RuntimeWarning: divide by zero encountered in log\n            return numpy.log(values)", "code_tokens": "def to_distribution_values ( self , values ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( \"ignore\" ) # avoid RuntimeWarning: divide by zero encountered in log return numpy . log ( values )", "docstring_tokens": "Returns numpy array of natural logarithms of values .", "label": 1}, {"idx": "cosqa-train-7201", "doc": "how to check if set is subset of another python", "code": "def issubset(self, other):\n        \"\"\"Report whether another set contains this RangeSet.\"\"\"\n        self._binary_sanity_check(other)\n        return set.issubset(self, other)", "code_tokens": "def issubset ( self , other ) : self . _binary_sanity_check ( other ) return set . issubset ( self , other )", "docstring_tokens": "Report whether another set contains this RangeSet .", "label": 0}, {"idx": "cosqa-train-7202", "doc": "python ndarray fast iterate", "code": "def _npiter(arr):\n    \"\"\"Wrapper for iterating numpy array\"\"\"\n    for a in np.nditer(arr, flags=[\"refs_ok\"]):\n        c = a.item()\n        if c is not None:\n            yield c", "code_tokens": "def _npiter ( arr ) : for a in np . nditer ( arr , flags = [ \"refs_ok\" ] ) : c = a . item ( ) if c is not None : yield c", "docstring_tokens": "Wrapper for iterating numpy array", "label": 1}, {"idx": "cosqa-train-7203", "doc": "how to check if value in dictionary python is the lowercased verson of the key", "code": "def __contains__ (self, key):\n        \"\"\"Check lowercase key item.\"\"\"\n        assert isinstance(key, basestring)\n        return dict.__contains__(self, key.lower())", "code_tokens": "def __contains__ ( self , key ) : assert isinstance ( key , basestring ) return dict . __contains__ ( self , key . lower ( ) )", "docstring_tokens": "Check lowercase key item .", "label": 0}, {"idx": "cosqa-train-7204", "doc": "python negating a value", "code": "def __neg__(self):\n        \"\"\"Unary negation\"\"\"\n        return self.__class__(self[0], self._curve.p()-self[1], self._curve)", "code_tokens": "def __neg__ ( self ) : return self . __class__ ( self [ 0 ] , self . _curve . p ( ) - self [ 1 ] , self . _curve )", "docstring_tokens": "Unary negation", "label": 0}, {"idx": "cosqa-train-7205", "doc": "how to check in python if a xml string is correct", "code": "def str_is_well_formed(xml_str):\n    \"\"\"\n  Args:\n    xml_str : str\n      DataONE API XML doc.\n\n  Returns:\n    bool: **True** if XML doc is well formed.\n  \"\"\"\n    try:\n        str_to_etree(xml_str)\n    except xml.etree.ElementTree.ParseError:\n        return False\n    else:\n        return True", "code_tokens": "def str_is_well_formed ( xml_str ) : try : str_to_etree ( xml_str ) except xml . etree . ElementTree . ParseError : return False else : return True", "docstring_tokens": "Args : xml_str : str DataONE API XML doc .", "label": 1}, {"idx": "cosqa-train-7206", "doc": "python nested list flatten out", "code": "def flat_list(lst):\n    \"\"\"This function flatten given nested list.\n    Argument:\n        nested list\n    Returns:\n        flat list\n    \"\"\"\n    if isinstance(lst, list):\n        for item in lst:\n            for i in flat_list(item):\n                yield i\n    else:\n        yield lst", "code_tokens": "def flat_list ( lst ) : if isinstance ( lst , list ) : for item in lst : for i in flat_list ( item ) : yield i else : yield lst", "docstring_tokens": "This function flatten given nested list . Argument : nested list Returns : flat list", "label": 1}, {"idx": "cosqa-train-7207", "doc": "how to check number comes in the power of 2 in python", "code": "def is_power_of_2(num):\n    \"\"\"Return whether `num` is a power of two\"\"\"\n    log = math.log2(num)\n    return int(log) == float(log)", "code_tokens": "def is_power_of_2 ( num ) : log = math . log2 ( num ) return int ( log ) == float ( log )", "docstring_tokens": "Return whether num is a power of two", "label": 1}, {"idx": "cosqa-train-7208", "doc": "python networkx save graph", "code": "def to_dotfile(G: nx.DiGraph, filename: str):\n    \"\"\" Output a networkx graph to a DOT file. \"\"\"\n    A = to_agraph(G)\n    A.write(filename)", "code_tokens": "def to_dotfile ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . write ( filename )", "docstring_tokens": "Output a networkx graph to a DOT file .", "label": 0}, {"idx": "cosqa-train-7209", "doc": "how to check punctuation in string in python3", "code": "def is_punctuation(text):\n    \"\"\"Check if given string is a punctuation\"\"\"\n    return not (text.lower() in config.AVRO_VOWELS or\n                text.lower() in config.AVRO_CONSONANTS)", "code_tokens": "def is_punctuation ( text ) : return not ( text . lower ( ) in config . AVRO_VOWELS or text . lower ( ) in config . AVRO_CONSONANTS )", "docstring_tokens": "Check if given string is a punctuation", "label": 0}, {"idx": "cosqa-train-7210", "doc": "python new line in comment", "code": "def comment (self, s, **args):\n        \"\"\"Write DOT comment.\"\"\"\n        self.write(u\"// \")\n        self.writeln(s=s, **args)", "code_tokens": "def comment ( self , s , * * args ) : self . write ( u\"// \" ) self . writeln ( s = s , * * args )", "docstring_tokens": "Write DOT comment .", "label": 0}, {"idx": "cosqa-train-7211", "doc": "how to check the accuracy of a model in python for continuous values", "code": "def local_accuracy(X_train, y_train, X_test, y_test, attr_test, model_generator, metric, trained_model):\n    \"\"\" The how well do the features plus a constant base rate sum up to the model output.\n    \"\"\"\n\n    X_train, X_test = to_array(X_train, X_test)\n\n    # how many features to mask\n    assert X_train.shape[1] == X_test.shape[1]\n\n    # keep nkeep top features and re-train the model for each test explanation\n    yp_test = trained_model.predict(X_test)\n\n    return metric(yp_test, strip_list(attr_test).sum(1))", "code_tokens": "def local_accuracy ( X_train , y_train , X_test , y_test , attr_test , model_generator , metric , trained_model ) : X_train , X_test = to_array ( X_train , X_test ) # how many features to mask assert X_train . shape [ 1 ] == X_test . shape [ 1 ] # keep nkeep top features and re-train the model for each test explanation yp_test = trained_model . predict ( X_test ) return metric ( yp_test , strip_list ( attr_test ) . sum ( 1 ) )", "docstring_tokens": "The how well do the features plus a constant base rate sum up to the model output .", "label": 0}, {"idx": "cosqa-train-7212", "doc": "how to check the current firectory in python", "code": "def is_readable_dir(path):\n  \"\"\"Returns whether a path names an existing directory we can list and read files from.\"\"\"\n  return os.path.isdir(path) and os.access(path, os.R_OK) and os.access(path, os.X_OK)", "code_tokens": "def is_readable_dir ( path ) : return os . path . isdir ( path ) and os . access ( path , os . R_OK ) and os . access ( path , os . X_OK )", "docstring_tokens": "Returns whether a path names an existing directory we can list and read files from .", "label": 1}, {"idx": "cosqa-train-7213", "doc": "python noise to signam", "code": "def normal_noise(points):\n    \"\"\"Init a noise variable.\"\"\"\n    return np.random.rand(1) * np.random.randn(points, 1) \\\n        + random.sample([2, -2], 1)", "code_tokens": "def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "docstring_tokens": "Init a noise variable .", "label": 0}, {"idx": "cosqa-train-7214", "doc": "how to check whether data is in between a sensible range in python", "code": "def are_in_interval(s, l, r, border = 'included'):\n        \"\"\"\n        Checks whether all number in the sequence s lie inside the interval formed by\n        l and r.\n        \"\"\"\n        return numpy.all([IntensityRangeStandardization.is_in_interval(x, l, r, border) for x in s])", "code_tokens": "def are_in_interval ( s , l , r , border = 'included' ) : return numpy . all ( [ IntensityRangeStandardization . is_in_interval ( x , l , r , border ) for x in s ] )", "docstring_tokens": "Checks whether all number in the sequence s lie inside the interval formed by l and r .", "label": 1}, {"idx": "cosqa-train-7215", "doc": "python non empty line count", "code": "def empty_line_count_at_the_end(self):\n        \"\"\"\n        Return number of empty lines at the end of the document.\n        \"\"\"\n        count = 0\n        for line in self.lines[::-1]:\n            if not line or line.isspace():\n                count += 1\n            else:\n                break\n\n        return count", "code_tokens": "def empty_line_count_at_the_end ( self ) : count = 0 for line in self . lines [ : : - 1 ] : if not line or line . isspace ( ) : count += 1 else : break return count", "docstring_tokens": "Return number of empty lines at the end of the document .", "label": 0}, {"idx": "cosqa-train-7216", "doc": "how to check windows filesystem with python", "code": "def is_unix_like(platform=None):\n    \"\"\"Returns whether the given platform is a Unix-like platform with the usual\n    Unix filesystem. When the parameter is omitted, it defaults to ``sys.platform``\n    \"\"\"\n    platform = platform or sys.platform\n    platform = platform.lower()\n    return platform.startswith(\"linux\") or platform.startswith(\"darwin\") or \\\n            platform.startswith(\"cygwin\")", "code_tokens": "def is_unix_like ( platform = None ) : platform = platform or sys . platform platform = platform . lower ( ) return platform . startswith ( \"linux\" ) or platform . startswith ( \"darwin\" ) or platform . startswith ( \"cygwin\" )", "docstring_tokens": "Returns whether the given platform is a Unix - like platform with the usual Unix filesystem . When the parameter is omitted it defaults to sys . platform", "label": 1}, {"idx": "cosqa-train-7217", "doc": "python non unique list values", "code": "def get_uniques(l):\n    \"\"\" Returns a list with no repeated elements.\n    \"\"\"\n    result = []\n\n    for i in l:\n        if i not in result:\n            result.append(i)\n\n    return result", "code_tokens": "def get_uniques ( l ) : result = [ ] for i in l : if i not in result : result . append ( i ) return result", "docstring_tokens": "Returns a list with no repeated elements .", "label": 1}, {"idx": "cosqa-train-7218", "doc": "how to clear a canvas python", "code": "def _clear(self):\n        \"\"\"\n        Helper that clears the composition.\n        \"\"\"\n        draw = ImageDraw.Draw(self._background_image)\n        draw.rectangle(self._device.bounding_box,\n                       fill=\"black\")\n        del draw", "code_tokens": "def _clear ( self ) : draw = ImageDraw . Draw ( self . _background_image ) draw . rectangle ( self . _device . bounding_box , fill = \"black\" ) del draw", "docstring_tokens": "Helper that clears the composition .", "label": 1}, {"idx": "cosqa-train-7219", "doc": "python nonetype object unsubscriptable", "code": "def listlike(obj):\n    \"\"\"Is an object iterable like a list (and not a string)?\"\"\"\n    \n    return hasattr(obj, \"__iter__\") \\\n    and not issubclass(type(obj), str)\\\n    and not issubclass(type(obj), unicode)", "code_tokens": "def listlike ( obj ) : return hasattr ( obj , \"__iter__\" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )", "docstring_tokens": "Is an object iterable like a list ( and not a string ) ?", "label": 0}, {"idx": "cosqa-train-7220", "doc": "how to clear a field in python", "code": "def forget_coords(self):\n        \"\"\"Forget all loaded coordinates.\"\"\"\n        self.w.ntotal.set_text('0')\n        self.coords_dict.clear()\n        self.redo()", "code_tokens": "def forget_coords ( self ) : self . w . ntotal . set_text ( '0' ) self . coords_dict . clear ( ) self . redo ( )", "docstring_tokens": "Forget all loaded coordinates .", "label": 1}, {"idx": "cosqa-train-7221", "doc": "python normal dist given mu sigma", "code": "def norm(x, mu, sigma=1.0):\n    \"\"\" Scipy norm function \"\"\"\n    return stats.norm(loc=mu, scale=sigma).pdf(x)", "code_tokens": "def norm ( x , mu , sigma = 1.0 ) : return stats . norm ( loc = mu , scale = sigma ) . pdf ( x )", "docstring_tokens": "Scipy norm function", "label": 1}, {"idx": "cosqa-train-7222", "doc": "how to clear canvas in python", "code": "def _clear(self):\n        \"\"\"\n        Helper that clears the composition.\n        \"\"\"\n        draw = ImageDraw.Draw(self._background_image)\n        draw.rectangle(self._device.bounding_box,\n                       fill=\"black\")\n        del draw", "code_tokens": "def _clear ( self ) : draw = ImageDraw . Draw ( self . _background_image ) draw . rectangle ( self . _device . bounding_box , fill = \"black\" ) del draw", "docstring_tokens": "Helper that clears the composition .", "label": 1}, {"idx": "cosqa-train-7223", "doc": "how to clear python canvas", "code": "def _clear(self):\n        \"\"\"\n        Helper that clears the composition.\n        \"\"\"\n        draw = ImageDraw.Draw(self._background_image)\n        draw.rectangle(self._device.bounding_box,\n                       fill=\"black\")\n        del draw", "code_tokens": "def _clear ( self ) : draw = ImageDraw . Draw ( self . _background_image ) draw . rectangle ( self . _device . bounding_box , fill = \"black\" ) del draw", "docstring_tokens": "Helper that clears the composition .", "label": 0}, {"idx": "cosqa-train-7224", "doc": "python normalize by column name", "code": "def normalize(name):\n    \"\"\"Normalize name for the Statsd convention\"\"\"\n\n    # Name should not contain some specials chars (issue #1068)\n    ret = name.replace(':', '')\n    ret = ret.replace('%', '')\n    ret = ret.replace(' ', '_')\n\n    return ret", "code_tokens": "def normalize ( name ) : # Name should not contain some specials chars (issue #1068) ret = name . replace ( ':' , '' ) ret = ret . replace ( '%' , '' ) ret = ret . replace ( ' ' , '_' ) return ret", "docstring_tokens": "Normalize name for the Statsd convention", "label": 0}, {"idx": "cosqa-train-7225", "doc": "how to click on next page python", "code": "def accel_next(self, *args):\n        \"\"\"Callback to go to the next tab. Called by the accel key.\n        \"\"\"\n        if self.get_notebook().get_current_page() + 1 == self.get_notebook().get_n_pages():\n            self.get_notebook().set_current_page(0)\n        else:\n            self.get_notebook().next_page()\n        return True", "code_tokens": "def accel_next ( self , * args ) : if self . get_notebook ( ) . get_current_page ( ) + 1 == self . get_notebook ( ) . get_n_pages ( ) : self . get_notebook ( ) . set_current_page ( 0 ) else : self . get_notebook ( ) . next_page ( ) return True", "docstring_tokens": "Callback to go to the next tab . Called by the accel key .", "label": 1}, {"idx": "cosqa-train-7226", "doc": "python nose run specific test function", "code": "def test(nose_argsuments):\n    \"\"\" Run application tests \"\"\"\n    from nose import run\n\n    params = ['__main__', '-c', 'nose.ini']\n    params.extend(nose_argsuments)\n    run(argv=params)", "code_tokens": "def test ( nose_argsuments ) : from nose import run params = [ '__main__' , '-c' , 'nose.ini' ] params . extend ( nose_argsuments ) run ( argv = params )", "docstring_tokens": "Run application tests", "label": 0}, {"idx": "cosqa-train-7227", "doc": "how to code the similarity between strings in python", "code": "def basic_word_sim(word1, word2):\n    \"\"\"\n    Simple measure of similarity: Number of letters in common / max length\n    \"\"\"\n    return sum([1 for c in word1 if c in word2]) / max(len(word1), len(word2))", "code_tokens": "def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )", "docstring_tokens": "Simple measure of similarity : Number of letters in common / max length", "label": 0}, {"idx": "cosqa-train-7228", "doc": "python not (condition1 and condition2)", "code": "def _not(condition=None, **kwargs):\n    \"\"\"\n    Return the opposite of input condition.\n\n    :param condition: condition to process.\n\n    :result: not condition.\n    :rtype: bool\n    \"\"\"\n\n    result = True\n\n    if condition is not None:\n        result = not run(condition, **kwargs)\n\n    return result", "code_tokens": "def _not ( condition = None , * * kwargs ) : result = True if condition is not None : result = not run ( condition , * * kwargs ) return result", "docstring_tokens": "Return the opposite of input condition .", "label": 1}, {"idx": "cosqa-train-7229", "doc": "how to compare non identical set python", "code": "def isetdiff_flags(list1, list2):\n    \"\"\"\n    move to util_iter\n    \"\"\"\n    set2 = set(list2)\n    return (item not in set2 for item in list1)", "code_tokens": "def isetdiff_flags ( list1 , list2 ) : set2 = set ( list2 ) return ( item not in set2 for item in list1 )", "docstring_tokens": "move to util_iter", "label": 0}, {"idx": "cosqa-train-7230", "doc": "python np array to string", "code": "def _array2cstr(arr):\n    \"\"\" Serializes a numpy array to a compressed base64 string \"\"\"\n    out = StringIO()\n    np.save(out, arr)\n    return b64encode(out.getvalue())", "code_tokens": "def _array2cstr ( arr ) : out = StringIO ( ) np . save ( out , arr ) return b64encode ( out . getvalue ( ) )", "docstring_tokens": "Serializes a numpy array to a compressed base64 string", "label": 1}, {"idx": "cosqa-train-7231", "doc": "how to compile c++ for python", "code": "def cpp_prog_builder(build_context, target):\n    \"\"\"Build a C++ binary executable\"\"\"\n    yprint(build_context.conf, 'Build CppProg', target)\n    workspace_dir = build_context.get_workspace('CppProg', target.name)\n    build_cpp(build_context, target, target.compiler_config, workspace_dir)", "code_tokens": "def cpp_prog_builder ( build_context , target ) : yprint ( build_context . conf , 'Build CppProg' , target ) workspace_dir = build_context . get_workspace ( 'CppProg' , target . name ) build_cpp ( build_context , target , target . compiler_config , workspace_dir )", "docstring_tokens": "Build a C ++ binary executable", "label": 1}, {"idx": "cosqa-train-7232", "doc": "python number of days in given year", "code": "def gday_of_year(self):\n        \"\"\"Return the number of days since January 1 of the given year.\"\"\"\n        return (self.date - dt.date(self.date.year, 1, 1)).days", "code_tokens": "def gday_of_year ( self ) : return ( self . date - dt . date ( self . date . year , 1 , 1 ) ) . days", "docstring_tokens": "Return the number of days since January 1 of the given year .", "label": 1}, {"idx": "cosqa-train-7233", "doc": "how to compress bytes python", "code": "def compressBuffer(buffer):\n    \"\"\"\n    Note that this code compresses into a buffer held in memory, rather\n    than a disk file. This is done through the use of cStringIO.StringIO().\n    \"\"\"\n    # http://jython.xhaus.com/http-compression-in-python-and-jython/\n    zbuf = cStringIO.StringIO()\n    zfile = gzip.GzipFile(mode='wb', fileobj=zbuf, compresslevel=9)\n    zfile.write(buffer)\n    zfile.close()\n    return zbuf.getvalue()", "code_tokens": "def compressBuffer ( buffer ) : # http://jython.xhaus.com/http-compression-in-python-and-jython/ zbuf = cStringIO . StringIO ( ) zfile = gzip . GzipFile ( mode = 'wb' , fileobj = zbuf , compresslevel = 9 ) zfile . write ( buffer ) zfile . close ( ) return zbuf . getvalue ( )", "docstring_tokens": "Note that this code compresses into a buffer held in memory rather than a disk file . This is done through the use of cStringIO . StringIO () .", "label": 0}, {"idx": "cosqa-train-7234", "doc": "python numpy array fix dtype", "code": "def dict_to_numpy_array(d):\n    \"\"\"\n    Convert a dict of 1d array to a numpy recarray\n    \"\"\"\n    return fromarrays(d.values(), np.dtype([(str(k), v.dtype) for k, v in d.items()]))", "code_tokens": "def dict_to_numpy_array ( d ) : return fromarrays ( d . values ( ) , np . dtype ( [ ( str ( k ) , v . dtype ) for k , v in d . items ( ) ] ) )", "docstring_tokens": "Convert a dict of 1d array to a numpy recarray", "label": 1}, {"idx": "cosqa-train-7235", "doc": "how to conduct a delaunay triangulation python", "code": "def computeDelaunayTriangulation(points):\n    \"\"\" Takes a list of point objects (which must have x and y fields).\n        Returns a list of 3-tuples: the indices of the points that form a\n        Delaunay triangle.\n    \"\"\"\n    siteList = SiteList(points)\n    context  = Context()\n    context.triangulate = True\n    voronoi(siteList,context)\n    return context.triangles", "code_tokens": "def computeDelaunayTriangulation ( points ) : siteList = SiteList ( points ) context = Context ( ) context . triangulate = True voronoi ( siteList , context ) return context . triangles", "docstring_tokens": "Takes a list of point objects ( which must have x and y fields ) . Returns a list of 3 - tuples : the indices of the points that form a Delaunay triangle .", "label": 1}, {"idx": "cosqa-train-7236", "doc": "python numpy array from bytes", "code": "def _arrayFromBytes(dataBytes, metadata):\n    \"\"\"Generates and returns a numpy array from raw data bytes.\n\n    :param bytes: raw data bytes as generated by ``numpy.ndarray.tobytes()``\n    :param metadata: a dictionary containing the data type and optionally the\n        shape parameter to reconstruct a ``numpy.array`` from the raw data\n        bytes. ``{\"dtype\": \"float64\", \"shape\": (2, 3)}``\n\n    :returns: ``numpy.array``\n    \"\"\"\n    array = numpy.fromstring(dataBytes, dtype=numpy.typeDict[metadata['dtype']])\n    if 'shape' in metadata:\n        array = array.reshape(metadata['shape'])\n    return array", "code_tokens": "def _arrayFromBytes ( dataBytes , metadata ) : array = numpy . fromstring ( dataBytes , dtype = numpy . typeDict [ metadata [ 'dtype' ] ] ) if 'shape' in metadata : array = array . reshape ( metadata [ 'shape' ] ) return array", "docstring_tokens": "Generates and returns a numpy array from raw data bytes .", "label": 0}, {"idx": "cosqa-train-7237", "doc": "how to connect to aws s3 using url from python", "code": "def parse_s3_url(url):\n    \"\"\"\n    Parses S3 URL.\n\n    Returns bucket (domain) and file (full path).\n    \"\"\"\n    bucket = ''\n    path = ''\n    if url:\n        result = urlparse(url)\n        bucket = result.netloc\n        path = result.path.strip('/')\n    return bucket, path", "code_tokens": "def parse_s3_url ( url ) : bucket = '' path = '' if url : result = urlparse ( url ) bucket = result . netloc path = result . path . strip ( '/' ) return bucket , path", "docstring_tokens": "Parses S3 URL .", "label": 1}, {"idx": "cosqa-train-7238", "doc": "python numpy array from items", "code": "def recarray(self):\n        \"\"\"Returns data as :class:`numpy.recarray`.\"\"\"\n        return numpy.rec.fromrecords(self.records, names=self.names)", "code_tokens": "def recarray ( self ) : return numpy . rec . fromrecords ( self . records , names = self . names )", "docstring_tokens": "Returns data as : class : numpy . recarray .", "label": 1}, {"idx": "cosqa-train-7239", "doc": "how to conver integer to date in python", "code": "def int_to_date(date):\n    \"\"\"\n    Convert an int of form yyyymmdd to a python date object.\n    \"\"\"\n\n    year = date // 10**4\n    month = date % 10**4 // 10**2\n    day = date % 10**2\n\n    return datetime.date(year, month, day)", "code_tokens": "def int_to_date ( date ) : year = date // 10 ** 4 month = date % 10 ** 4 // 10 ** 2 day = date % 10 ** 2 return datetime . date ( year , month , day )", "docstring_tokens": "Convert an int of form yyyymmdd to a python date object .", "label": 1}, {"idx": "cosqa-train-7240", "doc": "python numpy array sort return index", "code": "def argsort_indices(a, axis=-1):\n    \"\"\"Like argsort, but returns an index suitable for sorting the\n    the original array even if that array is multidimensional\n    \"\"\"\n    a = np.asarray(a)\n    ind = list(np.ix_(*[np.arange(d) for d in a.shape]))\n    ind[axis] = a.argsort(axis)\n    return tuple(ind)", "code_tokens": "def argsort_indices ( a , axis = - 1 ) : a = np . asarray ( a ) ind = list ( np . ix_ ( * [ np . arange ( d ) for d in a . shape ] ) ) ind [ axis ] = a . argsort ( axis ) return tuple ( ind )", "docstring_tokens": "Like argsort but returns an index suitable for sorting the the original array even if that array is multidimensional", "label": 0}, {"idx": "cosqa-train-7241", "doc": "how to count as far as memory allows in python", "code": "def _read_stream_for_size(stream, buf_size=65536):\n    \"\"\"Reads a stream discarding the data read and returns its size.\"\"\"\n    size = 0\n    while True:\n        buf = stream.read(buf_size)\n        size += len(buf)\n        if not buf:\n            break\n    return size", "code_tokens": "def _read_stream_for_size ( stream , buf_size = 65536 ) : size = 0 while True : buf = stream . read ( buf_size ) size += len ( buf ) if not buf : break return size", "docstring_tokens": "Reads a stream discarding the data read and returns its size .", "label": 0}, {"idx": "cosqa-train-7242", "doc": "python numpy array store string", "code": "def _numpy_bytes_to_char(arr):\n    \"\"\"Like netCDF4.stringtochar, but faster and more flexible.\n    \"\"\"\n    # ensure the array is contiguous\n    arr = np.array(arr, copy=False, order='C', dtype=np.string_)\n    return arr.reshape(arr.shape + (1,)).view('S1')", "code_tokens": "def _numpy_bytes_to_char ( arr ) : # ensure the array is contiguous arr = np . array ( arr , copy = False , order = 'C' , dtype = np . string_ ) return arr . reshape ( arr . shape + ( 1 , ) ) . view ( 'S1' )", "docstring_tokens": "Like netCDF4 . stringtochar but faster and more flexible .", "label": 0}, {"idx": "cosqa-train-7243", "doc": "how to count the number of objects in python", "code": "def get_size(objects):\n    \"\"\"Compute the total size of all elements in objects.\"\"\"\n    res = 0\n    for o in objects:\n        try:\n            res += _getsizeof(o)\n        except AttributeError:\n            print(\"IGNORING: type=%s; o=%s\" % (str(type(o)), str(o)))\n    return res", "code_tokens": "def get_size ( objects ) : res = 0 for o in objects : try : res += _getsizeof ( o ) except AttributeError : print ( \"IGNORING: type=%s; o=%s\" % ( str ( type ( o ) ) , str ( o ) ) ) return res", "docstring_tokens": "Compute the total size of all elements in objects .", "label": 1}, {"idx": "cosqa-train-7244", "doc": "python numpy average of minimum value in each column of array", "code": "def movingaverage(arr, window):\n    \"\"\"\n    Calculates the moving average (\"rolling mean\") of an array\n    of a certain window size.\n    \"\"\"\n    m = np.ones(int(window)) / int(window)\n    return scipy.ndimage.convolve1d(arr, m, axis=0, mode='reflect')", "code_tokens": "def movingaverage ( arr , window ) : m = np . ones ( int ( window ) ) / int ( window ) return scipy . ndimage . convolve1d ( arr , m , axis = 0 , mode = 'reflect' )", "docstring_tokens": "Calculates the moving average ( rolling mean ) of an array of a certain window size .", "label": 1}, {"idx": "cosqa-train-7245", "doc": "how to covert a string column to a float in python", "code": "def comma_converter(float_string):\n    \"\"\"Convert numbers to floats whether the decimal point is '.' or ','\"\"\"\n    trans_table = maketrans(b',', b'.')\n    return float(float_string.translate(trans_table))", "code_tokens": "def comma_converter ( float_string ) : trans_table = maketrans ( b',' , b'.' ) return float ( float_string . translate ( trans_table ) )", "docstring_tokens": "Convert numbers to floats whether the decimal point is . or", "label": 1}, {"idx": "cosqa-train-7246", "doc": "python numpy fft magnitude", "code": "def log_magnitude_spectrum(frames):\n    \"\"\"Compute the log of the magnitude spectrum of frames\"\"\"\n    return N.log(N.abs(N.fft.rfft(frames)).clip(1e-5, N.inf))", "code_tokens": "def log_magnitude_spectrum ( frames ) : return N . log ( N . abs ( N . fft . rfft ( frames ) ) . clip ( 1e-5 , N . inf ) )", "docstring_tokens": "Compute the log of the magnitude spectrum of frames", "label": 0}, {"idx": "cosqa-train-7247", "doc": "how to create a char array in python ctypes", "code": "def cfloat64_array_to_numpy(cptr, length):\n    \"\"\"Convert a ctypes double pointer array to a numpy array.\"\"\"\n    if isinstance(cptr, ctypes.POINTER(ctypes.c_double)):\n        return np.fromiter(cptr, dtype=np.float64, count=length)\n    else:\n        raise RuntimeError('Expected double pointer')", "code_tokens": "def cfloat64_array_to_numpy ( cptr , length ) : if isinstance ( cptr , ctypes . POINTER ( ctypes . c_double ) ) : return np . fromiter ( cptr , dtype = np . float64 , count = length ) else : raise RuntimeError ( 'Expected double pointer' )", "docstring_tokens": "Convert a ctypes double pointer array to a numpy array .", "label": 1}, {"idx": "cosqa-train-7248", "doc": "python numpy fromfile big endian", "code": "def read_numpy(fd, byte_order, dtype, count):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    return numpy.fromfile(fd, byte_order+dtype[-1], count)", "code_tokens": "def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 1}, {"idx": "cosqa-train-7249", "doc": "how to create a long string from a list python", "code": "def list2string (inlist,delimit=' '):\n    \"\"\"\nConverts a 1D list to a single long string for file output, using\nthe string.join function.\n\nUsage:   list2string (inlist,delimit=' ')\nReturns: the string created from inlist\n\"\"\"\n    stringlist = [makestr(_) for _ in inlist]\n    return string.join(stringlist,delimit)", "code_tokens": "def list2string ( inlist , delimit = ' ' ) : stringlist = [ makestr ( _ ) for _ in inlist ] return string . join ( stringlist , delimit )", "docstring_tokens": "Converts a 1D list to a single long string for file output using the string . join function .", "label": 0}, {"idx": "cosqa-train-7250", "doc": "python numpy how to specify dtype string length 32", "code": "def _isstring(dtype):\n    \"\"\"Given a numpy dtype, determines whether it is a string. Returns True\n    if the dtype is string or unicode.\n    \"\"\"\n    return dtype.type == numpy.unicode_ or dtype.type == numpy.string_", "code_tokens": "def _isstring ( dtype ) : return dtype . type == numpy . unicode_ or dtype . type == numpy . string_", "docstring_tokens": "Given a numpy dtype determines whether it is a string . Returns True if the dtype is string or unicode .", "label": 1}, {"idx": "cosqa-train-7251", "doc": "how to create an exponential distribution not at zero in python", "code": "def Exponential(x, a, tau, y0):\n    \"\"\"Exponential function\n\n    Inputs:\n    -------\n        ``x``: independent variable\n        ``a``: scaling factor\n        ``tau``: time constant\n        ``y0``: additive constant\n\n    Formula:\n    --------\n        ``a*exp(x/tau)+y0``\n    \"\"\"\n    return np.exp(x / tau) * a + y0", "code_tokens": "def Exponential ( x , a , tau , y0 ) : return np . exp ( x / tau ) * a + y0", "docstring_tokens": "Exponential function", "label": 1}, {"idx": "cosqa-train-7252", "doc": "python numpy max axie", "code": "def Max(a, axis, keep_dims):\n    \"\"\"\n    Max reduction op.\n    \"\"\"\n    return np.amax(a, axis=axis if not isinstance(axis, np.ndarray) else tuple(axis),\n                   keepdims=keep_dims),", "code_tokens": "def Max ( a , axis , keep_dims ) : return np . amax ( a , axis = axis if not isinstance ( axis , np . ndarray ) else tuple ( axis ) , keepdims = keep_dims ) ,", "docstring_tokens": "Max reduction op .", "label": 1}, {"idx": "cosqa-train-7253", "doc": "how to create histogram with bin in python", "code": "def inverseHistogram(hist, bin_range):\n    \"\"\"sample data from given histogram and min, max values within range\n\n    Returns:\n        np.array: data that would create the same histogram as given\n    \"\"\"\n    data = hist.astype(float) / np.min(hist[np.nonzero(hist)])\n    new_data = np.empty(shape=np.sum(data, dtype=int))\n    i = 0\n    xvals = np.linspace(bin_range[0], bin_range[1], len(data))\n    for d, x in zip(data, xvals):\n        new_data[i:i + d] = x\n        i += int(d)\n    return new_data", "code_tokens": "def inverseHistogram ( hist , bin_range ) : data = hist . astype ( float ) / np . min ( hist [ np . nonzero ( hist ) ] ) new_data = np . empty ( shape = np . sum ( data , dtype = int ) ) i = 0 xvals = np . linspace ( bin_range [ 0 ] , bin_range [ 1 ] , len ( data ) ) for d , x in zip ( data , xvals ) : new_data [ i : i + d ] = x i += int ( d ) return new_data", "docstring_tokens": "sample data from given histogram and min max values within range", "label": 1}, {"idx": "cosqa-train-7254", "doc": "python numpy read fro file", "code": "def read_numpy(fd, byte_order, dtype, count):\n    \"\"\"Read tag data from file and return as numpy array.\"\"\"\n    return numpy.fromfile(fd, byte_order+dtype[-1], count)", "code_tokens": "def read_numpy ( fd , byte_order , dtype , count ) : return numpy . fromfile ( fd , byte_order + dtype [ - 1 ] , count )", "docstring_tokens": "Read tag data from file and return as numpy array .", "label": 1}, {"idx": "cosqa-train-7255", "doc": "how to create new log in python at run tim", "code": "def setupLogFile(self):\n\t\t\"\"\"Set up the logging file for a new session- include date and some whitespace\"\"\"\n\t\tself.logWrite(\"\\n###############################################\")\n\t\tself.logWrite(\"calcpkg.py log from \" + str(datetime.datetime.now()))\n\t\tself.changeLogging(True)", "code_tokens": "def setupLogFile ( self ) : self . logWrite ( \"\\n###############################################\" ) self . logWrite ( \"calcpkg.py log from \" + str ( datetime . datetime . now ( ) ) ) self . changeLogging ( True )", "docstring_tokens": "Set up the logging file for a new session - include date and some whitespace", "label": 0}, {"idx": "cosqa-train-7256", "doc": "python numpy unit vector", "code": "def normalized(vector):\n    \"\"\"\n    Get unit vector for a given one.\n\n    :param vector:\n        Numpy vector as coordinates in Cartesian space, or an array of such.\n    :returns:\n        Numpy array of the same shape and structure where all vectors are\n        normalized. That is, each coordinate component is divided by its\n        vector's length.\n    \"\"\"\n    length = numpy.sum(vector * vector, axis=-1)\n    length = numpy.sqrt(length.reshape(length.shape + (1, )))\n    return vector / length", "code_tokens": "def normalized ( vector ) : length = numpy . sum ( vector * vector , axis = - 1 ) length = numpy . sqrt ( length . reshape ( length . shape + ( 1 , ) ) ) return vector / length", "docstring_tokens": "Get unit vector for a given one .", "label": 1}, {"idx": "cosqa-train-7257", "doc": "how to create np array from list in python", "code": "def _to_array(value):\n    \"\"\"As a convenience, turn Python lists and tuples into NumPy arrays.\"\"\"\n    if isinstance(value, (tuple, list)):\n        return array(value)\n    elif isinstance(value, (float, int)):\n        return np.float64(value)\n    else:\n        return value", "code_tokens": "def _to_array ( value ) : if isinstance ( value , ( tuple , list ) ) : return array ( value ) elif isinstance ( value , ( float , int ) ) : return np . float64 ( value ) else : return value", "docstring_tokens": "As a convenience turn Python lists and tuples into NumPy arrays .", "label": 0}, {"idx": "cosqa-train-7258", "doc": "python oauth2 get token no auth", "code": "def get_oauth_token():\n    \"\"\"Retrieve a simple OAuth Token for use with the local http client.\"\"\"\n    url = \"{0}/token\".format(DEFAULT_ORIGIN[\"Origin\"])\n    r = s.get(url=url)\n    return r.json()[\"t\"]", "code_tokens": "def get_oauth_token ( ) : url = \"{0}/token\" . format ( DEFAULT_ORIGIN [ \"Origin\" ] ) r = s . get ( url = url ) return r . json ( ) [ \"t\" ]", "docstring_tokens": "Retrieve a simple OAuth Token for use with the local http client .", "label": 0}, {"idx": "cosqa-train-7259", "doc": "python object of type 'int32' is not json serializable", "code": "def Serializable(o):\n    \"\"\"Make sure an object is JSON-serializable\n    Use this to return errors and other info that does not need to be\n    deserialized or does not contain important app data. Best for returning\n    error info and such\"\"\"\n    if isinstance(o, (str, dict, int)):\n        return o\n    else:\n        try:\n            json.dumps(o)\n            return o\n        except Exception:\n            LOG.debug(\"Got a non-serilizeable object: %s\" % o)\n            return o.__repr__()", "code_tokens": "def Serializable ( o ) : if isinstance ( o , ( str , dict , int ) ) : return o else : try : json . dumps ( o ) return o except Exception : LOG . debug ( \"Got a non-serilizeable object: %s\" % o ) return o . __repr__ ( )", "docstring_tokens": "Make sure an object is JSON - serializable Use this to return errors and other info that does not need to be deserialized or does not contain important app data . Best for returning error info and such", "label": 1}, {"idx": "cosqa-train-7260", "doc": "how to deal with kwargs python", "code": "def updateFromKwargs(self, properties, kwargs, collector, **unused):\n        \"\"\"Primary entry point to turn 'kwargs' into 'properties'\"\"\"\n        properties[self.name] = self.getFromKwargs(kwargs)", "code_tokens": "def updateFromKwargs ( self , properties , kwargs , collector , * * unused ) : properties [ self . name ] = self . getFromKwargs ( kwargs )", "docstring_tokens": "Primary entry point to turn kwargs into properties", "label": 1}, {"idx": "cosqa-train-7261", "doc": "python object of type bool has no len list length", "code": "def listlike(obj):\n    \"\"\"Is an object iterable like a list (and not a string)?\"\"\"\n    \n    return hasattr(obj, \"__iter__\") \\\n    and not issubclass(type(obj), str)\\\n    and not issubclass(type(obj), unicode)", "code_tokens": "def listlike ( obj ) : return hasattr ( obj , \"__iter__\" ) and not issubclass ( type ( obj ) , str ) and not issubclass ( type ( obj ) , unicode )", "docstring_tokens": "Is an object iterable like a list ( and not a string ) ?", "label": 0}, {"idx": "cosqa-train-7262", "doc": "python object of type date is not json serializable", "code": "def _time_to_json(value):\n    \"\"\"Coerce 'value' to an JSON-compatible representation.\"\"\"\n    if isinstance(value, datetime.time):\n        value = value.isoformat()\n    return value", "code_tokens": "def _time_to_json ( value ) : if isinstance ( value , datetime . time ) : value = value . isoformat ( ) return value", "docstring_tokens": "Coerce value to an JSON - compatible representation .", "label": 1}, {"idx": "cosqa-train-7263", "doc": "how to define linear regression in python", "code": "def linearRegressionAnalysis(series):\n    \"\"\"\n    Returns factor and offset of linear regression function by least\n    squares method.\n\n    \"\"\"\n    n = safeLen(series)\n    sumI = sum([i for i, v in enumerate(series) if v is not None])\n    sumV = sum([v for i, v in enumerate(series) if v is not None])\n    sumII = sum([i * i for i, v in enumerate(series) if v is not None])\n    sumIV = sum([i * v for i, v in enumerate(series) if v is not None])\n    denominator = float(n * sumII - sumI * sumI)\n    if denominator == 0:\n        return None\n    else:\n        factor = (n * sumIV - sumI * sumV) / denominator / series.step\n        offset = sumII * sumV - sumIV * sumI\n        offset = offset / denominator - factor * series.start\n        return factor, offset", "code_tokens": "def linearRegressionAnalysis ( series ) : n = safeLen ( series ) sumI = sum ( [ i for i , v in enumerate ( series ) if v is not None ] ) sumV = sum ( [ v for i , v in enumerate ( series ) if v is not None ] ) sumII = sum ( [ i * i for i , v in enumerate ( series ) if v is not None ] ) sumIV = sum ( [ i * v for i , v in enumerate ( series ) if v is not None ] ) denominator = float ( n * sumII - sumI * sumI ) if denominator == 0 : return None else : factor = ( n * sumIV - sumI * sumV ) / denominator / series . step offset = sumII * sumV - sumIV * sumI offset = offset / denominator - factor * series . start return factor , offset", "docstring_tokens": "Returns factor and offset of linear regression function by least squares method .", "label": 0}, {"idx": "cosqa-train-7264", "doc": "python object of type textiowrapper is not json serializable", "code": "def json_serial(obj):\n    \"\"\"JSON serializer for objects not serializable by default json code\"\"\"\n    if isinstance(obj, LegipyModel):\n        return obj.to_json()\n    elif isinstance(obj, (datetime.date, datetime.datetime)):\n        return obj.isoformat()\n    raise TypeError(\"Type {0} not serializable\".format(repr(type(obj))))", "code_tokens": "def json_serial ( obj ) : if isinstance ( obj , LegipyModel ) : return obj . to_json ( ) elif isinstance ( obj , ( datetime . date , datetime . datetime ) ) : return obj . isoformat ( ) raise TypeError ( \"Type {0} not serializable\" . format ( repr ( type ( obj ) ) ) )", "docstring_tokens": "JSON serializer for objects not serializable by default json code", "label": 1}, {"idx": "cosqa-train-7265", "doc": "how to delete all elements in a set python", "code": "def unique(seq):\n    \"\"\"Return the unique elements of a collection even if those elements are\n       unhashable and unsortable, like dicts and sets\"\"\"\n    cleaned = []\n    for each in seq:\n        if each not in cleaned:\n            cleaned.append(each)\n    return cleaned", "code_tokens": "def unique ( seq ) : cleaned = [ ] for each in seq : if each not in cleaned : cleaned . append ( each ) return cleaned", "docstring_tokens": "Return the unique elements of a collection even if those elements are unhashable and unsortable like dicts and sets", "label": 1}, {"idx": "cosqa-train-7266", "doc": "python object to json", "code": "def to_json(obj):\n    \"\"\"Return a json string representing the python object obj.\"\"\"\n    i = StringIO.StringIO()\n    w = Writer(i, encoding='UTF-8')\n    w.write_value(obj)\n    return i.getvalue()", "code_tokens": "def to_json ( obj ) : i = StringIO . StringIO ( ) w = Writer ( i , encoding = 'UTF-8' ) w . write_value ( obj ) return i . getvalue ( )", "docstring_tokens": "Return a json string representing the python object obj .", "label": 0}, {"idx": "cosqa-train-7267", "doc": "how to delete index in python", "code": "def delete_index(index):\n    \"\"\"Delete index entirely (removes all documents and mapping).\"\"\"\n    logger.info(\"Deleting search index: '%s'\", index)\n    client = get_client()\n    return client.indices.delete(index=index)", "code_tokens": "def delete_index ( index ) : logger . info ( \"Deleting search index: '%s'\" , index ) client = get_client ( ) return client . indices . delete ( index = index )", "docstring_tokens": "Delete index entirely ( removes all documents and mapping ) .", "label": 0}, {"idx": "cosqa-train-7268", "doc": "python obmit hour seconds in timestamp", "code": "def time2seconds(t):\n    \"\"\"Returns seconds since 0h00.\"\"\"\n    return t.hour * 3600 + t.minute * 60 + t.second + float(t.microsecond) / 1e6", "code_tokens": "def time2seconds ( t ) : return t . hour * 3600 + t . minute * 60 + t . second + float ( t . microsecond ) / 1e6", "docstring_tokens": "Returns seconds since 0h00 .", "label": 1}, {"idx": "cosqa-train-7269", "doc": "how to delete nodes from graphs python", "code": "def clear(self):\n        \"\"\"Remove all nodes and edges from the graph.\n\n        Unlike the regular networkx implementation, this does *not*\n        remove the graph's name. But all the other graph, node, and\n        edge attributes go away.\n\n        \"\"\"\n        self.adj.clear()\n        self.node.clear()\n        self.graph.clear()", "code_tokens": "def clear ( self ) : self . adj . clear ( ) self . node . clear ( ) self . graph . clear ( )", "docstring_tokens": "Remove all nodes and edges from the graph .", "label": 1}, {"idx": "cosqa-train-7270", "doc": "python ols categorical regression", "code": "def fit_linear(X, y):\n    \"\"\"\n    Uses OLS to fit the regression.\n    \"\"\"\n    model = linear_model.LinearRegression()\n    model.fit(X, y)\n    return model", "code_tokens": "def fit_linear ( X , y ) : model = linear_model . LinearRegression ( ) model . fit ( X , y ) return model", "docstring_tokens": "Uses OLS to fit the regression .", "label": 1}, {"idx": "cosqa-train-7271", "doc": "how to detect a palindrome word in python", "code": "def is_palindrome(string, strict=True):\n    \"\"\"\n    Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n    :param string: String to check.\n    :type string: str\n    :param strict: True if white spaces matter (default), false otherwise.\n    :type strict: bool\n    :return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),\n    False otherwise\n    \"\"\"\n    if is_full_string(string):\n        if strict:\n            return reverse(string) == string\n        return is_palindrome(SPACES_RE.sub('', string))\n    return False", "code_tokens": "def is_palindrome ( string , strict = True ) : if is_full_string ( string ) : if strict : return reverse ( string ) == string return is_palindrome ( SPACES_RE . sub ( '' , string ) ) return False", "docstring_tokens": "Checks if the string is a palindrome ( https : // en . wikipedia . org / wiki / Palindrome ) .", "label": 1}, {"idx": "cosqa-train-7272", "doc": "python onehotencoder categorical values into feature", "code": "def to_one_hot(dataY):\n    \"\"\"Convert the vector of labels dataY into one-hot encoding.\n\n    :param dataY: vector of labels\n    :return: one-hot encoded labels\n    \"\"\"\n    nc = 1 + np.max(dataY)\n    onehot = [np.zeros(nc, dtype=np.int8) for _ in dataY]\n    for i, j in enumerate(dataY):\n        onehot[i][j] = 1\n    return onehot", "code_tokens": "def to_one_hot ( dataY ) : nc = 1 + np . max ( dataY ) onehot = [ np . zeros ( nc , dtype = np . int8 ) for _ in dataY ] for i , j in enumerate ( dataY ) : onehot [ i ] [ j ] = 1 return onehot", "docstring_tokens": "Convert the vector of labels dataY into one - hot encoding .", "label": 0}, {"idx": "cosqa-train-7273", "doc": "how to detect a word being a palindrome python", "code": "def is_palindrome(string, strict=True):\n    \"\"\"\n    Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n    :param string: String to check.\n    :type string: str\n    :param strict: True if white spaces matter (default), false otherwise.\n    :type strict: bool\n    :return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),\n    False otherwise\n    \"\"\"\n    if is_full_string(string):\n        if strict:\n            return reverse(string) == string\n        return is_palindrome(SPACES_RE.sub('', string))\n    return False", "code_tokens": "def is_palindrome ( string , strict = True ) : if is_full_string ( string ) : if strict : return reverse ( string ) == string return is_palindrome ( SPACES_RE . sub ( '' , string ) ) return False", "docstring_tokens": "Checks if the string is a palindrome ( https : // en . wikipedia . org / wiki / Palindrome ) .", "label": 0}, {"idx": "cosqa-train-7274", "doc": "python open file with any encoding", "code": "def open_with_encoding(filename, encoding, mode='r'):\n    \"\"\"Return opened file with a specific encoding.\"\"\"\n    return io.open(filename, mode=mode, encoding=encoding,\n                   newline='')", "code_tokens": "def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )", "docstring_tokens": "Return opened file with a specific encoding .", "label": 1}, {"idx": "cosqa-train-7275", "doc": "how to detect the coordinates of the mouse python", "code": "def mouse_get_pos():\n    \"\"\"\n\n    :return:\n    \"\"\"\n    p = POINT()\n    AUTO_IT.AU3_MouseGetPos(ctypes.byref(p))\n    return p.x, p.y", "code_tokens": "def mouse_get_pos ( ) : p = POINT ( ) AUTO_IT . AU3_MouseGetPos ( ctypes . byref ( p ) ) return p . x , p . y", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-7276", "doc": "python opencv image scale down", "code": "def uint8sc(im):\n    \"\"\"Scale the image to uint8\n\n    Parameters:\n    -----------\n    im: 2d array\n        The image\n\n    Returns:\n    --------\n    im: 2d array (dtype uint8)\n        The scaled image to uint8\n    \"\"\"\n    im = np.asarray(im)\n    immin = im.min()\n    immax = im.max()\n    imrange = immax - immin\n    return cv2.convertScaleAbs(im - immin, alpha=255 / imrange)", "code_tokens": "def uint8sc ( im ) : im = np . asarray ( im ) immin = im . min ( ) immax = im . max ( ) imrange = immax - immin return cv2 . convertScaleAbs ( im - immin , alpha = 255 / imrange )", "docstring_tokens": "Scale the image to uint8", "label": 1}, {"idx": "cosqa-train-7277", "doc": "how to detect the encoding of a text file with python", "code": "def get_encoding(binary):\n    \"\"\"Return the encoding type.\"\"\"\n\n    try:\n        from chardet import detect\n    except ImportError:\n        LOGGER.error(\"Please install the 'chardet' module\")\n        sys.exit(1)\n\n    encoding = detect(binary).get('encoding')\n\n    return 'iso-8859-1' if encoding == 'CP949' else encoding", "code_tokens": "def get_encoding ( binary ) : try : from chardet import detect except ImportError : LOGGER . error ( \"Please install the 'chardet' module\" ) sys . exit ( 1 ) encoding = detect ( binary ) . get ( 'encoding' ) return 'iso-8859-1' if encoding == 'CP949' else encoding", "docstring_tokens": "Return the encoding type .", "label": 1}, {"idx": "cosqa-train-7278", "doc": "python optionparser type date", "code": "def Date(value):\n    \"\"\"Custom type for managing dates in the command-line.\"\"\"\n    from datetime import datetime\n    try:\n        return datetime(*reversed([int(val) for val in value.split('/')]))\n    except Exception as err:\n        raise argparse.ArgumentTypeError(\"invalid date '%s'\" % value)", "code_tokens": "def Date ( value ) : from datetime import datetime try : return datetime ( * reversed ( [ int ( val ) for val in value . split ( '/' ) ] ) ) except Exception as err : raise argparse . ArgumentTypeError ( \"invalid date '%s'\" % value )", "docstring_tokens": "Custom type for managing dates in the command - line .", "label": 1}, {"idx": "cosqa-train-7279", "doc": "how to do a column wise normalization in python", "code": "def normalize(X):\n    \"\"\" equivalent to scipy.preprocessing.normalize on sparse matrices\n    , but lets avoid another depedency just for a small utility function \"\"\"\n    X = coo_matrix(X)\n    X.data = X.data / sqrt(bincount(X.row, X.data ** 2))[X.row]\n    return X", "code_tokens": "def normalize ( X ) : X = coo_matrix ( X ) X . data = X . data / sqrt ( bincount ( X . row , X . data ** 2 ) ) [ X . row ] return X", "docstring_tokens": "equivalent to scipy . preprocessing . normalize on sparse matrices but lets avoid another depedency just for a small utility function", "label": 1}, {"idx": "cosqa-train-7280", "doc": "python order list by indices", "code": "def _index_ordering(redshift_list):\n        \"\"\"\n\n        :param redshift_list: list of redshifts\n        :return: indexes in acending order to be evaluated (from z=0 to z=z_source)\n        \"\"\"\n        redshift_list = np.array(redshift_list)\n        sort_index = np.argsort(redshift_list)\n        return sort_index", "code_tokens": "def _index_ordering ( redshift_list ) : redshift_list = np . array ( redshift_list ) sort_index = np . argsort ( redshift_list ) return sort_index", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-7281", "doc": "how to do coordinates on python", "code": "def unproject(self, xy):\n        \"\"\"\n        Returns the coordinates from position in meters\n        \"\"\"\n        (x, y) = xy\n        lng = x/EARTH_RADIUS * RAD_TO_DEG\n        lat = 2 * atan(exp(y/EARTH_RADIUS)) - pi/2 * RAD_TO_DEG\n        return (lng, lat)", "code_tokens": "def unproject ( self , xy ) : ( x , y ) = xy lng = x / EARTH_RADIUS * RAD_TO_DEG lat = 2 * atan ( exp ( y / EARTH_RADIUS ) ) - pi / 2 * RAD_TO_DEG return ( lng , lat )", "docstring_tokens": "Returns the coordinates from position in meters", "label": 0}, {"idx": "cosqa-train-7282", "doc": "python pad right side", "code": "def _pad(self, text):\n        \"\"\"Pad the text.\"\"\"\n        top_bottom = (\"\\n\" * self._padding) + \" \"\n        right_left = \" \" * self._padding * self.PAD_WIDTH\n        return top_bottom + right_left + text + right_left + top_bottom", "code_tokens": "def _pad ( self , text ) : top_bottom = ( \"\\n\" * self . _padding ) + \" \" right_left = \" \" * self . _padding * self . PAD_WIDTH return top_bottom + right_left + text + right_left + top_bottom", "docstring_tokens": "Pad the text .", "label": 0}, {"idx": "cosqa-train-7283", "doc": "how to do noise reduction in python", "code": "def normal_noise(points):\n    \"\"\"Init a noise variable.\"\"\"\n    return np.random.rand(1) * np.random.randn(points, 1) \\\n        + random.sample([2, -2], 1)", "code_tokens": "def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "docstring_tokens": "Init a noise variable .", "label": 0}, {"idx": "cosqa-train-7284", "doc": "python pad with leading zeros in bitstrings", "code": "def pad_hex(value, bit_size):\n    \"\"\"\n    Pads a hex string up to the given bit_size\n    \"\"\"\n    value = remove_0x_prefix(value)\n    return add_0x_prefix(value.zfill(int(bit_size / 4)))", "code_tokens": "def pad_hex ( value , bit_size ) : value = remove_0x_prefix ( value ) return add_0x_prefix ( value . zfill ( int ( bit_size / 4 ) ) )", "docstring_tokens": "Pads a hex string up to the given bit_size", "label": 1}, {"idx": "cosqa-train-7285", "doc": "how to do width on python", "code": "def text_width(string, font_name, font_size):\n    \"\"\"Determine with width in pixels of string.\"\"\"\n    return stringWidth(string, fontName=font_name, fontSize=font_size)", "code_tokens": "def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )", "docstring_tokens": "Determine with width in pixels of string .", "label": 0}, {"idx": "cosqa-train-7286", "doc": "python parse datetime from string with timezone", "code": "def clean_time(time_string):\n    \"\"\"Return a datetime from the Amazon-provided datetime string\"\"\"\n    # Get a timezone-aware datetime object from the string\n    time = dateutil.parser.parse(time_string)\n    if not settings.USE_TZ:\n        # If timezone support is not active, convert the time to UTC and\n        # remove the timezone field\n        time = time.astimezone(timezone.utc).replace(tzinfo=None)\n    return time", "code_tokens": "def clean_time ( time_string ) : # Get a timezone-aware datetime object from the string time = dateutil . parser . parse ( time_string ) if not settings . USE_TZ : # If timezone support is not active, convert the time to UTC and # remove the timezone field time = time . astimezone ( timezone . utc ) . replace ( tzinfo = None ) return time", "docstring_tokens": "Return a datetime from the Amazon - provided datetime string", "label": 0}, {"idx": "cosqa-train-7287", "doc": "how to do you check if a value is in an array in python", "code": "def isin(value, values):\n    \"\"\" Check that value is in values \"\"\"\n    for i, v in enumerate(value):\n        if v not in np.array(values)[:, i]:\n            return False\n    return True", "code_tokens": "def isin ( value , values ) : for i , v in enumerate ( value ) : if v not in np . array ( values ) [ : , i ] : return False return True", "docstring_tokens": "Check that value is in values", "label": 1}, {"idx": "cosqa-train-7288", "doc": "python parse ip and port", "code": "def parse_host_port (host_port):\n    \"\"\"Parse a host:port string into separate components.\"\"\"\n    host, port = urllib.splitport(host_port.strip())\n    if port is not None:\n        if urlutil.is_numeric_port(port):\n            port = int(port)\n    return host, port", "code_tokens": "def parse_host_port ( host_port ) : host , port = urllib . splitport ( host_port . strip ( ) ) if port is not None : if urlutil . is_numeric_port ( port ) : port = int ( port ) return host , port", "docstring_tokens": "Parse a host : port string into separate components .", "label": 0}, {"idx": "cosqa-train-7289", "doc": "how to efficiently return multiple values within a function in python", "code": "def get_in_samples(samples, fn):\n    \"\"\"\n    for a list of samples, return the value of a global option\n    \"\"\"\n    for sample in samples:\n        sample = to_single_data(sample)\n        if fn(sample, None):\n            return fn(sample)\n    return None", "code_tokens": "def get_in_samples ( samples , fn ) : for sample in samples : sample = to_single_data ( sample ) if fn ( sample , None ) : return fn ( sample ) return None", "docstring_tokens": "for a list of samples return the value of a global option", "label": 1}, {"idx": "cosqa-train-7290", "doc": "python parse markdown into elements", "code": "def clean_markdown(text):\n    \"\"\"\n    Parse markdown sintaxt to html.\n    \"\"\"\n    result = text\n\n    if isinstance(text, str):\n        result = ''.join(\n            BeautifulSoup(markdown(text), 'lxml').findAll(text=True))\n\n    return result", "code_tokens": "def clean_markdown ( text ) : result = text if isinstance ( text , str ) : result = '' . join ( BeautifulSoup ( markdown ( text ) , 'lxml' ) . findAll ( text = True ) ) return result", "docstring_tokens": "Parse markdown sintaxt to html .", "label": 1}, {"idx": "cosqa-train-7291", "doc": "how to error an self in python", "code": "def _connection_failed(self, error=\"Error not specified!\"):\n        \"\"\"Clean up after connection failure detected.\"\"\"\n        if not self._error:\n            LOG.error(\"Connection failed: %s\", str(error))\n            self._error = error", "code_tokens": "def _connection_failed ( self , error = \"Error not specified!\" ) : if not self . _error : LOG . error ( \"Connection failed: %s\" , str ( error ) ) self . _error = error", "docstring_tokens": "Clean up after connection failure detected .", "label": 1}, {"idx": "cosqa-train-7292", "doc": "python parse markdown to read html", "code": "def md_to_text(content):\n    \"\"\" Converts markdown content to text \"\"\"\n    text = None\n    html = markdown.markdown(content)\n    if html:\n        text = html_to_text(content)\n    return text", "code_tokens": "def md_to_text ( content ) : text = None html = markdown . markdown ( content ) if html : text = html_to_text ( content ) return text", "docstring_tokens": "Converts markdown content to text", "label": 0}, {"idx": "cosqa-train-7293", "doc": "how to etermine accuracy of model python", "code": "def local_accuracy(X_train, y_train, X_test, y_test, attr_test, model_generator, metric, trained_model):\n    \"\"\" The how well do the features plus a constant base rate sum up to the model output.\n    \"\"\"\n\n    X_train, X_test = to_array(X_train, X_test)\n\n    # how many features to mask\n    assert X_train.shape[1] == X_test.shape[1]\n\n    # keep nkeep top features and re-train the model for each test explanation\n    yp_test = trained_model.predict(X_test)\n\n    return metric(yp_test, strip_list(attr_test).sum(1))", "code_tokens": "def local_accuracy ( X_train , y_train , X_test , y_test , attr_test , model_generator , metric , trained_model ) : X_train , X_test = to_array ( X_train , X_test ) # how many features to mask assert X_train . shape [ 1 ] == X_test . shape [ 1 ] # keep nkeep top features and re-train the model for each test explanation yp_test = trained_model . predict ( X_test ) return metric ( yp_test , strip_list ( attr_test ) . sum ( 1 ) )", "docstring_tokens": "The how well do the features plus a constant base rate sum up to the model output .", "label": 0}, {"idx": "cosqa-train-7294", "doc": "python parse protobuf text file", "code": "def read_proto_object(fobj, klass):\n    \"\"\"Read a block of data and parse using the given protobuf object.\"\"\"\n    log.debug('%s chunk', klass.__name__)\n    obj = klass()\n    obj.ParseFromString(read_block(fobj))\n    log.debug('Header: %s', str(obj))\n    return obj", "code_tokens": "def read_proto_object ( fobj , klass ) : log . debug ( '%s chunk' , klass . __name__ ) obj = klass ( ) obj . ParseFromString ( read_block ( fobj ) ) log . debug ( 'Header: %s' , str ( obj ) ) return obj", "docstring_tokens": "Read a block of data and parse using the given protobuf object .", "label": 1}, {"idx": "cosqa-train-7295", "doc": "how to exclude words from a dictionary loop python", "code": "def _remove_keywords(d):\n    \"\"\"\n    copy the dict, filter_keywords\n\n    Parameters\n    ----------\n    d : dict\n    \"\"\"\n    return { k:v for k, v in iteritems(d) if k not in RESERVED }", "code_tokens": "def _remove_keywords ( d ) : return { k : v for k , v in iteritems ( d ) if k not in RESERVED }", "docstring_tokens": "copy the dict filter_keywords", "label": 1}, {"idx": "cosqa-train-7296", "doc": "python parse read xx/xx/xxxx datetime from string", "code": "def _read_date_from_string(str1):\n    \"\"\"\n    Reads the date from a string in the format YYYY/MM/DD and returns\n    :class: datetime.date\n    \"\"\"\n    full_date = [int(x) for x in str1.split('/')]\n    return datetime.date(full_date[0], full_date[1], full_date[2])", "code_tokens": "def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )", "docstring_tokens": "Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date", "label": 0}, {"idx": "cosqa-train-7297", "doc": "how to execute a bash script in python", "code": "def bash(filename):\n    \"\"\"Runs a bash script in the local directory\"\"\"\n    sys.stdout.flush()\n    subprocess.call(\"bash {}\".format(filename), shell=True)", "code_tokens": "def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( \"bash {}\" . format ( filename ) , shell = True )", "docstring_tokens": "Runs a bash script in the local directory", "label": 1}, {"idx": "cosqa-train-7298", "doc": "python parsing json args command line", "code": "def main(args=sys.argv):\n    \"\"\"\n    main entry point for the jardiff CLI\n    \"\"\"\n\n    parser = create_optparser(args[0])\n    return cli(parser.parse_args(args[1:]))", "code_tokens": "def main ( args = sys . argv ) : parser = create_optparser ( args [ 0 ] ) return cli ( parser . parse_args ( args [ 1 : ] ) )", "docstring_tokens": "main entry point for the jardiff CLI", "label": 1}, {"idx": "cosqa-train-7299", "doc": "how to execute shell commmands in python and return output", "code": "def run_command(cmd, *args):\n    \"\"\"\n    Runs command on the system with given ``args``.\n    \"\"\"\n    command = ' '.join((cmd, args))\n    p = Popen(command, shell=True, stdout=PIPE, stderr=PIPE)\n    stdout, stderr = p.communicate()\n    return p.retcode, stdout, stderr", "code_tokens": "def run_command ( cmd , * args ) : command = ' ' . join ( ( cmd , args ) ) p = Popen ( command , shell = True , stdout = PIPE , stderr = PIPE ) stdout , stderr = p . communicate ( ) return p . retcode , stdout , stderr", "docstring_tokens": "Runs command on the system with given args .", "label": 1}, {"idx": "cosqa-train-7300", "doc": "python pass array to html", "code": "def _render_table(data, fields=None):\n  \"\"\" Helper to render a list of dictionaries as an HTML display object. \"\"\"\n  return IPython.core.display.HTML(datalab.utils.commands.HtmlBuilder.render_table(data, fields))", "code_tokens": "def _render_table ( data , fields = None ) : return IPython . core . display . HTML ( datalab . utils . commands . HtmlBuilder . render_table ( data , fields ) )", "docstring_tokens": "Helper to render a list of dictionaries as an HTML display object .", "label": 1}, {"idx": "cosqa-train-7301", "doc": "how to extract tables of a database in python", "code": "def extract_table_names(query):\n    \"\"\" Extract table names from an SQL query. \"\"\"\n    # a good old fashioned regex. turns out this worked better than actually parsing the code\n    tables_blocks = re.findall(r'(?:FROM|JOIN)\\s+(\\w+(?:\\s*,\\s*\\w+)*)', query, re.IGNORECASE)\n    tables = [tbl\n              for block in tables_blocks\n              for tbl in re.findall(r'\\w+', block)]\n    return set(tables)", "code_tokens": "def extract_table_names ( query ) : # a good old fashioned regex. turns out this worked better than actually parsing the code tables_blocks = re . findall ( r'(?:FROM|JOIN)\\s+(\\w+(?:\\s*,\\s*\\w+)*)' , query , re . IGNORECASE ) tables = [ tbl for block in tables_blocks for tbl in re . findall ( r'\\w+' , block ) ] return set ( tables )", "docstring_tokens": "Extract table names from an SQL query .", "label": 1}, {"idx": "cosqa-train-7302", "doc": "python passing a list into function using slice", "code": "def iget_list_column_slice(list_, start=None, stop=None, stride=None):\n    \"\"\" iterator version of get_list_column \"\"\"\n    if isinstance(start, slice):\n        slice_ = start\n    else:\n        slice_ = slice(start, stop, stride)\n    return (row[slice_] for row in list_)", "code_tokens": "def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )", "docstring_tokens": "iterator version of get_list_column", "label": 0}, {"idx": "cosqa-train-7303", "doc": "how to extract tables of mysql database in python", "code": "def extract_table_names(query):\n    \"\"\" Extract table names from an SQL query. \"\"\"\n    # a good old fashioned regex. turns out this worked better than actually parsing the code\n    tables_blocks = re.findall(r'(?:FROM|JOIN)\\s+(\\w+(?:\\s*,\\s*\\w+)*)', query, re.IGNORECASE)\n    tables = [tbl\n              for block in tables_blocks\n              for tbl in re.findall(r'\\w+', block)]\n    return set(tables)", "code_tokens": "def extract_table_names ( query ) : # a good old fashioned regex. turns out this worked better than actually parsing the code tables_blocks = re . findall ( r'(?:FROM|JOIN)\\s+(\\w+(?:\\s*,\\s*\\w+)*)' , query , re . IGNORECASE ) tables = [ tbl for block in tables_blocks for tbl in re . findall ( r'\\w+' , block ) ] return set ( tables )", "docstring_tokens": "Extract table names from an SQL query .", "label": 1}, {"idx": "cosqa-train-7304", "doc": "python paste clipboard adds enter", "code": "def OnPasteAs(self, event):\n        \"\"\"Clipboard paste as event handler\"\"\"\n\n        data = self.main_window.clipboard.get_clipboard()\n        key = self.main_window.grid.actions.cursor\n\n        with undo.group(_(\"Paste As...\")):\n            self.main_window.actions.paste_as(key, data)\n\n        self.main_window.grid.ForceRefresh()\n\n        event.Skip()", "code_tokens": "def OnPasteAs ( self , event ) : data = self . main_window . clipboard . get_clipboard ( ) key = self . main_window . grid . actions . cursor with undo . group ( _ ( \"Paste As...\" ) ) : self . main_window . actions . paste_as ( key , data ) self . main_window . grid . ForceRefresh ( ) event . Skip ( )", "docstring_tokens": "Clipboard paste as event handler", "label": 0}, {"idx": "cosqa-train-7305", "doc": "how to extract the rgb values from a python colormap", "code": "def _value_to_color(value, cmap):\n    \"\"\"Convert a value in the range [0,1] to an RGB tuple using a colormap.\"\"\"\n    cm = plt.get_cmap(cmap)\n    rgba = cm(value)\n    return [int(round(255*v)) for v in rgba[0:3]]", "code_tokens": "def _value_to_color ( value , cmap ) : cm = plt . get_cmap ( cmap ) rgba = cm ( value ) return [ int ( round ( 255 * v ) ) for v in rgba [ 0 : 3 ] ]", "docstring_tokens": "Convert a value in the range [ 0 1 ] to an RGB tuple using a colormap .", "label": 0}, {"idx": "cosqa-train-7306", "doc": "python path to appdata folder", "code": "def data_directory():\n    \"\"\"Return the absolute path to the directory containing the package data.\"\"\"\n    package_directory = os.path.abspath(os.path.dirname(__file__))\n    return os.path.join(package_directory, \"data\")", "code_tokens": "def data_directory ( ) : package_directory = os . path . abspath ( os . path . dirname ( __file__ ) ) return os . path . join ( package_directory , \"data\" )", "docstring_tokens": "Return the absolute path to the directory containing the package data .", "label": 1}, {"idx": "cosqa-train-7307", "doc": "how to fibd the most frequent word from the stemmed words in python", "code": "def _rank(self, ranking, n):\n    \"\"\" return the first n sentences with highest ranking \"\"\"\n    return nlargest(n, ranking, key=ranking.get)", "code_tokens": "def _rank ( self , ranking , n ) : return nlargest ( n , ranking , key = ranking . get )", "docstring_tokens": "return the first n sentences with highest ranking", "label": 0}, {"idx": "cosqa-train-7308", "doc": "python pdb show stack trace", "code": "def debug_on_error(type, value, tb):\n    \"\"\"Code due to Thomas Heller - published in Python Cookbook (O'Reilley)\"\"\"\n    traceback.print_exc(type, value, tb)\n    print()\n    pdb.pm()", "code_tokens": "def debug_on_error ( type , value , tb ) : traceback . print_exc ( type , value , tb ) print ( ) pdb . pm ( )", "docstring_tokens": "Code due to Thomas Heller - published in Python Cookbook ( O Reilley )", "label": 0}, {"idx": "cosqa-train-7309", "doc": "how to fill linterrepter python", "code": "def register(linter):\n    \"\"\"Register the reporter classes with the linter.\"\"\"\n    linter.register_reporter(TextReporter)\n    linter.register_reporter(ParseableTextReporter)\n    linter.register_reporter(VSTextReporter)\n    linter.register_reporter(ColorizedTextReporter)", "code_tokens": "def register ( linter ) : linter . register_reporter ( TextReporter ) linter . register_reporter ( ParseableTextReporter ) linter . register_reporter ( VSTextReporter ) linter . register_reporter ( ColorizedTextReporter )", "docstring_tokens": "Register the reporter classes with the linter .", "label": 1}, {"idx": "cosqa-train-7310", "doc": "python pdf header footer just", "code": "def _put_header(self):\n        \"\"\" Standard first line in a PDF. \"\"\"\n        self.session._out('%%PDF-%s' % self.pdf_version)\n        if self.session.compression:\n            self.session.buffer += '%' + chr(235) + chr(236) + chr(237) + chr(238) + \"\\n\"", "code_tokens": "def _put_header ( self ) : self . session . _out ( '%%PDF-%s' % self . pdf_version ) if self . session . compression : self . session . buffer += '%' + chr ( 235 ) + chr ( 236 ) + chr ( 237 ) + chr ( 238 ) + \"\\n\"", "docstring_tokens": "Standard first line in a PDF .", "label": 1}, {"idx": "cosqa-train-7311", "doc": "how to fine a line's index in file python", "code": "def get_lines(handle, line):\n    \"\"\"\n    Get zero-indexed line from an open file-like.\n    \"\"\"\n    for i, l in enumerate(handle):\n        if i == line:\n            return l", "code_tokens": "def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l", "docstring_tokens": "Get zero - indexed line from an open file - like .", "label": 1}, {"idx": "cosqa-train-7312", "doc": "python pdf page size", "code": "def dimensions(self):\n        \"\"\"Get width and height of a PDF\"\"\"\n        size = self.pdf.getPage(0).mediaBox\n        return {'w': float(size[2]), 'h': float(size[3])}", "code_tokens": "def dimensions ( self ) : size = self . pdf . getPage ( 0 ) . mediaBox return { 'w' : float ( size [ 2 ] ) , 'h' : float ( size [ 3 ] ) }", "docstring_tokens": "Get width and height of a PDF", "label": 0}, {"idx": "cosqa-train-7313", "doc": "how to fix python error 'type' object is not subscriptable", "code": "def fix_call(callable, *args, **kw):\n    \"\"\"\n    Call ``callable(*args, **kw)`` fixing any type errors that come out.\n    \"\"\"\n    try:\n        val = callable(*args, **kw)\n    except TypeError:\n        exc_info = fix_type_error(None, callable, args, kw)\n        reraise(*exc_info)\n    return val", "code_tokens": "def fix_call ( callable , * args , * * kw ) : try : val = callable ( * args , * * kw ) except TypeError : exc_info = fix_type_error ( None , callable , args , kw ) reraise ( * exc_info ) return val", "docstring_tokens": "Call callable ( * args ** kw ) fixing any type errors that come out .", "label": 1}, {"idx": "cosqa-train-7314", "doc": "python pearson corr between 2 columns", "code": "def cor(y_true, y_pred):\n    \"\"\"Compute Pearson correlation coefficient.\n    \"\"\"\n    y_true, y_pred = _mask_nan(y_true, y_pred)\n    return np.corrcoef(y_true, y_pred)[0, 1]", "code_tokens": "def cor ( y_true , y_pred ) : y_true , y_pred = _mask_nan ( y_true , y_pred ) return np . corrcoef ( y_true , y_pred ) [ 0 , 1 ]", "docstring_tokens": "Compute Pearson correlation coefficient .", "label": 1}, {"idx": "cosqa-train-7315", "doc": "how to flatten 3d array in python", "code": "def make_2d(ary):\n    \"\"\"Convert any array into a 2d numpy array.\n\n    In case the array is already more than 2 dimensional, will ravel the\n    dimensions after the first.\n    \"\"\"\n    dim_0, *_ = np.atleast_1d(ary).shape\n    return ary.reshape(dim_0, -1, order=\"F\")", "code_tokens": "def make_2d ( ary ) : dim_0 ,  * _ = np . atleast_1d ( ary ) . shape return ary . reshape ( dim_0 , - 1 , order = \"F\" )", "docstring_tokens": "Convert any array into a 2d numpy array .", "label": 1}, {"idx": "cosqa-train-7316", "doc": "python pick top k", "code": "def topk(arg, k, by=None):\n    \"\"\"\n    Returns\n    -------\n    topk : TopK filter expression\n    \"\"\"\n    op = ops.TopK(arg, k, by=by)\n    return op.to_expr()", "code_tokens": "def topk ( arg , k , by = None ) : op = ops . TopK ( arg , k , by = by ) return op . to_expr ( )", "docstring_tokens": "Returns ------- topk : TopK filter expression", "label": 0}, {"idx": "cosqa-train-7317", "doc": "how to fold an array of strings in python", "code": "def flatten( iterables ):\n    \"\"\" Flatten an iterable, except for string elements. \"\"\"\n    for it in iterables:\n        if isinstance(it, str):\n            yield it\n        else:\n            for element in it:\n                yield element", "code_tokens": "def flatten ( iterables ) : for it in iterables : if isinstance ( it , str ) : yield it else : for element in it : yield element", "docstring_tokens": "Flatten an iterable except for string elements .", "label": 0}, {"idx": "cosqa-train-7318", "doc": "python picking out letters in strings", "code": "def return_letters_from_string(text):\n    \"\"\"Get letters from string only.\"\"\"\n    out = \"\"\n    for letter in text:\n        if letter.isalpha():\n            out += letter\n    return out", "code_tokens": "def return_letters_from_string ( text ) : out = \"\" for letter in text : if letter . isalpha ( ) : out += letter return out", "docstring_tokens": "Get letters from string only .", "label": 0}, {"idx": "cosqa-train-7319", "doc": "how to force a kill process in python", "code": "def set_stop_handler(self):\n        \"\"\"\n        Initializes functions that are invoked when the user or OS wants to kill this process.\n        :return:\n        \"\"\"\n        signal.signal(signal.SIGTERM, self.graceful_stop)\n        signal.signal(signal.SIGABRT, self.graceful_stop)\n        signal.signal(signal.SIGINT, self.graceful_stop)", "code_tokens": "def set_stop_handler ( self ) : signal . signal ( signal . SIGTERM , self . graceful_stop ) signal . signal ( signal . SIGABRT , self . graceful_stop ) signal . signal ( signal . SIGINT , self . graceful_stop )", "docstring_tokens": "Initializes functions that are invoked when the user or OS wants to kill this process . : return :", "label": 1}, {"idx": "cosqa-train-7320", "doc": "python pickle loads numpy", "code": "def _openResources(self):\n        \"\"\" Uses numpy.load to open the underlying file\n        \"\"\"\n        arr = np.load(self._fileName, allow_pickle=ALLOW_PICKLE)\n        check_is_an_array(arr)\n        self._array = arr", "code_tokens": "def _openResources ( self ) : arr = np . load ( self . _fileName , allow_pickle = ALLOW_PICKLE ) check_is_an_array ( arr ) self . _array = arr", "docstring_tokens": "Uses numpy . load to open the underlying file", "label": 1}, {"idx": "cosqa-train-7321", "doc": "how to format a float to have only 2 decimals in python", "code": "def fixed(ctx, number, decimals=2, no_commas=False):\n    \"\"\"\n    Formats the given number in decimal format using a period and commas\n    \"\"\"\n    value = _round(ctx, number, decimals)\n    format_str = '{:f}' if no_commas else '{:,f}'\n    return format_str.format(value)", "code_tokens": "def fixed ( ctx , number , decimals = 2 , no_commas = False ) : value = _round ( ctx , number , decimals ) format_str = '{:f}' if no_commas else '{:,f}' return format_str . format ( value )", "docstring_tokens": "Formats the given number in decimal format using a period and commas", "label": 1}, {"idx": "cosqa-train-7322", "doc": "python pil camera capture", "code": "def read(self):\n        \"\"\"https://picamera.readthedocs.io/en/release-1.13/recipes1.html#capturing-to-a-pil-image\"\"\"\n        stream = BytesIO()\n        self.cam.capture(stream, format='png')\n        # \"Rewind\" the stream to the beginning so we can read its content\n        stream.seek(0)\n        return Image.open(stream)", "code_tokens": "def read ( self ) : stream = BytesIO ( ) self . cam . capture ( stream , format = 'png' ) # \"Rewind\" the stream to the beginning so we can read its content stream . seek ( 0 ) return Image . open ( stream )", "docstring_tokens": "https : // picamera . readthedocs . io / en / release - 1 . 13 / recipes1 . html#capturing - to - a - pil - image", "label": 1}, {"idx": "cosqa-train-7323", "doc": "how to gain focus on a python widget", "code": "def focus(self):\n        \"\"\"\n        Call this to give this Widget the input focus.\n        \"\"\"\n        self._has_focus = True\n        self._frame.move_to(self._x, self._y, self._h)\n        if self._on_focus is not None:\n            self._on_focus()", "code_tokens": "def focus ( self ) : self . _has_focus = True self . _frame . move_to ( self . _x , self . _y , self . _h ) if self . _on_focus is not None : self . _on_focus ( )", "docstring_tokens": "Call this to give this Widget the input focus .", "label": 1}, {"idx": "cosqa-train-7324", "doc": "python play music same time", "code": "def pause(self):\n        \"\"\"Pause the music\"\"\"\n        mixer.music.pause()\n        self.pause_time = self.get_time()\n        self.paused = True", "code_tokens": "def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True", "docstring_tokens": "Pause the music", "label": 1}, {"idx": "cosqa-train-7325", "doc": "how to generate a random password with given length and compleiety in python 3", "code": "def GeneratePassphrase(length=20):\n  \"\"\"Create a 20 char passphrase with easily typeable chars.\"\"\"\n  valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  valid_chars += \"0123456789 ,-_&$#\"\n  return \"\".join(random.choice(valid_chars) for i in range(length))", "code_tokens": "def GeneratePassphrase ( length = 20 ) : valid_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" valid_chars += \"0123456789 ,-_&$#\" return \"\" . join ( random . choice ( valid_chars ) for i in range ( length ) )", "docstring_tokens": "Create a 20 char passphrase with easily typeable chars .", "label": 1}, {"idx": "cosqa-train-7326", "doc": "python plot array of 2d lines", "code": "def polyline(self, arr):\n        \"\"\"Draw a set of lines\"\"\"\n        for i in range(0, len(arr) - 1):\n            self.line(arr[i][0], arr[i][1], arr[i + 1][0], arr[i + 1][1])", "code_tokens": "def polyline ( self , arr ) : for i in range ( 0 , len ( arr ) - 1 ) : self . line ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] , arr [ i + 1 ] [ 0 ] , arr [ i + 1 ] [ 1 ] )", "docstring_tokens": "Draw a set of lines", "label": 0}, {"idx": "cosqa-train-7327", "doc": "how to generate n diffreent random numbers in a range python", "code": "def random_numbers(n):\n    \"\"\"\n    Generate a random string from 0-9\n    :param n: length of the string\n    :return: the random string\n    \"\"\"\n    return ''.join(random.SystemRandom().choice(string.digits) for _ in range(n))", "code_tokens": "def random_numbers ( n ) : return '' . join ( random . SystemRandom ( ) . choice ( string . digits ) for _ in range ( n ) )", "docstring_tokens": "Generate a random string from 0 - 9 : param n : length of the string : return : the random string", "label": 1}, {"idx": "cosqa-train-7328", "doc": "python plot aspect ratio set aspect equal", "code": "def image_set_aspect(aspect=1.0, axes=\"gca\"):\n    \"\"\"\n    sets the aspect ratio of the current zoom level of the imshow image\n    \"\"\"\n    if axes is \"gca\": axes = _pylab.gca()\n\n    e = axes.get_images()[0].get_extent()\n    axes.set_aspect(abs((e[1]-e[0])/(e[3]-e[2]))/aspect)", "code_tokens": "def image_set_aspect ( aspect = 1.0 , axes = \"gca\" ) : if axes is \"gca\" : axes = _pylab . gca ( ) e = axes . get_images ( ) [ 0 ] . get_extent ( ) axes . set_aspect ( abs ( ( e [ 1 ] - e [ 0 ] ) / ( e [ 3 ] - e [ 2 ] ) ) / aspect )", "docstring_tokens": "sets the aspect ratio of the current zoom level of the imshow image", "label": 0}, {"idx": "cosqa-train-7329", "doc": "how to generate random variates from lognormal distribution in python", "code": "def lognorm(x, mu, sigma=1.0):\n    \"\"\" Log-normal function from scipy \"\"\"\n    return stats.lognorm(sigma, scale=mu).pdf(x)", "code_tokens": "def lognorm ( x , mu , sigma = 1.0 ) : return stats . lognorm ( sigma , scale = mu ) . pdf ( x )", "docstring_tokens": "Log - normal function from scipy", "label": 0}, {"idx": "cosqa-train-7330", "doc": "python plot axis remove", "code": "def axes_off(ax):\n    \"\"\"Get rid of all axis ticks, lines, etc.\n    \"\"\"\n    ax.set_frame_on(False)\n    ax.axes.get_yaxis().set_visible(False)\n    ax.axes.get_xaxis().set_visible(False)", "code_tokens": "def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )", "docstring_tokens": "Get rid of all axis ticks lines etc .", "label": 1}, {"idx": "cosqa-train-7331", "doc": "how to generate secure uuid python", "code": "def generate_uuid():\n    \"\"\"Generate a UUID.\"\"\"\n    r_uuid = base64.urlsafe_b64encode(uuid.uuid4().bytes)\n    return r_uuid.decode().replace('=', '')", "code_tokens": "def generate_uuid ( ) : r_uuid = base64 . urlsafe_b64encode ( uuid . uuid4 ( ) . bytes ) return r_uuid . decode ( ) . replace ( '=' , '' )", "docstring_tokens": "Generate a UUID .", "label": 1}, {"idx": "cosqa-train-7332", "doc": "python plot least squares regression line pyplot", "code": "def _linear_seaborn_(self, label=None, style=None, opts=None):\n        \"\"\"\n        Returns a Seaborn linear regression plot\n        \"\"\"\n        xticks, yticks = self._get_ticks(opts)\n        try:\n            fig = sns.lmplot(self.x, self.y, data=self.df)\n            fig = self._set_with_height(fig, opts)\n            return fig\n        except Exception as e:\n            self.err(e, self.linear_,\n                     \"Can not draw linear regression chart\")", "code_tokens": "def _linear_seaborn_ ( self , label = None , style = None , opts = None ) : xticks , yticks = self . _get_ticks ( opts ) try : fig = sns . lmplot ( self . x , self . y , data = self . df ) fig = self . _set_with_height ( fig , opts ) return fig except Exception as e : self . err ( e , self . linear_ , \"Can not draw linear regression chart\" )", "docstring_tokens": "Returns a Seaborn linear regression plot", "label": 0}, {"idx": "cosqa-train-7333", "doc": "how to generate unique permutation of words in python", "code": "def make_unique_ngrams(s, n):\n    \"\"\"Make a set of unique n-grams from a string.\"\"\"\n    return set(s[i:i + n] for i in range(len(s) - n + 1))", "code_tokens": "def make_unique_ngrams ( s , n ) : return set ( s [ i : i + n ] for i in range ( len ( s ) - n + 1 ) )", "docstring_tokens": "Make a set of unique n - grams from a string .", "label": 1}, {"idx": "cosqa-train-7334", "doc": "python plot remove axis ticks", "code": "def axes_off(ax):\n    \"\"\"Get rid of all axis ticks, lines, etc.\n    \"\"\"\n    ax.set_frame_on(False)\n    ax.axes.get_yaxis().set_visible(False)\n    ax.axes.get_xaxis().set_visible(False)", "code_tokens": "def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )", "docstring_tokens": "Get rid of all axis ticks lines etc .", "label": 0}, {"idx": "cosqa-train-7335", "doc": "how to get a file from a parent folder in python", "code": "def get_parent_folder_name(file_path):\n    \"\"\"Finds parent folder of file\n\n    :param file_path: path\n    :return: Name of folder container\n    \"\"\"\n    return os.path.split(os.path.split(os.path.abspath(file_path))[0])[-1]", "code_tokens": "def get_parent_folder_name ( file_path ) : return os . path . split ( os . path . split ( os . path . abspath ( file_path ) ) [ 0 ] ) [ - 1 ]", "docstring_tokens": "Finds parent folder of file", "label": 1}, {"idx": "cosqa-train-7336", "doc": "python plotting in a single figure hold", "code": "def oplot(self, x, y, **kw):\n        \"\"\"generic plotting method, overplotting any existing plot \"\"\"\n        self.panel.oplot(x, y, **kw)", "code_tokens": "def oplot ( self , x , y , * * kw ) : self . panel . oplot ( x , y , * * kw )", "docstring_tokens": "generic plotting method overplotting any existing plot", "label": 0}, {"idx": "cosqa-train-7337", "doc": "how to get a list of devices python", "code": "def get_available_gpus():\n  \"\"\"\n  Returns a list of string names of all available GPUs\n  \"\"\"\n  local_device_protos = device_lib.list_local_devices()\n  return [x.name for x in local_device_protos if x.device_type == 'GPU']", "code_tokens": "def get_available_gpus ( ) : local_device_protos = device_lib . list_local_devices ( ) return [ x . name for x in local_device_protos if x . device_type == 'GPU' ]", "docstring_tokens": "Returns a list of string names of all available GPUs", "label": 0}, {"idx": "cosqa-train-7338", "doc": "python plt remove axis labels", "code": "def axes_off(ax):\n    \"\"\"Get rid of all axis ticks, lines, etc.\n    \"\"\"\n    ax.set_frame_on(False)\n    ax.axes.get_yaxis().set_visible(False)\n    ax.axes.get_xaxis().set_visible(False)", "code_tokens": "def axes_off ( ax ) : ax . set_frame_on ( False ) ax . axes . get_yaxis ( ) . set_visible ( False ) ax . axes . get_xaxis ( ) . set_visible ( False )", "docstring_tokens": "Get rid of all axis ticks lines etc .", "label": 1}, {"idx": "cosqa-train-7339", "doc": "how to get all dates between 2 dates python", "code": "def dates_in_range(start_date, end_date):\n    \"\"\"Returns all dates between two dates.\n\n    Inclusive of the start date but not the end date.\n\n    Args:\n        start_date (datetime.date)\n        end_date (datetime.date)\n\n    Returns:\n        (list) of datetime.date objects\n    \"\"\"\n    return [\n        start_date + timedelta(n)\n        for n in range(int((end_date - start_date).days))\n    ]", "code_tokens": "def dates_in_range ( start_date , end_date ) : return [ start_date + timedelta ( n ) for n in range ( int ( ( end_date - start_date ) . days ) ) ]", "docstring_tokens": "Returns all dates between two dates .", "label": 0}, {"idx": "cosqa-train-7340", "doc": "python pretty print dicitonary", "code": "def pprint(self, stream=None, indent=1, width=80, depth=None):\n    \"\"\"\n    Pretty print the underlying literal Python object\n    \"\"\"\n    pp.pprint(to_literal(self), stream, indent, width, depth)", "code_tokens": "def pprint ( self , stream = None , indent = 1 , width = 80 , depth = None ) : pp . pprint ( to_literal ( self ) , stream , indent , width , depth )", "docstring_tokens": "Pretty print the underlying literal Python object", "label": 0}, {"idx": "cosqa-train-7341", "doc": "how to get column names from table using python", "code": "def get_column_keys_and_names(table):\n    \"\"\"\n    Return a generator of tuples k, c such that k is the name of the python attribute for\n    the column and c is the name of the column in the sql table.\n    \"\"\"\n    ins = inspect(table)\n    return ((k, c.name) for k, c in ins.mapper.c.items())", "code_tokens": "def get_column_keys_and_names ( table ) : ins = inspect ( table ) return ( ( k , c . name ) for k , c in ins . mapper . c . items ( ) )", "docstring_tokens": "Return a generator of tuples k c such that k is the name of the python attribute for the column and c is the name of the column in the sql table .", "label": 0}, {"idx": "cosqa-train-7342", "doc": "python pretty print matrix", "code": "def print_matrix(X, decimals=1):\n    \"\"\"Pretty printing for numpy matrix X\"\"\"\n    for row in np.round(X, decimals=decimals):\n        print(row)", "code_tokens": "def print_matrix ( X , decimals = 1 ) : for row in np . round ( X , decimals = decimals ) : print ( row )", "docstring_tokens": "Pretty printing for numpy matrix X", "label": 0}, {"idx": "cosqa-train-7343", "doc": "how to get default path in python", "code": "def get_base_dir():\n    \"\"\"\n    Return the base directory\n    \"\"\"\n    return os.path.split(os.path.abspath(os.path.dirname(__file__)))[0]", "code_tokens": "def get_base_dir ( ) : return os . path . split ( os . path . abspath ( os . path . dirname ( __file__ ) ) ) [ 0 ]", "docstring_tokens": "Return the base directory", "label": 0}, {"idx": "cosqa-train-7344", "doc": "python pretty print without sort", "code": "def pprint(obj, verbose=False, max_width=79, newline='\\n'):\n    \"\"\"\n    Like `pretty` but print to stdout.\n    \"\"\"\n    printer = RepresentationPrinter(sys.stdout, verbose, max_width, newline)\n    printer.pretty(obj)\n    printer.flush()\n    sys.stdout.write(newline)\n    sys.stdout.flush()", "code_tokens": "def pprint ( obj , verbose = False , max_width = 79 , newline = '\\n' ) : printer = RepresentationPrinter ( sys . stdout , verbose , max_width , newline ) printer . pretty ( obj ) printer . flush ( ) sys . stdout . write ( newline ) sys . stdout . flush ( )", "docstring_tokens": "Like pretty but print to stdout .", "label": 1}, {"idx": "cosqa-train-7345", "doc": "how to get dictinary first element in python", "code": "def get_single_value(d):\n    \"\"\"Get a value from a dict which contains just one item.\"\"\"\n    assert len(d) == 1, 'Single-item dict must have just one item, not %d.' % len(d)\n    return next(six.itervalues(d))", "code_tokens": "def get_single_value ( d ) : assert len ( d ) == 1 , 'Single-item dict must have just one item, not %d.' % len ( d ) return next ( six . itervalues ( d ) )", "docstring_tokens": "Get a value from a dict which contains just one item .", "label": 1}, {"idx": "cosqa-train-7346", "doc": "python prettytable v ptable", "code": "def format_prettytable(table):\n    \"\"\"Converts SoftLayer.CLI.formatting.Table instance to a prettytable.\"\"\"\n    for i, row in enumerate(table.rows):\n        for j, item in enumerate(row):\n            table.rows[i][j] = format_output(item)\n\n    ptable = table.prettytable()\n    ptable.hrules = prettytable.FRAME\n    ptable.horizontal_char = '.'\n    ptable.vertical_char = ':'\n    ptable.junction_char = ':'\n    return ptable", "code_tokens": "def format_prettytable ( table ) : for i , row in enumerate ( table . rows ) : for j , item in enumerate ( row ) : table . rows [ i ] [ j ] = format_output ( item ) ptable = table . prettytable ( ) ptable . hrules = prettytable . FRAME ptable . horizontal_char = '.' ptable . vertical_char = ':' ptable . junction_char = ':' return ptable", "docstring_tokens": "Converts SoftLayer . CLI . formatting . Table instance to a prettytable .", "label": 0}, {"idx": "cosqa-train-7347", "doc": "how to get differet between two python files in python", "code": "def diff(file_, imports):\n    \"\"\"Display the difference between modules in a file and imported modules.\"\"\"\n    modules_not_imported = compare_modules(file_, imports)\n\n    logging.info(\"The following modules are in {} but do not seem to be imported: \"\n                 \"{}\".format(file_, \", \".join(x for x in modules_not_imported)))", "code_tokens": "def diff ( file_ , imports ) : modules_not_imported = compare_modules ( file_ , imports ) logging . info ( \"The following modules are in {} but do not seem to be imported: \" \"{}\" . format ( file_ , \", \" . join ( x for x in modules_not_imported ) ) )", "docstring_tokens": "Display the difference between modules in a file and imported modules .", "label": 1}, {"idx": "cosqa-train-7348", "doc": "python prevent buffering stdout", "code": "def disable_stdout_buffering():\n    \"\"\"This turns off stdout buffering so that outputs are immediately\n    materialized and log messages show up before the program exits\"\"\"\n    stdout_orig = sys.stdout\n    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)\n    # NOTE(brandyn): This removes the original stdout\n    return stdout_orig", "code_tokens": "def disable_stdout_buffering ( ) : stdout_orig = sys . stdout sys . stdout = os . fdopen ( sys . stdout . fileno ( ) , 'w' , 0 ) # NOTE(brandyn): This removes the original stdout return stdout_orig", "docstring_tokens": "This turns off stdout buffering so that outputs are immediately materialized and log messages show up before the program exits", "label": 1}, {"idx": "cosqa-train-7349", "doc": "how to get dimensions of a photo in python", "code": "def get_combined_size(tiles):\n    \"\"\"Calculate combined size of tiles.\"\"\"\n    # TODO: Refactor calculating layout to avoid repetition.\n    columns, rows = calc_columns_rows(len(tiles))\n    tile_size = tiles[0].image.size\n    return (tile_size[0] * columns, tile_size[1] * rows)", "code_tokens": "def get_combined_size ( tiles ) : # TODO: Refactor calculating layout to avoid repetition. columns , rows = calc_columns_rows ( len ( tiles ) ) tile_size = tiles [ 0 ] . image . size return ( tile_size [ 0 ] * columns , tile_size [ 1 ] * rows )", "docstring_tokens": "Calculate combined size of tiles .", "label": 0}, {"idx": "cosqa-train-7350", "doc": "python print all environment settings", "code": "def cli(env):\n    \"\"\"Show current configuration.\"\"\"\n\n    settings = config.get_settings_from_client(env.client)\n    env.fout(config.config_table(settings))", "code_tokens": "def cli ( env ) : settings = config . get_settings_from_client ( env . client ) env . fout ( config . config_table ( settings ) )", "docstring_tokens": "Show current configuration .", "label": 0}, {"idx": "cosqa-train-7351", "doc": "how to get file md5 by python", "code": "def get_md5_for_file(file):\n    \"\"\"Get the md5 hash for a file.\n\n    :param file: the file to get the md5 hash for\n    \"\"\"\n    md5 = hashlib.md5()\n\n    while True:\n        data = file.read(md5.block_size)\n\n        if not data:\n            break\n\n        md5.update(data)\n\n    return md5.hexdigest()", "code_tokens": "def get_md5_for_file ( file ) : md5 = hashlib . md5 ( ) while True : data = file . read ( md5 . block_size ) if not data : break md5 . update ( data ) return md5 . hexdigest ( )", "docstring_tokens": "Get the md5 hash for a file .", "label": 0}, {"idx": "cosqa-train-7352", "doc": "python print all environment variables join", "code": "def show():\n    \"\"\"Show (print out) current environment variables.\"\"\"\n    env = get_environment()\n\n    for key, val in sorted(env.env.items(), key=lambda item: item[0]):\n        click.secho('%s = %s' % (key, val))", "code_tokens": "def show ( ) : env = get_environment ( ) for key , val in sorted ( env . env . items ( ) , key = lambda item : item [ 0 ] ) : click . secho ( '%s = %s' % ( key , val ) )", "docstring_tokens": "Show ( print out ) current environment variables .", "label": 1}, {"idx": "cosqa-train-7353", "doc": "how to get file name using path in python", "code": "def get_file_name(url):\n  \"\"\"Returns file name of file at given url.\"\"\"\n  return os.path.basename(urllib.parse.urlparse(url).path) or 'unknown_name'", "code_tokens": "def get_file_name ( url ) : return os . path . basename ( urllib . parse . urlparse ( url ) . path ) or 'unknown_name'", "docstring_tokens": "Returns file name of file at given url .", "label": 1}, {"idx": "cosqa-train-7354", "doc": "python print format items", "code": "def _prtstr(self, obj, dashes):\n        \"\"\"Print object information using a namedtuple and a format pattern.\"\"\"\n        self.prt.write('{DASHES:{N}}'.format(\n            DASHES=self.fmt_dashes.format(DASHES=dashes, ID=obj.item_id),\n            N=self.dash_len))\n        self.prt.write(\"{INFO}\\n\".format(INFO=str(obj)))", "code_tokens": "def _prtstr ( self , obj , dashes ) : self . prt . write ( '{DASHES:{N}}' . format ( DASHES = self . fmt_dashes . format ( DASHES = dashes , ID = obj . item_id ) , N = self . dash_len ) ) self . prt . write ( \"{INFO}\\n\" . format ( INFO = str ( obj ) ) )", "docstring_tokens": "Print object information using a namedtuple and a format pattern .", "label": 0}, {"idx": "cosqa-train-7355", "doc": "how to get files matching to some pattern from sftp server directory using python", "code": "def globlookup(pattern, root):\n    \"\"\"globlookup finds filesystem objects whose relative path matches the\n    given pattern.\n\n    :param pattern: The pattern to wish to match relative filepaths to.\n    :param root: The root director to search within.\n\n    \"\"\"\n    for subdir, dirnames, filenames in os.walk(root):\n        d = subdir[len(root) + 1:]\n        files = (os.path.join(d, f) for f in filenames)\n        for f in fnmatch.filter(files, pattern):\n            yield f", "code_tokens": "def globlookup ( pattern , root ) : for subdir , dirnames , filenames in os . walk ( root ) : d = subdir [ len ( root ) + 1 : ] files = ( os . path . join ( d , f ) for f in filenames ) for f in fnmatch . filter ( files , pattern ) : yield f", "docstring_tokens": "globlookup finds filesystem objects whose relative path matches the given pattern .", "label": 1}, {"idx": "cosqa-train-7356", "doc": "python print global modifier", "code": "def debug(ftn, txt):\n    \"\"\"Used for debugging.\"\"\"\n    if debug_p:\n        sys.stdout.write(\"{0}.{1}:{2}\\n\".format(modname, ftn, txt))\n        sys.stdout.flush()", "code_tokens": "def debug ( ftn , txt ) : if debug_p : sys . stdout . write ( \"{0}.{1}:{2}\\n\" . format ( modname , ftn , txt ) ) sys . stdout . flush ( )", "docstring_tokens": "Used for debugging .", "label": 0}, {"idx": "cosqa-train-7357", "doc": "how to get first day of the month in python", "code": "def get_month_start(day=None):\n    \"\"\"Returns the first day of the given month.\"\"\"\n    day = add_timezone(day or datetime.date.today())\n    return day.replace(day=1)", "code_tokens": "def get_month_start ( day = None ) : day = add_timezone ( day or datetime . date . today ( ) ) return day . replace ( day = 1 )", "docstring_tokens": "Returns the first day of the given month .", "label": 1}, {"idx": "cosqa-train-7358", "doc": "python print message assert faild", "code": "def process_instance(self, instance):\n        self.log.debug(\"e = mc^2\")\n        self.log.info(\"About to fail..\")\n        self.log.warning(\"Failing.. soooon..\")\n        self.log.critical(\"Ok, you're done.\")\n        assert False, \"\"\"ValidateFailureMock was destined to fail..\n\nHere's some extended information about what went wrong.\n\nIt has quite the long string associated with it, including\na few newlines and a list.\n\n- Item 1\n- Item 2\n\n\"\"\"", "code_tokens": "def process_instance ( self , instance ) : self . log . debug ( \"e = mc^2\" ) self . log . info ( \"About to fail..\" ) self . log . warning ( \"Failing.. soooon..\" ) self . log . critical ( \"Ok, you're done.\" ) assert False , \"\"\"ValidateFailureMock was destined to fail..\n\nHere's some extended information about what went wrong.\n\nIt has quite the long string associated with it, including\na few newlines and a list.\n\n- Item 1\n- Item 2\n\n\"\"\"", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-7359", "doc": "how to get list of functions that come within python", "code": "def init_checks_registry():\n    \"\"\"Register all globally visible functions.\n\n    The first argument name is either 'physical_line' or 'logical_line'.\n    \"\"\"\n    mod = inspect.getmodule(register_check)\n    for (name, function) in inspect.getmembers(mod, inspect.isfunction):\n        register_check(function)", "code_tokens": "def init_checks_registry ( ) : mod = inspect . getmodule ( register_check ) for ( name , function ) in inspect . getmembers ( mod , inspect . isfunction ) : register_check ( function )", "docstring_tokens": "Register all globally visible functions .", "label": 1}, {"idx": "cosqa-train-7360", "doc": "python print namedtuple string formatting", "code": "def _prtfmt(self, item_id, dashes):\n        \"\"\"Print object information using a namedtuple and a format pattern.\"\"\"\n        ntprt = self.id2nt[item_id]\n        dct = ntprt._asdict()\n        self.prt.write('{DASHES:{N}}'.format(\n            DASHES=self.fmt_dashes.format(DASHES=dashes, ID=self.nm2prtfmt['ID'].format(**dct)),\n            N=self.dash_len))\n        self.prt.write(\"{INFO}\\n\".format(INFO=self.nm2prtfmt['ITEM'].format(**dct)))", "code_tokens": "def _prtfmt ( self , item_id , dashes ) : ntprt = self . id2nt [ item_id ] dct = ntprt . _asdict ( ) self . prt . write ( '{DASHES:{N}}' . format ( DASHES = self . fmt_dashes . format ( DASHES = dashes , ID = self . nm2prtfmt [ 'ID' ] . format ( * * dct ) ) , N = self . dash_len ) ) self . prt . write ( \"{INFO}\\n\" . format ( INFO = self . nm2prtfmt [ 'ITEM' ] . format ( * * dct ) ) )", "docstring_tokens": "Print object information using a namedtuple and a format pattern .", "label": 1}, {"idx": "cosqa-train-7361", "doc": "how to get memory utilization of a process python", "code": "def get_memory_usage():\n    \"\"\"Gets RAM memory usage\n\n    :return: MB of memory used by this process\n    \"\"\"\n    process = psutil.Process(os.getpid())\n    mem = process.memory_info().rss\n    return mem / (1024 * 1024)", "code_tokens": "def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )", "docstring_tokens": "Gets RAM memory usage", "label": 1}, {"idx": "cosqa-train-7362", "doc": "python print tree structure", "code": "def print_tree(self, indent=2):\n        \"\"\" print_tree: prints out structure of tree\n            Args: indent (int): What level of indentation at which to start printing\n            Returns: None\n        \"\"\"\n        config.LOGGER.info(\"{indent}{data}\".format(indent=\"   \" * indent, data=str(self)))\n        for child in self.children:\n            child.print_tree(indent + 1)", "code_tokens": "def print_tree ( self , indent = 2 ) : config . LOGGER . info ( \"{indent}{data}\" . format ( indent = \"   \" * indent , data = str ( self ) ) ) for child in self . children : child . print_tree ( indent + 1 )", "docstring_tokens": "print_tree : prints out structure of tree Args : indent ( int ) : What level of indentation at which to start printing Returns : None", "label": 1}, {"idx": "cosqa-train-7363", "doc": "how to get method name as string python", "code": "def get_method_name(method):\n    \"\"\"\n    Returns given method name.\n\n    :param method: Method to retrieve the name.\n    :type method: object\n    :return: Method name.\n    :rtype: unicode\n    \"\"\"\n\n    name = get_object_name(method)\n    if name.startswith(\"__\") and not name.endswith(\"__\"):\n        name = \"_{0}{1}\".format(get_object_name(method.im_class), name)\n    return name", "code_tokens": "def get_method_name ( method ) : name = get_object_name ( method ) if name . startswith ( \"__\" ) and not name . endswith ( \"__\" ) : name = \"_{0}{1}\" . format ( get_object_name ( method . im_class ) , name ) return name", "docstring_tokens": "Returns given method name .", "label": 1}, {"idx": "cosqa-train-7364", "doc": "python print with encoding", "code": "def imp_print(self, text, end):\n\t\t\"\"\"Directly send utf8 bytes to stdout\"\"\"\n\t\tsys.stdout.write((text + end).encode(\"utf-8\"))", "code_tokens": "def imp_print ( self , text , end ) : sys . stdout . write ( ( text + end ) . encode ( \"utf-8\" ) )", "docstring_tokens": "Directly send utf8 bytes to stdout", "label": 1}, {"idx": "cosqa-train-7365", "doc": "how to get month end working day in python", "code": "def get_week_start_end_day():\n    \"\"\"\n    Get the week start date and end date\n    \"\"\"\n    t = date.today()\n    wd = t.weekday()\n    return (t - timedelta(wd), t + timedelta(6 - wd))", "code_tokens": "def get_week_start_end_day ( ) : t = date . today ( ) wd = t . weekday ( ) return ( t - timedelta ( wd ) , t + timedelta ( 6 - wd ) )", "docstring_tokens": "Get the week start date and end date", "label": 0}, {"idx": "cosqa-train-7366", "doc": "python process alwasy alive", "code": "def is_alive(self):\n        \"\"\"\n        @rtype:  bool\n        @return: C{True} if the process is currently running.\n        \"\"\"\n        try:\n            self.wait(0)\n        except WindowsError:\n            e = sys.exc_info()[1]\n            return e.winerror == win32.WAIT_TIMEOUT\n        return False", "code_tokens": "def is_alive ( self ) : try : self . wait ( 0 ) except WindowsError : e = sys . exc_info ( ) [ 1 ] return e . winerror == win32 . WAIT_TIMEOUT return False", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-7367", "doc": "how to get python code to prompt user for information", "code": "def string_input(prompt=''):\n    \"\"\"Python 3 input()/Python 2 raw_input()\"\"\"\n    v = sys.version[0]\n    if v == '3':\n        return input(prompt)\n    else:\n        return raw_input(prompt)", "code_tokens": "def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )", "docstring_tokens": "Python 3 input () / Python 2 raw_input ()", "label": 1}, {"idx": "cosqa-train-7368", "doc": "python process killed automatically", "code": "def kill_mprocess(process):\n    \"\"\"kill process\n    Args:\n        process - Popen object for process\n    \"\"\"\n    if process and proc_alive(process):\n        process.terminate()\n        process.communicate()\n    return not proc_alive(process)", "code_tokens": "def kill_mprocess ( process ) : if process and proc_alive ( process ) : process . terminate ( ) process . communicate ( ) return not proc_alive ( process )", "docstring_tokens": "kill process Args : process - Popen object for process", "label": 0}, {"idx": "cosqa-train-7369", "doc": "how to get rid of xml namespaces in python", "code": "def _strip_namespace(self, xml):\n        \"\"\"strips any namespaces from an xml string\"\"\"\n        p = re.compile(b\"xmlns=*[\\\"\\\"][^\\\"\\\"]*[\\\"\\\"]\")\n        allmatches = p.finditer(xml)\n        for match in allmatches:\n            xml = xml.replace(match.group(), b\"\")\n        return xml", "code_tokens": "def _strip_namespace ( self , xml ) : p = re . compile ( b\"xmlns=*[\\\"\\\"][^\\\"\\\"]*[\\\"\\\"]\" ) allmatches = p . finditer ( xml ) for match in allmatches : xml = xml . replace ( match . group ( ) , b\"\" ) return xml", "docstring_tokens": "strips any namespaces from an xml string", "label": 1}, {"idx": "cosqa-train-7370", "doc": "python producing a comma seperated list", "code": "def list_to_csv(value):\n    \"\"\"\n    Converts list to string with comma separated values. For string is no-op.\n    \"\"\"\n    if isinstance(value, (list, tuple, set)):\n        value = \",\".join(value)\n    return value", "code_tokens": "def list_to_csv ( value ) : if isinstance ( value , ( list , tuple , set ) ) : value = \",\" . join ( value ) return value", "docstring_tokens": "Converts list to string with comma separated values . For string is no - op .", "label": 1}, {"idx": "cosqa-train-7371", "doc": "how to get the average of vectors from python", "code": "def ave_list_v3(vec_list):\n    \"\"\"Return the average vector of a list of vectors.\"\"\"\n\n    vec = Vec3(0, 0, 0)\n    for v in vec_list:\n        vec += v\n    num_vecs = float(len(vec_list))\n    vec = Vec3(vec.x / num_vecs, vec.y / num_vecs, vec.z / num_vecs)\n    return vec", "code_tokens": "def ave_list_v3 ( vec_list ) : vec = Vec3 ( 0 , 0 , 0 ) for v in vec_list : vec += v num_vecs = float ( len ( vec_list ) ) vec = Vec3 ( vec . x / num_vecs , vec . y / num_vecs , vec . z / num_vecs ) return vec", "docstring_tokens": "Return the average vector of a list of vectors .", "label": 1}, {"idx": "cosqa-train-7372", "doc": "python programmatically set docstring for instance method", "code": "def inheritdoc(method):\n    \"\"\"Set __doc__ of *method* to __doc__ of *method* in its parent class.\n\n    Since this is used on :class:`.StringMixIn`, the \"parent class\" used is\n    ``str``. This function can be used as a decorator.\n    \"\"\"\n    method.__doc__ = getattr(str, method.__name__).__doc__\n    return method", "code_tokens": "def inheritdoc ( method ) : method . __doc__ = getattr ( str , method . __name__ ) . __doc__ return method", "docstring_tokens": "Set __doc__ of * method * to __doc__ of * method * in its parent class .", "label": 0}, {"idx": "cosqa-train-7373", "doc": "how to get the current url in my browser in python", "code": "def url(self):\n        \"\"\" The url of this window \"\"\"\n        with switch_window(self._browser, self.name):\n            return self._browser.url", "code_tokens": "def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "docstring_tokens": "The url of this window", "label": 1}, {"idx": "cosqa-train-7374", "doc": "python prompt input default", "code": "def input(self, prompt, default=None, show_default=True):\n        \"\"\"Provide a command prompt.\"\"\"\n        return click.prompt(prompt, default=default, show_default=show_default)", "code_tokens": "def input ( self , prompt , default = None , show_default = True ) : return click . prompt ( prompt , default = default , show_default = show_default )", "docstring_tokens": "Provide a command prompt .", "label": 0}, {"idx": "cosqa-train-7375", "doc": "how to get the first and last index of element in list python", "code": "def bisect_index(a, x):\n    \"\"\" Find the leftmost index of an element in a list using binary search.\n\n    Parameters\n    ----------\n    a: list\n        A sorted list.\n    x: arbitrary\n        The element.\n\n    Returns\n    -------\n    int\n        The index.\n\n    \"\"\"\n    i = bisect.bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    raise ValueError", "code_tokens": "def bisect_index ( a , x ) : i = bisect . bisect_left ( a , x ) if i != len ( a ) and a [ i ] == x : return i raise ValueError", "docstring_tokens": "Find the leftmost index of an element in a list using binary search .", "label": 1}, {"idx": "cosqa-train-7376", "doc": "python property just getter", "code": "def value(self):\n        \"\"\"Value of property.\"\"\"\n        if self._prop.fget is None:\n            raise AttributeError('Unable to read attribute')\n        return self._prop.fget(self._obj)", "code_tokens": "def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )", "docstring_tokens": "Value of property .", "label": 0}, {"idx": "cosqa-train-7377", "doc": "how to get the full path of a file in python", "code": "def rel_path(filename):\n    \"\"\"\n    Function that gets relative path to the filename\n    \"\"\"\n    return os.path.join(os.getcwd(), os.path.dirname(__file__), filename)", "code_tokens": "def rel_path ( filename ) : return os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) , filename )", "docstring_tokens": "Function that gets relative path to the filename", "label": 1}, {"idx": "cosqa-train-7378", "doc": "python property object not callable", "code": "def _set_property(self, val, *args):\n        \"\"\"Private method that sets the value currently of the property\"\"\"\n        val = UserClassAdapter._set_property(self, val, *args)\n        if val:\n            Adapter._set_property(self, val, *args)\n        return val", "code_tokens": "def _set_property ( self , val , * args ) : val = UserClassAdapter . _set_property ( self , val , * args ) if val : Adapter . _set_property ( self , val , * args ) return val", "docstring_tokens": "Private method that sets the value currently of the property", "label": 0}, {"idx": "cosqa-train-7379", "doc": "python property of a property", "code": "def value(self):\n        \"\"\"Value of property.\"\"\"\n        if self._prop.fget is None:\n            raise AttributeError('Unable to read attribute')\n        return self._prop.fget(self._obj)", "code_tokens": "def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )", "docstring_tokens": "Value of property .", "label": 0}, {"idx": "cosqa-train-7380", "doc": "how to get the length of a list in python in incemental steps", "code": "def calculate_size(name, data_list):\n    \"\"\" Calculates the request payload size\"\"\"\n    data_size = 0\n    data_size += calculate_size_str(name)\n    data_size += INT_SIZE_IN_BYTES\n    for data_list_item in data_list:\n        data_size += calculate_size_data(data_list_item)\n    return data_size", "code_tokens": "def calculate_size ( name , data_list ) : data_size = 0 data_size += calculate_size_str ( name ) data_size += INT_SIZE_IN_BYTES for data_list_item in data_list : data_size += calculate_size_data ( data_list_item ) return data_size", "docstring_tokens": "Calculates the request payload size", "label": 1}, {"idx": "cosqa-train-7381", "doc": "python protobuf parsefromstring except", "code": "def message_from_string(s, *args, **kws):\n    \"\"\"Parse a string into a Message object model.\n\n    Optional _class and strict are passed to the Parser constructor.\n    \"\"\"\n    from future.backports.email.parser import Parser\n    return Parser(*args, **kws).parsestr(s)", "code_tokens": "def message_from_string ( s , * args , * * kws ) : from future . backports . email . parser import Parser return Parser ( * args , * * kws ) . parsestr ( s )", "docstring_tokens": "Parse a string into a Message object model .", "label": 0}, {"idx": "cosqa-train-7382", "doc": "how to get the number of non whitespace characters in python", "code": "def _count_leading_whitespace(text):\n  \"\"\"Returns the number of characters at the beginning of text that are whitespace.\"\"\"\n  idx = 0\n  for idx, char in enumerate(text):\n    if not char.isspace():\n      return idx\n  return idx + 1", "code_tokens": "def _count_leading_whitespace ( text ) : idx = 0 for idx , char in enumerate ( text ) : if not char . isspace ( ) : return idx return idx + 1", "docstring_tokens": "Returns the number of characters at the beginning of text that are whitespace .", "label": 1}, {"idx": "cosqa-train-7383", "doc": "python pylint disable method", "code": "def IsErrorSuppressedByNolint(category, linenum):\n  \"\"\"Returns true if the specified error category is suppressed on this line.\n\n  Consults the global error_suppressions map populated by\n  ParseNolintSuppressions/ResetNolintSuppressions.\n\n  Args:\n    category: str, the category of the error.\n    linenum: int, the current line number.\n  Returns:\n    bool, True iff the error should be suppressed due to a NOLINT comment.\n  \"\"\"\n  return (linenum in _error_suppressions.get(category, set()) or\n          linenum in _error_suppressions.get(None, set()))", "code_tokens": "def IsErrorSuppressedByNolint ( category , linenum ) : return ( linenum in _error_suppressions . get ( category , set ( ) ) or linenum in _error_suppressions . get ( None , set ( ) ) )", "docstring_tokens": "Returns true if the specified error category is suppressed on this line .", "label": 0}, {"idx": "cosqa-train-7384", "doc": "how to get the parent directory in python", "code": "def get_parent_dir(name):\n    \"\"\"Get the parent directory of a filename.\"\"\"\n    parent_dir = os.path.dirname(os.path.dirname(name))\n    if parent_dir:\n        return parent_dir\n    return os.path.abspath('.')", "code_tokens": "def get_parent_dir ( name ) : parent_dir = os . path . dirname ( os . path . dirname ( name ) ) if parent_dir : return parent_dir return os . path . abspath ( '.' )", "docstring_tokens": "Get the parent directory of a filename .", "label": 1}, {"idx": "cosqa-train-7385", "doc": "python pysaml2 signature verification fails", "code": "def _raise_if_wrong_file_signature(stream):\n    \"\"\" Reads the 4 first bytes of the stream to check that is LASF\"\"\"\n    file_sig = stream.read(len(headers.LAS_FILE_SIGNATURE))\n    if file_sig != headers.LAS_FILE_SIGNATURE:\n        raise errors.PylasError(\n            \"File Signature ({}) is not {}\".format(file_sig, headers.LAS_FILE_SIGNATURE)\n        )", "code_tokens": "def _raise_if_wrong_file_signature ( stream ) : file_sig = stream . read ( len ( headers . LAS_FILE_SIGNATURE ) ) if file_sig != headers . LAS_FILE_SIGNATURE : raise errors . PylasError ( \"File Signature ({}) is not {}\" . format ( file_sig , headers . LAS_FILE_SIGNATURE ) )", "docstring_tokens": "Reads the 4 first bytes of the stream to check that is LASF", "label": 0}, {"idx": "cosqa-train-7386", "doc": "how to get the start and end character from regex findall python", "code": "def unmatched(match):\n    \"\"\"Return unmatched part of re.Match object.\"\"\"\n    start, end = match.span(0)\n    return match.string[:start]+match.string[end:]", "code_tokens": "def unmatched ( match ) : start , end = match . span ( 0 ) return match . string [ : start ] + match . string [ end : ]", "docstring_tokens": "Return unmatched part of re . Match object .", "label": 0}, {"idx": "cosqa-train-7387", "doc": "python python passing to child process using stdin", "code": "def correspond(text):\n    \"\"\"Communicate with the child process without closing stdin.\"\"\"\n    subproc.stdin.write(text)\n    subproc.stdin.flush()\n    return drain()", "code_tokens": "def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )", "docstring_tokens": "Communicate with the child process without closing stdin .", "label": 0}, {"idx": "cosqa-train-7388", "doc": "how to get the value of loss at every iteration in python", "code": "def loss(loss_value):\n  \"\"\"Calculates aggregated mean loss.\"\"\"\n  total_loss = tf.Variable(0.0, False)\n  loss_count = tf.Variable(0, False)\n  total_loss_update = tf.assign_add(total_loss, loss_value)\n  loss_count_update = tf.assign_add(loss_count, 1)\n  loss_op = total_loss / tf.cast(loss_count, tf.float32)\n  return [total_loss_update, loss_count_update], loss_op", "code_tokens": "def loss ( loss_value ) : total_loss = tf . Variable ( 0.0 , False ) loss_count = tf . Variable ( 0 , False ) total_loss_update = tf . assign_add ( total_loss , loss_value ) loss_count_update = tf . assign_add ( loss_count , 1 ) loss_op = total_loss / tf . cast ( loss_count , tf . float32 ) return [ total_loss_update , loss_count_update ] , loss_op", "docstring_tokens": "Calculates aggregated mean loss .", "label": 0}, {"idx": "cosqa-train-7389", "doc": "python qapplication not defined", "code": "def create_app():\n    \"\"\"Create a Qt application.\"\"\"\n    global QT_APP\n    QT_APP = QApplication.instance()\n    if QT_APP is None:  # pragma: no cover\n        QT_APP = QApplication(sys.argv)\n    return QT_APP", "code_tokens": "def create_app ( ) : global QT_APP QT_APP = QApplication . instance ( ) if QT_APP is None : # pragma: no cover QT_APP = QApplication ( sys . argv ) return QT_APP", "docstring_tokens": "Create a Qt application .", "label": 1}, {"idx": "cosqa-train-7390", "doc": "python qdate object to datetime", "code": "def dt_to_qdatetime(dt):\n    \"\"\"Convert a python datetime.datetime object to QDateTime\n\n    :param dt: the datetime object\n    :type dt: :class:`datetime.datetime`\n    :returns: the QDateTime conversion\n    :rtype: :class:`QtCore.QDateTime`\n    :raises: None\n    \"\"\"\n    return QtCore.QDateTime(QtCore.QDate(dt.year, dt.month, dt.day),\n                            QtCore.QTime(dt.hour, dt.minute, dt.second))", "code_tokens": "def dt_to_qdatetime ( dt ) : return QtCore . QDateTime ( QtCore . QDate ( dt . year , dt . month , dt . day ) , QtCore . QTime ( dt . hour , dt . minute , dt . second ) )", "docstring_tokens": "Convert a python datetime . datetime object to QDateTime", "label": 0}, {"idx": "cosqa-train-7391", "doc": "how to get unique items in python", "code": "def unique_items(seq):\n    \"\"\"Return the unique items from iterable *seq* (in order).\"\"\"\n    seen = set()\n    return [x for x in seq if not (x in seen or seen.add(x))]", "code_tokens": "def unique_items ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Return the unique items from iterable * seq * ( in order ) .", "label": 0}, {"idx": "cosqa-train-7392", "doc": "python qdialog close signal", "code": "def done(self, result):\n        \"\"\"save the geometry before dialog is close to restore it later\"\"\"\n        self._geometry = self.geometry()\n        QtWidgets.QDialog.done(self, result)", "code_tokens": "def done ( self , result ) : self . _geometry = self . geometry ( ) QtWidgets . QDialog . done ( self , result )", "docstring_tokens": "save the geometry before dialog is close to restore it later", "label": 1}, {"idx": "cosqa-train-7393", "doc": "how to get unique value from list in python", "code": "def unique_element(ll):\n    \"\"\" returns unique elements from a list preserving the original order \"\"\"\n    seen = {}\n    result = []\n    for item in ll:\n        if item in seen:\n            continue\n        seen[item] = 1\n        result.append(item)\n    return result", "code_tokens": "def unique_element ( ll ) : seen = { } result = [ ] for item in ll : if item in seen : continue seen [ item ] = 1 result . append ( item ) return result", "docstring_tokens": "returns unique elements from a list preserving the original order", "label": 0}, {"idx": "cosqa-train-7394", "doc": "python qpushbutton resize in grid layout", "code": "def resize(self, width, height):\n        \"\"\"\n        Pyqt specific resize callback.\n        \"\"\"\n        if not self.fbo:\n            return\n\n        # pyqt reports sizes in actual buffer size\n        self.width = width // self.widget.devicePixelRatio()\n        self.height = height // self.widget.devicePixelRatio()\n        self.buffer_width = width\n        self.buffer_height = height\n\n        super().resize(width, height)", "code_tokens": "def resize ( self , width , height ) : if not self . fbo : return # pyqt reports sizes in actual buffer size self . width = width // self . widget . devicePixelRatio ( ) self . height = height // self . widget . devicePixelRatio ( ) self . buffer_width = width self . buffer_height = height super ( ) . resize ( width , height )", "docstring_tokens": "Pyqt specific resize callback .", "label": 1}, {"idx": "cosqa-train-7395", "doc": "how to get unique values in python data frame", "code": "def unique_(self, col):\n        \"\"\"\n        Returns unique values in a column\n        \"\"\"\n        try:\n            df = self.df.drop_duplicates(subset=[col], inplace=False)\n            return list(df[col])\n        except Exception as e:\n            self.err(e, \"Can not select unique data\")", "code_tokens": "def unique_ ( self , col ) : try : df = self . df . drop_duplicates ( subset = [ col ] , inplace = False ) return list ( df [ col ] ) except Exception as e : self . err ( e , \"Can not select unique data\" )", "docstring_tokens": "Returns unique values in a column", "label": 1}, {"idx": "cosqa-train-7396", "doc": "python query string parse", "code": "def urlencoded(body, charset='ascii', **kwargs):\n    \"\"\"Converts query strings into native Python objects\"\"\"\n    return parse_query_string(text(body, charset=charset), False)", "code_tokens": "def urlencoded ( body , charset = 'ascii' , * * kwargs ) : return parse_query_string ( text ( body , charset = charset ) , False )", "docstring_tokens": "Converts query strings into native Python objects", "label": 1}, {"idx": "cosqa-train-7397", "doc": "how to get x component of shape in python", "code": "def array_size(x, axis):\n  \"\"\"Calculate the size of `x` along `axis` dimensions only.\"\"\"\n  axis_shape = x.shape if axis is None else tuple(x.shape[a] for a in axis)\n  return max(numpy.prod(axis_shape), 1)", "code_tokens": "def array_size ( x , axis ) : axis_shape = x . shape if axis is None else tuple ( x . shape [ a ] for a in axis ) return max ( numpy . prod ( axis_shape ) , 1 )", "docstring_tokens": "Calculate the size of x along axis dimensions only .", "label": 0}, {"idx": "cosqa-train-7398", "doc": "python queue release memory", "code": "def deinit(self):\n        \"\"\"Deinitialises the PulseIn and releases any hardware and software\n        resources for reuse.\"\"\"\n        # Clean up after ourselves\n        self._process.terminate()\n        procs.remove(self._process)\n        self._mq.remove()\n        queues.remove(self._mq)", "code_tokens": "def deinit ( self ) : # Clean up after ourselves self . _process . terminate ( ) procs . remove ( self . _process ) self . _mq . remove ( ) queues . remove ( self . _mq )", "docstring_tokens": "Deinitialises the PulseIn and releases any hardware and software resources for reuse .", "label": 1}, {"idx": "cosqa-train-7399", "doc": "how to give decimal numbers random python", "code": "def money(min=0, max=10):\n    \"\"\"Return a str of decimal with two digits after a decimal mark.\"\"\"\n    value = random.choice(range(min * 100, max * 100))\n    return \"%1.2f\" % (float(value) / 100)", "code_tokens": "def money ( min = 0 , max = 10 ) : value = random . choice ( range ( min * 100 , max * 100 ) ) return \"%1.2f\" % ( float ( value ) / 100 )", "docstring_tokens": "Return a str of decimal with two digits after a decimal mark .", "label": 1}, {"idx": "cosqa-train-7400", "doc": "python quit all threads", "code": "def wait_until_exit(self):\n        \"\"\" Wait until all the threads are finished.\n\n        \"\"\"\n        [t.join() for t in self.threads]\n\n        self.threads = list()", "code_tokens": "def wait_until_exit ( self ) : [ t . join ( ) for t in self . threads ] self . threads = list ( )", "docstring_tokens": "Wait until all the threads are finished .", "label": 1}, {"idx": "cosqa-train-7401", "doc": "how to give multiline comments in python", "code": "def _comment(string):\n    \"\"\"return string as a comment\"\"\"\n    lines = [line.strip() for line in string.splitlines()]\n    return \"# \" + (\"%s# \" % linesep).join(lines)", "code_tokens": "def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return \"# \" + ( \"%s# \" % linesep ) . join ( lines )", "docstring_tokens": "return string as a comment", "label": 1}, {"idx": "cosqa-train-7402", "doc": "python rabbitmqctl subprocess hangs", "code": "def exec_rabbitmqctl(self, command, args=[], rabbitmqctl_opts=['-q']):\n        \"\"\"\n        Execute a ``rabbitmqctl`` command inside a running container.\n\n        :param command: the command to run\n        :param args: a list of args for the command\n        :param rabbitmqctl_opts:\n            a list of extra options to pass to ``rabbitmqctl``\n        :returns: a tuple of the command exit code and output\n        \"\"\"\n        cmd = ['rabbitmqctl'] + rabbitmqctl_opts + [command] + args\n        return self.inner().exec_run(cmd)", "code_tokens": "def exec_rabbitmqctl ( self , command , args = [ ] , rabbitmqctl_opts = [ '-q' ] ) : cmd = [ 'rabbitmqctl' ] + rabbitmqctl_opts + [ command ] + args return self . inner ( ) . exec_run ( cmd )", "docstring_tokens": "Execute a rabbitmqctl command inside a running container .", "label": 0}, {"idx": "cosqa-train-7403", "doc": "how to give output in new line in print command python", "code": "def out(self, output, newline=True):\n        \"\"\"Outputs a string to the console (stdout).\"\"\"\n        click.echo(output, nl=newline)", "code_tokens": "def out ( self , output , newline = True ) : click . echo ( output , nl = newline )", "docstring_tokens": "Outputs a string to the console ( stdout ) .", "label": 1}, {"idx": "cosqa-train-7404", "doc": "python random 30 character string", "code": "def gen_random_string(str_len):\n    \"\"\" generate random string with specified length\n    \"\"\"\n    return ''.join(\n        random.choice(string.ascii_letters + string.digits) for _ in range(str_len))", "code_tokens": "def gen_random_string ( str_len ) : return '' . join ( random . choice ( string . ascii_letters + string . digits ) for _ in range ( str_len ) )", "docstring_tokens": "generate random string with specified length", "label": 1}, {"idx": "cosqa-train-7405", "doc": "how to globaloze a variable in python in multiple definition", "code": "def set_global(node: Node, key: str, value: Any):\n    \"\"\"Adds passed value to node's globals\"\"\"\n    node.node_globals[key] = value", "code_tokens": "def set_global ( node : Node , key : str , value : Any ) : node . node_globals [ key ] = value", "docstring_tokens": "Adds passed value to node s globals", "label": 0}, {"idx": "cosqa-train-7406", "doc": "python random function non repeating", "code": "def sometimesish(fn):\n    \"\"\"\n    Has a 50/50 chance of calling a function\n    \"\"\"\n    def wrapped(*args, **kwargs):\n        if random.randint(1, 2) == 1:\n            return fn(*args, **kwargs)\n\n    return wrapped", "code_tokens": "def sometimesish ( fn ) : def wrapped ( * args , * * kwargs ) : if random . randint ( 1 , 2 ) == 1 : return fn ( * args , * * kwargs ) return wrapped", "docstring_tokens": "Has a 50 / 50 chance of calling a function", "label": 1}, {"idx": "cosqa-train-7407", "doc": "how to grab the current url in my browser python", "code": "def url(self):\n        \"\"\" The url of this window \"\"\"\n        with switch_window(self._browser, self.name):\n            return self._browser.url", "code_tokens": "def url ( self ) : with switch_window ( self . _browser , self . name ) : return self . _browser . url", "docstring_tokens": "The url of this window", "label": 0}, {"idx": "cosqa-train-7408", "doc": "python random noise image", "code": "def uniform_noise(points):\n    \"\"\"Init a uniform noise variable.\"\"\"\n    return np.random.rand(1) * np.random.uniform(points, 1) \\\n        + random.sample([2, -2], 1)", "code_tokens": "def uniform_noise ( points ) : return np . random . rand ( 1 ) * np . random . uniform ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "docstring_tokens": "Init a uniform noise variable .", "label": 0}, {"idx": "cosqa-train-7409", "doc": "how to hash a binary file in python", "code": "def generate_hash(filepath):\n    \"\"\"Public function that reads a local file and generates a SHA256 hash digest for it\"\"\"\n    fr = FileReader(filepath)\n    data = fr.read_bin()\n    return _calculate_sha256(data)", "code_tokens": "def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )", "docstring_tokens": "Public function that reads a local file and generates a SHA256 hash digest for it", "label": 1}, {"idx": "cosqa-train-7410", "doc": "how to hash a file in python", "code": "def generate_hash(filepath):\n    \"\"\"Public function that reads a local file and generates a SHA256 hash digest for it\"\"\"\n    fr = FileReader(filepath)\n    data = fr.read_bin()\n    return _calculate_sha256(data)", "code_tokens": "def generate_hash ( filepath ) : fr = FileReader ( filepath ) data = fr . read_bin ( ) return _calculate_sha256 ( data )", "docstring_tokens": "Public function that reads a local file and generates a SHA256 hash digest for it", "label": 1}, {"idx": "cosqa-train-7411", "doc": "python random sample based on pmf", "code": "def SampleSum(dists, n):\n    \"\"\"Draws a sample of sums from a list of distributions.\n\n    dists: sequence of Pmf or Cdf objects\n    n: sample size\n\n    returns: new Pmf of sums\n    \"\"\"\n    pmf = MakePmfFromList(RandomSum(dists) for i in xrange(n))\n    return pmf", "code_tokens": "def SampleSum ( dists , n ) : pmf = MakePmfFromList ( RandomSum ( dists ) for i in xrange ( n ) ) return pmf", "docstring_tokens": "Draws a sample of sums from a list of distributions .", "label": 1}, {"idx": "cosqa-train-7412", "doc": "how to hash variable in python 3", "code": "def _string_hash(s):\n    \"\"\"String hash (djb2) with consistency between py2/py3 and persistency between runs (unlike `hash`).\"\"\"\n    h = 5381\n    for c in s:\n        h = h * 33 + ord(c)\n    return h", "code_tokens": "def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h", "docstring_tokens": "String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) .", "label": 1}, {"idx": "cosqa-train-7413", "doc": "python range bound array", "code": "def _interval_to_bound_points(array):\n    \"\"\"\n    Helper function which returns an array\n    with the Intervals' boundaries.\n    \"\"\"\n\n    array_boundaries = np.array([x.left for x in array])\n    array_boundaries = np.concatenate(\n        (array_boundaries, np.array([array[-1].right])))\n\n    return array_boundaries", "code_tokens": "def _interval_to_bound_points ( array ) : array_boundaries = np . array ( [ x . left for x in array ] ) array_boundaries = np . concatenate ( ( array_boundaries , np . array ( [ array [ - 1 ] . right ] ) ) ) return array_boundaries", "docstring_tokens": "Helper function which returns an array with the Intervals boundaries .", "label": 1}, {"idx": "cosqa-train-7414", "doc": "how to have python highlight some phrase", "code": "def highlight_words(string, keywords, cls_name='highlighted'):\n    \"\"\" Given an list of words, this function highlights the matched words in the given string. \"\"\"\n\n    if not keywords:\n        return string\n    if not string:\n        return ''\n    include, exclude = get_text_tokenizer(keywords)\n    highlighted = highlight_text(include, string, cls_name, words=True)\n    return highlighted", "code_tokens": "def highlight_words ( string , keywords , cls_name = 'highlighted' ) : if not keywords : return string if not string : return '' include , exclude = get_text_tokenizer ( keywords ) highlighted = highlight_text ( include , string , cls_name , words = True ) return highlighted", "docstring_tokens": "Given an list of words this function highlights the matched words in the given string .", "label": 0}, {"idx": "cosqa-train-7415", "doc": "python read environment variables with default", "code": "def get_env_default(self, variable, default):\n        \"\"\"\n        Fetch environment variables, returning a default if not found\n        \"\"\"\n        if variable in os.environ:\n            env_var = os.environ[variable]\n        else:\n            env_var = default\n        return env_var", "code_tokens": "def get_env_default ( self , variable , default ) : if variable in os . environ : env_var = os . environ [ variable ] else : env_var = default return env_var", "docstring_tokens": "Fetch environment variables returning a default if not found", "label": 0}, {"idx": "cosqa-train-7416", "doc": "how to have python prompt", "code": "def _normal_prompt(self):\n        \"\"\"\n        Flushes the prompt before requesting the input\n\n        :return: The command line\n        \"\"\"\n        sys.stdout.write(self.__get_ps1())\n        sys.stdout.flush()\n        return safe_input()", "code_tokens": "def _normal_prompt ( self ) : sys . stdout . write ( self . __get_ps1 ( ) ) sys . stdout . flush ( ) return safe_input ( )", "docstring_tokens": "Flushes the prompt before requesting the input", "label": 0}, {"idx": "cosqa-train-7417", "doc": "python read file byte buffer", "code": "def read_string(buff, byteorder='big'):\n    \"\"\"Read a string from a file-like object.\"\"\"\n    length = read_numeric(USHORT, buff, byteorder)\n    return buff.read(length).decode('utf-8')", "code_tokens": "def read_string ( buff , byteorder = 'big' ) : length = read_numeric ( USHORT , buff , byteorder ) return buff . read ( length ) . decode ( 'utf-8' )", "docstring_tokens": "Read a string from a file - like object .", "label": 0}, {"idx": "cosqa-train-7418", "doc": "how to hide api key python", "code": "def api_home(request, key=None, hproPk=None):\n    \"\"\"Show the home page for the API with all methods\"\"\"\n\n    if not check_api_key(request, key, hproPk):\n        return HttpResponseForbidden\n\n    return render_to_response('plugIt/api.html', {}, context_instance=RequestContext(request))", "code_tokens": "def api_home ( request , key = None , hproPk = None ) : if not check_api_key ( request , key , hproPk ) : return HttpResponseForbidden return render_to_response ( 'plugIt/api.html' , { } , context_instance = RequestContext ( request ) )", "docstring_tokens": "Show the home page for the API with all methods", "label": 0}, {"idx": "cosqa-train-7419", "doc": "python read from s3 to a string", "code": "def get_as_string(self, s3_path, encoding='utf-8'):\n        \"\"\"\n        Get the contents of an object stored in S3 as string.\n\n        :param s3_path: URL for target S3 location\n        :param encoding: Encoding to decode bytes to string\n        :return: File contents as a string\n        \"\"\"\n        content = self.get_as_bytes(s3_path)\n        return content.decode(encoding)", "code_tokens": "def get_as_string ( self , s3_path , encoding = 'utf-8' ) : content = self . get_as_bytes ( s3_path ) return content . decode ( encoding )", "docstring_tokens": "Get the contents of an object stored in S3 as string .", "label": 1}, {"idx": "cosqa-train-7420", "doc": "how to hit backspace in python without deleting code", "code": "def backward_delete_word(self, e): # (Control-Rubout)\n        u\"\"\"Delete the character behind the cursor. A numeric argument means\n        to kill the characters instead of deleting them.\"\"\"\n        self.l_buffer.backward_delete_word(self.argument_reset)\n        self.finalize()", "code_tokens": "def backward_delete_word ( self , e ) : # (Control-Rubout)\n self . l_buffer . backward_delete_word ( self . argument_reset ) self . finalize ( )", "docstring_tokens": "u Delete the character behind the cursor . A numeric argument means to kill the characters instead of deleting them .", "label": 1}, {"idx": "cosqa-train-7421", "doc": "python read geotiff gdal", "code": "def load_tiff(file):\n    \"\"\"\n    Load a geotiff raster keeping ndv values using a masked array\n\n    Usage:\n            data = load_tiff(file)\n    \"\"\"\n    ndv, xsize, ysize, geot, projection, datatype = get_geo_info(file)\n    data = gdalnumeric.LoadFile(file)\n    data = np.ma.masked_array(data, mask=data == ndv, fill_value=ndv)\n    return data", "code_tokens": "def load_tiff ( file ) : ndv , xsize , ysize , geot , projection , datatype = get_geo_info ( file ) data = gdalnumeric . LoadFile ( file ) data = np . ma . masked_array ( data , mask = data == ndv , fill_value = ndv ) return data", "docstring_tokens": "Load a geotiff raster keeping ndv values using a masked array", "label": 1}, {"idx": "cosqa-train-7422", "doc": "how to implement drag and drop in python", "code": "def drag_and_drop(self, droppable):\n        \"\"\"\n        Performs drag a element to another elmenet.\n\n        Currently works only on Chrome driver.\n        \"\"\"\n        self.scroll_to()\n        ActionChains(self.parent.driver).drag_and_drop(self._element, droppable._element).perform()", "code_tokens": "def drag_and_drop ( self , droppable ) : self . scroll_to ( ) ActionChains ( self . parent . driver ) . drag_and_drop ( self . _element , droppable . _element ) . perform ( )", "docstring_tokens": "Performs drag a element to another elmenet .", "label": 0}, {"idx": "cosqa-train-7423", "doc": "python read json file iterate", "code": "def json_iter (path):\n    \"\"\"\n    iterator for JSON-per-line in a file pattern\n    \"\"\"\n    with open(path, 'r') as f:\n        for line in f.readlines():\n            yield json.loads(line)", "code_tokens": "def json_iter ( path ) : with open ( path , 'r' ) as f : for line in f . readlines ( ) : yield json . loads ( line )", "docstring_tokens": "iterator for JSON - per - line in a file pattern", "label": 1}, {"idx": "cosqa-train-7424", "doc": "how to implement eof in python", "code": "def do_EOF(self, args):\n        \"\"\"Exit on system end of file character\"\"\"\n        if _debug: ConsoleCmd._debug(\"do_EOF %r\", args)\n        return self.do_exit(args)", "code_tokens": "def do_EOF ( self , args ) : if _debug : ConsoleCmd . _debug ( \"do_EOF %r\" , args ) return self . do_exit ( args )", "docstring_tokens": "Exit on system end of file character", "label": 1}, {"idx": "cosqa-train-7425", "doc": "python read json to ordered dictionary", "code": "def _read_json_file(self, json_file):\n        \"\"\" Helper function to read JSON file as OrderedDict \"\"\"\n\n        self.log.debug(\"Reading '%s' JSON file...\" % json_file)\n\n        with open(json_file, 'r') as f:\n            return json.load(f, object_pairs_hook=OrderedDict)", "code_tokens": "def _read_json_file ( self , json_file ) : self . log . debug ( \"Reading '%s' JSON file...\" % json_file ) with open ( json_file , 'r' ) as f : return json . load ( f , object_pairs_hook = OrderedDict )", "docstring_tokens": "Helper function to read JSON file as OrderedDict", "label": 1}, {"idx": "cosqa-train-7426", "doc": "how to include traceback in error message python", "code": "def format_exception(e):\n    \"\"\"Returns a string containing the type and text of the exception.\n\n    \"\"\"\n    from .utils.printing import fill\n    return '\\n'.join(fill(line) for line in traceback.format_exception_only(type(e), e))", "code_tokens": "def format_exception ( e ) : from . utils . printing import fill return '\\n' . join ( fill ( line ) for line in traceback . format_exception_only ( type ( e ) , e ) )", "docstring_tokens": "Returns a string containing the type and text of the exception .", "label": 1}, {"idx": "cosqa-train-7427", "doc": "python read lambda from file", "code": "def lambda_from_file(python_file):\n    \"\"\"\n    Reads a python file and returns a awslambda.Code object\n    :param python_file:\n    :return:\n    \"\"\"\n    lambda_function = []\n    with open(python_file, 'r') as f:\n        lambda_function.extend(f.read().splitlines())\n\n    return awslambda.Code(ZipFile=(Join('\\n', lambda_function)))", "code_tokens": "def lambda_from_file ( python_file ) : lambda_function = [ ] with open ( python_file , 'r' ) as f : lambda_function . extend ( f . read ( ) . splitlines ( ) ) return awslambda . Code ( ZipFile = ( Join ( '\\n' , lambda_function ) ) )", "docstring_tokens": "Reads a python file and returns a awslambda . Code object : param python_file : : return :", "label": 1}, {"idx": "cosqa-train-7428", "doc": "how to insert arrows on plots python", "code": "def add_arrow(self, x1, y1, x2, y2, **kws):\n        \"\"\"add arrow to plot\"\"\"\n        self.panel.add_arrow(x1, y1, x2, y2, **kws)", "code_tokens": "def add_arrow ( self , x1 , y1 , x2 , y2 , * * kws ) : self . panel . add_arrow ( x1 , y1 , x2 , y2 , * * kws )", "docstring_tokens": "add arrow to plot", "label": 1}, {"idx": "cosqa-train-7429", "doc": "python read list of tuples from file", "code": "def readTuple(self, line, n=3):\n        \"\"\" Reads a tuple of numbers. e.g. vertices, normals or teture coords.\n        \"\"\"\n        numbers = [num for num in line.split(' ') if num]\n        return [float(num) for num in numbers[1:n + 1]]", "code_tokens": "def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]", "docstring_tokens": "Reads a tuple of numbers . e . g . vertices normals or teture coords .", "label": 1}, {"idx": "cosqa-train-7430", "doc": "how to inspect object in python", "code": "def stats(self):\n        \"\"\" shotcut to pull out useful info for interactive use \"\"\"\n        printDebug(\"Classes.....: %d\" % len(self.all_classes))\n        printDebug(\"Properties..: %d\" % len(self.all_properties))", "code_tokens": "def stats ( self ) : printDebug ( \"Classes.....: %d\" % len ( self . all_classes ) ) printDebug ( \"Properties..: %d\" % len ( self . all_properties ) )", "docstring_tokens": "shotcut to pull out useful info for interactive use", "label": 1}, {"idx": "cosqa-train-7431", "doc": "python read tif image get array", "code": "def ReadTif(tifFile):\n        \"\"\"Reads a tif file to a 2D NumPy array\"\"\"\n        img = Image.open(tifFile)\n        img = np.array(img)\n        return img", "code_tokens": "def ReadTif ( tifFile ) : img = Image . open ( tifFile ) img = np . array ( img ) return img", "docstring_tokens": "Reads a tif file to a 2D NumPy array", "label": 1}, {"idx": "cosqa-train-7432", "doc": "how to iterate over a line in a file word by word in python", "code": "def extract_words(lines):\n    \"\"\"\n    Extract from the given iterable of lines the list of words.\n\n    :param lines: an iterable of lines;\n    :return: a generator of words of lines.\n    \"\"\"\n    for line in lines:\n        for word in re.findall(r\"\\w+\", line):\n            yield word", "code_tokens": "def extract_words ( lines ) : for line in lines : for word in re . findall ( r\"\\w+\" , line ) : yield word", "docstring_tokens": "Extract from the given iterable of lines the list of words .", "label": 0}, {"idx": "cosqa-train-7433", "doc": "python read tuples from file", "code": "def readTuple(self, line, n=3):\n        \"\"\" Reads a tuple of numbers. e.g. vertices, normals or teture coords.\n        \"\"\"\n        numbers = [num for num in line.split(' ') if num]\n        return [float(num) for num in numbers[1:n + 1]]", "code_tokens": "def readTuple ( self , line , n = 3 ) : numbers = [ num for num in line . split ( ' ' ) if num ] return [ float ( num ) for num in numbers [ 1 : n + 1 ] ]", "docstring_tokens": "Reads a tuple of numbers . e . g . vertices normals or teture coords .", "label": 1}, {"idx": "cosqa-train-7434", "doc": "how to join *args into 1 string python", "code": "def kwargs_to_string(kwargs):\n    \"\"\"\n    Given a set of kwargs, turns them into a string which can then be passed to a command.\n    :param kwargs: kwargs from a function call.\n    :return: outstr: A string, which is '' if no kwargs were given, and the kwargs in string format otherwise.\n    \"\"\"\n    outstr = ''\n    for arg in kwargs:\n        outstr += ' -{} {}'.format(arg, kwargs[arg])\n    return outstr", "code_tokens": "def kwargs_to_string ( kwargs ) : outstr = '' for arg in kwargs : outstr += ' -{} {}' . format ( arg , kwargs [ arg ] ) return outstr", "docstring_tokens": "Given a set of kwargs turns them into a string which can then be passed to a command . : param kwargs : kwargs from a function call . : return : outstr : A string which is if no kwargs were given and the kwargs in string format otherwise .", "label": 1}, {"idx": "cosqa-train-7435", "doc": "python read whole file as a string", "code": "def file_to_str(fname):\n    \"\"\"\n    Read a file into a string\n    PRE: fname is a small file (to avoid hogging memory and its discontents)\n    \"\"\"\n    data = None\n    # rU = read with Universal line terminator\n    with open(fname, 'rU') as fd:\n        data = fd.read()\n    return data", "code_tokens": "def file_to_str ( fname ) : data = None # rU = read with Universal line terminator with open ( fname , 'rU' ) as fd : data = fd . read ( ) return data", "docstring_tokens": "Read a file into a string PRE : fname is a small file ( to avoid hogging memory and its discontents )", "label": 1}, {"idx": "cosqa-train-7436", "doc": "how to judge a string is uuid type in python", "code": "def valid_uuid(value):\n    \"\"\" Check if value is a valid UUID. \"\"\"\n\n    try:\n        uuid.UUID(value, version=4)\n        return True\n    except (TypeError, ValueError, AttributeError):\n        return False", "code_tokens": "def valid_uuid ( value ) : try : uuid . UUID ( value , version = 4 ) return True except ( TypeError , ValueError , AttributeError ) : return False", "docstring_tokens": "Check if value is a valid UUID .", "label": 1}, {"idx": "cosqa-train-7437", "doc": "python read xx/xx/xxx datetime from string", "code": "def _read_date_from_string(str1):\n    \"\"\"\n    Reads the date from a string in the format YYYY/MM/DD and returns\n    :class: datetime.date\n    \"\"\"\n    full_date = [int(x) for x in str1.split('/')]\n    return datetime.date(full_date[0], full_date[1], full_date[2])", "code_tokens": "def _read_date_from_string ( str1 ) : full_date = [ int ( x ) for x in str1 . split ( '/' ) ] return datetime . date ( full_date [ 0 ] , full_date [ 1 ] , full_date [ 2 ] )", "docstring_tokens": "Reads the date from a string in the format YYYY / MM / DD and returns : class : datetime . date", "label": 0}, {"idx": "cosqa-train-7438", "doc": "how to keep count the number of time something happens in python", "code": "def seq():\n    \"\"\"\n    Counts up sequentially from a number based on the current time\n\n    :rtype int:\n    \"\"\"\n    current_frame     = inspect.currentframe().f_back\n    trace_string      = \"\"\n    while current_frame.f_back:\n      trace_string = trace_string + current_frame.f_back.f_code.co_name\n      current_frame = current_frame.f_back\n    return counter.get_from_trace(trace_string)", "code_tokens": "def seq ( ) : current_frame = inspect . currentframe ( ) . f_back trace_string = \"\" while current_frame . f_back : trace_string = trace_string + current_frame . f_back . f_code . co_name current_frame = current_frame . f_back return counter . get_from_trace ( trace_string )", "docstring_tokens": "Counts up sequentially from a number based on the current time", "label": 1}, {"idx": "cosqa-train-7439", "doc": "python read/write dict to file json", "code": "def _write_json(file, contents):\n    \"\"\"Write a dict to a JSON file.\"\"\"\n    with open(file, 'w') as f:\n        return json.dump(contents, f, indent=2, sort_keys=True)", "code_tokens": "def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )", "docstring_tokens": "Write a dict to a JSON file .", "label": 1}, {"idx": "cosqa-train-7440", "doc": "how to keep the data frame column name and make the value empty python", "code": "def add_blank_row(self, label):\n        \"\"\"\n        Add a blank row with only an index value to self.df.\n        This is done inplace.\n        \"\"\"\n        col_labels = self.df.columns\n        blank_item = pd.Series({}, index=col_labels, name=label)\n        # use .loc to add in place (append won't do that)\n        self.df.loc[blank_item.name] = blank_item\n        return self.df", "code_tokens": "def add_blank_row ( self , label ) : col_labels = self . df . columns blank_item = pd . Series ( { } , index = col_labels , name = label ) # use .loc to add in place (append won't do that) self . df . loc [ blank_item . name ] = blank_item return self . df", "docstring_tokens": "Add a blank row with only an index value to self . df . This is done inplace .", "label": 1}, {"idx": "cosqa-train-7441", "doc": "python recursive object to dict", "code": "def as_dict(self):\n        \"\"\"Return all child objects in nested dict.\"\"\"\n        dicts = [x.as_dict for x in self.children]\n        return {'{0} {1}'.format(self.name, self.value): dicts}", "code_tokens": "def as_dict ( self ) : dicts = [ x . as_dict for x in self . children ] return { '{0} {1}' . format ( self . name , self . value ) : dicts }", "docstring_tokens": "Return all child objects in nested dict .", "label": 1}, {"idx": "cosqa-train-7442", "doc": "how to know if a list is sorted in python", "code": "def issorted(list_, op=operator.le):\n    \"\"\"\n    Determines if a list is sorted\n\n    Args:\n        list_ (list):\n        op (func): sorted operation (default=operator.le)\n\n    Returns:\n        bool : True if the list is sorted\n    \"\"\"\n    return all(op(list_[ix], list_[ix + 1]) for ix in range(len(list_) - 1))", "code_tokens": "def issorted ( list_ , op = operator . le ) : return all ( op ( list_ [ ix ] , list_ [ ix + 1 ] ) for ix in range ( len ( list_ ) - 1 ) )", "docstring_tokens": "Determines if a list is sorted", "label": 0}, {"idx": "cosqa-train-7443", "doc": "python redis get return none", "code": "def get(self, key):\n        \"\"\"Get a value from the cache.\n\n        Returns None if the key is not in the cache.\n        \"\"\"\n        value = redis_conn.get(key)\n\n        if value is not None:\n            value = pickle.loads(value)\n\n        return value", "code_tokens": "def get ( self , key ) : value = redis_conn . get ( key ) if value is not None : value = pickle . loads ( value ) return value", "docstring_tokens": "Get a value from the cache .", "label": 0}, {"idx": "cosqa-train-7444", "doc": "how to know the kind of data python", "code": "def type(self):\n        \"\"\"Returns type of the data for the given FeatureType.\"\"\"\n        if self is FeatureType.TIMESTAMP:\n            return list\n        if self is FeatureType.BBOX:\n            return BBox\n        return dict", "code_tokens": "def type ( self ) : if self is FeatureType . TIMESTAMP : return list if self is FeatureType . BBOX : return BBox return dict", "docstring_tokens": "Returns type of the data for the given FeatureType .", "label": 0}, {"idx": "cosqa-train-7445", "doc": "python redis how to check hash doesn't exist", "code": "def __contains__(self, key):\n        \"\"\"Return ``True`` if *key* is present, else ``False``.\"\"\"\n        pickled_key = self._pickle_key(key)\n        return bool(self.redis.hexists(self.key, pickled_key))", "code_tokens": "def __contains__ ( self , key ) : pickled_key = self . _pickle_key ( key ) return bool ( self . redis . hexists ( self . key , pickled_key ) )", "docstring_tokens": "Return True if * key * is present else False .", "label": 0}, {"idx": "cosqa-train-7446", "doc": "how to know the memory usage of current python process in linux", "code": "def get_memory_usage():\n    \"\"\"Gets RAM memory usage\n\n    :return: MB of memory used by this process\n    \"\"\"\n    process = psutil.Process(os.getpid())\n    mem = process.memory_info().rss\n    return mem / (1024 * 1024)", "code_tokens": "def get_memory_usage ( ) : process = psutil . Process ( os . getpid ( ) ) mem = process . memory_info ( ) . rss return mem / ( 1024 * 1024 )", "docstring_tokens": "Gets RAM memory usage", "label": 1}, {"idx": "cosqa-train-7447", "doc": "python redis set function return none", "code": "def get_instance(key, expire=None):\n    \"\"\"Return an instance of RedisSet.\"\"\"\n    global _instances\n    try:\n        instance = _instances[key]\n    except KeyError:\n        instance = RedisSet(\n            key,\n            _redis,\n            expire=expire\n        )\n        _instances[key] = instance\n\n    return instance", "code_tokens": "def get_instance ( key , expire = None ) : global _instances try : instance = _instances [ key ] except KeyError : instance = RedisSet ( key , _redis , expire = expire ) _instances [ key ] = instance return instance", "docstring_tokens": "Return an instance of RedisSet .", "label": 1}, {"idx": "cosqa-train-7448", "doc": "how to label each sentence in a documentin python", "code": "def tag(self, nerdoc):\n        \"\"\"Tag the given document.\n        Parameters\n        ----------\n        nerdoc: estnltk.estner.Document\n            The document to be tagged.\n\n        Returns\n        -------\n        labels: list of lists of str\n            Predicted token Labels for each sentence in the document\n        \"\"\"\n\n        labels = []\n        for snt in nerdoc.sentences:\n            xseq = [t.feature_list() for t in snt]\n            yseq = self.tagger.tag(xseq)\n            labels.append(yseq)\n        return labels", "code_tokens": "def tag ( self , nerdoc ) : labels = [ ] for snt in nerdoc . sentences : xseq = [ t . feature_list ( ) for t in snt ] yseq = self . tagger . tag ( xseq ) labels . append ( yseq ) return labels", "docstring_tokens": "Tag the given document . Parameters ---------- nerdoc : estnltk . estner . Document The document to be tagged .", "label": 1}, {"idx": "cosqa-train-7449", "doc": "python reex capital and lowercase", "code": "def decamelise(text):\n    \"\"\"Convert CamelCase to lower_and_underscore.\"\"\"\n    s = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', text)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s).lower()", "code_tokens": "def decamelise ( text ) : s = re . sub ( '(.)([A-Z][a-z]+)' , r'\\1_\\2' , text ) return re . sub ( '([a-z0-9])([A-Z])' , r'\\1_\\2' , s ) . lower ( )", "docstring_tokens": "Convert CamelCase to lower_and_underscore .", "label": 1}, {"idx": "cosqa-train-7450", "doc": "how to let width in python", "code": "def text_width(string, font_name, font_size):\n    \"\"\"Determine with width in pixels of string.\"\"\"\n    return stringWidth(string, fontName=font_name, fontSize=font_size)", "code_tokens": "def text_width ( string , font_name , font_size ) : return stringWidth ( string , fontName = font_name , fontSize = font_size )", "docstring_tokens": "Determine with width in pixels of string .", "label": 1}, {"idx": "cosqa-train-7451", "doc": "python refering hash as a letter", "code": "def _string_hash(s):\n    \"\"\"String hash (djb2) with consistency between py2/py3 and persistency between runs (unlike `hash`).\"\"\"\n    h = 5381\n    for c in s:\n        h = h * 33 + ord(c)\n    return h", "code_tokens": "def _string_hash ( s ) : h = 5381 for c in s : h = h * 33 + ord ( c ) return h", "docstring_tokens": "String hash ( djb2 ) with consistency between py2 / py3 and persistency between runs ( unlike hash ) .", "label": 1}, {"idx": "cosqa-train-7452", "doc": "how to load a ubyte file in python", "code": "async def load_unicode(reader):\n    \"\"\"\n    Loads UTF8 string\n    :param reader:\n    :return:\n    \"\"\"\n    ivalue = await load_uvarint(reader)\n    fvalue = bytearray(ivalue)\n    await reader.areadinto(fvalue)\n    return str(fvalue, 'utf8')", "code_tokens": "async def load_unicode ( reader ) : ivalue = await load_uvarint ( reader ) fvalue = bytearray ( ivalue ) await reader . areadinto ( fvalue ) return str ( fvalue , 'utf8' )", "docstring_tokens": "Loads UTF8 string : param reader : : return :", "label": 0}, {"idx": "cosqa-train-7453", "doc": "python regex custom delimiter", "code": "def make_regex(separator):\n    \"\"\"Utility function to create regexp for matching escaped separators\n    in strings.\n\n    \"\"\"\n    return re.compile(r'(?:' + re.escape(separator) + r')?((?:[^' +\n                      re.escape(separator) + r'\\\\]|\\\\.)+)')", "code_tokens": "def make_regex ( separator ) : return re . compile ( r'(?:' + re . escape ( separator ) + r')?((?:[^' + re . escape ( separator ) + r'\\\\]|\\\\.)+)' )", "docstring_tokens": "Utility function to create regexp for matching escaped separators in strings .", "label": 0}, {"idx": "cosqa-train-7454", "doc": "how to log error is python", "code": "def on_IOError(self, e):\n        \"\"\" Handle an IOError exception. \"\"\"\n\n        sys.stderr.write(\"Error: %s: \\\"%s\\\"\\n\" % (e.strerror, e.filename))", "code_tokens": "def on_IOError ( self , e ) : sys . stderr . write ( \"Error: %s: \\\"%s\\\"\\n\" % ( e . strerror , e . filename ) )", "docstring_tokens": "Handle an IOError exception .", "label": 1}, {"idx": "cosqa-train-7455", "doc": "python regex get named matches", "code": "def _namematcher(regex):\n    \"\"\"Checks if a target name matches with an input regular expression.\"\"\"\n\n    matcher = re_compile(regex)\n\n    def match(target):\n        target_name = getattr(target, '__name__', '')\n        result = matcher.match(target_name)\n        return result\n\n    return match", "code_tokens": "def _namematcher ( regex ) : matcher = re_compile ( regex ) def match ( target ) : target_name = getattr ( target , '__name__' , '' ) result = matcher . match ( target_name ) return result return match", "docstring_tokens": "Checks if a target name matches with an input regular expression .", "label": 1}, {"idx": "cosqa-train-7456", "doc": "how to log raised error in python log file", "code": "def error(self, text):\n\t\t\"\"\" Ajout d'un message de log de type ERROR \"\"\"\n\t\tself.logger.error(\"{}{}\".format(self.message_prefix, text))", "code_tokens": "def error ( self , text ) : self . logger . error ( \"{}{}\" . format ( self . message_prefix , text ) )", "docstring_tokens": "Ajout d un message de log de type ERROR", "label": 0}, {"idx": "cosqa-train-7457", "doc": "python regex validate email", "code": "def is_valid_email(email):\n    \"\"\"\n    Check if email is valid\n    \"\"\"\n    pattern = re.compile(r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+')\n    return bool(pattern.match(email))", "code_tokens": "def is_valid_email ( email ) : pattern = re . compile ( r'[\\w\\.-]+@[\\w\\.-]+[.]\\w+' ) return bool ( pattern . match ( email ) )", "docstring_tokens": "Check if email is valid", "label": 0}, {"idx": "cosqa-train-7458", "doc": "how to make a base to decimal converter for base 37 in python", "code": "def int2str(num, radix=10, alphabet=BASE85):\n    \"\"\"helper function for quick base conversions from integers to strings\"\"\"\n    return NumConv(radix, alphabet).int2str(num)", "code_tokens": "def int2str ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . int2str ( num )", "docstring_tokens": "helper function for quick base conversions from integers to strings", "label": 1}, {"idx": "cosqa-train-7459", "doc": "python regions of an array", "code": "def select_from_array(cls, array, identifier):\n        \"\"\"Return a region from a numpy array.\n        \n        :param array: :class:`numpy.ndarray`\n        :param identifier: value representing the region to select in the array\n        :returns: :class:`jicimagelib.region.Region`\n        \"\"\"\n\n        base_array = np.zeros(array.shape)\n        array_coords = np.where(array == identifier)\n        base_array[array_coords] = 1\n\n        return cls(base_array)", "code_tokens": "def select_from_array ( cls , array , identifier ) : base_array = np . zeros ( array . shape ) array_coords = np . where ( array == identifier ) base_array [ array_coords ] = 1 return cls ( base_array )", "docstring_tokens": "Return a region from a numpy array . : param array : : class : numpy . ndarray : param identifier : value representing the region to select in the array : returns : : class : jicimagelib . region . Region", "label": 0}, {"idx": "cosqa-train-7460", "doc": "how to make a char lowercase python", "code": "def to_snake_case(name):\n    \"\"\" Given a name in camelCase return in snake_case \"\"\"\n    s1 = FIRST_CAP_REGEX.sub(r'\\1_\\2', name)\n    return ALL_CAP_REGEX.sub(r'\\1_\\2', s1).lower()", "code_tokens": "def to_snake_case ( name ) : s1 = FIRST_CAP_REGEX . sub ( r'\\1_\\2' , name ) return ALL_CAP_REGEX . sub ( r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Given a name in camelCase return in snake_case", "label": 1}, {"idx": "cosqa-train-7461", "doc": "python register a service", "code": "def register_service(self, service):\n        \"\"\"\n            Register service into the system. Called by Services.\n        \"\"\"\n        if service not in self.services:\n            self.services.append(service)", "code_tokens": "def register_service ( self , service ) : if service not in self . services : self . services . append ( service )", "docstring_tokens": "Register service into the system . Called by Services .", "label": 1}, {"idx": "cosqa-train-7462", "doc": "python remove all accents from string", "code": "def unaccentuate(s):\n    \"\"\" Replace accentuated chars in string by their non accentuated equivalent. \"\"\"\n    return \"\".join(c for c in unicodedata.normalize(\"NFKD\", s) if not unicodedata.combining(c))", "code_tokens": "def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "docstring_tokens": "Replace accentuated chars in string by their non accentuated equivalent .", "label": 0}, {"idx": "cosqa-train-7463", "doc": "how to make a function happen only once python", "code": "def once(func):\n    \"\"\"Runs a thing once and once only.\"\"\"\n    lock = threading.Lock()\n\n    def new_func(*args, **kwargs):\n        if new_func.called:\n            return\n        with lock:\n            if new_func.called:\n                return\n            rv = func(*args, **kwargs)\n            new_func.called = True\n            return rv\n\n    new_func = update_wrapper(new_func, func)\n    new_func.called = False\n    return new_func", "code_tokens": "def once ( func ) : lock = threading . Lock ( ) def new_func ( * args , * * kwargs ) : if new_func . called : return with lock : if new_func . called : return rv = func ( * args , * * kwargs ) new_func . called = True return rv new_func = update_wrapper ( new_func , func ) new_func . called = False return new_func", "docstring_tokens": "Runs a thing once and once only .", "label": 0}, {"idx": "cosqa-train-7464", "doc": "python remove all comments for c++", "code": "def CleanseComments(line):\n  \"\"\"Removes //-comments and single-line C-style /* */ comments.\n\n  Args:\n    line: A line of C++ source.\n\n  Returns:\n    The line with single-line comments removed.\n  \"\"\"\n  commentpos = line.find('//')\n  if commentpos != -1 and not IsCppString(line[:commentpos]):\n    line = line[:commentpos].rstrip()\n  # get rid of /* ... */\n  return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS.sub('', line)", "code_tokens": "def CleanseComments ( line ) : commentpos = line . find ( '//' ) if commentpos != - 1 and not IsCppString ( line [ : commentpos ] ) : line = line [ : commentpos ] . rstrip ( ) # get rid of /* ... */ return _RE_PATTERN_CLEANSE_LINE_C_COMMENTS . sub ( '' , line )", "docstring_tokens": "Removes // - comments and single - line C - style / * * / comments .", "label": 1}, {"idx": "cosqa-train-7465", "doc": "how to make a list callable in python", "code": "def as_list(callable):\n    \"\"\"Convert a scalar validator in a list validator\"\"\"\n    @wraps(callable)\n    def wrapper(value_iter):\n        return [callable(value) for value in value_iter]\n\n    return wrapper", "code_tokens": "def as_list ( callable ) : @ wraps ( callable ) def wrapper ( value_iter ) : return [ callable ( value ) for value in value_iter ] return wrapper", "docstring_tokens": "Convert a scalar validator in a list validator", "label": 0}, {"idx": "cosqa-train-7466", "doc": "python remove cell if zero", "code": "def delete_cell(self,  key):\n        \"\"\"Deletes key cell\"\"\"\n\n        try:\n            self.code_array.pop(key)\n\n        except KeyError:\n            pass\n\n        self.grid.code_array.result_cache.clear()", "code_tokens": "def delete_cell ( self , key ) : try : self . code_array . pop ( key ) except KeyError : pass self . grid . code_array . result_cache . clear ( )", "docstring_tokens": "Deletes key cell", "label": 0}, {"idx": "cosqa-train-7467", "doc": "how to make a list of a list in python as an attribute", "code": "def _listify(collection):\n        \"\"\"This is a workaround where Collections are no longer iterable\n        when using JPype.\"\"\"\n        new_list = []\n        for index in range(len(collection)):\n            new_list.append(collection[index])\n        return new_list", "code_tokens": "def _listify ( collection ) : new_list = [ ] for index in range ( len ( collection ) ) : new_list . append ( collection [ index ] ) return new_list", "docstring_tokens": "This is a workaround where Collections are no longer iterable when using JPype .", "label": 1}, {"idx": "cosqa-train-7468", "doc": "python remove characters from query", "code": "def filter_query_string(query):\n    \"\"\"\n        Return a version of the query string with the _e, _k and _s values\n        removed.\n    \"\"\"\n    return '&'.join([q for q in query.split('&')\n        if not (q.startswith('_k=') or q.startswith('_e=') or q.startswith('_s'))])", "code_tokens": "def filter_query_string ( query ) : return '&' . join ( [ q for q in query . split ( '&' ) if not ( q . startswith ( '_k=' ) or q . startswith ( '_e=' ) or q . startswith ( '_s' ) ) ] )", "docstring_tokens": "Return a version of the query string with the _e _k and _s values removed .", "label": 1}, {"idx": "cosqa-train-7469", "doc": "how to make a log based graph in python", "code": "def make_stream_handler(graph, formatter):\n    \"\"\"\n    Create the stream handler. Used for console/debug output.\n\n    \"\"\"\n    return {\n        \"class\": graph.config.logging.stream_handler.class_,\n        \"formatter\": formatter,\n        \"level\": graph.config.logging.level,\n        \"stream\": graph.config.logging.stream_handler.stream,\n    }", "code_tokens": "def make_stream_handler ( graph , formatter ) : return { \"class\" : graph . config . logging . stream_handler . class_ , \"formatter\" : formatter , \"level\" : graph . config . logging . level , \"stream\" : graph . config . logging . stream_handler . stream , }", "docstring_tokens": "Create the stream handler . Used for console / debug output .", "label": 0}, {"idx": "cosqa-train-7470", "doc": "python remove characters from string except one word", "code": "def strip_accents(text):\n    \"\"\"\n    Strip agents from a string.\n    \"\"\"\n\n    normalized_str = unicodedata.normalize('NFD', text)\n\n    return ''.join([\n        c for c in normalized_str if unicodedata.category(c) != 'Mn'])", "code_tokens": "def strip_accents ( text ) : normalized_str = unicodedata . normalize ( 'NFD' , text ) return '' . join ( [ c for c in normalized_str if unicodedata . category ( c ) != 'Mn' ] )", "docstring_tokens": "Strip agents from a string .", "label": 0}, {"idx": "cosqa-train-7471", "doc": "how to make a log in python discord", "code": "def log_leave(event, nick, channel):\n\t\"\"\"\n\tLog a quit or part event.\n\t\"\"\"\n\tif channel not in pmxbot.config.log_channels:\n\t\treturn\n\tParticipantLogger.store.log(nick, channel, event.type)", "code_tokens": "def log_leave ( event , nick , channel ) : if channel not in pmxbot . config . log_channels : return ParticipantLogger . store . log ( nick , channel , event . type )", "docstring_tokens": "Log a quit or part event .", "label": 0}, {"idx": "cosqa-train-7472", "doc": "python remove duplicates without changing order", "code": "def remove_dups(seq):\n    \"\"\"remove duplicates from a sequence, preserving order\"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def remove_dups ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "remove duplicates from a sequence preserving order", "label": 0}, {"idx": "cosqa-train-7473", "doc": "how to make a product in a list python", "code": "def _cumprod(l):\n  \"\"\"Cumulative product of a list.\n\n  Args:\n    l: a list of integers\n  Returns:\n    a list with one more element (starting with 1)\n  \"\"\"\n  ret = [1]\n  for item in l:\n    ret.append(ret[-1] * item)\n  return ret", "code_tokens": "def _cumprod ( l ) : ret = [ 1 ] for item in l : ret . append ( ret [ - 1 ] * item ) return ret", "docstring_tokens": "Cumulative product of a list .", "label": 0}, {"idx": "cosqa-train-7474", "doc": "how to make a string into file name in python", "code": "def guess_title(basename):\n    \"\"\" Attempt to guess the title from the filename \"\"\"\n\n    base, _ = os.path.splitext(basename)\n    return re.sub(r'[ _-]+', r' ', base).title()", "code_tokens": "def guess_title ( basename ) : base , _ = os . path . splitext ( basename ) return re . sub ( r'[ _-]+' , r' ' , base ) . title ( )", "docstring_tokens": "Attempt to guess the title from the filename", "label": 0}, {"idx": "cosqa-train-7475", "doc": "python remove elements using list of indices", "code": "def filter_list_by_indices(lst, indices):\n    \"\"\"Return a modified list containing only the indices indicated.\n\n    Args:\n        lst: Original list of values\n        indices: List of indices to keep from the original list\n\n    Returns:\n        list: Filtered list of values\n\n    \"\"\"\n    return [x for i, x in enumerate(lst) if i in indices]", "code_tokens": "def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]", "docstring_tokens": "Return a modified list containing only the indices indicated .", "label": 1}, {"idx": "cosqa-train-7476", "doc": "how to make a sympy expression in python", "code": "def access_to_sympy(self, var_name, access):\n        \"\"\"\n        Transform a (multidimensional) variable access to a flattend sympy expression.\n\n        Also works with flat array accesses.\n        \"\"\"\n        base_sizes = self.variables[var_name][1]\n\n        expr = sympy.Number(0)\n\n        for dimension, a in enumerate(access):\n            base_size = reduce(operator.mul, base_sizes[dimension+1:], sympy.Integer(1))\n\n            expr += base_size*a\n\n        return expr", "code_tokens": "def access_to_sympy ( self , var_name , access ) : base_sizes = self . variables [ var_name ] [ 1 ] expr = sympy . Number ( 0 ) for dimension , a in enumerate ( access ) : base_size = reduce ( operator . mul , base_sizes [ dimension + 1 : ] , sympy . Integer ( 1 ) ) expr += base_size * a return expr", "docstring_tokens": "Transform a ( multidimensional ) variable access to a flattend sympy expression .", "label": 1}, {"idx": "cosqa-train-7477", "doc": "python remove html from markdown", "code": "def md_to_text(content):\n    \"\"\" Converts markdown content to text \"\"\"\n    text = None\n    html = markdown.markdown(content)\n    if html:\n        text = html_to_text(content)\n    return text", "code_tokens": "def md_to_text ( content ) : text = None html = markdown . markdown ( content ) if html : text = html_to_text ( content ) return text", "docstring_tokens": "Converts markdown content to text", "label": 0}, {"idx": "cosqa-train-7478", "doc": "how to make an input be recognized as an integer and string python", "code": "def cast_int(x):\n    \"\"\"\n    Cast unknown type into integer\n\n    :param any x:\n    :return int:\n    \"\"\"\n    try:\n        x = int(x)\n    except ValueError:\n        try:\n            x = x.strip()\n        except AttributeError as e:\n            logger_misc.warn(\"parse_str: AttributeError: String not number or word, {}, {}\".format(x, e))\n    return x", "code_tokens": "def cast_int ( x ) : try : x = int ( x ) except ValueError : try : x = x . strip ( ) except AttributeError as e : logger_misc . warn ( \"parse_str: AttributeError: String not number or word, {}, {}\" . format ( x , e ) ) return x", "docstring_tokens": "Cast unknown type into integer", "label": 0}, {"idx": "cosqa-train-7479", "doc": "python remove html markups", "code": "def do_striptags(value):\n    \"\"\"Strip SGML/XML tags and replace adjacent whitespace by one space.\n    \"\"\"\n    if hasattr(value, '__html__'):\n        value = value.__html__()\n    return Markup(unicode(value)).striptags()", "code_tokens": "def do_striptags ( value ) : if hasattr ( value , '__html__' ) : value = value . __html__ ( ) return Markup ( unicode ( value ) ) . striptags ( )", "docstring_tokens": "Strip SGML / XML tags and replace adjacent whitespace by one space .", "label": 1}, {"idx": "cosqa-train-7480", "doc": "how to make check digit of number even or odd python", "code": "def check_int(integer):\n    \"\"\"\n    Check if number is integer or not.\n\n    :param integer: Number as str\n    :return: Boolean\n    \"\"\"\n    if not isinstance(integer, str):\n        return False\n    if integer[0] in ('-', '+'):\n        return integer[1:].isdigit()\n    return integer.isdigit()", "code_tokens": "def check_int ( integer ) : if not isinstance ( integer , str ) : return False if integer [ 0 ] in ( '-' , '+' ) : return integer [ 1 : ] . isdigit ( ) return integer . isdigit ( )", "docstring_tokens": "Check if number is integer or not .", "label": 0}, {"idx": "cosqa-train-7481", "doc": "python remove newline with strip method of strings and list comprehensions", "code": "def reduce_multiline(string):\n    \"\"\"\n    reduces a multiline string to a single line of text.\n\n\n    args:\n        string: the text to reduce\n    \"\"\"\n    string = str(string)\n    return \" \".join([item.strip()\n                     for item in string.split(\"\\n\")\n                     if item.strip()])", "code_tokens": "def reduce_multiline ( string ) : string = str ( string ) return \" \" . join ( [ item . strip ( ) for item in string . split ( \"\\n\" ) if item . strip ( ) ] )", "docstring_tokens": "reduces a multiline string to a single line of text .", "label": 1}, {"idx": "cosqa-train-7482", "doc": "how to make clickable text in python", "code": "def out(self, output, newline=True):\n        \"\"\"Outputs a string to the console (stdout).\"\"\"\n        click.echo(output, nl=newline)", "code_tokens": "def out ( self , output , newline = True ) : click . echo ( output , nl = newline )", "docstring_tokens": "Outputs a string to the console ( stdout ) .", "label": 1}, {"idx": "cosqa-train-7483", "doc": "python remove non alphabetic", "code": "def unaccentuate(s):\n    \"\"\" Replace accentuated chars in string by their non accentuated equivalent. \"\"\"\n    return \"\".join(c for c in unicodedata.normalize(\"NFKD\", s) if not unicodedata.combining(c))", "code_tokens": "def unaccentuate ( s ) : return \"\" . join ( c for c in unicodedata . normalize ( \"NFKD\" , s ) if not unicodedata . combining ( c ) )", "docstring_tokens": "Replace accentuated chars in string by their non accentuated equivalent .", "label": 0}, {"idx": "cosqa-train-7484", "doc": "how to make correlation heatmap between features in python", "code": "def scatterplot_matrix(df, features, downsample_frac=None, figsize=(15, 15)):\n    \"\"\"\n    Plot a scatterplot matrix for a list of features, colored by target value.\n\n    Example: `scatterplot_matrix(X, X.columns.tolist(), downsample_frac=0.01)`\n\n    Args:\n        df: Pandas dataframe containing the target column (named 'target').\n        features: The list of features to include in the correlation plot.\n        downsample_frac: Dataframe downsampling rate (0.1 to include 10% of the dataset).\n        figsize: The size of the plot.\n    \"\"\"\n\n    if downsample_frac:\n        df = df.sample(frac=downsample_frac)\n\n    plt.figure(figsize=figsize)\n    sns.pairplot(df[features], hue='target')\n    plt.show()", "code_tokens": "def scatterplot_matrix ( df , features , downsample_frac = None , figsize = ( 15 , 15 ) ) : if downsample_frac : df = df . sample ( frac = downsample_frac ) plt . figure ( figsize = figsize ) sns . pairplot ( df [ features ] , hue = 'target' ) plt . show ( )", "docstring_tokens": "Plot a scatterplot matrix for a list of features colored by target value .", "label": 0}, {"idx": "cosqa-train-7485", "doc": "python remove non printing characters", "code": "def drop_bad_characters(text):\n    \"\"\"Takes a text and drops all non-printable and non-ascii characters and\n    also any whitespace characters that aren't space.\n\n    :arg str text: the text to fix\n\n    :returns: text with all bad characters dropped\n\n    \"\"\"\n    # Strip all non-ascii and non-printable characters\n    text = ''.join([c for c in text if c in ALLOWED_CHARS])\n    return text", "code_tokens": "def drop_bad_characters ( text ) : # Strip all non-ascii and non-printable characters text = '' . join ( [ c for c in text if c in ALLOWED_CHARS ] ) return text", "docstring_tokens": "Takes a text and drops all non - printable and non - ascii characters and also any whitespace characters that aren t space .", "label": 1}, {"idx": "cosqa-train-7486", "doc": "how to make float callable in python", "code": "def _loadf(ins):\n    \"\"\" Loads a floating point value from a memory address.\n    If 2nd arg. start with '*', it is always treated as\n    an indirect value.\n    \"\"\"\n    output = _float_oper(ins.quad[2])\n    output.extend(_fpush())\n    return output", "code_tokens": "def _loadf ( ins ) : output = _float_oper ( ins . quad [ 2 ] ) output . extend ( _fpush ( ) ) return output", "docstring_tokens": "Loads a floating point value from a memory address . If 2nd arg . start with * it is always treated as an indirect value .", "label": 1}, {"idx": "cosqa-train-7487", "doc": "python remove object from disc", "code": "def cleanup(self):\n        \"\"\"Forcefully delete objects from memory\n\n        In an ideal world, this shouldn't be necessary. Garbage\n        collection guarantees that anything without reference\n        is automatically removed.\n\n        However, because this application is designed to be run\n        multiple times from the same interpreter process, extra\n        case must be taken to ensure there are no memory leaks.\n\n        Explicitly deleting objects shines a light on where objects\n        may still be referenced in the form of an error. No errors\n        means this was uneccesary, but that's ok.\n\n        \"\"\"\n\n        for instance in self.context:\n            del(instance)\n\n        for plugin in self.plugins:\n            del(plugin)", "code_tokens": "def cleanup ( self ) : for instance in self . context : del ( instance ) for plugin in self . plugins : del ( plugin )", "docstring_tokens": "Forcefully delete objects from memory", "label": 1}, {"idx": "cosqa-train-7488", "doc": "how to make histogram plots use the same bins in python", "code": "def _histplot_op(ax, data, **kwargs):\n    \"\"\"Add a histogram for the data to the axes.\"\"\"\n    bins = get_bins(data)\n    ax.hist(data, bins=bins, align=\"left\", density=True, **kwargs)\n    return ax", "code_tokens": "def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "docstring_tokens": "Add a histogram for the data to the axes .", "label": 0}, {"idx": "cosqa-train-7489", "doc": "python remove quotation marks repr", "code": "def _repr_strip(mystring):\n    \"\"\"\n    Returns the string without any initial or final quotes.\n    \"\"\"\n    r = repr(mystring)\n    if r.startswith(\"'\") and r.endswith(\"'\"):\n        return r[1:-1]\n    else:\n        return r", "code_tokens": "def _repr_strip ( mystring ) : r = repr ( mystring ) if r . startswith ( \"'\" ) and r . endswith ( \"'\" ) : return r [ 1 : - 1 ] else : return r", "docstring_tokens": "Returns the string without any initial or final quotes .", "label": 0}, {"idx": "cosqa-train-7490", "doc": "how to make intercept zero in python", "code": "def prox_zero(X, step):\n    \"\"\"Proximal operator to project onto zero\n    \"\"\"\n    return np.zeros(X.shape, dtype=X.dtype)", "code_tokens": "def prox_zero ( X , step ) : return np . zeros ( X . shape , dtype = X . dtype )", "docstring_tokens": "Proximal operator to project onto zero", "label": 1}, {"idx": "cosqa-train-7491", "doc": "python remove same elements from list", "code": "def distinct(l):\n    \"\"\"\n    Return a list where the duplicates have been removed.\n\n    Args:\n        l (list): the list to filter.\n\n    Returns:\n        list: the same list without duplicates.\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return (_ for _ in l if not (_ in seen or seen_add(_)))", "code_tokens": "def distinct ( l ) : seen = set ( ) seen_add = seen . add return ( _ for _ in l if not ( _ in seen or seen_add ( _ ) ) )", "docstring_tokens": "Return a list where the duplicates have been removed .", "label": 1}, {"idx": "cosqa-train-7492", "doc": "python remove string list and space", "code": "def clean_strings(iterable):\n    \"\"\"\n    Take a list of strings and clear whitespace \n    on each one. If a value in the list is not a \n    string pass it through untouched.\n\n    Args:\n        iterable: mixed list\n\n    Returns: \n        mixed list\n    \"\"\"\n    retval = []\n    for val in iterable:\n        try:\n            retval.append(val.strip())\n        except(AttributeError):\n            retval.append(val)\n    return retval", "code_tokens": "def clean_strings ( iterable ) : retval = [ ] for val in iterable : try : retval . append ( val . strip ( ) ) except ( AttributeError ) : retval . append ( val ) return retval", "docstring_tokens": "Take a list of strings and clear whitespace on each one . If a value in the list is not a string pass it through untouched .", "label": 1}, {"idx": "cosqa-train-7493", "doc": "how to make outputs next to each other in python", "code": "def build_output(self, fout):\n        \"\"\"Squash self.out into string.\n\n        Join every line in self.out with a new line and write the\n        result to the output file.\n        \"\"\"\n        fout.write('\\n'.join([s for s in self.out]))", "code_tokens": "def build_output ( self , fout ) : fout . write ( '\\n' . join ( [ s for s in self . out ] ) )", "docstring_tokens": "Squash self . out into string .", "label": 1}, {"idx": "cosqa-train-7494", "doc": "python remove timezone info of time", "code": "def normalize_time(timestamp):\n    \"\"\"Normalize time in arbitrary timezone to UTC naive object.\"\"\"\n    offset = timestamp.utcoffset()\n    if offset is None:\n        return timestamp\n    return timestamp.replace(tzinfo=None) - offset", "code_tokens": "def normalize_time ( timestamp ) : offset = timestamp . utcoffset ( ) if offset is None : return timestamp return timestamp . replace ( tzinfo = None ) - offset", "docstring_tokens": "Normalize time in arbitrary timezone to UTC naive object .", "label": 0}, {"idx": "cosqa-train-7495", "doc": "how to make python ask question", "code": "def string_input(prompt=''):\n    \"\"\"Python 3 input()/Python 2 raw_input()\"\"\"\n    v = sys.version[0]\n    if v == '3':\n        return input(prompt)\n    else:\n        return raw_input(prompt)", "code_tokens": "def string_input ( prompt = '' ) : v = sys . version [ 0 ] if v == '3' : return input ( prompt ) else : return raw_input ( prompt )", "docstring_tokens": "Python 3 input () / Python 2 raw_input ()", "label": 0}, {"idx": "cosqa-train-7496", "doc": "python remove whitespaces in a string", "code": "def _split_comma_separated(string):\n    \"\"\"Return a set of strings.\"\"\"\n    return set(text.strip() for text in string.split(',') if text.strip())", "code_tokens": "def _split_comma_separated ( string ) : return set ( text . strip ( ) for text in string . split ( ',' ) if text . strip ( ) )", "docstring_tokens": "Return a set of strings .", "label": 1}, {"idx": "cosqa-train-7497", "doc": "how to make python create a file", "code": "def write_file(filename, content):\n    \"\"\"Create the file with the given content\"\"\"\n    print 'Generating {0}'.format(filename)\n    with open(filename, 'wb') as out_f:\n        out_f.write(content)", "code_tokens": "def write_file ( filename , content ) : print 'Generating {0}' . format ( filename ) with open ( filename , 'wb' ) as out_f : out_f . write ( content )", "docstring_tokens": "Create the file with the given content", "label": 1}, {"idx": "cosqa-train-7498", "doc": "python replace a substring in values of all items of dictionary", "code": "def replace_all(text, dic):\n    \"\"\"Takes a string and dictionary. replaces all occurrences of i with j\"\"\"\n\n    for i, j in dic.iteritems():\n        text = text.replace(i, j)\n    return text", "code_tokens": "def replace_all ( text , dic ) : for i , j in dic . iteritems ( ) : text = text . replace ( i , j ) return text", "docstring_tokens": "Takes a string and dictionary . replaces all occurrences of i with j", "label": 1}, {"idx": "cosqa-train-7499", "doc": "how to make python font larger", "code": "def set_font_size(self, size):\n        \"\"\"Convenience method for just changing font size.\"\"\"\n        if self.font.font_size == size:\n            pass\n        else:\n            self.font._set_size(size)", "code_tokens": "def set_font_size ( self , size ) : if self . font . font_size == size : pass else : self . font . _set_size ( size )", "docstring_tokens": "Convenience method for just changing font size .", "label": 1}, {"idx": "cosqa-train-7500", "doc": "python replace all occurances of a substring", "code": "def myreplace(astr, thefind, thereplace):\n    \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"\n    alist = astr.split(thefind)\n    new_s = alist.split(thereplace)\n    return new_s", "code_tokens": "def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "docstring_tokens": "in string astr replace all occurences of thefind with thereplace", "label": 1}, {"idx": "cosqa-train-7501", "doc": "how to make python use artifactory", "code": "def __call__(self, factory_name, *args, **kwargs):\n        \"\"\"Create object.\"\"\"\n        return self.factories[factory_name](*args, **kwargs)", "code_tokens": "def __call__ ( self , factory_name , * args , * * kwargs ) : return self . factories [ factory_name ] ( * args , * * kwargs )", "docstring_tokens": "Create object .", "label": 1}, {"idx": "cosqa-train-7502", "doc": "python replace date type from column", "code": "def convert_str_to_datetime(df, *, column: str, format: str):\n    \"\"\"\n    Convert string column into datetime column\n\n    ---\n\n    ### Parameters\n\n    *mandatory :*\n    - `column` (*str*): name of the column to format\n    - `format` (*str*): current format of the values (see [available formats](\n    https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior))\n    \"\"\"\n    df[column] = pd.to_datetime(df[column], format=format)\n    return df", "code_tokens": "def convert_str_to_datetime ( df , * , column : str , format : str ) : df [ column ] = pd . to_datetime ( df [ column ] , format = format ) return df", "docstring_tokens": "Convert string column into datetime column", "label": 0}, {"idx": "cosqa-train-7503", "doc": "how to make something lowercase in python", "code": "def to_camel(s):\n    \"\"\"\n    :param string s: under_scored string to be CamelCased\n    :return: CamelCase version of input\n    :rtype: str\n    \"\"\"\n    # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups\n    return re.sub(r'_([a-zA-Z])', lambda m: m.group(1).upper(), '_' + s)", "code_tokens": "def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )", "docstring_tokens": ": param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str", "label": 0}, {"idx": "cosqa-train-7504", "doc": "python replace html entities", "code": "def unescape_all(string):\n    \"\"\"Resolve all html entities to their corresponding unicode character\"\"\"\n    def escape_single(matchobj):\n        return _unicode_for_entity_with_name(matchobj.group(1))\n    return entities.sub(escape_single, string)", "code_tokens": "def unescape_all ( string ) : def escape_single ( matchobj ) : return _unicode_for_entity_with_name ( matchobj . group ( 1 ) ) return entities . sub ( escape_single , string )", "docstring_tokens": "Resolve all html entities to their corresponding unicode character", "label": 1}, {"idx": "cosqa-train-7505", "doc": "how to make sure input language is english in a python form", "code": "def get_language_parameter(request, query_language_key='language', object=None, default=None):\n    \"\"\"\n    Get the language parameter from the current request.\n    \"\"\"\n    # This is the same logic as the django-admin uses.\n    # The only difference is the origin of the request parameter.\n    if not is_multilingual_project():\n        # By default, the objects are stored in a single static language.\n        # This makes the transition to multilingual easier as well.\n        # The default language can operate as fallback language too.\n        return default or appsettings.PARLER_LANGUAGES.get_default_language()\n    else:\n        # In multilingual mode, take the provided language of the request.\n        code = request.GET.get(query_language_key)\n\n        if not code:\n            # forms: show first tab by default\n            code = default or appsettings.PARLER_LANGUAGES.get_first_language()\n\n        return normalize_language_code(code)", "code_tokens": "def get_language_parameter ( request , query_language_key = 'language' , object = None , default = None ) : # This is the same logic as the django-admin uses. # The only difference is the origin of the request parameter. if not is_multilingual_project ( ) : # By default, the objects are stored in a single static language. # This makes the transition to multilingual easier as well. # The default language can operate as fallback language too. return default or appsettings . PARLER_LANGUAGES . get_default_language ( ) else : # In multilingual mode, take the provided language of the request. code = request . GET . get ( query_language_key ) if not code : # forms: show first tab by default code = default or appsettings . PARLER_LANGUAGES . get_first_language ( ) return normalize_language_code ( code )", "docstring_tokens": "Get the language parameter from the current request .", "label": 0}, {"idx": "cosqa-train-7506", "doc": "python replace in place string in string", "code": "def multi_replace(instr, search_list=[], repl_list=None):\n    \"\"\"\n    Does a string replace with a list of search and replacements\n\n    TODO: rename\n    \"\"\"\n    repl_list = [''] * len(search_list) if repl_list is None else repl_list\n    for ser, repl in zip(search_list, repl_list):\n        instr = instr.replace(ser, repl)\n    return instr", "code_tokens": "def multi_replace ( instr , search_list = [ ] , repl_list = None ) : repl_list = [ '' ] * len ( search_list ) if repl_list is None else repl_list for ser , repl in zip ( search_list , repl_list ) : instr = instr . replace ( ser , repl ) return instr", "docstring_tokens": "Does a string replace with a list of search and replacements", "label": 1}, {"idx": "cosqa-train-7507", "doc": "how to make upper and lower case string the same in python", "code": "def clean(some_string, uppercase=False):\n    \"\"\"\n    helper to clean up an input string\n    \"\"\"\n    if uppercase:\n        return some_string.strip().upper()\n    else:\n        return some_string.strip().lower()", "code_tokens": "def clean ( some_string , uppercase = False ) : if uppercase : return some_string . strip ( ) . upper ( ) else : return some_string . strip ( ) . lower ( )", "docstring_tokens": "helper to clean up an input string", "label": 1}, {"idx": "cosqa-train-7508", "doc": "python replace new line in string", "code": "def replaceNewlines(string, newlineChar):\n\t\"\"\"There's probably a way to do this with string functions but I was lazy.\n\t\tReplace all instances of \\r or \\n in a string with something else.\"\"\"\n\tif newlineChar in string:\n\t\tsegments = string.split(newlineChar)\n\t\tstring = \"\"\n\t\tfor segment in segments:\n\t\t\tstring += segment\n\treturn string", "code_tokens": "def replaceNewlines ( string , newlineChar ) : if newlineChar in string : segments = string . split ( newlineChar ) string = \"\" for segment in segments : string += segment return string", "docstring_tokens": "There s probably a way to do this with string functions but I was lazy . Replace all instances of \\ r or \\ n in a string with something else .", "label": 0}, {"idx": "cosqa-train-7509", "doc": "how to maniplate location of text in python", "code": "def locate(command, on):\n    \"\"\"Locate the command's man page.\"\"\"\n    location = find_page_location(command, on)\n    click.echo(location)", "code_tokens": "def locate ( command , on ) : location = find_page_location ( command , on ) click . echo ( location )", "docstring_tokens": "Locate the command s man page .", "label": 1}, {"idx": "cosqa-train-7510", "doc": "python replace strings in a list of lists", "code": "def replace_list(items, match, replacement):\n    \"\"\"Replaces occurrences of a match string in a given list of strings and returns\n    a list of new strings. The match string can be a regex expression.\n\n    Args:\n        items (list):       the list of strings to modify.\n        match (str):        the search expression.\n        replacement (str):  the string to replace with.\n    \"\"\"\n    return [replace(item, match, replacement) for item in items]", "code_tokens": "def replace_list ( items , match , replacement ) : return [ replace ( item , match , replacement ) for item in items ]", "docstring_tokens": "Replaces occurrences of a match string in a given list of strings and returns a list of new strings . The match string can be a regex expression .", "label": 1}, {"idx": "cosqa-train-7511", "doc": "how to merge multi yaml file into csv in python", "code": "def csv2yaml(in_file, out_file=None):\n    \"\"\"Convert a CSV SampleSheet to YAML run_info format.\n    \"\"\"\n    if out_file is None:\n        out_file = \"%s.yaml\" % os.path.splitext(in_file)[0]\n    barcode_ids = _generate_barcode_ids(_read_input_csv(in_file))\n    lanes = _organize_lanes(_read_input_csv(in_file), barcode_ids)\n    with open(out_file, \"w\") as out_handle:\n        out_handle.write(yaml.safe_dump(lanes, default_flow_style=False))\n    return out_file", "code_tokens": "def csv2yaml ( in_file , out_file = None ) : if out_file is None : out_file = \"%s.yaml\" % os . path . splitext ( in_file ) [ 0 ] barcode_ids = _generate_barcode_ids ( _read_input_csv ( in_file ) ) lanes = _organize_lanes ( _read_input_csv ( in_file ) , barcode_ids ) with open ( out_file , \"w\" ) as out_handle : out_handle . write ( yaml . safe_dump ( lanes , default_flow_style = False ) ) return out_file", "docstring_tokens": "Convert a CSV SampleSheet to YAML run_info format .", "label": 1}, {"idx": "cosqa-train-7512", "doc": "python replace substring in a string with another substring", "code": "def myreplace(astr, thefind, thereplace):\n    \"\"\"in string astr replace all occurences of thefind with thereplace\"\"\"\n    alist = astr.split(thefind)\n    new_s = alist.split(thereplace)\n    return new_s", "code_tokens": "def myreplace ( astr , thefind , thereplace ) : alist = astr . split ( thefind ) new_s = alist . split ( thereplace ) return new_s", "docstring_tokens": "in string astr replace all occurences of thefind with thereplace", "label": 1}, {"idx": "cosqa-train-7513", "doc": "how to merge pdf files using python", "code": "def merge_pdfs(pdf_filepaths, out_filepath):\n    \"\"\" Merge all the PDF files in `pdf_filepaths` in a new PDF file `out_filepath`.\n\n    Parameters\n    ----------\n    pdf_filepaths: list of str\n        Paths to PDF files.\n\n    out_filepath: str\n        Path to the result PDF file.\n\n    Returns\n    -------\n    path: str\n        The output file path.\n    \"\"\"\n    merger = PdfFileMerger()\n    for pdf in pdf_filepaths:\n        merger.append(PdfFileReader(open(pdf, 'rb')))\n\n    merger.write(out_filepath)\n\n    return out_filepath", "code_tokens": "def merge_pdfs ( pdf_filepaths , out_filepath ) : merger = PdfFileMerger ( ) for pdf in pdf_filepaths : merger . append ( PdfFileReader ( open ( pdf , 'rb' ) ) ) merger . write ( out_filepath ) return out_filepath", "docstring_tokens": "Merge all the PDF files in pdf_filepaths in a new PDF file out_filepath .", "label": 1}, {"idx": "cosqa-train-7514", "doc": "python replace substring splice between words", "code": "def _replace_token_range(tokens, start, end, replacement):\n    \"\"\"For a range indicated from start to end, replace with replacement.\"\"\"\n    tokens = tokens[:start] + replacement + tokens[end:]\n    return tokens", "code_tokens": "def _replace_token_range ( tokens , start , end , replacement ) : tokens = tokens [ : start ] + replacement + tokens [ end : ] return tokens", "docstring_tokens": "For a range indicated from start to end replace with replacement .", "label": 1}, {"idx": "cosqa-train-7515", "doc": "how to modify values in a dictonary in python", "code": "def copy_and_update(dictionary, update):\n    \"\"\"Returns an updated copy of the dictionary without modifying the original\"\"\"\n    newdict = dictionary.copy()\n    newdict.update(update)\n    return newdict", "code_tokens": "def copy_and_update ( dictionary , update ) : newdict = dictionary . copy ( ) newdict . update ( update ) return newdict", "docstring_tokens": "Returns an updated copy of the dictionary without modifying the original", "label": 0}, {"idx": "cosqa-train-7516", "doc": "python replace zero entries in matrix", "code": "def check_precomputed_distance_matrix(X):\n    \"\"\"Perform check_array(X) after removing infinite values (numpy.inf) from the given distance matrix.\n    \"\"\"\n    tmp = X.copy()\n    tmp[np.isinf(tmp)] = 1\n    check_array(tmp)", "code_tokens": "def check_precomputed_distance_matrix ( X ) : tmp = X . copy ( ) tmp [ np . isinf ( tmp ) ] = 1 check_array ( tmp )", "docstring_tokens": "Perform check_array ( X ) after removing infinite values ( numpy . inf ) from the given distance matrix .", "label": 0}, {"idx": "cosqa-train-7517", "doc": "how to move a str in a list to the front in python", "code": "def list_move_to_front(l,value='other'):\n    \"\"\"if the value is in the list, move it to the front and return it.\"\"\"\n    l=list(l)\n    if value in l:\n        l.remove(value)\n        l.insert(0,value)\n    return l", "code_tokens": "def list_move_to_front ( l , value = 'other' ) : l = list ( l ) if value in l : l . remove ( value ) l . insert ( 0 , value ) return l", "docstring_tokens": "if the value is in the list move it to the front and return it .", "label": 0}, {"idx": "cosqa-train-7518", "doc": "python request only get http status code", "code": "def raise_for_not_ok_status(response):\n    \"\"\"\n    Raises a `requests.exceptions.HTTPError` if the response has a non-200\n    status code.\n    \"\"\"\n    if response.code != OK:\n        raise HTTPError('Non-200 response code (%s) for url: %s' % (\n            response.code, uridecode(response.request.absoluteURI)))\n\n    return response", "code_tokens": "def raise_for_not_ok_status ( response ) : if response . code != OK : raise HTTPError ( 'Non-200 response code (%s) for url: %s' % ( response . code , uridecode ( response . request . absoluteURI ) ) ) return response", "docstring_tokens": "Raises a requests . exceptions . HTTPError if the response has a non - 200 status code .", "label": 1}, {"idx": "cosqa-train-7519", "doc": "how to move the coursor up and down in python with arrow keys", "code": "def onRightUp(self, event=None):\n        \"\"\" right button up: put back to cursor mode\"\"\"\n        if event is None:\n            return\n        self.cursor_mode_action('rightup', event=event)\n        self.ForwardEvent(event=event.guiEvent)", "code_tokens": "def onRightUp ( self , event = None ) : if event is None : return self . cursor_mode_action ( 'rightup' , event = event ) self . ForwardEvent ( event = event . guiEvent )", "docstring_tokens": "right button up : put back to cursor mode", "label": 0}, {"idx": "cosqa-train-7520", "doc": "python request response 401", "code": "def HttpResponse401(request, template=KEY_AUTH_401_TEMPLATE,\ncontent=KEY_AUTH_401_CONTENT, content_type=KEY_AUTH_401_CONTENT_TYPE):\n    \"\"\"\n    HTTP response for not-authorized access (status code 403)\n    \"\"\"\n    return AccessFailedResponse(request, template, content, content_type, status=401)", "code_tokens": "def HttpResponse401 ( request , template = KEY_AUTH_401_TEMPLATE , content = KEY_AUTH_401_CONTENT , content_type = KEY_AUTH_401_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 401 )", "docstring_tokens": "HTTP response for not - authorized access ( status code 403 )", "label": 1}, {"idx": "cosqa-train-7521", "doc": "how to noise an image in python", "code": "def normal_noise(points):\n    \"\"\"Init a noise variable.\"\"\"\n    return np.random.rand(1) * np.random.randn(points, 1) \\\n        + random.sample([2, -2], 1)", "code_tokens": "def normal_noise ( points ) : return np . random . rand ( 1 ) * np . random . randn ( points , 1 ) + random . sample ( [ 2 , - 2 ] , 1 )", "docstring_tokens": "Init a noise variable .", "label": 1}, {"idx": "cosqa-train-7522", "doc": "python requests get last redirect url", "code": "def geturl(self):\n        \"\"\"\n        Returns the URL that was the source of this response.\n        If the request that generated this response redirected, this method\n        will return the final redirect location.\n        \"\"\"\n        if self.retries is not None and len(self.retries.history):\n            return self.retries.history[-1].redirect_location\n        else:\n            return self._request_url", "code_tokens": "def geturl ( self ) : if self . retries is not None and len ( self . retries . history ) : return self . retries . history [ - 1 ] . redirect_location else : return self . _request_url", "docstring_tokens": "Returns the URL that was the source of this response . If the request that generated this response redirected this method will return the final redirect location .", "label": 0}, {"idx": "cosqa-train-7523", "doc": "python requests streaming uploads", "code": "def rest_put_stream(self, url, stream, headers=None, session=None, verify=True, cert=None):\n        \"\"\"\n        Perform a chunked PUT request to url with requests.session\n        This is specifically to upload files.\n        \"\"\"\n        res = session.put(url, headers=headers, data=stream, verify=verify, cert=cert)\n        return res.text, res.status_code", "code_tokens": "def rest_put_stream ( self , url , stream , headers = None , session = None , verify = True , cert = None ) : res = session . put ( url , headers = headers , data = stream , verify = verify , cert = cert ) return res . text , res . status_code", "docstring_tokens": "Perform a chunked PUT request to url with requests . session This is specifically to upload files .", "label": 1}, {"idx": "cosqa-train-7524", "doc": "how to only read the integer value of a file python", "code": "def _fast_read(self, infile):\n        \"\"\"Function for fast reading from sensor files.\"\"\"\n        infile.seek(0)\n        return(int(infile.read().decode().strip()))", "code_tokens": "def _fast_read ( self , infile ) : infile . seek ( 0 ) return ( int ( infile . read ( ) . decode ( ) . strip ( ) ) )", "docstring_tokens": "Function for fast reading from sensor files .", "label": 1}, {"idx": "cosqa-train-7525", "doc": "python requests upload file from stream", "code": "def rest_put_stream(self, url, stream, headers=None, session=None, verify=True, cert=None):\n        \"\"\"\n        Perform a chunked PUT request to url with requests.session\n        This is specifically to upload files.\n        \"\"\"\n        res = session.put(url, headers=headers, data=stream, verify=verify, cert=cert)\n        return res.text, res.status_code", "code_tokens": "def rest_put_stream ( self , url , stream , headers = None , session = None , verify = True , cert = None ) : res = session . put ( url , headers = headers , data = stream , verify = verify , cert = cert ) return res . text , res . status_code", "docstring_tokens": "Perform a chunked PUT request to url with requests . session This is specifically to upload files .", "label": 0}, {"idx": "cosqa-train-7526", "doc": "how to open a text file as a string inpython", "code": "def from_file(cls, path, encoding, dialect, fields, converters, field_index):\n        \"\"\"Read delimited text from a text file.\"\"\"\n\n        return cls(open(path, 'r', encoding=encoding), dialect, fields, converters, field_index)", "code_tokens": "def from_file ( cls , path , encoding , dialect , fields , converters , field_index ) : return cls ( open ( path , 'r' , encoding = encoding ) , dialect , fields , converters , field_index )", "docstring_tokens": "Read delimited text from a text file .", "label": 0}, {"idx": "cosqa-train-7527", "doc": "python reset object as function", "code": "def _reset_bind(self):\n        \"\"\"Internal utility function to reset binding.\"\"\"\n        self.binded = False\n        self._buckets = {}\n        self._curr_module = None\n        self._curr_bucket_key = None", "code_tokens": "def _reset_bind ( self ) : self . binded = False self . _buckets = { } self . _curr_module = None self . _curr_bucket_key = None", "docstring_tokens": "Internal utility function to reset binding .", "label": 0}, {"idx": "cosqa-train-7528", "doc": "how to open image from content in python", "code": "def get_image(self, source):\n        \"\"\"\n        Given a file-like object, loads it up into a PIL.Image object\n        and returns it.\n\n        :param file source: A file-like object to load the image from.\n        :rtype: PIL.Image\n        :returns: The loaded image.\n        \"\"\"\n        buf = StringIO(source.read())\n        return Image.open(buf)", "code_tokens": "def get_image ( self , source ) : buf = StringIO ( source . read ( ) ) return Image . open ( buf )", "docstring_tokens": "Given a file - like object loads it up into a PIL . Image object and returns it .", "label": 1}, {"idx": "cosqa-train-7529", "doc": "python reset the appropriate variable(s) to their initial values", "code": "def reset_params(self):\n        \"\"\"Reset all parameters to their default values.\"\"\"\n        self.__params = dict([p, None] for p in self.param_names)\n        self.set_params(self.param_defaults)", "code_tokens": "def reset_params ( self ) : self . __params = dict ( [ p , None ] for p in self . param_names ) self . set_params ( self . param_defaults )", "docstring_tokens": "Reset all parameters to their default values .", "label": 1}, {"idx": "cosqa-train-7530", "doc": "how to parse string to float or int in python", "code": "def covstr(s):\n  \"\"\" convert string to int or float. \"\"\"\n  try:\n    ret = int(s)\n  except ValueError:\n    ret = float(s)\n  return ret", "code_tokens": "def covstr ( s ) : try : ret = int ( s ) except ValueError : ret = float ( s ) return ret", "docstring_tokens": "convert string to int or float .", "label": 0}, {"idx": "cosqa-train-7531", "doc": "python reshape a list of images into one matrix", "code": "def im2mat(I):\n    \"\"\"Converts and image to matrix (one pixel per line)\"\"\"\n    return I.reshape((I.shape[0] * I.shape[1], I.shape[2]))", "code_tokens": "def im2mat ( I ) : return I . reshape ( ( I . shape [ 0 ] * I . shape [ 1 ] , I . shape [ 2 ] ) )", "docstring_tokens": "Converts and image to matrix ( one pixel per line )", "label": 0}, {"idx": "cosqa-train-7532", "doc": "how to parse the results from a cursor python", "code": "def _parse_return(cls, result):\n        \"\"\"Extract the result, return value and context from a result object\n        \"\"\"\n\n        return_value = None\n        success = result['result']\n        context = result['context']\n\n        if 'return_value' in result:\n            return_value = result['return_value']\n\n        return success, return_value, context", "code_tokens": "def _parse_return ( cls , result ) : return_value = None success = result [ 'result' ] context = result [ 'context' ] if 'return_value' in result : return_value = result [ 'return_value' ] return success , return_value , context", "docstring_tokens": "Extract the result return value and context from a result object", "label": 0}, {"idx": "cosqa-train-7533", "doc": "python reshape to broadcast sum", "code": "def unbroadcast_numpy_to(array, shape):\n  \"\"\"Reverse the broadcasting operation.\n\n  Args:\n    array: An array.\n    shape: A shape that could have been broadcasted to the shape of array.\n\n  Returns:\n    Array with dimensions summed to match `shape`.\n  \"\"\"\n  axis = create_unbroadcast_axis(shape, numpy.shape(array))\n  return numpy.reshape(numpy.sum(array, axis=axis), shape)", "code_tokens": "def unbroadcast_numpy_to ( array , shape ) : axis = create_unbroadcast_axis ( shape , numpy . shape ( array ) ) return numpy . reshape ( numpy . sum ( array , axis = axis ) , shape )", "docstring_tokens": "Reverse the broadcasting operation .", "label": 1}, {"idx": "cosqa-train-7534", "doc": "how to pause a loop in python#", "code": "def seconds(num):\n    \"\"\"\n    Pause for this many seconds\n    \"\"\"\n    now = pytime.time()\n    end = now + num\n    until(end)", "code_tokens": "def seconds ( num ) : now = pytime . time ( ) end = now + num until ( end )", "docstring_tokens": "Pause for this many seconds", "label": 1}, {"idx": "cosqa-train-7535", "doc": "python resize image and keep aspect ratio", "code": "def resize_image_to_fit_width(image, dest_w):\n    \"\"\"\n    Resize and image to fit the passed in width, keeping the aspect ratio the same\n\n    :param image: PIL.Image\n    :param dest_w: The desired width\n    \"\"\"\n    scale_factor = dest_w / image.size[0]\n    dest_h = image.size[1] * scale_factor\n    \n    scaled_image = image.resize((int(dest_w), int(dest_h)), PIL.Image.ANTIALIAS)\n\n    return scaled_image", "code_tokens": "def resize_image_to_fit_width ( image , dest_w ) : scale_factor = dest_w / image . size [ 0 ] dest_h = image . size [ 1 ] * scale_factor scaled_image = image . resize ( ( int ( dest_w ) , int ( dest_h ) ) , PIL . Image . ANTIALIAS ) return scaled_image", "docstring_tokens": "Resize and image to fit the passed in width keeping the aspect ratio the same", "label": 0}, {"idx": "cosqa-train-7536", "doc": "how to pause audio using python", "code": "def pause(self):\n        \"\"\"Pause the music\"\"\"\n        mixer.music.pause()\n        self.pause_time = self.get_time()\n        self.paused = True", "code_tokens": "def pause ( self ) : mixer . music . pause ( ) self . pause_time = self . get_time ( ) self . paused = True", "docstring_tokens": "Pause the music", "label": 0}, {"idx": "cosqa-train-7537", "doc": "python response 401 with text", "code": "def HttpResponse401(request, template=KEY_AUTH_401_TEMPLATE,\ncontent=KEY_AUTH_401_CONTENT, content_type=KEY_AUTH_401_CONTENT_TYPE):\n    \"\"\"\n    HTTP response for not-authorized access (status code 403)\n    \"\"\"\n    return AccessFailedResponse(request, template, content, content_type, status=401)", "code_tokens": "def HttpResponse401 ( request , template = KEY_AUTH_401_TEMPLATE , content = KEY_AUTH_401_CONTENT , content_type = KEY_AUTH_401_CONTENT_TYPE ) : return AccessFailedResponse ( request , template , content , content_type , status = 401 )", "docstring_tokens": "HTTP response for not - authorized access ( status code 403 )", "label": 1}, {"idx": "cosqa-train-7538", "doc": "how to pickle a file in python", "code": "def load(self, filename='classifier.dump'):\n        \"\"\"\n        Unpickles the classifier used\n        \"\"\"\n        ifile = open(filename, 'r+')\n        self.classifier = pickle.load(ifile)\n        ifile.close()", "code_tokens": "def load ( self , filename = 'classifier.dump' ) : ifile = open ( filename , 'r+' ) self . classifier = pickle . load ( ifile ) ifile . close ( )", "docstring_tokens": "Unpickles the classifier used", "label": 0}, {"idx": "cosqa-train-7539", "doc": "python rest connection refused", "code": "def do_stc_disconnectall(self, s):\n        \"\"\"Remove connections to all chassis (test ports) in this session.\"\"\"\n        if self._not_joined():\n            return\n        try:\n            self._stc.disconnectall()\n        except resthttp.RestHttpError as e:\n            print(e)\n            return\n        print('OK')", "code_tokens": "def do_stc_disconnectall ( self , s ) : if self . _not_joined ( ) : return try : self . _stc . disconnectall ( ) except resthttp . RestHttpError as e : print ( e ) return print ( 'OK' )", "docstring_tokens": "Remove connections to all chassis ( test ports ) in this session .", "label": 0}, {"idx": "cosqa-train-7540", "doc": "how to plot confusion matrix python", "code": "def confusion_matrix(self):\n        \"\"\"Confusion matrix plot\n        \"\"\"\n        return plot.confusion_matrix(self.y_true, self.y_pred,\n                                     self.target_names, ax=_gen_ax())", "code_tokens": "def confusion_matrix ( self ) : return plot . confusion_matrix ( self . y_true , self . y_pred , self . target_names , ax = _gen_ax ( ) )", "docstring_tokens": "Confusion matrix plot", "label": 1}, {"idx": "cosqa-train-7541", "doc": "python rest cookie session managment", "code": "def _get_data(self):\n        \"\"\"\n        Extracts the session data from cookie.\n        \"\"\"\n        cookie = self.adapter.cookies.get(self.name)\n        return self._deserialize(cookie) if cookie else {}", "code_tokens": "def _get_data ( self ) : cookie = self . adapter . cookies . get ( self . name ) return self . _deserialize ( cookie ) if cookie else { }", "docstring_tokens": "Extracts the session data from cookie .", "label": 1}, {"idx": "cosqa-train-7542", "doc": "python restore to default settings", "code": "def restore_default_settings():\n    \"\"\" Restore settings to default values. \n    \"\"\"\n    global __DEFAULTS\n    __DEFAULTS.CACHE_DIR = defaults.CACHE_DIR\n    __DEFAULTS.SET_SEED = defaults.SET_SEED\n    __DEFAULTS.SEED = defaults.SEED\n    logging.info('Settings reverted to their default values.')", "code_tokens": "def restore_default_settings ( ) : global __DEFAULTS __DEFAULTS . CACHE_DIR = defaults . CACHE_DIR __DEFAULTS . SET_SEED = defaults . SET_SEED __DEFAULTS . SEED = defaults . SEED logging . info ( 'Settings reverted to their default values.' )", "docstring_tokens": "Restore settings to default values .", "label": 1}, {"idx": "cosqa-train-7543", "doc": "how to pretty print to json from python", "code": "def to_json(data):\n    \"\"\"Return data as a JSON string.\"\"\"\n    return json.dumps(data, default=lambda x: x.__dict__, sort_keys=True, indent=4)", "code_tokens": "def to_json ( data ) : return json . dumps ( data , default = lambda x : x . __dict__ , sort_keys = True , indent = 4 )", "docstring_tokens": "Return data as a JSON string .", "label": 0}, {"idx": "cosqa-train-7544", "doc": "python retrieve a file property", "code": "def get_property(self, filename):\n        \"\"\"Opens the file and reads the value\"\"\"\n\n        with open(self.filepath(filename)) as f:\n            return f.read().strip()", "code_tokens": "def get_property ( self , filename ) : with open ( self . filepath ( filename ) ) as f : return f . read ( ) . strip ( )", "docstring_tokens": "Opens the file and reads the value", "label": 1}, {"idx": "cosqa-train-7545", "doc": "how to print all objects in a string python", "code": "def __repr__(self):\n        \"\"\"Return list-lookalike of representation string of objects\"\"\"\n        strings = []\n        for currItem in self:\n            strings.append(\"%s\" % currItem)\n        return \"(%s)\" % (\", \".join(strings))", "code_tokens": "def __repr__ ( self ) : strings = [ ] for currItem in self : strings . append ( \"%s\" % currItem ) return \"(%s)\" % ( \", \" . join ( strings ) )", "docstring_tokens": "Return list - lookalike of representation string of objects", "label": 0}, {"idx": "cosqa-train-7546", "doc": "python retrieve parent path", "code": "def grandparent_path(self):\n        \"\"\" return grandparent's path string \"\"\"\n        return os.path.basename(os.path.join(self.path, '../..'))", "code_tokens": "def grandparent_path ( self ) : return os . path . basename ( os . path . join ( self . path , '../..' ) )", "docstring_tokens": "return grandparent s path string", "label": 1}, {"idx": "cosqa-train-7547", "doc": "how to print all the variables in an object python", "code": "def var_dump(*obs):\n\t\"\"\"\n\t  shows structured information of a object, list, tuple etc\n\t\"\"\"\n\ti = 0\n\tfor x in obs:\n\t\t\n\t\tstr = var_dump_output(x, 0, '  ', '\\n', True)\n\t\tprint (str.strip())\n\t\t\n\t\t#dump(x, 0, i, '', object)\n\t\ti += 1", "code_tokens": "def var_dump ( * obs ) : i = 0 for x in obs : str = var_dump_output ( x , 0 , '  ' , '\\n' , True ) print ( str . strip ( ) ) #dump(x, 0, i, '', object) i += 1", "docstring_tokens": "shows structured information of a object list tuple etc", "label": 1}, {"idx": "cosqa-train-7548", "doc": "how to print an additional text output to the screen on python", "code": "def out(self, output, newline=True):\n        \"\"\"Outputs a string to the console (stdout).\"\"\"\n        click.echo(output, nl=newline)", "code_tokens": "def out ( self , output , newline = True ) : click . echo ( output , nl = newline )", "docstring_tokens": "Outputs a string to the console ( stdout ) .", "label": 1}, {"idx": "cosqa-train-7549", "doc": "python return index of substring", "code": "def _find(string, sub_string, start_index):\n    \"\"\"Return index of sub_string in string.\n\n    Raise TokenError if sub_string is not found.\n    \"\"\"\n    result = string.find(sub_string, start_index)\n    if result == -1:\n        raise TokenError(\"expected '{0}'\".format(sub_string))\n    return result", "code_tokens": "def _find ( string , sub_string , start_index ) : result = string . find ( sub_string , start_index ) if result == - 1 : raise TokenError ( \"expected '{0}'\" . format ( sub_string ) ) return result", "docstring_tokens": "Return index of sub_string in string .", "label": 1}, {"idx": "cosqa-train-7550", "doc": "how to print from a dictionary with a new line python", "code": "def _attrprint(d, delimiter=', '):\n    \"\"\"Print a dictionary of attributes in the DOT format\"\"\"\n    return delimiter.join(('\"%s\"=\"%s\"' % item) for item in sorted(d.items()))", "code_tokens": "def _attrprint ( d , delimiter = ', ' ) : return delimiter . join ( ( '\"%s\"=\"%s\"' % item ) for item in sorted ( d . items ( ) ) )", "docstring_tokens": "Print a dictionary of attributes in the DOT format", "label": 0}, {"idx": "cosqa-train-7551", "doc": "python return parent path of a path", "code": "def grandparent_path(self):\n        \"\"\" return grandparent's path string \"\"\"\n        return os.path.basename(os.path.join(self.path, '../..'))", "code_tokens": "def grandparent_path ( self ) : return os . path . basename ( os . path . join ( self . path , '../..' ) )", "docstring_tokens": "return grandparent s path string", "label": 0}, {"idx": "cosqa-train-7552", "doc": "how to print generic error in python", "code": "def print_err(*args, end='\\n'):\n    \"\"\"Similar to print, but prints to stderr.\n    \"\"\"\n    print(*args, end=end, file=sys.stderr)\n    sys.stderr.flush()", "code_tokens": "def print_err ( * args , end = '\\n' ) : print ( * args , end = end , file = sys . stderr ) sys . stderr . flush ( )", "docstring_tokens": "Similar to print but prints to stderr .", "label": 1}, {"idx": "cosqa-train-7553", "doc": "python return position of item in series", "code": "def series_index(self, series):\n        \"\"\"\n        Return the integer index of *series* in this sequence.\n        \"\"\"\n        for idx, s in enumerate(self):\n            if series is s:\n                return idx\n        raise ValueError('series not in chart data object')", "code_tokens": "def series_index ( self , series ) : for idx , s in enumerate ( self ) : if series is s : return idx raise ValueError ( 'series not in chart data object' )", "docstring_tokens": "Return the integer index of * series * in this sequence .", "label": 1}, {"idx": "cosqa-train-7554", "doc": "how to print without moving cursor python", "code": "def ensure_newline(self):\n        \"\"\"\n        use before any custom printing when using the progress iter to ensure\n        your print statement starts on a new line instead of at the end of a\n        progress line\n        \"\"\"\n        DECTCEM_SHOW = '\\033[?25h'  # show cursor\n        AT_END = DECTCEM_SHOW + '\\n'\n        if not self._cursor_at_newline:\n            self.write(AT_END)\n            self._cursor_at_newline = True", "code_tokens": "def ensure_newline ( self ) : DECTCEM_SHOW = '\\033[?25h' # show cursor AT_END = DECTCEM_SHOW + '\\n' if not self . _cursor_at_newline : self . write ( AT_END ) self . _cursor_at_newline = True", "docstring_tokens": "use before any custom printing when using the progress iter to ensure your print statement starts on a new line instead of at the end of a progress line", "label": 1}, {"idx": "cosqa-train-7555", "doc": "python return property object", "code": "def value(self):\n        \"\"\"Value of property.\"\"\"\n        if self._prop.fget is None:\n            raise AttributeError('Unable to read attribute')\n        return self._prop.fget(self._obj)", "code_tokens": "def value ( self ) : if self . _prop . fget is None : raise AttributeError ( 'Unable to read attribute' ) return self . _prop . fget ( self . _obj )", "docstring_tokens": "Value of property .", "label": 1}, {"idx": "cosqa-train-7556", "doc": "how to profile a background python process", "code": "def _run_parallel_process_with_profiling(self, start_path, stop_path, queue, filename):\n        \"\"\"\n        wrapper for usage of profiling\n        \"\"\"\n        runctx('Engine._run_parallel_process(self,  start_path, stop_path, queue)', globals(), locals(), filename)", "code_tokens": "def _run_parallel_process_with_profiling ( self , start_path , stop_path , queue , filename ) : runctx ( 'Engine._run_parallel_process(self,  start_path, stop_path, queue)' , globals ( ) , locals ( ) , filename )", "docstring_tokens": "wrapper for usage of profiling", "label": 0}, {"idx": "cosqa-train-7557", "doc": "how to profile multithread python", "code": "def _run_parallel_process_with_profiling(self, start_path, stop_path, queue, filename):\n        \"\"\"\n        wrapper for usage of profiling\n        \"\"\"\n        runctx('Engine._run_parallel_process(self,  start_path, stop_path, queue)', globals(), locals(), filename)", "code_tokens": "def _run_parallel_process_with_profiling ( self , start_path , stop_path , queue , filename ) : runctx ( 'Engine._run_parallel_process(self,  start_path, stop_path, queue)' , globals ( ) , locals ( ) , filename )", "docstring_tokens": "wrapper for usage of profiling", "label": 0}, {"idx": "cosqa-train-7558", "doc": "python returning column without nan", "code": "def reduce_fn(x):\n    \"\"\"\n    Aggregation function to get the first non-zero value.\n    \"\"\"\n    values = x.values if pd and isinstance(x, pd.Series) else x\n    for v in values:\n        if not is_nan(v):\n            return v\n    return np.NaN", "code_tokens": "def reduce_fn ( x ) : values = x . values if pd and isinstance ( x , pd . Series ) else x for v in values : if not is_nan ( v ) : return v return np . NaN", "docstring_tokens": "Aggregation function to get the first non - zero value .", "label": 0}, {"idx": "cosqa-train-7559", "doc": "how to properly use a raise function in python", "code": "def reraise(error):\n    \"\"\"Re-raises the error that was processed by prepare_for_reraise earlier.\"\"\"\n    if hasattr(error, \"_type_\"):\n        six.reraise(type(error), error, error._traceback)\n    raise error", "code_tokens": "def reraise ( error ) : if hasattr ( error , \"_type_\" ) : six . reraise ( type ( error ) , error , error . _traceback ) raise error", "docstring_tokens": "Re - raises the error that was processed by prepare_for_reraise earlier .", "label": 0}, {"idx": "cosqa-train-7560", "doc": "how to put 3d position in python", "code": "def list(self):\n        \"\"\"position in 3d space\"\"\"\n        return [self._pos3d.x, self._pos3d.y, self._pos3d.z]", "code_tokens": "def list ( self ) : return [ self . _pos3d . x , self . _pos3d . y , self . _pos3d . z ]", "docstring_tokens": "position in 3d space", "label": 1}, {"idx": "cosqa-train-7561", "doc": "python round to x decimal place", "code": "def round_to_x_digits(number, digits):\n    \"\"\"\n    Returns 'number' rounded to 'digits' digits.\n    \"\"\"\n    return round(number * math.pow(10, digits)) / math.pow(10, digits)", "code_tokens": "def round_to_x_digits ( number , digits ) : return round ( number * math . pow ( 10 , digits ) ) / math . pow ( 10 , digits )", "docstring_tokens": "Returns number rounded to digits digits .", "label": 1}, {"idx": "cosqa-train-7562", "doc": "how to put in an error message in python flask", "code": "def handle_exception(error):\n        \"\"\"Simple method for handling exceptions raised by `PyBankID`.\n\n        :param flask_pybankid.FlaskPyBankIDError error: The exception to handle.\n        :return: The exception represented as a dictionary.\n        :rtype: dict\n\n        \"\"\"\n        response = jsonify(error.to_dict())\n        response.status_code = error.status_code\n        return response", "code_tokens": "def handle_exception ( error ) : response = jsonify ( error . to_dict ( ) ) response . status_code = error . status_code return response", "docstring_tokens": "Simple method for handling exceptions raised by PyBankID .", "label": 1}, {"idx": "cosqa-train-7563", "doc": "python routine remove stop words", "code": "def _removeStopwords(text_list):\n    \"\"\"\n    Removes stopwords contained in a list of words.\n\n    :param text_string: A list of strings.\n    :type text_string: list.\n\n    :returns: The input ``text_list`` with stopwords removed.\n    :rtype: list\n    \"\"\"\n\n    output_list = []\n\n    for word in text_list:\n        if word.lower() not in _stopwords:\n            output_list.append(word)\n\n    return output_list", "code_tokens": "def _removeStopwords ( text_list ) : output_list = [ ] for word in text_list : if word . lower ( ) not in _stopwords : output_list . append ( word ) return output_list", "docstring_tokens": "Removes stopwords contained in a list of words .", "label": 0}, {"idx": "cosqa-train-7564", "doc": "how to python3 user input", "code": "def _stdin_(p):\n    \"\"\"Takes input from user. Works for Python 2 and 3.\"\"\"\n    _v = sys.version[0]\n    return input(p) if _v is '3' else raw_input(p)", "code_tokens": "def _stdin_ ( p ) : _v = sys . version [ 0 ] return input ( p ) if _v is '3' else raw_input ( p )", "docstring_tokens": "Takes input from user . Works for Python 2 and 3 .", "label": 0}, {"idx": "cosqa-train-7565", "doc": "python run a function on a timer", "code": "def set(self, f):\n        \"\"\"Call a function after a delay, unless another function is set\n        in the meantime.\"\"\"\n        self.stop()\n        self._create_timer(f)\n        self.start()", "code_tokens": "def set ( self , f ) : self . stop ( ) self . _create_timer ( f ) self . start ( )", "docstring_tokens": "Call a function after a delay unless another function is set in the meantime .", "label": 1}, {"idx": "cosqa-train-7566", "doc": "how to quit the existing python session", "code": "def __del__(self):\n        \"\"\"Cleanup the session if it was created here\"\"\"\n        if self._cleanup_session:\n            self._session.loop.run_until_complete(self._session.close())", "code_tokens": "def __del__ ( self ) : if self . _cleanup_session : self . _session . loop . run_until_complete ( self . _session . close ( ) )", "docstring_tokens": "Cleanup the session if it was created here", "label": 1}, {"idx": "cosqa-train-7567", "doc": "python run a task every seconds asyncio", "code": "def sleep(self, time):\n        \"\"\"\n        Perform an asyncio sleep for the time specified in seconds. T\n        his method should be used in place of time.sleep()\n\n        :param time: time in seconds\n        :returns: No return value\n        \"\"\"\n        try:\n            task = asyncio.ensure_future(self.core.sleep(time))\n            self.loop.run_until_complete(task)\n\n        except asyncio.CancelledError:\n            pass\n        except RuntimeError:\n            pass", "code_tokens": "def sleep ( self , time ) : try : task = asyncio . ensure_future ( self . core . sleep ( time ) ) self . loop . run_until_complete ( task ) except asyncio . CancelledError : pass except RuntimeError : pass", "docstring_tokens": "Perform an asyncio sleep for the time specified in seconds . T his method should be used in place of time . sleep ()", "label": 0}, {"idx": "cosqa-train-7568", "doc": "how to raise a number to a power in python 3", "code": "def _power(ctx, number, power):\n    \"\"\"\n    Returns the result of a number raised to a power\n    \"\"\"\n    return decimal_pow(conversions.to_decimal(number, ctx), conversions.to_decimal(power, ctx))", "code_tokens": "def _power ( ctx , number , power ) : return decimal_pow ( conversions . to_decimal ( number , ctx ) , conversions . to_decimal ( power , ctx ) )", "docstring_tokens": "Returns the result of a number raised to a power", "label": 1}, {"idx": "cosqa-train-7569", "doc": "python run asyncio function from regular function", "code": "async def _thread_coro(self, *args):\n        \"\"\" Coroutine called by MapAsync. It's wrapping the call of\n        run_in_executor to run the synchronous function as thread \"\"\"\n        return await self._loop.run_in_executor(\n            self._executor, self._function, *args)", "code_tokens": "async def _thread_coro ( self , * args ) : return await self . _loop . run_in_executor ( self . _executor , self . _function , * args )", "docstring_tokens": "Coroutine called by MapAsync . It s wrapping the call of run_in_executor to run the synchronous function as thread", "label": 1}, {"idx": "cosqa-train-7570", "doc": "how to randomize a select list in python", "code": "def get_randomized_guid_sample(self, item_count):\n        \"\"\" Fetch a subset of randomzied GUIDs from the whitelist \"\"\"\n        dataset = self.get_whitelist()\n        random.shuffle(dataset)\n        return dataset[:item_count]", "code_tokens": "def get_randomized_guid_sample ( self , item_count ) : dataset = self . get_whitelist ( ) random . shuffle ( dataset ) return dataset [ : item_count ]", "docstring_tokens": "Fetch a subset of randomzied GUIDs from the whitelist", "label": 1}, {"idx": "cosqa-train-7571", "doc": "python safe make dir", "code": "def safe_mkdir_for(path, clean=False):\n  \"\"\"Ensure that the parent directory for a file is present.\n\n  If it's not there, create it. If it is, no-op.\n  \"\"\"\n  safe_mkdir(os.path.dirname(path), clean=clean)", "code_tokens": "def safe_mkdir_for ( path , clean = False ) : safe_mkdir ( os . path . dirname ( path ) , clean = clean )", "docstring_tokens": "Ensure that the parent directory for a file is present .", "label": 0}, {"idx": "cosqa-train-7572", "doc": "how to randomly index x elements from an array python", "code": "def downsample(array, k):\n    \"\"\"Choose k random elements of array.\"\"\"\n    length = array.shape[0]\n    indices = random.sample(xrange(length), k)\n    return array[indices]", "code_tokens": "def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . sample ( xrange ( length ) , k ) return array [ indices ]", "docstring_tokens": "Choose k random elements of array .", "label": 1}, {"idx": "cosqa-train-7573", "doc": "python safe terminate processes", "code": "def kill_mprocess(process):\n    \"\"\"kill process\n    Args:\n        process - Popen object for process\n    \"\"\"\n    if process and proc_alive(process):\n        process.terminate()\n        process.communicate()\n    return not proc_alive(process)", "code_tokens": "def kill_mprocess ( process ) : if process and proc_alive ( process ) : process . terminate ( ) process . communicate ( ) return not proc_alive ( process )", "docstring_tokens": "kill process Args : process - Popen object for process", "label": 1}, {"idx": "cosqa-train-7574", "doc": "how to read in a file in python utf8 encoded", "code": "def read_utf8(fh, byteorder, dtype, count, offsetsize):\n    \"\"\"Read tag data from file and return as unicode string.\"\"\"\n    return fh.read(count).decode('utf-8')", "code_tokens": "def read_utf8 ( fh , byteorder , dtype , count , offsetsize ) : return fh . read ( count ) . decode ( 'utf-8' )", "docstring_tokens": "Read tag data from file and return as unicode string .", "label": 1}, {"idx": "cosqa-train-7575", "doc": "python save file to temporary directory then stream it to memcached", "code": "def save_cache(data, filename):\n    \"\"\"Save cookies to a file.\"\"\"\n    with open(filename, 'wb') as handle:\n        pickle.dump(data, handle)", "code_tokens": "def save_cache ( data , filename ) : with open ( filename , 'wb' ) as handle : pickle . dump ( data , handle )", "docstring_tokens": "Save cookies to a file .", "label": 0}, {"idx": "cosqa-train-7576", "doc": "how to read python input from stdin", "code": "def standard_input():\n    \"\"\"Generator that yields lines from standard input.\"\"\"\n    with click.get_text_stream(\"stdin\") as stdin:\n        while stdin.readable():\n            line = stdin.readline()\n            if line:\n                yield line.strip().encode(\"utf-8\")", "code_tokens": "def standard_input ( ) : with click . get_text_stream ( \"stdin\" ) as stdin : while stdin . readable ( ) : line = stdin . readline ( ) if line : yield line . strip ( ) . encode ( \"utf-8\" )", "docstring_tokens": "Generator that yields lines from standard input .", "label": 1}, {"idx": "cosqa-train-7577", "doc": "how to read r rds object in python", "code": "def load_graph_from_rdf(fname):\n    \"\"\" reads an RDF file into a graph \"\"\"\n    print(\"reading RDF from \" + fname + \"....\")\n    store = Graph()\n    store.parse(fname, format=\"n3\")\n    print(\"Loaded \" + str(len(store)) + \" tuples\")\n    return store", "code_tokens": "def load_graph_from_rdf ( fname ) : print ( \"reading RDF from \" + fname + \"....\" ) store = Graph ( ) store . parse ( fname , format = \"n3\" ) print ( \"Loaded \" + str ( len ( store ) ) + \" tuples\" ) return store", "docstring_tokens": "reads an RDF file into a graph", "label": 0}, {"idx": "cosqa-train-7578", "doc": "python saving pickle file", "code": "def pickle_save(thing,fname):\n    \"\"\"save something to a pickle file\"\"\"\n    pickle.dump(thing, open(fname,\"wb\"),pickle.HIGHEST_PROTOCOL)\n    return thing", "code_tokens": "def pickle_save ( thing , fname ) : pickle . dump ( thing , open ( fname , \"wb\" ) , pickle . HIGHEST_PROTOCOL ) return thing", "docstring_tokens": "save something to a pickle file", "label": 0}, {"idx": "cosqa-train-7579", "doc": "how to read the last n lines of a program on python", "code": "def get_readline_tail(self, n=10):\n        \"\"\"Get the last n items in readline history.\"\"\"\n        end = self.shell.readline.get_current_history_length() + 1\n        start = max(end-n, 1)\n        ghi = self.shell.readline.get_history_item\n        return [ghi(x) for x in range(start, end)]", "code_tokens": "def get_readline_tail ( self , n = 10 ) : end = self . shell . readline . get_current_history_length ( ) + 1 start = max ( end - n , 1 ) ghi = self . shell . readline . get_history_item return [ ghi ( x ) for x in range ( start , end ) ]", "docstring_tokens": "Get the last n items in readline history .", "label": 1}, {"idx": "cosqa-train-7580", "doc": "python scipy interpolate datetime", "code": "def spline_interpolate_by_datetime(datetime_axis, y_axis, datetime_new_axis):\n    \"\"\"A datetime-version that takes datetime object list as x_axis\n    \"\"\"\n    numeric_datetime_axis = [\n        totimestamp(a_datetime) for a_datetime in datetime_axis\n    ]\n\n    numeric_datetime_new_axis = [\n        totimestamp(a_datetime) for a_datetime in datetime_new_axis\n    ]\n\n    return spline_interpolate(\n        numeric_datetime_axis, y_axis, numeric_datetime_new_axis)", "code_tokens": "def spline_interpolate_by_datetime ( datetime_axis , y_axis , datetime_new_axis ) : numeric_datetime_axis = [ totimestamp ( a_datetime ) for a_datetime in datetime_axis ] numeric_datetime_new_axis = [ totimestamp ( a_datetime ) for a_datetime in datetime_new_axis ] return spline_interpolate ( numeric_datetime_axis , y_axis , numeric_datetime_new_axis )", "docstring_tokens": "A datetime - version that takes datetime object list as x_axis", "label": 0}, {"idx": "cosqa-train-7581", "doc": "how to remive html format in python", "code": "def html_to_text(content):\n    \"\"\" Converts html content to plain text \"\"\"\n    text = None\n    h2t = html2text.HTML2Text()\n    h2t.ignore_links = False\n    text = h2t.handle(content)\n    return text", "code_tokens": "def html_to_text ( content ) : text = None h2t = html2text . HTML2Text ( ) h2t . ignore_links = False text = h2t . handle ( content ) return text", "docstring_tokens": "Converts html content to plain text", "label": 0}, {"idx": "cosqa-train-7582", "doc": "python scipy sparse multiply", "code": "def scipy_sparse_to_spmatrix(A):\n    \"\"\"Efficient conversion from scipy sparse matrix to cvxopt sparse matrix\"\"\"\n    coo = A.tocoo()\n    SP = spmatrix(coo.data.tolist(), coo.row.tolist(), coo.col.tolist(), size=A.shape)\n    return SP", "code_tokens": "def scipy_sparse_to_spmatrix ( A ) : coo = A . tocoo ( ) SP = spmatrix ( coo . data . tolist ( ) , coo . row . tolist ( ) , coo . col . tolist ( ) , size = A . shape ) return SP", "docstring_tokens": "Efficient conversion from scipy sparse matrix to cvxopt sparse matrix", "label": 0}, {"idx": "cosqa-train-7583", "doc": "how to remove \\\\ in windows path python", "code": "def path(self):\n        \"\"\"\n        Return the path always without the \\\\?\\ prefix.\n        \"\"\"\n        path = super(WindowsPath2, self).path\n        if path.startswith(\"\\\\\\\\?\\\\\"):\n            return path[4:]\n        return path", "code_tokens": "def path ( self ) : path = super ( WindowsPath2 , self ) . path if path . startswith ( \"\\\\\\\\?\\\\\" ) : return path [ 4 : ] return path", "docstring_tokens": "Return the path always without the \\\\ ? \\ prefix .", "label": 1}, {"idx": "cosqa-train-7584", "doc": "how to remove \\n from the right side of values in python", "code": "def normalize_value(text):\n    \"\"\"\n    This removes newlines and multiple spaces from a string.\n    \"\"\"\n    result = text.replace('\\n', ' ')\n    result = re.subn('[ ]{2,}', ' ', result)[0]\n    return result", "code_tokens": "def normalize_value ( text ) : result = text . replace ( '\\n' , ' ' ) result = re . subn ( '[ ]{2,}' , ' ' , result ) [ 0 ] return result", "docstring_tokens": "This removes newlines and multiple spaces from a string .", "label": 1}, {"idx": "cosqa-train-7585", "doc": "python scipy write wav file", "code": "def write_wav(path, samples, sr=16000):\n    \"\"\"\n    Write to given samples to a wav file.\n    The samples are expected to be floating point numbers\n    in the range of -1.0 to 1.0.\n\n    Args:\n        path (str): The path to write the wav to.\n        samples (np.array): A float array .\n        sr (int): The sampling rate.\n    \"\"\"\n    max_value = np.abs(np.iinfo(np.int16).min)\n    data = (samples * max_value).astype(np.int16)\n    scipy.io.wavfile.write(path, sr, data)", "code_tokens": "def write_wav ( path , samples , sr = 16000 ) : max_value = np . abs ( np . iinfo ( np . int16 ) . min ) data = ( samples * max_value ) . astype ( np . int16 ) scipy . io . wavfile . write ( path , sr , data )", "docstring_tokens": "Write to given samples to a wav file . The samples are expected to be floating point numbers in the range of - 1 . 0 to 1 . 0 .", "label": 1}, {"idx": "cosqa-train-7586", "doc": "how to remove axis python", "code": "def clean_axis(axis):\n    \"\"\"Remove ticks, tick labels, and frame from axis\"\"\"\n    axis.get_xaxis().set_ticks([])\n    axis.get_yaxis().set_ticks([])\n    for spine in list(axis.spines.values()):\n        spine.set_visible(False)", "code_tokens": "def clean_axis ( axis ) : axis . get_xaxis ( ) . set_ticks ( [ ] ) axis . get_yaxis ( ) . set_ticks ( [ ] ) for spine in list ( axis . spines . values ( ) ) : spine . set_visible ( False )", "docstring_tokens": "Remove ticks tick labels and frame from axis", "label": 0}, {"idx": "cosqa-train-7587", "doc": "python script to check a url and see the return", "code": "def get_url_nofollow(url):\n\t\"\"\" \n\tfunction to get return code of a url\n\n\tCredits: http://blog.jasonantman.com/2013/06/python-script-to-check-a-list-of-urls-for-return-code-and-final-return-code-if-redirected/\n\t\"\"\"\n\ttry:\n\t\tresponse = urlopen(url)\n\t\tcode = response.getcode()\n\t\treturn code\n\texcept HTTPError as e:\n\t\treturn e.code\n\texcept:\n\t\treturn 0", "code_tokens": "def get_url_nofollow ( url ) : try : response = urlopen ( url ) code = response . getcode ( ) return code except HTTPError as e : return e . code except : return 0", "docstring_tokens": "function to get return code of a url", "label": 0}, {"idx": "cosqa-train-7588", "doc": "how to remove commas python string", "code": "def seq_to_str(obj, sep=\",\"):\n    \"\"\"\n    Given a sequence convert it to a comma separated string.\n    If, however, the argument is a single object, return its string\n    representation.\n    \"\"\"\n    if isinstance(obj, string_classes):\n        return obj\n    elif isinstance(obj, (list, tuple)):\n        return sep.join([str(x) for x in obj])\n    else:\n        return str(obj)", "code_tokens": "def seq_to_str ( obj , sep = \",\" ) : if isinstance ( obj , string_classes ) : return obj elif isinstance ( obj , ( list , tuple ) ) : return sep . join ( [ str ( x ) for x in obj ] ) else : return str ( obj )", "docstring_tokens": "Given a sequence convert it to a comma separated string . If however the argument is a single object return its string representation .", "label": 1}, {"idx": "cosqa-train-7589", "doc": "python script to design line length of a file", "code": "def indentsize(line):\n    \"\"\"Return the indent size, in spaces, at the start of a line of text.\"\"\"\n    expline = string.expandtabs(line)\n    return len(expline) - len(string.lstrip(expline))", "code_tokens": "def indentsize ( line ) : expline = string . expandtabs ( line ) return len ( expline ) - len ( string . lstrip ( expline ) )", "docstring_tokens": "Return the indent size in spaces at the start of a line of text .", "label": 0}, {"idx": "cosqa-train-7590", "doc": "how to remove duplicaate from python list", "code": "def remove_list_duplicates(lista, unique=False):\n    \"\"\"\n    Remove duplicated elements in a list.\n    Args:\n        lista: List with elements to clean duplicates.\n    \"\"\"\n    result = []\n    allready = []\n\n    for elem in lista:\n        if elem not in result:\n            result.append(elem)\n        else:\n            allready.append(elem)\n\n    if unique:\n        for elem in allready:\n            result = list(filter((elem).__ne__, result))\n\n    return result", "code_tokens": "def remove_list_duplicates ( lista , unique = False ) : result = [ ] allready = [ ] for elem in lista : if elem not in result : result . append ( elem ) else : allready . append ( elem ) if unique : for elem in allready : result = list ( filter ( ( elem ) . __ne__ , result ) ) return result", "docstring_tokens": "Remove duplicated elements in a list . Args : lista : List with elements to clean duplicates .", "label": 0}, {"idx": "cosqa-train-7591", "doc": "python scrollbar for canvas", "code": "def set_scrollregion(self, event=None):\n        \"\"\" Set the scroll region on the canvas\"\"\"\n        self.canvas.configure(scrollregion=self.canvas.bbox('all'))", "code_tokens": "def set_scrollregion ( self , event = None ) : self . canvas . configure ( scrollregion = self . canvas . bbox ( 'all' ) )", "docstring_tokens": "Set the scroll region on the canvas", "label": 0}, {"idx": "cosqa-train-7592", "doc": "how to remove last line of string python", "code": "def get_line_ending(line):\n    \"\"\"Return line ending.\"\"\"\n    non_whitespace_index = len(line.rstrip()) - len(line)\n    if not non_whitespace_index:\n        return ''\n    else:\n        return line[non_whitespace_index:]", "code_tokens": "def get_line_ending ( line ) : non_whitespace_index = len ( line . rstrip ( ) ) - len ( line ) if not non_whitespace_index : return '' else : return line [ non_whitespace_index : ]", "docstring_tokens": "Return line ending .", "label": 0}, {"idx": "cosqa-train-7593", "doc": "how to remove legend on a python plot", "code": "def remove_legend(ax=None):\n    \"\"\"Remove legend for axes or gca.\n\n    See http://osdir.com/ml/python.matplotlib.general/2005-07/msg00285.html\n    \"\"\"\n    from pylab import gca, draw\n    if ax is None:\n        ax = gca()\n    ax.legend_ = None\n    draw()", "code_tokens": "def remove_legend ( ax = None ) : from pylab import gca , draw if ax is None : ax = gca ( ) ax . legend_ = None draw ( )", "docstring_tokens": "Remove legend for axes or gca .", "label": 1}, {"idx": "cosqa-train-7594", "doc": "python select a random timestamp between 2 timestamps", "code": "def date(start, end):\n    \"\"\"Get a random date between two dates\"\"\"\n\n    stime = date_to_timestamp(start)\n    etime = date_to_timestamp(end)\n\n    ptime = stime + random.random() * (etime - stime)\n\n    return datetime.date.fromtimestamp(ptime)", "code_tokens": "def date ( start , end ) : stime = date_to_timestamp ( start ) etime = date_to_timestamp ( end ) ptime = stime + random . random ( ) * ( etime - stime ) return datetime . date . fromtimestamp ( ptime )", "docstring_tokens": "Get a random date between two dates", "label": 1}, {"idx": "cosqa-train-7595", "doc": "how to remove noise from an image python", "code": "def shot_noise(x, severity=1):\n  \"\"\"Shot noise corruption to images.\n\n  Args:\n    x: numpy array, uncorrupted image, assumed to have uint8 pixel in [0,255].\n    severity: integer, severity of corruption.\n\n  Returns:\n    numpy array, image with uint8 pixels in [0,255]. Added shot noise.\n  \"\"\"\n  c = [60, 25, 12, 5, 3][severity - 1]\n  x = np.array(x) / 255.\n  x_clip = np.clip(np.random.poisson(x * c) / float(c), 0, 1) * 255\n  return around_and_astype(x_clip)", "code_tokens": "def shot_noise ( x , severity = 1 ) : c = [ 60 , 25 , 12 , 5 , 3 ] [ severity - 1 ] x = np . array ( x ) / 255. x_clip = np . clip ( np . random . poisson ( x * c ) / float ( c ) , 0 , 1 ) * 255 return around_and_astype ( x_clip )", "docstring_tokens": "Shot noise corruption to images .", "label": 1}, {"idx": "cosqa-train-7596", "doc": "python select equal to", "code": "def selecttrue(table, field, complement=False):\n    \"\"\"Select rows where the given field evaluates `True`.\"\"\"\n\n    return select(table, field, lambda v: bool(v), complement=complement)", "code_tokens": "def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )", "docstring_tokens": "Select rows where the given field evaluates True .", "label": 1}, {"idx": "cosqa-train-7597", "doc": "how to remove outer apostrophes and not inner python", "code": "def format_screen(strng):\n    \"\"\"Format a string for screen printing.\n\n    This removes some latex-type format codes.\"\"\"\n    # Paragraph continue\n    par_re = re.compile(r'\\\\$',re.MULTILINE)\n    strng = par_re.sub('',strng)\n    return strng", "code_tokens": "def format_screen ( strng ) : # Paragraph continue par_re = re . compile ( r'\\\\$' , re . MULTILINE ) strng = par_re . sub ( '' , strng ) return strng", "docstring_tokens": "Format a string for screen printing .", "label": 0}, {"idx": "cosqa-train-7598", "doc": "python select not null column values", "code": "def selectnotnone(table, field, complement=False):\n    \"\"\"Select rows where the given field is not `None`.\"\"\"\n\n    return select(table, field, lambda v: v is not None,\n                  complement=complement)", "code_tokens": "def selectnotnone ( table , field , complement = False ) : return select ( table , field , lambda v : v is not None , complement = complement )", "docstring_tokens": "Select rows where the given field is not None .", "label": 1}, {"idx": "cosqa-train-7599", "doc": "how to remove parth of the url python", "code": "def strip_querystring(url):\n    \"\"\"Remove the querystring from the end of a URL.\"\"\"\n    p = six.moves.urllib.parse.urlparse(url)\n    return p.scheme + \"://\" + p.netloc + p.path", "code_tokens": "def strip_querystring ( url ) : p = six . moves . urllib . parse . urlparse ( url ) return p . scheme + \"://\" + p . netloc + p . path", "docstring_tokens": "Remove the querystring from the end of a URL .", "label": 1}, {"idx": "cosqa-train-7600", "doc": "python select rows based on boolean", "code": "def selecttrue(table, field, complement=False):\n    \"\"\"Select rows where the given field evaluates `True`.\"\"\"\n\n    return select(table, field, lambda v: bool(v), complement=complement)", "code_tokens": "def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )", "docstring_tokens": "Select rows where the given field evaluates True .", "label": 0}, {"idx": "cosqa-train-7601", "doc": "how to remove repeat instances in a list python", "code": "def dedupe_list(seq):\n    \"\"\"\n    Utility function to remove duplicates from a list\n    :param seq: The sequence (list) to deduplicate\n    :return: A list with original duplicates removed\n    \"\"\"\n    seen = set()\n    return [x for x in seq if not (x in seen or seen.add(x))]", "code_tokens": "def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed", "label": 1}, {"idx": "cosqa-train-7602", "doc": "python select rows by bool value", "code": "def selecttrue(table, field, complement=False):\n    \"\"\"Select rows where the given field evaluates `True`.\"\"\"\n\n    return select(table, field, lambda v: bool(v), complement=complement)", "code_tokens": "def selecttrue ( table , field , complement = False ) : return select ( table , field , lambda v : bool ( v ) , complement = complement )", "docstring_tokens": "Select rows where the given field evaluates True .", "label": 0}, {"idx": "cosqa-train-7603", "doc": "how to remove space from a string python to list", "code": "def _str_to_list(s):\n    \"\"\"Converts a comma separated string to a list\"\"\"\n    _list = s.split(\",\")\n    return list(map(lambda i: i.lstrip(), _list))", "code_tokens": "def _str_to_list ( s ) : _list = s . split ( \",\" ) return list ( map ( lambda i : i . lstrip ( ) , _list ) )", "docstring_tokens": "Converts a comma separated string to a list", "label": 0}, {"idx": "cosqa-train-7604", "doc": "python select set of keys from dict", "code": "def _pick_attrs(attrs, keys):\n    \"\"\" Return attrs with keys in keys list\n    \"\"\"\n    return dict((k, v) for k, v in attrs.items() if k in keys)", "code_tokens": "def _pick_attrs ( attrs , keys ) : return dict ( ( k , v ) for k , v in attrs . items ( ) if k in keys )", "docstring_tokens": "Return attrs with keys in keys list", "label": 1}, {"idx": "cosqa-train-7605", "doc": "how to remove spaces from python string", "code": "def fix_dashes(string):\n    \"\"\"Fix bad Unicode special dashes in string.\"\"\"\n    string = string.replace(u'\\u05BE', '-')\n    string = string.replace(u'\\u1806', '-')\n    string = string.replace(u'\\u2E3A', '-')\n    string = string.replace(u'\\u2E3B', '-')\n    string = unidecode(string)\n    return re.sub(r'--+', '-', string)", "code_tokens": "def fix_dashes ( string ) : string = string . replace ( u'\\u05BE' , '-' ) string = string . replace ( u'\\u1806' , '-' ) string = string . replace ( u'\\u2E3A' , '-' ) string = string . replace ( u'\\u2E3B' , '-' ) string = unidecode ( string ) return re . sub ( r'--+' , '-' , string )", "docstring_tokens": "Fix bad Unicode special dashes in string .", "label": 0}, {"idx": "cosqa-train-7606", "doc": "python selecting from different dimensions of an array", "code": "def _indexes(arr):\n    \"\"\" Returns the list of all indexes of the given array.\n\n    Currently works for one and two-dimensional arrays\n\n    \"\"\"\n    myarr = np.array(arr)\n    if myarr.ndim == 1:\n        return list(range(len(myarr)))\n    elif myarr.ndim == 2:\n        return tuple(itertools.product(list(range(arr.shape[0])),\n                                       list(range(arr.shape[1]))))\n    else:\n        raise NotImplementedError('Only supporting arrays of dimension 1 and 2 as yet.')", "code_tokens": "def _indexes ( arr ) : myarr = np . array ( arr ) if myarr . ndim == 1 : return list ( range ( len ( myarr ) ) ) elif myarr . ndim == 2 : return tuple ( itertools . product ( list ( range ( arr . shape [ 0 ] ) ) , list ( range ( arr . shape [ 1 ] ) ) ) ) else : raise NotImplementedError ( 'Only supporting arrays of dimension 1 and 2 as yet.' )", "docstring_tokens": "Returns the list of all indexes of the given array .", "label": 1}, {"idx": "cosqa-train-7607", "doc": "how to remove spaces from string in python", "code": "def sanitize_word(s):\n    \"\"\"Remove non-alphanumerical characters from metric word.\n    And trim excessive underscores.\n    \"\"\"\n    s = re.sub('[^\\w-]+', '_', s)\n    s = re.sub('__+', '_', s)\n    return s.strip('_')", "code_tokens": "def sanitize_word ( s ) : s = re . sub ( '[^\\w-]+' , '_' , s ) s = re . sub ( '__+' , '_' , s ) return s . strip ( '_' )", "docstring_tokens": "Remove non - alphanumerical characters from metric word . And trim excessive underscores .", "label": 1}, {"idx": "cosqa-train-7608", "doc": "python self same as this", "code": "def copy(self):\n        \"\"\"Create an identical (deep) copy of this element.\"\"\"\n        result = self.space.element()\n        result.assign(self)\n        return result", "code_tokens": "def copy ( self ) : result = self . space . element ( ) result . assign ( self ) return result", "docstring_tokens": "Create an identical ( deep ) copy of this element .", "label": 0}, {"idx": "cosqa-train-7609", "doc": "how to remove stopwords python without nltk", "code": "def wordify(text):\n    \"\"\"Generate a list of words given text, removing punctuation.\n\n    Parameters\n    ----------\n    text : unicode\n        A piece of english text.\n\n    Returns\n    -------\n    words : list\n        List of words.\n    \"\"\"\n    stopset = set(nltk.corpus.stopwords.words('english'))\n    tokens = nltk.WordPunctTokenizer().tokenize(text)\n    return [w for w in tokens if w not in stopset]", "code_tokens": "def wordify ( text ) : stopset = set ( nltk . corpus . stopwords . words ( 'english' ) ) tokens = nltk . WordPunctTokenizer ( ) . tokenize ( text ) return [ w for w in tokens if w not in stopset ]", "docstring_tokens": "Generate a list of words given text removing punctuation .", "label": 1}, {"idx": "cosqa-train-7610", "doc": "python send data across thread", "code": "async def send(self, data):\n        \"\"\" Add data to send queue. \"\"\"\n        self.writer.write(data)\n        await self.writer.drain()", "code_tokens": "async def send ( self , data ) : self . writer . write ( data ) await self . writer . drain ( )", "docstring_tokens": "Add data to send queue .", "label": 1}, {"idx": "cosqa-train-7611", "doc": "how to remove symlink in python", "code": "def symlink_remove(link):\n    \"\"\"Remove a symlink. Used for model shortcut links.\n\n    link (unicode / Path): The path to the symlink.\n    \"\"\"\n    # https://stackoverflow.com/q/26554135/6400719\n    if os.path.isdir(path2str(link)) and is_windows:\n        # this should only be on Py2.7 and windows\n        os.rmdir(path2str(link))\n    else:\n        os.unlink(path2str(link))", "code_tokens": "def symlink_remove ( link ) : # https://stackoverflow.com/q/26554135/6400719 if os . path . isdir ( path2str ( link ) ) and is_windows : # this should only be on Py2.7 and windows os . rmdir ( path2str ( link ) ) else : os . unlink ( path2str ( link ) )", "docstring_tokens": "Remove a symlink . Used for model shortcut links .", "label": 1}, {"idx": "cosqa-train-7612", "doc": "python sequence export as pmml", "code": "def cli(yamlfile, format, output):\n    \"\"\" Generate an OWL representation of a biolink model \"\"\"\n    print(OwlSchemaGenerator(yamlfile, format).serialize(output=output))", "code_tokens": "def cli ( yamlfile , format , output ) : print ( OwlSchemaGenerator ( yamlfile , format ) . serialize ( output = output ) )", "docstring_tokens": "Generate an OWL representation of a biolink model", "label": 0}, {"idx": "cosqa-train-7613", "doc": "how to remove white spaces in a file in python", "code": "def get_stripped_file_lines(filename):\n    \"\"\"\n    Return lines of a file with whitespace removed\n    \"\"\"\n    try:\n        lines = open(filename).readlines()\n    except FileNotFoundError:\n        fatal(\"Could not open file: {!r}\".format(filename))\n\n    return [line.strip() for line in lines]", "code_tokens": "def get_stripped_file_lines ( filename ) : try : lines = open ( filename ) . readlines ( ) except FileNotFoundError : fatal ( \"Could not open file: {!r}\" . format ( filename ) ) return [ line . strip ( ) for line in lines ]", "docstring_tokens": "Return lines of a file with whitespace removed", "label": 0}, {"idx": "cosqa-train-7614", "doc": "python serializers validate list", "code": "def serialize(self, value, **kwargs):\n        \"\"\"Serialize every item of the list.\"\"\"\n        return [self.item_type.serialize(val, **kwargs) for val in value]", "code_tokens": "def serialize ( self , value , * * kwargs ) : return [ self . item_type . serialize ( val , * * kwargs ) for val in value ]", "docstring_tokens": "Serialize every item of the list .", "label": 1}, {"idx": "cosqa-train-7615", "doc": "how to render a image in python", "code": "def draw_image(self, ax, image):\n        \"\"\"Process a matplotlib image object and call renderer.draw_image\"\"\"\n        self.renderer.draw_image(imdata=utils.image_to_base64(image),\n                                 extent=image.get_extent(),\n                                 coordinates=\"data\",\n                                 style={\"alpha\": image.get_alpha(),\n                                        \"zorder\": image.get_zorder()},\n                                 mplobj=image)", "code_tokens": "def draw_image ( self , ax , image ) : self . renderer . draw_image ( imdata = utils . image_to_base64 ( image ) , extent = image . get_extent ( ) , coordinates = \"data\" , style = { \"alpha\" : image . get_alpha ( ) , \"zorder\" : image . get_zorder ( ) } , mplobj = image )", "docstring_tokens": "Process a matplotlib image object and call renderer . draw_image", "label": 0}, {"idx": "cosqa-train-7616", "doc": "python series replace nan values by another series", "code": "def na_if(series, *values):\n    \"\"\"\n    If values in a series match a specified value, change them to `np.nan`.\n\n    Args:\n        series: Series or vector, often symbolic.\n        *values: Value(s) to convert to `np.nan` in the series.\n    \"\"\"\n\n    series = pd.Series(series)\n    series[series.isin(values)] = np.nan\n    return series", "code_tokens": "def na_if ( series , * values ) : series = pd . Series ( series ) series [ series . isin ( values ) ] = np . nan return series", "docstring_tokens": "If values in a series match a specified value change them to np . nan .", "label": 0}, {"idx": "cosqa-train-7617", "doc": "how to repeat an input command if an input is invalid in python", "code": "def get_input(input_func, input_str):\n    \"\"\"\n    Get input from the user given an input function and an input string\n    \"\"\"\n    val = input_func(\"Please enter your {0}: \".format(input_str))\n    while not val or not len(val.strip()):\n        val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))\n    return val", "code_tokens": "def get_input ( input_func , input_str ) : val = input_func ( \"Please enter your {0}: \" . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( \"You didn't enter a valid {0}, please try again: \" . format ( input_str ) ) return val", "docstring_tokens": "Get input from the user given an input function and an input string", "label": 0}, {"idx": "cosqa-train-7618", "doc": "python series without freq", "code": "def to_monthly(series, method='ffill', how='end'):\n    \"\"\"\n    Convenience method that wraps asfreq_actual\n    with 'M' param (method='ffill', how='end').\n    \"\"\"\n    return series.asfreq_actual('M', method=method, how=how)", "code_tokens": "def to_monthly ( series , method = 'ffill' , how = 'end' ) : return series . asfreq_actual ( 'M' , method = method , how = how )", "docstring_tokens": "Convenience method that wraps asfreq_actual with M param ( method = ffill how = end ) .", "label": 0}, {"idx": "cosqa-train-7619", "doc": "how to reset the input python", "code": "def internal_reset(self):\n        \"\"\"\n        internal state reset.\n        used e.g. in unittests\n        \"\"\"\n        log.critical(\"PIA internal_reset()\")\n        self.empty_key_toggle = True\n        self.current_input_char = None\n        self.input_repead = 0", "code_tokens": "def internal_reset ( self ) : log . critical ( \"PIA internal_reset()\" ) self . empty_key_toggle = True self . current_input_char = None self . input_repead = 0", "docstring_tokens": "internal state reset . used e . g . in unittests", "label": 1}, {"idx": "cosqa-train-7620", "doc": "python session object how to use cookie for request", "code": "def dispatch(self):\n    \"\"\"Wraps the dispatch method to add session support.\"\"\"\n    try:\n      webapp2.RequestHandler.dispatch(self)\n    finally:\n      self.session_store.save_sessions(self.response)", "code_tokens": "def dispatch ( self ) : try : webapp2 . RequestHandler . dispatch ( self ) finally : self . session_store . save_sessions ( self . response )", "docstring_tokens": "Wraps the dispatch method to add session support .", "label": 0}, {"idx": "cosqa-train-7621", "doc": "python set an image as background", "code": "def copy_image_on_background(image, color=WHITE):\n    \"\"\"\n    Create a new image by copying the image on a *color* background.\n\n    Args:\n        image (PIL.Image.Image): Image to copy\n        color (tuple): Background color usually WHITE or BLACK\n\n    Returns:\n        PIL.Image.Image\n\n    \"\"\"\n    background = Image.new(\"RGB\", image.size, color)\n    background.paste(image, mask=image.split()[3])\n    return background", "code_tokens": "def copy_image_on_background ( image , color = WHITE ) : background = Image . new ( \"RGB\" , image . size , color ) background . paste ( image , mask = image . split ( ) [ 3 ] ) return background", "docstring_tokens": "Create a new image by copying the image on a * color * background .", "label": 0}, {"idx": "cosqa-train-7622", "doc": "how to restrict cpu usage percent for python", "code": "def _cpu(self):\n        \"\"\"Record CPU usage.\"\"\"\n        value = int(psutil.cpu_percent())\n        set_metric(\"cpu\", value, category=self.category)\n        gauge(\"cpu\", value)", "code_tokens": "def _cpu ( self ) : value = int ( psutil . cpu_percent ( ) ) set_metric ( \"cpu\" , value , category = self . category ) gauge ( \"cpu\" , value )", "docstring_tokens": "Record CPU usage .", "label": 0}, {"idx": "cosqa-train-7623", "doc": "python set axes to 3d", "code": "def plot3d_init(fignum):\n    \"\"\"\n    initializes 3D plot\n    \"\"\"\n    from mpl_toolkits.mplot3d import Axes3D\n    fig = plt.figure(fignum)\n    ax = fig.add_subplot(111, projection='3d')\n    return ax", "code_tokens": "def plot3d_init ( fignum ) : from mpl_toolkits . mplot3d import Axes3D fig = plt . figure ( fignum ) ax = fig . add_subplot ( 111 , projection = '3d' ) return ax", "docstring_tokens": "initializes 3D plot", "label": 1}, {"idx": "cosqa-train-7624", "doc": "how to restrict float decimals in python", "code": "def roundClosestValid(val, res, decimals=None):\n        \"\"\" round to closest resolution \"\"\"\n        if decimals is None and \".\" in str(res):\n            decimals = len(str(res).split('.')[1])\n\n        return round(round(val / res) * res, decimals)", "code_tokens": "def roundClosestValid ( val , res , decimals = None ) : if decimals is None and \".\" in str ( res ) : decimals = len ( str ( res ) . split ( '.' ) [ 1 ] ) return round ( round ( val / res ) * res , decimals )", "docstring_tokens": "round to closest resolution", "label": 0}, {"idx": "cosqa-train-7625", "doc": "python set default value of dictionary", "code": "def setdefaults(dct, defaults):\n    \"\"\"Given a target dct and a dict of {key:default value} pairs,\n    calls setdefault for all of those pairs.\"\"\"\n    for key in defaults:\n        dct.setdefault(key, defaults[key])\n\n    return dct", "code_tokens": "def setdefaults ( dct , defaults ) : for key in defaults : dct . setdefault ( key , defaults [ key ] ) return dct", "docstring_tokens": "Given a target dct and a dict of { key : default value } pairs calls setdefault for all of those pairs .", "label": 1}, {"idx": "cosqa-train-7626", "doc": "how to return a hashtable as an array python", "code": "def _transform_triple_numpy(x):\n    \"\"\"Transform triple index into a 1-D numpy array.\"\"\"\n    return np.array([x.head, x.relation, x.tail], dtype=np.int64)", "code_tokens": "def _transform_triple_numpy ( x ) : return np . array ( [ x . head , x . relation , x . tail ] , dtype = np . int64 )", "docstring_tokens": "Transform triple index into a 1 - D numpy array .", "label": 1}, {"idx": "cosqa-train-7627", "doc": "python set location to center of screen", "code": "def ensure_hbounds(self):\n        \"\"\"Ensure the cursor is within horizontal screen bounds.\"\"\"\n        self.cursor.x = min(max(0, self.cursor.x), self.columns - 1)", "code_tokens": "def ensure_hbounds ( self ) : self . cursor . x = min ( max ( 0 , self . cursor . x ) , self . columns - 1 )", "docstring_tokens": "Ensure the cursor is within horizontal screen bounds .", "label": 0}, {"idx": "cosqa-train-7628", "doc": "how to return multiple numpy objects python", "code": "def unpack2D(_x):\n    \"\"\"\n        Helper function for splitting 2D data into x and y component to make\n        equations simpler\n    \"\"\"\n    _x = np.atleast_2d(_x)\n    x = _x[:, 0]\n    y = _x[:, 1]\n    return x, y", "code_tokens": "def unpack2D ( _x ) : _x = np . atleast_2d ( _x ) x = _x [ : , 0 ] y = _x [ : , 1 ] return x , y", "docstring_tokens": "Helper function for splitting 2D data into x and y component to make equations simpler", "label": 0}, {"idx": "cosqa-train-7629", "doc": "python set pdf properties", "code": "def security(self):\n        \"\"\"Print security object information for a pdf document\"\"\"\n        return {k: v for i in self.pdf.resolvedObjects.items() for k, v in i[1].items()}", "code_tokens": "def security ( self ) : return { k : v for i in self . pdf . resolvedObjects . items ( ) for k , v in i [ 1 ] . items ( ) }", "docstring_tokens": "Print security object information for a pdf document", "label": 1}, {"idx": "cosqa-train-7630", "doc": "how to return the index of a number in a list python", "code": "def is_in(self, search_list, pair):\n        \"\"\"\n        If pair is in search_list, return the index. Otherwise return -1\n        \"\"\"\n        index = -1\n        for nr, i in enumerate(search_list):\n            if(np.all(i == pair)):\n                return nr\n        return index", "code_tokens": "def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index", "docstring_tokens": "If pair is in search_list return the index . Otherwise return - 1", "label": 1}, {"idx": "cosqa-train-7631", "doc": "python set remove list of elements", "code": "def unique(_list):\n    \"\"\"\n    Makes the list have unique items only and maintains the order\n\n    list(set()) won't provide that\n\n    :type _list list\n    :rtype: list\n    \"\"\"\n    ret = []\n\n    for item in _list:\n        if item not in ret:\n            ret.append(item)\n\n    return ret", "code_tokens": "def unique ( _list ) : ret = [ ] for item in _list : if item not in ret : ret . append ( item ) return ret", "docstring_tokens": "Makes the list have unique items only and maintains the order", "label": 1}, {"idx": "cosqa-train-7632", "doc": "how to return the longest string in a python list", "code": "def get_longest_orf(orfs):\n    \"\"\"Find longest ORF from the given list of ORFs.\"\"\"\n    sorted_orf = sorted(orfs, key=lambda x: len(x['sequence']), reverse=True)[0]\n    return sorted_orf", "code_tokens": "def get_longest_orf ( orfs ) : sorted_orf = sorted ( orfs , key = lambda x : len ( x [ 'sequence' ] ) , reverse = True ) [ 0 ] return sorted_orf", "docstring_tokens": "Find longest ORF from the given list of ORFs .", "label": 1}, {"idx": "cosqa-train-7633", "doc": "python set x axis limits", "code": "def set_xlimits(self, min=None, max=None):\n        \"\"\"Set limits for the x-axis.\n\n        :param min: minimum value to be displayed.  If None, it will be\n            calculated.\n        :param max: maximum value to be displayed.  If None, it will be\n            calculated.\n\n        \"\"\"\n        self.limits['xmin'] = min\n        self.limits['xmax'] = max", "code_tokens": "def set_xlimits ( self , min = None , max = None ) : self . limits [ 'xmin' ] = min self . limits [ 'xmax' ] = max", "docstring_tokens": "Set limits for the x - axis .", "label": 1}, {"idx": "cosqa-train-7634", "doc": "how to rotate a matrix in place in python", "code": "def similarity_transformation(rot, mat):\n    \"\"\" R x M x R^-1 \"\"\"\n    return np.dot(rot, np.dot(mat, np.linalg.inv(rot)))", "code_tokens": "def similarity_transformation ( rot , mat ) : return np . dot ( rot , np . dot ( mat , np . linalg . inv ( rot ) ) )", "docstring_tokens": "R x M x R^ - 1", "label": 0}, {"idx": "cosqa-train-7635", "doc": "python setcurrentindex qcombobox changing the index, but not the value", "code": "def _updateItemComboBoxIndex(self, item, column, num):\n        \"\"\"Callback for comboboxes: notifies us that a combobox for the given item and column has changed\"\"\"\n        item._combobox_current_index[column] = num\n        item._combobox_current_value[column] = item._combobox_option_list[column][num][0]", "code_tokens": "def _updateItemComboBoxIndex ( self , item , column , num ) : item . _combobox_current_index [ column ] = num item . _combobox_current_value [ column ] = item . _combobox_option_list [ column ] [ num ] [ 0 ]", "docstring_tokens": "Callback for comboboxes : notifies us that a combobox for the given item and column has changed", "label": 1}, {"idx": "cosqa-train-7636", "doc": "how to round a float to an int in python", "code": "def intround(value):\n    \"\"\"Given a float returns a rounded int. Should give the same result on\n    both Py2/3\n    \"\"\"\n\n    return int(decimal.Decimal.from_float(\n        value).to_integral_value(decimal.ROUND_HALF_EVEN))", "code_tokens": "def intround ( value ) : return int ( decimal . Decimal . from_float ( value ) . to_integral_value ( decimal . ROUND_HALF_EVEN ) )", "docstring_tokens": "Given a float returns a rounded int . Should give the same result on both Py2 / 3", "label": 1}, {"idx": "cosqa-train-7637", "doc": "python sha256 hash on a string", "code": "def sha1(s):\n    \"\"\" Returns a sha1 of the given string\n    \"\"\"\n    h = hashlib.new('sha1')\n    h.update(s)\n    return h.hexdigest()", "code_tokens": "def sha1 ( s ) : h = hashlib . new ( 'sha1' ) h . update ( s ) return h . hexdigest ( )", "docstring_tokens": "Returns a sha1 of the given string", "label": 0}, {"idx": "cosqa-train-7638", "doc": "how to save a pyplot figure fig as pdf in python", "code": "def save_pdf(path):\n  \"\"\"\n  Saves a pdf of the current matplotlib figure.\n\n  :param path: str, filepath to save to\n  \"\"\"\n\n  pp = PdfPages(path)\n  pp.savefig(pyplot.gcf())\n  pp.close()", "code_tokens": "def save_pdf ( path ) : pp = PdfPages ( path ) pp . savefig ( pyplot . gcf ( ) ) pp . close ( )", "docstring_tokens": "Saves a pdf of the current matplotlib figure .", "label": 0}, {"idx": "cosqa-train-7639", "doc": "python shelve change extension", "code": "def open(self, flag=\"c\"):\n        \"\"\"Open handle\n\n        set protocol=2 to fix python3\n\n        .. versionadded:: 1.3.1\n        \"\"\"\n        return shelve.open(os.path.join(gettempdir(), self.index), flag=flag, protocol=2)", "code_tokens": "def open ( self , flag = \"c\" ) : return shelve . open ( os . path . join ( gettempdir ( ) , self . index ) , flag = flag , protocol = 2 )", "docstring_tokens": "Open handle", "label": 0}, {"idx": "cosqa-train-7640", "doc": "how to save figures in a pdf python", "code": "def save_pdf(path):\n  \"\"\"\n  Saves a pdf of the current matplotlib figure.\n\n  :param path: str, filepath to save to\n  \"\"\"\n\n  pp = PdfPages(path)\n  pp.savefig(pyplot.gcf())\n  pp.close()", "code_tokens": "def save_pdf ( path ) : pp = PdfPages ( path ) pp . savefig ( pyplot . gcf ( ) ) pp . close ( )", "docstring_tokens": "Saves a pdf of the current matplotlib figure .", "label": 1}, {"idx": "cosqa-train-7641", "doc": "python shift image horizontally", "code": "def hflip(img):\n    \"\"\"Horizontally flip the given PIL Image.\n\n    Args:\n        img (PIL Image): Image to be flipped.\n\n    Returns:\n        PIL Image:  Horizontall flipped image.\n    \"\"\"\n    if not _is_pil_image(img):\n        raise TypeError('img should be PIL Image. Got {}'.format(type(img)))\n\n    return img.transpose(Image.FLIP_LEFT_RIGHT)", "code_tokens": "def hflip ( img ) : if not _is_pil_image ( img ) : raise TypeError ( 'img should be PIL Image. Got {}' . format ( type ( img ) ) ) return img . transpose ( Image . FLIP_LEFT_RIGHT )", "docstring_tokens": "Horizontally flip the given PIL Image .", "label": 0}, {"idx": "cosqa-train-7642", "doc": "how to save string to html file in python", "code": "def _save_file(self, filename, contents):\n        \"\"\"write the html file contents to disk\"\"\"\n        with open(filename, 'w') as f:\n            f.write(contents)", "code_tokens": "def _save_file ( self , filename , contents ) : with open ( filename , 'w' ) as f : f . write ( contents )", "docstring_tokens": "write the html file contents to disk", "label": 1}, {"idx": "cosqa-train-7643", "doc": "python short cut key to format", "code": "def normalise_key(self, key):\n        \"\"\"Make sure key is a valid python attribute\"\"\"\n        key = key.replace('-', '_')\n        if key.startswith(\"noy_\"):\n            key = key[4:]\n        return key", "code_tokens": "def normalise_key ( self , key ) : key = key . replace ( '-' , '_' ) if key . startswith ( \"noy_\" ) : key = key [ 4 : ] return key", "docstring_tokens": "Make sure key is a valid python attribute", "label": 0}, {"idx": "cosqa-train-7644", "doc": "how to say if array and index python", "code": "def is_int_vector(l):\n    r\"\"\"Checks if l is a numpy array of integers\n\n    \"\"\"\n    if isinstance(l, np.ndarray):\n        if l.ndim == 1 and (l.dtype.kind == 'i' or l.dtype.kind == 'u'):\n            return True\n    return False", "code_tokens": "def is_int_vector ( l ) : if isinstance ( l , np . ndarray ) : if l . ndim == 1 and ( l . dtype . kind == 'i' or l . dtype . kind == 'u' ) : return True return False", "docstring_tokens": "r Checks if l is a numpy array of integers", "label": 0}, {"idx": "cosqa-train-7645", "doc": "python show max width and max columns", "code": "def getFieldsColumnLengths(self):\n        \"\"\"\n        Gets the maximum length of each column in the field table\n        \"\"\"\n        nameLen = 0\n        descLen = 0\n        for f in self.fields:\n            nameLen = max(nameLen, len(f['title']))\n            descLen = max(descLen, len(f['description']))\n        return (nameLen, descLen)", "code_tokens": "def getFieldsColumnLengths ( self ) : nameLen = 0 descLen = 0 for f in self . fields : nameLen = max ( nameLen , len ( f [ 'title' ] ) ) descLen = max ( descLen , len ( f [ 'description' ] ) ) return ( nameLen , descLen )", "docstring_tokens": "Gets the maximum length of each column in the field table", "label": 1}, {"idx": "cosqa-train-7646", "doc": "how to scale a image in pil python", "code": "def resetScale(self):\n        \"\"\"Resets the scale on this image. Correctly aligns time scale, undoes manual scaling\"\"\"\n        self.img.scale(1./self.imgScale[0], 1./self.imgScale[1])\n        self.imgScale = (1.,1.)", "code_tokens": "def resetScale ( self ) : self . img . scale ( 1. / self . imgScale [ 0 ] , 1. / self . imgScale [ 1 ] ) self . imgScale = ( 1. , 1. )", "docstring_tokens": "Resets the scale on this image . Correctly aligns time scale undoes manual scaling", "label": 1}, {"idx": "cosqa-train-7647", "doc": "python show traceback without exiting", "code": "def format_exc(limit=None):\n    \"\"\"Like print_exc() but return a string. Backport for Python 2.3.\"\"\"\n    try:\n        etype, value, tb = sys.exc_info()\n        return ''.join(traceback.format_exception(etype, value, tb, limit))\n    finally:\n        etype = value = tb = None", "code_tokens": "def format_exc ( limit = None ) : try : etype , value , tb = sys . exc_info ( ) return '' . join ( traceback . format_exception ( etype , value , tb , limit ) ) finally : etype = value = tb = None", "docstring_tokens": "Like print_exc () but return a string . Backport for Python 2 . 3 .", "label": 0}, {"idx": "cosqa-train-7648", "doc": "how to see array size in python", "code": "def bytesize(arr):\n    \"\"\"\n    Returns the memory byte size of a Numpy array as an integer.\n    \"\"\"\n    byte_size = np.prod(arr.shape) * np.dtype(arr.dtype).itemsize\n    return byte_size", "code_tokens": "def bytesize ( arr ) : byte_size = np . prod ( arr . shape ) * np . dtype ( arr . dtype ) . itemsize return byte_size", "docstring_tokens": "Returns the memory byte size of a Numpy array as an integer .", "label": 1}, {"idx": "cosqa-train-7649", "doc": "python shutdown a pool", "code": "def close(self, wait=False):\n        \"\"\"Close session, shutdown pool.\"\"\"\n        self.session.close()\n        self.pool.shutdown(wait=wait)", "code_tokens": "def close ( self , wait = False ) : self . session . close ( ) self . pool . shutdown ( wait = wait )", "docstring_tokens": "Close session shutdown pool .", "label": 1}, {"idx": "cosqa-train-7650", "doc": "how to see matrix in python", "code": "def lengths( self ):\n        \"\"\"\n        The cell lengths.\n\n        Args:\n            None\n\n        Returns:\n            (np.array(a,b,c)): The cell lengths.\n        \"\"\"\n        return( np.array( [ math.sqrt( sum( row**2 ) ) for row in self.matrix ] ) )", "code_tokens": "def lengths ( self ) : return ( np . array ( [ math . sqrt ( sum ( row ** 2 ) ) for row in self . matrix ] ) )", "docstring_tokens": "The cell lengths .", "label": 1}, {"idx": "cosqa-train-7651", "doc": "python sigmoid activation function", "code": "def softplus(attrs, inputs, proto_obj):\n    \"\"\"Applies the sofplus activation function element-wise to the input.\"\"\"\n    new_attrs = translation_utils._add_extra_attributes(attrs, {'act_type' : 'softrelu'})\n    return 'Activation', new_attrs, inputs", "code_tokens": "def softplus ( attrs , inputs , proto_obj ) : new_attrs = translation_utils . _add_extra_attributes ( attrs , { 'act_type' : 'softrelu' } ) return 'Activation' , new_attrs , inputs", "docstring_tokens": "Applies the sofplus activation function element - wise to the input .", "label": 1}, {"idx": "cosqa-train-7652", "doc": "how to select random element from list in fixed sequence in python", "code": "def rand_elem(seq, n=None):\n    \"\"\"returns a random element from seq n times. If n is None, it continues indefinitly\"\"\"\n    return map(random.choice, repeat(seq, n) if n is not None else repeat(seq))", "code_tokens": "def rand_elem ( seq , n = None ) : return map ( random . choice , repeat ( seq , n ) if n is not None else repeat ( seq ) )", "docstring_tokens": "returns a random element from seq n times . If n is None it continues indefinitly", "label": 1}, {"idx": "cosqa-train-7653", "doc": "python similarity between two word seq", "code": "def basic_word_sim(word1, word2):\n    \"\"\"\n    Simple measure of similarity: Number of letters in common / max length\n    \"\"\"\n    return sum([1 for c in word1 if c in word2]) / max(len(word1), len(word2))", "code_tokens": "def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )", "docstring_tokens": "Simple measure of similarity : Number of letters in common / max length", "label": 0}, {"idx": "cosqa-train-7654", "doc": "python size in bytes of arrays", "code": "def array_bytes(array):\n    \"\"\" Estimates the memory of the supplied array in bytes \"\"\"\n    return np.product(array.shape)*np.dtype(array.dtype).itemsize", "code_tokens": "def array_bytes ( array ) : return np . product ( array . shape ) * np . dtype ( array . dtype ) . itemsize", "docstring_tokens": "Estimates the memory of the supplied array in bytes", "label": 0}, {"idx": "cosqa-train-7655", "doc": "how to selecte few elements in list in python by indices", "code": "def filter_list_by_indices(lst, indices):\n    \"\"\"Return a modified list containing only the indices indicated.\n\n    Args:\n        lst: Original list of values\n        indices: List of indices to keep from the original list\n\n    Returns:\n        list: Filtered list of values\n\n    \"\"\"\n    return [x for i, x in enumerate(lst) if i in indices]", "code_tokens": "def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]", "docstring_tokens": "Return a modified list containing only the indices indicated .", "label": 1}, {"idx": "cosqa-train-7656", "doc": "python sklearn imputer 'isnan' not supported for the input types", "code": "def impute_data(self,x):\n        \"\"\"Imputes data set containing Nan values\"\"\"\n        imp = Imputer(missing_values='NaN', strategy='mean', axis=0)\n        return imp.fit_transform(x)", "code_tokens": "def impute_data ( self , x ) : imp = Imputer ( missing_values = 'NaN' , strategy = 'mean' , axis = 0 ) return imp . fit_transform ( x )", "docstring_tokens": "Imputes data set containing Nan values", "label": 0}, {"idx": "cosqa-train-7657", "doc": "how to send ctrl+z to at command python", "code": "def pwm(host, seq, m1, m2, m3, m4):\n    \"\"\"\n    Sends control values directly to the engines, overriding control loops.\n\n    Parameters:\n    seq -- sequence number\n    m1 -- Integer: front left command\n    m2 -- Integer: front right command\n    m3 -- Integer: back right command\n    m4 -- Integer: back left command\n    \"\"\"\n    at(host, 'PWM', seq, [m1, m2, m3, m4])", "code_tokens": "def pwm ( host , seq , m1 , m2 , m3 , m4 ) : at ( host , 'PWM' , seq , [ m1 , m2 , m3 , m4 ] )", "docstring_tokens": "Sends control values directly to the engines overriding control loops .", "label": 1}, {"idx": "cosqa-train-7658", "doc": "python slice list pass by value", "code": "def iget_list_column_slice(list_, start=None, stop=None, stride=None):\n    \"\"\" iterator version of get_list_column \"\"\"\n    if isinstance(start, slice):\n        slice_ = start\n    else:\n        slice_ = slice(start, stop, stride)\n    return (row[slice_] for row in list_)", "code_tokens": "def iget_list_column_slice ( list_ , start = None , stop = None , stride = None ) : if isinstance ( start , slice ) : slice_ = start else : slice_ = slice ( start , stop , stride ) return ( row [ slice_ ] for row in list_ )", "docstring_tokens": "iterator version of get_list_column", "label": 1}, {"idx": "cosqa-train-7659", "doc": "how to seperate list with commas python", "code": "def _return_comma_list(self, l):\n        \"\"\" get a list and return a string with comma separated list values\n        Examples ['to', 'ta'] will return 'to,ta'.\n        \"\"\"\n        if isinstance(l, (text_type, int)):\n            return l\n\n        if not isinstance(l, list):\n            raise TypeError(l, ' should be a list of integers, \\\nnot {0}'.format(type(l)))\n\n        str_ids = ','.join(str(i) for i in l)\n\n        return str_ids", "code_tokens": "def _return_comma_list ( self , l ) : if isinstance ( l , ( text_type , int ) ) : return l if not isinstance ( l , list ) : raise TypeError ( l , ' should be a list of integers, \\\nnot {0}' . format ( type ( l ) ) ) str_ids = ',' . join ( str ( i ) for i in l ) return str_ids", "docstring_tokens": "get a list and return a string with comma separated list values Examples [ to ta ] will return to ta .", "label": 1}, {"idx": "cosqa-train-7660", "doc": "python sort array by new index", "code": "def unsort_vector(data, indices_of_increasing):\n    \"\"\"Upermutate 1-D data that is sorted by indices_of_increasing.\"\"\"\n    return numpy.array([data[indices_of_increasing.index(i)] for i in range(len(data))])", "code_tokens": "def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )", "docstring_tokens": "Upermutate 1 - D data that is sorted by indices_of_increasing .", "label": 1}, {"idx": "cosqa-train-7661", "doc": "how to seperate the matrix to upper triagle python", "code": "def symmetrise(matrix, tri='upper'):\n    \"\"\"\n    Will copy the selected (upper or lower) triangle of a square matrix\n    to the opposite side, so that the matrix is symmetrical.\n    Alters in place.\n    \"\"\"\n    if tri == 'upper':\n        tri_fn = np.triu_indices\n    else:\n        tri_fn = np.tril_indices\n    size = matrix.shape[0]\n    matrix[tri_fn(size)[::-1]] = matrix[tri_fn(size)]\n    return matrix", "code_tokens": "def symmetrise ( matrix , tri = 'upper' ) : if tri == 'upper' : tri_fn = np . triu_indices else : tri_fn = np . tril_indices size = matrix . shape [ 0 ] matrix [ tri_fn ( size ) [ : : - 1 ] ] = matrix [ tri_fn ( size ) ] return matrix", "docstring_tokens": "Will copy the selected ( upper or lower ) triangle of a square matrix to the opposite side so that the matrix is symmetrical . Alters in place .", "label": 1}, {"idx": "cosqa-train-7662", "doc": "python sort by second index in 2d array", "code": "def unsort_vector(data, indices_of_increasing):\n    \"\"\"Upermutate 1-D data that is sorted by indices_of_increasing.\"\"\"\n    return numpy.array([data[indices_of_increasing.index(i)] for i in range(len(data))])", "code_tokens": "def unsort_vector ( data , indices_of_increasing ) : return numpy . array ( [ data [ indices_of_increasing . index ( i ) ] for i in range ( len ( data ) ) ] )", "docstring_tokens": "Upermutate 1 - D data that is sorted by indices_of_increasing .", "label": 0}, {"idx": "cosqa-train-7663", "doc": "how to sequence events in python 3", "code": "def main():\n    \"\"\"Ideally we shouldn't lose the first second of events\"\"\"\n    time.sleep(1)\n    with Input() as input_generator:\n        for e in input_generator:\n            print(repr(e))", "code_tokens": "def main ( ) : time . sleep ( 1 ) with Input ( ) as input_generator : for e in input_generator : print ( repr ( e ) )", "docstring_tokens": "Ideally we shouldn t lose the first second of events", "label": 1}, {"idx": "cosqa-train-7664", "doc": "python sort data by variable", "code": "def sort_data(x, y):\n    \"\"\"Sort the data.\"\"\"\n    xy = sorted(zip(x, y))\n    x, y = zip(*xy)\n    return x, y", "code_tokens": "def sort_data ( x , y ) : xy = sorted ( zip ( x , y ) ) x , y = zip ( * xy ) return x , y", "docstring_tokens": "Sort the data .", "label": 1}, {"idx": "cosqa-train-7665", "doc": "how to set column in data frame using python", "code": "def SetValue(self, row, col, value):\n        \"\"\"\n        Set value in the pandas DataFrame\n        \"\"\"\n        self.dataframe.iloc[row, col] = value", "code_tokens": "def SetValue ( self , row , col , value ) : self . dataframe . iloc [ row , col ] = value", "docstring_tokens": "Set value in the pandas DataFrame", "label": 1}, {"idx": "cosqa-train-7666", "doc": "python sort list by name", "code": "def sort_by_name(self):\n        \"\"\"Sort list elements by name.\"\"\"\n        super(JSSObjectList, self).sort(key=lambda k: k.name)", "code_tokens": "def sort_by_name ( self ) : super ( JSSObjectList , self ) . sort ( key = lambda k : k . name )", "docstring_tokens": "Sort list elements by name .", "label": 0}, {"idx": "cosqa-train-7667", "doc": "how to set date parse in python", "code": "def parse(self, s):\n        \"\"\"\n        Parses a date string formatted like ``YYYY-MM-DD``.\n        \"\"\"\n        return datetime.datetime.strptime(s, self.date_format).date()", "code_tokens": "def parse ( self , s ) : return datetime . datetime . strptime ( s , self . date_format ) . date ( )", "docstring_tokens": "Parses a date string formatted like YYYY - MM - DD .", "label": 0}, {"idx": "cosqa-train-7668", "doc": "python sort two dimensional key", "code": "def sort_key(val):\n    \"\"\"Sort key for sorting keys in grevlex order.\"\"\"\n    return numpy.sum((max(val)+1)**numpy.arange(len(val)-1, -1, -1)*val)", "code_tokens": "def sort_key ( val ) : return numpy . sum ( ( max ( val ) + 1 ) ** numpy . arange ( len ( val ) - 1 , - 1 , - 1 ) * val )", "docstring_tokens": "Sort key for sorting keys in grevlex order .", "label": 0}, {"idx": "cosqa-train-7669", "doc": "how to set default values in dict python", "code": "def setDictDefaults (d, defaults):\n  \"\"\"Sets all defaults for the given dictionary to those contained in a\n  second defaults dictionary.  This convenience method calls:\n\n    d.setdefault(key, value)\n\n  for each key and value in the given defaults dictionary.\n  \"\"\"\n  for key, val in defaults.items():\n    d.setdefault(key, val)\n\n  return d", "code_tokens": "def setDictDefaults ( d , defaults ) : for key , val in defaults . items ( ) : d . setdefault ( key , val ) return d", "docstring_tokens": "Sets all defaults for the given dictionary to those contained in a second defaults dictionary . This convenience method calls :", "label": 1}, {"idx": "cosqa-train-7670", "doc": "python sort x and y", "code": "def sort_data(x, y):\n    \"\"\"Sort the data.\"\"\"\n    xy = sorted(zip(x, y))\n    x, y = zip(*xy)\n    return x, y", "code_tokens": "def sort_data ( x , y ) : xy = sorted ( zip ( x , y ) ) x , y = zip ( * xy ) return x , y", "docstring_tokens": "Sort the data .", "label": 0}, {"idx": "cosqa-train-7671", "doc": "how to set dimensions of python screen", "code": "def display(self):\n        \"\"\" Get screen width and height \"\"\"\n        w, h = self.session.window_size()\n        return Display(w*self.scale, h*self.scale)", "code_tokens": "def display ( self ) : w , h = self . session . window_size ( ) return Display ( w * self . scale , h * self . scale )", "docstring_tokens": "Get screen width and height", "label": 1}, {"idx": "cosqa-train-7672", "doc": "python sounddevice get audio volume", "code": "def calc_volume(self, sample: np.ndarray):\n        \"\"\"Find the RMS of the audio\"\"\"\n        return sqrt(np.mean(np.square(sample)))", "code_tokens": "def calc_volume ( self , sample : np . ndarray ) : return sqrt ( np . mean ( np . square ( sample ) ) )", "docstring_tokens": "Find the RMS of the audio", "label": 1}, {"idx": "cosqa-train-7673", "doc": "how to set python proxy", "code": "def enable_proxy(self, host, port):\n        \"\"\"Enable a default web proxy\"\"\"\n\n        self.proxy = [host, _number(port)]\n        self.proxy_enabled = True", "code_tokens": "def enable_proxy ( self , host , port ) : self . proxy = [ host , _number ( port ) ] self . proxy_enabled = True", "docstring_tokens": "Enable a default web proxy", "label": 1}, {"idx": "cosqa-train-7674", "doc": "python sparse matrix inverter", "code": "def scipy_sparse_to_spmatrix(A):\n    \"\"\"Efficient conversion from scipy sparse matrix to cvxopt sparse matrix\"\"\"\n    coo = A.tocoo()\n    SP = spmatrix(coo.data.tolist(), coo.row.tolist(), coo.col.tolist(), size=A.shape)\n    return SP", "code_tokens": "def scipy_sparse_to_spmatrix ( A ) : coo = A . tocoo ( ) SP = spmatrix ( coo . data . tolist ( ) , coo . row . tolist ( ) , coo . col . tolist ( ) , size = A . shape ) return SP", "docstring_tokens": "Efficient conversion from scipy sparse matrix to cvxopt sparse matrix", "label": 1}, {"idx": "cosqa-train-7675", "doc": "how to set up a python proxy", "code": "def set_proxy(proxy_url, transport_proxy=None):\n    \"\"\"Create the proxy to PyPI XML-RPC Server\"\"\"\n    global proxy, PYPI_URL\n    PYPI_URL = proxy_url\n    proxy = xmlrpc.ServerProxy(\n        proxy_url,\n        transport=RequestsTransport(proxy_url.startswith('https://')),\n        allow_none=True)", "code_tokens": "def set_proxy ( proxy_url , transport_proxy = None ) : global proxy , PYPI_URL PYPI_URL = proxy_url proxy = xmlrpc . ServerProxy ( proxy_url , transport = RequestsTransport ( proxy_url . startswith ( 'https://' ) ) , allow_none = True )", "docstring_tokens": "Create the proxy to PyPI XML - RPC Server", "label": 0}, {"idx": "cosqa-train-7676", "doc": "python sparse matrix nonzero number", "code": "def is_sparse_vector(x):\n    \"\"\" x is a 2D sparse matrix with it's first shape equal to 1.\n    \"\"\"\n    return sp.issparse(x) and len(x.shape) == 2 and x.shape[0] == 1", "code_tokens": "def is_sparse_vector ( x ) : return sp . issparse ( x ) and len ( x . shape ) == 2 and x . shape [ 0 ] == 1", "docstring_tokens": "x is a 2D sparse matrix with it s first shape equal to 1 .", "label": 1}, {"idx": "cosqa-train-7677", "doc": "how to set width of bar in horizontal bar chart python", "code": "def _change_height(self, ax, new_value):\n        \"\"\"Make bars in horizontal bar chart thinner\"\"\"\n        for patch in ax.patches:\n            current_height = patch.get_height()\n            diff = current_height - new_value\n\n            # we change the bar height\n            patch.set_height(new_value)\n\n            # we recenter the bar\n            patch.set_y(patch.get_y() + diff * .5)", "code_tokens": "def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )", "docstring_tokens": "Make bars in horizontal bar chart thinner", "label": 1}, {"idx": "cosqa-train-7678", "doc": "python specific type for data field", "code": "def value_to_python(self, value):\n        \"\"\"\n        Converts the input single value into the expected Python data type,\n        raising django.core.exceptions.ValidationError if the data can't be\n        converted.  Returns the converted value. Subclasses should override\n        this.\n        \"\"\"\n        if not isinstance(value, bytes):\n            raise tldap.exceptions.ValidationError(\"should be a bytes\")\n        value = value.decode(\"utf_8\")\n        return value", "code_tokens": "def value_to_python ( self , value ) : if not isinstance ( value , bytes ) : raise tldap . exceptions . ValidationError ( \"should be a bytes\" ) value = value . decode ( \"utf_8\" ) return value", "docstring_tokens": "Converts the input single value into the expected Python data type raising django . core . exceptions . ValidationError if the data can t be converted . Returns the converted value . Subclasses should override this .", "label": 1}, {"idx": "cosqa-train-7679", "doc": "how to set xlim in plot python", "code": "def set_xlimits_widgets(self, set_min=True, set_max=True):\n        \"\"\"Populate axis limits GUI with current plot values.\"\"\"\n        xmin, xmax = self.tab_plot.ax.get_xlim()\n        if set_min:\n            self.w.x_lo.set_text('{0}'.format(xmin))\n        if set_max:\n            self.w.x_hi.set_text('{0}'.format(xmax))", "code_tokens": "def set_xlimits_widgets ( self , set_min = True , set_max = True ) : xmin , xmax = self . tab_plot . ax . get_xlim ( ) if set_min : self . w . x_lo . set_text ( '{0}' . format ( xmin ) ) if set_max : self . w . x_hi . set_text ( '{0}' . format ( xmax ) )", "docstring_tokens": "Populate axis limits GUI with current plot values .", "label": 1}, {"idx": "cosqa-train-7680", "doc": "python spherical bessel function", "code": "def sbessely(x, N):\n    \"\"\"Returns a vector of spherical bessel functions yn:\n\n        x:   The argument.\n        N:   values of n will run from 0 to N-1.\n\n    \"\"\"\n\n    out = np.zeros(N, dtype=np.float64)\n\n    out[0] = -np.cos(x) / x\n    out[1] = -np.cos(x) / (x ** 2) - np.sin(x) / x\n\n    for n in xrange(2, N):\n        out[n] = ((2.0 * n - 1.0) / x) * out[n - 1] - out[n - 2]\n\n    return out", "code_tokens": "def sbessely ( x , N ) : out = np . zeros ( N , dtype = np . float64 ) out [ 0 ] = - np . cos ( x ) / x out [ 1 ] = - np . cos ( x ) / ( x ** 2 ) - np . sin ( x ) / x for n in xrange ( 2 , N ) : out [ n ] = ( ( 2.0 * n - 1.0 ) / x ) * out [ n - 1 ] - out [ n - 2 ] return out", "docstring_tokens": "Returns a vector of spherical bessel functions yn : x : The argument . N : values of n will run from 0 to N - 1 .", "label": 1}, {"idx": "cosqa-train-7681", "doc": "how to set y axis as log in python", "code": "def log_y_cb(self, w, val):\n        \"\"\"Toggle linear/log scale for Y-axis.\"\"\"\n        self.tab_plot.logy = val\n        self.plot_two_columns()", "code_tokens": "def log_y_cb ( self , w , val ) : self . tab_plot . logy = val self . plot_two_columns ( )", "docstring_tokens": "Toggle linear / log scale for Y - axis .", "label": 1}, {"idx": "cosqa-train-7682", "doc": "python split array into equal chunks", "code": "def partition(a, sz): \n    \"\"\"splits iterables a in equal parts of size sz\"\"\"\n    return [a[i:i+sz] for i in range(0, len(a), sz)]", "code_tokens": "def partition ( a , sz ) : return [ a [ i : i + sz ] for i in range ( 0 , len ( a ) , sz ) ]", "docstring_tokens": "splits iterables a in equal parts of size sz", "label": 1}, {"idx": "cosqa-train-7683", "doc": "how to show legend in python graphing", "code": "def finish_plot():\n    \"\"\"Helper for plotting.\"\"\"\n    plt.legend()\n    plt.grid(color='0.7')\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.show()", "code_tokens": "def finish_plot ( ) : plt . legend ( ) plt . grid ( color = '0.7' ) plt . xlabel ( 'x' ) plt . ylabel ( 'y' ) plt . show ( )", "docstring_tokens": "Helper for plotting .", "label": 1}, {"idx": "cosqa-train-7684", "doc": "python split brackets from word on", "code": "def split_on(s, sep=\" \"):\n    \"\"\"Split s by sep, unless it's inside a quote.\"\"\"\n    pattern = '''((?:[^%s\"']|\"[^\"]*\"|'[^']*')+)''' % sep\n\n    return [_strip_speechmarks(t) for t in re.split(pattern, s)[1::2]]", "code_tokens": "def split_on ( s , sep = \" \" ) : pattern = '''((?:[^%s\"']|\"[^\"]*\"|'[^']*')+)''' % sep return [ _strip_speechmarks ( t ) for t in re . split ( pattern , s ) [ 1 : : 2 ] ]", "docstring_tokens": "Split s by sep unless it s inside a quote .", "label": 1}, {"idx": "cosqa-train-7685", "doc": "how to show python error messges in tkinter", "code": "def error(*args):\n    \"\"\"Display error message via stderr or GUI.\"\"\"\n    if sys.stdin.isatty():\n        print('ERROR:', *args, file=sys.stderr)\n    else:\n        notify_error(*args)", "code_tokens": "def error ( * args ) : if sys . stdin . isatty ( ) : print ( 'ERROR:' , * args , file = sys . stderr ) else : notify_error ( * args )", "docstring_tokens": "Display error message via stderr or GUI .", "label": 0}, {"idx": "cosqa-train-7686", "doc": "python split iterable into batches", "code": "def ibatch(iterable, size):\n    \"\"\"Yield a series of batches from iterable, each size elements long.\"\"\"\n    source = iter(iterable)\n    while True:\n        batch = itertools.islice(source, size)\n        yield itertools.chain([next(batch)], batch)", "code_tokens": "def ibatch ( iterable , size ) : source = iter ( iterable ) while True : batch = itertools . islice ( source , size ) yield itertools . chain ( [ next ( batch ) ] , batch )", "docstring_tokens": "Yield a series of batches from iterable each size elements long .", "label": 1}, {"idx": "cosqa-train-7687", "doc": "how to show the plot python plt", "code": "def show(self, title=''):\n        \"\"\"\n        Display Bloch sphere and corresponding data sets.\n        \"\"\"\n        self.render(title=title)\n        if self.fig:\n            plt.show(self.fig)", "code_tokens": "def show ( self , title = '' ) : self . render ( title = title ) if self . fig : plt . show ( self . fig )", "docstring_tokens": "Display Bloch sphere and corresponding data sets .", "label": 0}, {"idx": "cosqa-train-7688", "doc": "python split not enough values to unpack (expected 2, got 1)", "code": "def _split(value):\n    \"\"\"Split input/output value into two values.\"\"\"\n    if isinstance(value, str):\n        # iterable, but not meant for splitting\n        return value, value\n    try:\n        invalue, outvalue = value\n    except TypeError:\n        invalue = outvalue = value\n    except ValueError:\n        raise ValueError(\"Only single values and pairs are allowed\")\n    return invalue, outvalue", "code_tokens": "def _split ( value ) : if isinstance ( value , str ) : # iterable, but not meant for splitting return value , value try : invalue , outvalue = value except TypeError : invalue = outvalue = value except ValueError : raise ValueError ( \"Only single values and pairs are allowed\" ) return invalue , outvalue", "docstring_tokens": "Split input / output value into two values .", "label": 0}, {"idx": "cosqa-train-7689", "doc": "how to slice iteratively in python", "code": "def partition(a, sz): \n    \"\"\"splits iterables a in equal parts of size sz\"\"\"\n    return [a[i:i+sz] for i in range(0, len(a), sz)]", "code_tokens": "def partition ( a , sz ) : return [ a [ i : i + sz ] for i in range ( 0 , len ( a ) , sz ) ]", "docstring_tokens": "splits iterables a in equal parts of size sz", "label": 1}, {"idx": "cosqa-train-7690", "doc": "python splitting a list into batches", "code": "def _split_batches(self, data, batch_size):\n        \"\"\"Yield successive n-sized chunks from l.\"\"\"\n        for i in range(0, len(data), batch_size):\n            yield data[i : i + batch_size]", "code_tokens": "def _split_batches ( self , data , batch_size ) : for i in range ( 0 , len ( data ) , batch_size ) : yield data [ i : i + batch_size ]", "docstring_tokens": "Yield successive n - sized chunks from l .", "label": 0}, {"idx": "cosqa-train-7691", "doc": "how to slice row and column specifically python", "code": "def getcolslice(self, blc, trc, inc=[], startrow=0, nrow=-1, rowincr=1):\n        \"\"\"Get a slice from a table column holding arrays.\n        (see :func:`table.getcolslice`)\"\"\"\n        return self._table.getcolslice(self._column, blc, trc, inc, startrow, nrow, rowincr)", "code_tokens": "def getcolslice ( self , blc , trc , inc = [ ] , startrow = 0 , nrow = - 1 , rowincr = 1 ) : return self . _table . getcolslice ( self . _column , blc , trc , inc , startrow , nrow , rowincr )", "docstring_tokens": "Get a slice from a table column holding arrays . ( see : func : table . getcolslice )", "label": 1}, {"idx": "cosqa-train-7692", "doc": "python spyder reset command in script", "code": "def restart(self, reset=False):\n        \"\"\"\n        Quit and Restart Spyder application.\n\n        If reset True it allows to reset spyder on restart.\n        \"\"\"\n        # Get start path to use in restart script\n        spyder_start_directory = get_module_path('spyder')\n        restart_script = osp.join(spyder_start_directory, 'app', 'restart.py')\n\n        # Get any initial argument passed when spyder was started\n        # Note: Variables defined in bootstrap.py and spyder/app/start.py\n        env = os.environ.copy()\n        bootstrap_args = env.pop('SPYDER_BOOTSTRAP_ARGS', None)\n        spyder_args = env.pop('SPYDER_ARGS')\n\n        # Get current process and python running spyder\n        pid = os.getpid()\n        python = sys.executable\n\n        # Check if started with bootstrap.py\n        if bootstrap_args is not None:\n            spyder_args = bootstrap_args\n            is_bootstrap = True\n        else:\n            is_bootstrap = False\n\n        # Pass variables as environment variables (str) to restarter subprocess\n        env['SPYDER_ARGS'] = spyder_args\n        env['SPYDER_PID'] = str(pid)\n        env['SPYDER_IS_BOOTSTRAP'] = str(is_bootstrap)\n        env['SPYDER_RESET'] = str(reset)\n\n        if DEV:\n            if os.name == 'nt':\n                env['PYTHONPATH'] = ';'.join(sys.path)\n            else:\n                env['PYTHONPATH'] = ':'.join(sys.path)\n\n        # Build the command and popen arguments depending on the OS\n        if os.name == 'nt':\n            # Hide flashing command prompt\n            startupinfo = subprocess.STARTUPINFO()\n            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n            shell = False\n        else:\n            startupinfo = None\n            shell = True\n\n        command = '\"{0}\" \"{1}\"'\n        command = command.format(python, restart_script)\n\n        try:\n            if self.closing(True):\n                subprocess.Popen(command, shell=shell, env=env,\n                                 startupinfo=startupinfo)\n                self.console.quit()\n        except Exception as error:\n            # If there is an error with subprocess, Spyder should not quit and\n            # the error can be inspected in the internal console\n            print(error)  # spyder: test-skip\n            print(command)", "code_tokens": "def restart ( self , reset = False ) : # Get start path to use in restart script\n spyder_start_directory = get_module_path ( 'spyder' ) restart_script = osp . join ( spyder_start_directory , 'app' , 'restart.py' ) # Get any initial argument passed when spyder was started\n # Note: Variables defined in bootstrap.py and spyder/app/start.py\n env = os . environ . copy ( ) bootstrap_args = env . pop ( 'SPYDER_BOOTSTRAP_ARGS' , None ) spyder_args = env . pop ( 'SPYDER_ARGS' ) # Get current process and python running spyder\n pid = os . getpid ( ) python = sys . executable # Check if started with bootstrap.py\n if bootstrap_args is not None : spyder_args = bootstrap_args is_bootstrap = True else : is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess\n env [ 'SPYDER_ARGS' ] = spyder_args env [ 'SPYDER_PID' ] = str ( pid ) env [ 'SPYDER_IS_BOOTSTRAP' ] = str ( is_bootstrap ) env [ 'SPYDER_RESET' ] = str ( reset ) if DEV : if os . name == 'nt' : env [ 'PYTHONPATH' ] = ';' . join ( sys . path ) else : env [ 'PYTHONPATH' ] = ':' . join ( sys . path ) # Build the command and popen arguments depending on the OS\n if os . name == 'nt' : # Hide flashing command prompt\n startupinfo = subprocess . STARTUPINFO ( ) startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW shell = False else : startupinfo = None shell = True command = '\"{0}\" \"{1}\"' command = command . format ( python , restart_script ) try : if self . closing ( True ) : subprocess . Popen ( command , shell = shell , env = env , startupinfo = startupinfo ) self . console . quit ( ) except Exception as error : # If there is an error with subprocess, Spyder should not quit and\n # the error can be inspected in the internal console\n print ( error ) # spyder: test-skip\n print ( command )", "docstring_tokens": "Quit and Restart Spyder application . If reset True it allows to reset spyder on restart .", "label": 0}, {"idx": "cosqa-train-7693", "doc": "how to smooth data in python", "code": "def smooth_array(array, amount=1):\n    \"\"\"\n\n    Returns the nearest-neighbor (+/- amount) smoothed array.\n    This does not modify the array or slice off the funny end points.\n\n    \"\"\"\n    if amount==0: return array\n\n    # we have to store the old values in a temp array to keep the\n    # smoothing from affecting the smoothing\n    new_array = _n.array(array)\n\n    for n in range(len(array)):\n        new_array[n] = smooth(array, n, amount)\n\n    return new_array", "code_tokens": "def smooth_array ( array , amount = 1 ) : if amount == 0 : return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n . array ( array ) for n in range ( len ( array ) ) : new_array [ n ] = smooth ( array , n , amount ) return new_array", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-7694", "doc": "python spyder reset not working", "code": "def restart(self, reset=False):\n        \"\"\"\n        Quit and Restart Spyder application.\n\n        If reset True it allows to reset spyder on restart.\n        \"\"\"\n        # Get start path to use in restart script\n        spyder_start_directory = get_module_path('spyder')\n        restart_script = osp.join(spyder_start_directory, 'app', 'restart.py')\n\n        # Get any initial argument passed when spyder was started\n        # Note: Variables defined in bootstrap.py and spyder/app/start.py\n        env = os.environ.copy()\n        bootstrap_args = env.pop('SPYDER_BOOTSTRAP_ARGS', None)\n        spyder_args = env.pop('SPYDER_ARGS')\n\n        # Get current process and python running spyder\n        pid = os.getpid()\n        python = sys.executable\n\n        # Check if started with bootstrap.py\n        if bootstrap_args is not None:\n            spyder_args = bootstrap_args\n            is_bootstrap = True\n        else:\n            is_bootstrap = False\n\n        # Pass variables as environment variables (str) to restarter subprocess\n        env['SPYDER_ARGS'] = spyder_args\n        env['SPYDER_PID'] = str(pid)\n        env['SPYDER_IS_BOOTSTRAP'] = str(is_bootstrap)\n        env['SPYDER_RESET'] = str(reset)\n\n        if DEV:\n            if os.name == 'nt':\n                env['PYTHONPATH'] = ';'.join(sys.path)\n            else:\n                env['PYTHONPATH'] = ':'.join(sys.path)\n\n        # Build the command and popen arguments depending on the OS\n        if os.name == 'nt':\n            # Hide flashing command prompt\n            startupinfo = subprocess.STARTUPINFO()\n            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n            shell = False\n        else:\n            startupinfo = None\n            shell = True\n\n        command = '\"{0}\" \"{1}\"'\n        command = command.format(python, restart_script)\n\n        try:\n            if self.closing(True):\n                subprocess.Popen(command, shell=shell, env=env,\n                                 startupinfo=startupinfo)\n                self.console.quit()\n        except Exception as error:\n            # If there is an error with subprocess, Spyder should not quit and\n            # the error can be inspected in the internal console\n            print(error)  # spyder: test-skip\n            print(command)", "code_tokens": "def restart ( self , reset = False ) : # Get start path to use in restart script\n spyder_start_directory = get_module_path ( 'spyder' ) restart_script = osp . join ( spyder_start_directory , 'app' , 'restart.py' ) # Get any initial argument passed when spyder was started\n # Note: Variables defined in bootstrap.py and spyder/app/start.py\n env = os . environ . copy ( ) bootstrap_args = env . pop ( 'SPYDER_BOOTSTRAP_ARGS' , None ) spyder_args = env . pop ( 'SPYDER_ARGS' ) # Get current process and python running spyder\n pid = os . getpid ( ) python = sys . executable # Check if started with bootstrap.py\n if bootstrap_args is not None : spyder_args = bootstrap_args is_bootstrap = True else : is_bootstrap = False # Pass variables as environment variables (str) to restarter subprocess\n env [ 'SPYDER_ARGS' ] = spyder_args env [ 'SPYDER_PID' ] = str ( pid ) env [ 'SPYDER_IS_BOOTSTRAP' ] = str ( is_bootstrap ) env [ 'SPYDER_RESET' ] = str ( reset ) if DEV : if os . name == 'nt' : env [ 'PYTHONPATH' ] = ';' . join ( sys . path ) else : env [ 'PYTHONPATH' ] = ':' . join ( sys . path ) # Build the command and popen arguments depending on the OS\n if os . name == 'nt' : # Hide flashing command prompt\n startupinfo = subprocess . STARTUPINFO ( ) startupinfo . dwFlags |= subprocess . STARTF_USESHOWWINDOW shell = False else : startupinfo = None shell = True command = '\"{0}\" \"{1}\"' command = command . format ( python , restart_script ) try : if self . closing ( True ) : subprocess . Popen ( command , shell = shell , env = env , startupinfo = startupinfo ) self . console . quit ( ) except Exception as error : # If there is an error with subprocess, Spyder should not quit and\n # the error can be inspected in the internal console\n print ( error ) # spyder: test-skip\n print ( command )", "docstring_tokens": "Quit and Restart Spyder application . If reset True it allows to reset spyder on restart .", "label": 0}, {"idx": "cosqa-train-7695", "doc": "how to smooth in python", "code": "def smooth_array(array, amount=1):\n    \"\"\"\n\n    Returns the nearest-neighbor (+/- amount) smoothed array.\n    This does not modify the array or slice off the funny end points.\n\n    \"\"\"\n    if amount==0: return array\n\n    # we have to store the old values in a temp array to keep the\n    # smoothing from affecting the smoothing\n    new_array = _n.array(array)\n\n    for n in range(len(array)):\n        new_array[n] = smooth(array, n, amount)\n\n    return new_array", "code_tokens": "def smooth_array ( array , amount = 1 ) : if amount == 0 : return array # we have to store the old values in a temp array to keep the # smoothing from affecting the smoothing new_array = _n . array ( array ) for n in range ( len ( array ) ) : new_array [ n ] = smooth ( array , n , amount ) return new_array", "docstring_tokens": "", "label": 1}, {"idx": "cosqa-train-7696", "doc": "python sql concat columns", "code": "def join_cols(cols):\n    \"\"\"Join list of columns into a string for a SQL query\"\"\"\n    return \", \".join([i for i in cols]) if isinstance(cols, (list, tuple, set)) else cols", "code_tokens": "def join_cols ( cols ) : return \", \" . join ( [ i for i in cols ] ) if isinstance ( cols , ( list , tuple , set ) ) else cols", "docstring_tokens": "Join list of columns into a string for a SQL query", "label": 1}, {"idx": "cosqa-train-7697", "doc": "how to solve a m x n matrix in python", "code": "def solve(A, x):\n    \"\"\"Solves a linear equation system with a matrix of shape (n, n) and an\n    array of shape (n, ...). The output has the same shape as the second\n    argument.\n    \"\"\"\n    # https://stackoverflow.com/a/48387507/353337\n    x = numpy.asarray(x)\n    return numpy.linalg.solve(A, x.reshape(x.shape[0], -1)).reshape(x.shape)", "code_tokens": "def solve ( A , x ) : # https://stackoverflow.com/a/48387507/353337 x = numpy . asarray ( x ) return numpy . linalg . solve ( A , x . reshape ( x . shape [ 0 ] , - 1 ) ) . reshape ( x . shape )", "docstring_tokens": "Solves a linear equation system with a matrix of shape ( n n ) and an array of shape ( n ... ) . The output has the same shape as the second argument .", "label": 0}, {"idx": "cosqa-train-7698", "doc": "python sql form in join from list", "code": "def join_cols(cols):\n    \"\"\"Join list of columns into a string for a SQL query\"\"\"\n    return \", \".join([i for i in cols]) if isinstance(cols, (list, tuple, set)) else cols", "code_tokens": "def join_cols ( cols ) : return \", \" . join ( [ i for i in cols ] ) if isinstance ( cols , ( list , tuple , set ) ) else cols", "docstring_tokens": "Join list of columns into a string for a SQL query", "label": 0}, {"idx": "cosqa-train-7699", "doc": "how to solve a matrix by python", "code": "def MatrixSolve(a, rhs, adj):\n    \"\"\"\n    Matrix solve op.\n    \"\"\"\n    return np.linalg.solve(a if not adj else _adjoint(a), rhs),", "code_tokens": "def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,", "docstring_tokens": "Matrix solve op .", "label": 1}, {"idx": "cosqa-train-7700", "doc": "python sql server stored proc with params example", "code": "def callproc(self, name, params, param_types=None):\n    \"\"\"Calls a procedure.\n\n    :param name: the name of the procedure\n    :param params: a list or tuple of parameters to pass to the procedure.\n    :param param_types: a list or tuple of type names. If given, each param will be cast via\n                        sql_writers typecast method. This is useful to disambiguate procedure calls\n                        when several parameters are null and therefore cause overload resoluation\n                        issues.\n    :return: a 2-tuple of (cursor, params)\n    \"\"\"\n\n    if param_types:\n      placeholders = [self.sql_writer.typecast(self.sql_writer.to_placeholder(), t)\n                      for t in param_types]\n    else:\n      placeholders = [self.sql_writer.to_placeholder() for p in params]\n\n    # TODO: This may be Postgres specific...\n    qs = \"select * from {0}({1});\".format(name, \", \".join(placeholders))\n    return self.execute(qs, params), params", "code_tokens": "def callproc ( self , name , params , param_types = None ) : if param_types : placeholders = [ self . sql_writer . typecast ( self . sql_writer . to_placeholder ( ) , t ) for t in param_types ] else : placeholders = [ self . sql_writer . to_placeholder ( ) for p in params ] # TODO: This may be Postgres specific... qs = \"select * from {0}({1});\" . format ( name , \", \" . join ( placeholders ) ) return self . execute ( qs , params ) , params", "docstring_tokens": "Calls a procedure .", "label": 1}, {"idx": "cosqa-train-7701", "doc": "how to solve matrix on python", "code": "def MatrixSolve(a, rhs, adj):\n    \"\"\"\n    Matrix solve op.\n    \"\"\"\n    return np.linalg.solve(a if not adj else _adjoint(a), rhs),", "code_tokens": "def MatrixSolve ( a , rhs , adj ) : return np . linalg . solve ( a if not adj else _adjoint ( a ) , rhs ) ,", "docstring_tokens": "Matrix solve op .", "label": 1}, {"idx": "cosqa-train-7702", "doc": "python sqlalchemy delete all rows", "code": "def clear_all(self):\n        \"\"\"Delete all Labels.\"\"\"\n        logger.info(\"Clearing ALL Labels and LabelKeys.\")\n        self.session.query(Label).delete(synchronize_session=\"fetch\")\n        self.session.query(LabelKey).delete(synchronize_session=\"fetch\")", "code_tokens": "def clear_all ( self ) : logger . info ( \"Clearing ALL Labels and LabelKeys.\" ) self . session . query ( Label ) . delete ( synchronize_session = \"fetch\" ) self . session . query ( LabelKey ) . delete ( synchronize_session = \"fetch\" )", "docstring_tokens": "Delete all Labels .", "label": 1}, {"idx": "cosqa-train-7703", "doc": "how to sort files by filename python", "code": "def sort_filenames(filenames):\n    \"\"\"\n    sort a list of files by filename only, ignoring the directory names\n    \"\"\"\n    basenames = [os.path.basename(x) for x in filenames]\n    indexes = [i[0] for i in sorted(enumerate(basenames), key=lambda x:x[1])]\n    return [filenames[x] for x in indexes]", "code_tokens": "def sort_filenames ( filenames ) : basenames = [ os . path . basename ( x ) for x in filenames ] indexes = [ i [ 0 ] for i in sorted ( enumerate ( basenames ) , key = lambda x : x [ 1 ] ) ] return [ filenames [ x ] for x in indexes ]", "docstring_tokens": "sort a list of files by filename only ignoring the directory names", "label": 1}, {"idx": "cosqa-train-7704", "doc": "python sqlalchemy get table primary keys", "code": "def primary_keys_full(cls):\n        \"\"\"Get primary key properties for a SQLAlchemy cls.\n        Taken from marshmallow_sqlalchemy\n        \"\"\"\n        mapper = cls.__mapper__\n        return [\n            mapper.get_property_by_column(column)\n            for column in mapper.primary_key\n        ]", "code_tokens": "def primary_keys_full ( cls ) : mapper = cls . __mapper__ return [ mapper . get_property_by_column ( column ) for column in mapper . primary_key ]", "docstring_tokens": "Get primary key properties for a SQLAlchemy cls . Taken from marshmallow_sqlalchemy", "label": 1}, {"idx": "cosqa-train-7705", "doc": "how to specfy time zone for python datetime", "code": "def datetime_from_timestamp(timestamp, content):\n    \"\"\"\n    Helper function to add timezone information to datetime,\n    so that datetime is comparable to other datetime objects in recent versions\n    that now also have timezone information.\n    \"\"\"\n    return set_date_tzinfo(\n        datetime.fromtimestamp(timestamp),\n        tz_name=content.settings.get('TIMEZONE', None))", "code_tokens": "def datetime_from_timestamp ( timestamp , content ) : return set_date_tzinfo ( datetime . fromtimestamp ( timestamp ) , tz_name = content . settings . get ( 'TIMEZONE' , None ) )", "docstring_tokens": "Helper function to add timezone information to datetime so that datetime is comparable to other datetime objects in recent versions that now also have timezone information .", "label": 0}, {"idx": "cosqa-train-7706", "doc": "python sqlalchemy out of sync with model", "code": "def createdb():\n    \"\"\"Create database tables from sqlalchemy models\"\"\"\n    manager.db.engine.echo = True\n    manager.db.create_all()\n    set_alembic_revision()", "code_tokens": "def createdb ( ) : manager . db . engine . echo = True manager . db . create_all ( ) set_alembic_revision ( )", "docstring_tokens": "Create database tables from sqlalchemy models", "label": 0}, {"idx": "cosqa-train-7707", "doc": "how to specify something that only a certain user can do in python", "code": "def has_permission(user, permission_name):\n    \"\"\"Check if a user has a given permission.\"\"\"\n    if user and user.is_superuser:\n        return True\n\n    return permission_name in available_perm_names(user)", "code_tokens": "def has_permission ( user , permission_name ) : if user and user . is_superuser : return True return permission_name in available_perm_names ( user )", "docstring_tokens": "Check if a user has a given permission .", "label": 0}, {"idx": "cosqa-train-7708", "doc": "python sqlite query to datetime", "code": "def from_pydatetime(cls, pydatetime):\n        \"\"\"\n        Creates sql datetime2 object from Python datetime object\n        ignoring timezone\n        @param pydatetime: Python datetime object\n        @return: sql datetime2 object\n        \"\"\"\n        return cls(date=Date.from_pydate(pydatetime.date),\n                   time=Time.from_pytime(pydatetime.time))", "code_tokens": "def from_pydatetime ( cls , pydatetime ) : return cls ( date = Date . from_pydate ( pydatetime . date ) , time = Time . from_pytime ( pydatetime . time ) )", "docstring_tokens": "Creates sql datetime2 object from Python datetime object ignoring timezone", "label": 1}, {"idx": "cosqa-train-7709", "doc": "how to specify the file encoding in python", "code": "def open_with_encoding(filename, encoding, mode='r'):\n    \"\"\"Return opened file with a specific encoding.\"\"\"\n    return io.open(filename, mode=mode, encoding=encoding,\n                   newline='')", "code_tokens": "def open_with_encoding ( filename , encoding , mode = 'r' ) : return io . open ( filename , mode = mode , encoding = encoding , newline = '' )", "docstring_tokens": "Return opened file with a specific encoding .", "label": 0}, {"idx": "cosqa-train-7710", "doc": "python sqlite3 fetchall dictionary", "code": "def sqliteRowsToDicts(sqliteRows):\n    \"\"\"\n    Unpacks sqlite rows as returned by fetchall\n    into an array of simple dicts.\n\n    :param sqliteRows: array of rows returned from fetchall DB call\n    :return:  array of dicts, keyed by the column names.\n    \"\"\"\n    return map(lambda r: dict(zip(r.keys(), r)), sqliteRows)", "code_tokens": "def sqliteRowsToDicts ( sqliteRows ) : return map ( lambda r : dict ( zip ( r . keys ( ) , r ) ) , sqliteRows )", "docstring_tokens": "Unpacks sqlite rows as returned by fetchall into an array of simple dicts .", "label": 1}, {"idx": "cosqa-train-7711", "doc": "how to split a string of words into a list with each word being a char python", "code": "def split_into_words(s):\n  \"\"\"Split a sentence into list of words.\"\"\"\n  s = re.sub(r\"\\W+\", \" \", s)\n  s = re.sub(r\"[_0-9]+\", \" \", s)\n  return s.split()", "code_tokens": "def split_into_words ( s ) : s = re . sub ( r\"\\W+\" , \" \" , s ) s = re . sub ( r\"[_0-9]+\" , \" \" , s ) return s . split ( )", "docstring_tokens": "Split a sentence into list of words .", "label": 1}, {"idx": "cosqa-train-7712", "doc": "python standards function names", "code": "def export(defn):\n    \"\"\"Decorator to explicitly mark functions that are exposed in a lib.\"\"\"\n    globals()[defn.__name__] = defn\n    __all__.append(defn.__name__)\n    return defn", "code_tokens": "def export ( defn ) : globals ( ) [ defn . __name__ ] = defn __all__ . append ( defn . __name__ ) return defn", "docstring_tokens": "Decorator to explicitly mark functions that are exposed in a lib .", "label": 0}, {"idx": "cosqa-train-7713", "doc": "how to split space seperated text in python", "code": "def split_into_sentences(s):\n  \"\"\"Split text into list of sentences.\"\"\"\n  s = re.sub(r\"\\s+\", \" \", s)\n  s = re.sub(r\"[\\\\.\\\\?\\\\!]\", \"\\n\", s)\n  return s.split(\"\\n\")", "code_tokens": "def split_into_sentences ( s ) : s = re . sub ( r\"\\s+\" , \" \" , s ) s = re . sub ( r\"[\\\\.\\\\?\\\\!]\" , \"\\n\" , s ) return s . split ( \"\\n\" )", "docstring_tokens": "Split text into list of sentences .", "label": 0}, {"idx": "cosqa-train-7714", "doc": "python start django service", "code": "def server(port):\n    \"\"\"Start the Django dev server.\"\"\"\n    args = ['python', 'manage.py', 'runserver']\n    if port:\n        args.append(port)\n    run.main(args)", "code_tokens": "def server ( port ) : args = [ 'python' , 'manage.py' , 'runserver' ] if port : args . append ( port ) run . main ( args )", "docstring_tokens": "Start the Django dev server .", "label": 1}, {"idx": "cosqa-train-7715", "doc": "how to split words into list without spaces and punctuation in python", "code": "def split_into_words(s):\n  \"\"\"Split a sentence into list of words.\"\"\"\n  s = re.sub(r\"\\W+\", \" \", s)\n  s = re.sub(r\"[_0-9]+\", \" \", s)\n  return s.split()", "code_tokens": "def split_into_words ( s ) : s = re . sub ( r\"\\W+\" , \" \" , s ) s = re . sub ( r\"[_0-9]+\" , \" \" , s ) return s . split ( )", "docstring_tokens": "Split a sentence into list of words .", "label": 1}, {"idx": "cosqa-train-7716", "doc": "python static method constant", "code": "def static_method(cls, f):\n        \"\"\"Decorator which dynamically binds static methods to the model for later use.\"\"\"\n        setattr(cls, f.__name__, staticmethod(f))\n        return f", "code_tokens": "def static_method ( cls , f ) : setattr ( cls , f . __name__ , staticmethod ( f ) ) return f", "docstring_tokens": "Decorator which dynamically binds static methods to the model for later use .", "label": 0}, {"idx": "cosqa-train-7717", "doc": "how to stack 2d arrays in python", "code": "def column_stack_2d(data):\n    \"\"\"Perform column-stacking on a list of 2d data blocks.\"\"\"\n    return list(list(itt.chain.from_iterable(_)) for _ in zip(*data))", "code_tokens": "def column_stack_2d ( data ) : return list ( list ( itt . chain . from_iterable ( _ ) ) for _ in zip ( * data ) )", "docstring_tokens": "Perform column - stacking on a list of 2d data blocks .", "label": 1}, {"idx": "cosqa-train-7718", "doc": "python static type return of functyion", "code": "def is_static(*p):\n    \"\"\" A static value (does not change at runtime)\n    which is known at compile time\n    \"\"\"\n    return all(is_CONST(x) or\n               is_number(x) or\n               is_const(x)\n               for x in p)", "code_tokens": "def is_static ( * p ) : return all ( is_CONST ( x ) or is_number ( x ) or is_const ( x ) for x in p )", "docstring_tokens": "A static value ( does not change at runtime ) which is known at compile time", "label": 0}, {"idx": "cosqa-train-7719", "doc": "how to stop a python window from closing on startup", "code": "def quit(self):\n        \"\"\" Quits the application (called when the last window is closed)\n        \"\"\"\n        logger.debug(\"ArgosApplication.quit called\")\n        assert len(self.mainWindows) == 0, \\\n            \"Bug: still {} windows present at application quit!\".format(len(self.mainWindows))\n        self.qApplication.quit()", "code_tokens": "def quit ( self ) : logger . debug ( \"ArgosApplication.quit called\" ) assert len ( self . mainWindows ) == 0 , \"Bug: still {} windows present at application quit!\" . format ( len ( self . mainWindows ) ) self . qApplication . quit ( )", "docstring_tokens": "Quits the application ( called when the last window is closed )", "label": 1}, {"idx": "cosqa-train-7720", "doc": "python std deviation of time", "code": "def circstd(dts, axis=2):\n    \"\"\"Circular standard deviation\"\"\"\n    R = np.abs(np.exp(1.0j * dts).mean(axis=axis))\n    return np.sqrt(-2.0 * np.log(R))", "code_tokens": "def circstd ( dts , axis = 2 ) : R = np . abs ( np . exp ( 1.0j * dts ) . mean ( axis = axis ) ) return np . sqrt ( - 2.0 * np . log ( R ) )", "docstring_tokens": "Circular standard deviation", "label": 1}, {"idx": "cosqa-train-7721", "doc": "how to store a default value in python", "code": "def setdefault(obj, field, default):\n    \"\"\"Set an object's field to default if it doesn't have a value\"\"\"\n    setattr(obj, field, getattr(obj, field, default))", "code_tokens": "def setdefault ( obj , field , default ) : setattr ( obj , field , getattr ( obj , field , default ) )", "docstring_tokens": "Set an object s field to default if it doesn t have a value", "label": 1}, {"idx": "cosqa-train-7722", "doc": "python stdin character encoding", "code": "def getdefaultencoding():\n    \"\"\"Return IPython's guess for the default encoding for bytes as text.\n\n    Asks for stdin.encoding first, to match the calling Terminal, but that\n    is often None for subprocesses.  Fall back on locale.getpreferredencoding()\n    which should be a sensible platform default (that respects LANG environment),\n    and finally to sys.getdefaultencoding() which is the most conservative option,\n    and usually ASCII.\n    \"\"\"\n    enc = get_stream_enc(sys.stdin)\n    if not enc or enc=='ascii':\n        try:\n            # There are reports of getpreferredencoding raising errors\n            # in some cases, which may well be fixed, but let's be conservative here.\n            enc = locale.getpreferredencoding()\n        except Exception:\n            pass\n    return enc or sys.getdefaultencoding()", "code_tokens": "def getdefaultencoding ( ) : enc = get_stream_enc ( sys . stdin ) if not enc or enc == 'ascii' : try : # There are reports of getpreferredencoding raising errors # in some cases, which may well be fixed, but let's be conservative here. enc = locale . getpreferredencoding ( ) except Exception : pass return enc or sys . getdefaultencoding ( )", "docstring_tokens": "Return IPython s guess for the default encoding for bytes as text .", "label": 0}, {"idx": "cosqa-train-7723", "doc": "how to strop an animation from repeating in python", "code": "def save(self, *args, **kwargs):\n        \"\"\"Saves an animation\n\n        A wrapper around :meth:`matplotlib.animation.Animation.save`\n        \"\"\"\n        self.timeline.index -= 1  # required for proper starting point for save\n        self.animation.save(*args, **kwargs)", "code_tokens": "def save ( self , * args , * * kwargs ) : self . timeline . index -= 1 # required for proper starting point for save self . animation . save ( * args , * * kwargs )", "docstring_tokens": "Saves an animation", "label": 0}, {"idx": "cosqa-train-7724", "doc": "python stdin file or tty", "code": "def read_stdin():\n    \"\"\" Read text from stdin, and print a helpful message for ttys. \"\"\"\n    if sys.stdin.isatty() and sys.stdout.isatty():\n        print('\\nReading from stdin until end of file (Ctrl + D)...')\n\n    return sys.stdin.read()", "code_tokens": "def read_stdin ( ) : if sys . stdin . isatty ( ) and sys . stdout . isatty ( ) : print ( '\\nReading from stdin until end of file (Ctrl + D)...' ) return sys . stdin . read ( )", "docstring_tokens": "Read text from stdin and print a helpful message for ttys .", "label": 1}, {"idx": "cosqa-train-7725", "doc": "how to swap maatrix rows in python", "code": "def _swap_rows(self, i, j):\n        \"\"\"Swap i and j rows\n\n        As the side effect, determinant flips.\n\n        \"\"\"\n\n        L = np.eye(3, dtype='intc')\n        L[i, i] = 0\n        L[j, j] = 0\n        L[i, j] = 1\n        L[j, i] = 1\n        self._L.append(L.copy())\n        self._A = np.dot(L, self._A)", "code_tokens": "def _swap_rows ( self , i , j ) : L = np . eye ( 3 , dtype = 'intc' ) L [ i , i ] = 0 L [ j , j ] = 0 L [ i , j ] = 1 L [ j , i ] = 1 self . _L . append ( L . copy ( ) ) self . _A = np . dot ( L , self . _A )", "docstring_tokens": "Swap i and j rows", "label": 1}, {"idx": "cosqa-train-7726", "doc": "python stdin object type", "code": "def __init__(self, encoding='utf-8'):\n    \"\"\"Initializes an stdin input reader.\n\n    Args:\n      encoding (Optional[str]): input encoding.\n    \"\"\"\n    super(StdinInputReader, self).__init__(sys.stdin, encoding=encoding)", "code_tokens": "def __init__ ( self , encoding = 'utf-8' ) : super ( StdinInputReader , self ) . __init__ ( sys . stdin , encoding = encoding )", "docstring_tokens": "Initializes an stdin input reader .", "label": 0}, {"idx": "cosqa-train-7727", "doc": "how to take data columns in mss file python", "code": "def generate_split_tsv_lines(fn, header):\n    \"\"\"Returns dicts with header-keys and psm statistic values\"\"\"\n    for line in generate_tsv_psms_line(fn):\n        yield {x: y for (x, y) in zip(header, line.strip().split('\\t'))}", "code_tokens": "def generate_split_tsv_lines ( fn , header ) : for line in generate_tsv_psms_line ( fn ) : yield { x : y for ( x , y ) in zip ( header , line . strip ( ) . split ( '\\t' ) ) }", "docstring_tokens": "Returns dicts with header - keys and psm statistic values", "label": 0}, {"idx": "cosqa-train-7728", "doc": "python stdout write line", "code": "def println(msg):\n    \"\"\"\n    Convenience function to print messages on a single line in the terminal\n    \"\"\"\n    sys.stdout.write(msg)\n    sys.stdout.flush()\n    sys.stdout.write('\\x08' * len(msg))\n    sys.stdout.flush()", "code_tokens": "def println ( msg ) : sys . stdout . write ( msg ) sys . stdout . flush ( ) sys . stdout . write ( '\\x08' * len ( msg ) ) sys . stdout . flush ( )", "docstring_tokens": "Convenience function to print messages on a single line in the terminal", "label": 0}, {"idx": "cosqa-train-7729", "doc": "how to tell if a list is sorted python", "code": "def issorted(list_, op=operator.le):\n    \"\"\"\n    Determines if a list is sorted\n\n    Args:\n        list_ (list):\n        op (func): sorted operation (default=operator.le)\n\n    Returns:\n        bool : True if the list is sorted\n    \"\"\"\n    return all(op(list_[ix], list_[ix + 1]) for ix in range(len(list_) - 1))", "code_tokens": "def issorted ( list_ , op = operator . le ) : return all ( op ( list_ [ ix ] , list_ [ ix + 1 ] ) for ix in range ( len ( list_ ) - 1 ) )", "docstring_tokens": "Determines if a list is sorted", "label": 0}, {"idx": "cosqa-train-7730", "doc": "python stop a moduyle", "code": "def nothread_quit(self, arg):\n        \"\"\" quit command when there's just one thread. \"\"\"\n\n        self.debugger.core.stop()\n        self.debugger.core.execution_status = 'Quit command'\n        raise Mexcept.DebuggerQuit", "code_tokens": "def nothread_quit ( self , arg ) : self . debugger . core . stop ( ) self . debugger . core . execution_status = 'Quit command' raise Mexcept . DebuggerQuit", "docstring_tokens": "quit command when there s just one thread .", "label": 0}, {"idx": "cosqa-train-7731", "doc": "how to tell if complex number in python", "code": "def is_complex(dtype):\n  \"\"\"Returns whether this is a complex floating point type.\"\"\"\n  dtype = tf.as_dtype(dtype)\n  if hasattr(dtype, 'is_complex'):\n    return dtype.is_complex\n  return np.issubdtype(np.dtype(dtype), np.complex)", "code_tokens": "def is_complex ( dtype ) : dtype = tf . as_dtype ( dtype ) if hasattr ( dtype , 'is_complex' ) : return dtype . is_complex return np . issubdtype ( np . dtype ( dtype ) , np . complex )", "docstring_tokens": "Returns whether this is a complex floating point type .", "label": 0}, {"idx": "cosqa-train-7732", "doc": "python stop flask server after response", "code": "def exit(self):\n        \"\"\"Stop the simple WSGI server running the appliation.\"\"\"\n        if self._server is not None:\n            self._server.shutdown()\n            self._server.server_close()\n            self._server = None", "code_tokens": "def exit ( self ) : if self . _server is not None : self . _server . shutdown ( ) self . _server . server_close ( ) self . _server = None", "docstring_tokens": "Stop the simple WSGI server running the appliation .", "label": 1}, {"idx": "cosqa-train-7733", "doc": "how to tell what you python path is", "code": "def getpackagepath():\n    \"\"\"\n     *Get the root path for this python package - used in unit testing code*\n    \"\"\"\n    moduleDirectory = os.path.dirname(__file__)\n    packagePath = os.path.dirname(__file__) + \"/../\"\n\n    return packagePath", "code_tokens": "def getpackagepath ( ) : moduleDirectory = os . path . dirname ( __file__ ) packagePath = os . path . dirname ( __file__ ) + \"/../\" return packagePath", "docstring_tokens": "* Get the root path for this python package - used in unit testing code *", "label": 1}, {"idx": "cosqa-train-7734", "doc": "python stop update services", "code": "def stop(self, reason=None):\n        \"\"\"Shutdown the service with a reason.\"\"\"\n        self.logger.info('stopping')\n        self.loop.stop(pyev.EVBREAK_ALL)", "code_tokens": "def stop ( self , reason = None ) : self . logger . info ( 'stopping' ) self . loop . stop ( pyev . EVBREAK_ALL )", "docstring_tokens": "Shutdown the service with a reason .", "label": 1}, {"idx": "cosqa-train-7735", "doc": "how to trim whitespace in python", "code": "def text_remove_empty_lines(text):\n    \"\"\"\n    Whitespace normalization:\n\n      - Strip empty lines\n      - Strip trailing whitespace\n    \"\"\"\n    lines = [ line.rstrip()  for line in text.splitlines()  if line.strip() ]\n    return \"\\n\".join(lines)", "code_tokens": "def text_remove_empty_lines ( text ) : lines = [ line . rstrip ( ) for line in text . splitlines ( ) if line . strip ( ) ] return \"\\n\" . join ( lines )", "docstring_tokens": "Whitespace normalization :", "label": 1}, {"idx": "cosqa-train-7736", "doc": "python store api responses as json", "code": "def json_response(data, status=200):\n    \"\"\"Return a JsonResponse. Make sure you have django installed first.\"\"\"\n    from django.http import JsonResponse\n    return JsonResponse(data=data, status=status, safe=isinstance(data, dict))", "code_tokens": "def json_response ( data , status = 200 ) : from django . http import JsonResponse return JsonResponse ( data = data , status = status , safe = isinstance ( data , dict ) )", "docstring_tokens": "Return a JsonResponse . Make sure you have django installed first .", "label": 1}, {"idx": "cosqa-train-7737", "doc": "how to turn a list into string python", "code": "def list_i2str(ilist):\n    \"\"\"\n    Convert an integer list into a string list.\n    \"\"\"\n    slist = []\n    for el in ilist:\n        slist.append(str(el))\n    return slist", "code_tokens": "def list_i2str ( ilist ) : slist = [ ] for el in ilist : slist . append ( str ( el ) ) return slist", "docstring_tokens": "Convert an integer list into a string list .", "label": 0}, {"idx": "cosqa-train-7738", "doc": "python str' object is not callable", "code": "def __str__(self):\n        \"\"\"Executes self.function to convert LazyString instance to a real\n        str.\"\"\"\n        if not hasattr(self, '_str'):\n            self._str=self.function(*self.args, **self.kwargs)\n        return self._str", "code_tokens": "def __str__ ( self ) : if not hasattr ( self , '_str' ) : self . _str = self . function ( * self . args , * * self . kwargs ) return self . _str", "docstring_tokens": "Executes self . function to convert LazyString instance to a real str .", "label": 1}, {"idx": "cosqa-train-7739", "doc": "how to turn a non iterable object in python into an iterable object", "code": "def concat(cls, iterables):\n    \"\"\"\n    Similar to #itertools.chain.from_iterable().\n    \"\"\"\n\n    def generator():\n      for it in iterables:\n        for element in it:\n          yield element\n    return cls(generator())", "code_tokens": "def concat ( cls , iterables ) : def generator ( ) : for it in iterables : for element in it : yield element return cls ( generator ( ) )", "docstring_tokens": "Similar to #itertools . chain . from_iterable () .", "label": 0}, {"idx": "cosqa-train-7740", "doc": "python stream data is empty after read", "code": "def next (self):    # File-like object.\n\n        \"\"\"This is to support iterators over a file-like object.\n        \"\"\"\n\n        result = self.readline()\n        if result == self._empty_buffer:\n            raise StopIteration\n        return result", "code_tokens": "def next ( self ) : # File-like object. result = self . readline ( ) if result == self . _empty_buffer : raise StopIteration return result", "docstring_tokens": "This is to support iterators over a file - like object .", "label": 0}, {"idx": "cosqa-train-7741", "doc": "how to turn array of arrays to one array in python", "code": "def pack_triples_numpy(triples):\n    \"\"\"Packs a list of triple indexes into a 2D numpy array.\"\"\"\n    if len(triples) == 0:\n        return np.array([], dtype=np.int64)\n    return np.stack(list(map(_transform_triple_numpy, triples)), axis=0)", "code_tokens": "def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )", "docstring_tokens": "Packs a list of triple indexes into a 2D numpy array .", "label": 0}, {"idx": "cosqa-train-7742", "doc": "python strftime milliseconds precision", "code": "def fmt_duration(secs):\n    \"\"\"Format a duration in seconds.\"\"\"\n    return ' '.join(fmt.human_duration(secs, 0, precision=2, short=True).strip().split())", "code_tokens": "def fmt_duration ( secs ) : return ' ' . join ( fmt . human_duration ( secs , 0 , precision = 2 , short = True ) . strip ( ) . split ( ) )", "docstring_tokens": "Format a duration in seconds .", "label": 1}, {"idx": "cosqa-train-7743", "doc": "how to turn sync functino asynchronous python asyncio", "code": "def runcoro(async_function):\n    \"\"\"\n    Runs an asynchronous function without needing to use await - useful for lambda\n\n    Args:\n        async_function (Coroutine): The asynchronous function to run\n    \"\"\"\n\n    future = _asyncio.run_coroutine_threadsafe(async_function, client.loop)\n    result = future.result()\n    return result", "code_tokens": "def runcoro ( async_function ) : future = _asyncio . run_coroutine_threadsafe ( async_function , client . loop ) result = future . result ( ) return result", "docstring_tokens": "Runs an asynchronous function without needing to use await - useful for lambda", "label": 1}, {"idx": "cosqa-train-7744", "doc": "python string date to epoch", "code": "def AmericanDateToEpoch(self, date_str):\n    \"\"\"Take a US format date and return epoch.\"\"\"\n    try:\n      epoch = time.strptime(date_str, \"%m/%d/%Y\")\n      return int(calendar.timegm(epoch)) * 1000000\n    except ValueError:\n      return 0", "code_tokens": "def AmericanDateToEpoch ( self , date_str ) : try : epoch = time . strptime ( date_str , \"%m/%d/%Y\" ) return int ( calendar . timegm ( epoch ) ) * 1000000 except ValueError : return 0", "docstring_tokens": "Take a US format date and return epoch .", "label": 1}, {"idx": "cosqa-train-7745", "doc": "how to use capitalize eacg word in python", "code": "def to_camel_case(text):\n    \"\"\"Convert to camel case.\n\n    :param str text:\n    :rtype: str\n    :return:\n    \"\"\"\n    split = text.split('_')\n    return split[0] + \"\".join(x.title() for x in split[1:])", "code_tokens": "def to_camel_case ( text ) : split = text . split ( '_' ) return split [ 0 ] + \"\" . join ( x . title ( ) for x in split [ 1 : ] )", "docstring_tokens": "Convert to camel case .", "label": 1}, {"idx": "cosqa-train-7746", "doc": "python string differnce accuracy", "code": "def entropy(string):\n    \"\"\"Compute entropy on the string\"\"\"\n    p, lns = Counter(string), float(len(string))\n    return -sum(count/lns * math.log(count/lns, 2) for count in p.values())", "code_tokens": "def entropy ( string ) : p , lns = Counter ( string ) , float ( len ( string ) ) return - sum ( count / lns * math . log ( count / lns , 2 ) for count in p . values ( ) )", "docstring_tokens": "Compute entropy on the string", "label": 0}, {"idx": "cosqa-train-7747", "doc": "how to use fillna for blank strings in python", "code": "def fill_nulls(self, col: str):\n        \"\"\"\n        Fill all null values with NaN values in a column.\n        Null values are ``None`` or en empty string\n\n        :param col: column name\n        :type col: str\n\n        :example: ``ds.fill_nulls(\"mycol\")``\n        \"\"\"\n        n = [None, \"\"]\n        try:\n            self.df[col] = self.df[col].replace(n, nan)\n        except Exception as e:\n            self.err(e)", "code_tokens": "def fill_nulls ( self , col : str ) : n = [ None , \"\" ] try : self . df [ col ] = self . df [ col ] . replace ( n , nan ) except Exception as e : self . err ( e )", "docstring_tokens": "Fill all null values with NaN values in a column . Null values are None or en empty string", "label": 1}, {"idx": "cosqa-train-7748", "doc": "python string format of dictionary to dictionary", "code": "def str_dict(some_dict):\n    \"\"\"Convert dict of ascii str/unicode to dict of str, if necessary\"\"\"\n    return {str(k): str(v) for k, v in some_dict.items()}", "code_tokens": "def str_dict ( some_dict ) : return { str ( k ) : str ( v ) for k , v in some_dict . items ( ) }", "docstring_tokens": "Convert dict of ascii str / unicode to dict of str if necessary", "label": 1}, {"idx": "cosqa-train-7749", "doc": "how to use isin to negate in python", "code": "def notin(arg, values):\n    \"\"\"\n    Like isin, but checks whether this expression's value(s) are not\n    contained in the passed values. See isin docs for full usage.\n    \"\"\"\n    op = ops.NotContains(arg, values)\n    return op.to_expr()", "code_tokens": "def notin ( arg , values ) : op = ops . NotContains ( arg , values ) return op . to_expr ( )", "docstring_tokens": "Like isin but checks whether this expression s value ( s ) are not contained in the passed values . See isin docs for full usage .", "label": 0}, {"idx": "cosqa-train-7750", "doc": "python string formating stackoverflow", "code": "def exception_format():\n    \"\"\"\n    Convert exception info into a string suitable for display.\n    \"\"\"\n    return \"\".join(traceback.format_exception(\n        sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]\n    ))", "code_tokens": "def exception_format ( ) : return \"\" . join ( traceback . format_exception ( sys . exc_info ( ) [ 0 ] , sys . exc_info ( ) [ 1 ] , sys . exc_info ( ) [ 2 ] ) )", "docstring_tokens": "Convert exception info into a string suitable for display .", "label": 1}, {"idx": "cosqa-train-7751", "doc": "how to use key to access tags in python", "code": "def graph_key_from_tag(tag, entity_index):\n    \"\"\"Returns a key from a tag entity\n\n    Args:\n        tag (tag) : this is the tag selected to get the key from\n        entity_index (int) : this is the index of the tagged entity\n\n    Returns:\n        str : String representing the key for the given tagged entity.\n    \"\"\"\n    start_token = tag.get('start_token')\n    entity = tag.get('entities', [])[entity_index]\n    return str(start_token) + '-' + entity.get('key') + '-' + str(entity.get('confidence'))", "code_tokens": "def graph_key_from_tag ( tag , entity_index ) : start_token = tag . get ( 'start_token' ) entity = tag . get ( 'entities' , [ ] ) [ entity_index ] return str ( start_token ) + '-' + entity . get ( 'key' ) + '-' + str ( entity . get ( 'confidence' ) )", "docstring_tokens": "Returns a key from a tag entity", "label": 0}, {"idx": "cosqa-train-7752", "doc": "python string graphic font width", "code": "def measure_string(self, text, fontname, fontsize, encoding=0):\n        \"\"\"Measure length of a string for a Base14 font.\"\"\"\n        return _fitz.Tools_measure_string(self, text, fontname, fontsize, encoding)", "code_tokens": "def measure_string ( self , text , fontname , fontsize , encoding = 0 ) : return _fitz . Tools_measure_string ( self , text , fontname , fontsize , encoding )", "docstring_tokens": "Measure length of a string for a Base14 font .", "label": 1}, {"idx": "cosqa-train-7753", "doc": "how to use multiple booleen opetators in python", "code": "def visit_BoolOp(self, node):\n        \"\"\" Return type may come from any boolop operand. \"\"\"\n        return sum((self.visit(value) for value in node.values), [])", "code_tokens": "def visit_BoolOp ( self , node ) : return sum ( ( self . visit ( value ) for value in node . values ) , [ ] )", "docstring_tokens": "Return type may come from any boolop operand .", "label": 1}, {"idx": "cosqa-train-7754", "doc": "python string logical comparison", "code": "def __is__(cls, s):\n        \"\"\"Test if string matches this argument's format.\"\"\"\n        return s.startswith(cls.delims()[0]) and s.endswith(cls.delims()[1])", "code_tokens": "def __is__ ( cls , s ) : return s . startswith ( cls . delims ( ) [ 0 ] ) and s . endswith ( cls . delims ( ) [ 1 ] )", "docstring_tokens": "Test if string matches this argument s format .", "label": 0}, {"idx": "cosqa-train-7755", "doc": "how to use python to check contains", "code": "def instance_contains(container, item):\n    \"\"\"Search into instance attributes, properties and return values of no-args methods.\"\"\"\n    return item in (member for _, member in inspect.getmembers(container))", "code_tokens": "def instance_contains ( container , item ) : return item in ( member for _ , member in inspect . getmembers ( container ) )", "docstring_tokens": "Search into instance attributes properties and return values of no - args methods .", "label": 0}, {"idx": "cosqa-train-7756", "doc": "python string methods to remove punctuation", "code": "def unpunctuate(s, *, char_blacklist=string.punctuation):\n    \"\"\" Remove punctuation from string s. \"\"\"\n    # remove punctuation\n    s = \"\".join(c for c in s if c not in char_blacklist)\n    # remove consecutive spaces\n    return \" \".join(filter(None, s.split(\" \")))", "code_tokens": "def unpunctuate ( s , * , char_blacklist = string . punctuation ) : # remove punctuation s = \"\" . join ( c for c in s if c not in char_blacklist ) # remove consecutive spaces return \" \" . join ( filter ( None , s . split ( \" \" ) ) )", "docstring_tokens": "Remove punctuation from string s .", "label": 0}, {"idx": "cosqa-train-7757", "doc": "python string remove white spaces three different way", "code": "def text_cleanup(data, key, last_type):\n    \"\"\" I strip extra whitespace off multi-line strings if they are ready to be stripped!\"\"\"\n    if key in data and last_type == STRING_TYPE:\n        data[key] = data[key].strip()\n    return data", "code_tokens": "def text_cleanup ( data , key , last_type ) : if key in data and last_type == STRING_TYPE : data [ key ] = data [ key ] . strip ( ) return data", "docstring_tokens": "I strip extra whitespace off multi - line strings if they are ready to be stripped!", "label": 1}, {"idx": "cosqa-train-7758", "doc": "how to use python to do fft", "code": "def stft(func=None, **kwparams):\n  \"\"\"\n  Short Time Fourier Transform for real data keeping the full FFT block.\n\n  Same to the default STFT strategy, but with new defaults. This is the same\n  to:\n\n  .. code-block:: python\n\n    stft.base(transform=numpy.fft.fft,\n              inverse_transform=lambda *args: numpy.fft.ifft(*args).real)\n\n  See ``stft.base`` docs for more.\n  \"\"\"\n  from numpy.fft import fft, ifft\n  ifft_r = lambda *args: ifft(*args).real\n  return stft.base(transform=fft, inverse_transform=ifft_r)(func, **kwparams)", "code_tokens": "def stft ( func = None , * * kwparams ) : from numpy . fft import fft , ifft ifft_r = lambda * args : ifft ( * args ) . real return stft . base ( transform = fft , inverse_transform = ifft_r ) ( func , * * kwparams )", "docstring_tokens": "Short Time Fourier Transform for real data keeping the full FFT block .", "label": 0}, {"idx": "cosqa-train-7759", "doc": "python string replace case insensitive", "code": "def to_snake_case(name):\n    \"\"\" Given a name in camelCase return in snake_case \"\"\"\n    s1 = FIRST_CAP_REGEX.sub(r'\\1_\\2', name)\n    return ALL_CAP_REGEX.sub(r'\\1_\\2', s1).lower()", "code_tokens": "def to_snake_case ( name ) : s1 = FIRST_CAP_REGEX . sub ( r'\\1_\\2' , name ) return ALL_CAP_REGEX . sub ( r'\\1_\\2' , s1 ) . lower ( )", "docstring_tokens": "Given a name in camelCase return in snake_case", "label": 1}, {"idx": "cosqa-train-7760", "doc": "how to use python to perform fft", "code": "def stft(func=None, **kwparams):\n  \"\"\"\n  Short Time Fourier Transform for real data keeping the full FFT block.\n\n  Same to the default STFT strategy, but with new defaults. This is the same\n  to:\n\n  .. code-block:: python\n\n    stft.base(transform=numpy.fft.fft,\n              inverse_transform=lambda *args: numpy.fft.ifft(*args).real)\n\n  See ``stft.base`` docs for more.\n  \"\"\"\n  from numpy.fft import fft, ifft\n  ifft_r = lambda *args: ifft(*args).real\n  return stft.base(transform=fft, inverse_transform=ifft_r)(func, **kwparams)", "code_tokens": "def stft ( func = None , * * kwparams ) : from numpy . fft import fft , ifft ifft_r = lambda * args : ifft ( * args ) . real return stft . base ( transform = fft , inverse_transform = ifft_r ) ( func , * * kwparams )", "docstring_tokens": "Short Time Fourier Transform for real data keeping the full FFT block .", "label": 1}, {"idx": "cosqa-train-7761", "doc": "python string slice end of string", "code": "def fsliceafter(astr, sub):\n    \"\"\"Return the slice after at sub in string astr\"\"\"\n    findex = astr.find(sub)\n    return astr[findex + len(sub):]", "code_tokens": "def fsliceafter ( astr , sub ) : findex = astr . find ( sub ) return astr [ findex + len ( sub ) : ]", "docstring_tokens": "Return the slice after at sub in string astr", "label": 1}, {"idx": "cosqa-train-7762", "doc": "how to use the restart python function", "code": "def do_restart(self, line):\n        \"\"\"Request that the Outstation perform a cold restart. Command syntax is: restart\"\"\"\n        self.application.master.Restart(opendnp3.RestartType.COLD, restart_callback)", "code_tokens": "def do_restart ( self , line ) : self . application . master . Restart ( opendnp3 . RestartType . COLD , restart_callback )", "docstring_tokens": "Request that the Outstation perform a cold restart . Command syntax is : restart", "label": 0}, {"idx": "cosqa-train-7763", "doc": "python string slice first half", "code": "def fsliceafter(astr, sub):\n    \"\"\"Return the slice after at sub in string astr\"\"\"\n    findex = astr.find(sub)\n    return astr[findex + len(sub):]", "code_tokens": "def fsliceafter ( astr , sub ) : findex = astr . find ( sub ) return astr [ findex + len ( sub ) : ]", "docstring_tokens": "Return the slice after at sub in string astr", "label": 1}, {"idx": "cosqa-train-7764", "doc": "how to validate a regex in python3", "code": "def is_valid_regex(string):\n    \"\"\"\n    Checks whether the re module can compile the given regular expression.\n\n    Parameters\n    ----------\n    string: str\n\n    Returns\n    -------\n    boolean\n    \"\"\"\n    try:\n        re.compile(string)\n        is_valid = True\n    except re.error:\n        is_valid = False\n    return is_valid", "code_tokens": "def is_valid_regex ( string ) : try : re . compile ( string ) is_valid = True except re . error : is_valid = False return is_valid", "docstring_tokens": "Checks whether the re module can compile the given regular expression .", "label": 1}, {"idx": "cosqa-train-7765", "doc": "python string to c++ char array", "code": "def bytes_to_c_array(data):\n    \"\"\"\n    Make a C array using the given string.\n    \"\"\"\n    chars = [\n        \"'{}'\".format(encode_escape(i))\n        for i in decode_escape(data)\n    ]\n    return ', '.join(chars) + ', 0'", "code_tokens": "def bytes_to_c_array ( data ) : chars = [ \"'{}'\" . format ( encode_escape ( i ) ) for i in decode_escape ( data ) ] return ', ' . join ( chars ) + ', 0'", "docstring_tokens": "Make a C array using the given string .", "label": 1}, {"idx": "cosqa-train-7766", "doc": "how to verify if a type is a string python", "code": "def is_string(val):\n    \"\"\"Determines whether the passed value is a string, safe for 2/3.\"\"\"\n    try:\n        basestring\n    except NameError:\n        return isinstance(val, str)\n    return isinstance(val, basestring)", "code_tokens": "def is_string ( val ) : try : basestring except NameError : return isinstance ( val , str ) return isinstance ( val , basestring )", "docstring_tokens": "Determines whether the passed value is a string safe for 2 / 3 .", "label": 1}, {"idx": "cosqa-train-7767", "doc": "python strings sstrip punctuation", "code": "def _clean_str(self, s):\n        \"\"\" Returns a lowercase string with punctuation and bad chars removed\n        :param s: string to clean\n        \"\"\"\n        return s.translate(str.maketrans('', '', punctuation)).replace('\\u200b', \" \").strip().lower()", "code_tokens": "def _clean_str ( self , s ) : return s . translate ( str . maketrans ( '' , '' , punctuation ) ) . replace ( '\\u200b' , \" \" ) . strip ( ) . lower ( )", "docstring_tokens": "Returns a lowercase string with punctuation and bad chars removed : param s : string to clean", "label": 1}, {"idx": "cosqa-train-7768", "doc": "how to view the connection status in python", "code": "def _print(self, msg, flush=False, end=\"\\n\"):\n        \"\"\"Helper function to print connection status messages when in verbose mode.\"\"\"\n        if self._verbose:\n            print2(msg, end=end, flush=flush)", "code_tokens": "def _print ( self , msg , flush = False , end = \"\\n\" ) : if self . _verbose : print2 ( msg , end = end , flush = flush )", "docstring_tokens": "Helper function to print connection status messages when in verbose mode .", "label": 0}, {"idx": "cosqa-train-7769", "doc": "python strip trailing non alpha", "code": "def _to_lower_alpha_only(s):\n    \"\"\"Return a lowercased string with non alphabetic chars removed.\n\n    White spaces are not to be removed.\"\"\"\n    s = re.sub(r'\\n', ' ',  s.lower())\n    return re.sub(r'[^a-z\\s]', '', s)", "code_tokens": "def _to_lower_alpha_only ( s ) : s = re . sub ( r'\\n' , ' ' , s . lower ( ) ) return re . sub ( r'[^a-z\\s]' , '' , s )", "docstring_tokens": "Return a lowercased string with non alphabetic chars removed .", "label": 0}, {"idx": "cosqa-train-7770", "doc": "how to visualize decision tree python sklearn", "code": "def human__decision_tree():\n    \"\"\" Decision Tree\n    \"\"\"\n\n    # build data\n    N = 1000000\n    M = 3\n    X = np.zeros((N,M))\n    X.shape\n    y = np.zeros(N)\n    X[0, 0] = 1\n    y[0] = 8\n    X[1, 1] = 1\n    y[1] = 8\n    X[2, 0:2] = 1\n    y[2] = 4\n\n    # fit model\n    xor_model = sklearn.tree.DecisionTreeRegressor(max_depth=2)\n    xor_model.fit(X, y)\n\n    return xor_model", "code_tokens": "def human__decision_tree ( ) : # build data N = 1000000 M = 3 X = np . zeros ( ( N , M ) ) X . shape y = np . zeros ( N ) X [ 0 , 0 ] = 1 y [ 0 ] = 8 X [ 1 , 1 ] = 1 y [ 1 ] = 8 X [ 2 , 0 : 2 ] = 1 y [ 2 ] = 4 # fit model xor_model = sklearn . tree . DecisionTreeRegressor ( max_depth = 2 ) xor_model . fit ( X , y ) return xor_model", "docstring_tokens": "Decision Tree", "label": 1}, {"idx": "cosqa-train-7771", "doc": "python strip zeroes after decimal", "code": "def drop_trailing_zeros_decimal(num):\n    \"\"\" Drops the trailinz zeros from decimal value.\n        Returns a string\n    \"\"\"\n    out = str(num)\n    return out.rstrip('0').rstrip('.') if '.' in out else out", "code_tokens": "def drop_trailing_zeros_decimal ( num ) : out = str ( num ) return out . rstrip ( '0' ) . rstrip ( '.' ) if '.' in out else out", "docstring_tokens": "Drops the trailinz zeros from decimal value . Returns a string", "label": 0}, {"idx": "cosqa-train-7772", "doc": "how to write a function that returns the fibonacci number on python", "code": "def software_fibonacci(n):\n    \"\"\" a normal old python function to return the Nth fibonacci number. \"\"\"\n    a, b = 0, 1\n    for i in range(n):\n        a, b = b, a + b\n    return a", "code_tokens": "def software_fibonacci ( n ) : a , b = 0 , 1 for i in range ( n ) : a , b = b , a + b return a", "docstring_tokens": "a normal old python function to return the Nth fibonacci number .", "label": 0}, {"idx": "cosqa-train-7773", "doc": "python subplot second y axis", "code": "def show_yticklabels(self, row, column):\n        \"\"\"Show the y-axis tick labels for a subplot.\n\n        :param row,column: specify the subplot.\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.show_yticklabels()", "code_tokens": "def show_yticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_yticklabels ( )", "docstring_tokens": "Show the y - axis tick labels for a subplot .", "label": 1}, {"idx": "cosqa-train-7774", "doc": "how to write a variable value to log python", "code": "def info(self, text):\n\t\t\"\"\" Ajout d'un message de log de type INFO \"\"\"\n\t\tself.logger.info(\"{}{}\".format(self.message_prefix, text))", "code_tokens": "def info ( self , text ) : self . logger . info ( \"{}{}\" . format ( self . message_prefix , text ) )", "docstring_tokens": "Ajout d un message de log de type INFO", "label": 1}, {"idx": "cosqa-train-7775", "doc": "python subplot xtick labels won't show", "code": "def show_xticklabels(self, row, column):\n        \"\"\"Show the x-axis tick labels for a subplot.\n\n        :param row,column: specify the subplot.\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.show_xticklabels()", "code_tokens": "def show_xticklabels ( self , row , column ) : subplot = self . get_subplot_at ( row , column ) subplot . show_xticklabels ( )", "docstring_tokens": "Show the x - axis tick labels for a subplot .", "label": 1}, {"idx": "cosqa-train-7776", "doc": "how to write to a document without erasing python", "code": "def write_document(doc, fnm):\n    \"\"\"Write a Text document to file.\n\n    Parameters\n    ----------\n    doc: Text\n        The document to save.\n    fnm: str\n        The filename to save the document\n    \"\"\"\n    with codecs.open(fnm, 'wb', 'ascii') as f:\n        f.write(json.dumps(doc, indent=2))", "code_tokens": "def write_document ( doc , fnm ) : with codecs . open ( fnm , 'wb' , 'ascii' ) as f : f . write ( json . dumps ( doc , indent = 2 ) )", "docstring_tokens": "Write a Text document to file .", "label": 0}, {"idx": "cosqa-train-7777", "doc": "python subprocess run bash script in local directory", "code": "def bash(filename):\n    \"\"\"Runs a bash script in the local directory\"\"\"\n    sys.stdout.flush()\n    subprocess.call(\"bash {}\".format(filename), shell=True)", "code_tokens": "def bash ( filename ) : sys . stdout . flush ( ) subprocess . call ( \"bash {}\" . format ( filename ) , shell = True )", "docstring_tokens": "Runs a bash script in the local directory", "label": 1}, {"idx": "cosqa-train-7778", "doc": "hwo to get function name in the function python", "code": "def get_func_name(func):\n    \"\"\"Return a name which includes the module name and function name.\"\"\"\n    func_name = getattr(func, '__name__', func.__class__.__name__)\n    module_name = func.__module__\n\n    if module_name is not None:\n        module_name = func.__module__\n        return '{}.{}'.format(module_name, func_name)\n\n    return func_name", "code_tokens": "def get_func_name ( func ) : func_name = getattr ( func , '__name__' , func . __class__ . __name__ ) module_name = func . __module__ if module_name is not None : module_name = func . __module__ return '{}.{}' . format ( module_name , func_name ) return func_name", "docstring_tokens": "Return a name which includes the module name and function name .", "label": 1}, {"idx": "cosqa-train-7779", "doc": "python subprocess thread not closing", "code": "def _finish(self):\n        \"\"\"\n        Closes and waits for subprocess to exit.\n        \"\"\"\n        if self._process.returncode is None:\n            self._process.stdin.flush()\n            self._process.stdin.close()\n            self._process.wait()\n            self.closed = True", "code_tokens": "def _finish ( self ) : if self . _process . returncode is None : self . _process . stdin . flush ( ) self . _process . stdin . close ( ) self . _process . wait ( ) self . closed = True", "docstring_tokens": "Closes and waits for subprocess to exit .", "label": 1}, {"idx": "cosqa-train-7780", "doc": "i want to return none if input to my function is empty python", "code": "def get_input(input_func, input_str):\n    \"\"\"\n    Get input from the user given an input function and an input string\n    \"\"\"\n    val = input_func(\"Please enter your {0}: \".format(input_str))\n    while not val or not len(val.strip()):\n        val = input_func(\"You didn't enter a valid {0}, please try again: \".format(input_str))\n    return val", "code_tokens": "def get_input ( input_func , input_str ) : val = input_func ( \"Please enter your {0}: \" . format ( input_str ) ) while not val or not len ( val . strip ( ) ) : val = input_func ( \"You didn't enter a valid {0}, please try again: \" . format ( input_str ) ) return val", "docstring_tokens": "Get input from the user given an input function and an input string", "label": 1}, {"idx": "cosqa-train-7781", "doc": "python subprocess write stdin", "code": "def correspond(text):\n    \"\"\"Communicate with the child process without closing stdin.\"\"\"\n    subproc.stdin.write(text)\n    subproc.stdin.flush()\n    return drain()", "code_tokens": "def correspond ( text ) : subproc . stdin . write ( text ) subproc . stdin . flush ( ) return drain ( )", "docstring_tokens": "Communicate with the child process without closing stdin .", "label": 1}, {"idx": "cosqa-train-7782", "doc": "ideal lowpass filter python", "code": "def highpass(cutoff):\n  \"\"\"\n  This strategy uses an exponential approximation for cut-off frequency\n  calculation, found by matching the one-pole Laplace lowpass filter\n  and mirroring the resulting filter to get a highpass.\n  \"\"\"\n  R = thub(exp(cutoff - pi), 2)\n  return (1 - R) / (1 + R * z ** -1)", "code_tokens": "def highpass ( cutoff ) : R = thub ( exp ( cutoff - pi ) , 2 ) return ( 1 - R ) / ( 1 + R * z ** - 1 )", "docstring_tokens": "This strategy uses an exponential approximation for cut - off frequency calculation found by matching the one - pole Laplace lowpass filter and mirroring the resulting filter to get a highpass .", "label": 0}, {"idx": "cosqa-train-7783", "doc": "python subset list by list of index values", "code": "def filter_list_by_indices(lst, indices):\n    \"\"\"Return a modified list containing only the indices indicated.\n\n    Args:\n        lst: Original list of values\n        indices: List of indices to keep from the original list\n\n    Returns:\n        list: Filtered list of values\n\n    \"\"\"\n    return [x for i, x in enumerate(lst) if i in indices]", "code_tokens": "def filter_list_by_indices ( lst , indices ) : return [ x for i , x in enumerate ( lst ) if i in indices ]", "docstring_tokens": "Return a modified list containing only the indices indicated .", "label": 1}, {"idx": "cosqa-train-7784", "doc": "identify the index of median python", "code": "def median_high(data):\n    \"\"\"Return the high median of data.\n\n    When the number of data points is odd, the middle value is returned.\n    When it is even, the larger of the two middle values is returned.\n\n    \"\"\"\n    data = sorted(data)\n    n = len(data)\n    if n == 0:\n        raise StatisticsError(\"no median for empty data\")\n    return data[n // 2]", "code_tokens": "def median_high ( data ) : data = sorted ( data ) n = len ( data ) if n == 0 : raise StatisticsError ( \"no median for empty data\" ) return data [ n // 2 ]", "docstring_tokens": "Return the high median of data .", "label": 1}, {"idx": "cosqa-train-7785", "doc": "python sync mysql tables sqlalchemy", "code": "def init_db():\n    \"\"\"\n    Drops and re-creates the SQL schema\n    \"\"\"\n    db.drop_all()\n    db.configure_mappers()\n    db.create_all()\n    db.session.commit()", "code_tokens": "def init_db ( ) : db . drop_all ( ) db . configure_mappers ( ) db . create_all ( ) db . session . commit ( )", "docstring_tokens": "Drops and re - creates the SQL schema", "label": 0}, {"idx": "cosqa-train-7786", "doc": "if a string contains any of a list python", "code": "def any_contains_any(strings, candidates):\n    \"\"\"Whether any of the strings contains any of the candidates.\"\"\"\n    for string in strings:\n        for c in candidates:\n            if c in string:\n                return True", "code_tokens": "def any_contains_any ( strings , candidates ) : for string in strings : for c in candidates : if c in string : return True", "docstring_tokens": "Whether any of the strings contains any of the candidates .", "label": 1}, {"idx": "cosqa-train-7787", "doc": "python syntax parenthases inside", "code": "def maybeparens(lparen, item, rparen):\n    \"\"\"Wrap an item in optional parentheses, only applying them if necessary.\"\"\"\n    return item | lparen.suppress() + item + rparen.suppress()", "code_tokens": "def maybeparens ( lparen , item , rparen ) : return item | lparen . suppress ( ) + item + rparen . suppress ( )", "docstring_tokens": "Wrap an item in optional parentheses only applying them if necessary .", "label": 0}, {"idx": "cosqa-train-7788", "doc": "if file changes then python", "code": "def example_write_file_to_disk_if_changed():\n    \"\"\" Try to remove all comments from a file, and save it if changes were made. \"\"\"\n    my_file = FileAsObj('/tmp/example_file.txt')\n    my_file.rm(my_file.egrep('^#'))\n    if my_file.changed:\n        my_file.save()", "code_tokens": "def example_write_file_to_disk_if_changed ( ) : my_file = FileAsObj ( '/tmp/example_file.txt' ) my_file . rm ( my_file . egrep ( '^#' ) ) if my_file . changed : my_file . save ( )", "docstring_tokens": "Try to remove all comments from a file and save it if changes were made .", "label": 1}, {"idx": "cosqa-train-7789", "doc": "python table already exists", "code": "def exists(self):\n        \"\"\"Check whether the cluster already exists.\n\n        For example:\n\n        .. literalinclude:: snippets.py\n            :start-after: [START bigtable_check_cluster_exists]\n            :end-before: [END bigtable_check_cluster_exists]\n\n        :rtype: bool\n        :returns: True if the table exists, else False.\n        \"\"\"\n        client = self._instance._client\n        try:\n            client.instance_admin_client.get_cluster(name=self.name)\n            return True\n        # NOTE: There could be other exceptions that are returned to the user.\n        except NotFound:\n            return False", "code_tokens": "def exists ( self ) : client = self . _instance . _client try : client . instance_admin_client . get_cluster ( name = self . name ) return True # NOTE: There could be other exceptions that are returned to the user. except NotFound : return False", "docstring_tokens": "Check whether the cluster already exists .", "label": 0}, {"idx": "cosqa-train-7790", "doc": "python table column row slicing", "code": "def getcolslice(self, blc, trc, inc=[], startrow=0, nrow=-1, rowincr=1):\n        \"\"\"Get a slice from a table column holding arrays.\n        (see :func:`table.getcolslice`)\"\"\"\n        return self._table.getcolslice(self._column, blc, trc, inc, startrow, nrow, rowincr)", "code_tokens": "def getcolslice ( self , blc , trc , inc = [ ] , startrow = 0 , nrow = - 1 , rowincr = 1 ) : return self . _table . getcolslice ( self . _column , blc , trc , inc , startrow , nrow , rowincr )", "docstring_tokens": "Get a slice from a table column holding arrays . ( see : func : table . getcolslice )", "label": 1}, {"idx": "cosqa-train-7791", "doc": "if method equals post python flask", "code": "def handleFlaskPostRequest(flaskRequest, endpoint):\n    \"\"\"\n    Handles the specified flask request for one of the POST URLS\n    Invokes the specified endpoint to generate a response.\n    \"\"\"\n    if flaskRequest.method == \"POST\":\n        return handleHttpPost(flaskRequest, endpoint)\n    elif flaskRequest.method == \"OPTIONS\":\n        return handleHttpOptions()\n    else:\n        raise exceptions.MethodNotAllowedException()", "code_tokens": "def handleFlaskPostRequest ( flaskRequest , endpoint ) : if flaskRequest . method == \"POST\" : return handleHttpPost ( flaskRequest , endpoint ) elif flaskRequest . method == \"OPTIONS\" : return handleHttpOptions ( ) else : raise exceptions . MethodNotAllowedException ( )", "docstring_tokens": "Handles the specified flask request for one of the POST URLS Invokes the specified endpoint to generate a response .", "label": 0}, {"idx": "cosqa-train-7792", "doc": "python table styles colorful grid", "code": "def top(n, width=WIDTH, style=STYLE):\n    \"\"\"Prints the top row of a table\"\"\"\n    return hrule(n, width, linestyle=STYLES[style].top)", "code_tokens": "def top ( n , width = WIDTH , style = STYLE ) : return hrule ( n , width , linestyle = STYLES [ style ] . top )", "docstring_tokens": "Prints the top row of a table", "label": 0}, {"idx": "cosqa-train-7793", "doc": "if request args get flask python", "code": "def get_path_from_query_string(req):\n    \"\"\"Gets path from query string\n\n    Args:\n        req (flask.request): Request object from Flask\n\n    Returns:\n        path (str): Value of \"path\" parameter from query string\n\n    Raises:\n        exceptions.UserError: If \"path\" is not found in query string\n    \"\"\"\n    if req.args.get('path') is None:\n        raise exceptions.UserError('Path not found in query string')\n    return req.args.get('path')", "code_tokens": "def get_path_from_query_string ( req ) : if req . args . get ( 'path' ) is None : raise exceptions . UserError ( 'Path not found in query string' ) return req . args . get ( 'path' )", "docstring_tokens": "Gets path from query string", "label": 1}, {"idx": "cosqa-train-7794", "doc": "python tell all threads to end", "code": "def finish():\n    \"\"\"Print warning about interrupt and empty the job queue.\"\"\"\n    out.warn(\"Interrupted!\")\n    for t in threads:\n        t.stop()\n    jobs.clear()\n    out.warn(\"Waiting for download threads to finish.\")", "code_tokens": "def finish ( ) : out . warn ( \"Interrupted!\" ) for t in threads : t . stop ( ) jobs . clear ( ) out . warn ( \"Waiting for download threads to finish.\" )", "docstring_tokens": "Print warning about interrupt and empty the job queue .", "label": 1}, {"idx": "cosqa-train-7795", "doc": "python tell scalar or vector", "code": "def is_scalar(value):\n    \"\"\"Test if the given value is a scalar.\n\n    This function also works with memory mapped array values, in contrast to the numpy is_scalar method.\n\n    Args:\n        value: the value to test for being a scalar value\n\n    Returns:\n        boolean: if the given value is a scalar or not\n    \"\"\"\n    return np.isscalar(value) or (isinstance(value, np.ndarray) and (len(np.squeeze(value).shape) == 0))", "code_tokens": "def is_scalar ( value ) : return np . isscalar ( value ) or ( isinstance ( value , np . ndarray ) and ( len ( np . squeeze ( value ) . shape ) == 0 ) )", "docstring_tokens": "Test if the given value is a scalar .", "label": 1}, {"idx": "cosqa-train-7796", "doc": "if set is in subset python", "code": "def issubset(self, other):\n        \"\"\"Report whether another set contains this RangeSet.\"\"\"\n        self._binary_sanity_check(other)\n        return set.issubset(self, other)", "code_tokens": "def issubset ( self , other ) : self . _binary_sanity_check ( other ) return set . issubset ( self , other )", "docstring_tokens": "Report whether another set contains this RangeSet .", "label": 1}, {"idx": "cosqa-train-7797", "doc": "python tensor squeeze specific dimension", "code": "def _squeeze(x, axis):\n  \"\"\"A version of squeeze that works with dynamic axis.\"\"\"\n  x = tf.convert_to_tensor(value=x, name='x')\n  if axis is None:\n    return tf.squeeze(x, axis=None)\n  axis = tf.convert_to_tensor(value=axis, name='axis', dtype=tf.int32)\n  axis += tf.zeros([1], dtype=axis.dtype)  # Make axis at least 1d.\n  keep_axis, _ = tf.compat.v1.setdiff1d(tf.range(0, tf.rank(x)), axis)\n  return tf.reshape(x, tf.gather(tf.shape(input=x), keep_axis))", "code_tokens": "def _squeeze ( x , axis ) : x = tf . convert_to_tensor ( value = x , name = 'x' ) if axis is None : return tf . squeeze ( x , axis = None ) axis = tf . convert_to_tensor ( value = axis , name = 'axis' , dtype = tf . int32 ) axis += tf . zeros ( [ 1 ] , dtype = axis . dtype ) # Make axis at least 1d. keep_axis , _ = tf . compat . v1 . setdiff1d ( tf . range ( 0 , tf . rank ( x ) ) , axis ) return tf . reshape ( x , tf . gather ( tf . shape ( input = x ) , keep_axis ) )", "docstring_tokens": "A version of squeeze that works with dynamic axis .", "label": 1}, {"idx": "cosqa-train-7798", "doc": "if status code is 401 what should we do in python", "code": "def _handle_authentication_error(self):\n        \"\"\"\n        Return an authentication error.\n        \"\"\"\n        response = make_response('Access Denied')\n        response.headers['WWW-Authenticate'] = self.auth.get_authenticate_header()\n        response.status_code = 401\n        return response", "code_tokens": "def _handle_authentication_error ( self ) : response = make_response ( 'Access Denied' ) response . headers [ 'WWW-Authenticate' ] = self . auth . get_authenticate_header ( ) response . status_code = 401 return response", "docstring_tokens": "Return an authentication error .", "label": 0}, {"idx": "cosqa-train-7799", "doc": "python tensorflow argmax axis", "code": "def argmax(attrs, inputs, proto_obj):\n    \"\"\"Returns indices of the maximum values along an axis\"\"\"\n    axis = attrs.get('axis', 0)\n    keepdims = attrs.get('keepdims', 1)\n    argmax_op = symbol.argmax(inputs[0], axis=axis, keepdims=keepdims)\n    # onnx argmax operator always expects int64 as output type\n    cast_attrs = {'dtype': 'int64'}\n    return 'cast', cast_attrs, argmax_op", "code_tokens": "def argmax ( attrs , inputs , proto_obj ) : axis = attrs . get ( 'axis' , 0 ) keepdims = attrs . get ( 'keepdims' , 1 ) argmax_op = symbol . argmax ( inputs [ 0 ] , axis = axis , keepdims = keepdims ) # onnx argmax operator always expects int64 as output type cast_attrs = { 'dtype' : 'int64' } return 'cast' , cast_attrs , argmax_op", "docstring_tokens": "Returns indices of the maximum values along an axis", "label": 1}, {"idx": "cosqa-train-7800", "doc": "implementing drag and drop python", "code": "def drag_and_drop(self, droppable):\n        \"\"\"\n        Performs drag a element to another elmenet.\n\n        Currently works only on Chrome driver.\n        \"\"\"\n        self.scroll_to()\n        ActionChains(self.parent.driver).drag_and_drop(self._element, droppable._element).perform()", "code_tokens": "def drag_and_drop ( self , droppable ) : self . scroll_to ( ) ActionChains ( self . parent . driver ) . drag_and_drop ( self . _element , droppable . _element ) . perform ( )", "docstring_tokens": "Performs drag a element to another elmenet .", "label": 1}, {"idx": "cosqa-train-7801", "doc": "python tensorflow estimator get prediction on data", "code": "def predict(self, X):\n        \"\"\"\n        Apply transforms to the data, and predict with the final estimator\n\n        Parameters\n        ----------\n        X : iterable\n            Data to predict on. Must fulfill input requirements of first step\n            of the pipeline.\n\n        Returns\n        -------\n        yp : array-like\n            Predicted transformed target\n        \"\"\"\n        Xt, _, _ = self._transform(X)\n        return self._final_estimator.predict(Xt)", "code_tokens": "def predict ( self , X ) : Xt , _ , _ = self . _transform ( X ) return self . _final_estimator . predict ( Xt )", "docstring_tokens": "Apply transforms to the data and predict with the final estimator", "label": 1}, {"idx": "cosqa-train-7802", "doc": "in python is none the same as empty set", "code": "def uniqify(cls, seq):\n        \"\"\"Returns a unique list of seq\"\"\"\n        seen = set()\n        seen_add = seen.add\n        return [ x for x in seq if x not in seen and not seen_add(x)]", "code_tokens": "def uniqify ( cls , seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if x not in seen and not seen_add ( x ) ]", "docstring_tokens": "Returns a unique list of seq", "label": 0}, {"idx": "cosqa-train-7803", "doc": "python tensorflow list gpus", "code": "def available_gpus():\n  \"\"\"List of GPU device names detected by TensorFlow.\"\"\"\n  local_device_protos = device_lib.list_local_devices()\n  return [x.name for x in local_device_protos if x.device_type == 'GPU']", "code_tokens": "def available_gpus ( ) : local_device_protos = device_lib . list_local_devices ( ) return [ x . name for x in local_device_protos if x . device_type == 'GPU' ]", "docstring_tokens": "List of GPU device names detected by TensorFlow .", "label": 1}, {"idx": "cosqa-train-7804", "doc": "inappropriate ioctl for device python popen", "code": "def _ioctl (self, func, args):\n        \"\"\"Call ioctl() with given parameters.\"\"\"\n        import fcntl\n        return fcntl.ioctl(self.sockfd.fileno(), func, args)", "code_tokens": "def _ioctl ( self , func , args ) : import fcntl return fcntl . ioctl ( self . sockfd . fileno ( ) , func , args )", "docstring_tokens": "Call ioctl () with given parameters .", "label": 0}, {"idx": "cosqa-train-7805", "doc": "python tensorflow unequal dimensions", "code": "def flatten_all_but_last(a):\n  \"\"\"Flatten all dimensions of a except the last.\"\"\"\n  ret = tf.reshape(a, [-1, tf.shape(a)[-1]])\n  if not tf.executing_eagerly():\n    ret.set_shape([None] + a.get_shape().as_list()[-1:])\n  return ret", "code_tokens": "def flatten_all_but_last ( a ) : ret = tf . reshape ( a , [ - 1 , tf . shape ( a ) [ - 1 ] ] ) if not tf . executing_eagerly ( ) : ret . set_shape ( [ None ] + a . get_shape ( ) . as_list ( ) [ - 1 : ] ) return ret", "docstring_tokens": "Flatten all dimensions of a except the last .", "label": 1}, {"idx": "cosqa-train-7806", "doc": "increase rectangle line size python", "code": "def vline(self, x, y, height, color):\n        \"\"\"Draw a vertical line up to a given length.\"\"\"\n        self.rect(x, y, 1, height, color, fill=True)", "code_tokens": "def vline ( self , x , y , height , color ) : self . rect ( x , y , 1 , height , color , fill = True )", "docstring_tokens": "Draw a vertical line up to a given length .", "label": 0}, {"idx": "cosqa-train-7807", "doc": "python test all booleans in list", "code": "def assert_exactly_one_true(bool_list):\n    \"\"\"This method asserts that only one value of the provided list is True.\n\n    :param bool_list: List of booleans to check\n    :return: True if only one value is True, False otherwise\n    \"\"\"\n    assert isinstance(bool_list, list)\n    counter = 0\n    for item in bool_list:\n        if item:\n            counter += 1\n    return counter == 1", "code_tokens": "def assert_exactly_one_true ( bool_list ) : assert isinstance ( bool_list , list ) counter = 0 for item in bool_list : if item : counter += 1 return counter == 1", "docstring_tokens": "This method asserts that only one value of the provided list is True .", "label": 0}, {"idx": "cosqa-train-7808", "doc": "increase width of bar plot in python", "code": "def _change_height(self, ax, new_value):\n        \"\"\"Make bars in horizontal bar chart thinner\"\"\"\n        for patch in ax.patches:\n            current_height = patch.get_height()\n            diff = current_height - new_value\n\n            # we change the bar height\n            patch.set_height(new_value)\n\n            # we recenter the bar\n            patch.set_y(patch.get_y() + diff * .5)", "code_tokens": "def _change_height ( self , ax , new_value ) : for patch in ax . patches : current_height = patch . get_height ( ) diff = current_height - new_value # we change the bar height patch . set_height ( new_value ) # we recenter the bar patch . set_y ( patch . get_y ( ) + diff * .5 )", "docstring_tokens": "Make bars in horizontal bar chart thinner", "label": 0}, {"idx": "cosqa-train-7809", "doc": "python test graph connected components", "code": "def is_closed(self):\n        \"\"\"\n        Are all entities connected to other entities.\n\n        Returns\n        -----------\n        closed : bool\n          Every entity is connected at its ends\n        \"\"\"\n        closed = all(i == 2 for i in\n                     dict(self.vertex_graph.degree()).values())\n\n        return closed", "code_tokens": "def is_closed ( self ) : closed = all ( i == 2 for i in dict ( self . vertex_graph . degree ( ) ) . values ( ) ) return closed", "docstring_tokens": "Are all entities connected to other entities .", "label": 0}, {"idx": "cosqa-train-7810", "doc": "index lines in a file python", "code": "def get_lines(handle, line):\n    \"\"\"\n    Get zero-indexed line from an open file-like.\n    \"\"\"\n    for i, l in enumerate(handle):\n        if i == line:\n            return l", "code_tokens": "def get_lines ( handle , line ) : for i , l in enumerate ( handle ) : if i == line : return l", "docstring_tokens": "Get zero - indexed line from an open file - like .", "label": 0}, {"idx": "cosqa-train-7811", "doc": "python test if a object is iterable", "code": "def is_lazy_iterable(obj):\n    \"\"\"\n    Returns whether *obj* is iterable lazily, such as generators, range objects, etc.\n    \"\"\"\n    return isinstance(obj,\n        (types.GeneratorType, collections.MappingView, six.moves.range, enumerate))", "code_tokens": "def is_lazy_iterable ( obj ) : return isinstance ( obj , ( types . GeneratorType , collections . MappingView , six . moves . range , enumerate ) )", "docstring_tokens": "Returns whether * obj * is iterable lazily such as generators range objects etc .", "label": 0}, {"idx": "cosqa-train-7812", "doc": "index number in a series python", "code": "def series_index(self, series):\n        \"\"\"\n        Return the integer index of *series* in this sequence.\n        \"\"\"\n        for idx, s in enumerate(self):\n            if series is s:\n                return idx\n        raise ValueError('series not in chart data object')", "code_tokens": "def series_index ( self , series ) : for idx , s in enumerate ( self ) : if series is s : return idx raise ValueError ( 'series not in chart data object' )", "docstring_tokens": "Return the integer index of * series * in this sequence .", "label": 1}, {"idx": "cosqa-train-7813", "doc": "python test if file in folder", "code": "def contained_in(filename, directory):\n    \"\"\"Test if a file is located within the given directory.\"\"\"\n    filename = os.path.normcase(os.path.abspath(filename))\n    directory = os.path.normcase(os.path.abspath(directory))\n    return os.path.commonprefix([filename, directory]) == directory", "code_tokens": "def contained_in ( filename , directory ) : filename = os . path . normcase ( os . path . abspath ( filename ) ) directory = os . path . normcase ( os . path . abspath ( directory ) ) return os . path . commonprefix ( [ filename , directory ] ) == directory", "docstring_tokens": "Test if a file is located within the given directory .", "label": 1}, {"idx": "cosqa-train-7814", "doc": "index of an element in list python", "code": "def binSearch(arr, val):\n  \"\"\" \n  Function for running binary search on a sorted list.\n\n  :param arr: (list) a sorted list of integers to search\n  :param val: (int)  a integer to search for in the sorted array\n  :returns: (int) the index of the element if it is found and -1 otherwise.\n  \"\"\"\n  i = bisect_left(arr, val)\n  if i != len(arr) and arr[i] == val:\n    return i\n  return -1", "code_tokens": "def binSearch ( arr , val ) : i = bisect_left ( arr , val ) if i != len ( arr ) and arr [ i ] == val : return i return - 1", "docstring_tokens": "Function for running binary search on a sorted list .", "label": 0}, {"idx": "cosqa-train-7815", "doc": "python test if object has method", "code": "def is_function(self):\n        \"\"\"return True if callback is a vanilla plain jane function\"\"\"\n        if self.is_instance() or self.is_class(): return False\n        return isinstance(self.callback, (Callable, classmethod))", "code_tokens": "def is_function ( self ) : if self . is_instance ( ) or self . is_class ( ) : return False return isinstance ( self . callback , ( Callable , classmethod ) )", "docstring_tokens": "return True if callback is a vanilla plain jane function", "label": 0}, {"idx": "cosqa-train-7816", "doc": "index of an entry in a list python", "code": "def is_in(self, search_list, pair):\n        \"\"\"\n        If pair is in search_list, return the index. Otherwise return -1\n        \"\"\"\n        index = -1\n        for nr, i in enumerate(search_list):\n            if(np.all(i == pair)):\n                return nr\n        return index", "code_tokens": "def is_in ( self , search_list , pair ) : index = - 1 for nr , i in enumerate ( search_list ) : if ( np . all ( i == pair ) ) : return nr return index", "docstring_tokens": "If pair is in search_list return the index . Otherwise return - 1", "label": 1}, {"idx": "cosqa-train-7817", "doc": "python test if stdin", "code": "def stdin_readable():\n    \"\"\"Determine whether stdin has any data to read.\"\"\"\n    if not WINDOWS:\n        try:\n            return bool(select([sys.stdin], [], [], 0)[0])\n        except Exception:\n            logger.log_exc()\n    try:\n        return not sys.stdin.isatty()\n    except Exception:\n        logger.log_exc()\n    return False", "code_tokens": "def stdin_readable ( ) : if not WINDOWS : try : return bool ( select ( [ sys . stdin ] , [ ] , [ ] , 0 ) [ 0 ] ) except Exception : logger . log_exc ( ) try : return not sys . stdin . isatty ( ) except Exception : logger . log_exc ( ) return False", "docstring_tokens": "Determine whether stdin has any data to read .", "label": 0}, {"idx": "cosqa-train-7818", "doc": "index value of cell python", "code": "def get_cell(self, index):\n        \"\"\"\n        For a single index and return the value\n\n        :param index: index value\n        :return: value\n        \"\"\"\n        i = sorted_index(self._index, index) if self._sort else self._index.index(index)\n        return self._data[i]", "code_tokens": "def get_cell ( self , index ) : i = sorted_index ( self . _index , index ) if self . _sort else self . _index . index ( index ) return self . _data [ i ]", "docstring_tokens": "For a single index and return the value", "label": 1}, {"idx": "cosqa-train-7819", "doc": "python testing if an xml node is empty", "code": "def is_empty(self):\n        \"\"\"Returns True if the root node contains no child elements, no text,\n        and no attributes other than **type**. Returns False if any are present.\"\"\"\n        non_type_attributes = [attr for attr in self.node.attrib.keys() if attr != 'type']\n        return len(self.node) == 0 and len(non_type_attributes) == 0 \\\n            and not self.node.text and not self.node.tail", "code_tokens": "def is_empty ( self ) : non_type_attributes = [ attr for attr in self . node . attrib . keys ( ) if attr != 'type' ] return len ( self . node ) == 0 and len ( non_type_attributes ) == 0 and not self . node . text and not self . node . tail", "docstring_tokens": "Returns True if the root node contains no child elements no text and no attributes other than ** type ** . Returns False if any are present .", "label": 0}, {"idx": "cosqa-train-7820", "doc": "init a python list of certain size", "code": "def __init__(self, capacity=10):\n        \"\"\"\n        Initialize python List with capacity of 10 or user given input.\n        Python List type is a dynamic array, so we have to restrict its\n        dynamic nature to make it work like a static array.\n        \"\"\"\n        super().__init__()\n        self._array = [None] * capacity\n        self._front = 0\n        self._rear = 0", "code_tokens": "def __init__ ( self , capacity = 10 ) : super ( ) . __init__ ( ) self . _array = [ None ] * capacity self . _front = 0 self . _rear = 0", "docstring_tokens": "Initialize python List with capacity of 10 or user given input . Python List type is a dynamic array so we have to restrict its dynamic nature to make it work like a static array .", "label": 1}, {"idx": "cosqa-train-7821", "doc": "python threading exit handler", "code": "def __exit__(self, *exc_info):\n        \"\"\"Close connection to NATS when used in a context manager\"\"\"\n\n        self._loop.create_task(self._close(Client.CLOSED, True))", "code_tokens": "def __exit__ ( self , * exc_info ) : self . _loop . create_task ( self . _close ( Client . CLOSED , True ) )", "docstring_tokens": "Close connection to NATS when used in a context manager", "label": 0}, {"idx": "cosqa-train-7822", "doc": "inputting time as hours and minutes in python", "code": "def pprint(self, seconds):\n        \"\"\"\n        Pretty Prints seconds as Hours:Minutes:Seconds.MilliSeconds\n\n        :param seconds:  The time in seconds.\n        \"\"\"\n        return (\"%d:%02d:%02d.%03d\", reduce(lambda ll, b: divmod(ll[0], b) + ll[1:], [(seconds * 1000,), 1000, 60, 60]))", "code_tokens": "def pprint ( self , seconds ) : return ( \"%d:%02d:%02d.%03d\" , reduce ( lambda ll , b : divmod ( ll [ 0 ] , b ) + ll [ 1 : ] , [ ( seconds * 1000 , ) , 1000 , 60 , 60 ] ) )", "docstring_tokens": "Pretty Prints seconds as Hours : Minutes : Seconds . MilliSeconds", "label": 0}, {"idx": "cosqa-train-7823", "doc": "python three labels matthews correlation coefficient", "code": "def mcc(y, z):\n    \"\"\"Matthews correlation coefficient\n    \"\"\"\n    tp, tn, fp, fn = contingency_table(y, z)\n    return (tp * tn - fp * fn) / K.sqrt((tp + fp) * (tp + fn) * (tn + fp) * (tn + fn))", "code_tokens": "def mcc ( y , z ) : tp , tn , fp , fn = contingency_table ( y , z ) return ( tp * tn - fp * fn ) / K . sqrt ( ( tp + fp ) * ( tp + fn ) * ( tn + fp ) * ( tn + fn ) )", "docstring_tokens": "Matthews correlation coefficient", "label": 1}, {"idx": "cosqa-train-7824", "doc": "int to strin python", "code": "def int2str(num, radix=10, alphabet=BASE85):\n    \"\"\"helper function for quick base conversions from integers to strings\"\"\"\n    return NumConv(radix, alphabet).int2str(num)", "code_tokens": "def int2str ( num , radix = 10 , alphabet = BASE85 ) : return NumConv ( radix , alphabet ) . int2str ( num )", "docstring_tokens": "helper function for quick base conversions from integers to strings", "label": 0}, {"idx": "cosqa-train-7825", "doc": "python time from hour to minute", "code": "def time2seconds(t):\n    \"\"\"Returns seconds since 0h00.\"\"\"\n    return t.hour * 3600 + t.minute * 60 + t.second + float(t.microsecond) / 1e6", "code_tokens": "def time2seconds ( t ) : return t . hour * 3600 + t . minute * 60 + t . second + float ( t . microsecond ) / 1e6", "docstring_tokens": "Returns seconds since 0h00 .", "label": 0}, {"idx": "cosqa-train-7826", "doc": "integer boolen iterable in python", "code": "def is_iterable_of_int(l):\n    r\"\"\" Checks if l is iterable and contains only integral types \"\"\"\n    if not is_iterable(l):\n        return False\n\n    return all(is_int(value) for value in l)", "code_tokens": "def is_iterable_of_int ( l ) : if not is_iterable ( l ) : return False return all ( is_int ( value ) for value in l )", "docstring_tokens": "r Checks if l is iterable and contains only integral types", "label": 0}, {"idx": "cosqa-train-7827", "doc": "python time is between start end", "code": "def timespan(start_time):\n    \"\"\"Return time in milliseconds from start_time\"\"\"\n\n    timespan = datetime.datetime.now() - start_time\n    timespan_ms = timespan.total_seconds() * 1000\n    return timespan_ms", "code_tokens": "def timespan ( start_time ) : timespan = datetime . datetime . now ( ) - start_time timespan_ms = timespan . total_seconds ( ) * 1000 return timespan_ms", "docstring_tokens": "Return time in milliseconds from start_time", "label": 1}, {"idx": "cosqa-train-7828", "doc": "integrer to bytes python", "code": "def Binary(x):\n    \"\"\"Return x as a binary type.\"\"\"\n    if isinstance(x, text_type) and not (JYTHON or IRONPYTHON):\n        return x.encode()\n    return bytes(x)", "code_tokens": "def Binary ( x ) : if isinstance ( x , text_type ) and not ( JYTHON or IRONPYTHON ) : return x . encode ( ) return bytes ( x )", "docstring_tokens": "Return x as a binary type .", "label": 0}, {"idx": "cosqa-train-7829", "doc": "python timestamp type to datetime type", "code": "def dt_to_ts(value):\n    \"\"\" If value is a datetime, convert to timestamp \"\"\"\n    if not isinstance(value, datetime):\n        return value\n    return calendar.timegm(value.utctimetuple()) + value.microsecond / 1000000.0", "code_tokens": "def dt_to_ts ( value ) : if not isinstance ( value , datetime ) : return value return calendar . timegm ( value . utctimetuple ( ) ) + value . microsecond / 1000000.0", "docstring_tokens": "If value is a datetime convert to timestamp", "label": 1}, {"idx": "cosqa-train-7830", "doc": "interpolate python last value", "code": "def value(self, progress_indicator):\n        \"\"\" Interpolate linearly between start and end \"\"\"\n        return interpolate.interpolate_linear_single(self.initial_value, self.final_value, progress_indicator)", "code_tokens": "def value ( self , progress_indicator ) : return interpolate . interpolate_linear_single ( self . initial_value , self . final_value , progress_indicator )", "docstring_tokens": "Interpolate linearly between start and end", "label": 0}, {"idx": "cosqa-train-7831", "doc": "python tinker move focus to next widget", "code": "def focusNext(self, event):\n        \"\"\"Set focus to next item in sequence\"\"\"\n        try:\n            event.widget.tk_focusNext().focus_set()\n        except TypeError:\n            # see tkinter equivalent code for tk_focusNext to see\n            # commented original version\n            name = event.widget.tk.call('tk_focusNext', event.widget._w)\n            event.widget._nametowidget(str(name)).focus_set()", "code_tokens": "def focusNext ( self , event ) : try : event . widget . tk_focusNext ( ) . focus_set ( ) except TypeError : # see tkinter equivalent code for tk_focusNext to see # commented original version name = event . widget . tk . call ( 'tk_focusNext' , event . widget . _w ) event . widget . _nametowidget ( str ( name ) ) . focus_set ( )", "docstring_tokens": "Set focus to next item in sequence", "label": 1}, {"idx": "cosqa-train-7832", "doc": "iron python delete object from memory", "code": "def removeFromRegistery(obj) :\n\t\"\"\"Removes an object/rabalist from registery. This is useful if you want to allow the garbage collector to free the memory\n\ttaken by the objects you've already loaded. Be careful might cause some discrepenties in your scripts. For objects,\n\tcascades to free the registeries of related rabalists also\"\"\"\n\t\n\tif isRabaObject(obj) :\n\t\t_unregisterRabaObjectInstance(obj)\n\telif isRabaList(obj) :\n\t\t_unregisterRabaListInstance(obj)", "code_tokens": "def removeFromRegistery ( obj ) : if isRabaObject ( obj ) : _unregisterRabaObjectInstance ( obj ) elif isRabaList ( obj ) : _unregisterRabaListInstance ( obj )", "docstring_tokens": "Removes an object / rabalist from registery . This is useful if you want to allow the garbage collector to free the memory taken by the objects you ve already loaded . Be careful might cause some discrepenties in your scripts . For objects cascades to free the registeries of related rabalists also", "label": 0}, {"idx": "cosqa-train-7833", "doc": "python tkinter canvas scroll bars", "code": "def _set_scroll_v(self, *args):\n        \"\"\"Scroll both categories Canvas and scrolling container\"\"\"\n        self._canvas_categories.yview(*args)\n        self._canvas_scroll.yview(*args)", "code_tokens": "def _set_scroll_v ( self , * args ) : self . _canvas_categories . yview ( * args ) self . _canvas_scroll . yview ( * args )", "docstring_tokens": "Scroll both categories Canvas and scrolling container", "label": 0}, {"idx": "cosqa-train-7834", "doc": "ironpython not calling garbage collection", "code": "def removeFromRegistery(obj) :\n\t\"\"\"Removes an object/rabalist from registery. This is useful if you want to allow the garbage collector to free the memory\n\ttaken by the objects you've already loaded. Be careful might cause some discrepenties in your scripts. For objects,\n\tcascades to free the registeries of related rabalists also\"\"\"\n\t\n\tif isRabaObject(obj) :\n\t\t_unregisterRabaObjectInstance(obj)\n\telif isRabaList(obj) :\n\t\t_unregisterRabaListInstance(obj)", "code_tokens": "def removeFromRegistery ( obj ) : if isRabaObject ( obj ) : _unregisterRabaObjectInstance ( obj ) elif isRabaList ( obj ) : _unregisterRabaListInstance ( obj )", "docstring_tokens": "Removes an object / rabalist from registery . This is useful if you want to allow the garbage collector to free the memory taken by the objects you ve already loaded . Be careful might cause some discrepenties in your scripts . For objects cascades to free the registeries of related rabalists also", "label": 1}, {"idx": "cosqa-train-7835", "doc": "python tkinter combobox all values", "code": "def get_all_items(self):\n        \"\"\"\n        Returns all items in the combobox dictionary.\n        \"\"\"\n        return [self._widget.itemText(k) for k in range(self._widget.count())]", "code_tokens": "def get_all_items ( self ) : return [ self . _widget . itemText ( k ) for k in range ( self . _widget . count ( ) ) ]", "docstring_tokens": "Returns all items in the combobox dictionary .", "label": 0}, {"idx": "cosqa-train-7836", "doc": "python tkinter get window width", "code": "def get_size(self):\n        \"\"\"see doc in Term class\"\"\"\n        self.curses.setupterm()\n        return self.curses.tigetnum('cols'), self.curses.tigetnum('lines')", "code_tokens": "def get_size ( self ) : self . curses . setupterm ( ) return self . curses . tigetnum ( 'cols' ) , self . curses . tigetnum ( 'lines' )", "docstring_tokens": "see doc in Term class", "label": 1}, {"idx": "cosqa-train-7837", "doc": "is node defined in python", "code": "def find_if_expression_as_statement(node):\n    \"\"\"Finds an \"if\" expression as a statement\"\"\"\n    return (\n        isinstance(node, ast.Expr)\n        and isinstance(node.value, ast.IfExp)\n    )", "code_tokens": "def find_if_expression_as_statement ( node ) : return ( isinstance ( node , ast . Expr ) and isinstance ( node . value , ast . IfExp ) )", "docstring_tokens": "Finds an if expression as a statement", "label": 1}, {"idx": "cosqa-train-7838", "doc": "python tkinter gui closes immediately", "code": "def closing_plugin(self, cancelable=False):\n        \"\"\"Perform actions before parent main window is closed\"\"\"\n        self.dialog_manager.close_all()\n        self.shell.exit_interpreter()\n        return True", "code_tokens": "def closing_plugin ( self , cancelable = False ) : self . dialog_manager . close_all ( ) self . shell . exit_interpreter ( ) return True", "docstring_tokens": "Perform actions before parent main window is closed", "label": 1}, {"idx": "cosqa-train-7839", "doc": "is python block scoped or function scoped", "code": "def nonlocal_check(self, original, loc, tokens):\n        \"\"\"Check for Python 3 nonlocal statement.\"\"\"\n        return self.check_py(\"3\", \"nonlocal statement\", original, loc, tokens)", "code_tokens": "def nonlocal_check ( self , original , loc , tokens ) : return self . check_py ( \"3\" , \"nonlocal statement\" , original , loc , tokens )", "docstring_tokens": "Check for Python 3 nonlocal statement .", "label": 1}, {"idx": "cosqa-train-7840", "doc": "python tkinter how to size a scrollbar", "code": "def __grid_widgets(self):\n        \"\"\"Places all the child widgets in the appropriate positions.\"\"\"\n        scrollbar_column = 0 if self.__compound is tk.LEFT else 2\n        self._canvas.grid(row=0, column=1, sticky=\"nswe\")\n        self._scrollbar.grid(row=0, column=scrollbar_column, sticky=\"ns\")", "code_tokens": "def __grid_widgets ( self ) : scrollbar_column = 0 if self . __compound is tk . LEFT else 2 self . _canvas . grid ( row = 0 , column = 1 , sticky = \"nswe\" ) self . _scrollbar . grid ( row = 0 , column = scrollbar_column , sticky = \"ns\" )", "docstring_tokens": "Places all the child widgets in the appropriate positions .", "label": 1}, {"idx": "cosqa-train-7841", "doc": "is python ssl socket connection thread safe", "code": "def enable_ssl(self, *args, **kwargs):\n        \"\"\"\n        Transforms the regular socket.socket to an ssl.SSLSocket for secure\n        connections. Any arguments are passed to ssl.wrap_socket:\n        http://docs.python.org/dev/library/ssl.html#ssl.wrap_socket\n        \"\"\"\n        if self.handshake_sent:\n            raise SSLError('can only enable SSL before handshake')\n\n        self.secure = True\n        self.sock = ssl.wrap_socket(self.sock, *args, **kwargs)", "code_tokens": "def enable_ssl ( self , * args , * * kwargs ) : if self . handshake_sent : raise SSLError ( 'can only enable SSL before handshake' ) self . secure = True self . sock = ssl . wrap_socket ( self . sock , * args , * * kwargs )", "docstring_tokens": "Transforms the regular socket . socket to an ssl . SSLSocket for secure connections . Any arguments are passed to ssl . wrap_socket : http : // docs . python . org / dev / library / ssl . html#ssl . wrap_socket", "label": 1}, {"idx": "cosqa-train-7842", "doc": "python tkinter paned scrollbar", "code": "def restore_scrollbar_position(self):\n        \"\"\"Restoring scrollbar position after main window is visible\"\"\"\n        scrollbar_pos = self.get_option('scrollbar_position', None)\n        if scrollbar_pos is not None:\n            self.explorer.treewidget.set_scrollbar_position(scrollbar_pos)", "code_tokens": "def restore_scrollbar_position ( self ) : scrollbar_pos = self . get_option ( 'scrollbar_position' , None ) if scrollbar_pos is not None : self . explorer . treewidget . set_scrollbar_position ( scrollbar_pos )", "docstring_tokens": "Restoring scrollbar position after main window is visible", "label": 0}, {"idx": "cosqa-train-7843", "doc": "is true a singleton in python", "code": "def singleton(class_):\n    \"\"\"Singleton definition.\n\n    Method 1 from\n    https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python\n    \"\"\"\n    instances = {}\n\n    def get_instance(*args, **kwargs):\n        if class_ not in instances:\n            instances[class_] = class_(*args, **kwargs)\n        return instances[class_]\n    return get_instance", "code_tokens": "def singleton ( class_ ) : instances = { } def get_instance ( * args , * * kwargs ) : if class_ not in instances : instances [ class_ ] = class_ ( * args , * * kwargs ) return instances [ class_ ] return get_instance", "docstring_tokens": "Singleton definition .", "label": 0}, {"idx": "cosqa-train-7844", "doc": "python tkinter unchecking checkbutton change variable", "code": "def checkbox_uncheck(self, force_check=False):\n        \"\"\"\n        Wrapper to uncheck a checkbox\n        \"\"\"\n        if self.get_attribute('checked'):\n            self.click(force_click=force_check)", "code_tokens": "def checkbox_uncheck ( self , force_check = False ) : if self . get_attribute ( 'checked' ) : self . click ( force_click = force_check )", "docstring_tokens": "Wrapper to uncheck a checkbox", "label": 1}, {"idx": "cosqa-train-7845", "doc": "iterate json file pythong", "code": "def json_iter (path):\n    \"\"\"\n    iterator for JSON-per-line in a file pattern\n    \"\"\"\n    with open(path, 'r') as f:\n        for line in f.readlines():\n            yield json.loads(line)", "code_tokens": "def json_iter ( path ) : with open ( path , 'r' ) as f : for line in f . readlines ( ) : yield json . loads ( line )", "docstring_tokens": "iterator for JSON - per - line in a file pattern", "label": 1}, {"idx": "cosqa-train-7846", "doc": "python to add random noise", "code": "def add_noise(Y, sigma):\n    \"\"\"Adds noise to Y\"\"\"\n    return Y + np.random.normal(0, sigma, Y.shape)", "code_tokens": "def add_noise ( Y , sigma ) : return Y + np . random . normal ( 0 , sigma , Y . shape )", "docstring_tokens": "Adds noise to Y", "label": 0}, {"idx": "cosqa-train-7847", "doc": "iterate over the sorted keys of a dict in python", "code": "def _dict_values_sorted_by_key(dictionary):\n    # This should be a yield from instead.\n    \"\"\"Internal helper to return the values of a dictionary, sorted by key.\n    \"\"\"\n    for _, value in sorted(dictionary.iteritems(), key=operator.itemgetter(0)):\n        yield value", "code_tokens": "def _dict_values_sorted_by_key ( dictionary ) : # This should be a yield from instead. for _ , value in sorted ( dictionary . iteritems ( ) , key = operator . itemgetter ( 0 ) ) : yield value", "docstring_tokens": "Internal helper to return the values of a dictionary sorted by key .", "label": 1}, {"idx": "cosqa-train-7848", "doc": "python to calculate max min median", "code": "def getMedian(numericValues):\n    \"\"\"\n    Gets the median of a list of values\n    Returns a float/int\n    \"\"\"\n    theValues = sorted(numericValues)\n\n    if len(theValues) % 2 == 1:\n        return theValues[(len(theValues) + 1) / 2 - 1]\n    else:\n        lower = theValues[len(theValues) / 2 - 1]\n        upper = theValues[len(theValues) / 2]\n\n        return (float(lower + upper)) / 2", "code_tokens": "def getMedian ( numericValues ) : theValues = sorted ( numericValues ) if len ( theValues ) % 2 == 1 : return theValues [ ( len ( theValues ) + 1 ) / 2 - 1 ] else : lower = theValues [ len ( theValues ) / 2 - 1 ] upper = theValues [ len ( theValues ) / 2 ] return ( float ( lower + upper ) ) / 2", "docstring_tokens": "Gets the median of a list of values Returns a float / int", "label": 1}, {"idx": "cosqa-train-7849", "doc": "jar is for java and what python has", "code": "def add_bundled_jars():\n    \"\"\"\n    Adds the bundled jars to the JVM's classpath.\n    \"\"\"\n    # determine lib directory with jars\n    rootdir = os.path.split(os.path.dirname(__file__))[0]\n    libdir = rootdir + os.sep + \"lib\"\n\n    # add jars from lib directory\n    for l in glob.glob(libdir + os.sep + \"*.jar\"):\n        if l.lower().find(\"-src.\") == -1:\n            javabridge.JARS.append(str(l))", "code_tokens": "def add_bundled_jars ( ) : # determine lib directory with jars rootdir = os . path . split ( os . path . dirname ( __file__ ) ) [ 0 ] libdir = rootdir + os . sep + \"lib\" # add jars from lib directory for l in glob . glob ( libdir + os . sep + \"*.jar\" ) : if l . lower ( ) . find ( \"-src.\" ) == - 1 : javabridge . JARS . append ( str ( l ) )", "docstring_tokens": "Adds the bundled jars to the JVM s classpath .", "label": 0}, {"idx": "cosqa-train-7850", "doc": "python to lat and long", "code": "def xyz2lonlat(x, y, z):\n    \"\"\"Convert cartesian to lon lat.\"\"\"\n    lon = xu.rad2deg(xu.arctan2(y, x))\n    lat = xu.rad2deg(xu.arctan2(z, xu.sqrt(x**2 + y**2)))\n    return lon, lat", "code_tokens": "def xyz2lonlat ( x , y , z ) : lon = xu . rad2deg ( xu . arctan2 ( y , x ) ) lat = xu . rad2deg ( xu . arctan2 ( z , xu . sqrt ( x ** 2 + y ** 2 ) ) ) return lon , lat", "docstring_tokens": "Convert cartesian to lon lat .", "label": 1}, {"idx": "cosqa-train-7851", "doc": "java inputstreamreader python equivalent", "code": "def get_iter_string_reader(stdin):\n    \"\"\" return an iterator that returns a chunk of a string every time it is\n    called.  notice that even though bufsize_type might be line buffered, we're\n    not doing any line buffering here.  that's because our StreamBufferer\n    handles all buffering.  we just need to return a reasonable-sized chunk. \"\"\"\n    bufsize = 1024\n    iter_str = (stdin[i:i + bufsize] for i in range(0, len(stdin), bufsize))\n    return get_iter_chunk_reader(iter_str)", "code_tokens": "def get_iter_string_reader ( stdin ) : bufsize = 1024 iter_str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get_iter_chunk_reader ( iter_str )", "docstring_tokens": "return an iterator that returns a chunk of a string every time it is called . notice that even though bufsize_type might be line buffered we re not doing any line buffering here . that s because our StreamBufferer handles all buffering . we just need to return a reasonable - sized chunk .", "label": 1}, {"idx": "cosqa-train-7852", "doc": "python to scala converter", "code": "def get_python_dict(scala_map):\n    \"\"\"Return a dict from entries in a scala.collection.immutable.Map\"\"\"\n    python_dict = {}\n    keys = get_python_list(scala_map.keys().toList())\n    for key in keys:\n        python_dict[key] = scala_map.apply(key)\n    return python_dict", "code_tokens": "def get_python_dict ( scala_map ) : python_dict = { } keys = get_python_list ( scala_map . keys ( ) . toList ( ) ) for key in keys : python_dict [ key ] = scala_map . apply ( key ) return python_dict", "docstring_tokens": "Return a dict from entries in a scala . collection . immutable . Map", "label": 0}, {"idx": "cosqa-train-7853", "doc": "jpupyter taking input to a python code", "code": "def jupytext_cli(args=None):\n    \"\"\"Entry point for the jupytext script\"\"\"\n    try:\n        jupytext(args)\n    except (ValueError, TypeError, IOError) as err:\n        sys.stderr.write('[jupytext] Error: ' + str(err) + '\\n')\n        exit(1)", "code_tokens": "def jupytext_cli ( args = None ) : try : jupytext ( args ) except ( ValueError , TypeError , IOError ) as err : sys . stderr . write ( '[jupytext] Error: ' + str ( err ) + '\\n' ) exit ( 1 )", "docstring_tokens": "Entry point for the jupytext script", "label": 0}, {"idx": "cosqa-train-7854", "doc": "python tornado detect user agent", "code": "def _get_user_agent(self):\n        \"\"\"Retrieve the request's User-Agent, if available.\n\n        Taken from Flask Login utils.py.\n        \"\"\"\n        user_agent = request.headers.get('User-Agent')\n        if user_agent:\n            user_agent = user_agent.encode('utf-8')\n        return user_agent or ''", "code_tokens": "def _get_user_agent ( self ) : user_agent = request . headers . get ( 'User-Agent' ) if user_agent : user_agent = user_agent . encode ( 'utf-8' ) return user_agent or ''", "docstring_tokens": "Retrieve the request s User - Agent if available .", "label": 1}, {"idx": "cosqa-train-7855", "doc": "json loads python encoding", "code": "def load_jsonf(fpath, encoding):\n    \"\"\"\n    :param unicode fpath:\n    :param unicode encoding:\n    :rtype: dict | list\n    \"\"\"\n    with codecs.open(fpath, encoding=encoding) as f:\n        return json.load(f)", "code_tokens": "def load_jsonf ( fpath , encoding ) : with codecs . open ( fpath , encoding = encoding ) as f : return json . load ( f )", "docstring_tokens": ": param unicode fpath : : param unicode encoding : : rtype : dict | list", "label": 0}, {"idx": "cosqa-train-7856", "doc": "python trace execution ath", "code": "def __run(self):\n    \"\"\"Hacked run function, which installs the trace.\"\"\"\n    sys.settrace(self.globaltrace)\n    self.__run_backup()\n    self.run = self.__run_backup", "code_tokens": "def __run ( self ) : sys . settrace ( self . globaltrace ) self . __run_backup ( ) self . run = self . __run_backup", "docstring_tokens": "Hacked run function which installs the trace .", "label": 0}, {"idx": "cosqa-train-7857", "doc": "json to protobuf python", "code": "def toJson(protoObject, indent=None):\n    \"\"\"\n    Serialises a protobuf object as json\n    \"\"\"\n    # Using the internal method because this way we can reformat the JSON\n    js = json_format.MessageToDict(protoObject, False)\n    return json.dumps(js, indent=indent)", "code_tokens": "def toJson ( protoObject , indent = None ) : # Using the internal method because this way we can reformat the JSON js = json_format . MessageToDict ( protoObject , False ) return json . dumps ( js , indent = indent )", "docstring_tokens": "Serialises a protobuf object as json", "label": 1}, {"idx": "cosqa-train-7858", "doc": "python track time it takes to run function", "code": "def timed_call(func, *args, log_level='DEBUG', **kwargs):\n    \"\"\"Logs a function's run time\n\n    :param func: The function to run\n    :param args: The args to pass to the function\n    :param kwargs: The keyword args to pass to the function\n    :param log_level: The log level at which to print the run time\n    :return: The function's return value\n    \"\"\"\n    start = time()\n    r = func(*args, **kwargs)\n    t = time() - start\n    log(log_level, \"Call to '{}' took {:0.6f}s\".format(func.__name__, t))\n    return r", "code_tokens": "def timed_call ( func , * args , log_level = 'DEBUG' , * * kwargs ) : start = time ( ) r = func ( * args , * * kwargs ) t = time ( ) - start log ( log_level , \"Call to '{}' took {:0.6f}s\" . format ( func . __name__ , t ) ) return r", "docstring_tokens": "Logs a function s run time", "label": 1}, {"idx": "cosqa-train-7859", "doc": "judge if the last iterator python", "code": "def iter_with_last(iterable):\n    \"\"\"\n    :return: generator of tuples (isLastFlag, item)\n    \"\"\"\n    # Ensure it's an iterator and get the first field\n    iterable = iter(iterable)\n    prev = next(iterable)\n    for item in iterable:\n        # Lag by one item so I know I'm not at the end\n        yield False, prev\n        prev = item\n    # Last item\n    yield True, prev", "code_tokens": "def iter_with_last ( iterable ) : # Ensure it's an iterator and get the first field iterable = iter ( iterable ) prev = next ( iterable ) for item in iterable : # Lag by one item so I know I'm not at the end yield False , prev prev = item # Last item yield True , prev", "docstring_tokens": ": return : generator of tuples ( isLastFlag item )", "label": 1}, {"idx": "cosqa-train-7860", "doc": "python tree pretty print", "code": "def pprint(self, ind):\n        \"\"\"pretty prints the tree with indentation\"\"\"\n        pp = pprint.PrettyPrinter(indent=ind)\n        pp.pprint(self.tree)", "code_tokens": "def pprint ( self , ind ) : pp = pprint . PrettyPrinter ( indent = ind ) pp . pprint ( self . tree )", "docstring_tokens": "pretty prints the tree with indentation", "label": 0}, {"idx": "cosqa-train-7861", "doc": "judge if the python value type is numeric", "code": "def is_numeric(value):\n        \"\"\"Test if a value is numeric.\n        \"\"\"\n        return type(value) in [\n            int,\n            float,\n            \n            np.int8,\n            np.int16,\n            np.int32,\n            np.int64,\n\n            np.float16,\n            np.float32,\n            np.float64,\n            np.float128\n        ]", "code_tokens": "def is_numeric ( value ) : return type ( value ) in [ int , float , np . int8 , np . int16 , np . int32 , np . int64 , np . float16 , np . float32 , np . float64 , np . float128 ]", "docstring_tokens": "Test if a value is numeric .", "label": 1}, {"idx": "cosqa-train-7862", "doc": "python trim characters for left side of string", "code": "def _trim(self, somestr):\n        \"\"\" Trim left-right given string \"\"\"\n        tmp = RE_LSPACES.sub(\"\", somestr)\n        tmp = RE_TSPACES.sub(\"\", tmp)\n        return str(tmp)", "code_tokens": "def _trim ( self , somestr ) : tmp = RE_LSPACES . sub ( \"\" , somestr ) tmp = RE_TSPACES . sub ( \"\" , tmp ) return str ( tmp )", "docstring_tokens": "Trim left - right given string", "label": 0}, {"idx": "cosqa-train-7863", "doc": "keep the ' in the sentence python", "code": "def _make_sentence(txt):\n    \"\"\"Make a sentence from a piece of text.\"\"\"\n    #Make sure first letter is capitalized\n    txt = txt.strip(' ')\n    txt = txt[0].upper() + txt[1:] + '.'\n    return txt", "code_tokens": "def _make_sentence ( txt ) : #Make sure first letter is capitalized txt = txt . strip ( ' ' ) txt = txt [ 0 ] . upper ( ) + txt [ 1 : ] + '.' return txt", "docstring_tokens": "Make a sentence from a piece of text .", "label": 1}, {"idx": "cosqa-train-7864", "doc": "python trim string from right of string", "code": "def _trim(self, somestr):\n        \"\"\" Trim left-right given string \"\"\"\n        tmp = RE_LSPACES.sub(\"\", somestr)\n        tmp = RE_TSPACES.sub(\"\", tmp)\n        return str(tmp)", "code_tokens": "def _trim ( self , somestr ) : tmp = RE_LSPACES . sub ( \"\" , somestr ) tmp = RE_TSPACES . sub ( \"\" , tmp ) return str ( tmp )", "docstring_tokens": "Trim left - right given string", "label": 0}, {"idx": "cosqa-train-7865", "doc": "keep the order of keys in a dictionary in python", "code": "def unique_list_dicts(dlist, key):\n    \"\"\"Return a list of dictionaries which are sorted for only unique entries.\n\n    :param dlist:\n    :param key:\n    :return list:\n    \"\"\"\n\n    return list(dict((val[key], val) for val in dlist).values())", "code_tokens": "def unique_list_dicts ( dlist , key ) : return list ( dict ( ( val [ key ] , val ) for val in dlist ) . values ( ) )", "docstring_tokens": "Return a list of dictionaries which are sorted for only unique entries .", "label": 1}, {"idx": "cosqa-train-7866", "doc": "python trim whitespace at the end of the line", "code": "def clean(s):\n  \"\"\"Removes trailing whitespace on each line.\"\"\"\n  lines = [l.rstrip() for l in s.split('\\n')]\n  return '\\n'.join(lines)", "code_tokens": "def clean ( s ) : lines = [ l . rstrip ( ) for l in s . split ( '\\n' ) ] return '\\n' . join ( lines )", "docstring_tokens": "Removes trailing whitespace on each line .", "label": 1}, {"idx": "cosqa-train-7867", "doc": "keyboard binding function python", "code": "def keyPressEvent(self, event):\n        \"\"\"\n        Pyqt specific key press callback function.\n        Translates and forwards events to :py:func:`keyboard_event`.\n        \"\"\"\n        self.keyboard_event(event.key(), self.keys.ACTION_PRESS, 0)", "code_tokens": "def keyPressEvent ( self , event ) : self . keyboard_event ( event . key ( ) , self . keys . ACTION_PRESS , 0 )", "docstring_tokens": "Pyqt specific key press callback function . Translates and forwards events to : py : func : keyboard_event .", "label": 1}, {"idx": "cosqa-train-7868", "doc": "python try catch 3 times", "code": "def retry_call(func, cleanup=lambda: None, retries=0, trap=()):\n\t\"\"\"\n\tGiven a callable func, trap the indicated exceptions\n\tfor up to 'retries' times, invoking cleanup on the\n\texception. On the final attempt, allow any exceptions\n\tto propagate.\n\t\"\"\"\n\tattempts = count() if retries == float('inf') else range(retries)\n\tfor attempt in attempts:\n\t\ttry:\n\t\t\treturn func()\n\t\texcept trap:\n\t\t\tcleanup()\n\n\treturn func()", "code_tokens": "def retry_call ( func , cleanup = lambda : None , retries = 0 , trap = ( ) ) : attempts = count ( ) if retries == float ( 'inf' ) else range ( retries ) for attempt in attempts : try : return func ( ) except trap : cleanup ( ) return func ( )", "docstring_tokens": "Given a callable func trap the indicated exceptions for up to retries times invoking cleanup on the exception . On the final attempt allow any exceptions to propagate .", "label": 1}, {"idx": "cosqa-train-7869", "doc": "kill a thread after join in python", "code": "def _try_join_cancelled_thread(thread):\n    \"\"\"Join a thread, but if the thread doesn't terminate for some time, ignore it\n    instead of waiting infinitely.\"\"\"\n    thread.join(10)\n    if thread.is_alive():\n        logging.warning(\"Thread %s did not terminate within grace period after cancellation\",\n                        thread.name)", "code_tokens": "def _try_join_cancelled_thread ( thread ) : thread . join ( 10 ) if thread . is_alive ( ) : logging . warning ( \"Thread %s did not terminate within grace period after cancellation\" , thread . name )", "docstring_tokens": "Join a thread but if the thread doesn t terminate for some time ignore it instead of waiting infinitely .", "label": 0}, {"idx": "cosqa-train-7870", "doc": "python try catch within a loop", "code": "def retry_call(func, cleanup=lambda: None, retries=0, trap=()):\n\t\"\"\"\n\tGiven a callable func, trap the indicated exceptions\n\tfor up to 'retries' times, invoking cleanup on the\n\texception. On the final attempt, allow any exceptions\n\tto propagate.\n\t\"\"\"\n\tattempts = count() if retries == float('inf') else range(retries)\n\tfor attempt in attempts:\n\t\ttry:\n\t\t\treturn func()\n\t\texcept trap:\n\t\t\tcleanup()\n\n\treturn func()", "code_tokens": "def retry_call ( func , cleanup = lambda : None , retries = 0 , trap = ( ) ) : attempts = count ( ) if retries == float ( 'inf' ) else range ( retries ) for attempt in attempts : try : return func ( ) except trap : cleanup ( ) return func ( )", "docstring_tokens": "Given a callable func trap the indicated exceptions for up to retries times invoking cleanup on the exception . On the final attempt allow any exceptions to propagate .", "label": 0}, {"idx": "cosqa-train-7871", "doc": "kmeans for multidimensional clustering python", "code": "def classify_clusters(points, n=10):\n    \"\"\"\n    Return an array of K-Means cluster classes for an array of `shapely.geometry.Point` objects.\n    \"\"\"\n    arr = [[p.x, p.y] for p in points.values]\n    clf = KMeans(n_clusters=n)\n    clf.fit(arr)\n    classes = clf.predict(arr)\n    return classes", "code_tokens": "def classify_clusters ( points , n = 10 ) : arr = [ [ p . x , p . y ] for p in points . values ] clf = KMeans ( n_clusters = n ) clf . fit ( arr ) classes = clf . predict ( arr ) return classes", "docstring_tokens": "Return an array of K - Means cluster classes for an array of shapely . geometry . Point objects .", "label": 1}, {"idx": "cosqa-train-7872", "doc": "python ttk scrollbar display only in treeview window area", "code": "def yview(self, *args):\n        \"\"\"Update inplace widgets position when doing vertical scroll\"\"\"\n        self.after_idle(self.__updateWnds)\n        ttk.Treeview.yview(self, *args)", "code_tokens": "def yview ( self , * args ) : self . after_idle ( self . __updateWnds ) ttk . Treeview . yview ( self , * args )", "docstring_tokens": "Update inplace widgets position when doing vertical scroll", "label": 1}, {"idx": "cosqa-train-7873", "doc": "kmeans select columns to cluster python", "code": "def fit(self, X):\n        \"\"\" Apply KMeans Clustering\n              X: dataset with feature vectors\n        \"\"\"\n        self.centers_, self.labels_, self.sse_arr_, self.n_iter_ = \\\n              _kmeans(X, self.n_clusters, self.max_iter, self.n_trials, self.tol)", "code_tokens": "def fit ( self , X ) : self . centers_ , self . labels_ , self . sse_arr_ , self . n_iter_ = _kmeans ( X , self . n_clusters , self . max_iter , self . n_trials , self . tol )", "docstring_tokens": "Apply KMeans Clustering X : dataset with feature vectors", "label": 0}, {"idx": "cosqa-train-7874", "doc": "python tuple destructuring in lambda", "code": "def lambda_tuple_converter(func):\n    \"\"\"\n    Converts a Python 2 function as\n      lambda (x,y): x + y\n    In the Python 3 format:\n      lambda x,y : x + y\n    \"\"\"\n    if func is not None and func.__code__.co_argcount == 1:\n        return lambda *args: func(args[0] if len(args) == 1 else args)\n    else:\n        return func", "code_tokens": "def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func", "docstring_tokens": "Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y", "label": 1}, {"idx": "cosqa-train-7875", "doc": "l2 norm of vector matrix python", "code": "def l2_norm(arr):\n    \"\"\"\n    The l2 norm of an array is is defined as: sqrt(||x||), where ||x|| is the\n    dot product of the vector.\n    \"\"\"\n    arr = np.asarray(arr)\n    return np.sqrt(np.dot(arr.ravel().squeeze(), arr.ravel().squeeze()))", "code_tokens": "def l2_norm ( arr ) : arr = np . asarray ( arr ) return np . sqrt ( np . dot ( arr . ravel ( ) . squeeze ( ) , arr . ravel ( ) . squeeze ( ) ) )", "docstring_tokens": "The l2 norm of an array is is defined as : sqrt ( ||x|| ) where ||x|| is the dot product of the vector .", "label": 1}, {"idx": "cosqa-train-7876", "doc": "python tuple destructuring on lambda not working", "code": "def lambda_tuple_converter(func):\n    \"\"\"\n    Converts a Python 2 function as\n      lambda (x,y): x + y\n    In the Python 3 format:\n      lambda x,y : x + y\n    \"\"\"\n    if func is not None and func.__code__.co_argcount == 1:\n        return lambda *args: func(args[0] if len(args) == 1 else args)\n    else:\n        return func", "code_tokens": "def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func", "docstring_tokens": "Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y", "label": 1}, {"idx": "cosqa-train-7877", "doc": "lambert conformal conic projection python", "code": "def projR(gamma, p):\n    \"\"\"return the KL projection on the row constrints \"\"\"\n    return np.multiply(gamma.T, p / np.maximum(np.sum(gamma, axis=1), 1e-10)).T", "code_tokens": "def projR ( gamma , p ) : return np . multiply ( gamma . T , p / np . maximum ( np . sum ( gamma , axis = 1 ) , 1e-10 ) ) . T", "docstring_tokens": "return the KL projection on the row constrints", "label": 1}, {"idx": "cosqa-train-7878", "doc": "python tuple hash function", "code": "def hash_iterable(it):\n\t\"\"\"Perform a O(1) memory hash of an iterable of arbitrary length.\n\n\thash(tuple(it)) creates a temporary tuple containing all values from it\n\twhich could be a problem if it is large.\n\n\tSee discussion at:\n\thttps://groups.google.com/forum/#!msg/python-ideas/XcuC01a8SYs/e-doB9TbDwAJ\n\t\"\"\"\n\thash_value = hash(type(it))\n\tfor value in it:\n\t\thash_value = hash((hash_value, value))\n\treturn hash_value", "code_tokens": "def hash_iterable ( it ) : hash_value = hash ( type ( it ) ) for value in it : hash_value = hash ( ( hash_value , value ) ) return hash_value", "docstring_tokens": "Perform a O ( 1 ) memory hash of an iterable of arbitrary length .", "label": 0}, {"idx": "cosqa-train-7879", "doc": "last element in iterator python", "code": "def iter_with_last(iterable):\n    \"\"\"\n    :return: generator of tuples (isLastFlag, item)\n    \"\"\"\n    # Ensure it's an iterator and get the first field\n    iterable = iter(iterable)\n    prev = next(iterable)\n    for item in iterable:\n        # Lag by one item so I know I'm not at the end\n        yield False, prev\n        prev = item\n    # Last item\n    yield True, prev", "code_tokens": "def iter_with_last ( iterable ) : # Ensure it's an iterator and get the first field iterable = iter ( iterable ) prev = next ( iterable ) for item in iterable : # Lag by one item so I know I'm not at the end yield False , prev prev = item # Last item yield True , prev", "docstring_tokens": ": return : generator of tuples ( isLastFlag item )", "label": 1}, {"idx": "cosqa-train-7880", "doc": "python turn a string into a number", "code": "def get_number(s, cast=int):\n    \"\"\"\n    Try to get a number out of a string, and cast it.\n    \"\"\"\n    import string\n    d = \"\".join(x for x in str(s) if x in string.digits)\n    return cast(d)", "code_tokens": "def get_number ( s , cast = int ) : import string d = \"\" . join ( x for x in str ( s ) if x in string . digits ) return cast ( d )", "docstring_tokens": "Try to get a number out of a string and cast it .", "label": 1}, {"idx": "cosqa-train-7881", "doc": "length or norm of the vector a in python", "code": "def norm_vec(vector):\n    \"\"\"Normalize the length of a vector to one\"\"\"\n    assert len(vector) == 3\n    v = np.array(vector)\n    return v/np.sqrt(np.sum(v**2))", "code_tokens": "def norm_vec ( vector ) : assert len ( vector ) == 3 v = np . array ( vector ) return v / np . sqrt ( np . sum ( v ** 2 ) )", "docstring_tokens": "Normalize the length of a vector to one", "label": 0}, {"idx": "cosqa-train-7882", "doc": "python turn dict into kwargs", "code": "def json_to_initkwargs(self, json_data, kwargs):\n        \"\"\"Subclassing hook to specialize how JSON data is converted\n        to keyword arguments\"\"\"\n        if isinstance(json_data, basestring):\n            json_data = json.loads(json_data)\n        return json_to_initkwargs(self, json_data, kwargs)", "code_tokens": "def json_to_initkwargs ( self , json_data , kwargs ) : if isinstance ( json_data , basestring ) : json_data = json . loads ( json_data ) return json_to_initkwargs ( self , json_data , kwargs )", "docstring_tokens": "Subclassing hook to specialize how JSON data is converted to keyword arguments", "label": 1}, {"idx": "cosqa-train-7883", "doc": "limit on heapq size python", "code": "def heappush_max(heap, item):\n    \"\"\"Push item onto heap, maintaining the heap invariant.\"\"\"\n    heap.append(item)\n    _siftdown_max(heap, 0, len(heap) - 1)", "code_tokens": "def heappush_max ( heap , item ) : heap . append ( item ) _siftdown_max ( heap , 0 , len ( heap ) - 1 )", "docstring_tokens": "Push item onto heap maintaining the heap invariant .", "label": 1}, {"idx": "cosqa-train-7884", "doc": "python turn init args into kwargs", "code": "def json_to_initkwargs(self, json_data, kwargs):\n        \"\"\"Subclassing hook to specialize how JSON data is converted\n        to keyword arguments\"\"\"\n        if isinstance(json_data, basestring):\n            json_data = json.loads(json_data)\n        return json_to_initkwargs(self, json_data, kwargs)", "code_tokens": "def json_to_initkwargs ( self , json_data , kwargs ) : if isinstance ( json_data , basestring ) : json_data = json . loads ( json_data ) return json_to_initkwargs ( self , json_data , kwargs )", "docstring_tokens": "Subclassing hook to specialize how JSON data is converted to keyword arguments", "label": 0}, {"idx": "cosqa-train-7885", "doc": "limit on open file handles in python", "code": "def _increase_file_handle_limit():\n    \"\"\"Raise the open file handles permitted by the Dusty daemon process\n    and its child processes. The number we choose here needs to be within\n    the OS X default kernel hard limit, which is 10240.\"\"\"\n    logging.info('Increasing file handle limit to {}'.format(constants.FILE_HANDLE_LIMIT))\n    resource.setrlimit(resource.RLIMIT_NOFILE,\n                       (constants.FILE_HANDLE_LIMIT, resource.RLIM_INFINITY))", "code_tokens": "def _increase_file_handle_limit ( ) : logging . info ( 'Increasing file handle limit to {}' . format ( constants . FILE_HANDLE_LIMIT ) ) resource . setrlimit ( resource . RLIMIT_NOFILE , ( constants . FILE_HANDLE_LIMIT , resource . RLIM_INFINITY ) )", "docstring_tokens": "Raise the open file handles permitted by the Dusty daemon process and its child processes . The number we choose here needs to be within the OS X default kernel hard limit which is 10240 .", "label": 1}, {"idx": "cosqa-train-7886", "doc": "python turn nonetype to string", "code": "def bytes_to_str(s, encoding='utf-8'):\n    \"\"\"Returns a str if a bytes object is given.\"\"\"\n    if six.PY3 and isinstance(s, bytes):\n        return s.decode(encoding)\n    return s", "code_tokens": "def bytes_to_str ( s , encoding = 'utf-8' ) : if six . PY3 and isinstance ( s , bytes ) : return s . decode ( encoding ) return s", "docstring_tokens": "Returns a str if a bytes object is given .", "label": 1}, {"idx": "cosqa-train-7887", "doc": "limit y axis in python pyplot", "code": "def set_ylimits(self, row, column, min=None, max=None):\n        \"\"\"Set y-axis limits of a subplot.\n\n        :param row,column: specify the subplot.\n        :param min: minimal axis value\n        :param max: maximum axis value\n\n        \"\"\"\n        subplot = self.get_subplot_at(row, column)\n        subplot.set_ylimits(min, max)", "code_tokens": "def set_ylimits ( self , row , column , min = None , max = None ) : subplot = self . get_subplot_at ( row , column ) subplot . set_ylimits ( min , max )", "docstring_tokens": "Set y - axis limits of a subplot .", "label": 1}, {"idx": "cosqa-train-7888", "doc": "python turn nparray into list", "code": "def dump_nparray(self, obj, class_name=numpy_ndarray_class_name):\n        \"\"\"\n        ``numpy.ndarray`` dumper.\n        \"\"\"\n        return {\"$\" + class_name: self._json_convert(obj.tolist())}", "code_tokens": "def dump_nparray ( self , obj , class_name = numpy_ndarray_class_name ) : return { \"$\" + class_name : self . _json_convert ( obj . tolist ( ) ) }", "docstring_tokens": "numpy . ndarray dumper .", "label": 0}, {"idx": "cosqa-train-7889", "doc": "linear regression in python with multiple features", "code": "def fit_linear(X, y):\n    \"\"\"\n    Uses OLS to fit the regression.\n    \"\"\"\n    model = linear_model.LinearRegression()\n    model.fit(X, y)\n    return model", "code_tokens": "def fit_linear ( X , y ) : model = linear_model . LinearRegression ( ) model . fit ( X , y ) return model", "docstring_tokens": "Uses OLS to fit the regression .", "label": 0}, {"idx": "cosqa-train-7890", "doc": "python twisted session hangs", "code": "def delayed_close(self):\n        \"\"\" Delayed close - won't close immediately, but on the next reactor\n        loop. \"\"\"\n        self.state = SESSION_STATE.CLOSING\n        reactor.callLater(0, self.close)", "code_tokens": "def delayed_close ( self ) : self . state = SESSION_STATE . CLOSING reactor . callLater ( 0 , self . close )", "docstring_tokens": "Delayed close - won t close immediately but on the next reactor loop .", "label": 1}, {"idx": "cosqa-train-7891", "doc": "linux python get memory usage", "code": "def get_free_memory_win():\n    \"\"\"Return current free memory on the machine for windows.\n\n    Warning : this script is really not robust\n    Return in MB unit\n    \"\"\"\n    stat = MEMORYSTATUSEX()\n    ctypes.windll.kernel32.GlobalMemoryStatusEx(ctypes.byref(stat))\n    return int(stat.ullAvailPhys / 1024 / 1024)", "code_tokens": "def get_free_memory_win ( ) : stat = MEMORYSTATUSEX ( ) ctypes . windll . kernel32 . GlobalMemoryStatusEx ( ctypes . byref ( stat ) ) return int ( stat . ullAvailPhys / 1024 / 1024 )", "docstring_tokens": "Return current free memory on the machine for windows .", "label": 0}, {"idx": "cosqa-train-7892", "doc": "python twitter api get tweets from user", "code": "def search_for_tweets_about(user_id, params):\n    \"\"\" Search twitter API \"\"\"\n    url = \"https://api.twitter.com/1.1/search/tweets.json\"\n    response = make_twitter_request(url, user_id, params)\n    return process_tweets(response.json()[\"statuses\"])", "code_tokens": "def search_for_tweets_about ( user_id , params ) : url = \"https://api.twitter.com/1.1/search/tweets.json\" response = make_twitter_request ( url , user_id , params ) return process_tweets ( response . json ( ) [ \"statuses\" ] )", "docstring_tokens": "Search twitter API", "label": 0}, {"idx": "cosqa-train-7893", "doc": "list composed of 2d arrays in python", "code": "def pack_triples_numpy(triples):\n    \"\"\"Packs a list of triple indexes into a 2D numpy array.\"\"\"\n    if len(triples) == 0:\n        return np.array([], dtype=np.int64)\n    return np.stack(list(map(_transform_triple_numpy, triples)), axis=0)", "code_tokens": "def pack_triples_numpy ( triples ) : if len ( triples ) == 0 : return np . array ( [ ] , dtype = np . int64 ) return np . stack ( list ( map ( _transform_triple_numpy , triples ) ) , axis = 0 )", "docstring_tokens": "Packs a list of triple indexes into a 2D numpy array .", "label": 1}, {"idx": "cosqa-train-7894", "doc": "python twitter hashtag detector", "code": "def urlize_twitter(text):\n    \"\"\"\n    Replace #hashtag and @username references in a tweet with HTML text.\n    \"\"\"\n    html = TwitterText(text).autolink.auto_link()\n    return mark_safe(html.replace(\n        'twitter.com/search?q=', 'twitter.com/search/realtime/'))", "code_tokens": "def urlize_twitter ( text ) : html = TwitterText ( text ) . autolink . auto_link ( ) return mark_safe ( html . replace ( 'twitter.com/search?q=' , 'twitter.com/search/realtime/' ) )", "docstring_tokens": "Replace #hashtag and", "label": 1}, {"idx": "cosqa-train-7895", "doc": "list contain same elements python", "code": "def unique(input_list):\n    \"\"\"\n    Return a list of unique items (similar to set functionality).\n\n    Parameters\n    ----------\n    input_list : list\n        A list containg some items that can occur more than once.\n\n    Returns\n    -------\n    list\n        A list with only unique occurances of an item.\n\n    \"\"\"\n    output = []\n    for item in input_list:\n        if item not in output:\n            output.append(item)\n    return output", "code_tokens": "def unique ( input_list ) : output = [ ] for item in input_list : if item not in output : output . append ( item ) return output", "docstring_tokens": "Return a list of unique items ( similar to set functionality ) .", "label": 1}, {"idx": "cosqa-train-7896", "doc": "python type assertion int", "code": "def is_int_type(val):\n    \"\"\"Return True if `val` is of integer type.\"\"\"\n    try:               # Python 2\n        return isinstance(val, (int, long))\n    except NameError:  # Python 3\n        return isinstance(val, int)", "code_tokens": "def is_int_type ( val ) : try : # Python 2 return isinstance ( val , ( int , long ) ) except NameError : # Python 3 return isinstance ( val , int )", "docstring_tokens": "Return True if val is of integer type .", "label": 1}, {"idx": "cosqa-train-7897", "doc": "list delete duplicate python", "code": "def dedupe_list(seq):\n    \"\"\"\n    Utility function to remove duplicates from a list\n    :param seq: The sequence (list) to deduplicate\n    :return: A list with original duplicates removed\n    \"\"\"\n    seen = set()\n    return [x for x in seq if not (x in seen or seen.add(x))]", "code_tokens": "def dedupe_list ( seq ) : seen = set ( ) return [ x for x in seq if not ( x in seen or seen . add ( x ) ) ]", "docstring_tokens": "Utility function to remove duplicates from a list : param seq : The sequence ( list ) to deduplicate : return : A list with original duplicates removed", "label": 1}, {"idx": "cosqa-train-7898", "doc": "python unique entries in list", "code": "def delete_duplicates(seq):\n    \"\"\"\n    Remove duplicates from an iterable, preserving the order.\n\n    Args:\n        seq: Iterable of various type.\n\n    Returns:\n        list: List of unique objects.\n\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    return [x for x in seq if not (x in seen or seen_add(x))]", "code_tokens": "def delete_duplicates ( seq ) : seen = set ( ) seen_add = seen . add return [ x for x in seq if not ( x in seen or seen_add ( x ) ) ]", "docstring_tokens": "Remove duplicates from an iterable preserving the order .", "label": 1}, {"idx": "cosqa-train-7899", "doc": "list to dict in python", "code": "def list2dict(lst):\n    \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"\n\n    dic = {}\n    for k,v in lst: dic[k] = v\n    return dic", "code_tokens": "def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic", "docstring_tokens": "Takes a list of ( key value ) pairs and turns it into a dict .", "label": 0}, {"idx": "cosqa-train-7900", "doc": "python unit test cmd", "code": "def test(ctx, all=False, verbose=False):\n    \"\"\"Run the tests.\"\"\"\n    cmd = 'tox' if all else 'py.test'\n    if verbose:\n        cmd += ' -v'\n    return ctx.run(cmd, pty=True).return_code", "code_tokens": "def test ( ctx , all = False , verbose = False ) : cmd = 'tox' if all else 'py.test' if verbose : cmd += ' -v' return ctx . run ( cmd , pty = True ) . return_code", "docstring_tokens": "Run the tests .", "label": 1}, {"idx": "cosqa-train-7901", "doc": "load h5py load to different formats in python", "code": "def h5ToDict(h5, readH5pyDataset=True):\n    \"\"\" Read a hdf5 file into a dictionary \"\"\"\n    h = h5py.File(h5, \"r\")\n    ret = unwrapArray(h, recursive=True, readH5pyDataset=readH5pyDataset)\n    if readH5pyDataset: h.close()\n    return ret", "code_tokens": "def h5ToDict ( h5 , readH5pyDataset = True ) : h = h5py . File ( h5 , \"r\" ) ret = unwrapArray ( h , recursive = True , readH5pyDataset = readH5pyDataset ) if readH5pyDataset : h . close ( ) return ret", "docstring_tokens": "Read a hdf5 file into a dictionary", "label": 0}, {"idx": "cosqa-train-7902", "doc": "python unittest and coverage report", "code": "def cover(session):\n    \"\"\"Run the final coverage report.\n    This outputs the coverage report aggregating coverage from the unit\n    test runs (not system test runs), and then erases coverage data.\n    \"\"\"\n    session.interpreter = 'python3.6'\n    session.install('coverage', 'pytest-cov')\n    session.run('coverage', 'report', '--show-missing', '--fail-under=100')\n    session.run('coverage', 'erase')", "code_tokens": "def cover ( session ) : session . interpreter = 'python3.6' session . install ( 'coverage' , 'pytest-cov' ) session . run ( 'coverage' , 'report' , '--show-missing' , '--fail-under=100' ) session . run ( 'coverage' , 'erase' )", "docstring_tokens": "Run the final coverage report . This outputs the coverage report aggregating coverage from the unit test runs ( not system test runs ) and then erases coverage data .", "label": 1}, {"idx": "cosqa-train-7903", "doc": "load image into tensorflow python", "code": "def decode_example(self, example):\n    \"\"\"Reconstruct the image from the tf example.\"\"\"\n    img = tf.image.decode_image(\n        example, channels=self._shape[-1], dtype=tf.uint8)\n    img.set_shape(self._shape)\n    return img", "code_tokens": "def decode_example ( self , example ) : img = tf . image . decode_image ( example , channels = self . _shape [ - 1 ] , dtype = tf . uint8 ) img . set_shape ( self . _shape ) return img", "docstring_tokens": "Reconstruct the image from the tf example .", "label": 1}, {"idx": "cosqa-train-7904", "doc": "python unittest assert not raise", "code": "def assert_is_not(expected, actual, message=None, extra=None):\n    \"\"\"Raises an AssertionError if expected is actual.\"\"\"\n    assert expected is not actual, _assert_fail_message(\n        message, expected, actual, \"is\", extra\n    )", "code_tokens": "def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , \"is\" , extra )", "docstring_tokens": "Raises an AssertionError if expected is actual .", "label": 1}, {"idx": "cosqa-train-7905", "doc": "load json into mongodb from python", "code": "def load_db(file, db, verbose=True):\n    \"\"\"\n    Load :class:`mongomock.database.Database` from a local file.\n\n    :param file: file path.\n    :param db: instance of :class:`mongomock.database.Database`.\n    :param verbose: bool, toggle on log.\n    :return: loaded db.\n    \"\"\"\n    db_data = json.load(file, verbose=verbose)\n    return _load(db_data, db)", "code_tokens": "def load_db ( file , db , verbose = True ) : db_data = json . load ( file , verbose = verbose ) return _load ( db_data , db )", "docstring_tokens": "Load : class : mongomock . database . Database from a local file .", "label": 0}, {"idx": "cosqa-train-7906", "doc": "python unittest assert not raises", "code": "def assert_is_not(expected, actual, message=None, extra=None):\n    \"\"\"Raises an AssertionError if expected is actual.\"\"\"\n    assert expected is not actual, _assert_fail_message(\n        message, expected, actual, \"is\", extra\n    )", "code_tokens": "def assert_is_not ( expected , actual , message = None , extra = None ) : assert expected is not actual , _assert_fail_message ( message , expected , actual , \"is\" , extra )", "docstring_tokens": "Raises an AssertionError if expected is actual .", "label": 1}, {"idx": "cosqa-train-7907", "doc": "loading a json file into netezza using python", "code": "def from_file(filename):\n    \"\"\"\n    load an nparray object from a json filename\n\n    @parameter str filename: path to the file\n    \"\"\"\n    f = open(filename, 'r')\n    j = json.load(f)\n    f.close()\n\n    return from_dict(j)", "code_tokens": "def from_file ( filename ) : f = open ( filename , 'r' ) j = json . load ( f ) f . close ( ) return from_dict ( j )", "docstring_tokens": "load an nparray object from a json filename", "label": 1}, {"idx": "cosqa-train-7908", "doc": "python url retrieve ntp time", "code": "def get_time():\n    \"\"\"Get time from a locally running NTP server\"\"\"\n\n    time_request = '\\x1b' + 47 * '\\0'\n    now = struct.unpack(\"!12I\", ntp_service.request(time_request, timeout=5.0).data.read())[10]\n    return time.ctime(now - EPOCH_START)", "code_tokens": "def get_time ( ) : time_request = '\\x1b' + 47 * '\\0' now = struct . unpack ( \"!12I\" , ntp_service . request ( time_request , timeout = 5.0 ) . data . read ( ) ) [ 10 ] return time . ctime ( now - EPOCH_START )", "docstring_tokens": "Get time from a locally running NTP server", "label": 0}, {"idx": "cosqa-train-7909", "doc": "log fit unbalanced python", "code": "def plfit_lsq(x,y):\n    \"\"\"\n    Returns A and B in y=Ax^B\n    http://mathworld.wolfram.com/LeastSquaresFittingPowerLaw.html\n    \"\"\"\n    n = len(x)\n    btop = n * (log(x)*log(y)).sum() - (log(x)).sum()*(log(y)).sum()\n    bbottom = n*(log(x)**2).sum() - (log(x).sum())**2\n    b = btop / bbottom\n    a = ( log(y).sum() - b * log(x).sum() ) / n\n\n    A = exp(a)\n    return A,b", "code_tokens": "def plfit_lsq ( x , y ) : n = len ( x ) btop = n * ( log ( x ) * log ( y ) ) . sum ( ) - ( log ( x ) ) . sum ( ) * ( log ( y ) ) . sum ( ) bbottom = n * ( log ( x ) ** 2 ) . sum ( ) - ( log ( x ) . sum ( ) ) ** 2 b = btop / bbottom a = ( log ( y ) . sum ( ) - b * log ( x ) . sum ( ) ) / n A = exp ( a ) return A , b", "docstring_tokens": "Returns A and B in y = Ax^B http : // mathworld . wolfram . com / LeastSquaresFittingPowerLaw . html", "label": 1}, {"idx": "cosqa-train-7910", "doc": "python urllib openurl return code", "code": "def get_url_nofollow(url):\n\t\"\"\" \n\tfunction to get return code of a url\n\n\tCredits: http://blog.jasonantman.com/2013/06/python-script-to-check-a-list-of-urls-for-return-code-and-final-return-code-if-redirected/\n\t\"\"\"\n\ttry:\n\t\tresponse = urlopen(url)\n\t\tcode = response.getcode()\n\t\treturn code\n\texcept HTTPError as e:\n\t\treturn e.code\n\texcept:\n\t\treturn 0", "code_tokens": "def get_url_nofollow ( url ) : try : response = urlopen ( url ) code = response . getcode ( ) return code except HTTPError as e : return e . code except : return 0", "docstring_tokens": "function to get return code of a url", "label": 1}, {"idx": "cosqa-train-7911", "doc": "logging output in python stored", "code": "def logger(message, level=10):\n    \"\"\"Handle logging.\"\"\"\n    logging.getLogger(__name__).log(level, str(message))", "code_tokens": "def logger ( message , level = 10 ) : logging . getLogger ( __name__ ) . log ( level , str ( message ) )", "docstring_tokens": "Handle logging .", "label": 0}, {"idx": "cosqa-train-7912", "doc": "python usb access deined", "code": "def open_usb_handle(self, port_num):\n    \"\"\"open usb port\n\n    Args:\n      port_num: port number on the Cambrionix unit\n\n    Return:\n      usb handle\n    \"\"\"\n    serial = self.get_usb_serial(port_num)\n    return local_usb.LibUsbHandle.open(serial_number=serial)", "code_tokens": "def open_usb_handle ( self , port_num ) : serial = self . get_usb_serial ( port_num ) return local_usb . LibUsbHandle . open ( serial_number = serial )", "docstring_tokens": "open usb port", "label": 0}, {"idx": "cosqa-train-7913", "doc": "logics for making a histogram in python without using matplotlib", "code": "def _histplot_op(ax, data, **kwargs):\n    \"\"\"Add a histogram for the data to the axes.\"\"\"\n    bins = get_bins(data)\n    ax.hist(data, bins=bins, align=\"left\", density=True, **kwargs)\n    return ax", "code_tokens": "def _histplot_op ( ax , data , * * kwargs ) : bins = get_bins ( data ) ax . hist ( data , bins = bins , align = \"left\" , density = True , * * kwargs ) return ax", "docstring_tokens": "Add a histogram for the data to the axes .", "label": 0}, {"idx": "cosqa-train-7914", "doc": "python use list generate dict", "code": "def list2dict(list_of_options):\n    \"\"\"Transforms a list of 2 element tuples to a dictionary\"\"\"\n    d = {}\n    for key, value in list_of_options:\n        d[key] = value\n    return d", "code_tokens": "def list2dict ( list_of_options ) : d = { } for key , value in list_of_options : d [ key ] = value return d", "docstring_tokens": "Transforms a list of 2 element tuples to a dictionary", "label": 0}, {"idx": "cosqa-train-7915", "doc": "logistic regression for two valued variable python stack overflow", "code": "def survival(value=t, lam=lam, f=failure):\n    \"\"\"Exponential survival likelihood, accounting for censoring\"\"\"\n    return sum(f * log(lam) - lam * value)", "code_tokens": "def survival ( value = t , lam = lam , f = failure ) : return sum ( f * log ( lam ) - lam * value )", "docstring_tokens": "Exponential survival likelihood accounting for censoring", "label": 0}, {"idx": "cosqa-train-7916", "doc": "python using a pidfile", "code": "def put_pidfile( pidfile_path, pid ):\n    \"\"\"\n    Put a PID into a pidfile\n    \"\"\"\n    with open( pidfile_path, \"w\" ) as f:\n        f.write(\"%s\" % pid)\n        os.fsync(f.fileno())\n\n    return", "code_tokens": "def put_pidfile ( pidfile_path , pid ) : with open ( pidfile_path , \"w\" ) as f : f . write ( \"%s\" % pid ) os . fsync ( f . fileno ( ) ) return", "docstring_tokens": "Put a PID into a pidfile", "label": 1}, {"idx": "cosqa-train-7917", "doc": "logistic regression python skleran with categorical variables", "code": "def _log_multivariate_normal_density_tied(X, means, covars):\n    \"\"\"Compute Gaussian log-density at X for a tied model.\"\"\"\n    cv = np.tile(covars, (means.shape[0], 1, 1))\n    return _log_multivariate_normal_density_full(X, means, cv)", "code_tokens": "def _log_multivariate_normal_density_tied ( X , means , covars ) : cv = np . tile ( covars , ( means . shape [ 0 ] , 1 , 1 ) ) return _log_multivariate_normal_density_full ( X , means , cv )", "docstring_tokens": "Compute Gaussian log - density at X for a tied model .", "label": 0}, {"idx": "cosqa-train-7918", "doc": "python var and distribution of probability", "code": "def pdf(x, mu, std):\n    \"\"\"Probability density function (normal distribution)\"\"\"\n    return (1.0 / (std * sqrt(2 * pi))) * np.exp(-(x - mu) ** 2 / (2 * std ** 2))", "code_tokens": "def pdf ( x , mu , std ) : return ( 1.0 / ( std * sqrt ( 2 * pi ) ) ) * np . exp ( - ( x - mu ) ** 2 / ( 2 * std ** 2 ) )", "docstring_tokens": "Probability density function ( normal distribution )", "label": 1}, {"idx": "cosqa-train-7919", "doc": "lowercasing a string python", "code": "def to_camel(s):\n    \"\"\"\n    :param string s: under_scored string to be CamelCased\n    :return: CamelCase version of input\n    :rtype: str\n    \"\"\"\n    # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups\n    return re.sub(r'_([a-zA-Z])', lambda m: m.group(1).upper(), '_' + s)", "code_tokens": "def to_camel ( s ) : # r'(?!^)_([a-zA-Z]) original regex wasn't process first groups return re . sub ( r'_([a-zA-Z])' , lambda m : m . group ( 1 ) . upper ( ) , '_' + s )", "docstring_tokens": ": param string s : under_scored string to be CamelCased : return : CamelCase version of input : rtype : str", "label": 0}, {"idx": "cosqa-train-7920", "doc": "python variables equals to the value of other variable", "code": "def _eq(self, other):\n        \"\"\"Compare two nodes for equality.\"\"\"\n        return (self.type, self.value) == (other.type, other.value)", "code_tokens": "def _eq ( self , other ) : return ( self . type , self . value ) == ( other . type , other . value )", "docstring_tokens": "Compare two nodes for equality .", "label": 1}, {"idx": "cosqa-train-7921", "doc": "make a callable tuple python", "code": "def lambda_tuple_converter(func):\n    \"\"\"\n    Converts a Python 2 function as\n      lambda (x,y): x + y\n    In the Python 3 format:\n      lambda x,y : x + y\n    \"\"\"\n    if func is not None and func.__code__.co_argcount == 1:\n        return lambda *args: func(args[0] if len(args) == 1 else args)\n    else:\n        return func", "code_tokens": "def lambda_tuple_converter ( func ) : if func is not None and func . __code__ . co_argcount == 1 : return lambda * args : func ( args [ 0 ] if len ( args ) == 1 else args ) else : return func", "docstring_tokens": "Converts a Python 2 function as lambda ( x y ) : x + y In the Python 3 format : lambda x y : x + y", "label": 1}, {"idx": "cosqa-train-7922", "doc": "python virtualenv exist dir", "code": "def _pip_exists(self):\n        \"\"\"Returns True if pip exists inside the virtual environment. Can be\n        used as a naive way to verify that the environment is installed.\"\"\"\n        return os.path.isfile(os.path.join(self.path, 'bin', 'pip'))", "code_tokens": "def _pip_exists ( self ) : return os . path . isfile ( os . path . join ( self . path , 'bin' , 'pip' ) )", "docstring_tokens": "Returns True if pip exists inside the virtual environment . Can be used as a naive way to verify that the environment is installed .", "label": 1}, {"idx": "cosqa-train-7923", "doc": "make a separate copy in python", "code": "def copy(obj):\n    def copy(self):\n        \"\"\"\n        Copy self to a new object.\n        \"\"\"\n        from copy import deepcopy\n\n        return deepcopy(self)\n    obj.copy = copy\n    return obj", "code_tokens": "def copy ( obj ) : def copy ( self ) : \"\"\"\n        Copy self to a new object.\n        \"\"\" from copy import deepcopy return deepcopy ( self ) obj . copy = copy return obj", "docstring_tokens": "", "label": 0}, {"idx": "cosqa-train-7924", "doc": "python walk through all files in folder recuricvely", "code": "def get_all_files(folder):\n    \"\"\"\n    Generator that loops through all absolute paths of the files within folder\n\n    Parameters\n    ----------\n    folder: str\n    Root folder start point for recursive search.\n\n    Yields\n    ------\n    fpath: str\n    Absolute path of one file in the folders\n    \"\"\"\n    for path, dirlist, filelist in os.walk(folder):\n        for fn in filelist:\n            yield op.join(path, fn)", "code_tokens": "def get_all_files ( folder ) : for path , dirlist , filelist in os . walk ( folder ) : for fn in filelist : yield op . join ( path , fn )", "docstring_tokens": "Generator that loops through all absolute paths of the files within folder", "label": 0}, {"idx": "cosqa-train-7925", "doc": "make array sequence python numpy", "code": "def _transform_triple_numpy(x):\n    \"\"\"Transform triple index into a 1-D numpy array.\"\"\"\n    return np.array([x.head, x.relation, x.tail], dtype=np.int64)", "code_tokens": "def _transform_triple_numpy ( x ) : return np . array ( [ x . head , x . relation , x . tail ] , dtype = np . int64 )", "docstring_tokens": "Transform triple index into a 1 - D numpy array .", "label": 0}, {"idx": "cosqa-train-7926", "doc": "python waveform offset subtraction", "code": "def _adjust_offset(self, real_wave_mfcc, algo_parameters):\n        \"\"\"\n        OFFSET\n        \"\"\"\n        self.log(u\"Called _adjust_offset\")\n        self._apply_offset(offset=algo_parameters[0])", "code_tokens": "def _adjust_offset ( self , real_wave_mfcc , algo_parameters ) : self . log ( u\"Called _adjust_offset\" ) self . _apply_offset ( offset = algo_parameters [ 0 ] )", "docstring_tokens": "OFFSET", "label": 1}, {"idx": "cosqa-train-7927", "doc": "make columns strings python", "code": "def cols_str(columns):\n    \"\"\"Concatenate list of columns into a string.\"\"\"\n    cols = \"\"\n    for c in columns:\n        cols = cols + wrap(c) + ', '\n    return cols[:-2]", "code_tokens": "def cols_str ( columns ) : cols = \"\" for c in columns : cols = cols + wrap ( c ) + ', ' return cols [ : - 2 ]", "docstring_tokens": "Concatenate list of columns into a string .", "label": 0}, {"idx": "cosqa-train-7928", "doc": "python websocket detect closed", "code": "def _ws_on_close(self, ws: websocket.WebSocketApp):\n        \"\"\"Callback for closing the websocket connection\n\n        Args:\n            ws: websocket connection (now closed)\n        \"\"\"\n        self.connected = False\n        self.logger.error('Websocket closed')\n        self._reconnect_websocket()", "code_tokens": "def _ws_on_close ( self , ws : websocket . WebSocketApp ) : self . connected = False self . logger . error ( 'Websocket closed' ) self . _reconnect_websocket ( )", "docstring_tokens": "Callback for closing the websocket connection", "label": 1}, {"idx": "cosqa-train-7929", "doc": "make list to dictionary python", "code": "def list2dict(lst):\n    \"\"\"Takes a list of (key,value) pairs and turns it into a dict.\"\"\"\n\n    dic = {}\n    for k,v in lst: dic[k] = v\n    return dic", "code_tokens": "def list2dict ( lst ) : dic = { } for k , v in lst : dic [ k ] = v return dic", "docstring_tokens": "Takes a list of ( key value ) pairs and turns it into a dict .", "label": 1}, {"idx": "cosqa-train-7930", "doc": "python what character ends the line after an if", "code": "def cell_ends_with_code(lines):\n    \"\"\"Is the last line of the cell a line with code?\"\"\"\n    if not lines:\n        return False\n    if not lines[-1].strip():\n        return False\n    if lines[-1].startswith('#'):\n        return False\n    return True", "code_tokens": "def cell_ends_with_code ( lines ) : if not lines : return False if not lines [ - 1 ] . strip ( ) : return False if lines [ - 1 ] . startswith ( '#' ) : return False return True", "docstring_tokens": "Is the last line of the cell a line with code?", "label": 1}, {"idx": "cosqa-train-7931", "doc": "make something an array python", "code": "def convert_array(array):\n    \"\"\"\n    Converts an ARRAY string stored in the database back into a Numpy array.\n\n    Parameters\n    ----------\n    array: ARRAY\n        The array object to be converted back into a Numpy array.\n\n    Returns\n    -------\n    array\n            The converted Numpy array.\n\n    \"\"\"\n    out = io.BytesIO(array)\n    out.seek(0)\n    return np.load(out)", "code_tokens": "def convert_array ( array ) : out = io . BytesIO ( array ) out . seek ( 0 ) return np . load ( out )", "docstring_tokens": "Converts an ARRAY string stored in the database back into a Numpy array .", "label": 1}, {"idx": "cosqa-train-7932", "doc": "python win32api get handle from property name", "code": "def get_property_by_name(pif, name):\n    \"\"\"Get a property by name\"\"\"\n    return next((x for x in pif.properties if x.name == name), None)", "code_tokens": "def get_property_by_name ( pif , name ) : return next ( ( x for x in pif . properties if x . name == name ) , None )", "docstring_tokens": "Get a property by name", "label": 0}, {"idx": "cosqa-train-7933", "doc": "making a list of a specific size in python", "code": "def batch(items, size):\n    \"\"\"Batches a list into a list of lists, with sub-lists sized by a specified\n    batch size.\"\"\"\n    return [items[x:x + size] for x in xrange(0, len(items), size)]", "code_tokens": "def batch ( items , size ) : return [ items [ x : x + size ] for x in xrange ( 0 , len ( items ) , size ) ]", "docstring_tokens": "Batches a list into a list of lists with sub - lists sized by a specified batch size .", "label": 1}, {"idx": "cosqa-train-7934", "doc": "python window reset mouse cursor", "code": "def set_cursor(self, x, y):\n        \"\"\"\n        Sets the cursor to the desired position.\n\n        :param x: X position\n        :param y: Y position\n        \"\"\"\n        curses.curs_set(1)\n        self.screen.move(y, x)", "code_tokens": "def set_cursor ( self , x , y ) : curses . curs_set ( 1 ) self . screen . move ( y , x )", "docstring_tokens": "Sets the cursor to the desired position .", "label": 1}, {"idx": "cosqa-train-7935", "doc": "making pie charts in python without external libraries", "code": "def house_explosions():\n    \"\"\"\n    Data from http://indexed.blogspot.com/2007/12/meltdown-indeed.html\n    \"\"\"\n    chart = PieChart2D(int(settings.width * 1.7), settings.height)\n    chart.add_data([10, 10, 30, 200])\n    chart.set_pie_labels([\n        'Budding Chemists',\n        'Propane issues',\n        'Meth Labs',\n        'Attempts to escape morgage',\n        ])\n    chart.download('pie-house-explosions.png')", "code_tokens": "def house_explosions ( ) : chart = PieChart2D ( int ( settings . width * 1.7 ) , settings . height ) chart . add_data ( [ 10 , 10 , 30 , 200 ] ) chart . set_pie_labels ( [ 'Budding Chemists' , 'Propane issues' , 'Meth Labs' , 'Attempts to escape morgage' , ] ) chart . download ( 'pie-house-explosions.png' )", "docstring_tokens": "Data from http : // indexed . blogspot . com / 2007 / 12 / meltdown - indeed . html", "label": 1}, {"idx": "cosqa-train-7936", "doc": "python winreg looping through subkeys", "code": "def RecurseKeys(self):\n    \"\"\"Recurses the subkeys starting with the key.\n\n    Yields:\n      WinRegistryKey: Windows Registry key.\n    \"\"\"\n    yield self\n    for subkey in self.GetSubkeys():\n      for key in subkey.RecurseKeys():\n        yield key", "code_tokens": "def RecurseKeys ( self ) : yield self for subkey in self . GetSubkeys ( ) : for key in subkey . RecurseKeys ( ) : yield key", "docstring_tokens": "Recurses the subkeys starting with the key .", "label": 0}, {"idx": "cosqa-train-7937", "doc": "map to reverse dictionary python", "code": "def invertDictMapping(d):\n    \"\"\" Invert mapping of dictionary (i.e. map values to list of keys) \"\"\"\n    inv_map = {}\n    for k, v in d.items():\n        inv_map[v] = inv_map.get(v, [])\n        inv_map[v].append(k)\n    return inv_map", "code_tokens": "def invertDictMapping ( d ) : inv_map = { } for k , v in d . items ( ) : inv_map [ v ] = inv_map . get ( v , [ ] ) inv_map [ v ] . append ( k ) return inv_map", "docstring_tokens": "Invert mapping of dictionary ( i . e . map values to list of keys )", "label": 0}, {"idx": "cosqa-train-7938", "doc": "python word similarity sementic", "code": "def basic_word_sim(word1, word2):\n    \"\"\"\n    Simple measure of similarity: Number of letters in common / max length\n    \"\"\"\n    return sum([1 for c in word1 if c in word2]) / max(len(word1), len(word2))", "code_tokens": "def basic_word_sim ( word1 , word2 ) : return sum ( [ 1 for c in word1 if c in word2 ] ) / max ( len ( word1 ) , len ( word2 ) )", "docstring_tokens": "Simple measure of similarity : Number of letters in common / max length", "label": 1}, {"idx": "cosqa-train-7939", "doc": "match parenthesis in string using stack python", "code": "def match_paren(self, tokens, item):\n        \"\"\"Matches a paren.\"\"\"\n        match, = tokens\n        return self.match(match, item)", "code_tokens": "def match_paren ( self , tokens , item ) : match , = tokens return self . match ( match , item )", "docstring_tokens": "Matches a paren .", "label": 1}, {"idx": "cosqa-train-7940", "doc": "python write a dict into a file", "code": "def save_dict_to_file(filename, dictionary):\n  \"\"\"Saves dictionary as CSV file.\"\"\"\n  with open(filename, 'w') as f:\n    writer = csv.writer(f)\n    for k, v in iteritems(dictionary):\n      writer.writerow([str(k), str(v)])", "code_tokens": "def save_dict_to_file ( filename , dictionary ) : with open ( filename , 'w' ) as f : writer = csv . writer ( f ) for k , v in iteritems ( dictionary ) : writer . writerow ( [ str ( k ) , str ( v ) ] )", "docstring_tokens": "Saves dictionary as CSV file .", "label": 0}, {"idx": "cosqa-train-7941", "doc": "python write a dictinery to a josn file", "code": "def save_notebook(work_notebook, write_file):\n    \"\"\"Saves the Jupyter work_notebook to write_file\"\"\"\n    with open(write_file, 'w') as out_nb:\n        json.dump(work_notebook, out_nb, indent=2)", "code_tokens": "def save_notebook ( work_notebook , write_file ) : with open ( write_file , 'w' ) as out_nb : json . dump ( work_notebook , out_nb , indent = 2 )", "docstring_tokens": "Saves the Jupyter work_notebook to write_file", "label": 0}, {"idx": "cosqa-train-7942", "doc": "math fuction for area of triangle python", "code": "def get_tri_area(pts):\n    \"\"\"\n    Given a list of coords for 3 points,\n    Compute the area of this triangle.\n\n    Args:\n        pts: [a, b, c] three points\n    \"\"\"\n    a, b, c = pts[0], pts[1], pts[2]\n    v1 = np.array(b) - np.array(a)\n    v2 = np.array(c) - np.array(a)\n    area_tri = abs(sp.linalg.norm(sp.cross(v1, v2)) / 2)\n    return area_tri", "code_tokens": "def get_tri_area ( pts ) : a , b , c = pts [ 0 ] , pts [ 1 ] , pts [ 2 ] v1 = np . array ( b ) - np . array ( a ) v2 = np . array ( c ) - np . array ( a ) area_tri = abs ( sp . linalg . norm ( sp . cross ( v1 , v2 ) ) / 2 ) return area_tri", "docstring_tokens": "Given a list of coords for 3 points Compute the area of this triangle .", "label": 1}, {"idx": "cosqa-train-7943", "doc": "python write a list to a file tab separated", "code": "def write_tsv_line_from_list(linelist, outfp):\n    \"\"\"Utility method to convert list to tsv line with carriage return\"\"\"\n    line = '\\t'.join(linelist)\n    outfp.write(line)\n    outfp.write('\\n')", "code_tokens": "def write_tsv_line_from_list ( linelist , outfp ) : line = '\\t' . join ( linelist ) outfp . write ( line ) outfp . write ( '\\n' )", "docstring_tokens": "Utility method to convert list to tsv line with carriage return", "label": 0}, {"idx": "cosqa-train-7944", "doc": "matrix row vector return python", "code": "def cross_product_matrix(vec):\n    \"\"\"Returns a 3x3 cross-product matrix from a 3-element vector.\"\"\"\n    return np.array([[0, -vec[2], vec[1]],\n                     [vec[2], 0, -vec[0]],\n                     [-vec[1], vec[0], 0]])", "code_tokens": "def cross_product_matrix ( vec ) : return np . array ( [ [ 0 , - vec [ 2 ] , vec [ 1 ] ] , [ vec [ 2 ] , 0 , - vec [ 0 ] ] , [ - vec [ 1 ] , vec [ 0 ] , 0 ] ] )", "docstring_tokens": "Returns a 3x3 cross - product matrix from a 3 - element vector .", "label": 0}, {"idx": "cosqa-train-7945", "doc": "python write data frames to hdf5", "code": "def save_hdf(self,filename,path=''):\n        \"\"\"Saves all relevant data to .h5 file; so state can be restored.\n        \"\"\"\n        self.dataframe.to_hdf(filename,'{}/df'.format(path))", "code_tokens": "def save_hdf ( self , filename , path = '' ) : self . dataframe . to_hdf ( filename , '{}/df' . format ( path ) )", "docstring_tokens": "Saves all relevant data to . h5 file ; so state can be restored .", "label": 1}, {"idx": "cosqa-train-7946", "doc": "python write json to file format", "code": "def _write_json(file, contents):\n    \"\"\"Write a dict to a JSON file.\"\"\"\n    with open(file, 'w') as f:\n        return json.dump(contents, f, indent=2, sort_keys=True)", "code_tokens": "def _write_json ( file , contents ) : with open ( file , 'w' ) as f : return json . dump ( contents , f , indent = 2 , sort_keys = True )", "docstring_tokens": "Write a dict to a JSON file .", "label": 1}, {"idx": "cosqa-train-7947", "doc": "maximum memory usage running python script", "code": "def peak_memory_usage():\n    \"\"\"Return peak memory usage in MB\"\"\"\n    if sys.platform.startswith('win'):\n        p = psutil.Process()\n        return p.memory_info().peak_wset / 1024 / 1024\n\n    mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss\n    factor_mb = 1 / 1024\n    if sys.platform == 'darwin':\n        factor_mb = 1 / (1024 * 1024)\n    return mem * factor_mb", "code_tokens": "def peak_memory_usage ( ) : if sys . platform . startswith ( 'win' ) : p = psutil . Process ( ) return p . memory_info ( ) . peak_wset / 1024 / 1024 mem = resource . getrusage ( resource . RUSAGE_SELF ) . ru_maxrss factor_mb = 1 / 1024 if sys . platform == 'darwin' : factor_mb = 1 / ( 1024 * 1024 ) return mem * factor_mb", "docstring_tokens": "Return peak memory usage in MB", "label": 1}, {"idx": "cosqa-train-7948", "doc": "python write lines on new line next", "code": "def write_line(self, line, count=1):\n        \"\"\"writes the line and count newlines after the line\"\"\"\n        self.write(line)\n        self.write_newlines(count)", "code_tokens": "def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )", "docstring_tokens": "writes the line and count newlines after the line", "label": 1}, {"idx": "cosqa-train-7949", "doc": "md5 string python code", "code": "def md5_string(s):\n    \"\"\"\n    Shortcut to create md5 hash\n    :param s:\n    :return:\n    \"\"\"\n    m = hashlib.md5()\n    m.update(s)\n    return str(m.hexdigest())", "code_tokens": "def md5_string ( s ) : m = hashlib . md5 ( ) m . update ( s ) return str ( m . hexdigest ( ) )", "docstring_tokens": "Shortcut to create md5 hash : param s : : return :", "label": 1}, {"idx": "cosqa-train-7950", "doc": "python write list to tab delimited", "code": "def linedelimited (inlist,delimiter):\n    \"\"\"\nReturns a string composed of elements in inlist, with each element\nseparated by 'delimiter.'  Used by function writedelimited.  Use '\\t'\nfor tab-delimiting.\n\nUsage:   linedelimited (inlist,delimiter)\n\"\"\"\n    outstr = ''\n    for item in inlist:\n        if type(item) != StringType:\n            item = str(item)\n        outstr = outstr + item + delimiter\n    outstr = outstr[0:-1]\n    return outstr", "code_tokens": "def linedelimited ( inlist , delimiter ) : outstr = '' for item in inlist : if type ( item ) != StringType : item = str ( item ) outstr = outstr + item + delimiter outstr = outstr [ 0 : - 1 ] return outstr", "docstring_tokens": "Returns a string composed of elements in inlist with each element separated by delimiter . Used by function writedelimited . Use \\ t for tab - delimiting .", "label": 0}, {"idx": "cosqa-train-7951", "doc": "measure duration of python function call", "code": "def memory_usage(method):\n  \"\"\"Log memory usage before and after a method.\"\"\"\n  def wrapper(*args, **kwargs):\n    logging.info('Memory before method %s is %s.',\n                 method.__name__, runtime.memory_usage().current())\n    result = method(*args, **kwargs)\n    logging.info('Memory after method %s is %s',\n                 method.__name__, runtime.memory_usage().current())\n    return result\n  return wrapper", "code_tokens": "def memory_usage ( method ) : def wrapper ( * args , * * kwargs ) : logging . info ( 'Memory before method %s is %s.' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) result = method ( * args , * * kwargs ) logging . info ( 'Memory after method %s is %s' , method . __name__ , runtime . memory_usage ( ) . current ( ) ) return result return wrapper", "docstring_tokens": "Log memory usage before and after a method .", "label": 1}, {"idx": "cosqa-train-7952", "doc": "python xml element copy", "code": "def copy_of_xml_element(elem):\n    \"\"\"\n    This method returns a shallow copy of a XML-Element.\n    This method is for compatibility with Python 2.6 or earlier..\n    In Python 2.7 you can use  'copyElem = elem.copy()'  instead.\n    \"\"\"\n\n    copyElem = ElementTree.Element(elem.tag, elem.attrib)\n    for child in elem:\n        copyElem.append(child)\n    return copyElem", "code_tokens": "def copy_of_xml_element ( elem ) : copyElem = ElementTree . Element ( elem . tag , elem . attrib ) for child in elem : copyElem . append ( child ) return copyElem", "docstring_tokens": "This method returns a shallow copy of a XML - Element . This method is for compatibility with Python 2 . 6 or earlier .. In Python 2 . 7 you can use copyElem = elem . copy () instead .", "label": 0}, {"idx": "cosqa-train-7953", "doc": "method chaining return self python", "code": "def __ror__(self, other):\n\t\t\"\"\"The main machinery of the Pipe, calling the chosen callable with the recorded arguments.\"\"\"\n\t\t\n\t\treturn self.callable(*(self.args + (other, )), **self.kwargs)", "code_tokens": "def __ror__ ( self , other ) : return self . callable ( * ( self . args + ( other , ) ) , * * self . kwargs )", "docstring_tokens": "The main machinery of the Pipe calling the chosen callable with the recorded arguments .", "label": 0}, {"idx": "cosqa-train-7954", "doc": "python xml get value of tag", "code": "def _get_minidom_tag_value(station, tag_name):\n    \"\"\"get a value from a tag (if it exists)\"\"\"\n    tag = station.getElementsByTagName(tag_name)[0].firstChild\n    if tag:\n        return tag.nodeValue\n\n    return None", "code_tokens": "def _get_minidom_tag_value ( station , tag_name ) : tag = station . getElementsByTagName ( tag_name ) [ 0 ] . firstChild if tag : return tag . nodeValue return None", "docstring_tokens": "get a value from a tag ( if it exists )", "label": 1}, {"idx": "cosqa-train-7955", "doc": "micropython how to flush input buffer", "code": "def _flush(self, buffer):\n        \"\"\"\n        Flush the write buffers of the stream if applicable.\n\n        Args:\n            buffer (memoryview): Buffer content.\n        \"\"\"\n        container, obj = self._client_args\n        with _handle_client_exception():\n            self._client.put_object(container, obj, buffer)", "code_tokens": "def _flush ( self , buffer ) : container , obj = self . _client_args with _handle_client_exception ( ) : self . _client . put_object ( container , obj , buffer )", "docstring_tokens": "Flush the write buffers of the stream if applicable .", "label": 1}, {"idx": "cosqa-train-7956", "doc": "python xmlstring to dict", "code": "def xml_str_to_dict(s):\n    \"\"\" Transforms an XML string it to python-zimbra dict format\n\n    For format, see:\n      https://github.com/Zimbra-Community/python-zimbra/blob/master/README.md\n\n    :param: a string, containing XML\n    :returns: a dict, with python-zimbra format\n    \"\"\"\n    xml = minidom.parseString(s)\n    return pythonzimbra.tools.xmlserializer.dom_to_dict(xml.firstChild)", "code_tokens": "def xml_str_to_dict ( s ) : xml = minidom . parseString ( s ) return pythonzimbra . tools . xmlserializer . dom_to_dict ( xml . firstChild )", "docstring_tokens": "Transforms an XML string it to python - zimbra dict format", "label": 0}, {"idx": "cosqa-train-7957", "doc": "mirror a plot python", "code": "def oplot(self, x, y, **kw):\n        \"\"\"generic plotting method, overplotting any existing plot \"\"\"\n        self.panel.oplot(x, y, **kw)", "code_tokens": "def oplot ( self , x , y , * * kw ) : self . panel . oplot ( x , y , * * kw )", "docstring_tokens": "generic plotting method overplotting any existing plot", "label": 1}, {"idx": "cosqa-train-7958", "doc": "python xsltwriter get row height", "code": "def series_table_row_offset(self, series):\n        \"\"\"\n        Return the number of rows preceding the data table for *series* in\n        the Excel worksheet.\n        \"\"\"\n        title_and_spacer_rows = series.index * 2\n        data_point_rows = series.data_point_offset\n        return title_and_spacer_rows + data_point_rows", "code_tokens": "def series_table_row_offset ( self , series ) : title_and_spacer_rows = series . index * 2 data_point_rows = series . data_point_offset return title_and_spacer_rows + data_point_rows", "docstring_tokens": "Return the number of rows preceding the data table for * series * in the Excel worksheet .", "label": 1}, {"idx": "cosqa-train-7959", "doc": "mnist multi gpu training python tensorflow", "code": "def transformer_tall_pretrain_lm_tpu_adafactor():\n  \"\"\"Hparams for transformer on LM pretraining (with 64k vocab) on TPU.\"\"\"\n  hparams = transformer_tall_pretrain_lm()\n  update_hparams_for_tpu(hparams)\n  hparams.max_length = 1024\n  # For multi-problem on TPU we need it in absolute examples.\n  hparams.batch_size = 8\n  hparams.multiproblem_vocab_size = 2**16\n  return hparams", "code_tokens": "def transformer_tall_pretrain_lm_tpu_adafactor ( ) : hparams = transformer_tall_pretrain_lm ( ) update_hparams_for_tpu ( hparams ) hparams . max_length = 1024 # For multi-problem on TPU we need it in absolute examples. hparams . batch_size = 8 hparams . multiproblem_vocab_size = 2 ** 16 return hparams", "docstring_tokens": "Hparams for transformer on LM pretraining ( with 64k vocab ) on TPU .", "label": 0}, {"idx": "cosqa-train-7960", "doc": "python xy scale of imshow", "code": "def extent(self):\n        \"\"\"Helper for matplotlib imshow\"\"\"\n        return (\n            self.intervals[1].pix1 - 0.5,\n            self.intervals[1].pix2 - 0.5,\n            self.intervals[0].pix1 - 0.5,\n            self.intervals[0].pix2 - 0.5,\n        )", "code_tokens": "def extent ( self ) : return ( self . intervals [ 1 ] . pix1 - 0.5 , self . intervals [ 1 ] . pix2 - 0.5 , self . intervals [ 0 ] . pix1 - 0.5 , self . intervals [ 0 ] . pix2 - 0.5 , )", "docstring_tokens": "Helper for matplotlib imshow", "label": 1}, {"idx": "cosqa-train-7961", "doc": "mock api response in python unit test", "code": "def api_test(method='GET', **response_kwargs):\n    \"\"\" Decorator to ensure API calls are made and return expected data. \"\"\"\n\n    method = method.lower()\n\n    def api_test_factory(fn):\n        @functools.wraps(fn)\n        @mock.patch('requests.{}'.format(method))\n        def execute_test(method_func, *args, **kwargs):\n            method_func.return_value = MockResponse(**response_kwargs)\n\n            expected_url, response = fn(*args, **kwargs)\n\n            method_func.assert_called_once()\n            assert_valid_api_call(method_func, expected_url)\n            assert isinstance(response, JSONAPIParser)\n            assert response.json_data is method_func.return_value.data\n\n        return execute_test\n\n    return api_test_factory", "code_tokens": "def api_test ( method = 'GET' , * * response_kwargs ) : method = method . lower ( ) def api_test_factory ( fn ) : @ functools . wraps ( fn ) @ mock . patch ( 'requests.{}' . format ( method ) ) def execute_test ( method_func , * args , * * kwargs ) : method_func . return_value = MockResponse ( * * response_kwargs ) expected_url , response = fn ( * args , * * kwargs ) method_func . assert_called_once ( ) assert_valid_api_call ( method_func , expected_url ) assert isinstance ( response , JSONAPIParser ) assert response . json_data is method_func . return_value . data return execute_test return api_test_factory", "docstring_tokens": "Decorator to ensure API calls are made and return expected data .", "label": 1}, {"idx": "cosqa-train-7962", "doc": "python y axis percentage", "code": "def vertical_percent(plot, percent=0.1):\n    \"\"\"\n    Using the size of the y axis, return a fraction of that size.\n    \"\"\"\n    plot_bottom, plot_top = plot.get_ylim()\n    return percent * (plot_top - plot_bottom)", "code_tokens": "def vertical_percent ( plot , percent = 0.1 ) : plot_bottom , plot_top = plot . get_ylim ( ) return percent * ( plot_top - plot_bottom )", "docstring_tokens": "Using the size of the y axis return a fraction of that size .", "label": 1}, {"idx": "cosqa-train-7963", "doc": "mongodb list all collections in database python", "code": "def all_collections(db):\n\t\"\"\"\n\tYield all non-sytem collections in db.\n\t\"\"\"\n\tinclude_pattern = r'(?!system\\.)'\n\treturn (\n\t\tdb[name]\n\t\tfor name in db.list_collection_names()\n\t\tif re.match(include_pattern, name)\n\t)", "code_tokens": "def all_collections ( db ) : include_pattern = r'(?!system\\.)' return ( db [ name ] for name in db . list_collection_names ( ) if re . match ( include_pattern , name ) )", "docstring_tokens": "Yield all non - sytem collections in db .", "label": 0}, {"idx": "cosqa-train-7964", "doc": "python yaml config file parser", "code": "def _ParseYamlFromFile(filedesc):\n  \"\"\"Parses given YAML file.\"\"\"\n  content = filedesc.read()\n  return yaml.Parse(content) or collections.OrderedDict()", "code_tokens": "def _ParseYamlFromFile ( filedesc ) : content = filedesc . read ( ) return yaml . Parse ( content ) or collections . OrderedDict ( )", "docstring_tokens": "Parses given YAML file .", "label": 0}, {"idx": "cosqa-train-7965", "doc": "multi axis slicing python", "code": "def get_axis(array, axis, slice_num):\n    \"\"\"Returns a fixed axis\"\"\"\n\n    slice_list = [slice(None)] * array.ndim\n    slice_list[axis] = slice_num\n    slice_data = array[tuple(slice_list)].T  # transpose for proper orientation\n\n    return slice_data", "code_tokens": "def get_axis ( array , axis , slice_num ) : slice_list = [ slice ( None ) ] * array . ndim slice_list [ axis ] = slice_num slice_data = array [ tuple ( slice_list ) ] . T # transpose for proper orientation return slice_data", "docstring_tokens": "Returns a fixed axis", "label": 0}, {"idx": "cosqa-train-7966", "doc": "python yaml dump curly bracket", "code": "def print_yaml(o):\n    \"\"\"Pretty print an object as YAML.\"\"\"\n    print(yaml.dump(o, default_flow_style=False, indent=4, encoding='utf-8'))", "code_tokens": "def print_yaml ( o ) : print ( yaml . dump ( o , default_flow_style = False , indent = 4 , encoding = 'utf-8' ) )", "docstring_tokens": "Pretty print an object as YAML .", "label": 0}, {"idx": "cosqa-train-7967", "doc": "multiline text send message python", "code": "async def _send_plain_text(self, request: Request, stack: Stack):\n        \"\"\"\n        Sends plain text using `_send_text()`.\n        \"\"\"\n\n        await self._send_text(request, stack, None)", "code_tokens": "async def _send_plain_text ( self , request : Request , stack : Stack ) : await self . _send_text ( request , stack , None )", "docstring_tokens": "Sends plain text using _send_text () .", "label": 1}, {"idx": "cosqa-train-7968", "doc": "python yaml to object", "code": "def yaml_to_param(obj, name):\n\t\"\"\"\n\tReturn the top-level element of a document sub-tree containing the\n\tYAML serialization of a Python object.\n\t\"\"\"\n\treturn from_pyvalue(u\"yaml:%s\" % name, unicode(yaml.dump(obj)))", "code_tokens": "def yaml_to_param ( obj , name ) : return from_pyvalue ( u\"yaml:%s\" % name , unicode ( yaml . dump ( obj ) ) )", "docstring_tokens": "Return the top - level element of a document sub - tree containing the YAML serialization of a Python object .", "label": 1}, {"idx": "cosqa-train-7969", "doc": "multiple comments in python shortcut", "code": "def comments(tag, limit=0, flags=0, **kwargs):\n    \"\"\"Get comments only.\"\"\"\n\n    return [comment for comment in cm.CommentsMatch(tag).get_comments(limit)]", "code_tokens": "def comments ( tag , limit = 0 , flags = 0 , * * kwargs ) : return [ comment for comment in cm . CommentsMatch ( tag ) . get_comments ( limit ) ]", "docstring_tokens": "Get comments only .", "label": 1}, {"idx": "cosqa-train-7970", "doc": "python zip everything in the current folder", "code": "def extract_zip(zip_path, target_folder):\n    \"\"\"\n    Extract the content of the zip-file at `zip_path` into `target_folder`.\n    \"\"\"\n    with zipfile.ZipFile(zip_path) as archive:\n        archive.extractall(target_folder)", "code_tokens": "def extract_zip ( zip_path , target_folder ) : with zipfile . ZipFile ( zip_path ) as archive : archive . extractall ( target_folder )", "docstring_tokens": "Extract the content of the zip - file at zip_path into target_folder .", "label": 0}, {"idx": "cosqa-train-7971", "doc": "multiple context managers in one line python3", "code": "def replace_sys_args(new_args):\n    \"\"\"Temporarily replace sys.argv with current arguments\n\n    Restores sys.argv upon exit of the context manager.\n    \"\"\"\n    # Replace sys.argv arguments\n    # for module import\n    old_args = sys.argv\n    sys.argv = new_args\n    try:\n        yield\n    finally:\n        sys.argv = old_args", "code_tokens": "def replace_sys_args ( new_args ) : # Replace sys.argv arguments # for module import old_args = sys . argv sys . argv = new_args try : yield finally : sys . argv = old_args", "docstring_tokens": "Temporarily replace sys . argv with current arguments", "label": 0}, {"idx": "cosqa-train-7972", "doc": "python zipfile extractall overwrite", "code": "def extract(self, destination):\n        \"\"\"Extract the archive.\"\"\"\n        with zipfile.ZipFile(self.archive, 'r') as zip_ref:\n            zip_ref.extractall(destination)", "code_tokens": "def extract ( self , destination ) : with zipfile . ZipFile ( self . archive , 'r' ) as zip_ref : zip_ref . extractall ( destination )", "docstring_tokens": "Extract the archive .", "label": 1}, {"idx": "cosqa-train-7973", "doc": "mutating dictionaries using recursion python", "code": "def map_keys_deep(f, dct):\n    \"\"\"\n    Implementation of map that recurses. This tests the same keys at every level of dict and in lists\n    :param f: 2-ary function expecting a key and value and returns a modified key\n    :param dct: Dict for deep processing\n    :return: Modified dct with matching props mapped\n    \"\"\"\n    return _map_deep(lambda k, v: [f(k, v), v], dct)", "code_tokens": "def map_keys_deep ( f , dct ) : return _map_deep ( lambda k , v : [ f ( k , v ) , v ] , dct )", "docstring_tokens": "Implementation of map that recurses . This tests the same keys at every level of dict and in lists : param f : 2 - ary function expecting a key and value and returns a modified key : param dct : Dict for deep processing : return : Modified dct with matching props mapped", "label": 0}, {"idx": "cosqa-train-7974", "doc": "python zlib compress content to file", "code": "def compressBuffer(buffer):\n    \"\"\"\n    Note that this code compresses into a buffer held in memory, rather\n    than a disk file. This is done through the use of cStringIO.StringIO().\n    \"\"\"\n    # http://jython.xhaus.com/http-compression-in-python-and-jython/\n    zbuf = cStringIO.StringIO()\n    zfile = gzip.GzipFile(mode='wb', fileobj=zbuf, compresslevel=9)\n    zfile.write(buffer)\n    zfile.close()\n    return zbuf.getvalue()", "code_tokens": "def compressBuffer ( buffer ) : # http://jython.xhaus.com/http-compression-in-python-and-jython/ zbuf = cStringIO . StringIO ( ) zfile = gzip . GzipFile ( mode = 'wb' , fileobj = zbuf , compresslevel = 9 ) zfile . write ( buffer ) zfile . close ( ) return zbuf . getvalue ( )", "docstring_tokens": "Note that this code compresses into a buffer held in memory rather than a disk file . This is done through the use of cStringIO . StringIO () .", "label": 1}, {"idx": "cosqa-train-7975", "doc": "my cursor in python has become white", "code": "def step_next_line(self):\n        \"\"\"Sets cursor as beginning of next line.\"\"\"\n        self._eol.append(self.position)\n        self._lineno += 1\n        self._col_offset = 0", "code_tokens": "def step_next_line ( self ) : self . _eol . append ( self . position ) self . _lineno += 1 self . _col_offset = 0", "docstring_tokens": "Sets cursor as beginning of next line .", "label": 1}, {"idx": "cosqa-train-7976", "doc": "python zlib stream decompress", "code": "def __init__(self, stream_start):\n    \"\"\"Initializes a gzip member decompressor wrapper.\n\n    Args:\n      stream_start (int): offset to the compressed stream within the containing\n          file object.\n    \"\"\"\n    self._decompressor = zlib_decompressor.DeflateDecompressor()\n    self.last_read = stream_start\n    self.uncompressed_offset = 0\n    self._compressed_data = b''", "code_tokens": "def __init__ ( self , stream_start ) : self . _decompressor = zlib_decompressor . DeflateDecompressor ( ) self . last_read = stream_start self . uncompressed_offset = 0 self . _compressed_data = b''", "docstring_tokens": "Initializes a gzip member decompressor wrapper .", "label": 0}, {"idx": "cosqa-train-7977", "doc": "mysqldb python bulk remote", "code": "def bulk_query(self, query, *multiparams):\n        \"\"\"Bulk insert or update.\"\"\"\n\n        with self.get_connection() as conn:\n            conn.bulk_query(query, *multiparams)", "code_tokens": "def bulk_query ( self , query , * multiparams ) : with self . get_connection ( ) as conn : conn . bulk_query ( query , * multiparams )", "docstring_tokens": "Bulk insert or update .", "label": 0}, {"idx": "cosqa-train-7978", "doc": "python, calc average date in datetime column", "code": "def mean_date(dt_list):\n    \"\"\"Calcuate mean datetime from datetime list\n    \"\"\"\n    dt_list_sort = sorted(dt_list)\n    dt_list_sort_rel = [dt - dt_list_sort[0] for dt in dt_list_sort]\n    avg_timedelta = sum(dt_list_sort_rel, timedelta())/len(dt_list_sort_rel)\n    return dt_list_sort[0] + avg_timedelta", "code_tokens": "def mean_date ( dt_list ) : dt_list_sort = sorted ( dt_list ) dt_list_sort_rel = [ dt - dt_list_sort [ 0 ] for dt in dt_list_sort ] avg_timedelta = sum ( dt_list_sort_rel , timedelta ( ) ) / len ( dt_list_sort_rel ) return dt_list_sort [ 0 ] + avg_timedelta", "docstring_tokens": "Calcuate mean datetime from datetime list", "label": 1}, {"idx": "cosqa-train-7979", "doc": "nest string list to list python", "code": "def flatten_list(l):\n    \"\"\" Nested lists to single-level list, does not split strings\"\"\"\n    return list(chain.from_iterable(repeat(x,1) if isinstance(x,str) else x for x in l))", "code_tokens": "def flatten_list ( l ) : return list ( chain . from_iterable ( repeat ( x , 1 ) if isinstance ( x , str ) else x for x in l ) )", "docstring_tokens": "Nested lists to single - level list does not split strings", "label": 0}, {"idx": "cosqa-train-7980", "doc": "python, don't allow a variable to be changed", "code": "def changed(self, *value):\n        \"\"\"Checks whether the value has changed since the last call.\"\"\"\n        if self._last_checked_value != value:\n            self._last_checked_value = value\n            return True\n        return False", "code_tokens": "def changed ( self , * value ) : if self . _last_checked_value != value : self . _last_checked_value = value return True return False", "docstring_tokens": "Checks whether the value has changed since the last call .", "label": 0}, {"idx": "cosqa-train-7981", "doc": "networkx digraph python print", "code": "def to_dotfile(G: nx.DiGraph, filename: str):\n    \"\"\" Output a networkx graph to a DOT file. \"\"\"\n    A = to_agraph(G)\n    A.write(filename)", "code_tokens": "def to_dotfile ( G : nx . DiGraph , filename : str ) : A = to_agraph ( G ) A . write ( filename )", "docstring_tokens": "Output a networkx graph to a DOT file .", "label": 0}, {"idx": "cosqa-train-7982", "doc": "python, how to iterate through a folder of files", "code": "def get_all_files(folder):\n    \"\"\"\n    Generator that loops through all absolute paths of the files within folder\n\n    Parameters\n    ----------\n    folder: str\n    Root folder start point for recursive search.\n\n    Yields\n    ------\n    fpath: str\n    Absolute path of one file in the folders\n    \"\"\"\n    for path, dirlist, filelist in os.walk(folder):\n        for fn in filelist:\n            yield op.join(path, fn)", "code_tokens": "def get_all_files ( folder ) : for path , dirlist , filelist in os . walk ( folder ) : for fn in filelist : yield op . join ( path , fn )", "docstring_tokens": "Generator that loops through all absolute paths of the files within folder", "label": 0}, {"idx": "cosqa-train-7983", "doc": "new line column header python", "code": "def draw_header(self, stream, header):\n        \"\"\"Draw header with underline\"\"\"\n        stream.writeln('=' * (len(header) + 4))\n        stream.writeln('| ' + header + ' |')\n        stream.writeln('=' * (len(header) + 4))\n        stream.writeln()", "code_tokens": "def draw_header ( self , stream , header ) : stream . writeln ( '=' * ( len ( header ) + 4 ) ) stream . writeln ( '| ' + header + ' |' ) stream . writeln ( '=' * ( len ( header ) + 4 ) ) stream . writeln ( )", "docstring_tokens": "Draw header with underline", "label": 1}, {"idx": "cosqa-train-7984", "doc": "new line statemnt pythong write", "code": "def write_line(self, line, count=1):\n        \"\"\"writes the line and count newlines after the line\"\"\"\n        self.write(line)\n        self.write_newlines(count)", "code_tokens": "def write_line ( self , line , count = 1 ) : self . write ( line ) self . write_newlines ( count )", "docstring_tokens": "writes the line and count newlines after the line", "label": 1}, {"idx": "cosqa-train-7985", "doc": "python2 parse query string", "code": "def urlencoded(body, charset='ascii', **kwargs):\n    \"\"\"Converts query strings into native Python objects\"\"\"\n    return parse_query_string(text(body, charset=charset), False)", "code_tokens": "def urlencoded ( body , charset = 'ascii' , * * kwargs ) : return parse_query_string ( text ( body , charset = charset ) , False )", "docstring_tokens": "Converts query strings into native Python objects", "label": 1}, {"idx": "cosqa-train-7986", "doc": "python2 psutil get process memory", "code": "def current_memory_usage():\n    \"\"\"\n    Returns this programs current memory usage in bytes\n    \"\"\"\n    import psutil\n    proc = psutil.Process(os.getpid())\n    #meminfo = proc.get_memory_info()\n    meminfo = proc.memory_info()\n    rss = meminfo[0]  # Resident Set Size / Mem Usage\n    vms = meminfo[1]  # Virtual Memory Size / VM Size  # NOQA\n    return rss", "code_tokens": "def current_memory_usage ( ) : import psutil proc = psutil . Process ( os . getpid ( ) ) #meminfo = proc.get_memory_info() meminfo = proc . memory_info ( ) rss = meminfo [ 0 ] # Resident Set Size / Mem Usage vms = meminfo [ 1 ] # Virtual Memory Size / VM Size  # NOQA return rss", "docstring_tokens": "Returns this programs current memory usage in bytes", "label": 1}, {"idx": "cosqa-train-7987", "doc": "no of levels of categorical variable in python", "code": "def nlevels(self):\n        \"\"\"\n        Get the number of factor levels for each categorical column.\n\n        :returns: A list of the number of levels per column.\n        \"\"\"\n        levels = self.levels()\n        return [len(l) for l in levels] if levels else 0", "code_tokens": "def nlevels ( self ) : levels = self . levels ( ) return [ len ( l ) for l in levels ] if levels else 0", "docstring_tokens": "Get the number of factor levels for each categorical column .", "label": 1}, {"idx": "cosqa-train-7988", "doc": "python3 cast to string", "code": "def to_str(s):\n    \"\"\"\n    Convert bytes and non-string into Python 3 str\n    \"\"\"\n    if isinstance(s, bytes):\n        s = s.decode('utf-8')\n    elif not isinstance(s, str):\n        s = str(s)\n    return s", "code_tokens": "def to_str ( s ) : if isinstance ( s , bytes ) : s = s . decode ( 'utf-8' ) elif not isinstance ( s , str ) : s = str ( s ) return s", "docstring_tokens": "Convert bytes and non - string into Python 3 str", "label": 1}, {"idx": "cosqa-train-7989", "doc": "non duplicate list in list python", "code": "def unique(list):\n    \"\"\" Returns a copy of the list without duplicates.\n    \"\"\"\n    unique = []; [unique.append(x) for x in list if x not in unique]\n    return unique", "code_tokens": "def unique ( list ) : unique = [ ] [ unique . append ( x ) for x in list if x not in unique ] return unique", "docstring_tokens": "Returns a copy of the list without duplicates .", "label": 1}, {"idx": "cosqa-train-7990", "doc": "python3 check whether is string", "code": "def is_string(obj):\n    \"\"\"Is this a string.\n\n    :param object obj:\n    :rtype: bool\n    \"\"\"\n    if PYTHON3:\n        str_type = (bytes, str)\n    else:\n        str_type = (bytes, str, unicode)\n    return isinstance(obj, str_type)", "code_tokens": "def is_string ( obj ) : if PYTHON3 : str_type = ( bytes , str ) else : str_type = ( bytes , str , unicode ) return isinstance ( obj , str_type )", "docstring_tokens": "Is this a string .", "label": 1}, {"idx": "cosqa-train-7991", "doc": "normalize 1 d array in python", "code": "def _normalize_abmn(abmn):\n    \"\"\"return a normalized version of abmn\n    \"\"\"\n    abmn_2d = np.atleast_2d(abmn)\n    abmn_normalized = np.hstack((\n        np.sort(abmn_2d[:, 0:2], axis=1),\n        np.sort(abmn_2d[:, 2:4], axis=1),\n    ))\n    return abmn_normalized", "code_tokens": "def _normalize_abmn ( abmn ) : abmn_2d = np . atleast_2d ( abmn ) abmn_normalized = np . hstack ( ( np . sort ( abmn_2d [ : , 0 : 2 ] , axis = 1 ) , np . sort ( abmn_2d [ : , 2 : 4 ] , axis = 1 ) , ) ) return abmn_normalized", "docstring_tokens": "return a normalized version of abmn", "label": 0}, {"idx": "cosqa-train-7992", "doc": "python3 checking if line is a comment", "code": "def _get_line_no_from_comments(py_line):\n    \"\"\"Return the line number parsed from the comment or 0.\"\"\"\n    matched = LINECOL_COMMENT_RE.match(py_line)\n    if matched:\n        return int(matched.group(1))\n    else:\n        return 0", "code_tokens": "def _get_line_no_from_comments ( py_line ) : matched = LINECOL_COMMENT_RE . match ( py_line ) if matched : return int ( matched . group ( 1 ) ) else : return 0", "docstring_tokens": "Return the line number parsed from the comment or 0 .", "label": 1}, {"idx": "cosqa-train-7993", "doc": "normalize 2d array python", "code": "def denorm(self,arr):\n        \"\"\"Reverse the normalization done to a batch of images.\n\n        Arguments:\n            arr: of shape/size (N,3,sz,sz)\n        \"\"\"\n        if type(arr) is not np.ndarray: arr = to_np(arr)\n        if len(arr.shape)==3: arr = arr[None]\n        return self.transform.denorm(np.rollaxis(arr,1,4))", "code_tokens": "def denorm ( self , arr ) : if type ( arr ) is not np . ndarray : arr = to_np ( arr ) if len ( arr . shape ) == 3 : arr = arr [ None ] return self . transform . denorm ( np . rollaxis ( arr , 1 , 4 ) )", "docstring_tokens": "Reverse the normalization done to a batch of images .", "label": 1}, {"idx": "cosqa-train-7994", "doc": "python3 date to string", "code": "def QA_util_datetime_to_strdate(dt):\n    \"\"\"\n    :param dt:  pythone datetime.datetime\n    :return:  1999-02-01 string type\n    \"\"\"\n    strdate = \"%04d-%02d-%02d\" % (dt.year, dt.month, dt.day)\n    return strdate", "code_tokens": "def QA_util_datetime_to_strdate ( dt ) : strdate = \"%04d-%02d-%02d\" % ( dt . year , dt . month , dt . day ) return strdate", "docstring_tokens": ": param dt : pythone datetime . datetime : return : 1999 - 02 - 01 string type", "label": 0}, {"idx": "cosqa-train-7995", "doc": "normalize data in python into 0 to 1 range", "code": "def _normalize(mat: np.ndarray):\n    \"\"\"rescales a numpy array, so that min is 0 and max is 255\"\"\"\n    return ((mat - mat.min()) * (255 / mat.max())).astype(np.uint8)", "code_tokens": "def _normalize ( mat : np . ndarray ) : return ( ( mat - mat . min ( ) ) * ( 255 / mat . max ( ) ) ) . astype ( np . uint8 )", "docstring_tokens": "rescales a numpy array so that min is 0 and max is 255", "label": 0}, {"idx": "cosqa-train-7996", "doc": "python3 datetime second to minute", "code": "def datetime_to_ms(dt):\n    \"\"\"\n    Converts a datetime to a millisecond accuracy timestamp\n    \"\"\"\n    seconds = calendar.timegm(dt.utctimetuple())\n    return seconds * 1000 + int(dt.microsecond / 1000)", "code_tokens": "def datetime_to_ms ( dt ) : seconds = calendar . timegm ( dt . utctimetuple ( ) ) return seconds * 1000 + int ( dt . microsecond / 1000 )", "docstring_tokens": "Converts a datetime to a millisecond accuracy timestamp", "label": 0}, {"idx": "cosqa-train-7997", "doc": "normalize image color python", "code": "def normalize(im, invert=False, scale=None, dtype=np.float64):\n    \"\"\"\n    Normalize a field to a (min, max) exposure range, default is (0, 255).\n    (min, max) exposure values. Invert the image if requested.\n    \"\"\"\n    if dtype not in {np.float16, np.float32, np.float64}:\n        raise ValueError('dtype must be numpy.float16, float32, or float64.')\n    out = im.astype('float').copy()\n\n    scale = scale or (0.0, 255.0)\n    l, u = (float(i) for i in scale)\n    out = (out - l) / (u - l)\n    if invert:\n        out = -out + (out.max() + out.min())\n    return out.astype(dtype)", "code_tokens": "def normalize ( im , invert = False , scale = None , dtype = np . float64 ) : if dtype not in { np . float16 , np . float32 , np . float64 } : raise ValueError ( 'dtype must be numpy.float16, float32, or float64.' ) out = im . astype ( 'float' ) . copy ( ) scale = scale or ( 0.0 , 255.0 ) l , u = ( float ( i ) for i in scale ) out = ( out - l ) / ( u - l ) if invert : out = - out + ( out . max ( ) + out . min ( ) ) return out . astype ( dtype )", "docstring_tokens": "Normalize a field to a ( min max ) exposure range default is ( 0 255 ) . ( min max ) exposure values . Invert the image if requested .", "label": 0}, {"idx": "cosqa-train-7998", "doc": "python3 encode decode bytes", "code": "def to_bytes(value):\n    \"\"\" str to bytes (py3k) \"\"\"\n    vtype = type(value)\n\n    if vtype == bytes or vtype == type(None):\n        return value\n\n    try:\n        return vtype.encode(value)\n    except UnicodeEncodeError:\n        pass\n    return value", "code_tokens": "def to_bytes ( value ) : vtype = type ( value ) if vtype == bytes or vtype == type ( None ) : return value try : return vtype . encode ( value ) except UnicodeEncodeError : pass return value", "docstring_tokens": "str to bytes ( py3k )", "label": 1}, {"idx": "cosqa-train-7999", "doc": "number of bins in a histogram python", "code": "def _histplot_bins(column, bins=100):\n    \"\"\"Helper to get bins for histplot.\"\"\"\n    col_min = np.min(column)\n    col_max = np.max(column)\n    return range(col_min, col_max + 2, max((col_max - col_min) // bins, 1))", "code_tokens": "def _histplot_bins ( column , bins = 100 ) : col_min = np . min ( column ) col_max = np . max ( column ) return range ( col_min , col_max + 2 , max ( ( col_max - col_min ) // bins , 1 ) )", "docstring_tokens": "Helper to get bins for histplot .", "label": 0}]